{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assume StringUtils is imported, e.g., from org.apache.commons.lang3\n// Assume helper methods like isAllZeros, isDigits, parseBigIntegerMaybeOctal are available if needed by the rest of the logic.\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer, Long, or BigInteger depending on the magnitude of the value.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n    * <code>BigDecimal</code>.</p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigInteger as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) { // Assuming StringUtils.isBlank is available from commons-lang3\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Handle hexadecimal numbers\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        boolean negative = false;\n        for (final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length();\n                if (pfx.startsWith(\"-\")) {\n                    negative = true;\n                }\n                break;\n            }\n        }\n\n        if (pfxLen > 0) { // It's a hexadecimal number\n            String numberPart = str.substring(pfxLen);\n            if (numberPart.isEmpty()) {\n                // Handle cases like \"0x\", \"-#\", etc.\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            // Use BigInteger to parse the hexadecimal part to handle magnitude correctly\n            try {\n                BigInteger val = new BigInteger(numberPart, 16);\n                if (negative) {\n                    val = val.negate();\n                }\n                // Determine the smallest Java Number type that can hold the value\n                if (val.bitLength() <= 31) { // Fits in Integer range (-2^31 to 2^31-1)\n                    return Integer.valueOf(val.intValue());\n                }\n                if (val.bitLength() <= 63) { // Fits in Long range (-2^63 to 2^63-1)\n                    return Long.valueOf(val.longValue());\n                }\n                // Value is too large for Long, return as BigInteger\n                return val;\n            } catch (NumberFormatException e) {\n                // If BigInteger parsing fails (e.g., invalid hex digits)\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n        // Handle non-hexadecimal numbers (decimal, octal, floating point)\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e'); // Find exponent marker 'e' or 'E'\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        // Split the string into mantissa, decimal, and exponent parts\n        int numDecimals = 0;\n        if (decPos > -1) { // Contains a decimal point\n            if (expPos > -1) { // Contains an exponent\n                if (expPos < decPos || expPos >= str.length()) { // Validate exponent position\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length();\n        } else { // No decimal point\n            if (expPos > -1) { // Contains an exponent\n                 if (expPos >= str.length()) { // Validate exponent position\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null; // No decimal part\n        }\n\n        // Check for type qualifiers (f, F, d, D, l, L) at the end\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            final String numeric = str.substring(0, str.length() - 1); // String without qualifier\n            // Assuming isAllZeros helper is available and correctly implemented\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp);\n\n            switch (lastChar) {\n                case 'l':\n                case 'L': // Long specified\n                    // Input must be an integer (no decimal point or exponent)\n                    if (dec != null || expPos > -1 || (numeric.isEmpty() || numeric.equals(\"+\") || numeric.equals(\"-\"))) {\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                    try {\n                        // Use Long.valueOf, fallback to BigInteger for large values\n                        return Long.valueOf(numeric);\n                    } catch (final NumberFormatException nfe) {\n                        // NOPMD - Only catch NFE\n                        return new BigInteger(numeric);\n                    }\n                case 'f':\n                case 'F': // Float specified\n                    try {\n                        final Float f = Float.valueOf(numeric);\n                        // Check for infinity or zero result when input was non-zero\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    // Fall through to Double/BigDecimal might be intended by original code structure ($FALL-THROUGH$)\n                    // but is questionable for explicit 'f'. Retaining fall-through to match original behavior.\n                    //$FALL-THROUGH$\n                case 'd':\n                case 'D': // Double specified\n                    try {\n                        final Double d = Double.valueOf(numeric);\n                        // Check for infinity or zero result when input was non-zero\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number\n                    }\n                    try {\n                        // Fallback to BigDecimal if Double fails or is infinite/zero\n                        return new BigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // ignore the bad number\n                    }\n                    //$FALL-THROUGH$\n                default: // Invalid qualifier\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            // No type qualifier: Infer type\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1);\n            } else {\n                 // Exponent marker cannot be the last character\n                 if (expPos > -1 && expPos >= str.length() -1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                exp = null;\n            }\n\n            if (dec == null && expPos == -1) { // Integral number candidate (no decimal, no exponent)\n                // Try Integer -> Long -> BigInteger (handling octal with decode/helper)\n                try { return Integer.decode(str); } catch (final NumberFormatException nfe1) { /* Ignore */ }\n                try { return Long.decode(str); } catch (final NumberFormatException nfe2) { /* Ignore */ }\n                // Assuming parseBigIntegerMaybeOctal helper is available for BigInteger with octal check\n                return parseBigIntegerMaybeOctal(str);\n            } else { // Floating point number candidate (has decimal or exponent)\n                // Assuming isAllZeros helper is available and correctly implemented\n                final boolean allZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp);\n                // Try Float -> Double -> BigDecimal\n                try {\n                    final Float f = Float.valueOf(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe1) { /* Ignore */ }\n                try {\n                    final Double d = Double.valueOf(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe2) { /* Ignore */ }\n                try {\n                    return new BigDecimal(str);\n                } catch (final NumberFormatException nfe3) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            }\n        }\n    }\n\n    // --- Helper methods assumed to exist (implement or import as needed) ---\n\n    /** Placeholder: Checks if a string consists only of '0' characters. Null/empty might be true depending on context. */\n    private static boolean isAllZeros(String s) {\n       if (s == null || s.isEmpty()) return true;\n       for (char c : s.toCharArray()) {\n           if (c != '0') return false;\n       }\n       return true;\n    }\n\n    /** Placeholder: Parses a String potentially representing an octal number into a BigInteger. */\n    private static BigInteger parseBigIntegerMaybeOctal(final String str) throws NumberFormatException {\n        boolean negative = str.startsWith(\"-\");\n        int startIndex = negative ? 1 : 0;\n        // Check for octal prefix (0 followed by 0-7 digits)\n        if (str.startsWith(\"0\", startIndex) && str.length() > startIndex + 1) {\n            String octalPart = str.substring(startIndex + 1);\n            // Validate all following chars are octal digits\n            boolean isOctal = true;\n            for (char c : octalPart.toCharArray()) {\n                if (c < '0' || c > '7') {\n                    isOctal = false;\n                    break;\n                }\n            }\n            if (isOctal) {\n                 try {\n                      BigInteger val = new BigInteger(octalPart, 8);\n                      return negative ? val.negate() : val;\n                 } catch (NumberFormatException nfe) {\n                      // Should not happen if validation passes, but handle defensively\n                       throw new NumberFormatException(str + \" is not a valid octal number.\");\n                 }\n            }\n        }\n        // If not valid octal, parse as decimal BigInteger\n        try {\n            return new BigInteger(str);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}