{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport org.apache.commons.lang3.StringUtils;\n\n// Assume NumberUtils class context and helpers like createFloat, createDouble, createBigDecimal, isAllZeros, isDigits exist\n// Assume createInteger, createLong, createBigInteger can handle respective standard Java number formats including octal/hex prefixes (like decode methods)\n// The following code block contains only the fixed createNumber method.\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal number. The type will be chosen based on the smallest primitive type\n     * (Integer, Long) or BigInteger that can hold the value specified by the hexadecimal representation.</p>\n     *\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigInteger as appropriate, determined by the smallest type that fits.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Handle hex numbers explicitly first due to sign/magnitude ambiguity with decode methods\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        boolean negativeHex = false;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length();\n                negativeHex = pfx.startsWith(\"-\"); // Record if the prefix included a '-'\n                break;\n            }\n        }\n        if (pfxLen > 0) { // We have a hex number\n            // Extract the part after the prefix\n            String numberPart = str.substring(pfxLen);\n            if (numberPart.isEmpty()) {\n                 throw new NumberFormatException(\"Hexadecimal number must have digits after prefix: \" + str);\n             }\n\n            BigInteger bigIntValue;\n            try {\n                 // Use BigInteger to parse the hexadecimal digits. Handles arbitrary size.\n                 // Constructor requires only hex digits (no sign).\n                 bigIntValue = new BigInteger(numberPart, 16);\n            } catch (final NumberFormatException e) {\n                 // Rethrow if the number part is not valid hex, providing the original string\n                 final NumberFormatException nfe = new NumberFormatException(\"Illegal hexadecimal digit(s) in: \" + str);\n                 nfe.initCause(e); // Preserve original cause\n                 throw nfe;\n            }\n\n            // Apply the sign based on the prefix found\n            if (negativeHex) {\n                bigIntValue = bigIntValue.negate();\n            }\n\n            // Determine the smallest type (Integer, Long, BigInteger) that fits the value\n            // Using BigInteger constants for range comparison for clarity and robustness\n            final BigInteger MIN_INTEGER = BigInteger.valueOf(Integer.MIN_VALUE);\n            final BigInteger MAX_INTEGER = BigInteger.valueOf(Integer.MAX_VALUE);\n            final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n            final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\n            if (bigIntValue.compareTo(MAX_INTEGER) <= 0 &&\n                bigIntValue.compareTo(MIN_INTEGER) >= 0) {\n                 return Integer.valueOf(bigIntValue.intValue()); // Fits in Integer\n            }\n            if (bigIntValue.compareTo(MAX_LONG) <= 0 &&\n                bigIntValue.compareTo(MIN_LONG) >= 0) {\n                 return Long.valueOf(bigIntValue.longValue()); // Fits in Long\n            }\n            // Value is too large for Long, return as BigInteger\n            return bigIntValue;\n        }\n\n        // ---- Non-hex numbers ----\n\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant; // Mantissa part\n        String dec;  // Decimal part\n        // Correct calculation of expPos: find first 'e' or 'E'\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        int numDecimals = 0; // Number of digits after decimal point\n        final int decPos = str.indexOf('.'); // Find decimal point position\n\n        if (decPos > -1) { // Contains a decimal point\n            if (expPos > -1) { // Contains an exponent\n                if (expPos < decPos || expPos >= str.length()) { // Validate exponent position\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length();\n        } else { // No decimal point\n            if (expPos > -1) { // Contains an exponent\n                if (expPos == 0 || expPos >= str.length()) { // Validate exponent position\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str; // Full string is mantissa\n            }\n            dec = null; // No decimal part\n        }\n\n        if (!Character.isDigit(lastChar) && lastChar != '.') { // Ends with a type specifier or invalid char\n             String numeric = str.substring(0, str.length() - 1); // Numeric part without suffix\n             // Determine exponent string for allZeros check\n             String expStr = null;\n             if (expPos > -1 && expPos < numeric.length()) { // Check against numeric length\n                  expStr = numeric.substring(expPos + 1);\n             }\n             // Determine mantissa string for allZeros check\n             String mantStr = numeric;\n             final int mantDecPos = numeric.indexOf('.');\n             if(mantDecPos > -1) {\n                  mantStr = numeric.substring(0, mantDecPos);\n             } else if (expPos > -1 && expPos < numeric.length()) {\n                  mantStr = numeric.substring(0, expPos);\n             }\n             // Check if the significant parts (mantissa before decimal/exponent, exponent digits) are all zeros.\n             // isAllZeros should handle null inputs safely (treat as true or zero).\n             final boolean allZeros = isAllZeros(mantStr) && isAllZeros(expStr); // Assumes isAllZeros helper exists\n\n            switch (lastChar) {\n                case 'l' : case 'L' :\n                     // Check if numeric part is valid integer format (no decimal, no exponent)\n                     if (dec == null && expPos == -1 &&\n                         (!numeric.isEmpty() && // Cannot be empty, e.g. \"L\"\n                         (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric)))) { // Assumes isDigits helper exists\n                        try {\n                             return createLong(numeric); // Assumes createLong handles standard integer format\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // If Long parsing fails (e.g., overflow), fall back to BigInteger\n                            return createBigInteger(numeric); // Assumes createBigInteger handles standard integer format\n                        }\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n                case 'f' : case 'F' :\n                    try {\n                        final Float f = createFloat(numeric); // Assumes createFloat handles float format\n                        // Check for infinity or zero result when original wasn't zero (indicates precision/range issues)\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                        // If Float has issues, fall through to Double/BigDecimal for better precision/range\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Fall through\n                    }\n                    // $FALL-THROUGH$ Intentional fallthrough\n\n                case 'd' : case 'D' :\n                    try {\n                        final Double d = createDouble(numeric); // Assumes createDouble handles double format\n                        // Check for infinity or zero result when original wasn't zero\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { // Use d.doubleValue()\n                            return d;\n                        }\n                         // If Double has issues, fall through to BigDecimal\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // Fall through\n                    }\n                    try {\n                        // Final attempt with BigDecimal for 'f','F','d','D' cases for precision\n                        return createBigDecimal(numeric); // Assumes createBigDecimal handles decimal format\n                    } catch (final NumberFormatException e) { // NOPMD\n                         // If createBigDecimal fails, the number is invalid for F/D types\n                    }\n                     // Throw exception if all attempts (Float, Double, BigDecimal) failed for F/D\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n                default : // Invalid type suffix\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else { // Ends with digit or '.' -> No type specifier\n            // Determine exponent string part if exists\n            String expString = null;\n            if (expPos > -1 && expPos < str.length() - 1) { // Check 'e'/'E' is not last char\n                expString = str.substring(expPos + 1);\n            }\n            // Check if mantissa and exponent string are all zeros\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(expString); // Assumes isAllZeros helper exists\n\n            if (dec == null && expPos == -1) { // Integral number (potentially octal if starts with 0)\n                // Try creating Integer/Long/BigInteger using the helper methods which should handle octal/decimal\n                try {\n                    return createInteger(str);\n                } catch (final NumberFormatException nfe) { /* Ignore */ } // NOPMD\n                try {\n                    return createLong(str);\n                } catch (final NumberFormatException nfe) { /* Ignore */ } // NOPMD\n                return createBigInteger(str); // Final attempt for integer types\n\n            }\n            // Number is non-integral (has '.' or 'e'/'E')\n            // Try Float -> Double -> BigDecimal, considering precision heuristics from original code (LANG-693)\n            try {\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    // Heuristic: Float may be okay for few decimals\n                    if (numDecimals <= 7) {\n                       return f;\n                    }\n                    // Otherwise, precision might be insufficient, try Double\n                }\n            } catch (final NumberFormatException nfe) { /* Ignore */ } // NOPMD\n            try {\n                final Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { // Use d.doubleValue()\n                    // Heuristic: Double may be okay for moderate decimals\n                    if (numDecimals <= 16) {\n                       return d;\n                    }\n                    // Otherwise, precision might be insufficient, try BigDecimal\n                }\n            } catch (final NumberFormatException nfe) { /* Ignore */ } // NOPMD\n\n            // Final fallback for non-integral numbers without suffix is BigDecimal for exact representation\n            return createBigDecimal(str);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}