{
    "generation": "import org.traccar.helper.BitUtil;\nimport org.traccar.helper.Parser;\nimport org.traccar.model.Position;\n\nimport java.net.SocketAddress;\nimport java.util.LinkedList;\n\n// ... other imports and context assumed from the original code ...\n\n// Assume Gl200BaseProtocolDecoder provides necessary methods and fields like:\n// getProtocolName(), getDeviceSession(), decodeLocation(), parseHours(), decodeStatus(), decodeDeviceTime()\n// PATTERN_ERI, PATTERN_LOCATION, ignoreFixTime\n// Assume decodeStatus(Position position, int statusValue) signature works.\n\n    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        // Regex might need adjustment based on actual PATTERN_ERI definition to capture fields correctly\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next()); // IMEI\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong(); // Mask\n\n        LinkedList<Position> positions = new LinkedList<>();\n\n        Integer power = parser.nextInt(); // Reserved / Power\n\n        // Location Data Block (assuming parser.next() gets the whole block)\n        // Check if location field exists before creating itemParser\n        if (parser.hasNext()) {\n            String locationBlock = parser.next();\n            if (locationBlock != null && !locationBlock.isEmpty()) {\n                // Use a pattern that splits the location block by commas but handles potential internal structures if needed\n                // Assuming PATTERN_LOCATION works on the whole block string for find() loop\n                Parser itemParser = new Parser(PATTERN_LOCATION, locationBlock);\n                while (itemParser.find()) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    decodeLocation(position, itemParser); // Parses location fields from itemParser match\n                    positions.add(position);\n                }\n            }\n        }\n\n        // If no positions were created (e.g., empty/invalid location block), create a basic one\n        if (positions.isEmpty()) {\n             Position position = new Position(getProtocolName());\n             position.setDeviceId(deviceSession.getDeviceId());\n             positions.add(position);\n        }\n\n        Position position = positions.getLast(); // Use the last position for subsequent attributes\n\n        if (power != null) {\n            position.set(Position.KEY_POWER, power * 0.001);\n        }\n\n        // Parse optional fixed fields after location block\n        if (parser.hasNext()) {\n            position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000); // Odometer\n        }\n        if (parser.hasNext()) {\n            position.set(Position.KEY_HOURS, parseHours(parser.next())); // Hours\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 1, parser.next()); // ADC1\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 2, parser.next()); // ADC2\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 3, parser.next()); // ADC3\n        }\n\n        // Input / Output\n        if (parser.hasNext(2)) {\n            Integer input = parser.nextHexInt();\n            Integer output = parser.nextHexInt();\n            if (input != null) {\n                position.set(Position.KEY_INPUT, input);\n            }\n            if (output != null) {\n                 position.set(Position.KEY_OUTPUT, output);\n            }\n        }\n\n        // Battery Level / Status\n        Integer batteryLevel = null;\n        Integer statusValue = null; // Store status value for potential fuel parsing\n        if (parser.hasNext(2)) {\n            batteryLevel = parser.nextInt(); // Parse battery first\n            statusValue = parser.nextHexInt(); // Parse status as Hex Int second\n\n            if (batteryLevel != null) {\n                position.set(Position.KEY_BATTERY_LEVEL, batteryLevel);\n            }\n            if (statusValue != null) {\n                // Assuming decodeStatus takes Integer value.\n                // If decodeStatus needs the parser object, this logic must change.\n                decodeStatus(position, statusValue);\n            }\n        }\n\n        // Check if extended data field exists (heuristic: check if 3+ fields remain before time/checksum)\n        // Needs at least time and checksum (2), plus the extended data (1) = 3\n        boolean extendedDataPresent = parser.hasNext(3);\n\n        if (extendedDataPresent) {\n            int index = 0;\n            String extendedData = parser.next(); // Consume the extended data field\n            String[] data = extendedData.split(\",\");\n\n            // Skip device type/info field at index 0 if present\n            if (data.length > index) {\n                index++;\n            }\n\n            if (BitUtil.check(mask, 0)) { // Digital Fuel Sensor Data Field Index\n                 if (data.length > index) { index++; } // Skip field\n            }\n\n            // Temperature sensor parsing\n            if (BitUtil.check(mask, 1)) {\n                 if (data.length > index) { // Check index valid for count\n                    try {\n                        int deviceCount = Integer.parseInt(data[index++]); // Read count, increment index\n                        for (int i = 1; i <= deviceCount; i++) {\n                            // Skip ID & Type fields if they exist\n                            if (data.length > index) { index++; } // Skip ID\n                            if (data.length > index) { index++; } // Skip Type\n\n                            // Read value field if it exists\n                            if (data.length > index && !data[index].isEmpty()) {\n                                try {\n                                    // Value is at current index, parse it\n                                    position.set(Position.PREFIX_TEMP + i, Integer.parseInt(data[index], 16) * 0.0625);\n                                } catch (NumberFormatException e) { /* ignore temp parse error */ }\n                                index++; // Increment index AFTER parsing/attempting value\n                            } else if (data.length > index) {\n                                // Increment even if value is empty or missing to move past this sensor's value field\n                                index++;\n                            }\n                        }\n                    } catch (NumberFormatException e) { /* ignore count parse error */ }\n                 }\n            }\n\n            // CAN data parsing\n            if (BitUtil.check(mask, 2)) {\n                // Skip CAN data field index\n                 if (data.length > index) { index++; }\n            }\n\n            // Fuel level/volume parsing\n            if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) {\n                if (data.length > index) { // Check index valid for count\n                    try {\n                        int deviceCount = Integer.parseInt(data[index++]); // Read count, increment index\n                        for (int i = 1; i <= deviceCount; i++) {\n                            // Skip Type field if it exists\n                            if (data.length > index) { index++; } // Skip Type\n\n                            boolean fuelLevelPresent = BitUtil.check(mask, 3);\n                            boolean fuelVolumePresent = BitUtil.check(mask, 4);\n                            boolean consumedIndex = false; // Track if index was consumed for this device\n\n                            if (fuelLevelPresent) {\n                                // Read fuel level field if it exists\n                                if (data.length > index) {\n                                    try {\n                                        position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(data[index]));\n                                    } catch (NumberFormatException e) { /* ignore */ }\n                                    index++; // Increment index after reading/skipping fuel level\n                                    consumedIndex = true;\n                                }\n                            }\n                            if (fuelVolumePresent) {\n                                // Skip volume field if it exists\n                                // Increment only if fuel level wasn't present or didn't consume index\n                                if (data.length > index && !consumedIndex) {\n                                     index++;\n                                }\n                            }\n                        }\n                    } catch (NumberFormatException e) { /* ignore count parse error */ }\n                }\n            }\n        }\n\n        // Fallback fuel level check: If mask bit 3 (Fuel Level) is OFF, but mask bit 0 (Digital Fuel Sensor) is ON,\n        // and fuel level attribute is not already set, use the 'status' field value as fuel level.\n        if (!BitUtil.check(mask, 3) && BitUtil.check(mask, 0) && statusValue != null\n                && !position.hasAttribute(Position.KEY_FUEL_LEVEL)) {\n            position.set(Position.KEY_FUEL_LEVEL, statusValue.doubleValue());\n        }\n\n        // Device Time is expected to be the next field after optional extended data\n        decodeDeviceTime(position, parser);\n\n        // ignoreFixTime logic (keep only last position)\n        if (ignoreFixTime && positions.size() > 1) {\n            Position lastPosition = positions.getLast(); // Keep last position\n            positions.clear(); // Clear the list\n            positions.add(lastPosition); // Add the last one back\n        }\n\n        return positions; // Return the list (may contain one or more positions)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}