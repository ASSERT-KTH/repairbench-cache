{
    "generation": "    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong();\n\n        LinkedList<Position> positions = new LinkedList<>();\n\n        Integer power = parser.nextInt();\n\n        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());\n        while (itemParser.find()) {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            decodeLocation(position, itemParser);\n\n            positions.add(position);\n        }\n\n        // If no positions were decoded from location data, return null or handle error\n        if (positions.isEmpty()) {\n             // Or potentially create a basic position if other data exists? Depends on protocol spec.\n             return null;\n        }\n        Position position = positions.getLast();\n\n        // skipLocation(parser); // This was incorrect, fields are parsed sequentially below\n\n        if (power != null) {\n            position.set(Position.KEY_POWER, power * 0.001);\n        }\n\n        Integer fuelLevelHex = null; // Variable to store potential hex fuel parsed later\n\n        if (parser.hasNextAny(12)) { // Check if Odometer to Status fields exist\n\n            position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n            position.set(Position.KEY_HOURS, parseHours(parser.next()));\n            position.set(Position.PREFIX_ADC + 1, parser.next());\n            position.set(Position.PREFIX_ADC + 2, parser.next());\n            position.set(Position.PREFIX_ADC + 3, parser.next());\n            if (parser.hasNext(2)) {\n                position.set(Position.KEY_INPUT, parser.nextHexInt());\n                position.set(Position.KEY_OUTPUT, parser.nextHexInt());\n            }\n            if (parser.hasNext(4)) {\n                position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt()); // Battery Level 1\n                decodeStatus(position, parser); // Status\n            }\n\n            // Parse Extra Data based on mask\n            if (parser.hasNext()) { // Check if Extra Data field exists\n                String extraData = parser.next(); // Consume Extra Data field\n                // Only parse extraData if it's not null and not empty\n                if (extraData != null && !extraData.isEmpty()) {\n                    int index = 0;\n                    String[] data = extraData.split(\",\");\n\n                    // Assuming the first field is always device type if extraData is present\n                    if (index < data.length) {\n                        index += 1; // device type (Skip)\n                    }\n\n                    if (BitUtil.check(mask, 0)) {\n                        // Original logic just incremented index. Keep it, but ensure index is valid.\n                        if (index < data.length) {\n                            index += 1; // digital fuel sensor data field (skipped)\n                        }\n                    }\n\n                    if (BitUtil.check(mask, 1)) {\n                        if (index < data.length) { // Check index before reading deviceCount\n                            int deviceCount = Integer.parseInt(data[index++]);\n                            for (int i = 1; i <= deviceCount; i++) {\n                                // Need 3 fields: id, type, temp value\n                                if (index + 2 < data.length) {\n                                    index += 1; // id (skipped)\n                                    index += 1; // type (skipped)\n                                    String tempValue = data[index++];\n                                    if (!tempValue.isEmpty()) {\n                                        position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(tempValue, 16) * 0.0625);\n                                    }\n                                } else {\n                                    break; // Not enough fields left in data array\n                                }\n                            }\n                        }\n                    }\n\n                    if (BitUtil.check(mask, 2)) {\n                        if (index < data.length) {\n                            index += 1; // can data (skipped)\n                        }\n                    }\n\n                    if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) {\n                        if (index < data.length) { // Check index before reading deviceCount\n                            int deviceCount = Integer.parseInt(data[index++]);\n                            for (int i = 1; i <= deviceCount; i++) {\n                                // Need at least type field\n                                if (index < data.length) {\n                                    index += 1; // type (skipped)\n                                    if (BitUtil.check(mask, 3)) {\n                                        // Need fuel level field\n                                        if (index < data.length) {\n                                            position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(data[index++]));\n                                        } else { break; } // Not enough fields\n                                    }\n                                    if (BitUtil.check(mask, 4)) {\n                                         // Need volume field\n                                         if (index < data.length) {\n                                            index += 1; // volume (skipped)\n                                         } else { break; } // Not enough fields\n                                    }\n                                } else {\n                                    break; // Not enough fields left in data array\n                                }\n                            }\n                        }\n                    }\n                }\n            } // End of Extra Data parsing\n        } // End of if (parser.hasNextAny(12))\n\n        // Handle fields potentially after Extra Data (BatteryLevel2, FuelLevelHex?, DeviceTime)\n        // This logic specifically handles the case where mask bit 0 is set,\n        // inserting a hex fuel level between BatteryLevel2 and DeviceTime.\n        if (parser.hasNext()) {\n            String field1 = parser.peekNext();\n            if (field1.matches(\"\\\\d+\")) { // Field 1 looks like Battery Level 2 (numeric)\n                position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt()); // Consume and set Battery Level 2\n\n                // If mask bit 0 is set, check if the *next* field is the hex fuel level\n                if (BitUtil.check(mask, 0) && parser.hasNext()) {\n                    String field2 = parser.peekNext();\n                    if (field2.matches(\"^[\\\\p{XDigit}]+$\")) { // Field 2 looks like hex fuel\n                        // Check if it's followed by a 14-digit timestamp\n                        if (parser.hasNext(2) && parser.peekNext(2).matches(\"^\\\\d{14}$\")) {\n                             fuelLevelHex = parser.nextHexInt(); // Consume hex fuel\n                             position.set(Position.KEY_FUEL_LEVEL, fuelLevelHex); // Set fuel level from hex value\n                        } else {\n                             // It looked like hex fuel, but wasn't followed by time. Consume it anyway.\n                             parser.next();\n                        }\n                    }\n                    // If field2 doesn't look hex, do nothing, let decodeDeviceTime handle the next field\n                }\n            } else if (BitUtil.check(mask, 0) && field1.matches(\"^[\\\\p{XDigit}]+$\")) {\n                 // Field1 wasn't numeric battery, but mask bit 0 is set and field1 looks hex.\n                 // Assume this is fuel level directly (no Battery Level 2 reported).\n                 if (parser.hasNext(2) && parser.peekNext(2).matches(\"^\\\\d{14}$\")) { // Check if followed by time\n                     fuelLevelHex = parser.nextHexInt(); // Consume hex fuel\n                     position.set(Position.KEY_FUEL_LEVEL, fuelLevelHex); // Set fuel level\n                 } else {\n                     // Hex field not followed by time. Consume it.\n                     parser.next();\n                 }\n            } else {\n                // Field1 is neither expected Battery Level 2 nor Hex Fuel. Consume it.\n                parser.next();\n            }\n        }\n        // If fuelLevelHex was parsed from extraData (mask bit 3), this won't overwrite it unless null\n\n        decodeDeviceTime(position, parser); // Parse device time (should be the next field now)\n        if (ignoreFixTime) {\n            positions.clear();\n            positions.add(position);\n        }\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}