{
    "generation": "private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n    Parser parser = new Parser(PATTERN_ERI, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n\n    long mask = parser.nextHexLong();\n\n    LinkedList<Position> positions = new LinkedList<>();\n\n    Position position = new Position(getProtocolName());\n    position.setDeviceId(deviceSession.getDeviceId());\n\n    decodeLocation(position, parser);\n\n    Optional<Parser> optionalParser = parser.getAny();\n    if (optionalParser.isPresent()) {\n        Parser itemParser = parser.next();\n        while (itemParser != null) {\n            itemParser = itemParser.getAny().orElse(null);\n            if (itemParser != null) {\n                Position pos = new Position(getProtocolName());\n                pos.setDeviceId(deviceSession.getDeviceId());\n                decodeLocation(pos, itemParser);\n                positions.add(pos);\n            }\n        }\n    }\n\n    Integer power = parser.nextInt();\n    if (power != null) {\n        position.set(Position.KEY_POWER, power * 0.001);\n    }\n\n    if (parser.hasNext() && parser.peek().equals(\"odometer\")) {\n        Long odometer = parser.nextAnyLong();\n        position.set(Position.KEY_ODOMETER, odometer != null ? odometer * 1000.0 : 0.0);\n    }\n\n    if (parser.hasNext(2)) {\n        position.set(Position.KEY_HOURS, parseHours(parser.next()));\n        position.set(Position.PREFIX_ADC + 1, parser.next());\n        position.set(Position.PREFIX_ADC + 2, parser.next());\n        position.set(Position.PREFIX_ADC + 3, parser.next());\n        if (parser.hasNext(2)) {\n            position.set(Position.KEY_INPUT, parser.nextHexInt());\n            position.set(Position.KEY_OUTPUT, parser.nextHexInt());\n        }\n        if (parser.hasNext(4)) {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n            decodeStatus(position, parser);\n        }\n\n        if (parser.hasNext()) {\n            String[] data = parser.next().split(\",\");\n            int index = 0; // Handle index correctly\n\n            Optional<String> deviceType = Optional.ofNullable(data[index++]);\n            if (deviceType.isPresent() && Boolean.parseBoolean(deviceType.get())) {\n                index += 1; // digital fuel sensor data\n            }\n\n            if (BitUtil.check(mask, 2)) {\n                index += 1; // can data\n            }\n\n            if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) {\n                int deviceCount = Integer.parseInt(data[index++]);\n                for (int i = 1; i <= deviceCount; i++) {\n                    index += 1; // id\n                    index += 1; // type\n                    if (!data[index++].isEmpty()) {\n                        position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(data[index - 1], 16) * 0.0625);\n                    }\n                }\n            }\n\n            if (index < data.length) { // Remaining data\n                skipRemainingData(parser, index);\n            }\n        }\n    }\n\n    if (parser.hasNext()) {\n        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n    }\n\n    decodeDeviceTime(position, parser);\n    if (ignoreFixTime) {\n        positions.clear();\n        positions.add(position);\n    }\n\n    return positions;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}