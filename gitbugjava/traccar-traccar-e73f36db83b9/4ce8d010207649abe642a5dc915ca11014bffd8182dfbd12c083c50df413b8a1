{
    "generation": "    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        // PATTERN_ERI is assumed to match the beginning and capture IMEI, mask etc.\n        // PATTERN_LOCATION is assumed to capture fields within the location block\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next()); // Get IMEI\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong(); // Get mask\n\n        LinkedList<Position> positions = new LinkedList<>();\n\n        Integer power = parser.nextInt(); // Get optional power value\n\n        // Parse the location block using a sub-parser\n        String locationBlock = parser.next(); // Get the whole location block string\n        if (locationBlock != null && !locationBlock.isEmpty()) {\n            Parser itemParser = new Parser(PATTERN_LOCATION, locationBlock);\n            while (itemParser.find()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                decodeLocation(position, itemParser); // Decode individual location fields\n                positions.add(position);\n            }\n        }\n\n        // If no position was decoded from the location block, we can't add further details\n        if (positions.isEmpty()) {\n            return null;\n        }\n        \n        // Use the last position found in the block to add subsequent data\n        Position position = positions.getLast();\n\n        // skipLocation(parser); // REMOVED - Incorrect, location already processed by itemParser\n\n        // Set power if available\n        if (power != null) {\n            position.set(Position.KEY_POWER, power * 0.001);\n        }\n\n        // Parse standard optional fields following the location block\n        // Use hasNext() before each access for robustness\n        if (parser.hasNext()) {\n            String odometer = parser.next();\n            if (odometer != null && !odometer.isEmpty()) {\n                try {\n                    position.set(Position.KEY_ODOMETER, Double.parseDouble(odometer) * 1000);\n                } catch (NumberFormatException e) { /* Ignore parse error */ }\n            }\n        }\n        if (parser.hasNext()) {\n            // parseHours should handle empty string if necessary\n            position.set(Position.KEY_HOURS, parseHours(parser.next()));\n        }\n        if (parser.hasNext()) {\n            String adc1 = parser.next();\n             if (adc1 != null && !adc1.isEmpty()) {\n                position.set(Position.PREFIX_ADC + 1, adc1);\n             }\n        }\n        if (parser.hasNext()) {\n             String adc2 = parser.next();\n             if (adc2 != null && !adc2.isEmpty()) {\n                position.set(Position.PREFIX_ADC + 2, adc2);\n             }\n        }\n        if (parser.hasNext()) {\n             String adc3 = parser.next();\n             if (adc3 != null && !adc3.isEmpty()) {\n                position.set(Position.PREFIX_ADC + 3, adc3);\n             }\n        }\n        // Input/Output fields (parsed as Hex)\n         if (parser.hasNext()) {\n             String input = parser.next();\n             if (input != null && !input.isEmpty()) {\n                  try {\n                      position.set(Position.KEY_INPUT, Integer.parseInt(input, 16));\n                  } catch (NumberFormatException e) { /* Ignore parse error */ }\n             }\n        }\n         if (parser.hasNext()) {\n             String output = parser.next();\n             if (output != null && !output.isEmpty()) {\n                 try {\n                     position.set(Position.KEY_OUTPUT, Integer.parseInt(output, 16));\n                 } catch (NumberFormatException e) { /* Ignore parse error */ }\n             }\n        }\n\n        // Parse fields indicated by the mask\n        // Note: Battery and Status might appear here in some variants, but the failing test\n        // places the fuel level (mask bit 0) directly after I/O. We parse based on mask bits.\n        if (mask > 0) {\n            if (BitUtil.check(mask, 0)) { // Bit 0: Digital fuel sensor data (Hex value)\n                if (parser.hasNext()) {\n                    String fuelValue = parser.next();\n                    if (fuelValue != null && !fuelValue.isEmpty()) {\n                        try {\n                            // Value is hex in the example \"0099\" -> 153\n                            position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(fuelValue, 16));\n                        } catch (NumberFormatException e) { /* Ignore parse error */ }\n                    }\n                }\n            }\n\n            if (BitUtil.check(mask, 1)) { // Bit 1: Temperature sensors\n                if (parser.hasNext()) { // Check if count field exists\n                    int deviceCount = parser.nextInt(10); // Read count\n                    for (int i = 1; i <= deviceCount; i++) {\n                        // Each sensor has id, type, value\n                        if (parser.hasNext()) parser.next(); // Skip id\n                        else break; // Stop if fields run out\n                        if (parser.hasNext()) parser.next(); // Skip type\n                        else break;\n                        if (parser.hasNext()) {\n                            String tempValue = parser.next(); // Read value (Hex)\n                            if (tempValue != null && !tempValue.isEmpty()) {\n                                try {\n                                    position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(tempValue, 16) * 0.0625);\n                                } catch (NumberFormatException e) { /* Ignore parse error */ }\n                            }\n                        } else { break; }\n                    }\n                }\n            }\n\n            if (BitUtil.check(mask, 2)) { // Bit 2: CAN data\n                if (parser.hasNext()) {\n                    parser.next(); // Skip the CAN data field\n                }\n            }\n\n            if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) { // Bits 3/4: Analog Fuel sensor(s)\n                if (parser.hasNext()) { // Check if count field exists\n                    int deviceCount = parser.nextInt(10); // Read count\n                    for (int i = 1; i <= deviceCount; i++) {\n                        // Each sensor has type, level (if bit 3), volume (if bit 4)\n                        if (parser.hasNext()) parser.next(); // Skip type\n                        else break;\n                        if (BitUtil.check(mask, 3)) { // Fuel Level (Double)\n                            if (parser.hasNext()) {\n                                String fuelValue = parser.next();\n                                if (fuelValue != null && !fuelValue.isEmpty()) {\n                                     try {\n                                         // Note: Overwrites fuel level from bit 0 if both are present\n                                         position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(fuelValue));\n                                     } catch (NumberFormatException e) { /* Ignore parse error */ }\n                                }\n                            } else { break; }\n                        }\n                        if (BitUtil.check(mask, 4)) { // Fuel Volume\n                            if (parser.hasNext()) {\n                                 parser.next(); // Skip volume field\n                            } else { break; }\n                        }\n                    }\n                }\n            }\n        } // End if (mask > 0)\n\n        // Battery level might be present after mask fields, just before time (common in FRI)\n        // Use peek-and-parse to avoid consuming time field if it's not an integer battery value.\n        if (parser.hasNext()) {\n            String nextField = parser.peek(); // Assume Parser has peek()\n            if (nextField != null) {\n                try {\n                    int batteryLevel = Integer.parseInt(nextField);\n                    // If parse succeeded, consume the field and set battery level\n                    parser.next();\n                    position.set(Position.KEY_BATTERY_LEVEL, batteryLevel);\n                } catch (NumberFormatException e) {\n                    // Not a valid integer, assume it's not battery level, leave field for time parser\n                }\n            }\n        }\n\n        // Decode device timestamp if present at the end\n        decodeDeviceTime(position, parser);\n\n        // Handle ignoreFixTime: only return the last position's state\n        if (ignoreFixTime) {\n            // Create a new list containing only the last updated position\n            LinkedList<Position> result = new LinkedList<>();\n            result.add(position);\n            return result;\n        }\n\n        // Return the list of positions (potentially modified by ignoreFixTime)\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}