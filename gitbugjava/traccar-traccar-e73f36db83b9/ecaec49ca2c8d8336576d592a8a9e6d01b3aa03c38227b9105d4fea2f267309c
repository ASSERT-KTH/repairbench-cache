{
    "generation": "private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n    Parser parser = new Parser(PATTERN_ERI, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n\n    long mask = 0;\n    String maskStr = parser.next();\n    if (maskStr != null && !maskStr.isEmpty()) {\n        try {\n            mask = Long.parseLong(maskStr, 16);\n        } catch (NumberFormatException e) {\n            mask = 0;\n        }\n    }\n\n    LinkedList<Position> positions = new LinkedList<>();\n\n    Integer power = parser.nextInt();\n\n    Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());\n    while (itemParser.find()) {\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        decodeLocation(position, itemParser);\n\n        positions.add(position);\n    }\n\n    // Check if no positions found, early return to avoid IndexOutOfBoundsException\n    if (positions.isEmpty()) {\n        return null;\n    }\n\n    Position position = positions.getLast();\n\n    skipLocation(parser);\n\n    if (power != null) {\n        position.set(Position.KEY_POWER, power * 0.001);\n    }\n\n    if (parser.hasNextAny(12)) {\n\n        position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n        position.set(Position.KEY_HOURS, parseHours(parser.next()));\n        position.set(Position.PREFIX_ADC + 1, parser.next());\n        position.set(Position.PREFIX_ADC + 2, parser.next());\n        position.set(Position.PREFIX_ADC + 3, parser.next());\n        if (parser.hasNext(2)) {\n            position.set(Position.KEY_INPUT, parser.nextHexInt());\n            position.set(Position.KEY_OUTPUT, parser.nextHexInt());\n        }\n        if (parser.hasNext(4)) {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n            decodeStatus(position, parser);\n        }\n\n        if (parser.hasNext()) {\n            String block = parser.next();\n            if (block != null && block.contains(\",\")) {\n                int index = 0;\n                String[] data = block.split(\",\");\n\n                index += 1; // usually device type\n\n                if (BitUtil.check(mask, 0)) {\n                    index += 1; // digital fuel sensor data\n                }\n\n                if (BitUtil.check(mask, 1) && index < data.length) {\n                    int deviceCount = Integer.parseInt(data[index++]);\n                    for (int i = 1; i <= deviceCount && index < data.length; i++) {\n                        index += 1; // id\n                        index += 1; // type\n                        if (index < data.length && !data[index].isEmpty()) {\n                            try {\n                                short tempValue = (short) Integer.parseInt(data[index], 16);\n                                position.set(Position.PREFIX_TEMP + i, tempValue * 0.0625);\n                            } catch (NumberFormatException e) {\n                                // ignore parse error\n                            }\n                        }\n                        index++;\n                    }\n                }\n\n                if (BitUtil.check(mask, 2)) {\n                    index += 1; // can data\n                }\n\n                if ((BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) && index < data.length) {\n                    int deviceCount = Integer.parseInt(data[index++]);\n                    for (int i = 1; i <= deviceCount && index < data.length; i++) {\n                        index += 1; // type\n                        if (BitUtil.check(mask, 3) && index < data.length) {\n                            try {\n                                position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(data[index++]));\n                            } catch (NumberFormatException e) {\n                                index++; // skip if not a valid double\n                            }\n                        }\n                        if (BitUtil.check(mask, 4)) {\n                            index += 1; // volume\n                        }\n                    }\n                }\n            } else if (block != null && !block.isEmpty()) {\n                // Some implementations may return the value directly, not as a CSV block\n                // Try to extract temp/fuel as fallback\n                if (BitUtil.check(mask, 1)) {\n                    try {\n                        short tempValue = (short) Integer.parseInt(block, 16);\n                        position.set(Position.PREFIX_TEMP + 1, tempValue * 0.0625);\n                    } catch (Exception e) {}\n                }\n                if (BitUtil.check(mask, 3)) {\n                    try {\n                        position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(block));\n                    } catch (Exception e) {}\n                }\n            }\n        }\n    }\n\n    if (parser.hasNext()) {\n        try {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n        } catch (NumberFormatException ignore) {}\n    }\n\n    decodeDeviceTime(position, parser);\n    if (ignoreFixTime) {\n        positions.clear();\n        positions.add(position);\n    }\n\n    return positions;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}