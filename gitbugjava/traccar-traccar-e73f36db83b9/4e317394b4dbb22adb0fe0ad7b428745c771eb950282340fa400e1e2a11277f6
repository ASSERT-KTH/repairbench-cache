{
    "generation": "    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong();\n\n        LinkedList<Position> positions = new LinkedList<>();\n\n        Integer power = parser.nextInt();\n\n        // Location block can repeat, parse all occurrences\n        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());\n        while (itemParser.find()) {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            decodeLocation(position, itemParser);\n            positions.add(position);\n        }\n\n        // If no location data was found, we can't proceed\n        if (positions.isEmpty()) {\n             return null;\n        }\n\n        // Use the last position for subsequent data\n        Position position = positions.getLast();\n\n        // Skip Cell/Wifi Tower ID field that follows location block\n        skipLocation(parser);\n\n        // External Power Voltage\n        if (power != null) {\n            position.set(Position.KEY_POWER, power * 0.001);\n        }\n\n        // Optional Fields before Mask data\n        // Check for Odometer\n        if (parser.hasNext()) {\n            position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n        }\n        // Check for Hours\n        if (parser.hasNext()) {\n            position.set(Position.KEY_HOURS, parseHours(parser.next()));\n        }\n        // Check for ADC 1, 2, 3\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 1, parser.next());\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 2, parser.next());\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 3, parser.next());\n        }\n        // Check for Input/Output (2 fields)\n        if (parser.hasNext(2)) {\n            position.set(Position.KEY_INPUT, parser.nextHexInt());\n            position.set(Position.KEY_OUTPUT, parser.nextHexInt());\n        }\n\n        // Optional Mask-Based Data Fields\n        boolean maskDataParsed = false;\n        if (mask != 0 && parser.hasNext()) { // Check if mask is non-zero and there's at least one field for device type\n            maskDataParsed = true;\n            parser.nextInt(); // Consume device type field (usually '1' or '2' based on examples)\n\n            // Parse fields based on mask bits\n            if (BitUtil.check(mask, 0)) { // Digital Fuel Sensor Data\n                if (parser.hasNext()) {\n                    // Example shows \"0099\" parsed as 153, suggesting hex\n                    position.set(Position.KEY_FUEL_LEVEL, parser.nextHexInt());\n                }\n            }\n\n            if (BitUtil.check(mask, 1)) { // Temperature Sensors\n                if (parser.hasNext()) { // Check for count field\n                    int deviceCount = parser.nextInt();\n                    for (int i = 1; i <= deviceCount; i++) {\n                        if (parser.hasNext()) {\n                            parser.next(); // skip id\n                        }\n                        if (parser.hasNext()) {\n                             parser.next(); // skip type\n                        }\n                        if (parser.hasNext()) {\n                            String tempData = parser.next();\n                            if (!tempData.isEmpty()) {\n                                // Formula from original code\n                                position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(tempData, 16) * 0.0625);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (BitUtil.check(mask, 2)) { // CAN Data\n                if (parser.hasNext()) {\n                    parser.next(); // Skip CAN data field\n                }\n            }\n\n            if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) { // Fuel Level / Volume Sensors\n                if (parser.hasNext()) { // Check for count field\n                    int deviceCount = parser.nextInt();\n                    for (int i = 1; i <= deviceCount; i++) {\n                        if (parser.hasNext()) {\n                            parser.next(); // skip type\n                        }\n                        if (BitUtil.check(mask, 3)) { // Fuel Level\n                            if (parser.hasNext()) {\n                                // Assume double based on other examples with this mask bit\n                                position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble());\n                            }\n                        }\n                        if (BitUtil.check(mask, 4)) { // Volume\n                            if (parser.hasNext()) {\n                                parser.next(); // Skip volume field\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Battery Level: Parse only if mask data wasn't present (common pattern in other messages like GTFRI)\n        if (!maskDataParsed && parser.hasNext()) {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n        }\n\n        // Device Time (should be the last field before checksum)\n        decodeDeviceTime(position, parser);\n\n        // Handle potential time rollback\n        if (ignoreFixTime) {\n            positions.clear();\n            positions.add(position);\n        }\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}