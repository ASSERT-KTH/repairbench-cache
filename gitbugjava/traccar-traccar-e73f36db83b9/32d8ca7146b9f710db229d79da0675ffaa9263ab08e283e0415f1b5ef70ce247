{
    "generation": "    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next()); // Consumes IMEI (group 2)\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong(); // Consumes Mask (group 3)\n\n        // The parser automatically skips non-capturing groups (like Device Name, GPS Quality)\n        // and advances to the next capturing group (Report Type, group 4).\n        Integer reportType = parser.nextInt(); // Consumes Report Type (group 4)\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // GPS Fix (group 5) and GPS Valid (group 6)\n        position.setValid(parser.nextInt() == 1); // Consumes GPS Fix (group 5)\n        position.setValid(parser.nextInt() == 1 && position.getValid()); // Consumes GPS Valid (group 6)\n\n        // Location fields (groups 7-12: Speed, Course, Altitude, Longitude, Latitude, Date/Time)\n        // `decodeLocation` consumes these fields directly from the main parser.\n        // The original `itemParser` loop was incorrect for GTERI messages.\n        decodeLocation(position, parser); // Consumes groups 7-12\n\n        // Add the parsed position to the list. GTERI typically yields a single position.\n        positions.add(position);\n\n        // Process fields after location, following the order in PATTERN_ERI (starting from group 13: MCC)\n\n        // Network info (groups 13-16)\n        if (parser.hasNext(4)) {\n            position.set(Position.KEY_MCC, parser.nextInt()); // Consumes MCC (group 13)\n            position.set(Position.KEY_MNC, parser.nextInt()); // Consumes MNC (group 14)\n            position.set(Position.KEY_LAC, parser.nextHexInt()); // Consumes LAC (group 15)\n            position.set(Position.KEY_CID, parser.nextHexInt()); // Consumes CID (group 16)\n        }\n\n        // IO State (group 17)\n        if (parser.hasNext()) {\n            decodeStatus(position, parser.next()); // Consumes IO State (group 17)\n        }\n\n        // ADC values (groups 18-21)\n        for (int i = 0; i < 4; i++) {\n            if (parser.hasNext()) {\n                position.set(Position.PREFIX_ADC + i, parser.nextDouble()); // Consumes ADC, ADC2, ADC3, ADC4 (groups 18-21)\n            }\n        }\n\n        // Battery level (group 22)\n        if (parser.hasNext()) {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt()); // Consumes Battery level (group 22)\n        }\n\n        // Digital input/output status (group 23)\n        // PATTERN_ERI defines this as a single field. Original code's `hasNext(2)` for two distinct fields was incorrect.\n        if (parser.hasNext()) {\n            position.set(Position.KEY_INPUT, parser.nextHexInt()); // Consumes Digital input/output status (group 23)\n            // If KEY_OUTPUT is also expected, it should be derived from the same value (e.g., bitwise operations)\n            // or there should be another field in PATTERN_ERI. Based on PATTERN_ERI, there's only one.\n            // Removing `position.set(Position.KEY_OUTPUT, parser.nextHexInt());` as it would consume the next field (Odometer) incorrectly.\n        }\n\n        // Odometer (group 24)\n        if (parser.hasNext()) {\n            position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000); // Consumes Odometer (group 24)\n        }\n\n        // Hour meter (group 25)\n        if (parser.hasNext()) {\n            position.set(Position.KEY_HOURS, parseHours(parser.next())); // Consumes Hour meter (group 25)\n        }\n\n        // Custom data (group 26) - This section processes sub-fields based on the mask\n        if (parser.hasNext()) {\n            String[] data = parser.next().split(\",\"); // Consumes Custom data (group 26)\n\n            int dataIndex = 0; // Index for navigating the 'data' array\n\n            // Device type (data[0])\n            if (dataIndex < data.length) {\n                dataIndex += 1;\n            }\n\n            // Digital Fuel Sensor Data (data[1])\n            if (BitUtil.check(mask, 0)) {\n                if (dataIndex < data.length) {\n                    dataIndex += 1;\n                }\n            }\n\n            // Temperature Sensor Data (based on mask bit 1)\n            if (BitUtil.check(mask, 1)) {\n                if (dataIndex < data.length) {\n                    int deviceCount = Integer.parseInt(data[dataIndex++]);\n                    for (int i = 1; i <= deviceCount; i++) {\n                        if (dataIndex < data.length) {\n                            dataIndex += 1; // id\n                        }\n                        if (dataIndex < data.length) {\n                            dataIndex += 1; // type\n                        }\n                        if (dataIndex < data.length && !data[dataIndex].isEmpty()) {\n                            position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(data[dataIndex++], 16) * 0.0625);\n                        } else if (dataIndex < data.length) {\n                            // Consume the empty field if it exists, to maintain correct index for subsequent fields\n                            dataIndex++;\n                        }\n                    }\n                }\n            }\n\n            // CANBUS Data (based on mask bit 2)\n            if (BitUtil.check(mask, 2)) {\n                if (dataIndex < data.length) {\n                    dataIndex += 1; // can data\n                }\n            }\n\n            // Fuel Level Sensor Data (based on mask bit 3) or Fuel Volume Sensor Data (based on mask bit 4)\n            if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) {\n                if (dataIndex < data.length) {\n                    int deviceCount = Integer.parseInt(data[dataIndex++]);\n                    for (int i = 1; i <= deviceCount; i++) {\n                        if (dataIndex < data.length) {\n                            dataIndex += 1; // type\n                        }\n                        if (BitUtil.check(mask, 3)) { // Fuel Level\n                            if (dataIndex < data.length) {\n                                position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(data[dataIndex++]));\n                            }\n                        }\n                        if (BitUtil.check(mask, 4)) { // Fuel Volume\n                            if (dataIndex < data.length) {\n                                dataIndex += 1; // volume\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Apply KEY_POWER based on `reportType`. Original code had `power`.\n        if (reportType != null) {\n            position.set(Position.KEY_POWER, reportType * 0.001);\n        }\n\n        // The final `if (parser.hasNext())` block for `KEY_BATTERY_LEVEL` and `decodeDeviceTime` are removed.\n        // `KEY_BATTERY_LEVEL` is already handled at group 22.\n        // `decodeDeviceTime` is already implicitly handled by `decodeLocation` for the fix time.\n\n        if (ignoreFixTime) {\n            positions.clear();\n            positions.add(position);\n        }\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}