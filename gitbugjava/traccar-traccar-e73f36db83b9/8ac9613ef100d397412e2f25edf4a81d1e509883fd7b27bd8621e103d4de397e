{
    "generation": "private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n    Parser parser = new Parser(PATTERN_ERI, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n    // The first field in the message is a protocol\u2010specific header; skip it.\n    parser.next();\n    // Now the next field is the unique device id (IMEI)\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n    // The next field (originally read as a hex long) is not used for sensor data,\n    // so just read and ignore it.\n    parser.nextHexLong();\n    Integer power = parser.nextInt();\n\n    LinkedList<Position> positions = new LinkedList<>();\n\n    // The next field contains location information which is parsed using a dedicated pattern.\n    Parser itemParser = new Parser(PATTERN_LOCATION, parser.next());\n    while (itemParser.find()) {\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n        decodeLocation(position, itemParser);\n        positions.add(position);\n    }\n\n    Position position = positions.getLast();\n\n    // Some protocols include an extra location token which must be skipped.\n    skipLocation(parser);\n\n    if (power != null) {\n        position.set(Position.KEY_POWER, power * 0.001);\n    }\n\n    if (parser.hasNextAny(12)) {\n\n        position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n        position.set(Position.KEY_HOURS, parseHours(parser.next()));\n        position.set(Position.PREFIX_ADC + 1, parser.next());\n        position.set(Position.PREFIX_ADC + 2, parser.next());\n        position.set(Position.PREFIX_ADC + 3, parser.next());\n        if (parser.hasNext(2)) {\n            position.set(Position.KEY_INPUT, parser.nextHexInt());\n            position.set(Position.KEY_OUTPUT, parser.nextHexInt());\n        }\n        if (parser.hasNext(4)) {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n            decodeStatus(position, parser);\n        }\n\n        // For sensor readings the message contains a separate sensor mask.\n        long sensorMask = parser.nextHexLong();\n\n        // The remaining fields are provided as a comma\u2010separated string.\n        String[] data = parser.next().split(\",\");\n        int index = 0;\n\n        // First value in sensor data is the device type \u2013 ignore it.\n        index += 1;\n\n        if (BitUtil.check(sensorMask, 0)) {\n            index += 1; // skip digital fuel sensor data if present\n        }\n\n        if (BitUtil.check(sensorMask, 1)) {\n            int deviceCount = Integer.parseInt(data[index++]);\n            for (int i = 1; i <= deviceCount; i++) {\n                index += 1; // skip sensor id\n                index += 1; // skip sensor type\n                if (!data[index++].isEmpty()) {\n                    position.set(Position.PREFIX_TEMP + i,\n                            (short) (Integer.parseInt(data[index - 1], 16) * 0.0625));\n                }\n            }\n        }\n\n        if (BitUtil.check(sensorMask, 2)) {\n            index += 1; // skip CAN data\n        }\n\n        // IMPORTANT: Fuel level is sent as a hexadecimal value.\n        if (BitUtil.check(sensorMask, 3) || BitUtil.check(sensorMask, 4)) {\n            int deviceCount = Integer.parseInt(data[index++]);\n            for (int i = 1; i <= deviceCount; i++) {\n                index += 1; // skip sensor type\n                if (BitUtil.check(sensorMask, 3)) {\n                    // Parse fuel level in hexadecimal (e.g. \"0099\" becomes 0x99 == 153)\n                    position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(data[index++], 16));\n                }\n                if (BitUtil.check(sensorMask, 4)) {\n                    index += 1; // skip volume\n                }\n            }\n        }\n    }\n\n    if (parser.hasNext()) {\n        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n    }\n\n    decodeDeviceTime(position, parser);\n    if (ignoreFixTime) {\n        positions.clear();\n        positions.add(position);\n    }\n\n    return positions;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}