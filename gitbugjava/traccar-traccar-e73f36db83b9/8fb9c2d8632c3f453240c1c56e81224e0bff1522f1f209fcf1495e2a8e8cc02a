{
    "generation": "    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next()); // IMEI (group 2 of PATTERN_ERI's main capture group)\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong(0); // Mask (group 4)\n\n        LinkedList<Position> positions = new LinkedList<>();\n\n        Integer power = parser.nextInt(0); // Power (group 6)\n\n        Parser itemParser = new Parser(PATTERN_LOCATION, parser.next()); // Location Data (group 7)\n        while (itemParser.find()) {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            decodeLocation(position, itemParser);\n\n            positions.add(position);\n        }\n\n        if (positions.isEmpty()) {\n            // Fallback if location data is empty or unparseable, though PATTERN_ERI implies it's structured\n            Position fallbackPosition = new Position(getProtocolName());\n            fallbackPosition.setDeviceId(deviceSession.getDeviceId());\n            positions.add(fallbackPosition);\n        }\n        Position position = positions.getLast();\n\n        // Removed skipLocation(parser); as group 7 (Location Data) is already consumed by parser.next() above.\n\n        if (power != null) {\n            position.set(Position.KEY_POWER, power * 0.001);\n        }\n\n        // Parse ADC, Odometer, Hours according to PATTERN_ERI group order\n        // Group 8: ADC1, Group 9: Odometer, Group 10: Hours, Group 11: ADC2, Group 12: ADC3\n        String adc1 = parser.next();      // Group 8\n        double odometer = parser.nextDouble(0.0); // Group 9\n        String hours = parser.next();     // Group 10\n        String adc2 = parser.next();      // Group 11\n        String adc3 = parser.next();      // Group 12\n\n        position.set(Position.KEY_ODOMETER, odometer * 1000);\n        position.set(Position.KEY_HOURS, parseHours(hours));\n        if (adc1 != null && !adc1.isEmpty()) {\n            position.set(Position.PREFIX_ADC + 1, adc1);\n        }\n        if (adc2 != null && !adc2.isEmpty()) {\n            position.set(Position.PREFIX_ADC + 2, adc2);\n        }\n        if (adc3 != null && !adc3.isEmpty()) {\n            position.set(Position.PREFIX_ADC + 3, adc3);\n        }\n\n        // Parse IO (group 13), Battery Level (group 14), Status/Extended Data (group 15)\n        if (parser.hasNext()) { // Check for IO data (group 13)\n            String ioData = parser.next(); // IO data (group 13)\n            if (ioData != null) {\n                // Assuming IO data is hex, e.g., \"IIOO...\" where II is input, OO is output\n                if (ioData.length() >= 2) {\n                    try {\n                        position.set(Position.KEY_INPUT, Integer.parseInt(ioData.substring(0, 2), 16));\n                    } catch (NumberFormatException e) {\n                        // Ignore if not valid hex or too short\n                    }\n                }\n                if (ioData.length() >= 4) {\n                     try {\n                        position.set(Position.KEY_OUTPUT, Integer.parseInt(ioData.substring(2, 4), 16));\n                    } catch (NumberFormatException e) {\n                        // Ignore\n                    }\n                }\n            }\n\n            if (parser.hasNext()) { // Check for Battery Level (group 14)\n                Integer batteryLevel = parser.nextInt(0); // Battery Level (group 14)\n                if (batteryLevel != null && batteryLevel != 0) { // Often 0 is an invalid/missing value from device\n                    position.set(Position.KEY_BATTERY_LEVEL, batteryLevel);\n                }\n\n                if (parser.hasNext()) { // Check for Status/Extended Data (group 15)\n                    String statusExtendedData = parser.next(); // Status/Extended Data (group 15)\n\n                    if (statusExtendedData != null && !statusExtendedData.isEmpty()) {\n                        // Original masked data processing logic\n                        int index = 0;\n                        String[] data = statusExtendedData.split(\",\");\n\n                        // Device type is usually the first part of statusExtendedData\n                        if (data.length > index) {\n                            index += 1; // consume device type part\n                        }\n\n                        if (BitUtil.check(mask, 0)) { // digital fuel sensor data\n                            if (data.length > index) {\n                                index += 1; \n                            }\n                        }\n\n                        if (BitUtil.check(mask, 1)) { // temperature sensors\n                            if (data.length > index && !data[index].isEmpty()) {\n                                int deviceCount = Integer.parseInt(data[index++]);\n                                for (int i = 1; i <= deviceCount; i++) {\n                                    if (data.length > index) { index += 1; } // id\n                                    if (data.length > index) { index += 1; } // type\n                                    if (data.length > index && !data[index].isEmpty()) {\n                                        position.set(Position.PREFIX_TEMP + i, (short) Integer.parseInt(data[index], 16) * 0.0625);\n                                    }\n                                    if (data.length > index) { index += 1; } // consume temp data field\n                                }\n                            } else if (data.length > index && data[index].isEmpty()) {\n                                index++; // consume empty device count field\n                            }\n                        }\n\n                        if (BitUtil.check(mask, 2)) { // can data\n                             if (data.length > index) {\n                                index += 1;\n                            }\n                        }\n\n                        if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) { // fuel level/volume\n                            if (data.length > index && !data[index].isEmpty()) {\n                                int deviceCount = Integer.parseInt(data[index++]);\n                                for (int i = 1; i <= deviceCount; i++) {\n                                    if (data.length > index) { index += 1; } // type\n                                    if (BitUtil.check(mask, 3)) {\n                                        if (data.length > index && !data[index].isEmpty()) {\n                                            position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(data[index]));\n                                        }\n                                        if (data.length > index) { index += 1; } // consume fuel level field\n                                    }\n                                    if (BitUtil.check(mask, 4)) {\n                                        if (data.length > index) { index += 1; } // volume\n                                    }\n                                }\n                            } else if (data.length > index && data[index].isEmpty()) {\n                                index++; // consume empty device count field\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // The final `if (parser.hasNext()) { position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt()); }`\n        // was incorrect as it would parse Device Time (group 16) as battery. Removed.\n\n        decodeDeviceTime(position, parser); // Parses Device Time (group 16)\n        if (ignoreFixTime) {\n            positions.clear();\n            positions.add(position);\n        }\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}