{
    "generation": "    private Object decodeEri(Channel channel, SocketAddress remoteAddress, String sentence) {\n        Parser parser = new Parser(PATTERN_ERI, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, parser.next());\n        if (deviceSession == null) {\n            return null;\n        }\n\n        long mask = parser.nextHexLong();\n\n        LinkedList<Position> positions = new LinkedList<>();\n\n        Integer power = parser.nextInt(); // Optional power\n\n        // Parse location block\n        String locationBlock = parser.next();\n        if (locationBlock != null && !locationBlock.isEmpty()) {\n            Parser itemParser = new Parser(PATTERN_LOCATION, locationBlock);\n            while (itemParser.find()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                decodeLocation(position, itemParser); // Sets fixTime etc.\n                positions.add(position);\n            }\n        }\n\n        Position position;\n        if (positions.isEmpty()) {\n            // If no positions parsed from location block, create a base one\n            position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            // Time might be set later by decodeDeviceTime\n            positions.add(position);\n        } else {\n            position = positions.getLast(); // Use the last position for subsequent data\n        }\n\n        // Location block already consumed by parser.next() above\n\n        if (power != null) {\n            position.set(Position.KEY_POWER, power * 0.001);\n        }\n\n        // Check for optional fields block that follows location block\n        // Odometer\n        if (parser.hasNext()) {\n            position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n        }\n\n        // Hours\n        if (parser.hasNext()) {\n            position.set(Position.KEY_HOURS, parseHours(parser.next()));\n        }\n\n        // ADCs\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 1, parser.next());\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 2, parser.next());\n        }\n        if (parser.hasNext()) {\n            position.set(Position.PREFIX_ADC + 3, parser.next());\n        }\n\n        // Input/Output\n        if (parser.hasNext(2)) {\n            position.set(Position.KEY_INPUT, parser.nextHexInt());\n            position.set(Position.KEY_OUTPUT, parser.nextHexInt());\n        }\n\n        // Battery Level\n        if (parser.hasNext()) {\n            position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n        }\n\n        // Status / Digital Fuel Level (if mask bit 0 is set)\n        String statusValue = null;\n        if (parser.hasNext()) {\n            statusValue = parser.next(); // Consume Status/Fuel field\n            if (BitUtil.check(mask, 0)) {\n                // If mask bit 0 is set, this field represents digital fuel level (hex)\n                try {\n                    position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(statusValue, 16));\n                } catch (NumberFormatException e) {\n                    // Ignore if not a valid hex number, might be just status\n                }\n            }\n            // Always try to decode standard status bits from this field too\n            if (statusValue != null && statusValue.matches(\"[0-9a-fA-F]+\")) {\n                 try {\n                     position.set(Position.KEY_STATUS, Integer.parseInt(statusValue, 16));\n                     // Potentially call a more detailed status decoding helper if needed\n                 } catch (NumberFormatException e) {/*ignore*/}\n            }\n        }\n\n        // Extended Data (check if field exists and is not the timestamp)\n        String extendedDataContent = null;\n        // Check if next field exists and is not a 14-digit timestamp\n        if (parser.hasNext() && !parser.peek().matches(\"^\\\\d{14}$\")) {\n            extendedDataContent = parser.next(); // Consume only if it's not the timestamp\n        }\n\n        // Process Extended Data only if mask is non-zero and content exists\n        if (mask != 0 && extendedDataContent != null && !extendedDataContent.isEmpty()) {\n            String[] data = extendedDataContent.split(\",\");\n            int index = 0;\n\n            // Assume first field is device type - skip it\n            if (index < data.length) {\n                 index++;\n            }\n\n            // Skip digital fuel data index placeholder if mask bit 0 was set\n            // Assumes extended data structure accounts for this, even if value read from status field\n            if (BitUtil.check(mask, 0)) {\n                if (index < data.length) {\n                    index++;\n                }\n            }\n\n            // Temperature Sensors (mask bit 1)\n            if (BitUtil.check(mask, 1)) {\n                if (index < data.length) { // Check if count field exists\n                    try {\n                        int deviceCount = Integer.parseInt(data[index++]); // Consume count\n                        for (int i = 1; i <= deviceCount; i++) {\n                            if (index < data.length && !data[index].isEmpty()) { // Check if value field exists\n                                position.set(Position.PREFIX_TEMP + i, Integer.parseInt(data[index], 16) * 0.0625);\n                            }\n                            index++; // Consume the value field\n                        }\n                    } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {/*ignore*/}\n                }\n            }\n\n            // CAN Data (mask bit 2) - Skip placeholder\n            if (BitUtil.check(mask, 2)) {\n                if (index < data.length) {\n                    index++;\n                }\n            }\n\n            // Analog Fuel Sensors (mask bits 3 or 4)\n            if (BitUtil.check(mask, 3) || BitUtil.check(mask, 4)) {\n                 if (index < data.length) { // Check if count field exists\n                     try {\n                         int deviceCount = Integer.parseInt(data[index++]); // Consume count\n                         for (int i = 1; i <= deviceCount; i++) {\n                             // Skip type field placeholder\n                             if (index < data.length) {\n                                 index++;\n                             }\n                             // Read level if mask bit 3\n                             if (BitUtil.check(mask, 3)) {\n                                 if (index < data.length && !data[index].isEmpty()) {\n                                     position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(data[index]));\n                                 }\n                                 index++; // Consume level field\n                             }\n                             // Skip volume if mask bit 4\n                             if (BitUtil.check(mask, 4)) {\n                                  if (index < data.length) {\n                                      index++;\n                                  }\n                             }\n                         }\n                     } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {/*ignore*/}\n                 }\n            }\n        } // end if (mask != 0 && extendedDataContent != null)\n\n        // Device Time (should be the next field now)\n        decodeDeviceTime(position, parser);\n\n        // Final cleanup and return\n        if (ignoreFixTime && positions.size() > 1) {\n            // Keep only the last position which has all the combined data\n            position = positions.getLast();\n            positions.clear();\n            positions.add(position);\n        }\n\n        return positions; // Return the list (might contain one or more positions)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}