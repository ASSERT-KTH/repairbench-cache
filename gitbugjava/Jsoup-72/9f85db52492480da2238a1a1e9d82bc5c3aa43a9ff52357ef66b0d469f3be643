{
    "generation": "import org.jsoup.internal.StringUtil; // Required import\n\n// Assuming maxStringCacheLen is a static final field in the same class or accessible.\n// e.g. private static final int maxStringCacheLen = 12;\n\n    /**\n     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n     * <p />\n     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n     * some more duplicates.\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // 1. Validate input ranges\n        // Check for negative start or count, or range exceeding buffer bounds.\n        // Use long for sum to prevent potential overflow.\n        if (start < 0 || count < 0 || (long)start + (long)count > charBuf.length) {\n            // Invalid range requested. Delegate to String constructor, which will throw\n            // the appropriate StringIndexOutOfBoundsException. This preserves the original\n            // behavior for invalid inputs (throwing an exception) while ensuring the\n            // caching logic below only operates on valid ranges.\n            return new String(charBuf, start, count);\n        }\n\n        // 2. Handle non-cacheable cases or optimizations\n        if (count == 0) {\n            // Return the canonical empty string. Avoids cache lookup/storage for \"\".\n            return \"\";\n        }\n        // Check if the string length exceeds the maximum cacheable length.\n        // maxStringCacheLen is expected to be defined elsewhere in the class.\n        if (count > maxStringCacheLen) {\n            // String is too long for cache. Create a new instance directly.\n            // The new String call is safe due to the range validation above.\n            return new String(charBuf, start, count);\n        }\n\n        // 3. Proceed with cache lookup / update for eligible strings\n        // Calculate hash code based on the character range.\n        // This loop is safe because 'start' and 'count' have been validated.\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = 31 * hash + charBuf[offset++];\n        }\n\n        // Calculate the cache index using bitwise AND (assuming stringCache.length is power of 2).\n        // This is efficient and ensures the index is within bounds [0, stringCache.length - 1].\n        final int index = hash & (stringCache.length - 1);\n        String cached = stringCache[index];\n\n        if (cached == null) { // Cache miss\n            // Create the string from the char buffer range (call is safe).\n            cached = new String(charBuf, start, count);\n            // Store the new string in the cache.\n            stringCache[index] = cached;\n        } else { // Cache entry exists: hash hit or collision\n            // Verify if the cached string actually matches the requested character range.\n            // Assumes StringUtil.rangeEquals correctly compares the string and char range.\n            // The call is safe due to input validation checks ensuring start, count are valid.\n            if (StringUtil.rangeEquals(cached, charBuf, start, count)) { // Cache hit\n                // The cached string is identical, return it.\n                return cached;\n            } else { // Hash collision\n                // The cached string has the same hash but different content.\n                // Create the new string from the char buffer range (call is safe).\n                cached = new String(charBuf, start, count);\n                // Replace the cache entry with the new string (Flywheel update strategy).\n                stringCache[index] = cached;\n            }\n        }\n        // Return the string (either newly created or found/verified in cache).\n        return cached;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}