{
    "generation": "    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return the larger of a and b, following {@link Math#max(float, float)} NaN and signed zero rules.\n     */\n    public static float max(final float a, final float b) {\n        // Handle NaN: if a is NaN, return NaN.\n        // This check works because NaN is the only float value f such that f != f.\n        if (a != a) {\n            return a;\n        }\n\n        // Handle signed zeros: Math.max(-0.0f, +0.0f) == +0.0f.\n        // The Java specification requires that Float.compare(a, b) is used implicitly,\n        // which means -0.0 is considered less than +0.0.\n        // However, the direct comparison operators (<=, >=) treat -0.0 and +0.0 as equal.\n        // We need special handling for the case max(-0.0f, 0.0f) which should be 0.0f.\n        // The check (a == 0.0f && b == 0.0f && Float.floatToRawIntBits(a) == 0x80000000)\n        // identifies when a is -0.0f and b is 0.0f (could be +0.0f or -0.0f).\n        // In this specific case (a=-0.0f, b=0.0f), returning b ensures the correct result:\n        // max(-0.0f, +0.0f) returns +0.0f (b)\n        // max(-0.0f, -0.0f) returns -0.0f (b)\n        // The constant 0x80000000 is the raw integer representation of -0.0f.\n        if ((a == 0.0f) && (b == 0.0f) && (Float.floatToRawIntBits(a) == 0x80000000)) {\n            // If a is -0.0 and b is 0.0 (signed or unsigned), return b.\n            return b;\n        }\n\n        // Standard comparison for non-NaN, non-special-zero cases.\n        // This also correctly handles the case where 'a' is a number but 'b' is NaN.\n        // In that case, (a >= b) evaluates to false, and b (NaN) is returned, which is correct.\n        return (a >= b) ? a : b;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}