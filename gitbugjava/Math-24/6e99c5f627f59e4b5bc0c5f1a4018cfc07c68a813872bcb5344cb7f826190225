{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n        // Get threshold values from superclass\n        final double relativeThreshold = getRelativeAccuracy();\n        final double absoluteThreshold = getAbsoluteAccuracy();\n\n        // Correct ordering of interval boundaries [a, b]\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid; // Current best point estimate\n        double v = x; // Point with second best value\n        double w = x; // Point with third best value\n        double d = 0; // Step length in the current iteration\n        double e = 0; // Step length from the previous iteration\n        double fx = computeObjectiveValue(x); // Objective value at x\n        if (!isMinim) {\n            fx = -fx; // Internal computations assume minimization\n        }\n        double fv = fx; // Objective value at v\n        double fw = fx; // Objective value at w\n\n        // Points used for the convergence checker\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Midpoint of the current interval [a, b]\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion (Brent's criterion)\n            // Check if the interval width relative to x is within tolerance\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\n            if (stop) {\n                // Default termination: return the best point found (x, fx)\n                // Adjust fx back based on the goal type\n                return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            }\n\n            // Tentative next evaluation point u, calculated by interpolation or golden section\n            double p = 0; // Numerator for parabolic interpolation step\n            double q = 0; // Denominator for parabolic interpolation step\n            double r = 0; // Temporary variable\n            double u = 0; // Next point to evaluate\n\n            // Try parabolic interpolation if the previous step was significant\n            if (FastMath.abs(e) > tol1) {\n                // Fit parabola through (x, fx), (w, fw), (v, fv)\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                // Ensure q is positive for the division p/q\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store the previous step length e\n                e = d; // Store the step length before previous d\n\n                // Check if the parabolic interpolation step is acceptable\n                if (p > q * (a - x) &&        // Interpolated point is within (a, b)\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // Step size is reasonable compared to previous step\n                    // Parabolic interpolation step\n                    d = p / q;\n                    u = x + d;\n\n                    // Ensure u is not too close to the boundaries a or b\n                    if (u - a < tol2 || b - u < tol2) {\n                         // If too close, adjust d to a small step towards the center m\n                         // This adjusted d might be used if parabolic step fails below, or for next iteration's e\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        // Note: u is not immediately recalculated with this adjusted d here.\n                        // If the conditions below fail, the golden section step will use this adjusted d.\n                    }\n                } else {\n                    // Parabolic step is not acceptable, fall back to Golden Section step\n                    // Determine the larger segment to keep the minimum bracketed\n                    if (x < m) {\n                        e = b - x; // x is in [a, m), step towards b\n                    } else {\n                        e = a - x; // x is in [m, b], step towards a\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Previous step e was too small, use Golden Section step\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Ensure the step d is at least tol1 in magnitude\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) { // Keep the direction of the small step\n                    d = tol1;\n                } else {\n                    d = -tol1;\n                }\n            }\n\n            // Calculate the final point u for this iteration\n            u = x + d;\n\n\n            // Compute the objective function value at u\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu; // Negate if maximizing (internal calculations assume minimization)\n            }\n\n            // Update points for convergence checker\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // User-defined convergence checker\n            if (checker != null && previous != null) { // Check only after the first iteration\n                if (checker.converged(iter, previous, current)) {\n                    // Checker indicates convergence. Return the best point found so far (x, fx).\n                    return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n                }\n            }\n\n            // Update the interval [a, b] and the points v, w, x based on the new value fu\n            if (fu <= fx) { // New point u is better than or equal to the current best x\n                // Update the interval boundary based on u relative to x\n                if (u < x) { // New interval is [a, x]\n                    b = x;\n                } else {     // New interval is [x, b]\n                    a = x;\n                }\n                // Update the tracking points: v <- w, w <- x, x <- u\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else { // New point u is worse than x (fu > fx)\n                // Update the interval boundary using u\n                if (u < x) { // New interval is [u, b]\n                    a = u;\n                } else {     // New interval is [a, u]\n                    b = u;\n                }\n                // Update w and v if u is better than w or v, maintaining order fx <= fw <= fv\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n\n            ++iter; // Increment iteration counter\n        } // End of while loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}