{
    "generation": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            // Find the longest match\n            String bestMatchId = null;\n            int bestMatchLength = 0;\n\n            // Iterate through all available timezone IDs.\n            // Assumes ALL_IDS is accessible in this scope and contains all valid IDs.\n            // It should be populated, for example, from DateTimeZone.getAvailableIDs().\n            for (String id : ALL_IDS) {\n                // Check if the text starts with the id at the given position.\n                // Timezone IDs are case-sensitive, hence the 'false' argument.\n                if (text.regionMatches(false, position, id, 0, id.length())) {\n                    // If this match is longer than the current best match, update.\n                    if (id.length() > bestMatchLength) {\n                        bestMatchId = id;\n                        bestMatchLength = id.length();\n                    }\n                }\n            }\n\n            if (bestMatchId != null) {\n                // Found the longest match, set the zone in the bucket.\n                bucket.setZone(DateTimeZone.forID(bestMatchId));\n                // Return the position after the matched ID.\n                return position + bestMatchLength;\n            }\n\n            // No match found, return error indicator.\n            return ~position;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}