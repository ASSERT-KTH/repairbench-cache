{
    "generation": "    private List<Position> parseData(\n            Channel channel, SocketAddress remoteAddress, ByteBuf buf, int locationPacketId, String... imei) {\n        List<Position> positions = new LinkedList<>();\n\n        if (!connectionless) {\n            if (buf.readableBytes() < 4) { // Not enough for Teltonika data length field\n                return null;\n            }\n            buf.readUnsignedInt(); // data length field for TCP (value not directly used, framing handled by Netty)\n        }\n\n        if (buf.readableBytes() < 2) { // Not enough for codec and count\n            return null;\n        }\n        int codec = buf.readUnsignedByte();\n        int count = buf.readUnsignedByte();\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n        // Assuming device and model will be available as per test setup; production code might need null checks\n        String model = getCacheManager().getObject(Device.class, deviceSession.getDeviceId()).getModel();\n\n        for (int i = 0; i < count; i++) {\n            Position position = new Position(getProtocolName());\n\n            position.setDeviceId(deviceSession.getDeviceId());\n            position.setValid(true); // Default to true, can be overridden by specific decoders\n\n            if (codec == CODEC_13) {\n                // Check for enough bytes for CODEC_13 record header: type (1) + lengthField (4) + timestamp (4)\n                if (buf.readableBytes() < (1 + 4 + 4)) {\n                    break; // Stop processing records for this packet if header is incomplete\n                }\n                int externalDeviceType = buf.readUnsignedByte();\n                int lengthField = buf.readInt();\n                // Teltonika timestamp is in seconds, convert to milliseconds for Date constructor\n                getLastLocation(position, new Date(buf.readUnsignedInt() * 1000L));\n                int dataLength = lengthField - 4; // Subtract timestamp length\n\n                if (dataLength < 0) {\n                    // Invalid data length (e.g., lengthField < 4)\n                    break; // Stop processing records\n                }\n                if (buf.readableBytes() < dataLength) {\n                    // Not enough data in buffer for the declared payload length\n                    break; // Stop processing records\n                }\n\n                if (dataLength == 0) {\n                    // No actual data payload to process\n                } else if (externalDeviceType == 0x06) { // iButton reader\n                    String rawDataString;\n                    if (isPrintable(buf, dataLength)) {\n                        rawDataString = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString().trim();\n                    } else {\n                        rawDataString = ByteBufUtil.hexDump(buf.readSlice(dataLength));\n                    }\n\n                    if (rawDataString.startsWith(\"GTSL|\")) {\n                        String[] parts = rawDataString.split(\"\\\\|\");\n                        if (parts.length >= 5) { // Expecting at least GTSL, id, type, len, value\n                            position.set(Position.KEY_DRIVER_UNIQUE_ID, parts[4]);\n                        } else {\n                            // Malformed GTSL string, store raw string in KEY_RESULT as a fallback\n                            position.set(Position.KEY_RESULT, rawDataString);\n                        }\n                    } else {\n                        // If not \"GTSL\" format, assume the raw string itself is the driver ID\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, rawDataString);\n                    }\n                } else { // Other external device types under CODEC_13\n                    if (isPrintable(buf, dataLength)) {\n                        position.set(Position.KEY_RESULT,\n                                buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString().trim());\n                    } else {\n                        position.set(Position.KEY_RESULT,\n                                ByteBufUtil.hexDump(buf.readSlice(dataLength)));\n                    }\n                }\n            } else if (codec == CODEC_12) {\n                decodeSerial(channel, remoteAddress, deviceSession, position, buf);\n            } else {\n                decodeLocation(position, buf, codec, model);\n            }\n\n            // Add position if it's not outdated or if it has any attributes (even if outdated)\n            if (!position.getOutdated() || !position.getAttributes().isEmpty()) {\n                positions.add(position);\n            }\n        }\n\n        if (channel != null && codec != CODEC_12 && codec != CODEC_13) {\n            ByteBuf response = Unpooled.buffer();\n            if (connectionless) {\n                response.writeShort(5);\n                response.writeShort(0);\n                response.writeByte(0x01);\n                response.writeByte(locationPacketId);\n                response.writeByte(count);\n            } else {\n                response.writeInt(count);\n            }\n            channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n        }\n\n        return positions.isEmpty() ? null : positions;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}