{
    "generation": "    private List<Position> parseData(\n            Channel channel, SocketAddress remoteAddress, ByteBuf buf, int locationPacketId, String... imei) {\n        List<Position> positions = new LinkedList<>();\n\n        // For connection-oriented protocols (TCP), TeltonikaFrameDecoder typically handles\n        // preamble and data length. 'buf' should start directly with Codec ID.\n        // The following block was causing misaligned reads for TCP.\n        // if (!connectionless) {\n        //     buf.readUnsignedInt(); // data length - REMOVED\n        // }\n\n        int codec = buf.readUnsignedByte();\n        int count = buf.readUnsignedByte();\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n        String model = getCacheManager().getObject(Device.class, deviceSession.getDeviceId()).getModel();\n\n        for (int i = 0; i < count; i++) {\n            Position position = new Position(getProtocolName());\n\n            position.setDeviceId(deviceSession.getDeviceId());\n            position.setValid(true);\n\n            if (codec == CODEC_13) {\n                buf.readUnsignedByte(); // type (e.g., command type)\n                int dataPacketLength = buf.readInt(); // Length of the following data (timestamp + string)\n                int stringLength = dataPacketLength - 4; // Subtract 4 bytes for the timestamp field\n\n                // Assuming the next 4 bytes are a timestamp, as per original logic structure\n                Date timestamp = new Date(buf.readUnsignedInt() * 1000L);\n                getLastLocation(position, timestamp); // Sets fixTime and potentially other last known data\n\n                if (stringLength > 0) {\n                    if (isPrintable(buf, stringLength)) {\n                        String resultString = buf.readCharSequence(stringLength, StandardCharsets.US_ASCII).toString().trim();\n                        position.set(Position.KEY_RESULT, resultString);\n\n                        // Parse driver ID from specific command responses like \"GTSL|...|driverId|...\"\n                        if (resultString.startsWith(\"GTSL|\")) {\n                            String[] parts = resultString.split(\"\\\\|\");\n                            if (parts.length >= 5) { // parts[4] is expected to be driverId\n                                String driverId = parts[4];\n                                if (!driverId.isEmpty()) {\n                                    position.set(Position.KEY_DRIVER_UNIQUE_ID, driverId);\n                                }\n                            }\n                        }\n                    } else {\n                        position.set(Position.KEY_RESULT, ByteBufUtil.hexDump(buf.readSlice(stringLength)));\n                    }\n                } else if (stringLength == 0) {\n                    position.set(Position.KEY_RESULT, \"\"); // Empty string if length is exactly zero\n                }\n                // If stringLength < 0, it indicates a malformed packet section; KEY_RESULT remains unset.\n                // The buffer's readerIndex is already advanced past type, dataPacketLength, and timestamp.\n\n            } else if (codec == CODEC_12) {\n                decodeSerial(channel, remoteAddress, deviceSession, position, buf);\n            } else {\n                decodeLocation(position, buf, codec, model);\n            }\n\n            if (!position.getOutdated() || !position.getAttributes().isEmpty()) {\n                positions.add(position);\n            }\n        }\n\n        if (channel != null && codec != CODEC_12 && codec != CODEC_13) {\n            ByteBuf response = Unpooled.buffer();\n            if (connectionless) {\n                response.writeShort(5);\n                response.writeShort(0);\n                response.writeByte(0x01);\n                response.writeByte(locationPacketId);\n                response.writeByte(count);\n            } else {\n                response.writeInt(count);\n            }\n            channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n        }\n\n        return positions.isEmpty() ? null : positions;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}