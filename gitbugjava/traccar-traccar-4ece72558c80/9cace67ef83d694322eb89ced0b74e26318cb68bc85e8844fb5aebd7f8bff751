{
    "generation": "    private List<Position> parseData(\n            Channel channel, SocketAddress remoteAddress, ByteBuf buf, int locationPacketId, String... imei) {\n        List<Position> positions = new LinkedList<>();\n\n        if (!connectionless) {\n            buf.readUnsignedInt(); // data length\n        }\n\n        int codec = buf.readUnsignedByte();\n        int count = buf.readUnsignedByte();\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            // If no session, we can't associate data but might still need to process for ACK\n            if (channel != null && codec != CODEC_12 && codec != CODEC_13) {\n                sendResponse(channel, remoteAddress, connectionless, locationPacketId, (byte) count);\n            }\n            return null;\n        }\n        String model = getCacheManager().getObject(Device.class, deviceSession.getDeviceId()).getModel();\n\n        for (int i = 0; i < count; i++) {\n            Position position = new Position(getProtocolName());\n\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            if (codec == CODEC_13) {\n                buf.readUnsignedByte(); // type\n                int length = buf.readInt() - 4; // length includes timestamp\n                Date time = new Date(buf.readUnsignedInt() * 1000); // read timestamp\n                getLastLocation(position, time); // Get previous location data first\n                position.setTime(time); // Set the time from the packet\n\n                if (length > 0) {\n                    if (isPrintable(buf, length)) {\n                        String data = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString().trim();\n                        // Special handling for GTSL driver message format\n                        if (data.startsWith(\"GTSL|\")) {\n                            String[] parts = data.split(\"\\\\|\");\n                            if (parts.length >= 5) {\n                                position.set(Position.KEY_DRIVER_UNIQUE_ID, parts[4]);\n                                // Keep other potentially useful info in result if needed\n                                // position.set(Position.KEY_RESULT, data);\n                            } else {\n                                position.set(Position.KEY_RESULT, data); // Fallback if format is unexpected\n                            }\n                        } else {\n                            position.set(Position.KEY_RESULT, data); // Store other printable data\n                        }\n                    } else {\n                        position.set(Position.KEY_RESULT,\n                                ByteBufUtil.hexDump(buf.readSlice(length)));\n                    }\n                } else {\n                    // If length is 0, still create a position with timestamp and last location\n                    position.setValid(true); // Assume valid if we have a timestamp\n                }\n            } else if (codec == CODEC_12) {\n                decodeSerial(channel, remoteAddress, deviceSession, position, buf);\n            } else {\n                decodeLocation(position, buf, codec, model);\n            }\n\n            // Add position if it's valid or has any attributes (like driver ID from CODEC_13)\n            if (position.getValid() || !position.getAttributes().isEmpty()) {\n                 // Ensure outdated status is correctly determined after all potential data setting\n                 if (position.getFixTime() == null) {\n                     getLastLocation(position, position.getDeviceTime()); // Try again if fix time wasn't set\n                 }\n                 positions.add(position);\n            }\n        }\n\n        if (channel != null && codec != CODEC_12 && codec != CODEC_13) {\n            sendResponse(channel, remoteAddress, connectionless, locationPacketId, (byte) count);\n        }\n\n        return positions.isEmpty() ? null : positions;\n    }\n\n    private void sendResponse(Channel channel, SocketAddress remoteAddress, boolean connectionless, int locationPacketId, byte count) {\n        ByteBuf response = Unpooled.buffer();\n        if (connectionless) {\n            response.writeShort(5); // length\n            response.writeShort(0); // packet id\n            response.writeByte(0x01); // type\n            response.writeByte(locationPacketId); // location packet id\n            response.writeByte(count); // number of accepted records\n        } else {\n            response.writeInt(count); // number of accepted records\n        }\n        channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}