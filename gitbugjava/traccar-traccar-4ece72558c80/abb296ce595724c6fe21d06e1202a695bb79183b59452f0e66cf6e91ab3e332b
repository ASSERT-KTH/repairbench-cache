{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport org.traccar.model.Device;\nimport org.traccar.model.NetworkMessage;\nimport org.traccar.model.Position;\nimport org.traccar.session.DeviceSession;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.LinkedList;\nimport java.util.List;\n\n// Class definition and other methods are omitted for brevity.\n// Assume necessary helper methods (getDeviceSession, getCacheManager, getProtocolName, getLastLocation, isPrintable, decodeSerial, decodeLocation)\n// and constants (CODEC_12, CODEC_13) exist within the TeltonikaProtocolDecoder class scope.\n\n    private List<Position> parseData(\n            Channel channel, SocketAddress remoteAddress, ByteBuf buf, int locationPacketId, String... imei) {\n        List<Position> positions = new LinkedList<>();\n\n        // Framing (like length prefix in TCP) should be handled by the pipeline before this decoder method.\n        // UDP framing might be handled in the main decode method before calling parseData.\n        // Therefore, buf should start directly with the Teltonika AVL data payload (Codec ID, Num Records, ...).\n        // Removed incorrect read of data length that was previously here based on `connectionless` flag.\n\n        // Check if buffer is readable before attempting to read codec and count\n        if (buf.readableBytes() < 2) {\n             // Not enough data for mandatory codec and count fields\n             return null;\n        }\n\n        int codec = buf.readUnsignedByte();\n        int count = buf.readUnsignedByte();\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            // Cannot process data without a device session, log?\n            return null;\n        }\n\n        // Get device model safely, handling potential null CacheManager or Device\n        String model = null;\n        if (getCacheManager() != null) {\n            Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n            if (device != null) {\n                model = device.getModel();\n            }\n        }\n\n        for (int i = 0; i < count; i++) {\n            // Ensure buffer is readable before processing each record's data\n            if (!buf.isReadable()) {\n                 // Log warning: Buffer exhausted before reading all expected records\n                 break;\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            // Validity is usually determined within decodeLocation based on GPS data.\n            // Initialize as false, might be overridden by decodeLocation or getLastLocation.\n            position.setValid(false);\n\n            if (codec == CODEC_13) {\n                // Text data packet (e.g., response to SMS command, iButton string)\n                // Structure: Type (1 byte), Total Length (4 bytes), Timestamp (4 bytes), Data (variable)\n                if (buf.readableBytes() < 1 + 4 + 4) { // Check for Type, Length, Timestamp fields presence\n                    // Log warning: Not enough data in buffer for CODEC_13 header\n                    break;\n                }\n                buf.readUnsignedByte(); // Consume Type field (e.g., 0x06 for command responses)\n                int totalLength = buf.readInt(); // Includes timestamp length (4 bytes)\n                long timeMillis = buf.readUnsignedInt() * 1000L; // Timestamp from packet\n\n                // Use getLastLocation to set time and potentially copy last known coordinates\n                // This also helps set network information if available from getLastLocation's logic\n                getLastLocation(position, new Date(timeMillis));\n                // Ensure the time from the packet is set, even if no previous location was found\n                if (position.getFixTime() == null) {\n                    position.setTime(new Date(timeMillis));\n                }\n\n                int stringLength = totalLength - 4; // Calculate length of the actual text data part\n\n                if (stringLength < 0) {\n                    // Log error: Negative string length indicated in CODEC_13 packet\n                    stringLength = 0; // Treat as no string data\n                }\n\n                // Check if announced string length exceeds available bytes\n                if (stringLength > buf.readableBytes()) {\n                    // Log error: Announced CODEC_13 string length exceeds available buffer bytes\n                    stringLength = buf.readableBytes(); // Clamp length to available bytes to prevent Overread error\n                }\n\n                if (stringLength > 0) {\n                    // Read the data part into a slice\n                    ByteBuf dataSlice = buf.readSlice(stringLength);\n                    // Check printability using the slice, does not modify reader index of slice\n                    if (isPrintable(dataSlice, stringLength)) {\n                        String data = dataSlice.toString(StandardCharsets.US_ASCII).trim();\n                        position.set(Position.KEY_RESULT, data); // Store the raw/trimmed text data\n\n                        // --- BEGIN FIX ---\n                        // Attempt to parse known text formats to extract specific attributes\n                        String[] parts = data.split(\"\\\\|\");\n                        // Example: Parse \"GTSL\" format which often contains iButton/Driver ID\n                        if (parts.length >= 5 && \"GTSL\".equals(parts[0])) {\n                            String driverId = parts[4];\n                            // Teltonika often sends \"0\" or empty string if no iButton is attached/read\n                            if (driverId != null && !driverId.isEmpty() && !driverId.equals(\"0\")) {\n                                position.set(Position.KEY_DRIVER_UNIQUE_ID, driverId);\n                            }\n                            // Potentially parse other fields from GTSL if their meaning is known\n                        }\n                        // Add parsing rules for other known CODEC_13 text message formats here if necessary\n                        // --- END FIX ---\n\n                    } else {\n                        // Store non-printable data as hex string\n                        position.set(Position.KEY_RESULT, ByteBufUtil.hexDump(dataSlice));\n                    }\n                }\n                // If stringLength was 0 or negative, KEY_RESULT is not set from payload.\n\n                // Add the position regardless of GPS validity, as CODEC_13 carries attribute/command data\n                positions.add(position);\n\n            } else if (codec == CODEC_12) {\n                // Serial data packet (e.g., RFID, Garmin FMI messages)\n                // decodeSerial is responsible for reading from buf and populating the position object.\n                decodeSerial(channel, remoteAddress, deviceSession, position, buf);\n                // Only add if decodeSerial actually populated something meaningful (e.g., attributes)\n                if (!position.getAttributes().isEmpty()) {\n                    positions.add(position);\n                }\n\n            } else {\n                // Standard AVL data packet (Codec 8, 8E, 16 etc.)\n                // decodeLocation is responsible for reading from buf and populating the position object.\n                decodeLocation(position, buf, codec, model);\n                // Add the position if it's considered valid (usually means has GPS fix) or has any attributes decoded\n                if (position.getValid() || !position.getAttributes().isEmpty()) {\n                    positions.add(position);\n                }\n            }\n        }\n\n        // Send acknowledgment response for relevant codecs and connection types\n        // Use the original 'count' read from the packet header for the response value.\n        if (channel != null && codec != CODEC_12 && codec != CODEC_13) {\n            if (connectionless) { // UDP Response structure\n                 ByteBuf response = Unpooled.buffer(5);\n                 response.writeShort(5); // Packet Length field\n                 response.writeShort(0); // Packet ID field (seems hardcoded to 0)\n                 response.writeByte(0x01); // Type field (seems hardcoded to 1)\n                 response.writeByte(locationPacketId); // Echo back ID from UDP header parsing step\n                 response.writeByte(count); // Number of records acknowledged\n                 channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n            } else { // TCP Response structure\n                 ByteBuf response = Unpooled.buffer(4);\n                 response.writeInt(count); // Number of records acknowledged\n                 channel.writeAndFlush(new NetworkMessage(response, remoteAddress));\n            }\n        }\n\n        return positions.isEmpty() ? null : positions;\n    }\n\n    // Assume isPrintable helper method exists and checks buffer slice without consuming its reader index:\n    // Example:\n    // private boolean isPrintable(ByteBuf buf, int len) {\n    //     int initialReaderIndex = buf.readerIndex();\n    //     for (int i = 0; i < len; i++) {\n    //         byte b = buf.getByte(initialReaderIndex + i);\n    //         if (b < 32 && b != '\\r' && b != '\\n' && b != '\\t') {\n    //             return false;\n    //         }\n    //     }\n    //     return true;\n    // }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}