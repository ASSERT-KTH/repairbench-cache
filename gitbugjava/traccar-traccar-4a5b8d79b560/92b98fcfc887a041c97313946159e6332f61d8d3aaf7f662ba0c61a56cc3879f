{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        String sentence = (String) msg;\n        int firstPipe = sentence.indexOf('|');\n        int lastPipe = sentence.lastIndexOf('|');\n        if (firstPipe == -1 || lastPipe == -1 || lastPipe <= firstPipe) {\n            return null; // Not a valid message format\n        }\n        sentence = sentence.substring(firstPipe + 1, lastPipe);\n\n        Position position = new Position();\n        position.setProtocol(getProtocolName());\n        DeviceSession deviceSession = null;\n\n        for (String entry : sentence.split(\",\")) {\n            int delimiter = entry.indexOf('=');\n            if (delimiter <= 0 || delimiter >= entry.length() - 1) { // Ensure key and value exist\n                continue; // Skip malformed entries\n            }\n            String key = entry.substring(0, delimiter).trim(); // Trim whitespace\n            String value = entry.substring(delimiter + 1).trim(); // Trim whitespace\n\n            // Skip empty keys or values, unless a specific key allows empty value\n            if (key.isEmpty() || value.isEmpty()) {\n                continue;\n            }\n\n            try { // Wrap parsing logic in try-catch to handle potential format errors\n                switch (key) {\n                    case \"unit\":\n                        deviceSession = getDeviceSession(channel, remoteAddress, value);\n                        if (deviceSession != null) {\n                            position.setDeviceId(deviceSession.getDeviceId());\n                        } else {\n                            // Log missing device session?\n                        }\n                        break;\n                    case \"gps_valid\":\n                        position.setValid(Integer.parseInt(value) != 0);\n                        break;\n                    case \"datetime_actual\":\n                        // Use existing time if already set (e.g., from datetime_utc if it came first)\n                        if (position.getFixTime() == null) {\n                           position.setTime(new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\").parse(value));\n                        }\n                        break;\n                    case \"datetime_utc\":\n                         // Allow UTC time to override device time if present, assuming it's more accurate\n                         position.setTime(new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\").parse(value));\n                         break;\n                    case \"latitude\":\n                        position.setLatitude(Double.parseDouble(value));\n                        break;\n                    case \"longitude\":\n                        position.setLongitude(Double.parseDouble(value));\n                        break;\n                    case \"altitude\":\n                        position.setAltitude(Double.parseDouble(value));\n                        break;\n                    case \"velocity\":\n                        position.setSpeed(UnitsConverter.knotsFromKph(Integer.parseInt(value)));\n                        break;\n                    case \"heading\":\n                        position.setCourse(Integer.parseInt(value));\n                        break;\n                    case \"eventid\":\n                        position.set(Position.KEY_EVENT, Integer.parseInt(value));\n                        break;\n                    case \"mileage\":\n                        position.set(Position.KEY_ODOMETER, (long) (Double.parseDouble(value) * 1000));\n                        break;\n                    // Handle 'odometer' field if present, potentially overriding 'mileage'\n                    case \"odometer\":\n                        position.set(Position.KEY_ODOMETER, Long.parseLong(value)); // Assuming meters\n                        break;\n                    case \"satellites\":\n                        position.set(Position.KEY_SATELLITES, Integer.parseInt(value));\n                        break;\n                    case \"ignition\":\n                        position.set(Position.KEY_IGNITION, Integer.parseInt(value) != 0);\n                        break;\n                    case \"door\":\n                        position.set(Position.KEY_DOOR, Integer.parseInt(value) != 0);\n                        break;\n                    case \"arm\":\n                        position.set(Position.KEY_ARMED, Integer.parseInt(value) != 0);\n                        break;\n                    case \"fuel\":\n                        position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(value));\n                        break;\n                    case \"rpm\":\n                        position.set(Position.KEY_RPM, Integer.parseInt(value));\n                        break;\n                    case \"main_voltage\":\n                        position.set(Position.KEY_POWER, Double.parseDouble(value));\n                        break;\n                    case \"backup_voltage\":\n                        position.set(Position.KEY_BATTERY, Double.parseDouble(value));\n                        break;\n                    case \"analog1\":\n                    case \"analog2\":\n                    case \"analog3\":\n                        position.set(Position.PREFIX_ADC + (key.charAt(key.length() - 1) - '0'), Double.parseDouble(value));\n                        break;\n                    // FIX: Handle immobilizer explicitly as boolean\n                    case \"immobilizer\":\n                        position.set(Position.KEY_IMMOBILIZER, Integer.parseInt(value) != 0);\n                        break;\n                    case \"emergency\": // Often maps to SOS\n                        boolean sos = Integer.parseInt(value) != 0;\n                        position.set(Position.KEY_SOS, sos);\n                        if (sos) {\n                            position.set(Position.KEY_ALARM, org.traccar.model.Alarm.ALARM_SOS);\n                        }\n                        break;\n                    case \"lock\": // Map to KEY_LOCK if it represents door lock status\n                        position.set(Position.KEY_LOCK, Integer.parseInt(value) != 0);\n                        break;\n                    case \"extra1\":\n                    case \"extra2\":\n                    case \"extra3\":\n                        // Fall-through intended\n                    default:\n                        position.set(key, value); // Store other fields as string attributes\n                        break;\n                }\n            } catch (NumberFormatException | java.text.ParseException e) {\n                // Log parsing exception for the specific key/value?\n                // Log.warning(\"Failed to parse Starcom field: \" + key + \"=\" + value + \" - \" + e.getMessage());\n            }\n        }\n\n        // Ensure deviceId is set if position is otherwise valid\n        if (position.getDeviceId() == 0 && deviceSession != null) {\n             position.setDeviceId(deviceSession.getDeviceId());\n        }\n\n        // Return position only if essential fields are present\n        if (position.getDeviceId() != 0 && position.getFixTime() != null) {\n            return position;\n        } else {\n            // Log discarded message due to missing essential info?\n            return null; // Or return partial position depending on requirements\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}