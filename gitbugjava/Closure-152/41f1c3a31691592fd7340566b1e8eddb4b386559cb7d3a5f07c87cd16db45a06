{
    "generation": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    // Resolve call signature (ArrowType)\n    call = (ArrowType) safeResolve(call, t, scope);\n    // Resolve prototype (FunctionPrototypeType)\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Resolve 'this' type\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    JSType resolvedTypeOfThis = safeResolve(typeOfThis, t, scope);\n\n    // Check if the resolved type is actually an ObjectType.\n    // The field 'typeOfThis' expects an ObjectType.\n    if (resolvedTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) resolvedTypeOfThis;\n    } else if (resolvedTypeOfThis == null) {\n      // If safeResolve returns null (e.g., original type was null), assign null.\n      typeOfThis = null;\n    } else {\n      // Resolved to a non-ObjectType (like UnionType, PrimitiveType).\n      // The field type demands an ObjectType, so we assign a fallback.\n      // Using UNKNOWN_TYPE's object representation prevents ClassCastException.\n      // The upstream validation should still catch the invalid @this type.\n      // Note: This loses the specific resolved type information in the 'typeOfThis' field.\n      typeOfThis = registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n\n    // Resolve implemented interfaces (ObjectTypes)\n    if (implementedInterfaces != null) {\n        boolean changed = false;\n        ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n        for (ObjectType iface : implementedInterfaces) {\n            // Interfaces must resolve to ObjectType. Cast is expected to succeed,\n            // or indicates an error reported elsewhere. Use safeResolve for null safety on input 'iface'.\n            ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n            // Assume resolvedIface is not null if input iface was not null, otherwise\n            // the cast or subsequent operations might fail (same as original code).\n            resolvedInterfaces.add(resolvedIface);\n            changed |= (resolvedIface != iface);\n        }\n        if (changed) {\n            implementedInterfaces = resolvedInterfaces.build();\n        }\n    }\n\n    // Resolve subtypes (FunctionTypes)\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        // Subtypes must resolve to FunctionType. Cast is expected to succeed.\n        // Use safeResolve for null safety on input element.\n        subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n      }\n    }\n\n    // Delegate to superclass for common resolution steps (like type parameters)\n    return super.resolveInternal(t, scope);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}