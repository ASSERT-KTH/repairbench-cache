{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // Determine if the parent element is intrinsically block or is formatting as block.\n        // Use tag.formatAsBlock() which considers block status & content if applicable.\n        final boolean parentFormatAsBlock = parent != null && parent.tag().formatAsBlock();\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Use parentFormatAsBlock for both leading and trailing trim checks for consistency.\n            // Trim leading if first node in a block-like parent or the document root.\n            trimLeading = (siblingIndex == 0 && parentFormatAsBlock) ||\n                parentNode instanceof Document;\n            // Trim trailing if the last node in a block-like parent.\n            trimTrailing = (nextSibling() == null) && parentFormatAsBlock;\n\n            // If this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = nextSibling();\n            boolean isBlank = isBlank(); // cache isBlank result\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next element will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text\n            if (couldSkip && isBlank) return; // Don't output blank space that is just filling previous indent space.\n\n            // Indentation check - Handle indent for non-blank text nodes in specific contexts:\n            Node prev = previousSibling();\n            if (\n                // If the first child of block-like parent, and not blank, indent. And not suppressed by parent.\n                (siblingIndex == 0 && parentFormatAsBlock && !isBlank && parent.shouldIndent(out)) ||\n                // If in outline mode, and siblings exist, and not blank, indent\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                // If follows a <br> tag, and not blank, indent\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\") && !isBlank)\n            ) {\n                indent(accum, depth, out);\n            }\n        }\n\n        // Escape and print, using determined trim flags and normalise flag. The escape method handles the StringUtil.normaliseWhitespace call internally.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}