{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // parent() might be null if this is a Document node, but this is a TextNode.\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // Element.preserveWhitespace gets the effective preserve attribute from this node, or any parent.\n        // If a custom tag's parent (e.g. <pre>) preserves whitespace, then normaliseWhite will be false.\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // if this text is just whitespace, and the parent is a block, trim the leading space\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                (parentNode instanceof Document); // first node in document. Calculated from parentNode not parent, as Document isn't Element.\n\n            // if this text is just whitespace, and the parent is a block, trim the trailing space\n            trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock());\n            // the above is the original line. If the issue is specific to custom (unknown) tags being too aggressively treated as block:\n            // one might consider: trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock() && parent.tag().isKnownTag());\n            // However, this would preserve a trailing newline text node, leading to \\n\\n</customTag> which is usually not desired.\n            // The existing logic seems more robust for the common case.\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = nextSibling();\n            boolean isBlank = isBlank(); // check if this TextNode is all whitespace\n            boolean couldSkip = false;\n            if (next instanceof Element) {\n                couldSkip = ((Element) next).shouldIndent(out); // next element will indent\n            } else if (next instanceof TextNode) {\n                couldSkip = ((TextNode) next).isBlank(); // next is blank text (e.g. from re-parenting or multiple ws nodes)\n            }\n            // note that this is a \"optimistic\" skip. If the next node is skipped for other reasons, this node might reappear.\n            // And can't skip if this is the last node in a preservewhitespace parent.\n            if (couldSkip && isBlank && !Element.preserveWhitespace(parent)) { // added !preserveWhitespace(parent) to be very sure\n                return;\n            }\n\n\n            Node prev = previousSibling();\n            // if this text is on a new line (either at start of parent, or after outline, or after a <br>)\n            // and it's not blank (ignore GIGO), then indent it\n            if (\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (prev instanceof Element && ((Element) prev).tag().normalName().equals(\"br\")) // special case wrap on inline <br>\n                // was: (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) which missed firstchild after br\n            ) {\n                indent(accum, depth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}