{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        // Move isBlank declaration to a scope where it's accessible by all its usages.\n        // In the original buggy code, 'isBlank' was defined inside the 'if (normaliseWhite)' block,\n        // but then used outside it in the 'indent' condition, which would be a compile error.\n        boolean isBlank = isBlank();\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n\n        if (normaliseWhite) {\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document;\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // Original bug: if (couldSkip && isBlank) return;\n            // This line prematurely returned for blank text nodes, preventing necessary newlines/spaces\n            // for pretty-printing, assuming the next element would handle it correctly.\n            // Removing this line allows the text node to proceed to output.\n            // The logic for 'couldSkip' (and 'next') is now unused but harmless if this line is removed.\n            // Node next = nextSibling(); // This line and 'couldSkip' are no longer needed\n            // boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n            //     || (next instanceof TextNode && (((TextNode) next).isBlank()));\n            // if (couldSkip && isBlank) return; // REMOVED\n        }\n\n        Node prev = previousSibling();\n        if (\n            (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n            (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n            (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // special case wrap on inline <br> - doesn't make sense as a block tag\n        )\n            indent(accum, depth, out);\n\n        // Original bug: Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n        // Problem: When pretty-printing a blank text node (e.g., \"\\n\"), trimLeading/trimTrailing\n        // could remove the entire formatting content.\n        // Fix: Pass trimLeading and trimTrailing as false if the text node is purely blank.\n        // This ensures formatting newlines are not incorrectly stripped.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading && !isBlank, trimTrailing && !isBlank);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}