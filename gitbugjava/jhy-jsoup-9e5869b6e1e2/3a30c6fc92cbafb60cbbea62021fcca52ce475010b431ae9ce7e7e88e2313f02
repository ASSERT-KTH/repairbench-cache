{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        // Calculate trim leading/trailing flags that will be passed to Entities.escape.\n        // These are based on the parent's actual block status (e.g., div, p, not custom elements by default).\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n\n        // Determine if this TextNode is blank (contains only whitespace)\n        boolean isBlank = isBlank();\n\n        // Calculate if we have preceding or following newlines from surrounding elements\n        // This is crucial for fixing pretty-printing for custom elements that should behave as blocks.\n        // It relies on Element.shouldIndent() being able to determine if an element (including custom ones)\n        // should cause an indent (e.g., if it contains block-level children).\n        boolean hasPrecedingNewline = false;\n        // boolean hasFollowingNewline = false; // Not directly used in the final logic for TextNode\n        if (prettyPrint) {\n            if (parent != null) {\n                // If it's the first child and parent should indent, then there's a preceding newline.\n                hasPrecedingNewline = (siblingIndex == 0 && parent.shouldIndent(out));\n                // If it's the last child and parent should indent, then there's a following newline.\n                // hasFollowingNewline = (nextSibling() == null && parent.shouldIndent(out)); // Not used here\n            }\n            // If previous sibling is an element and it should indent, then there's a preceding newline.\n            if (!hasPrecedingNewline && previousSibling() instanceof Element) {\n                hasPrecedingNewline = ((Element) previousSibling()).shouldIndent(out);\n            }\n            // If next sibling is an element and it should indent, then there's a following newline.\n            // if (!hasFollowingNewline && nextSibling() instanceof Element) { // Not used here\n            //     hasFollowingNewline = ((Element) nextSibling()).shouldIndent(out);\n            // }\n        }\n\n        // If this text is just whitespace, and the next node will cause an indent, skip this text:\n        Node next = nextSibling();\n        boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n            || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n\n        if (normaliseWhite) {\n            // If this blank text node is preceded by a structural newline (from parent or previous sibling),\n            // then this text node is purely structural whitespace. It should output an indent and return.\n            // This prevents its content (e.g., `\\n ` or `  `) from being normalized to a single space.\n            if (isBlank && hasPrecedingNewline) {\n                indent(accum, depth, out);\n                return; // The text node is handled by indent; its content is not outputted.\n            }\n            // If it's blank and the next node would cause an indent (and it's not handled by the above `hasPrecedingNewline`),\n            // skip it entirely.\n            if (couldSkip && isBlank) {\n                 return;\n            }\n\n            // `trimLeading` and `trimTrailing` are applied to the TextNode's content via Entities.escape.\n            // They rely on the parent's actual block tag status, not its formatting behavior.\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) || parentNode instanceof Document;\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // The old complex `indent` condition was removed in Jsoup 1.15.2, as its logic is now\n            // either handled by `Element.outerHtml`'s `shouldIndent` checks or by the `hasPrecedingNewline` logic above.\n        }\n\n        // For non-blank text nodes, or if normaliseWhite is false,\n        // or if it's a blank node that wasn't covered by the structural newline handling (e.g., just spaces between inline elements),\n        // output its content, applying normalisation and trimming as determined.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}