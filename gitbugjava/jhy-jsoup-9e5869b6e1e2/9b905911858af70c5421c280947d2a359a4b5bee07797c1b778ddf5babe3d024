{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // trimLeading: e.g. \"  Hello\" -> \"Hello\" OR \"<div>  Hello\" -> \"<div>Hello\"\n            // If this text is the first child of a block-formatted parent (e.g. custom tags), trim leading whitespace.\n            // Also if it's directly inside the Document body (which is often a block-like context).\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock()) ||\n                          parentNode instanceof Document;\n            // trimTrailing: e.g. \"Hello  \" -> \"Hello\" OR \"Hello  </div>\" -> \"Hello</div>\"\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().formatAsBlock();\n\n            Node next = nextSibling();\n            boolean isBlank = isBlank();\n            \n            // Determine if the current text node consists only of newlines (and carriage returns).\n            // Such text nodes are often introduced by the pretty printer or represent structural line breaks.\n            // They should generally not be skipped if they precede an indentable element, as they serve for formatting.\n            boolean isOnlyNewlines = coreValue().matches(\"^[\\\\n\\\\r]+$\"); \n\n            // Skip if:\n            // 1. The current text node is blank AND (\n            //    a. The next node is an Element that should indent, AND the current text node is NOT just newlines.\n            //       (This covers cases like \" \\n \" where the spaces are dangling and should be removed if followed by an indentable block)\n            //    OR\n            //    b. The next node is also a blank TextNode.\n            //       (This covers redundant blank text nodes like \"a  \\n \\n  b\" -> \"a \\n b\")\n            // )\n            boolean couldSkip = isBlank && (\n                (next instanceof Element && ((Element) next).shouldIndent(out) && !isOnlyNewlines) ||\n                (next instanceof TextNode && (((TextNode) next).isBlank()))\n            );\n            if (couldSkip) return;\n\n            Node prev = previousSibling();\n            if (\n                // If this is the first child of a block-formatted parent, always indent\n                // (Even if the text is blank, if it's the first child, it should cause indentation for subsequent elements)\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock()) ||\n                // If outlining is enabled and there are siblings, and text is not blank, indent\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                // Special case: wrap on inline <br> - doesn't make sense as a block tag\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) \n            )\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}