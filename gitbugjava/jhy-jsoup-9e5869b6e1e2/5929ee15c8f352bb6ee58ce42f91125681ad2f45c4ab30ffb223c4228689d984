{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        // Determine if the parent element should be formatted as a block for pretty printing.\n        // This is crucial for custom elements (like <bar> in the test) that contain block-level content,\n        // which should cause their text nodes to trim and contribute to proper indentation.\n        // We assume that the Element.isBlock() method on the parent element reflects this formatting intent\n        // (as per the fix for Jsoup issue 1852, where Element.isBlock() became aware of content).\n        final boolean parentFormatsAsBlock = parent != null ? parent.isBlock() : (parentNode instanceof Document);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Trim leading whitespace if this is the first child of a block-formatting parent\n            // or if the parent is the Document itself.\n            trimLeading = (siblingIndex == 0 && parentFormatsAsBlock) || parentNode instanceof Document;\n            // Trim trailing whitespace if this is the last child of a block-formatting parent.\n            trimTrailing = nextSibling() == null && parentFormatsAsBlock;\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = nextSibling();\n            boolean isBlank = isBlank();\n            // Skip this text node if it's blank and the next node is an Element that will indent,\n            // or if the next node is also a blank TextNode (e.g., from re-parenting).\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n                || (next instanceof TextNode && (((TextNode) next).isBlank()));\n            if (couldSkip && isBlank) {\n                return; // Skip this text node entirely.\n            }\n\n            Node prev = previousSibling();\n            // Indent based on whether this text node is the first child of a block-formatting parent,\n            // or if outline mode is enabled, or if the previous sibling was a <br> (special case).\n            if (\n                (siblingIndex == 0 && parentFormatsAsBlock && !isBlank) || // first child of a block-formatting parent (and not blank)\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) || // outline mode (and not blank)\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // previous was <br>\n            ) {\n                indent(accum, depth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}