{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        final String core = coreValue();\n        final boolean isBlank = isBlank(); // Calculate once\n\n        // Determine if normalization should *actually* be applied by Entities.escape\n        // Don't normalize if node is blank and we are pretty printing (normaliseWhite=true),\n        // as that would collapse structural newlines to spaces.\n        final boolean shouldNormalise = normaliseWhite && !isBlank;\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n\n        if (normaliseWhite) { // Check if pretty print context applies for skip/trim/indent logic\n             // Calculate trim flags based on block context (still needed for Entities.escape)\n             trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                 parentNode instanceof Document;\n             trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n             // Original skip logic: if this text is just whitespace, and the next node will cause an indent, skip this text:\n             Node next = nextSibling();\n             // TODO: reconsider skip logic. See https://github.com/jhy/jsoup/issues/1109\n             boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                 || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n             if (couldSkip && isBlank) return;\n\n             // Original indent logic (only triggers if !isBlank or special cases like <br>)\n             Node prev = previousSibling();\n             if (\n                 (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) || // first in block non-blank\n                 (out.outline() && siblingNodes().size() > 0 && !isBlank) ||                       // outline non-blank\n                 (prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // special case wrap on inline <br>\n             ) {\n                 indent(accum, depth, out);\n             }\n        }\n\n        // Escape the text. Use the calculated `shouldNormalise` flag instead of `normaliseWhite`.\n        Entities.escape(accum, core, out, false, shouldNormalise, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}