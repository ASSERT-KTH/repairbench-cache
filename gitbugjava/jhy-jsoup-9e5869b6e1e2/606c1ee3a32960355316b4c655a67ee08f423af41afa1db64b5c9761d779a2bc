{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentElement(); // Use helper method for parent element access\n        // Check formatAsBlock for parent, used in trim logic, as formatting behavior depends on formatAsBlock, not isBlock\n        // Check parent != null because parentElement() can return null\n        final boolean parentFormatsAsBlock = parent != null && parent.tag().formatAsBlock();\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode); // Check preserveWhitespace based on parentNode\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Use parentFormatsAsBlock for trimming decisions instead of parent.tag().isBlock()\n            // The check parentNode instanceof Document handles the case where the text node is directly under the Document node.\n            trimLeading = (siblingIndex == 0 && parentFormatsAsBlock) ||\n                parentNode instanceof Document;\n            // Use parentFormatsAsBlock for trailing trim decision\n            trimTrailing = (nextSibling() == null && parentFormatsAsBlock);\n\n            // Original skip logic: if this text is just whitespace, and the next node will cause an indent, skip this text.\n            Node next = nextSibling();\n            boolean isBlank = isBlank();\n            // Combine checks for clarity: skip if blank AND (next causes indent OR next is blank)\n            if (isBlank && next != null) { // Ensure next is not null before checking its type/properties\n                boolean nextWillIndent = (next instanceof Element && ((Element) next).shouldIndent(out));\n                boolean nextIsBlank = (next instanceof TextNode && ((TextNode) next).isBlank());\n                if (nextWillIndent || nextIsBlank) {\n                    return; // Skip this blank node\n                }\n            }\n\n            // Original indentation logic:\n            Node prev = previousSibling();\n            // Indent if:\n            // 1. First non-blank child of a block-formatting parent\n            // 2. Outline mode active and node is not blank\n            // 3. Follows an inline <br> element (original logic)\n            // Note: parentFormatsAsBlock implicitly checks parent != null\n            if (\n                (siblingIndex == 0 && parentFormatsAsBlock && !isBlank) || // Already uses formatAsBlock\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                // Check prev is an Element before calling methods on it. The original code already did this.\n                (prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // Keep original <br> check for minimal diff\n            )\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}