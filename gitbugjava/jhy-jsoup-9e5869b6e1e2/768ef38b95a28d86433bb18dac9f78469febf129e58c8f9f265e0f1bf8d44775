{
    "generation": "    @Override // Omitting the Javadoc for brevity in the final output\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // Parent could be Document, Element, etc.; cast later if needed. instanceof checks handle null.\n        final Node parentNode = parentNode(); // Cache parentNode lookup\n        // Check if whitespace normalization is active (pretty print enabled, and parent node does not preserve whitespace)\n        final boolean NORMALIZE_WHITE = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        if (!NORMALIZE_WHITE) { // If not normalizing, just escape the core value as is and return\n            Entities.escape(accum, coreValue(), out, false, false, false, false);\n            return;\n        }\n\n        // --- Normalization is active ---\n        final boolean isBlank = isBlank(); // Check if this text node is blank (whitespace only)\n        final Node next = nextSibling(); // Get the next sibling node\n\n        // Skip check: if this node is blank, and the next node triggers an indent or is another blank node,\n        // then skip outputting this current blank node entirely. This avoids extraneous whitespace between blocks.\n        boolean nextWillIndent = (next instanceof Element && ((Element) next).shouldIndent(out));\n        boolean nextIsBlankText = (next instanceof TextNode && ((TextNode) next).isBlank());\n        if (isBlank && (nextWillIndent || nextIsBlankText)) {\n            return; // Skip this whitespace node\n        }\n\n        // Handle remaining blank nodes (those not skipped above)\n        if (isBlank) {\n            // If this blank node is the last child within a block-level parent element,\n            // output nothing. Structural newlines/indentation are handled by the parent element's logic.\n            boolean isLastChild = next == null;\n            boolean parentIsBlock = parentNode instanceof Element && ((Element) parentNode).tag().isBlock();\n            if (isLastChild && parentIsBlock) {\n                return; // Output nothing for trailing blank nodes in blocks\n            } else {\n                // Otherwise (blank node not skipped, and not the last child of a block),\n                // output a single space. This preserves necessary spacing, e.g., between inline elements.\n                accum.append(' ');\n                return; // Done handling this blank node\n            }\n        }\n\n        // --- Node is NOT blank ---\n        // Cast parent to Element for tag checks, handling potential null or non-element parent.\n        final Element parent = parentNode instanceof Element ? (Element) parentNode : null;\n\n        // Determine trimming flags for non-blank text based on position within the parent.\n        boolean parentIsBlockForTrim = parent != null && parent.tag().isBlock(); // Re-check block status safely\n        boolean trimLeading = (siblingIndex() == 0 && parentIsBlockForTrim) || parentNode instanceof Document; // Trim leading if first child of block/doc\n        boolean trimTrailing = (next == null && parentIsBlockForTrim); // Trim trailing if last child of block\n\n        // Determine if indentation is needed before outputting this non-blank text node.\n        Node prev = previousSibling(); // Get the previous sibling node\n        boolean indentBefore = false;\n        // Indentation is needed if specific conditions are met, based on original logic:\n        if (parent != null) { // Ensure parent Element exists for these tag-related checks\n             if (\n                 // 1. If it's the first child of a block-formatting parent element\n                 (siblingIndex() == 0 && parent.tag().formatAsBlock()) ||\n                 // 2. If outline mode is enabled and the node has siblings (indicating structure)\n                 (out.outline() && siblingNodes().size() > 0) ||\n                 // 3. If the previous sibling was a <br> element (special case for line breaks)\n                 (siblingIndex() > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\"))\n             ) {\n                 indentBefore = true;\n             }\n        }\n\n        // Apply indentation if determined to be necessary\n        if (indentBefore) {\n             indent(accum, depth, out); // Assumes 'indent' helper method exists (standard in Jsoup Node class)\n        }\n\n        // Escape the non-blank text content.\n        // Pass 'true' for normalizeWhite parameter to collapse internal whitespace.\n        // Pass calculated trimLeading and trimTrailing flags.\n        Entities.escape(accum, coreValue(), out, false, true, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}