{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeadingForEscape = false; // Flags to be passed to Entities.escape\n        boolean trimTrailingForEscape = false;\n\n        if (normaliseWhite) {\n            final boolean isBlank = isBlank(); // Calculate once\n\n            // 1. Existing couldSkip logic: if this text is blank and the next node will cause an indent, skip this text.\n            Node next = nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n                || (next instanceof TextNode && (((TextNode) next).isBlank()));\n            if (couldSkip && isBlank) {\n                return; // Skip this blank node entirely\n            }\n\n            // Determine original contextual trim flags (i.e., whether the context suggests trimming)\n            final boolean isContextTrimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                                                 (parentNode instanceof Document && siblingIndex == 0);\n            final boolean isContextTrimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock());\n\n            // 2. New behavior for blank nodes:\n            if (isBlank) {\n                // If this blank node is at the start of a block (but not Document root)\n                // or at the end of a block, it should be omitted entirely.\n                final boolean isBlockEdgeLeadingNotDocRoot = (siblingIndex == 0 && parent != null && parent.tag().isBlock() && !(parentNode instanceof Document));\n                // isContextTrimTrailing correctly identifies if it's the last child of a block.\n                if (isBlockEdgeLeadingNotDocRoot || isContextTrimTrailing) {\n                    return; // Omit this blank node\n                }\n                // Otherwise, a blank node (e.g., internal to a block, or at doc root start, or in an inline parent)\n                // will fall through. For these cases, trimLeadingForEscape and trimTrailingForEscape remain false,\n                // so Entities.escape will correctly turn the blank node into a single space.\n            } else {\n                // Not blank: Use the original contextual trim flags for Entities.escape.\n                trimLeadingForEscape = isContextTrimLeading;\n                trimTrailingForEscape = isContextTrimTrailing;\n            }\n\n            // 3. Existing indent logic (from the original buggy function).\n            // This applies mainly to non-blank text or text immediately following a <br> element.\n            Node prev = previousSibling();\n            if (\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\"))\n            ) {\n                indent(accum, depth, out);\n            }\n        }\n        // If !normaliseWhite, trimLeadingForEscape and trimTrailingForEscape remain false,\n        // and Entities.escape will output the text as is.\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeadingForEscape, trimTrailingForEscape);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}