{
    "generation": "    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        // Handle null text\n        if (text == null || text.length() == 0) \n        {\n            return sb;\n        }\n\n        // Split by newline. Use limit=-1 to preserve trailing empty strings,\n        // which might be relevant for intentional blank lines.\n        // Use '\\n' directly as the splitter, assuming findWrapPos handles '\\n' appropriately\n        // and defaultNewLine might be '\\r\\n'. Using a simple split and then handling\n        // padding logic seems robust across platforms.\n        String[] lines = text.split(\"\\n\", -1);\n\n        final String padding = createPadding(nextLineTabStop);\n        boolean firstLineProcessed = true; // Flag for controlling inter-line newlines in output\n\n        for (int i = 0; i < lines.length; i++)\n        {\n            String line = lines[i];\n\n            // Add newline separator between original lines, except before the first one\n            if (!firstLineProcessed) {\n                sb.append(defaultNewLine);\n            } else {\n                firstLineProcessed = false; // Mark first line as processed\n            }\n\n            // Handle wrapping for the current line\n            int pos = findWrapPos(line, width, 0);\n            if (pos == -1) { // Line fits entirely\n                sb.append(rtrim(line));\n            } else {\n                // Append first segment\n                sb.append(rtrim(line.substring(0, pos)));\n                // Process remainder with padding\n                String remainder = line.substring(pos).trim();\n                while (remainder.length() > 0) {\n                     sb.append(defaultNewLine); // Newline before each subsequent wrapped segment\n                     String currentPaddedLine = padding + remainder;\n                     pos = findWrapPos(currentPaddedLine, width, 0);\n\n                     if (pos == -1) { // Remainder fits on one padded line\n                         sb.append(rtrim(currentPaddedLine));\n                         remainder = \"\"; // Done\n                     } else {\n                         // Append wrapped segment\n                         sb.append(rtrim(currentPaddedLine.substring(0, pos)));\n                         // Update remainder for next iteration\n                         remainder = currentPaddedLine.substring(pos).trim();\n                     }\n                }\n            }\n        }\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}