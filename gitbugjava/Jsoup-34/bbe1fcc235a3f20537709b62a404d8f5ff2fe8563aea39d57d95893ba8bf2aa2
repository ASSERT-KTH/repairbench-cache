{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        // Validate args\n        if (seq.length() == 0)\n            return -1; // Or specify different behavior for empty seq\n\n        char startChar = seq.charAt(0);\n        int seqLen = seq.length();\n\n        // The search needs to start scanning at `pos`, and must find the sequence entirely within the bounds `[pos, length)`.\n        // The last possible starting position for the sequence `seq` is `length - seqLen`.\n        // So, we search for `startChar` in the range `[pos, length - seqLen]`.\n        int searchLimit = length - seqLen;\n\n        for (int offset = pos; offset <= searchLimit; offset++) {\n            // Step 1: Scan for the first character of the sequence.\n            if (input[offset] != startChar) {\n                // Optimization: fast skip until the next potential start character.\n                while (++offset <= searchLimit && input[offset] != startChar);\n                // If the inner loop went past the limit, it means startChar wasn't found\n                // in the remaining valid range. We can stop searching.\n                if (offset > searchLimit) {\n                    break; // Exit the outer loop\n                }\n            }\n\n            // Step 2: Found a potential start character at `offset`. Check if the rest matches.\n            // We already know that `offset + seqLen <= length` because `offset <= searchLimit`.\n            int i = offset + 1; // Index into input array, starting after startChar\n            int j = 1;          // Index into seq, starting from the second char\n\n            // Compare the remaining characters of the sequence\n            while (j < seqLen) {\n                // Check bounds implicitly handled by loop condition `j < seqLen` combined with\n                // the outer loop's `offset <= searchLimit` which ensures `i = offset + j < length`.\n                if (input[i] != seq.charAt(j)) {\n                    break; // Mismatch found, break the inner while loop\n                }\n                i++;\n                j++;\n            }\n\n            // Step 3: Check if the entire sequence matched.\n            if (j == seqLen) {\n                // All characters matched.\n                return offset - pos; // Return the relative offset from the initial position.\n            }\n            // If j < seqLen, it means there was a mismatch. The outer loop will continue\n            // to find the next potential start character.\n        }\n\n        // Sequence not found in the specified range.\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}