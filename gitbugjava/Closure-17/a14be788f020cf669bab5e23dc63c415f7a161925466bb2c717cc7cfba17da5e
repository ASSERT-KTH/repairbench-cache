{
    "generation": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n\n      // Check for a type annotation attached to the rValue node.\n      // This occurs in cases like: var x = /** @type {T} */ (value);\n      // or /** @type {T} */ ({...}). This annotation takes precedence.\n      if (rValue != null) {\n        JSDocInfo rValueInfo = rValue.getJSDocInfo();\n        if (rValueInfo != null && rValueInfo.hasType()) {\n          // Use the type annotation found on the rValue.\n          // Pass rValue as the 'defining' node for context.\n          return getDeclaredTypeInAnnotation(sourceName, rValue, rValueInfo);\n        }\n      }\n\n      // If no type annotation on rValue, check for one on the lValue.\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      }\n\n      // If no explicit type annotation found yet, check for specific structures.\n      if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        // Handle function literal rhs\n        return rValue.getJSType();\n      }\n\n      if (info != null) {\n        // Handle @enum, @constructor, @interface from lValue's JSDoc\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            // Enum initialized with an object literal. Use the literal's type\n            // if no explicit @type was found on rValue already.\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else if (info.isConstant()) {\n          // Handle @const, try to infer the type from rValue if no explicit type found.\n          if (rValue != null) {\n            // Check if rValue's type was already computed (e.g., by type inference)\n            // Make sure we didn't already handle this via an rValue JSDoc check above.\n            JSType rValueType = rValue.getJSType();\n            if (rValueType != null && !rValueType.isUnknownType()) {\n              return rValueType;\n            } else if (rValue.isOr()) {\n              // Check for the specific JS idiom: var x = x || DEFAULT_VALUE;\n              Node firstClause = rValue.getFirstChild();\n              Node secondClause = firstClause.getNext();\n              boolean namesMatch = lValue.isQualifiedName()\n                  && firstClause.isQualifiedName()\n                  && lValue.matchesQualifiedName(firstClause);\n              if (namesMatch) {\n                  JSType secondClauseType = secondClause.getJSType();\n                  if (secondClauseType != null && !secondClauseType.isUnknownType()) {\n                      return secondClauseType;\n                  }\n              }\n            }\n          }\n        }\n      }\n\n      // Fallback: Try to get type from lValue JSDoc again, possibly handling\n      // other kinds of annotations or if info was initially null.\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}