{
    "generation": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      // 1. Handle @type annotation on the l-value.\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      }\n\n      // Check for function literal assigned to a variable.\n      // We special case this because we can often infer the type of a function\n      // literal directly.\n      if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      }\n\n      // 2. Handle specific JSDoc constructs like @enum, @constructor, @interface\n      //    on the l-value declaration.\n      if (info != null) {\n        if (info.hasEnumParameterType()) {\n          // Use the inferred type of the object literal if it's available.\n          // TODO(nicksantos): There's no reason why we shouldn't\n          // do this for all types.\n          if (rValue != null && rValue.isObjectLit()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        }\n      }\n\n      // 3. Handle @const on the l-value.\n      // This case is special, because we want to use the type *before*\n      // the r-value is assigned. To make this more complicated, sometimes\n      // the type is only specified on the r-value. e.g.,\n      // /** @const */ var MY_BEATLES =\n      //     /** @type {!Array.<string>} */ ([\"Paul\", \"John\", ...]);\n      if (info != null && info.isConstant()) {\n        // Use the type annotation on the r-value if it exists. This handles\n        // cases like /** @const */ var x = /** @type {Foo} */ (y);\n        JSDocInfo rValueInfo = rValue != null ? rValue.getJSDocInfo() : null;\n        if (rValueInfo != null && rValueInfo.hasType()) {\n            return getDeclaredTypeInAnnotation(sourceName, rValue, rValueInfo);\n        }\n\n        // Fall back to the inferred type of the r-value.\n        if (rValue != null) {\n          JSType rValueType = rValue.getJSType();\n          // Make sure we're not recursively trying to infer the type of a VAR.\n          if (rValueType != null && !rValueType.isUnknownType() && !rValue.isName()) {\n            return rValueType;\n          } else if (rValue.isOr()) {\n            // Check for a very specific JS idiom:\n            // var x = x || TYPE;\n            // This is used by Closure's base namespace for esoteric\n            // reasons.\n            Node firstClause = rValue.getFirstChild();\n            Node secondClause = firstClause.getNext();\n            boolean namesMatch = firstClause.isName()\n                && lValue.isName()\n                && firstClause.getString().equals(lValue.getString());\n            if (namesMatch && secondClause.getJSType() != null\n                && !secondClause.getJSType().isUnknownType()) {\n              return secondClause.getJSType();\n            }\n          }\n        }\n      }\n\n\n      // 4. Last resort, try to get a type from the l-value node's JSDoc.\n      // This is the place where we handle stub declarations, like:\n      // /** @type {number} */ var x;\n      // It also sometimes catches types declared inline, which is illegal\n      // according to the style guide, but allowed by the compiler:\n      // var /** @type {number} */ x = 3;\n      // TODO(nicksantos): The support for inline types should probably be\n      // moved elsewhere.\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}