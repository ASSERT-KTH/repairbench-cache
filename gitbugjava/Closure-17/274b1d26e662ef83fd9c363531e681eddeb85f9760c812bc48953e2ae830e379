{
    "generation": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      // 1. Check for @type JSDoc on the L-Value.\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      }\n\n      // 2. Check for a @type JSDoc cast on the R-Value.\n      // This is commonly used for constants. e.g. @const x = /** @type {foo} */ (bar);\n      // This also needs to be checked before the other rValue checks below\n      // (like isFunction or isObjectLit), as casts can wrap those types.\n      if (rValue != null && rValue.isCast()) {\n        JSDocInfo rValueInfo = rValue.getJSDocInfo();\n        if (rValueInfo != null && rValueInfo.hasType()) {\n          // Use the type from the cast.\n          return getDeclaredTypeInAnnotation(sourceName, rValue, rValueInfo);\n        }\n        // If the cast doesn't have type info (which would be weird),\n        // fall through and try to get the type from the expression being cast\n        // or other conditions below.\n      }\n\n      // 3. Check for function literal types.\n      if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        return rValue.getJSType();\n      }\n\n      // 4. Check for other JSDoc annotations on the L-Value (@enum, @constructor, @interface, @const).\n      if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            // If the RHS is an object literal, its type might be precomputed.\n            return rValue.getJSType();\n          } else {\n            // Otherwise, create the enum type from the declaration.\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          // Create the function type from the declaration.\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else if (info.isConstant()) {\n          // Handle @const when no explicit @type on L-Value and no cast on R-Value.\n          // Try to infer the type from the R-Value if possible.\n          if (rValue != null) {\n            // Don't check cast nodes again, they were handled above.\n            // Check if rValue's type is already known and usable.\n             if (!rValue.isCast() && rValue.getJSType() != null &&\n                 !rValue.getJSType().isUnknownType()) {\n                // If rValue has a known type (and isn't a cast), use it.\n                // This handles cases like @const x = 1; or @const y = someFunction();\n                return rValue.getJSType();\n             } else if (rValue.isOr()) {\n                // Handle the \"var x = x || DEFAULT\" idiom.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.isName()\n                    && lValue.isName()\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n             }\n          }\n          // If @const but R-Value is null, unknown, a cast without type, or unhandled, fall through.\n        }\n      }\n\n      // 5. Final fallback. If no type was determined by annotations or inference,\n      //    call getDeclaredTypeInAnnotation again. This might return null or handle\n      //    other cases like @param for function parameters based on the original 'info'.\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}