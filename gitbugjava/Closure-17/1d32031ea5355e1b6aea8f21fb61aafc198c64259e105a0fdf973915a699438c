{
    "generation": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      // 1. Check @type on lValue (info)\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      }\n      // 2. Check if rValue is a function literal (special handling)\n      else if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        // Function literal definition can be handled specially.\n        return rValue.getJSType();\n      }\n      // 3. Check specific JSDoc tags on lValue (info)\n      else if (info != null) {\n        // 3a. @enum\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.isObjectLit()) {\n            // If rValue is an object literal, this is an enum definition.\n            return rValue.getJSType();\n          } else {\n            // If rValue is not an object literal, this is the declaration\n            // of an enum type, so use the enum type declared in the JSDoc.\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        }\n        // 3b. @constructor/@interface\n        else if (info.isConstructor() || info.isInterface()) {\n          // If rValue is a function literal, this is a function definition.\n          // If rValue is something else, this is the declaration of a function\n          // type, so use the function type declared in the JSDoc.\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        }\n        // 3c. @const / other properties\n        else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            if (rValue != null) {\n              JSType rValueType = rValue.getJSType();\n              // Check 1: Use existing type on rValue if valid and known.\n              if (rValueType != null && !rValueType.isUnknownType()) {\n                // If rValue has a type-cast, we use the type in the type-cast.\n                // If rValue's type was already computed during scope creation,\n                // then we can safely use that.\n                return rValueType;\n              }\n              // Check 2: If rValue type is unknown/null, check specific structures.\n              else {\n                 // Check 2a: If rValue is a CAST, try resolving its JSDoc type directly.\n                 // This can help if the type wasn't propagated to the node's JSType yet.\n                 if (rValue.isCast()) {\n                    JSDocInfo castInfo = rValue.getJSDocInfo();\n                    if (castInfo != null && castInfo.hasType()) {\n                      JSType typeFromCastInfo =\n                          getDeclaredTypeInAnnotation(sourceName, rValue, castInfo);\n                      // Return the resolved type if successful.\n                      if (typeFromCastInfo != null) {\n                        return typeFromCastInfo;\n                      }\n                    }\n                 }\n                 // Check 2b: Handle the \"var x = x || TYPE;\" idiom.\n                 else if (rValue.isOr()) {\n                   Node firstClause = rValue.getFirstChild();\n                   Node secondClause = firstClause.getNext();\n                   boolean namesMatch = firstClause.isName()\n                       && lValue.isName()\n                       && firstClause.getString().equals(lValue.getString());\n                   if (namesMatch && secondClause.getJSType() != null\n                       && !secondClause.getJSType().isUnknownType()) {\n                     // Use the type of the second clause if names match.\n                     return secondClause.getJSType();\n                   }\n                 }\n              }\n            }\n          }\n          // Fall through: If not constant or type not determined,\n          // let the final fallback handle it.\n        }\n      }\n\n      // 4. Fallback: Check @type on lValue (info) again.\n      // This might be reached if info is null, or if info is non-null\n      // but has no recognized annotations (@type, @enum, @const etc.) handled above,\n      // or if @const handling above didn't find a type.\n      // If info is non-null but has no @type, this will likely return null.\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}