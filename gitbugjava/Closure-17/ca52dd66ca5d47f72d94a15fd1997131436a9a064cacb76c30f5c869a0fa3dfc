{
    "generation": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      // 1. Check for @type in JSDoc associated with the l-value\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      }\n\n      // Check for inline type information on the r-value if l-value has no @type\n      // Note: CAST nodes are handled later in the isConstant check by looking\n      // at rValue.getJSType(), which should return the cast type.\n      // However, if JSDoc is directly on rValue (e.g. /** @type {T} */ value),\n      // it might be preferable, especially for constants.\n\n      // 2. Check for function literal type inference\n      if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        // Function literal with declared parameter types or return type.\n        return rValue.getJSType();\n      }\n\n      // 3. Check for @enum, @constructor, @interface in JSDoc associated with l-value\n      if (info != null) {\n        if (info.hasEnumParameterType()) {\n          // If rValue is an object literal, its type is usually inferred\n          // and has already been set by ProcessObjectPropertyPatterns.\n          // We prefer that type. See issue 643.\n          if (rValue != null && rValue.isObjectLit()\n              && rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          // Function literal inference was handled above, so this is likely\n          // a stub declaration or an alias.\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else if (info.isConstant()) {\n          // 4. Handle @const case\n          if (rValue != null) {\n            // Check #1: Explicit JSDoc on rValue (e.g., /** @type {T} */ value)\n            // This handles cases where the JSDoc is directly on the rValue node.\n            JSDocInfo rValueInfo = rValue.getJSDocInfo();\n            if (rValueInfo != null && rValueInfo.hasType()) {\n              return getDeclaredTypeInAnnotation(sourceName, lValue, rValueInfo);\n            }\n\n            // Check #2: Pre-computed type on rValue (e.g., from CAST node /** @type {T} */ (value))\n            // or other prior inference. This should take precedence over OR idiom.\n            JSType rValueType = rValue.getJSType();\n            if (rValueType != null && !rValueType.isUnknownType()) {\n              // If rValue has a type-cast, we use the type in the type-cast.\n              // If rValue's type was already computed during scope creation,\n              // then we can safely use that.\n              return rValueType;\n            }\n\n            // Check #3: 'var x = x || TYPE;' idiom\n            if (rValue.isOr()) {\n              Node firstClause = rValue.getFirstChild();\n              Node secondClause = firstClause.getNext();\n              boolean namesMatch = firstClause.isName()\n                  && lValue.isName()\n                  && firstClause.getString().equals(lValue.getString());\n              if (namesMatch) {\n                   JSType secondClauseType = secondClause.getJSType();\n                   if (secondClauseType != null && !secondClauseType.isUnknownType()) {\n                     return secondClauseType;\n                   }\n              }\n            }\n          }\n          // If no type found for the constant, fall through to default.\n        }\n      }\n\n      // 5. Last resort: return null or an inferred type based on the annotation.\n      // This handles stub declarations, and constants without RHS types.\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}