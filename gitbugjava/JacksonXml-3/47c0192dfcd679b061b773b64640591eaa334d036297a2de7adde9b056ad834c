{
    "generation": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                // _currText should be properly set, by `nextToken()` that returned the token\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought it might be leaf, it wasn't, must be OBJECT...\n            if (_mayBeLeaf) {\n                // Must change state, don't return yet\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                // We need to advance to the next element/text/whatever, so that\n                // caller gets FIELD_NAME, then VALUE_STRING (or whatever)\n                 return null; // Indicate change of state\n            }\n            if (_parsingContext.inArray()) {\n                // Ok: just need to skip STE\n                token = _xmlTokens.next();\n                _mayBeLeaf = true; // Don't yet know if it's leaf or wrapper\n                continue;\n            }\n            // Otherwise, field name\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            \n            // Ok, need to check if this needs to be wrapped in an array: if so,\n            // need to repeat the start element\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true; // Don't yet know if it's leaf or wrapper\n            _currToken = JsonToken.FIELD_NAME; // And return indication of FIELD_NAME\n            // Field name will always be set as `_currText`, so it'll be available\n            return null; // indicate change of state\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Simple empty element?\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            // Otherwise, closing element\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME; // to match attribute name\n                _currText = _xmlTokens.getText(); // name is text\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                 _currToken = JsonToken.START_OBJECT; // And return START_OBJECT\n            } else { // just attribute name\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            // Added return for [dataformat-xml#204]\n            return _currText;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING; // which is coming next\n            _currToken = JsonToken.FIELD_NAME; // that we return now\n            break;\n        // Any other token? Error really...\n        /*\n        case XmlTokenStream.XML_COMMENT:\n        case XmlTokenStream.XML_PROCESSING_INSTRUCTION:\n            // TODO: Filter out? Or expose?\n            // For now, let's just skip comments and PIs... (and NOT expose)\n             continue;\n             */\n        case XmlTokenStream.XML_END: // document end\n            _currToken = null; // means end-of-input\n            _handleEOF();\n        }\n        // Should not get here usually\n        _updateState(_currToken);\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}