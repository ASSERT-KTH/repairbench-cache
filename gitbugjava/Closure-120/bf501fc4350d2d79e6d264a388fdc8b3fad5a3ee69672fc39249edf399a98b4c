{
    "generation": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        // The variable is never assigned or assigned multiple times.\n        return false;\n      }\n\n      // Make sure this assignment is not executed multiple times.\n      // This can happen if the assignment is part of a loop structure\n      // (syntactic loop, goto loop, or recursion) or if the function containing\n      // the assignment is called multiple times (e.g., from an outer loop).\n      // We check this by walking up the basic block nesting hierarchy.\n      // If any containing block is marked as part of a loop structure,\n      // the assignment might occur multiple times.\n      // Note: getParent() gives the block lexically containing this block, it\n      // does not correspond to the control flow graph's predecessor list.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        // block.isLoop checks if the block is part of a loop structure\n        // in the control flow graph. This handles syntactic loops.\n        // If the CFG analysis correctly marks blocks in recursive cycles\n        // or functions called from loops as 'isLoop', this check might\n        // cover those cases too.\n        // By removing the early termination condition `else if (block.isFunction) { break; }`,\n        // we allow the check to continue potentially finding loops that contain\n        // the function definition itself. This correctly handles cases like\n        // functions defined and called within a loop, and potentially\n        // recursive functions or functions called from loops if `isLoop`\n        // is set based on CFG cycles detected by the analysis (e.g., SCCs).\n        if (block.isLoop) {\n          return false;\n        }\n      }\n\n      // If the assignment is not contained within any loop structure up to the\n      // root of the control flow graph based on lexical nesting,\n      // we assume it's assigned once in its lifetime for the purpose of this check.\n      // This might be insufficient for complex control flow like recursion not marked\n      // by isLoop or functions called multiple times from different locations, but\n      // it addresses the issue of stopping the check prematurely at function boundaries.\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}