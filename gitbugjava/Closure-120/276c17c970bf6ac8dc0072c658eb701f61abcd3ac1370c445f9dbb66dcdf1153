{
    "generation": "import com.google.common.base.Predicate;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        // No single assignment found.\n        return false;\n      }\n\n      Node statementNode = ref.getStatement();\n      if (statementNode == null) {\n          // Cannot determine the context of the assignment, assume it might not be assigned once.\n          // This might happen for variables assigned in complex ways or synthetic code.\n          return false;\n      }\n\n      // Check 1: Assignment must not be lexically inside a standard loop structure (for, while, do).\n      for (Node ancestor = statementNode.getParent();\n           ancestor != null && !ancestor.isFunction(); // Stop searching at the enclosing function boundary\n           ancestor = ancestor.getParent()) {\n        if (NodeUtil.isLoopStructure(ancestor)) {\n          // Assignment is definitely inside a loop.\n          return false;\n        }\n      }\n\n      // Check 2: Assignment must not be inside a function that directly calls itself recursively by name.\n      // This helps catch cases where an assignment seems unique lexically but runs multiple times due to recursion.\n      Node enclosingFunction = NodeUtil.getEnclosingFunction(statementNode);\n      if (enclosingFunction != null) {\n        final String functionName = NodeUtil.getName(enclosingFunction);\n        // Only perform the check if the function is named. Handles simple direct recursion cases.\n        // Does not handle anonymous function recursion (e.g., via arguments.callee) or mutual recursion.\n        if (functionName != null && !functionName.isEmpty()) {\n          Predicate<Node> isRecursiveCall =\n              new Predicate<Node>() {\n                @Override\n                public boolean apply(Node input) {\n                  // Check if the node is a CALL node\n                  if (input.isCall()) {\n                    Node callee = input.getFirstChild();\n                    // Check if the target of the call is a NAME node matching the function's name.\n                    // Note: This is a heuristic and doesn't perform full scope resolution.\n                    // It assumes a name match implies a recursive call here.\n                    if (callee.isName() && functionName.equals(callee.getString())) {\n                      return true; // Found a potential recursive call.\n                    }\n                  }\n                  return false;\n                }\n              };\n\n          // Search within the function's body for any node satisfying the isRecursiveCall predicate.\n          // The search should not descend into nested function definitions.\n          if (NodeUtil.has(\n              enclosingFunction.getLastChild(), // The function body block\n              isRecursiveCall,\n              new Predicate<Node>() { // Traversal predicate: stop \u0639\u0646\u062f nested functions\n                @Override\n                public boolean apply(Node node) {\n                  // Continue traversal as long as the node is not a function definition.\n                  return !node.isFunction();\n                }\n              })) {\n            // A recursive call was found within the function.\n            return false;\n          }\n        }\n      }\n\n      // Check 3: Use the original BasicBlock based check.\n      // This check might rely on CFG analysis results (e.g., detecting loops from goto or complex flow)\n      // potentially captured by the isLoop flag on BasicBlocks.\n      BasicBlock assignmentBlock = ref.getBasicBlock();\n      if (assignmentBlock != null) {\n        // Traverse up the BasicBlock hierarchy associated with the assignment.\n        // The meaning of getParent() depends on how BasicBlocks are structured (e.g., dominance, nesting).\n        for (BasicBlock block = assignmentBlock; block != null; block = block.getParent()) {\n          if (block.isFunction) {\n            // Reached the function boundary in the block hierarchy.\n            break;\n          } else if (block.isLoop) {\n            // The BasicBlock analysis indicates this assignment is within a loop context.\n            return false;\n          }\n        }\n      }\n      // Note: If assignmentBlock is null, we proceed. This might mean CFG info is unavailable.\n      // The AST based checks above provide some safety net.\n\n\n      // If none of the checks determined that the assignment can happen multiple times,\n      // assume it is assigned once in its lifetime for the purpose of this check.\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}