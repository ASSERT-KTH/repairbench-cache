{
    "generation": "import com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.jscomp.NodeUtil;\nimport static com.google.javascript.jscomp.AstFactory.type; // Assuming AstFactory access if needed\nimport static com.google.javascript.jscomp.parsing.JsDocInfoParser.getParser; // Assuming parser access if needed\nimport static com.google.javascript.jscomp.AbstractPeepholeOptimization.areNodesEqualForInlining; // Assuming access\nimport static com.google.javascript.jscomp.AbstractPeepholeOptimization.mayEffectMutableState; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isFoldableExpressBlock; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.getBlockExpression; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isPropertyAssignmentInExpression; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isLowerPrecedenceInExpression; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isReturnExpressBlock; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.getBlockReturnExpression; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isVarBlock; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.getBlockVar; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.consumesDanglingElse; // Assuming access\nimport static com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.isSimpleExpression; // Assuming access\nimport com.google.javascript.rhino.Token; // Assuming Token access\nimport com.google.template.soy.examples.FeaturesSoyInfo.InnerMessage; // Assuming necessary imports\n\n// Dummy implementations or assumed external methods for context\nclass PeepholeDummy {\n    // Assume these constants exist\n    final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n    final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n    boolean late = false; // Example value\n\n    void reportCodeChange() {} // Dummy implementation\n\n    // Assume these methods are defined elsewhere in the class or a base class\n    static boolean isFoldableExpressBlock(Node n) { return false; }\n    static Node getBlockExpression(Node n) { return null; }\n    static boolean isPropertyAssignmentInExpression(Node expr) { return false; }\n    static boolean isLowerPrecedenceInExpression(Node expr, int precedence) { return false; }\n    static boolean isReturnExpressBlock(Node n) { return false; }\n    static Node getBlockReturnExpression(Node n) { return null; }\n    static boolean isVarBlock(Node n) { return false; }\n    static Node getBlockVar(Node n) { return null; }\n    static boolean consumesDanglingElse(Node n) { return false; }\n    static boolean areNodesEqualForInlining(Node n1, Node n2) { return false; }\n    static boolean mayEffectMutableState(Node n) { return false; }\n    static boolean isSimpleExpression(Node n) { return true; }\n\n\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n    if (parent == null) {\n      // Cannot replace the root node.\n      return n;\n    }\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      // Handle IF without ELSE\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        Node value = expr.getFirstChild();\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          // Need to make sure that the expr doesn't have lower precedence than ||.\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(value, OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(), // Original condition (without NOT)\n              value.detachFromParent()).srcref(n); // Use srcref from original IF\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        // Need to make sure that the expr doesn't have lower precedence than &&.\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(value, AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        cond.detachFromParent();\n        Node and = IR.and(cond, value.detachFromParent()).srcref(n); // Use srcref from original IF\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n        // Try to combine two IFs. if(x) { if (y) { foo() } } -> if (x&&y) { foo() }\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            // Check the inner IF doesn't have an ELSE branch, and that merging\n            // the conditions doesn't create precedence issues.\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n\n              // Ensure the conditions are simple enough to combine safely.\n              // Fix for http://b/5626764\n              if (isSimpleExpression(innerCond) && isSimpleExpression(cond)) {\n                  n.detachChildren(); // Detach existing children (cond, thenBranch)\n                  n.addChildToBack(\n                      IR.and(\n                          cond.detachFromParent(), // Reuse original condition node\n                          innerCond.detachFromParent()) // Reuse inner condition node\n                          .srcref(cond)); // Copy srcref\n                  n.addChildrenToBack(innerThenBranch.detachFromParent()); // Move inner then branch\n                  reportCodeChange();\n                  // Return the modified IF node. Further optimizations might apply.\n                  return n;\n              }\n            }\n          }\n        }\n      }\n      // No transformation applied for IF without ELSE\n      return n;\n    }\n\n    // Handle IF with ELSE\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // Avoid if the else branch might consume a dangling else.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      Node notChild = cond.removeFirstChild();\n      n.replaceChild(cond, notChild); // Replace NOT node with its child\n      // Swap branches: detach else, remove then, add else, add then\n      elseBranch.detachFromParent();\n      n.removeChild(thenBranch);\n      n.addChildToBack(elseBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      // Re-fetch nodes as structure changed. Optimization may continue.\n      cond = n.getFirstChild();\n      thenBranch = cond.getNext();\n      elseBranch = thenBranch.getNext();\n      // Fall through to potentially apply HOOK transformations to the modified IF\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n\n      // Ensure both returns have expressions (ignore \"return;\")\n      if (thenExpr != null && elseExpr != null) {\n          cond.detachFromParent();\n          thenExpr.detachFromParent();\n          elseExpr.detachFromParent();\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); // Copy srcref from IF\n          Node returnNode = IR.returnNode(hookNode).srcref(n); // Copy srcref from IF\n          parent.replaceChild(n, returnNode);\n          reportCodeChange();\n          return returnNode;\n      }\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenExprBlock = getBlockExpression(thenBranch);\n      Node elseExprBlock = getBlockExpression(elseBranch);\n      Node thenOp = thenExprBlock.getFirstChild();\n      Node elseOp = elseExprBlock.getFirstChild();\n\n      // Try specific common assignment pattern: if(x)a=1;else a=2; -> a=x?1:2;\n      if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            // Ensure LHS evaluation itself doesn't have side effects (e.g., a[i++]=...).\n            !mayEffectMutableState(lhs) &&\n            // Ensure condition's side effects don't affect LHS evaluation,\n            // unless LHS is a simple name (whose evaluation is trivial).\n            (!NodeUtil.mayHaveSideEffects(cond) || lhs.isName())) {\n\n          cond.detachFromParent();\n          // Detach LHS ('a') from thenOp\n          Node assignLhs = thenOp.getFirstChild().detachFromParent();\n          // Detach RHS ('1') from thenOp\n          Node thenRhsExpr = thenOp.getLastChild().detachFromParent();\n          // Detach RHS ('2') from elseOp\n          Node elseRhsExpr = elseOp.getLastChild().detachFromParent();\n\n          // Create 'cond ? 1 : 2'\n          Node hookNode = IR.hook(cond, thenRhsExpr, elseRhsExpr)\n                            .srcref(n); // Copy srcref from original IF\n          // Create 'a = (cond ? 1 : 2)'\n          Node assign = new Node(thenOp.getType(), assignLhs, hookNode)\n                            .srcref(thenOp); // Copy srcref from original assignment\n          Node newExpr = NodeUtil.newExpr(assign); // Wrap in EXPR_RESULT\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n      }\n\n      // Try general transformation: if(x)foo();else bar(); -> x?foo():bar()\n      // This requires wrapping the HOOK in an EXPR_RESULT.\n      cond.detachFromParent();\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n      Node expr = IR.exprResult(hookNode).srcref(n); // Wrap in EXPR_RESULT\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild(); // The NAME node in the VAR\n      Node maybeName2 = elseAssign.getFirstChild(); // LHS of assignment\n\n      // Check: VAR has an initializer, the assignment LHS is a NAME, and names match.\n      if (name1.hasChildren()\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) {\n\n        Node thenExpr = name1.removeChildren(); // Initializer of VAR\n        Node elseExpr = elseAssign.getLastChild().detachFromParent(); // RHS of assignment\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n); // Copy srcref from original IF\n        var.detachFromParent(); // Detach VAR node itself\n        name1.addChildrenToBack(hookNode); // Assign HOOK as new initializer for the NAME\n        parent.replaceChild(n, var); // Replace IF with the modified VAR\n        reportCodeChange();\n        return var;\n      }\n    }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild(); // LHS of assignment\n      Node name2 = var.getFirstChild(); // The NAME node in the VAR\n\n      // Check: VAR has an initializer, the assignment LHS is a NAME, and names match.\n      if (name2.hasChildren()\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) {\n\n        Node thenExpr = thenAssign.getLastChild().detachFromParent(); // RHS of assignment\n        Node elseExpr = name2.removeChildren(); // Initializer of VAR\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n); // Copy srcref from original IF\n        var.detachFromParent(); // Detach VAR node itself\n        name2.addChildrenToBack(hookNode); // Assign HOOK as new initializer for the NAME\n        parent.replaceChild(n, var); // Replace IF with the modified VAR\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n; // No transformation applied\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}