{
    "generation": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n    // Ensure parent is available before proceeding, replaceChild will fail otherwise.\n    if (parent == null) {\n      return n;\n    }\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    // Need thenBranch to exist\n    if (thenBranch == null) {\n        return n;\n    }\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      // IF without ELSE\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        // getBlockExpression returns null if not foldable, check for safety\n        if (expr == null) {\n          return n;\n        }\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        // Ensure expr has a child (the actual expression node)\n        Node exprChild = expr.getFirstChild();\n        if (exprChild == null) {\n            return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          Node notChild = cond.getFirstChild();\n          // Ensure NOT has a child\n          if (notChild == null) {\n            return n;\n          }\n\n          if (isLowerPrecedenceInExpression(notChild, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(exprChild, OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          // Detach operands before creating the OR node\n          cond.removeChild(notChild);\n          expr.removeChild(exprChild);\n\n          Node or = IR.or(notChild, exprChild).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        } else {\n          // if(x)foo(); -> x&&foo();\n          if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(exprChild, AND_PRECEDENCE)) {\n            // One additional set of parentheses is worth the change even if\n            // there is no immediate code size win. However, two extra pair of\n            // {}, we would have to think twice. (unless we know for sure the\n            // we can further optimize its parent.\n            return n;\n          }\n\n          // Detach operands before creating the AND node\n          n.removeChild(cond); // Detach cond from IF\n          expr.removeChild(exprChild); // Detach exprChild from EXPR_RESULT\n\n          Node and = IR.and(cond, exprChild).srcref(n);\n          Node newExpr = NodeUtil.newExpr(and);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n      } else {\n        // Try to combine two IF-ELSE: if(x) { if(y) foo() } -> if(x&&y) foo()\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            // Need innerCond and innerThenBranch to proceed\n            if (innerCond == null || innerThenBranch == null) {\n                return n;\n            }\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n\n              n.detachChildren(); // Detach original cond, thenBranch\n\n              Node andCond = IR.and(\n                  cond, // cond was already detached by detachChildren\n                  innerCond.detachFromParent())\n                  .srcref(cond); // Use original outer cond's source info\n\n              n.addChildToBack(andCond);\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Return the modified IF node 'n'\n              return n;\n            }\n          }\n        }\n      }\n      // No transformation applied for IF without ELSE\n      return n;\n    }\n\n    // IF with ELSE\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n       Node notChild = cond.getFirstChild();\n       // Ensure NOT has a child\n       if (notChild != null) {\n           n.replaceChild(cond, notChild); // Replace NOT node with its child\n           n.removeChild(thenBranch); // Remove then branch\n           n.addChildToBack(thenBranch); // Add then branch as the new else branch\n           reportCodeChange();\n           // Return the modified IF node 'n'\n           return n;\n       }\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size. Check that both returns have values.\n      if (thenExpr != null && elseExpr != null) {\n          n.removeChild(cond); // Detach condition\n          thenExpr.detachFromParent(); // Detach return value from its RETURN node\n          elseExpr.detachFromParent(); // Detach return value from its RETURN node\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); // Use IF's source info\n          Node returnNode = IR.returnNode(hookNode).srcref(n); // Use IF's source info again for RETURN\n\n          parent.replaceChild(n, returnNode);\n          reportCodeChange();\n          return returnNode;\n      }\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenExprBlock = getBlockExpression(thenBranch);\n      Node elseExprBlock = getBlockExpression(elseBranch);\n\n      // Check that blocks and their first children (the expressions) exist\n      if (thenExprBlock == null || elseExprBlock == null ||\n          thenExprBlock.getFirstChild() == null || elseExprBlock.getFirstChild() == null) {\n        return n;\n      }\n\n      Node thenOp = thenExprBlock.getFirstChild();\n      Node elseOp = elseExprBlock.getFirstChild();\n\n      // Check for assignment operations specifically:\n      // if(x)a=1;else a=2; -> a=x?1:2; (also handles +=, *= etc.)\n      if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          Node elseLhs = elseOp.getFirstChild();\n          // Check LHS exists in both and they are equivalent\n          if (lhs != null && elseLhs != null && areNodesEqualForInlining(lhs, elseLhs)) {\n\n            // Check if the optimization `lhs op= (cond ? ...)` is safe or explicitly allowed.\n            boolean lhsMayBeAffectedByCond = NodeUtil.canBeSideEffected(lhs);\n            boolean lhsEvalHasSideEffects = mayEffectMutableState(lhs);\n\n            // Allow `lhs op= (cond ? ...)` if:\n            // 1. Evaluating lhs itself has no side effects (e.g., `getLhs().prop = ...` is disallowed).\n            // 2. AND EITHER:\n            //    a) lhs's value cannot be affected by external side effects (like cond's). This is the safe case.\n            //    b) OR it's the special case allowed by Issue925: simple assignment (ASSIGN) to a simple name (NAME),\n            //       even if the name's value might be affected by the condition (e.g. `x = x++ ? ...`).\n            if (!lhsEvalHasSideEffects &&\n                (!lhsMayBeAffectedByCond || (thenOp.isAssign() && lhs.isName()))) {\n\n               Node thenRhs = thenOp.getLastChild();\n               Node elseRhs = elseOp.getLastChild();\n               // Ensure RHS exists in both assignments\n               if (thenRhs != null && elseRhs != null) {\n                 n.removeChild(cond); // Detach cond separately first\n                 Node assignLhs = thenOp.removeFirstChild(); // Detach shared LHS\n                 thenRhs.detachFromParent(); // Detach then RHS\n                 elseRhs.detachFromParent(); // Detach else RHS\n\n                 Node hookNode = IR.hook(cond, thenRhs, elseRhs).srcref(n); // Hook(cond, thenRhs, elseRhs)\n                 Node assign = new Node(thenOp.getType(), assignLhs, hookNode) // Reuse thenOp's type (ASSIGN or ASSIGN_XXX)\n                                   .srcref(thenOp); // Use first assignment's source info\n                 Node newExpr = NodeUtil.newExpr(assign); // Wrap in EXPR_RESULT\n                 parent.replaceChild(n, newExpr);\n                 reportCodeChange();\n                 return newExpr;\n               }\n            }\n          }\n      }\n      // Fallthrough or different expression types:\n      // if(x)foo();else bar(); -> x?foo():bar()\n      // This handles cases like `if(cond){a=1}else{b=2}` and the assignment cases\n      // that were disallowed above (e.g., `if(x[--y]...){x[y]=0}else{x[y]=1}` which becomes `cond ? (x[y]=0) : (x[y]=1)`)\n      n.removeChild(cond); // Detach cond from IF\n      thenOp.detachFromParent(); // Detach the root of the then expression (e.g., ASSIGN, CALL)\n      elseOp.detachFromParent(); // Detach the root of the else expression\n\n      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n      Node expr = IR.exprResult(hookNode); // Create EXPR_RESULT(HOOK(cond, thenOp, elseOp))\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock) {\n        Node elseExprBlock = getBlockExpression(elseBranch);\n        // Ensure else block is a valid assignment expression\n        if (elseExprBlock != null && elseExprBlock.getFirstChild() != null &&\n            elseExprBlock.getFirstChild().isAssign()) {\n            Node var = getBlockVar(thenBranch); // VAR node\n            Node elseAssign = elseExprBlock.getFirstChild(); // ASSIGN node\n\n            // Ensure VAR has one child (the NAME node)\n            if (var != null && var.hasOneChild()) {\n                Node name1 = var.getFirstChild(); // The NAME node in `var y=1;`\n                Node maybeName2 = elseAssign.getFirstChild(); // The LHS of `y=2;`\n\n                // Check name1 has initializer, maybeName2 is a NAME node, and names match\n                if (name1.hasChildren() && maybeName2 != null && maybeName2.isName() &&\n                    name1.getString().equals(maybeName2.getString())) {\n\n                    Node thenExpr = name1.getFirstChild(); // Initializer of var (RHS of var y=1)\n                    Node elseExpr = elseAssign.getLastChild(); // RHS of assign y=2\n\n                    // Ensure both initializers/RHS exist\n                    if (thenExpr != null && elseExpr != null) {\n                        cond.detachFromParent();\n                        thenExpr.detachFromParent(); // Detach thenExpr from NAME\n                        elseExpr.detachFromParent(); // Detach elseExpr from ASSIGN\n\n                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                        var.detachFromParent(); // Detach VAR from its original block\n                        name1.addChildToBack(hookNode); // Replace original initializer with HOOK\n                        parent.replaceChild(n, var);\n                        reportCodeChange();\n                        return var;\n                    }\n                }\n            }\n        }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock) {\n        Node thenExprBlock = getBlockExpression(thenBranch);\n        // Ensure then block is a valid assignment expression\n        if (thenExprBlock != null && thenExprBlock.getFirstChild() != null &&\n            thenExprBlock.getFirstChild().isAssign()) {\n            Node var = getBlockVar(elseBranch); // VAR node\n            Node thenAssign = thenExprBlock.getFirstChild(); // ASSIGN node\n\n            // Ensure VAR has one child (the NAME node)\n            if (var != null && var.hasOneChild()) {\n                Node maybeName1 = thenAssign.getFirstChild(); // LHS of `y=1;`\n                Node name2 = var.getFirstChild(); // The NAME node in `var y=2;`\n\n                // Check name2 has initializer, maybeName1 is a NAME node, and names match\n                if (name2.hasChildren() && maybeName1 != null && maybeName1.isName() &&\n                    maybeName1.getString().equals(name2.getString())) {\n\n                    Node thenExpr = thenAssign.getLastChild(); // RHS of assign y=1\n                    Node elseExpr = name2.getFirstChild(); // Initializer of var (RHS of var y=2)\n\n                    // Ensure both RHS/initializers exist\n                    if (thenExpr != null && elseExpr != null) {\n                        cond.detachFromParent();\n                        thenExpr.detachFromParent(); // Detach thenExpr from ASSIGN\n                        elseExpr.detachFromParent(); // Detach elseExpr from NAME\n\n                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                        var.detachFromParent(); // Detach VAR from its original block\n                        name2.addChildToBack(hookNode); // Replace original initializer with HOOK\n                        parent.replaceChild(n, var);\n                        reportCodeChange();\n                        return var;\n                    }\n                }\n            }\n        }\n    }\n\n    // No transformation applied for IF with ELSE in this section\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}