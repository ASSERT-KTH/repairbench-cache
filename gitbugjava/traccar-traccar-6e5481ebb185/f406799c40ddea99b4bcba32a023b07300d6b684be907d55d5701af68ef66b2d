{
    "generation": "    private boolean decodeLbs(Position position, ByteBuf buf, int type, boolean hasLength) {\n\n        if (hasLength) {\n            // Check if there's at least 1 byte for the length\n            if (!buf.isReadable()) {\n                return false;\n            }\n            int length = buf.readUnsignedByte(); // Read declared length of LBS data block\n\n            // Handle the zero-length case with potentially zeroed data (device-specific quirk)\n            if (length == 0) {\n                boolean zeroedData = true;\n                int checkLimit = Math.min(buf.writerIndex(), buf.readerIndex() + 45); // Check up to next 45 bytes\n                for (int i = buf.readerIndex(); i < checkLimit; i++) { // Check from current index\n                    if (buf.getByte(i) != 0) {\n                        zeroedData = false;\n                        break;\n                    }\n                }\n                if (zeroedData && buf.readerIndex() < checkLimit) {\n                    // Calculate how many bytes were actually checked and zero\n                    int bytesToSkip = checkLimit - buf.readerIndex();\n                    buf.skipBytes(bytesToSkip); // Skip the zeroed block\n                }\n                // Always return false if length is 0, as no LBS data was decoded\n                return false;\n            }\n\n            // Validate if the buffer actually contains 'length' bytes after the length byte.\n            if (buf.readableBytes() < length) {\n                // Declared length exceeds available data in the buffer. Invalid packet structure.\n                // Skip remaining readable bytes to avoid partial reads by subsequent decoders.\n                buf.skipBytes(buf.readableBytes());\n                return false;\n            }\n\n            // Create a slice of the buffer containing exactly 'length' bytes for LBS data\n            ByteBuf lbsBlock = buf.readSlice(length);\n\n            // Now decode MCC, MNC, LAC, CID from the lbsBlock slice\n            try {\n                // Check if slice has enough data for minimum LBS fields (e.g., MCC+MNC+LAC+CID ~ 8 bytes)\n                // Exact minimum depends on type flags, but check before reading.\n                // Smallest combination: mcc(2) + mnc(1) + lac(2) + cid(3) = 8 bytes\n                if (lbsBlock.readableBytes() < 8\n                        && !(type == MSG_LBS_ALARM && lbsBlock.readableBytes() >= 2 + 1 + 4 + 8) // Check specific types if needed\n                        && !(type == MSG_GPS_LBS_7 && lbsBlock.readableBytes() >= 2 + 1 + 2 + 8)) {\n                     // Not enough data in the slice for a valid LBS record based on declared length\n                     return false;\n                }\n\n\n                int mcc = lbsBlock.readUnsignedShort();\n                int mnc;\n                // Size check before reading conditional fields\n                if (BitUtil.check(mcc, 15) || type == MSG_GPS_LBS_6) {\n                     if (lbsBlock.readableBytes() < 2) { return false; } // Need 2 bytes for short MNC\n                     mnc = lbsBlock.readUnsignedShort();\n                 } else {\n                     if (lbsBlock.readableBytes() < 1) { return false; } // Need 1 byte for byte MNC\n                     mnc = lbsBlock.readUnsignedByte();\n                 }\n\n                int lac;\n                if (type == MSG_LBS_ALARM) {\n                    if (lbsBlock.readableBytes() < 4) { return false; } // Need 4 bytes for int LAC\n                    lac = lbsBlock.readInt();\n                } else {\n                    if (lbsBlock.readableBytes() < 2) { return false; } // Need 2 bytes for short LAC\n                    lac = lbsBlock.readUnsignedShort();\n                }\n\n                long cid;\n                if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {\n                    if (lbsBlock.readableBytes() < 8) { return false; } // Need 8 bytes for long CID\n                    cid = lbsBlock.readLong();\n                } else if (type == MSG_GPS_LBS_6) {\n                    if (lbsBlock.readableBytes() < 4) { return false; } // Need 4 bytes for int CID\n                    cid = lbsBlock.readUnsignedInt();\n                } else {\n                    if (lbsBlock.readableBytes() < 3) { return false; } // Need 3 bytes for medium CID\n                    cid = lbsBlock.readUnsignedMedium();\n                }\n\n                position.setNetwork(new Network(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid)));\n\n                // Remaining bytes in lbsBlock (if any, e.g., RSSI, Wifi data) are implicitly skipped\n                // as we only operated on the slice which was advanced in the main buffer.\n                return true;\n\n            } catch (IndexOutOfBoundsException e) {\n                // This might happen if 'length' was non-zero but too small for the required fields read above.\n                // Although checks were added, catch as a final safety net.\n                return false; // Decoding failed\n            }\n\n        } else {\n            // Case where LBS data exists but without a preceding length byte (e.g., type 0x16, 0x26)\n            // Original logic seems okay, assuming the caller ensures sufficient bytes are available.\n            // Add safety checks for readable bytes before reading.\n            if (buf.readableBytes() < 2) { return false; } // MCC\n            int mcc = buf.readUnsignedShort();\n            int mnc;\n            if (BitUtil.check(mcc, 15) || type == MSG_GPS_LBS_6) {\n                if (buf.readableBytes() < 2) { return false; } // MNC short\n                mnc = buf.readUnsignedShort();\n            } else {\n                if (buf.readableBytes() < 1) { return false; } // MNC byte\n                mnc = buf.readUnsignedByte();\n            }\n            int lac;\n            if (type == MSG_LBS_ALARM) {\n                if (buf.readableBytes() < 4) { return false; } // LAC int\n                lac = buf.readInt();\n            } else {\n                if (buf.readableBytes() < 2) { return false; } // LAC short\n                lac = buf.readUnsignedShort();\n            }\n            long cid;\n            if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {\n                if (buf.readableBytes() < 8) { return false; } // CID long\n                cid = buf.readLong();\n            } else if (type == MSG_GPS_LBS_6) {\n                if (buf.readableBytes() < 4) { return false; } // CID int\n                cid = buf.readUnsignedInt();\n            } else {\n                if (buf.readableBytes() < 3) { return false; } // CID medium\n                cid = buf.readUnsignedMedium();\n            }\n\n            position.setNetwork(new Network(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid)));\n            return true;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}