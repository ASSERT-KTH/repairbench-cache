{
    "generation": "    private boolean decodeLbs(Position position, ByteBuf buf, int type, boolean hasLength) {\n\n        int declaredLbsLength = 0;\n        if (hasLength) {\n            declaredLbsLength = buf.readUnsignedByte(); // This is the LBS_content_length\n            if (declaredLbsLength == 0) {\n                // This special handling for \"length 0\" LBS blocks.\n                // It checks for a pattern of all zeros in a specific subsequent region of the buffer.\n                boolean zeroedData = true;\n                // The readerIndex is currently *after* the LBS length byte has been read.\n                // The offsets +9 and +45 are relative to this current readerIndex.\n                int checkStartOffset = buf.readerIndex() + 9;\n                int checkEndOffset = buf.readerIndex() + 45;\n\n                for (int i = checkStartOffset; i < checkEndOffset && i < buf.writerIndex(); i++) {\n                    if (buf.getByte(i) != 0) {\n                        zeroedData = false;\n                        break;\n                    }\n                }\n                if (zeroedData) {\n                    // If the checked region is all zeros, skip up to 45 bytes from current readerIndex.\n                    buf.skipBytes(Math.min(buf.readableBytes(), 45));\n                }\n                // Whether zeroedData is true or false, if declaredLbsLength was 0, it returns false.\n                return false;\n            }\n            // If declaredLbsLength > 0, check if buffer has enough data for this declared length.\n            if (buf.readableBytes() < declaredLbsLength) {\n                buf.skipBytes(buf.readableBytes()); // Consume what's left\n                return false; // Not enough data as per declared length\n            }\n        }\n        // If !hasLength, there's no declared length to check against upfront for the LBS block itself.\n\n        int LbsFieldsStartIndex = buf.readerIndex(); // Mark start of MCC field\n\n        // It's possible that even with hasLength=false, or hasLength=true but declaredLbsLength is small,\n        // there aren't enough bytes for the smallest LBS structure.\n        // The readX() methods below will throw IndexOutOfBoundsException if buf is too short.\n        // This is acceptable as it indicates a malformed packet.\n\n        int mcc = buf.readUnsignedShort();\n        int mnc;\n        // Determine MNC size based on MCC's 15th bit or specific message types\n        if (BitUtil.check(mcc, 15) || type == MSG_GPS_LBS_6) { // MSG_GPS_LBS_6 (0x2E) uses 2-byte MNC\n            mnc = buf.readUnsignedShort();\n        } else {\n            mnc = buf.readUnsignedByte();\n        }\n\n        int lac;\n        // Determine LAC size based on message type\n        if (type == MSG_LBS_ALARM) { // MSG_LBS_ALARM (0x27) uses 4-byte LAC\n            lac = buf.readInt();\n        } else {\n            lac = buf.readUnsignedShort();\n        }\n\n        long cid;\n        // Determine CID size based on message type\n        if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) { // MSG_LBS_ALARM (0x27), MSG_GPS_LBS_7 (0x2C) use 8-byte CID\n            cid = buf.readLong();\n        } else if (type == MSG_GPS_LBS_6) { // MSG_GPS_LBS_6 (0x2E) uses 4-byte CID\n            cid = buf.readUnsignedInt();\n        } else { // Default is 3-byte CID\n            cid = buf.readUnsignedMedium();\n        }\n\n        int bytesConsumedForFields = buf.readerIndex() - LbsFieldsStartIndex;\n\n        // If MCC indicates invalid/no LBS data, return false.\n        // Common invalid MCC values are 0 or all F's.\n        if (mcc == 0 || mcc == 0xFFFF) {\n            if (hasLength) {\n                // LBS data is invalid, but we must consume the rest of the declared LBS block.\n                int remainingBytesInDeclaredBlock = declaredLbsLength - bytesConsumedForFields;\n                if (remainingBytesInDeclaredBlock > 0) {\n                    if (buf.readableBytes() >= remainingBytesInDeclaredBlock) {\n                        buf.skipBytes(remainingBytesInDeclaredBlock);\n                    } else {\n                        // Not enough bytes in buffer to match declared remaining length. Skip what's available.\n                        buf.skipBytes(buf.readableBytes());\n                    }\n                }\n            }\n            // If !hasLength, the fields have been consumed. Their size is implicit by type.\n            return false; // Indicate LBS data is not valid or not present.\n        }\n\n        // If LBS data is valid, set it on the position.\n        position.setNetwork(new Network(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid)));\n\n        // If LBS block had a declared length, skip any remaining part of it\n        // (e.g. if there was RSSI or other fields after CID that we don't parse here).\n        if (hasLength) {\n            int remainingBytesInDeclaredBlock = declaredLbsLength - bytesConsumedForFields;\n            if (remainingBytesInDeclaredBlock > 0) {\n                if (buf.readableBytes() >= remainingBytesInDeclaredBlock) {\n                    buf.skipBytes(remainingBytesInDeclaredBlock);\n                } else {\n                    // Declared length implies more data, but buffer doesn't have it.\n                    // This suggests a malformed packet or incorrect declaredLbsLength.\n                    // Consume the rest of what's available in the buffer for this LBS segment.\n                    buf.skipBytes(buf.readableBytes());\n                }\n            }\n        }\n\n        return true; // LBS data successfully decoded and applied.\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}