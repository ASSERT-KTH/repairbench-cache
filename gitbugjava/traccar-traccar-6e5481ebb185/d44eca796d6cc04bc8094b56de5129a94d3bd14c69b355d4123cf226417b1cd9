{
    "generation": "    private boolean decodeLbs(Position position, ByteBuf buf, int type, boolean hasLength) {\n\n        int length = 0;\n        int startIndex = buf.readerIndex(); // Mark start index before reading anything\n\n        if (hasLength) {\n            if (!buf.isReadable()) {\n                return false; // Not enough data to read length\n            }\n            length = buf.readUnsignedByte();\n            if (length == 0) {\n                // Length 0 means no LBS data block follows.\n                return false;\n            }\n            // If length is non-zero, the LBS data starts after the length byte\n            startIndex = buf.readerIndex();\n        }\n\n        // Check buffer readable capacity before attempting to read cell info\n        // Estimate minimum bytes needed (worst case might be larger)\n        int minBytesNeeded = 2 + 1 + 2 + 3; // MCC + MNC + LAC + CID (smallest combination)\n        if (buf.readableBytes() < minBytesNeeded) {\n             return false; // Not enough data for basic cell info\n        }\n\n        // Decode MCC, MNC, LAC, CID\n        int mcc = buf.readUnsignedShort();\n        int mnc;\n        boolean isMccHighBit = BitUtil.check(mcc, 15); // Check high bit before converting\n        int networkMcc = BitUtil.to(mcc, 15); // Use converted MCC for CellTower\n\n        // Determine MNC size and read\n        int mncBytes = (isMccHighBit || type == MSG_GPS_LBS_6) ? 2 : 1;\n        if (buf.readableBytes() < mncBytes) return false; // Check remaining bytes\n        mnc = (mncBytes == 2) ? buf.readUnsignedShort() : buf.readUnsignedByte();\n\n        // Determine LAC size and read\n        int lacBytes = (type == MSG_LBS_ALARM) ? 4 : 2;\n        if (buf.readableBytes() < lacBytes) return false; // Check remaining bytes\n        lac = (lacBytes == 4) ? buf.readInt() : buf.readUnsignedShort();\n\n        // Determine CID size and read\n        int cidBytes;\n        long cid;\n        if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {\n            cidBytes = 8;\n            if (buf.readableBytes() < cidBytes) return false;\n            cid = buf.readLong();\n        } else if (type == MSG_GPS_LBS_6) {\n            cidBytes = 4;\n            if (buf.readableBytes() < cidBytes) return false;\n            cid = buf.readUnsignedInt();\n        } else {\n            cidBytes = 3;\n            if (buf.readableBytes() < cidBytes) return false;\n            cid = buf.readUnsignedMedium();\n        }\n\n        position.setNetwork(new Network(CellTower.from(networkMcc, mnc, lac, cid)));\n\n        // Calculate bytes actually read for MCC, MNC, LAC, CID\n        int bytesRead = buf.readerIndex() - startIndex;\n\n        // Skip remaining bytes if length was provided\n        if (hasLength) {\n            // length field indicates the total size of the LBS data block (MCC, MNC, etc + any extra)\n            if (length > bytesRead) {\n                int bytesToSkip = length - bytesRead;\n                if (bytesToSkip > 0) {\n                    if (buf.readableBytes() >= bytesToSkip) {\n                        buf.skipBytes(bytesToSkip);\n                    } else {\n                        // Log warning or handle error: Not enough bytes left to skip according to length field\n                        // Skipping only readable bytes to avoid exception, but indicates data inconsistency\n                        buf.skipBytes(buf.readableBytes());\n                        return false; // Indicate potential issue by returning false? Or true since we got cell data? Stick with true for now.\n                    }\n                }\n            } else if (length < bytesRead) {\n                // Log warning or handle error: Length field value is less than bytes actually read. Protocol mismatch?\n                // Returning true as we successfully read cell data, but the length was inconsistent.\n            }\n            // If length == bytesRead, no skip needed.\n        }\n        // If !hasLength, assume LBS data ends after CID, no skip needed.\n\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}