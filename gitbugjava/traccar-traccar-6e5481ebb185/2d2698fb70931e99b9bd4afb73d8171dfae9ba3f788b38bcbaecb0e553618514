{
    "generation": "    private boolean decodeLbs(Position position, ByteBuf buf, int type, boolean hasLength) {\n\n        final int MIN_LBS_DATA_SIZE = 8; // Minimum bytes for MCC+MNC+LAC+CID (e.g., 2+1+2+3)\n        int length = 0;\n\n        if (hasLength) {\n            if (!buf.isReadable()) {\n                return false; // Cannot read length byte\n            }\n            length = buf.readUnsignedByte();\n\n            if (length == 0) {\n                // Original logic for zero length: check specific following bytes for zeros, skip if needed, return false.\n                boolean zeroedData = true;\n                int checkStartOffset = 9; // As per original code's logic\n                int checkBytes = 36;      // Original check span: readerIndex + 9 to readerIndex + 45 (exclusive end)\n                int baseIndex = buf.readerIndex();\n                for (int i = 0; i < checkBytes && baseIndex + checkStartOffset + i < buf.writerIndex(); i++) {\n                    if (buf.getByte(baseIndex + checkStartOffset + i) != 0) {\n                        zeroedData = false;\n                        break;\n                    }\n                }\n                if (zeroedData) {\n                    // Original code skipped up to 45 bytes *from current position* if zeroed\n                    buf.skipBytes(Math.min(buf.readableBytes(), 45));\n                }\n                return false; // Always return false if length byte is 0\n            }\n\n            // Check if buffer contains enough data for the specified length\n            if (buf.readableBytes() < length) {\n                buf.skipBytes(buf.readableBytes()); // Consume what's left\n                return false; // Not enough data for declared length\n            }\n\n            // Check if the declared length is sufficient for minimum LBS data\n            // Note: actual LBS data size varies, MIN_LBS_DATA_SIZE is the smallest possible.\n            // If length is less than this, it's definitely invalid.\n            if (length < MIN_LBS_DATA_SIZE) {\n                buf.skipBytes(length); // Skip the invalid block as indicated by length\n                return false; // Declared length too small for valid LBS\n            }\n            // We will read the LBS fields now, and later ensure we don't exceed 'length'.\n        } else {\n            // No length provided, check if we have at least minimum bytes for LBS\n            if (buf.readableBytes() < MIN_LBS_DATA_SIZE) {\n                return false; // Not enough data for minimal LBS reading\n            }\n        }\n\n        // Record start index to calculate bytes read later and for potential rollback/skip\n        int startReaderIndex = buf.readerIndex();\n        int bytesRead = 0; // Accumulate bytes read for LBS data\n\n        try {\n            // Read MCC (2 bytes)\n            if (buf.readableBytes() < 2) { return false; }\n            int mcc = buf.readUnsignedShort();\n            bytesRead += 2;\n\n            // Read MNC (1 or 2 bytes)\n            int mnc;\n            if (BitUtil.check(mcc, 15) || type == MSG_GPS_LBS_6) {\n                if (buf.readableBytes() < 2) { return false; }\n                mnc = buf.readUnsignedShort();\n                bytesRead += 2;\n            } else {\n                if (buf.readableBytes() < 1) { return false; }\n                mnc = buf.readUnsignedByte();\n                bytesRead += 1;\n            }\n\n            // Read LAC (2 or 4 bytes)\n            int lac;\n            if (type == MSG_LBS_ALARM) {\n                if (buf.readableBytes() < 4) { return false; }\n                lac = buf.readInt();\n                bytesRead += 4;\n            } else {\n                if (buf.readableBytes() < 2) { return false; }\n                lac = buf.readUnsignedShort();\n                bytesRead += 2;\n            }\n\n            // Read CID (3, 4 or 8 bytes)\n            long cid;\n            if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {\n                if (buf.readableBytes() < 8) { return false; }\n                cid = buf.readLong();\n                bytesRead += 8;\n            } else if (type == MSG_GPS_LBS_6) {\n                if (buf.readableBytes() < 4) { return false; }\n                cid = buf.readUnsignedInt();\n                bytesRead += 4;\n            } else {\n                if (buf.readableBytes() < 3) { return false; }\n                cid = buf.readUnsignedMedium();\n                bytesRead += 3;\n            }\n\n            // If length was provided, validate that we didn't read more bytes than declared\n            if (hasLength && bytesRead > length) {\n                 // Data inconsistency: Actual LBS fields took more space than the declared length.\n                 // Reset reader index to start and skip the 'length' bytes as declared.\n                 buf.readerIndex(startReaderIndex);\n                 buf.skipBytes(Math.min(length, buf.capacity() - startReaderIndex)); // Skip declared length safely\n                 return false;\n            }\n\n            // Successfully read LBS data, set network info\n            position.setNetwork(new Network(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid)));\n\n            // If length was provided, skip any remaining bytes within the declared length\n            if (hasLength) {\n                int remainingBytesInBlock = length - bytesRead;\n                if (remainingBytesInBlock > 0) {\n                    // We already checked buf.readableBytes() >= length initially,\n                    // and bytesRead <= length, so buffer should have these bytes. Skip defensively.\n                    buf.skipBytes(Math.min(remainingBytesInBlock, buf.readableBytes()));\n                }\n            }\n\n            return true; // Success\n\n        } catch (IndexOutOfBoundsException | NegativeArraySizeException e) {\n            // Catch potential buffer read errors if checks were insufficient or type caused unexpected read size.\n             if (hasLength) {\n                 // Try to recover by skipping the declared length from the start\n                 buf.readerIndex(startReaderIndex);\n                 buf.skipBytes(Math.min(length, buf.capacity() - startReaderIndex));\n             }\n             // else: no length, buffer likely truncated mid-read. Position might be inconsistent.\n            return false; // Indicate failure\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}