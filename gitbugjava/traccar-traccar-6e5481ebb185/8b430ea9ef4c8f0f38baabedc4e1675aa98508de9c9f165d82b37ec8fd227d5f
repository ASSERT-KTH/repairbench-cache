{
    "generation": "    private boolean decodeLbs(Position position, ByteBuf buf, int type, boolean hasLength) {\n\n        int lbsPayloadLength = 0;\n        if (hasLength) {\n            lbsPayloadLength = buf.readUnsignedByte();\n            if (lbsPayloadLength == 0) {\n                // This specific handling for lbsPayloadLength == 0 seems to be a device-specific\n                // workaround or for a special \"no LBS\" signal. It returns false, which prevents\n                // further LBS processing. This part is kept as is from the original code.\n                boolean zeroedData = true;\n                for (int i = buf.readerIndex() + 9; i < buf.readerIndex() + 45 && i < buf.writerIndex(); i++) {\n                    if (buf.getByte(i) != 0) {\n                        zeroedData = false;\n                        break;\n                    }\n                }\n                if (zeroedData) {\n                    buf.skipBytes(Math.min(buf.readableBytes(), 45));\n                }\n                return false;\n            }\n        }\n\n        int bytesReadForCellInfo = 0;\n\n        int mcc = buf.readUnsignedShort(); bytesReadForCellInfo += 2;\n        int mnc;\n        // The 15th bit of MCC indicates if MNC is 1 byte (standard) or 2 bytes (extended).\n        // MSG_GPS_LBS_6 also uses 2-byte MNC.\n        if (BitUtil.check(mcc, 15) || type == MSG_GPS_LBS_6) {\n            mnc = buf.readUnsignedShort(); bytesReadForCellInfo += 2;\n        } else {\n            mnc = buf.readUnsignedByte(); bytesReadForCellInfo += 1;\n        }\n\n        int lac;\n        if (type == MSG_LBS_ALARM) {\n            lac = buf.readInt(); bytesReadForCellInfo += 4;\n        } else {\n            lac = buf.readUnsignedShort(); bytesReadForCellInfo += 2;\n        }\n\n        long cid;\n        if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {\n            cid = buf.readLong(); bytesReadForCellInfo += 8;\n        } else if (type == MSG_GPS_LBS_6) {\n            cid = buf.readUnsignedInt(); bytesReadForCellInfo += 4;\n        } else { // Default case, includes MSG_LBS (protocol 0x12)\n            cid = buf.readUnsignedMedium(); bytesReadForCellInfo += 3;\n        }\n\n        // Use mcc without the 15th bit for the actual MCC value\n        position.setNetwork(new Network(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid)));\n\n        if (hasLength) {\n            // lbsPayloadLength is the total length of the LBS data block, starting from mcc.\n            // We have read 'bytesReadForCellInfo' for the main cell tower.\n            // Skip any remaining bytes in this LBS block.\n            if (lbsPayloadLength > bytesReadForCellInfo) {\n                buf.skipBytes(lbsPayloadLength - bytesReadForCellInfo);\n            } else if (lbsPayloadLength < bytesReadForCellInfo) {\n                // If the declared length is less than what we've read for essential cell info,\n                // it's a malformed packet. Indicate failure.\n                return false;\n            }\n            // If lbsPayloadLength == bytesReadForCellInfo, nothing to skip, which is correct.\n        }\n        // If !hasLength, the LBS data is assumed to consist of exactly mcc, mnc, lac, cid,\n        // and no additional data or length field. No skipping is needed.\n\n        return true;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}