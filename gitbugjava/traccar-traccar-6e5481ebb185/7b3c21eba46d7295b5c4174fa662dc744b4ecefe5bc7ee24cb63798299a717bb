{
    "generation": "    private boolean decodeLbs(Position position, ByteBuf buf, int type, boolean hasLength) {\n\n        int length = 0;\n        if (hasLength) {\n            if (buf.readableBytes() < 1) { // Not enough data for LBS length byte\n                return false;\n            }\n            length = buf.readUnsignedByte();\n            if (length == 0) {\n                // Special handling for LBS length 0 (often with zero padding after)\n                boolean zeroedData = true;\n                // Check a fixed block of 36 bytes (from offset 9 to 44 after length byte) for zeros\n                // The loop correctly handles buffer boundaries with `i < buf.writerIndex()`.\n                // If (buf.readerIndex() + 9) is already beyond writerIndex, loop doesn't run, zeroedData stays true.\n                for (int i = buf.readerIndex() + 9; i < buf.readerIndex() + 45 && i < buf.writerIndex(); i++) {\n                    if (buf.getByte(i) != 0) {\n                        zeroedData = false;\n                        break;\n                    }\n                }\n                if (zeroedData) {\n                    // If the checked block was zero (or not fully present and what was present was zero),\n                    // skip up to 45 bytes from the current position (after length byte).\n                    buf.skipBytes(Math.min(buf.readableBytes(), 45));\n                }\n                return false; // LBS data is considered invalid / not present if length byte is 0\n            }\n            // If length > 0, ensure the declared 'length' bytes are available in the buffer\n            if (buf.readableBytes() < length) {\n                return false; // Not enough data for the declared LBS data block\n            }\n        }\n\n        int lbsFieldsStartIndex = buf.readerIndex(); // To calculate actual bytes read for LBS fields\n\n        // MCC\n        if (buf.readableBytes() < 2) {\n            return false;\n        }\n        int mcc = buf.readUnsignedShort();\n\n        // MNC\n        int mnc;\n        boolean mncIsShort = BitUtil.check(mcc, 15) || type == MSG_GPS_LBS_6;\n        if (mncIsShort) {\n            if (buf.readableBytes() < 2) {\n                return false;\n            }\n            mnc = buf.readUnsignedShort();\n        } else {\n            if (buf.readableBytes() < 1) {\n                return false;\n            }\n            mnc = buf.readUnsignedByte();\n        }\n\n        // LAC\n        int lac;\n        if (type == MSG_LBS_ALARM) {\n            if (buf.readableBytes() < 4) {\n                return false;\n            }\n            lac = buf.readInt();\n        } else {\n            if (buf.readableBytes() < 2) {\n                return false;\n            }\n            lac = buf.readUnsignedShort();\n        }\n\n        // CID\n        long cid;\n        if (type == MSG_LBS_ALARM || type == MSG_GPS_LBS_7) {\n            if (buf.readableBytes() < 8) {\n                return false;\n            }\n            cid = buf.readLong();\n        } else if (type == MSG_GPS_LBS_6) {\n            if (buf.readableBytes() < 4) {\n                return false;\n            }\n            cid = buf.readUnsignedInt();\n        } else {\n            if (buf.readableBytes() < 3) {\n                return false;\n            }\n            cid = buf.readUnsignedMedium();\n        }\n\n        position.setNetwork(new Network(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid)));\n\n        if (hasLength) {\n            int bytesConsumedForLbsFields = buf.readerIndex() - lbsFieldsStartIndex;\n            if (length < bytesConsumedForLbsFields) {\n                // Declared LBS data length is less than what we needed for the fields. Malformed.\n                return false;\n            }\n            // Skip any remaining part of the LBS data block as per declared 'length'\n            int remainingBytesInLbsBlock = length - bytesConsumedForLbsFields;\n            if (remainingBytesInLbsBlock > 0) {\n                // Buffer was already checked to contain 'length' bytes (see `if (buf.readableBytes() < length)` above),\n                // so this skip is safe.\n                buf.skipBytes(remainingBytesInLbsBlock);\n            }\n        }\n        // If !hasLength, no specific LBS block length was declared.\n        // The fields were read based on type, and no further skip based on 'length' is applicable.\n        // The original code's `if (length > 9)` with `length=0` (when `!hasLength`) effectively did nothing,\n        // which is consistent with not needing to skip based on a non-existent LBS block length.\n\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}