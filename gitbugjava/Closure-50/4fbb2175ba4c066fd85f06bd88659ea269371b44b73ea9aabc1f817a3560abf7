{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.Iterator;\nimport java.util.List;\n\n// Assumed context: This method exists within a class that provides\n// `reportCodeChange()` and `InlineCostEstimator.getCost(Node)`.\n// Example: PeepholeReplaceKnownMethods.java\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   * Also handles partial folding: ['a', foo, 'b'].join(',') -> [\"a\", foo, \"b\"].join()\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    // n must be a CALL node\n    if (!n.isCall()) {\n        return n;\n    }\n    Node callTarget = n.getFirstChild();\n\n    // Target must be a GETPROP (like xxx.join)\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    // Structure must be [ARRAYLIT].join(...)\n    if (arrayNode == null || !arrayNode.isArrayLit()) {\n      return n;\n    }\n    // The property must be \"join\"\n    // Check isString() first for safety before getString()\n    if (functionName == null || !functionName.isString() || !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    Node right = callTarget.getNext(); // Separator argument\n    // Check separator validity and arity\n    if (right != null) {\n      // Separator must be constant (immutable) or omitted.\n      if (!NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n      // Array.join only takes one argument. Disallow more.\n      if (right.getNext() != null) {\n        return n;\n      }\n    }\n\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    // Check if the separator was explicitly the default \",\" string literal\n    // This matters for deciding whether to keep the arg in partial folding.\n    boolean isDefaultSeparator = (right == null || (right.isString() && right.getString().equals(\",\")));\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    boolean canFoldEverything = true; // Assume full folding is possible initially\n\n    // Iterate through array elements, folding adjacent immutable elements\n    while (elem != null) {\n      // Use isImmutableValue (covers primitives, null, void)\n      // Also handle EMPTY elements which act like empty strings in join.\n      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          // Append the separator if this is not the first segment being joined.\n          sb.append(joinString);\n        }\n        // Append the string value of the element. Handles null/undefined correctly.\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        // Encountered a non-foldable element (variable, function call, etc.)\n        canFoldEverything = false;\n        // Add any pending accumulated string node before the non-foldable one.\n        if (sb != null) {\n          Preconditions.checkNotNull(prev, \"Previous node must be set when sb is not null\");\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        // Add the non-foldable element, cloning it to avoid modifying the original AST.\n        arrayFoldedChildren.add(elem.cloneTree());\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    // Add the last accumulated string node if there is one.\n    if (sb != null) {\n      Preconditions.checkNotNull(prev, \"Previous node must be set when sb is not null\");\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n\n    // Decide on the replacement node based on the folding result.\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node parent = n.getParent(); // Get parent before potentially modifying n's structure\n\n    switch (arrayFoldedChildren.size()) {\n      case 0: {\n        // Case: [].join(...) => \"\"\n        Node emptyStringNode = Node.newString(\"\");\n        // Check if replacing with \"\" is smaller or equal cost.\n        if (InlineCostEstimator.getCost(emptyStringNode) <= originalSize) {\n            emptyStringNode.copyInformationIfMissingFrom(n);\n            parent.replaceChild(n, emptyStringNode);\n            reportCodeChange();\n            return emptyStringNode;\n        }\n        // If not smaller, return original node.\n        return n;\n      }\n\n      case 1: {\n        // Case: Result is a single element. It's either fully folded string,\n        // or a non-foldable element that needs string coercion.\n        Node onlyChild = arrayFoldedChildren.get(0);\n        Node replacement;\n        if (canFoldEverything) {\n            // Fully folded to a single string/value. Join result is always string.\n            Preconditions.checkState(onlyChild.isString(), \"Folded result should be a string node\");\n            replacement = onlyChild;\n        } else {\n            // Single non-foldable element, e.g., [foo].join(',')\n            // Coerce to string: \"\" + foo\n            replacement = new Node(Token.ADD, Node.newString(\"\"), onlyChild);\n            // Copy source info for the ADD node itself from the original CALL node.\n            replacement.copyInformationIfMissingFrom(n);\n            // Ensure the \"\" node also has source info.\n            replacement.getFirstChild().copyInformationIfMissingFrom(n);\n            // onlyChild is already cloned and should retain its info.\n        }\n\n        // Check if the replacement is smaller or equal cost.\n        if (InlineCostEstimator.getCost(replacement) <= originalSize) {\n            replacement.copyInformationIfMissingFrom(n); // Ensure final node has info\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n        }\n         // If not smaller, return original node.\n        return n;\n      }\n\n      default: { // Size > 1, indicates partial folding or no folding needed.\n        // Check if anything actually changed compared to the original array children.\n        boolean changed = false;\n        if (arrayFoldedChildren.size() != arrayNode.getChildCount()) {\n            changed = true;\n        } else {\n            Node curOrig = arrayNode.getFirstChild();\n            // Use iterator for the new list as it might not support get(index) efficiently.\n            Iterator<Node> itNew = arrayFoldedChildren.iterator();\n            while(curOrig != null && itNew.hasNext()) {\n                Node curNew = itNew.next();\n                // isEquivalentTo checks recursively if nodes are the same structure/values.\n                if (!curOrig.isEquivalentTo(curNew)) {\n                    changed = true;\n                    break;\n                }\n                curOrig = curOrig.getNext();\n            }\n            // If lengths matched, both iterators should end simultaneously.\n            // If not, it implies a structural difference was missed, treat as changed.\n            if (curOrig != null || itNew.hasNext()) {\n                 changed = true;\n            }\n        }\n\n        // If the array elements are effectively identical, no optimization to perform.\n        if (!changed) {\n          return n;\n        }\n\n        // Rebuild the call node with the new array children.\n        // Create the new ARRAYLIT node.\n        Node newArrayLit = new Node(Token.ARRAYLIT);\n        for (Node node : arrayFoldedChildren) {\n          newArrayLit.addChildToBack(node);\n        }\n        newArrayLit.copyInformationFrom(arrayNode); // Preserve source info of original array\n\n        // Clone the GETPROP node ([...].join) and replace its first child (the array).\n        Node newGetProp = callTarget.cloneTree();\n        newGetProp.replaceChild(newGetProp.getFirstChild(), newArrayLit);\n\n        // Create the new CALL node.\n        Node newCall = new Node(Token.CALL, newGetProp);\n        // Copy call properties (like isFreeCall) from the original call node.\n        newCall.copyInformationFrom(n);\n\n        // Add the separator argument back ONLY if it was provided AND it wasn't the default \",\" string literal.\n        // If the original call was `join(',')`, the new optimized call uses the default, becoming `join()`.\n        if (right != null && !isDefaultSeparator) {\n             newCall.addChildToBack(right.cloneTree());\n        }\n\n        // Check if the new structure is smaller or equal cost.\n        if (InlineCostEstimator.getCost(newCall) <= originalSize) {\n            newCall.copyInformationIfMissingFrom(n); // Ensure final node gets source info\n            parent.replaceChild(n, newCall);\n            reportCodeChange();\n            return newCall;\n        }\n        // If not smaller, return original node.\n        return n;\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}