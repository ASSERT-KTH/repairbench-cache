{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.AbstractCompiler; // Added for reportCodeChange signature context\nimport com.google.javascript.jscomp.InlineCostEstimator;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.List;\n\n// Assuming the context of a class that has access to reportCodeChange()\n// and potentially an AbstractCompiler instance.\n// The user requested only the function, so helper methods/fields are omitted in the final block.\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    // Ensure the node is a CALL node\n    if (!n.isCall()) {\n      return n;\n    }\n\n    Node callTarget = n.getFirstChild();\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    // Check if it's Array.prototype.join on an ARRAYLIT\n    if (arrayNode.getType() != Token.ARRAYLIT ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // Check arguments: join() or join(separator)\n    Node separatorNode = callTarget.getNext(); // First argument (separator)\n    Node secondArg = (separatorNode == null) ? null : separatorNode.getNext(); // Beyond first argument\n    if (secondArg != null) {\n      // Array.prototype.join takes at most one argument.\n      return n;\n    }\n\n    // If separator is specified, it must be immutable for folding.\n    if (separatorNode != null && !NodeUtil.isImmutableValue(separatorNode)) {\n      return n; // Separator must be constant\n    }\n\n    // Determine the separator string. Default is \",\".\n    // NodeUtil.getStringValue handles null, undefined, boolean, number -> string.\n    String joinString = (separatorNode == null) ? \",\" : NodeUtil.getStringValue(separatorNode);\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    Node prev = null; // Keep track of the last node processed for source info\n    Node elem = arrayNode.getFirstChild();\n\n    // Iterate through elements, merging adjacent constants\n    while (elem != null) {\n      // EMPTY nodes are treated as \"\" by Array.join\n      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          // Append the separator if this isn't the first element in the current sequence\n          sb.append(joinString);\n        }\n        // Append the string value of the element. Handles null/undefined/empty correctly.\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        // Non-constant element found\n        if (sb != null) {\n          // Add the accumulated string node before the non-constant element\n          Preconditions.checkNotNull(prev, \"StringBuilder should not be active before first element\");\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null; // Reset StringBuilder\n        }\n        // Add the non-constant element itself, cloned to avoid modifying the original tree\n        // before we commit to the change.\n        arrayFoldedChildren.add(elem.cloneTree());\n      }\n      prev = elem; // Update prev to the original node for source info propagation\n      elem = elem.getNext();\n    }\n\n    // Add any remaining accumulated string at the end\n    if (sb != null) {\n      // If sb != null, it means we processed at least one foldable element,\n      // so prev cannot be null here (unless the array was empty, but then sb would be null).\n      Preconditions.checkNotNull(prev, \"prev cannot be null if sb is set\");\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n\n    // Original size for comparison\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacementNode = null; // The node that will replace 'n' if optimization is beneficial\n    Node newCall = null; // Define here for scope if needed in default case\n\n    switch (arrayFoldedChildren.size()) {\n      case 0: // Original array was empty e.g., [].join() -> \"\"\n        replacementNode = Node.newString(\"\").copyInformationFrom(n);\n        break;\n\n      case 1: // Result is a single element (either fully folded string or single non-constant element)\n        Node foldedElement = arrayFoldedChildren.get(0);\n        if (foldedElement.isString()) {\n             // Result is already a string literal (e.g., \"a,b,c\" or from ['a', 'b'].join(','))\n             replacementNode = foldedElement;\n        } else {\n            // Result is a single non-string element (e.g. [foo].join() -> foo)\n            // The result of JS join is String(element). Represent as \"\" + element for compiler.\n            replacementNode = new Node(Token.ADD,\n                Node.newString(\"\").copyInformationFrom(n),\n                foldedElement); // foldedElement is already a clone or new node\n            replacementNode.copyInformationFrom(n); // Copy info to the ADD node\n        }\n        // Ensure top-level node has the original source info\n        replacementNode.copyInformationFrom(n);\n        break;\n\n      default: // Result is multiple elements (partial folding occurred)\n        // Check if the number of elements changed. If not, no structural folding occurred.\n        // However, elements might have changed (e.g. 'a', 'b' became \"a,b\").\n        // We rely on the cost comparison below to decide if the change is worthwhile.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n            // If element count is same, check if nodes actually changed.\n            // This check might be complex/costly. Let's rely on cost comparison.\n            // If cost isn't lower, we won't replace anyway.\n        }\n\n        // Create the potential new array literal node\n        Node newArray = new Node(Token.ARRAYLIT).copyInformationFrom(arrayNode);\n        for (Node node : arrayFoldedChildren) {\n          // Nodes in arrayFoldedChildren are either new strings or clones of original non-constants\n          newArray.addChildToBack(node);\n        }\n\n        // Create the new call structure: newArray.join(separator)\n        Node newGetProp = new Node(Token.GETPROP, newArray, functionName.cloneNode());\n        newCall = new Node(Token.CALL, newGetProp); // Assign to newCall defined outside switch\n        if (separatorNode != null) {\n          // Clone the original separator node to keep attributes and source info\n          newCall.addChildToBack(separatorNode.cloneTree());\n        }\n        newCall.copyInformationFrom(n); // Copy source info from original call\n\n        // This new call structure is the potential replacement node\n        replacementNode = newCall;\n        break;\n    }\n\n    // Check cost ONLY if a replacement is proposed\n    if (replacementNode != null) {\n      int newSize = InlineCostEstimator.getCost(replacementNode);\n      // Only replace if the new node is strictly smaller. \">=\" means no change or worse.\n      // Test case `testStringJoinAdd` with long separator implies stability if size >= original.\n      if (newSize >= originalSize) {\n         return n; // Not smaller, bail out, return original node.\n      }\n\n      // Perform the replacement in the AST\n      n.getParent().replaceChild(n, replacementNode);\n      reportCodeChange(); // Report modification\n      return replacementNode; // Return the new node\n    }\n\n    // No replacement was suitable (e.g., cost wasn't lower or no case matched for replacement)\n    return n;\n  }\n} // End of dummy class context",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}