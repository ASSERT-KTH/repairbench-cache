{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.InlineCostEstimator;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    // Input node must be a call node\n    if (!n.isCall()) {\n        return n;\n    }\n\n    Node callTarget = n.getFirstChild();\n    // The function called must be a GETPROP (like \"x.join\")\n    if (!NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionNameNode = callTarget.getLastChild(); // Property name is last child of GETPROP\n\n    // Check receiver is an ARRAYLIT and the function is \"join\"\n    // Rhino represents property names as STRING nodes.\n    if (!arrayNode.isArrayLit() ||\n        !functionNameNode.isString() ||\n        !functionNameNode.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // Check arguments to join()\n    Node separatorArg = callTarget.getNext(); // First argument to CALL\n    if (separatorArg != null) {\n      // Separator must be an immutable value (string, number, boolean, null, undefined)\n      if (!NodeUtil.isImmutableValue(separatorArg)) {\n        return n;\n      }\n      // Array.prototype.join takes at most one argument.\n      // While JS ignores extra arguments, folding is confusing/error-prone in this case.\n      if (separatorArg.getNext() != null) {\n        return n; // Don't fold if more than one argument is provided\n      }\n    }\n\n    // Determine the join separator string. If separatorArg is null, default is \",\".\n    String joinString = (separatorArg == null) ? \",\" : NodeUtil.getStringValue(separatorArg);\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    Node firstConsecutiveNode = null; // Track the source node for merged strings\n    int originalChildCount = 0;\n\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      originalChildCount++;\n      Node next = elem.getNext(); // Store next before potential modification/detachment\n\n      // Check if the element is foldable (immutable literal or empty slot)\n      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n        if (sb == null) {\n          sb = new StringBuilder();\n          firstConsecutiveNode = elem; // Mark the start of a foldable sequence\n        } else {\n          // Add the separator if this isn't the first element in the sequence\n          sb.append(joinString);\n        }\n        // Append the string value of the element (handles null/undefined correctly)\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        // Non-foldable element encountered, flush any accumulated string first\n        if (sb != null) {\n          Preconditions.checkNotNull(firstConsecutiveNode);\n          // Create a new string node for the merged sequence\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(firstConsecutiveNode));\n          sb = null;\n          firstConsecutiveNode = null;\n        }\n        // Add the non-foldable element (detach it from the original array)\n        arrayFoldedChildren.add(elem.detach());\n      }\n      elem = next;\n    }\n\n    // Flush the last accumulated string sequence if any\n    if (sb != null) {\n      Preconditions.checkNotNull(firstConsecutiveNode);\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(firstConsecutiveNode));\n    }\n\n    // Now evaluate the potential folding options based on cost\n\n    Node parent = n.getParent();\n    // Parent might be null if the node is detached, handle defensively.\n    if (parent == null) {\n        return n; // Cannot replace the node if it has no parent\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacementNode = n; // Default to no change\n\n    // Possibility 1: Fold entirely to a single node (String or Coerced non-string).\n    // This happens if the resulting list has 0 or 1 elements.\n    if (arrayFoldedChildren.isEmpty()) {\n        // Example: [].join() -> \"\"\n        Node emptyStringNode = Node.newString(\"\").copyInformationFrom(n);\n        if (InlineCostEstimator.getCost(emptyStringNode) < originalSize) {\n             replacementNode = emptyStringNode;\n        }\n    } else if (arrayFoldedChildren.size() == 1) {\n        // Example: ['a','b'].join('') -> \"ab\"\n        // Example: [foo].join(',') -> \"\" + foo\n        Node singleNode = arrayFoldedChildren.get(0); // This node is already detached or new\n        Node potentialReplacement = singleNode;\n\n        // If the single resulting element is not a string literal (e.g., it was [foo]),\n        // it needs explicit coercion to string according to how join works for single non-string elements.\n        if (singleNode.getType() != Token.STRING) {\n             potentialReplacement = new Node(Token.ADD,\n                Node.newString(\"\").copyInformationFrom(n), // Add \"\" to force string coercion\n                singleNode); // Use the node directly - it's already detached/new\n             potentialReplacement.copyInformationFrom(n);\n        }\n        // Note: if singleNode *was* already a STRING (e.g. from merging ['a','b']),\n        // potentialReplacement remains singleNode (the STRING node).\n\n        if (InlineCostEstimator.getCost(potentialReplacement) < originalSize) {\n            replacementNode = potentialReplacement;\n        }\n    }\n\n    // Possibility 2: Partially fold, keeping the join call but simplifying the array.\n    // This applies if the list has > 1 element AND elements were actually merged.\n    boolean didMerge = arrayFoldedChildren.size() < originalChildCount;\n    boolean canConsiderPartialFold = arrayFoldedChildren.size() > 1 && didMerge;\n\n    if (replacementNode == n && canConsiderPartialFold) {\n        // Example: ['a', foo, 'b', 'c'].join(',') -> [\"a\", foo, \"b,c\"].join()\n        // Build the potential new array node\n        Node newArrayNode = new Node(Token.ARRAYLIT).copyInformationFrom(arrayNode);\n        for (Node newNode : arrayFoldedChildren) {\n            // newNode is either a detached node from original array or a new STRING node\n            newArrayNode.addChildToBack(newNode);\n        }\n\n        // Build the potential new call node structure\n        // Clone the GETPROP node (e.g., xxx.join)\n        Node newCallTarget = callTarget.cloneNode();\n        // Replace the old array node (the first child of GETPROP) with the new one\n        newCallTarget.replaceChild(newCallTarget.getFirstChild(), newArrayNode);\n\n        // Create the new CALL node using the modified GETPROP\n        Node newCallNode = new Node(Token.CALL, newCallTarget).copyInformationFrom(n);\n\n        boolean separatorIsDefault = joinString.equals(\",\");\n        // Clone original separator arg if needed (only if it existed and wasn't default)\n        if (separatorArg != null && !separatorIsDefault) {\n            newCallNode.addChildToBack(separatorArg.cloneTree());\n        }\n        // If separatorArg was null or the separator was the default \",\",\n        // we simply don't add it to newCallNode, achieving optimization.\n\n        // Estimate cost of the partially folded call\n        int partialFoldSize = InlineCostEstimator.getCost(newCallNode);\n\n        if (partialFoldSize < originalSize) {\n             replacementNode = newCallNode;\n        }\n    }\n\n    // Perform the replacement if a beneficial fold was found\n    if (replacementNode != n) {\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n    }\n\n    // No beneficial change was made\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}