{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n// Assumes the context of a class that has reportCodeChange() and InlineCostEstimator available.\nabstract class ContainingClass {\n  abstract void reportCodeChange();\n  // Placeholder for the actual estimator\n  static class InlineCostEstimator {\n      static int getCost(Node n) { return 10; } // Dummy cost implementation\n  }\n\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    // Structure check: n must be a CALL node.\n    if (!n.isCall()) {\n        return n;\n    }\n\n    Node callTarget = n.getFirstChild();\n    // The target of the call must be a GETPROP node (like ... .join).\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    // Structure check: The GETPROP node must have the structure ARRAYLIT.join.\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = callTarget.getLastChild(); // Property name is the last child of GETPROP\n\n    // Use isArrayLit() for type checking.\n    if (arrayNode == null || !arrayNode.isArrayLit() ||\n        functionName == null || !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // Check arguments to join: should be 0 or 1.\n    Node separatorNode = callTarget.getNext(); // First argument\n    if (separatorNode != null) {\n        // If a separator argument exists, it must be an immutable value.\n        if (!NodeUtil.isImmutableValue(separatorNode)) {\n            return n;\n        }\n        // Check for extra arguments after the separator.\n        if (separatorNode.getNext() != null) {\n            // join() should not have more than one argument.\n            return n;\n        }\n    }\n\n    // All checks passed, proceed with folding attempt.\n\n    // Determine the separator string. Defaults to \",\" if no argument is provided.\n    String joinString = (separatorNode == null) ? \",\" : NodeUtil.getStringValue(separatorNode);\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null; // Used to accumulate adjacent foldable elements.\n    Node prev = null; // Keep track of the last node processed for copying source info.\n    Node elem = arrayNode.getFirstChild(); // Start iterating through array elements.\n\n    // Iterate through the elements of the array literal.\n    while (elem != null) {\n      // Check if the element is foldable: an immutable value (string, number,\n      // boolean, null, undefined) or an EMPTY node.\n      // NodeUtil.isImmutableValue handles null/undefined correctly.\n      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          // Add the join separator if this isn't the first foldable element in the sequence.\n          sb.append(joinString);\n        }\n        // Append the string value of the element. Handles null/undefined/empty correctly.\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        // Found a non-foldable element (e.g., a variable).\n        // First, add any accumulated string from the preceding foldable elements.\n        if (sb != null) {\n          Preconditions.checkNotNull(prev, \"Previous node should not be null when sb is not null\");\n          // Create a new string node for the folded part.\n          Node foldedString = Node.newString(sb.toString());\n          // Copy source info from the last node contributing to the string\n          foldedString.copyInformationFrom(prev);\n          arrayFoldedChildren.add(foldedString);\n          sb = null; // Reset the StringBuilder.\n        }\n        // Add the non-foldable element itself to the list of new children.\n        // We keep the original node instance.\n        arrayFoldedChildren.add(elem);\n      }\n      // Update prev to the current element before moving next.\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    // After the loop, add any remaining accumulated string.\n    if (sb != null) {\n      Preconditions.checkNotNull(prev, \"Previous node should not be null when sb is not null after loop\");\n      Node finalFoldedString = Node.newString(sb.toString());\n      // Copy source info from the last node contributing to the string\n      finalFoldedString.copyInformationFrom(prev);\n      arrayFoldedChildren.add(finalFoldedString);\n    }\n\n    // ---- Replacement Logic ----\n\n    Node parent = n.getParent();\n    if (parent == null) {\n      // Cannot replace the node if it has no parent.\n      return n;\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacementNode = null;\n\n    switch (arrayFoldedChildren.size()) {\n      case 0: // Array folded completely to an empty result, e.g., [].join() or [null].join()\n        // Result is always \"\". This is generally smaller/simpler than [].join(), etc.\n        replacementNode = Node.newString(\"\").copyInformationFrom(n);\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n\n      case 1: // Array folded into a single element.\n        Node onlyChild = arrayFoldedChildren.get(0);\n        int costCase1;\n\n        // Detach the child from the temporary list, as it will be re-parented.\n        onlyChild.detach();\n\n        if (onlyChild.isString()) {\n           // Result is a single string literal \"abc\".\n           replacementNode = onlyChild;\n           costCase1 = InlineCostEstimator.getCost(replacementNode);\n        } else {\n           // Result is a non-string value (e.g., number, variable). Needs coercion (\"\" + node).\n           replacementNode = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n), // Add empty string for coercion\n              onlyChild);\n           replacementNode.copyInformationFrom(n); // Copy overall source info\n           costCase1 = InlineCostEstimator.getCost(replacementNode);\n        }\n\n        // Only replace if the folded version is smaller or equal in size estimate.\n        if (costCase1 > originalSize) {\n          // Restore detached child if not replacing? No, onlyChild is local ref.\n          return n;\n        }\n\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode;\n\n      default: // Partial folding: >1 element remaining in arrayFoldedChildren.\n        // Check if the folding actually changed the array elements meaningfully.\n        // If the new list of children has the same size and elements as the original,\n        // it implies no strings were merged adjacent to non-literals.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n           boolean nodesChanged = false;\n           Node curOrig = arrayNode.getFirstChild();\n           int i = 0;\n           while (curOrig != null && i < arrayFoldedChildren.size()) {\n               // If a node in the folded list is not the same instance as the original,\n               // it implies either a string was folded or structure changed.\n               if (arrayFoldedChildren.get(i) != curOrig) {\n                   nodesChanged = true;\n                   break;\n               }\n               curOrig = curOrig.getNext();\n               i++;\n           }\n           // If counts match and no node instances changed, return original node.\n           if (!nodesChanged) {\n               return n;\n           }\n        }\n\n        // Optimization: If the original separator was explicitly \",\", make it implicit (remove arg).\n        boolean removeSeparator = (separatorNode != null && separatorNode.isString()\n                                    && separatorNode.getString().equals(\",\"));\n\n        // Calculate the cost of the potentially modified expression.\n        int foldedCost = calculatePartialFoldCost(arrayFoldedChildren, separatorNode, removeSeparator);\n\n        // Only perform the modification if it reduces code size estimate.\n        if (foldedCost > originalSize) {\n          return n;\n        }\n\n        // Perform the modification: Update the array node's children.\n        arrayNode.detachChildren(); // Clear existing children\n        for (Node node : arrayFoldedChildren) {\n          // Detach node from its potential previous parent (if it's an original non-folded element)\n          // before adding it to the modified arrayNode.\n          node.detach();\n          arrayNode.addChildToBack(node);\n        }\n\n        // Remove the separator argument from the CALL node if it was explicitly \",\".\n        if (removeSeparator) {\n           n.removeChild(separatorNode);\n        }\n\n        // Report the change and return the modified original node 'n'.\n        reportCodeChange();\n        return n;\n    }\n  }\n\n  /** Helper function to estimate the cost of the partially folded expression. */\n  private int calculatePartialFoldCost(List<Node> foldedChildren, Node separatorNode, boolean removingSeparator) {\n      // Create a temporary new array node with the folded children for cost estimation.\n      // We need to clone children as getCost might traverse them or modify them.\n      Node newArray = new Node(Token.ARRAYLIT);\n      for (Node node : foldedChildren) {\n          newArray.addChildToBack(node.cloneNode());\n      }\n      int arrayCost = InlineCostEstimator.getCost(newArray);\n\n      // Estimate the cost of the \".join()\" part. Using a fixed length is approximate.\n      // A more accurate approach might involve estimating GETPROP + CALL costs.\n      int joinOverhead = \".join()\".length(); // Rough estimate: dot, name, parens\n\n      // Cost of the separator argument, if it remains.\n      int separatorCost = 0;\n      if (separatorNode != null && !removingSeparator) {\n          separatorCost = InlineCostEstimator.getCost(separatorNode);\n      }\n\n      return arrayCost + joinOverhead + separatorCost;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}