{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 28-Aug-2018, tatu: Let's use non-copying pool-recycled TokenBuffer\n        //   during iteration, release when done, to minimize overhead.\n        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.currentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.currentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                // first buffer, then maybe create\n                if (buffer.assignParameter(creatorProp,\n                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        // 24-Aug-2016, tatu: As per [databind#1328], need to wrap\n                        //   building exception, regardless of whether it's theoretically\n                        //   possible to handle...\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    // first, let's see if we have anything buffered?\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        return ctxt.reportBadDefinition(_beanType, String.format(\n\"Cannot create polymorphic instances with unwrapped values (%s vs %s)\",\nbean.getClass().getName(), _beanType.getRawClass().getName()));\n                        // 05-Feb-2018, tatu: Wait. No. We should be able to...?\n                        // TODO: try to support\n                        /*\n                        return ctxt.reportInputMismatch(creatorProp,\n                                \"Cannot create polymorphic instances with unwrapped values\");\n                                */\n                    }\n\n                    // NOTE: Code here is different from version without unwrapped properties\n                    // Need to copy remaining tokens, prefix with buffered properties\n\n                    // This was the fix for [databind#2088]: ensure we copy FIELD_NAME along with value\n                    while (t == JsonToken.FIELD_NAME) {\n                        // Need to copy FIELD_NAME followed by value\n                        tokens.writeFieldName(p.currentName());\n                        p.nextToken(); // value\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken(); // Read next token to check if we are done\n                    }\n                    tokens.writeEndObject();\n\n                    // We were buffering, so need to consume the buffered tokens\n                    // 28-Aug-2018, tatu: ... which we can do directly from buffer\n                    TokenBuffer buffered = tokens; // alias for clarity\n                    tokens = null; // to ensure we won't accidentally release it below\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, buffered);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // External type id?\n            if (_externalTypeIdHandler != null) {\n                if (_externalTypeIdHandler.handlePropertyValue(p, ctxt, propName, null)) {\n                    continue;\n                }\n            }\n\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            // but... others should be passed to unwrapped property deserializers\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n\n            // Any setter? copy contents, maybe call setter on build()\n            // 10-Dec-2018, tatu: Need to be careful with possibly HUGE values; do not\n            //   try buffering these if using ANY_SETTER? Seems unlikely to be common\n            //   usage but maybe...\n            if (_anySetter != null) {\n                // 16-Aug-2018, tatu: As per [databind#2097], need to capture stored\n                //   value now, not just reference...\n                buffer.bufferAnyProperty(_anySetter, propName,\n                        _anySetter.deserialize(p, ctxt));\n            }\n            // note: this call is NOT complete, need to close Object too; caller will handle\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        // 28-Aug-2018, tatu: Need to release token buffer, if we have one\n        if (tokens != null) {\n            // We were buffering, so need to consume the buffered tokens\n            tokens.writeEndObject();\n            // 28-Aug-2018, tatu: ... which we can do directly from buffer\n            TokenBuffer buffered = tokens;\n            tokens = null; // to ensure we won't accidentally release it below\n            return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, buffered);\n        }\n        // If not, we may just have had creator properties, nothing buffered?\n        // unlikely, but check\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}