{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n        //    Ok however to pass via setter or field.\n\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to set?\n                // Need to deserialize value now, for creator property\n                Object value = _deserializeWithErrorWrapping(p, ctxt, creatorProp);\n                if (buffer.assignParameter(creatorProp, value)) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        // We can't yet know if input would be valid with potentially more creator\n                        // properties; report low-level problem with new wrapper. Can't use the\n                        // main standard helper as it assumes bean object is constructed.\n                        // 18-Dec-2017, tatu: Need message specific to \"through-creator\" problem.\n                         // 15-Jun-2018, tatu: Although... conceivably, we might be ok with\n                         //   the case of Unwrapped too? Or maybe not. Let's play it safe for now.\n                         return wrapInstantiationProblem(e, ctxt);\n                    }\n                    // [databind#631]: Assign current value, to be accessible by custom serializers\n                    p.setCurrentValue(bean);\n                    // if so, need to copy all remaining tokens into buffer\n                    // 15-Jun-2018, tatu [databind#2088]: Used to skip field name, shouldn't.\n                    while (t == JsonToken.FIELD_NAME) {\n                        // Fix [databind#2088]: Need to copy name _first_, then value etc\n                        tokens.writeFieldName(p.getCurrentName());\n                        p.nextToken(); // important: move to value\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                    //    problems if we maintain invariants\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                        //   it's too complicated, so bail out\n                        // 02-Aug-2013, tatu: Actually, we have to bail out, since buffer has tokens,\n                        //   may need to re-process based on actual type.\n                        // 15-Jan-2016, tatu: ... and more importantly, `processUnwrapped` requires\n                        //    bean to be of target type\n                        ctxt.reportBadDefinition(_beanType, String.format(\n\"Cannot create polymorphic instances with unwrapped values. Discovered type %s, expected %s\",\nbean.getClass().getName(), _beanType.getRawClass().getName()));\n                        // 16-Nov-2017, tatu: As per comments above, just can't deal with this.\n                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // External prop?\n            // 19-Jan-2017, tatu: Should this be handled earlier, like creator props? For now\n            //    assume after regular props is fine. Typically occurs with VPOs so...\n            if (_externalTypeIdHandler != null) {\n                if (_externalTypeIdHandler.handlePropertyValue(p, ctxt, propName, null)) {\n                    continue;\n                }\n            }\n\n            // 29-Nov-2016, tatu: probably should try to avoid sending content\n            //    both to any setter AND buffer... but, for now, the only thing\n            //    we can do.\n            // how about any setter? We'll get copies but...\n            if (_anySetter == null) {\n                // but... others should be passed to unwrapped property deserializers\n                 tokens.writeFieldName(propName);\n                 tokens.copyCurrentStructure(p);\n            } else {\n                // Need to copy to a separate buffer first\n                TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n                tokens.writeFieldName(propName);\n                tokens.append(b2);\n                try {\n                     // note: cannot call buffer.bufferAnyProperty() -- buffer is only used\n                     // for Creator properties. So must handle directly\n                     // 15-Jun-2018, tatu: ... which is problematic, but let's try this for now:\n                     buffer.bufferAnyProperty(_anySetter, propName,\n                             _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n             }\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            // We can't yet know if input would be valid with potentially more creator\n            // properties; report low-level problem with new wrapper. Can't use the\n            // main standard helper as it assumes bean object is constructed.\n            // 18-Dec-2017, tatu: Need message specific to \"through-creator\" problem.\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n        p.setCurrentValue(bean);\n        // And then need to process unwrapped properties...\n        if (_externalTypeIdHandler != null) {\n            // 19-Jan-2017, tatu: Important! If we use external type id, those properties\n            //    may be buffered, need to be resolved now. Uh-oh. Pass `null` buffer?\n            if (buffer.isComplete()) { // only if we have all creator props?\n                bean = _externalTypeIdHandler.complete(p, ctxt, bean);\n            } else {\n                 // 17-Apr-2018, tatu: Should call method that takes buffer, perhaps?\n                  _externalTypeIdHandler.complete(p, ctxt, buffer, creator);\n                  // ... and we are basically done? Or no? Probably not. Needs more work. For now:\n                  return bean;\n             }\n         }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}