{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   * This analysis considers the JavaScript evaluation order.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    // Base case: Found the variable NAME node. Check if it's a read.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // If it's the LHS of an assignment(-op) or inc/dec, the specific node handler\n      // below will determine the exact read/kill order based on evaluation rules.\n      // Otherwise (it's used in any other context), it's a read.\n      Node parent = n.getParent();\n      boolean isLhs = (parent != null) &&\n                      (parent.isAssign() || NodeUtil.isAssignmentOp(parent) || parent.isInc() || parent.isDec()) &&\n                      (parent.getFirstChild() == n);\n\n      if (!isLhs) {\n         // This is a read operation.\n         return VariableLiveness.READ;\n      } else {\n         // This is a NAME node on the LHS of an assignment or update.\n         // Let the specific handler for the parent ASSIGN/ASSIGN_OP/INC/DEC\n         // determine the effective operation order (read/kill).\n         // Return MAYBE_LIVE so the traversal continues to that parent handler.\n         return VariableLiveness.MAYBE_LIVE;\n      }\n    }\n\n    // Handle assignments (=) specially for evaluation order.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = n.getLastChild();\n\n      // 1. Check RHS first (evaluated before assignment).\n      VariableLiveness rhsLiveness = isVariableReadBeforeKill(rhs, variable);\n      if (rhsLiveness != VariableLiveness.MAYBE_LIVE) {\n        // Found the first read/kill on the RHS.\n        return rhsLiveness;\n      }\n\n      // 2. Check for reads within the LHS structure (e.g., a[x] = ..., evaluated before kill).\n      VariableLiveness lhsReadLiveness = isVariableReadBeforeKill(lhs, variable);\n      if (lhsReadLiveness == VariableLiveness.READ) {\n          // Found a read within the LHS structure itself.\n          return VariableLiveness.READ;\n      }\n\n      // 3. Check if the LHS node *is* the variable name being assigned to. This is the KILL site.\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n          // The KILL happens AFTER evaluating RHS and any reads within the LHS structure.\n          // If we reached here, no earlier read/kill was found.\n          return VariableLiveness.KILL;\n      }\n\n      // 4. If the variable wasn't read/killed in RHS, not read in LHS structure,\n      //    and the LHS isn't the variable name itself, maybe it was killed\n      //    within the LHS structure (e.g., a[x=1]=2 searching for x)?\n      //    Return the result from analyzing the LHS structure.\n      return lhsReadLiveness; // Returns KILL or MAYBE_LIVE\n    }\n\n    // Handle assignment operators (+=, -=, etc.). x += y roughly means x = x + y.\n    // Read of x happens first, then RHS, then kill of x.\n    if (NodeUtil.isAssignmentOp(n)) {\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n\n        // 1. Check for reads within the LHS structure itself (e.g., a[x] += ...)\n        //    This read happens before the implicit read of the LHS variable itself.\n        VariableLiveness lhsReadLiveness = isVariableReadBeforeKill(lhs, variable);\n        if (lhsReadLiveness == VariableLiveness.READ) {\n             return VariableLiveness.READ;\n        }\n        // Keep track of KILL/MAYBE_LIVE state from LHS structure analysis.\n\n        // 2. Check if the LHS node *is* the variable name. This implies an initial READ.\n        if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n            // The read of 'x' in 'x op y' happens before the RHS evaluation and the final assignment.\n            return VariableLiveness.READ;\n        }\n\n        // 3. Check the RHS for reads/kills (evaluated after LHS variable is read).\n        VariableLiveness rhsLiveness = isVariableReadBeforeKill(rhs, variable);\n        if (rhsLiveness != VariableLiveness.MAYBE_LIVE) {\n            return rhsLiveness;\n        }\n\n        // 4. If we reached here: Variable not read in LHS structure (step 1),\n        //    LHS is not the variable name (step 2 implies implicit read already returned),\n        //    and not read/killed in RHS (step 3).\n        //    The only possibility left is a KILL within the LHS structure or MAYBE_LIVE.\n       return lhsReadLiveness; // Returns KILL or MAYBE_LIVE\n    }\n\n\n    // Handle ++ and -- (read occurs first for both prefix and postfix).\n    if (n.isInc() || n.isDec()) {\n       Node operand = n.getFirstChild();\n\n       // 1. Check for reads/kills inside the operand structure first (e.g., a[x]++).\n       //    These happen during operand evaluation, before the inc/dec read/write.\n       VariableLiveness operandLiveness = isVariableReadBeforeKill(operand, variable);\n       if (operandLiveness == VariableLiveness.READ) { // Found read inside structure first.\n           return VariableLiveness.READ;\n       }\n       // Keep track of KILL/MAYBE_LIVE state.\n\n       // 2. If the operand itself is the variable name (e.g. x++).\n       if (NodeUtil.isName(operand) && variable.equals(operand.getString())) {\n           // The read of the variable's value happens before the kill (write back).\n           return VariableLiveness.READ;\n       }\n\n       // 3. If not read inside the structure, and the operand is not the variable name,\n       //    return the result from the operand structure analysis (KILL or MAYBE_LIVE).\n       return operandLiveness;\n    }\n\n\n    // General case: Traverse children left-to-right according to standard evaluation order.\n    // This handles operators like &&, ||, comma, etc., respecting their evaluation flow.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Skip FUNCTION nodes, as they represent a different scope/CFG boundary.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // Found the first read/kill in this child, return immediately.\n          return state;\n        }\n      }\n    }\n\n    // Variable was not read or killed in this subtree according to evaluation order.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}