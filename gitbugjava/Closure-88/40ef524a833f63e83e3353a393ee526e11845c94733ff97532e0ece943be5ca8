{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // Check NAME nodes for read or kill\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      Node parent = n.getParent();\n      // Check if n is the LHS of an assignment.\n      // Note: The assignment happens AFTER the right side is evaluated.\n      if (parent != null && parent.isAssign() && n == parent.getFirstChild()) {\n        // Check the right hand side for reads/kills of the variable first.\n        Node rhs = n.getNext();\n        VariableLiveness rhsLiveness = VariableLiveness.MAYBE_LIVE;\n        // Check rhs != null to be safe, and avoid recursing into new CFG nodes.\n        if (rhs != null && !ControlFlowGraph.isEnteringNewCfgNode(rhs)) {\n           rhsLiveness = isVariableReadBeforeKill(rhs, variable);\n        }\n\n        // If the RHS contains the first read or kill, that takes precedence\n        // over the kill from the assignment operation itself.\n        if (rhsLiveness != VariableLiveness.MAYBE_LIVE) {\n          return rhsLiveness;\n        }\n\n        // Otherwise, the assignment to this name is the first relevant operation\n        // originating from this ASSIGN node.\n        return VariableLiveness.KILL;\n      } else {\n        // This name is not being assigned to (or is not the direct LHS name),\n        // so it's a read reference.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are generally evaluated left-right, depth first.\n    // Recurse down the children.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Don't traverse into functions, as they have different scopes and CFGs.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // Found the first read or kill in this child subtree.\n          return state;\n        }\n      }\n    }\n\n    // No read or kill of the variable found in this subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}