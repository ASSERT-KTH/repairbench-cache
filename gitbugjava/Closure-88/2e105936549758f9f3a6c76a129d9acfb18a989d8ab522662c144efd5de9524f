{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable, according to evaluation order, is a read.\n   * It returns KILL, if the first reference of that variable, according\n   * to evaluation order, is an assignment or variable initialization.\n   * It returns MAY_LIVE otherwise.\n   * Note: This function's accuracy depends on the assumption of left-to-right\n   * evaluation order and does not account for control flow branching.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    switch (n.getToken()) {\n      case ASSIGN:\n        // Assignment: RHS is evaluated before the assignment occurs.\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n        // Check RHS first.\n        VariableLiveness rhsLiveness = isVariableReadBeforeKill(rhs, variable);\n        if (rhsLiveness != VariableLiveness.MAYBE_LIVE) {\n          return rhsLiveness;\n        }\n        // Check LHS. If the variable is the LHS, it's a kill, happening after RHS.\n        // The recursive call to isVariableReadBeforeKill for the LHS node\n        // itself (during the standard traversal below) will handle reads/kills\n        // within a complex LHS (e.g., obj[x] = 1). We only need to check\n        // here if the simple LHS name matches the variable.\n        if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n          return VariableLiveness.KILL;\n        }\n        // If LHS is complex, fall through to standard traversal to check its children.\n        // We still need to check the LHS structure itself via traversal.\n        VariableLiveness lhsLiveness = isVariableReadBeforeKill(lhs, variable);\n        if (lhsLiveness != VariableLiveness.MAYBE_LIVE) {\n           return lhsLiveness;\n        }\n        // If neither RHS nor LHS structure contains the first read/kill, it's MAYBE_LIVE.\n        // This point should technically not be reached if lhs is the variable name due to check above.\n        break;\n\n      case INC: // e.g., ++x or x++\n      case DEC: // e.g., --x or x--\n        Node operand = n.getFirstChild();\n        // Check if the operand is the variable itself.\n        if (NodeUtil.isName(operand) && variable.equals(operand.getString())) {\n          // Postfix (x++, x--) reads the value *before* the kill/update.\n          // Prefix (++x, --x) kills/updates the value *before* it's read (as the expression result).\n          boolean isPostfix = n.getBooleanProp(Node.INCRDECR_PROP);\n          return isPostfix ? VariableLiveness.READ : VariableLiveness.KILL;\n        }\n        // If operand is complex (e.g., obj[x]++), fall through for standard traversal of the operand.\n        break; // Let standard traversal handle operand children\n\n      case VAR:\n        // Handle declarations like 'var x = initializer;' or 'var x;'\n        Node nameNode = n.getFirstChild();\n        // Check if this VAR declares the variable we're looking for.\n        if (NodeUtil.isName(nameNode) && variable.equals(nameNode.getString())) {\n          Node initializer = nameNode.getFirstChild();\n          if (initializer != null) {\n            // Check initializer first.\n            VariableLiveness initializerLiveness = isVariableReadBeforeKill(initializer, variable);\n            if (initializerLiveness != VariableLiveness.MAYBE_LIVE) {\n              return initializerLiveness; // Found read/kill in initializer first.\n            }\n          }\n          // If no initializer or initializer didn't contain first read/kill, the declaration is a KILL.\n          return VariableLiveness.KILL;\n        }\n        // If this VAR is not for the variable, fall through for standard traversal of children (initializer).\n        break;\n\n       case NAME:\n         // If we encounter the name directly, it's a read, unless it's an LHS\n         // handled by the specific logic in ASSIGN, VAR, INC, DEC cases which check parents.\n         // Since those cases return directly, reaching here implies it's not one of those LHS cases.\n         if (variable.equals(n.getString())) {\n           return VariableLiveness.READ;\n         }\n         break;\n    }\n\n    // Standard recursive descent: process children left-to-right.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Skip nodes that introduce new control flow or scopes for this analysis.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // e.g., FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state; // Return first read/kill found in children.\n        }\n      }\n    }\n\n    // Variable not found as the first read/kill in this subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}