{
    "generation": "import java.net.MalformedURLException;\nimport java.net.URL;\nimport org.jsoup.helper.Validate; // Assuming Validate is in this package\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // Attribute missing, nothing to make absolute\n        }\n\n        String relUrl = attr(attributeKey).trim(); // Trim leading/trailing whitespace\n        if (relUrl.isEmpty()) {\n            return \"\"; // Attribute present but empty\n        }\n\n        // Check if relUrl is already absolute (has a protocol)\n        try {\n            URL abs = new URL(relUrl);\n            // Check if the protocol is present (e.g. http, https, file)\n            // URLs like \"//example.com/path\" are protocol-relative and need baseUri\n            // URLs like \"/path\" or \"file.html\" are path-relative and need baseUri\n            if (abs.getProtocol() != null && !abs.getProtocol().isEmpty()) {\n                return abs.toExternalForm(); // Already absolute\n            }\n        } catch (MalformedURLException e) {\n            // If it's not absolute or is malformed, fall through to resolve against baseUri\n        }\n\n        // Must be relative. Get the base URI.\n        URL base;\n        try {\n            // Ensure baseUri itself is valid and present\n            if (baseUri == null || baseUri.isEmpty()) return \"\"; // No base URI to resolve against\n            base = new URL(baseUri);\n        } catch (MalformedURLException e) {\n            // Base URI is invalid, cannot resolve\n            return \"\";\n        }\n\n        // Resolve relative URL against base\n        try {\n            URL abs;\n            // Workaround for Java's URL constructor behavior with query-only refs\n            // java resolves //path/file + ?foo to //path/?foo, not //path/file?foo as desired/spec\n            if (relUrl.startsWith(\"?\")) {\n                String baseSpec = base.toExternalForm();\n                int qPos = baseSpec.indexOf('?');\n                int fPos = baseSpec.indexOf('#'); // Also handle fragments\n\n                int cutPos = -1;\n                // Find the earliest position of '?' or '#'\n                if (qPos != -1 && fPos != -1) {\n                    cutPos = Math.min(qPos, fPos);\n                } else if (qPos != -1) {\n                    cutPos = qPos;\n                } else if (fPos != -1) {\n                    cutPos = fPos;\n                }\n\n                // Take the base string up to the query/fragment part\n                String pathAndQueryLessBase = (cutPos != -1) ? baseSpec.substring(0, cutPos) : baseSpec;\n                // Append the relative query string\n                abs = new URL(pathAndQueryLessBase + relUrl);\n            } else {\n                // Standard resolution for other relative URLs\n                abs = new URL(base, relUrl);\n            }\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            // Resolution failed (e.g. combining base + relUrl is invalid)\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}