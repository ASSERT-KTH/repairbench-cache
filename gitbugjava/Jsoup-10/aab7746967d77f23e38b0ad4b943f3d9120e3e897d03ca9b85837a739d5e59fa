{
    "generation": "    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        }\n\n        String relUrl = attr(attributeKey);\n\n        try {\n            // First, try to parse relUrl as an absolute URL. If it fails, it's likely relative, so fall through.\n            // Note that URL constructs GIGO - it will create an object even if the input is invalid. We check if it's valid by trying to parse it.\n            // See https://stackoverflow.com/questions/2942487/checking-if-string-is-a-valid-url\n            URL abs = new URL(relUrl);\n            // if it parses OK, is absolute. Handled. It may be an invalid URL, but we don't check that\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            // Fall through to resolve against base URI\n        }\n\n        // Needs a base URI to resolve a relative URL. StandaloneNodes may not have one.\n        if (baseUri == null || baseUri.length() == 0) {\n             // No base Uri, and URL is not absolute, so return empty string\n            return \"\";\n        }\n\n        URL base;\n        try {\n            base = new URL(baseUri);\n        } catch (MalformedURLException e) {\n            // If base URI is invalid, we can't resolve relative URLs against it.\n            return \"\";\n        }\n\n        try {\n            // Handle resolving \"?query\" against a base URI properly, as URL(base, \"?query\") does not work as expected\n            if (relUrl.startsWith(\"?\")) {\n                String path = base.getPath() != null ? base.getPath() : \"\";\n                // If the base path is empty but there's an authority, ensure path starts with /\n                String authority = base.getAuthority() != null ? base.getAuthority() : \"\";\n                if (authority.length() > 0 && path.isEmpty()) {\n                    path = \"/\";\n                } else if (authority.length() > 0 && path.charAt(0) != '/') {\n                    // Ensure path starts with / if authority present (should be done by URL constructor already, but be safe)\n                    // This case might not be strictly needed depending on URL impl, but covers edge cases.\n                     path = \"/\" + path;\n                }\n\n                int port = base.getPort();\n                String portString = (port != -1) ? \":\" + port : \"\";\n\n                // We need to reconstruct the base URL up to the path, then append the query.\n                // Using getProtocol, getAuthority, getPath handles nuances like ports or userinfo.\n                String resolvedUrlString = base.getProtocol() + \"://\" + authority + portString + path + relUrl;\n                URL resolved = new URL(resolvedUrlString);\n                return resolved.toExternalForm();\n            }\n\n            // For all other cases, use the standard URL constructor, which handles relative paths correctly.\n            URL abs = new URL(base, relUrl);\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            // Resolution failed (e.g., invalid relative URL part). Return empty string.\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}