{
    "generation": "import java.util.Stack;\n\npublic int[] calculateSpans(int[] prices) {\n\n    if (prices == null || prices.length == 0) {\n        return new int[0];\n    }\n\n    int[] spans = new int[prices.length];\n    spans[0] = 1; // Span of first element is always 1\n\n    Stack<Integer> indexStack = new Stack<>();\n\n    // Push the index of first element\n    indexStack.push(0);\n\n    for (int i = 1; i < prices.length; i++) {\n      // The original code used prices[indexStack.peek()] <= prices[i].\n      // This included consecutive equal prices in the span calculation,\n      // leading to spans like {1, 2, 3, 4} for {10, 10, 10, 10}.\n      // The failing test expects {1, 1, 1, 1} for this case.\n      // Changing <= to < ensures that we only pop indices with strictly\n      // smaller prices. When a price equal to the current price is encountered\n      // at the top of the stack, the loop terminates.\n      while (!indexStack.isEmpty()\n          && prices[indexStack.peek()] <= prices[i]) { // Keep popping while previous price is less than or equal\n          indexStack.pop();\n      }\n\n\n      // If index stack is empty, the price at index 'i'\n      // is greater than or equal to all previous values\n      if (indexStack.isEmpty())\n        spans[i] = i + 1;\n      else\n        // The span is the difference between the current index 'i'\n        // and the index of the first previous day with a strictly greater price.\n        spans[i] = i - indexStack.peek();\n\n      // Push current index onto the stack. It might be the PGL (Previous Greater element)\n      // for subsequent elements, or the PGE (Previous Greater or Equal) depending on interpretation.\n      // Given the fix aligns with standard span problem (<=), we push i.\n      indexStack.push(i);\n    }\n\n    // The above logic still produces {1, 2, 3, 4} for {10, 10, 10, 10}.\n    // Let's re-read the trace and the definition of span.\n    // Span: maximum number of *consecutive days* (starting *from* that day and going backward)\n    // for which the stock price was *less than or equal* to the price on that day.\n    // Day 0: prices[0]=10. Span=1. spans={1} stack={0}\n    // Day 1: prices[1]=10. prices[stack.peek()]=prices[0]=10. 10 <= 10. Pop 0. stack={}. stack is empty. spans[1]=1+1=2. spans={1,2}. Push 1. stack={1}.\n    // Day 2: prices[2]=10. prices[stack.peek()]=prices[1]=10. 10 <= 10. Pop 1. stack={}. stack is empty. spans[2]=2+1=3. spans={1,2,3}. Push 2. stack={2}.\n    // Day 3: prices[3]=10. prices[stack.peek()]=prices[2]=10. 10 <= 10. Pop 2. stack={}. stack is empty. spans[3]=3+1=4. spans={1,2,3,4}. Push 3. stack={3}.\n    // Result {1, 2, 3, 4}\n\n    // The test expects {1, 1, 1, 1}. This implies a different definition or interpretation.\n    // Maybe the span only includes strictly lesser prices *or* only the current day if previous are equal?\n    // Let's assume the test implies span is 1 if the *immediately preceding* day has an equal or greater price.\n    // This contradicts the standard \"consecutive days\" definition.\n\n    // If the test implies the span should be 1 when the price is equal to the previous *relevant* price found by the stack,\n    // we need to adjust how the stack is used or how the span is calculated.\n\n    // Let's rethink the condition `prices[indexStack.peek()] <= prices[i]`.\n    // If we want the span to be 1 for `10, 10`, the stack logic needs to find the nearest *strictly greater* element.\n    // The current logic finds the nearest *strictly greater* element because it pops *less than or equal* elements.\n    // If `prices[indexStack.peek()] <= prices[i]` is true, we pop.\n    // When the loop finishes, either the stack is empty (all previous <= current), or `prices[indexStack.peek()] > prices[i]`.\n    // If stack empty -> span = i + 1.\n    // If stack not empty -> span = i - indexStack.peek().\n\n    // Example {10, 10, 10, 10}:\n    // i=1: peek=0, price[0]=10. price[1]=10. 10 <= 10 is true. Pop 0. Stack empty. span[1] = 1+1=2. Push 1. Stack={1}.\n    // i=2: peek=1, price[1]=10. price[2]=10. 10 <= 10 is true. Pop 1. Stack empty. span[2] = 2+1=3. Push 2. Stack={2}.\n    // i=3: peek=2, price[2]=10. price[3]=10. 10 <= 10 is true. Pop 2. Stack empty. span[3] = 3+1=4. Push 3. Stack={3}.\n    // Output: {1, 2, 3, 4}. Code is correct according to standard definition. The test is likely wrong or uses a non-standard definition.\n\n    // To force the output {1, 1, 1, 1} for {10, 10, 10, 10}, we need the span calculation to yield 1 when equality occurs.\n    // Let's try modifying the calculation *after* the loop.\n    // When `prices[indexStack.peek()] == prices[i]`, maybe the span should be 1?\n    // But the stack state depends on previous pops.\n\n    // Let's reconsider the `while` loop condition. If we use `<` instead of `<=`.\n    // `while (!indexStack.isEmpty() && prices[indexStack.peek()] < prices[i])`\n    // Trace {10, 10, 10, 10} with `<`:\n    // i=1: peek=0, price[0]=10. price[1]=10. 10 < 10 is false. Loop doesn't run. Stack={0}. Stack not empty. span[1] = 1 - peek = 1 - 0 = 1. Push 1. Stack={0, 1}.\n    // i=2: peek=1, price[1]=10. price[2]=10. 10 < 10 is false. Loop doesn't run. Stack={0, 1}. Stack not empty. span[2] = 2 - peek = 2 - 1 = 1. Push 2. Stack={0, 1, 2}.\n    // i=3: peek=2, price[2]=10. price[3]=10. 10 < 10 is false. Loop doesn't run. Stack={0, 1, 2}. Stack not empty. span[3] = 3 - peek = 3 - 2 = 1. Push 3. Stack={0, 1, 2, 3}.\n    // Output: {1, 1, 1, 1}. This matches the test expectation.\n\n    // Therefore, the fix is to change `<=` to `<` in the while loop condition.\n\n    // Resetting and applying the fix:\n    int[] fixedSpans = new int[prices.length];\n    if (prices.length > 0) {\n        fixedSpans[0] = 1;\n    } else {\n        return fixedSpans; // Handle empty input case\n    }\n\n\n    Stack<Integer> fixedIndexStack = new Stack<>();\n    fixedIndexStack.push(0);\n\n    for (int i = 1; i < prices.length; i++) {\n      // Use '<' instead of '<=' to match the failing test's expected output.\n      // This means we pop only when the previous price is strictly smaller.\n      // If the previous price is equal or greater, we stop popping.\n      while (!fixedIndexStack.isEmpty()\n          && prices[fixedIndexStack.peek()] < prices[i]) { // FIX: Changed <= to <\n        fixedIndexStack.pop();\n      }\n\n      // If the stack is empty, it means the current price is strictly greater\n      // than all previous prices encountered so far in the loop.\n      // Span is i + 1.\n      if (fixedIndexStack.isEmpty()) {\n        fixedSpans[i] = i + 1;\n      } else {\n        // If the stack is not empty, fixedIndexStack.peek() holds the index 'p'\n        // of the nearest preceding element such that prices[p] >= prices[i].\n        // The span is the number of consecutive days ending at 'i'\n        // where the price was less than or equal to prices[i].\n        // According to the logic derived from the test case {10,10,10,10}->{1,1,1,1},\n        // the span should be the distance to the nearest preceding element\n        // that is *greater than or equal* to the current element.\n        // This distance is i - p.\n        fixedSpans[i] = i - fixedIndexStack.peek();\n      }\n\n      // Push the current index onto the stack.\n      fixedIndexStack.push(i);\n    }\n\n    return fixedSpans;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}