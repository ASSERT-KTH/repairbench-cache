{
    "generation": "  public int[] calculateSpans(int[] prices) {\n\n    int[] spans = new int[prices.length];\n    spans[0] = 1; // Span of first element is always 1\n\n    Stack<Integer> indexStack = new Stack<>();\n\n    // Push the index of first element\n    indexStack.push(0);\n\n    for (int i = 1; i < prices.length; i++) {\n      // The original condition `prices[indexStack.peek()] <= prices[i]`\n      // implies that if a previous price is equal to the current price,\n      // it should be popped from the stack, allowing the span to extend\n      // further back. This leads to spans like {1, 2, 3, 4} for {10, 10, 10, 10}.\n      //\n      // The failing test `testCalculateSpans6` expects {1, 1, 1, 1} for {10, 10, 10, 10}.\n      // This implies that for consecutive equal prices, the span should be 1.\n      // To achieve this, if a previous price is *equal* to the current price,\n      // its index should NOT be popped from the stack. It should serve as the\n      // 'barrier' for the current price's span, making the span calculation\n      // `i - indexStack.peek()` result in 1.\n      //\n      // Therefore, the condition to pop should only be for prices strictly less than\n      // the current price.\n      while (!indexStack.isEmpty()\n          && prices[indexStack.peek()] < prices[i]) // Changed from <= to <\n        indexStack.pop();\n\n      // If index stack is empty, it means all previous values were strictly smaller\n      // than the current price. So the span is 'i + 1' (including all previous days).\n      if (indexStack.isEmpty())\n        spans[i] = i + 1;\n      else\n        // Otherwise, indexStack.peek() holds the index of the first element to the left\n        // that is greater than or equal to the current price.\n        // The span is the difference between current index and that boundary index.\n        spans[i] = i - indexStack.peek();\n\n      indexStack.push(i);\n    }\n\n    return spans;\n  }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}