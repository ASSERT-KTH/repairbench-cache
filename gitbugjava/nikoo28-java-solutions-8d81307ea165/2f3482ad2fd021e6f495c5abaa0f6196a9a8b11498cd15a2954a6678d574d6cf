{
    "generation": "  public int[] calculateSpans(int[] prices) {\n\n    int[] spans = new int[prices.length];\n    // Assuming prices.length >= 1, as spans[0] is accessed unconditionally.\n    // This is typical for stock span problems and suggested by the original code structure.\n    if (prices.length == 0) {\n        return new int[0]; // Or handle as per specific problem constraints for empty input.\n                           // Removed to keep the fix minimal, assuming prices.length >= 1.\n    }\n    \n    spans[0] = 1; // Span of first element is always 1\n\n    Stack<Integer> indexStack = new Stack<>();\n\n    // Push the index of first element\n    indexStack.push(0);\n\n    for (int i = 1; i < prices.length; i++) {\n      // Changed condition from prices[indexStack.peek()] <= prices[i]\n      // to prices[indexStack.peek()] < prices[i].\n      // This prevents popping elements from the stack if their price is equal\n      // to the current price, which aligns with the failing test's expectation.\n      while (!indexStack.isEmpty()\n          && prices[indexStack.peek()] < prices[i]) {\n        indexStack.pop();\n      }\n\n      // If index stack is empty, the price at index 'i'\n      // is strictly greater than all previous values encountered so far in the loop.\n      if (indexStack.isEmpty()) {\n        spans[i] = i + 1;\n      } else {\n        // indexStack.peek() holds the index of the nearest previous day 'j'\n        // such that prices[j] >= prices[i].\n        // The span is the number of days from day j (exclusive, if prices[j] > prices[i])\n        // or day j (inclusive, if prices[j] == prices[i] and this is the definition) up to day i.\n        // This calculation gives i - j.\n        spans[i] = i - indexStack.peek();\n      }\n\n      indexStack.push(i);\n    }\n\n    return spans;\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}