{
    "generation": "    private Position decodeLocation2(DeviceSession deviceSession, ByteBuf buf, int type) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Replace Jt600ProtocolDecoder.decodeBinaryLocation(buf, position)\n        // with Huabao-specific GPS data parsing.\n        // Assumes buf is positioned at the start of the GPS data block.\n\n        // Date and Time (6 bytes BCD: YYMMDDHHMMSS)\n        DateBuilder dateBuilder = new DateBuilder()\n                .setYear(BcdUtil.readInteger(buf, 1))\n                .setMonth(BcdUtil.readInteger(buf, 1))\n                .setDay(BcdUtil.readInteger(buf, 1))\n                .setHour(BcdUtil.readInteger(buf, 1))\n                .setMinute(BcdUtil.readInteger(buf, 1))\n                .setSecond(BcdUtil.readInteger(buf, 1));\n        position.setTime(dateBuilder.getDate());\n\n        // Latitude and Longitude (4 bytes each, unsigned int)\n        // Common Huabao scaling: value / 1,000,000.0\n        double latitude = buf.readUnsignedInt() / 1000000.0;\n        double longitude = buf.readUnsignedInt() / 1000000.0;\n\n        // Speed (1 byte, kph)\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n\n        // Course and Status (2 bytes)\n        int courseStatus = buf.readUnsignedShort();\n\n        // Validity:\n        // Original logic: position.setValid(type != MSG_LOCATION_REPORT_BLIND);\n        // New logic combines this with GPS signal validity.\n        // Huabao common status bits: Bit 13 (0x2000) for positioning status (0=invalid, 1=valid)\n        if (type == MSG_LOCATION_REPORT_BLIND) {\n            position.setValid(false); // Blind reports are considered not currently valid\n        } else {\n            position.setValid((courseStatus & 0x2000) != 0); // Validity from GPS signal\n        }\n\n        // Hemisphere and Course from courseStatus word\n        // Bit 15 (0x8000): Latitude South (0 North, 1 South)\n        if ((courseStatus & 0x8000) != 0) {\n            latitude = -latitude;\n        }\n        // Bit 14 (0x4000): Longitude West (0 East, 1 West)\n        if ((courseStatus & 0x4000) != 0) {\n            longitude = -longitude;\n        }\n        position.setLatitude(latitude);\n        position.setLongitude(longitude);\n        position.setCourse(courseStatus & 0x03FF); // Course in lower 10 bits (0-9)\n\n        // The above GPS block consumes 6 + 4 + 4 + 1 + 2 = 17 bytes.\n        // The original line \"position.setValid(type != MSG_LOCATION_REPORT_BLIND);\" is now handled.\n\n        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000L);\n\n        int battery = buf.readUnsignedByte();\n        if (battery <= 100) {\n            position.set(Position.KEY_BATTERY_LEVEL, battery);\n        } else if (battery == 0xAA) { // Common value for charging status\n            position.set(Position.KEY_CHARGE, true);\n        }\n\n        position.setNetwork(new Network(CellTower.fromCidLac(\n                getConfig(), buf.readUnsignedInt(), buf.readUnsignedShort())));\n\n        int product = buf.readUnsignedByte();\n        int status = buf.readUnsignedShort(); // Device status\n        int alarm = buf.readUnsignedShort();  // Alarm information\n\n        // Alarm processing based on product type\n        if (product == 1 || product == 2) {\n            if (BitUtil.check(alarm, 0)) {\n                position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER);\n            }\n        } else if (product == 3) {\n            position.set(Position.KEY_BLOCKED, BitUtil.check(status, 5)); // Assuming bit 5 of device status means blocked\n            if (BitUtil.check(alarm, 1)) {\n                position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER);\n            }\n            if (BitUtil.check(alarm, 2)) {\n                position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n            }\n            if (BitUtil.check(alarm, 3)) {\n                position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY);\n            }\n        }\n\n        position.set(Position.KEY_STATUS, status); // Store the raw device status\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}