{
    "generation": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode(); // The NAME node for the variable 'v'\n        Node parent = n.getParent(); // The node containing the declaration (VAR, FUNCTION, etc.)\n\n        // Assume it's not a valid alias unless proven otherwise.\n        boolean isAlias = false;\n\n        // Check if it's a 'var' declaration aliasing a qualified name.\n        // We only allow aliases of the form:\n        // var A = B.C;\n        if (parent.isVar()) {\n          Node initialValue = v.getInitialValue();\n          if (initialValue != null && initialValue.isQualifiedName()) {\n            // It looks like 'var name = qualified.name;'\n            String name = v.getName(); // Use Var's name\n            String qualifiedName = initialValue.getQualifiedName();\n            // getQualifiedName() can return null for valid qualified names\n            // like \"this.foo\". We don't want to alias those.\n            if (qualifiedName != null && initialValue.isGetProp()) {\n               aliases.put(name, v);\n               transformation.addAlias(name, qualifiedName);\n               isAlias = true; // Mark as a valid alias\n            }\n          }\n          // else: It's a 'var' declaration but not a qualified name alias\n          // (e.g., var x = 10; var x = function(){}; var x;).\n          // 'isAlias' remains false.\n        }\n        // else: It's not a 'var' declaration (e.g., function f() {}, param, catch).\n        // 'isAlias' remains false.\n\n        // Report error for declarations that are not valid aliases.\n        // We expect only aliases (var x = goog.module) within a goog.scope body.\n        // Other variable or function declarations (var x = 10; function y() {}) are disallowed.\n        // Parameters (parent.isParamList()) and catch variables (parent.isCatch()) are allowed implicitly\n        // as their parents are not VAR or FUNCTION.\n        if (!isAlias) {\n          if (parent.isVar() || parent.isFunction()) {\n            // Don't warn about bleeding functions, they are handled elsewhere.\n            // TODO(robbyw): Consider adding a specific exemption if v.isBleedingFunction() is true,\n            // although the original code structure didn't seem to do this explicitly here.\n            // For now, report for any local var/function that isn't a valid alias.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}