{
    "generation": "    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws IllegalArgumentException if the field type is already present and the value is invalid for that field\n     * @throws IllegalArgumentException if the field type is not already present and is incompatible with the other fields\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            // Field type not present, add it\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField); // Compare durations\n                        if (compare > 0) { // New field duration is shorter than loop field duration\n                            break; // Insert new field before loop field\n                        } else if (compare == 0) { // Durations are equal\n                            // Compare range durations\n                            DurationField rangeField = null;\n                            DurationFieldType rangeFieldType = fieldType.getRangeDurationType();\n                            if (rangeFieldType != null) {\n                                rangeField = rangeFieldType.getField(iChronology);\n                            }\n                            \n                            DurationField loopRangeField = null;\n                            DurationFieldType loopRangeFieldType = loopType.getRangeDurationType();\n                             if (loopRangeFieldType != null) {\n                                loopRangeField = loopRangeFieldType.getField(iChronology);\n                            }\n\n                            if (rangeField == null) {\n                                if (loopRangeField != null) {\n                                    break; // New field is smaller (null range) -> insert before\n                                }\n                                // Both null ranges: clash as fields have same duration and null range.\n                                throw new IllegalArgumentException(\"Field '\" + fieldType + \"' has the same duration and null range fields as '\" + loopType + \"'\");\n\n                            } else if (loopRangeField == null) {\n                                // New field non-null range, loop field null range. New field is \"larger\".\n                                // Continue loop to insert after loop field.\n                            } else {\n                                // Both ranges non-null, compare them.\n                                int rangeCompare = rangeField.compareTo(loopRangeField);\n                                if (rangeCompare > 0) { // New field range duration is shorter than loop field range\n                                    break; // Insert new field before loop field\n                                } else if (rangeCompare == 0) { // Ranges are equal too\n                                    // Fields have same duration and same range. This is not allowed.\n                                    throw new IllegalArgumentException(\"Field '\" + fieldType + \"' has the same duration (\" + unitField.getName() + \") and range (\" + rangeField.getName() + \") as '\" + loopType + \"'\");\n                                }\n                                // else rangeCompare < 0: New field range is larger. Continue loop to insert after loop field.\n                            }\n                        }\n                        // else compare < 0: New field duration is longer. Continue loop to insert after loop field.\n                    }\n                }\n            } else {\n                // If the new field's duration is not supported, insert it at the end\n                // based on the assumption that unsupported durations are ordered last.\n                i = iTypes.length;\n            }\n\n            // Copy arrays and insert new field at determined position i\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);\n            System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);\n            \n            // Use public constructor to ensure full validation, including chronology validation.\n            // This constructor will validate the field combination and ordering again.\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            // The constructor already called validate, no need to call it again.\n            // iChronology.validate(newPartial, newValues); // Removed redundant call\n            return newPartial;\n            \n        } else {\n            // Field type already present, update value\n            if (value == getValue(index)) {\n                return this; // No change, return same instance\n            }\n            // Get a copy of the values and use the field's set method\n            // to update the value (this handles validation within the field).\n            int[] newValues = getValues();\n            newValues = getField(index).set(this, index, newValues, value);\n            // Create a new Partial instance with the updated values array.\n            return new Partial(this, newValues);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}