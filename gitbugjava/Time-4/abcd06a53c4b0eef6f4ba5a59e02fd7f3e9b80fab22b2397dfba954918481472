{
    "generation": "    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            // --- BEGIN FIX ---\n            // Check for incompatibility: A field is incompatible if the duration and range duration match an existing field.\n            DurationField newUnitField = fieldType.getDurationType().getField(iChronology);\n            DurationField newRangeField = null;\n            if (fieldType.getRangeDurationType() != null) {\n                newRangeField = fieldType.getRangeDurationType().getField(iChronology);\n            }\n\n            for (int i = 0; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (newUnitField.isSupported() && loopUnitField.isSupported() && newUnitField.getType().equals(loopUnitField.getType())) {\n                    DurationField loopRangeField = null;\n                    if (loopType.getRangeDurationType() != null) {\n                        loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                    }\n                    // Check if range duration fields match (or are both null)\n                    boolean rangeFieldsMatch;\n                    if (newRangeField == null) {\n                        rangeFieldsMatch = (loopRangeField == null);\n                    } else {\n                        rangeFieldsMatch = (loopRangeField != null &&\n                                            newRangeField.isSupported() && // Check if fields are supported before comparing type\n                                            loopRangeField.isSupported() &&\n                                            newRangeField.getType().equals(loopRangeField.getType()));\n                    }\n\n                    if (rangeFieldsMatch) {\n                        // Found a field with the same duration and range duration.\n                        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is already supported by '\" + loopType + \"'\");\n                    }\n                }\n            }\n            // --- END FIX ---\n\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            // DurationField unitField = fieldType.getDurationType().getField(iChronology); // Use newUnitField from check\n            if (newUnitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = newUnitField.compareTo(loopUnitField);\n                        if (compare > 0) { // new unit is > loop unit (eg years > months)\n                            break;\n                        } else if (compare == 0) { // units are equal (eg hours == hours)\n                            // DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); // Use newRangeField from check\n                            DurationField loopRangeField = null;\n                            if (loopType.getRangeDurationType() != null) {\n                                 loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            }\n                            // Handle nulls in comparison for insertion order\n                            if (newRangeField == null) {\n                                if (loopRangeField != null) {\n                                    break; // New is null (bigger range), loop is not. Insert new before loop.\n                                }\n                                // Both null. Order doesn't matter based on range. Continue search.\n                            } else { // newRangeField != null\n                                if (loopRangeField == null) {\n                                    // New is not null, loop is null (bigger range). Continue search.\n                                } else {\n                                     // Both non-null, compare them.\n                                     if (newRangeField.compareTo(loopRangeField) > 0) { // New range > loop range\n                                         break; // Insert new before loop.\n                                     }\n                                     // If new range <= loop range, continue search.\n                                }\n                            }\n                        }\n                        // else if (compare < 0) - new unit < loop unit (eg minutes < hours), continue searching\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i); // Original length was correct\n            System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i); // Original length was correct\n            // use public constructor to ensure full validation (value range, etc)\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            // iChronology.validate(newPartial, newValues); // Constructor already calls validate, remove redundant call\n            return newPartial;\n        }\n\n        // Field already exists - update value\n        if (value == getValue(index)) {\n            return this; // No change\n        }\n        int[] newValues = getValues(); // Get a copy\n        // Use the chronology-specific DateTimeField to set the value, which handles validation and cascading effects if necessary (though Partial is normally simple)\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues); // Constructor validates the potentially changed values\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}