{
    "generation": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      // Calculate the index of the first reference after the declaration and\n      // initialization. If declaration and initialization are the same reference,\n      // it's the second reference (index 1). Otherwise, it's the third (index 2).\n      // The list indices are 0-based. The reference list is [decl, init?, ref1, ref2, ...]\n      // So the first actual *use* is at index 1 if decl==init, or index 2 if decl!=init.\n      // firstRefAfterInit points to the position *after* the first use.\n      int firstUseIndex = (declaration == init) ? 1 : (init != null ? 2 : 1);\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (init != null && refCount == firstUseIndex + 1) {\n        // The variable is declared, initialized, and used exactly once.\n        Reference reference = referenceInfo.references.get(firstUseIndex);\n        Node value = init.getAssignedValue();\n\n        // Fix for issue 1053:\n        // Don't inline non-immutable values in the read-once case.\n        // This is because the value might change between the initialization\n        // and the reference point due to side effects (e.g., function calls\n        // modifying the source variable). Example: var x = u; f(); print(x);\n        // If 'u' is modified by f(), inlining 'u' for 'x' is incorrect.\n        // A more sophisticated analysis could check for side effects between\n        // init and reference, but checking for immutability is a safe,\n        // conservative approximation.\n        boolean valueIsImmutable = (value != null && NodeUtil.isImmutableValue(value));\n\n        if (valueIsImmutable && canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && refCount == 2 && init != null) {\n        // This case handles: var v; v = foo(); (and v is never used again).\n        // Note: refCount == 2 means references are [decl, init]. No uses.\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only reference after declaration is the initialization.\n          // Remove the assignment if the value has no side effects, and\n          // remove the variable declaration.\n          // Current implementation calls inlineWellDefinedVariable, which seems incorrect\n          // for this case (it would try to replace decl/init with value).\n          // TODO(johnlenz): Fix this case to actually remove unused variables/assignments.\n          // For now, let's keep the potentially incorrect logic or simply do nothing.\n          // Let's avoid calling inlineWellDefinedVariable as it's likely wrong here.\n          // Consider removing the assignment if safe.\n           Node assignedValue = init.getAssignedValue();\n           if (assignedValue != null && !NodeUtil.mayHaveSideEffects(assignedValue, compiler)) {\n              Node assignmentNode = init.getNode().getParent(); // Assuming init.getNode() is NAME in ASSIGN\n              if (NodeUtil.isExprAssign(assignmentNode)) { // Check if it's 'v = foo();'\n                 NodeUtil.removeChild(assignmentNode.getParent(), assignmentNode);\n                 compiler.reportCodeChange();\n                 // Remove the var declaration too?\n                 Node varNode = declaration.getNode().getParent(); // Assuming declaration.getNode() is NAME in VAR\n                 if (varNode.isVar() && varNode.hasOneChild()) { // Only child is 'v'\n                    NodeUtil.removeChild(varNode.getParent(), varNode);\n                    compiler.reportCodeChange();\n                    // Mark 'v' as stale since its declaration is gone.\n                    staleVars.add(v);\n                 }\n              }\n           }\n           // Previous logic (likely incorrect for this specific case):\n           // Node value = init.getAssignedValue();\n           // Preconditions.checkNotNull(value);\n           // inlineWellDefinedVariable(v, value, referenceInfo.references);\n           // staleVars.add(v);\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n          // Inlining the variable based solely on well-defined and assigned\n          // once is *NOT* correct unless the variable is constant.\n          // We relax this for alias inlining, guarded by checks below.\n        List<Reference> refs = referenceInfo.references;\n        for (int i = 1 /* start from a read/init */; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          // Don't attempt alias inlining if the reference is the initializing assignment\n          // or part of the declaration. Alias inlining replaces reads.\n          if (nameNode == init.getNode() || nameNode == declaration.getNode()) {\n              continue;\n          }\n\n          if (aliasCandidates.containsKey(nameNode)) {\n            AliasCandidate candidate = aliasCandidates.get(nameNode);\n            // Check if the alias itself is eligible for inlining\n            if (!staleVars.contains(candidate.alias) &&\n                !isVarInlineForbidden(candidate.alias) &&\n                candidate.refInfo.isWellDefined() && // Alias should be well-defined\n                candidate.refInfo.isAssignedOnceInLifetime() // Alias assigned once\n                /* && isImmutableAndWellDefinedVariable(candidate.alias, candidate.refInfo) ? */ // Maybe stricter check?\n                ) {\n              Reference aliasInit = candidate.refInfo.getInitializingReference();\n              if (aliasInit != null) { // Ensure alias was initialized\n                 Node value = aliasInit.getAssignedValue();\n                 if (value != null) { // Ensure alias has a value\n                    // Inline the alias variable with its value\n                    inlineWellDefinedVariable(candidate.alias,\n                                              value,\n                                              candidate.refInfo.references);\n                    staleVars.add(candidate.alias);\n                    // Note: This inlines the *alias*, not the original variable 'v'.\n                    // It might make 'v' eligible for inlining later if 'v' aliased 'candidate.alias'.\n                 }\n              }\n            }\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}