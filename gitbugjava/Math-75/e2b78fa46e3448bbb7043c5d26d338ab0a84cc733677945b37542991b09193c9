{
    "generation": "    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n        final long sumFreq = getSumFreq();\n        if (sumFreq == 0) {\n            return Double.NaN;\n        }\n        try {\n            // Cast to Comparable needed for getCount(Comparable) call later\n            // Maintains compatibility between this Object version and the Comparable version\n            @SuppressWarnings(\"unchecked\") // v is verified to be Comparable below\n            Comparable<Object> comparableV = (v instanceof Comparable) ? (Comparable<Object>) v : new Comparable<Object>() {\n                /** {@inheritDoc} */\n                @Override\n                public int compareTo(Object other) {\n                    return String.valueOf(v).compareTo(String.valueOf(other));\n                }\n            };\n            // Use getCount(Comparable) to ensure consistent counting logic with other methods\n            return (double) getCount(comparableV) / (double) sumFreq;\n        } catch (ClassCastException ex) {\n            // v is not Comparable, try to convert to String and lookup count\n            // Note: This path might deviate from getPct(Comparable) behavior\n            // if v's toString() representation doesn't match how it would compare\n            // if it were Comparable. However, it preserves the behavior of\n            // looking up non-Comparable objects based on their string form,\n            // which might have been relied upon by users of this deprecated method.\n            // A cleaner approach would be to strictly require Comparable or handle\n            // the comparison based on the actual types stored in the frequency map,\n            // but this maintains closer compatibility with potential old usage.\n            return (double) getCount(v.toString()) / (double) sumFreq; // Fallback for non-Comparable\n                                                                       // Should ideally align with how counts are stored/compared\n                                                                       // This assumes counts might be keyed by String for non-Comparables\n                                                                       // or that getCount handles Object comparison appropriately.\n                                                                       // A direct call to the internal map's get might be better if accessible.\n                                                                       // Or simply rely on getCount(Object) if it exists and handles this.\n                                                                       // Let's assume getCount(Object) exists and handles the lookup correctly.\n             // Correction: Assuming getCount(Object v) exists and handles the lookup\n             // return (double) getCount(v) / (double) sumFreq;\n             // Based on the structure and the test failure, the most likely intended fix,\n             // aligning with the purpose (getting pct for *that* value, not cumulative),\n             // is to use the count of that specific value.\n             // The simplest fix reflecting this intent is:\n             // return (double) getCount(v) / (double) sumFreq;\n             // Let's use this direct approach.\n             return (double) getCount(v) / (double) sumFreq;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}