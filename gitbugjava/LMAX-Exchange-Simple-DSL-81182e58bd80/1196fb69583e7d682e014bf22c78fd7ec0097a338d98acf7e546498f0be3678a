{
    "generation": "        void consume(final RepeatingArgGroup groupArg, final Deque<NameValuePair> arguments)\n        {\n            // Map to hold values for THIS instance of the repeating group\n            final Map<DslArg, List<String>> valuesByArg = new HashMap<>();\n            // Processor configured to use the local valuesByArg map and specific error message\n            // Note: Using a *new* processor for each group instance ensures state isolation.\n            final SimpleArgumentProcessor processor = new SimpleArgumentProcessor(valuesByArg, \"Did not supply a value for %s in group \" + groupArg.getName());\n\n            // Consume the identity argument (e.g., \"group: Joe\") - this MUST be present and starts the group instance.\n            // The processor handles required check, validation, and multiple values for the identity arg itself.\n            processor.consume(groupArg.getIdentity(), arguments);\n\n            // Build a map for quick lookup of other arguments belonging to this group type\n            final Map<String, SimpleDslArg> argsByName = new HashMap<>();\n            // Add identity arg for the break check later\n            argsByName.put(groupArg.getIdentity().getName().toLowerCase(), groupArg.getIdentity());\n            for (SimpleDslArg dslArg : groupArg.getOtherArgs())\n            {\n                // Store lowercase for case-insensitive matching\n                if (argsByName.put(dslArg.getName().toLowerCase(), dslArg) != null)\n                {\n                    // Check for duplicates within the group definition itself\n                    throw new IllegalArgumentException(\"Duplicate parameter '\" + dslArg.getName() + \"' in group \" + groupArg.getName());\n                }\n            }\n\n            // Consume subsequent arguments belonging to this group instance\n            while (!arguments.isEmpty())\n            {\n                final NameValuePair argument = arguments.peekFirst();\n                if (argument == NameValuePair.NULL)\n                {\n                    arguments.pollFirst(); // Skip null placeholders\n                    continue;\n                }\n\n                // Arguments must have names within a group context (null name might be positional, not allowed here)\n                if (argument.name == null)\n                {\n                    // Or maybe just break? Depending on overall parser design. Throwing seems safer for groups.\n                    throw new IllegalArgumentException(\"Unexpected ambiguous argument \" + argument.originalValue + \" within group \" + groupArg.getName());\n                }\n\n                // Look up the argument definition by name (case-insensitive)\n                final DslArg arg = argsByName.get(argument.name.toLowerCase());\n\n                // If the argument name doesn't match any arg in this group definition...\n                if (arg == null)\n                {\n                    break; // ...it belongs to something else (next group instance or different parameter)\n                }\n\n                // Check if seeing this argument means we've finished the current group instance\n                final List<String> argValues = valuesByArg.computeIfAbsent(arg, k -> new ArrayList<>());\n                // If we see the identity arg again, OR if we see a non-multi-value arg that already has a value,\n                // then this argument belongs to the *next* instance of the group.\n                if ((arg == groupArg.getIdentity()) || (!argValues.isEmpty() && !arg.isAllowMultipleValues()))\n                {\n                    break;\n                }\n\n                // Consume the argument from the deque *now* that we know it belongs to this group instance\n                arguments.pollFirst();\n\n                // Validate the raw value against any constraints defined on the DslArg\n                checkValidValue(arg, argument.value);\n\n                // Add value(s), splitting if multiple values are allowed for this arg\n                if (arg.isAllowMultipleValues())\n                {\n                    // arg.split handles separator logic and trimming\n                    argValues.addAll(arg.split(argument.value));\n                }\n                else\n                {\n                    // Since the check above ensures argValues is empty if !isAllowMultipleValues, we just add.\n                    argValues.add(argument.value);\n                }\n            }\n\n            // Build the final map of lowercase names to value lists for *this group instance*\n            // Use the values collected in valuesByArg (populated by initial processor.consume and the while loop)\n            final Map<String, List<String>> valuesByName = new HashMap<>();\n            for (final Map.Entry<DslArg, List<String>> entry : valuesByArg.entrySet())\n            {\n                final DslArg collectedArg = entry.getKey();\n                final List<String> collectedValues = entry.getValue();\n                // Only include args that actually received values\n                if (collectedValues != null && !collectedValues.isEmpty()) // Check collectedValues != null for safety\n                {\n                    valuesByName.put(collectedArg.getName().toLowerCase(), collectedValues);\n                }\n            }\n\n            // Check that all *other* required arguments within this group instance received a value\n            // (The identity argument's requirement was checked by processor.consume earlier)\n            for (final SimpleDslArg otherArg : groupArg.getOtherArgs())\n            {\n                // Check lowercase name against the populated valuesByName map\n                if (otherArg.isRequired() && !valuesByName.containsKey(otherArg.getName().toLowerCase()))\n                {\n                    // Use the processor's error message format for consistency\n                    throw new IllegalArgumentException(String.format(processor.getMissingValueMessage(), otherArg.getName()));\n                }\n            }\n\n            // Store the collected values for this group instance\n            // Create the DslArg array representing the structure of this group type\n            final DslArg[] dslArgs = new DslArg[groupArg.getOtherArgs().length + 1];\n            dslArgs[0] = groupArg.getIdentity();\n            System.arraycopy(groupArg.getOtherArgs(), 0, dslArgs, 1, groupArg.getOtherArgs().length);\n            // Add the parsed values (valuesByName) associated with this structure\n            groupsByArg.computeIfAbsent(groupArg, k -> new ArrayList<>()).add(new RepeatingParamValues(dslArgs, valuesByName));\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}