{
    "generation": "        void consume(final RepeatingArgGroup groupArg, final Deque<NameValuePair> arguments)\n        {\n            final Map<DslArg, List<String>> valuesByArg = new HashMap<>();\n            final SimpleArgumentProcessor processor = new SimpleArgumentProcessor(valuesByArg, \"Did not supply a value for %s in group \" + groupArg.getName());\n\n            // Consume the identity argument for this group instance (e.g., \"group: Joe\")\n            processor.consume(groupArg.getIdentity(), arguments);\n\n            // Build a map of all DslArgs in this group (identity + others) by name for quick lookup\n            final Map<String, SimpleDslArg> argsByName = new HashMap<>();\n            argsByName.put(groupArg.getIdentity().getName().toLowerCase(), groupArg.getIdentity());\n            for (SimpleDslArg dslArg : groupArg.getOtherArgs())\n            {\n                if (argsByName.put(dslArg.getName().toLowerCase(), dslArg) != null)\n                {\n                    throw new IllegalArgumentException(\"Duplicate parameter '\" + dslArg.getName() + \"' in group \" + groupArg.getName());\n                }\n            }\n\n            // Loop to consume \"other\" arguments for the current group instance\n            while (!arguments.isEmpty())\n            {\n                final NameValuePair argumentNvp = arguments.peekFirst();\n                if (argumentNvp == NameValuePair.NULL)\n                {\n                    arguments.pollFirst();\n                    continue;\n                }\n\n                if (argumentNvp.name == null)\n                {\n                    throw new IllegalArgumentException(\"Unexpected ambiguous argument \" + argumentNvp.originalValue);\n                }\n\n                // If the next argument in the queue is the identity of a new group instance,\n                // stop processing \"other\" args for the *current* group instance.\n                if (argumentNvp.name.equalsIgnoreCase(groupArg.getIdentity().getName()))\n                {\n                    break;\n                }\n\n                final DslArg currentParamDslArg = argsByName.get(argumentNvp.name.toLowerCase());\n\n                // If the argument name is not recognized as part of this group (neither identity nor other arg),\n                // or if it's somehow the identity arg again (which should have been caught by the check above), break.\n                // This loop is only for \"other\" args.\n                if (currentParamDslArg == null || currentParamDslArg == groupArg.getIdentity())\n                {\n                    break;\n                }\n\n                // At this point, currentParamDslArg is one of groupArg.getOtherArgs().\n                final List<String> existingValuesForParam = valuesByArg.computeIfAbsent(currentParamDslArg, k -> new ArrayList<>());\n\n                // This check handles cases like \"param: val1, param: val2\" where 'param' DslArg\n                // is NOT configured with .setAllowMultipleValues(true) (meaning it expects a single logical value,\n                // not a list like \"val1,val2\" from one string).\n                // If such a param already has a value, seeing it again means we should stop or error.\n                // The original code breaks, implying subsequent values belong elsewhere or are invalid.\n                if (!existingValuesForParam.isEmpty() && !currentParamDslArg.isAllowMultipleValues())\n                {\n                    break;\n                }\n                \n                // Argument is valid for current group and DslArg. Consume it from the queue.\n                arguments.pollFirst();\n\n                final String valueFromNvp = argumentNvp.value;\n\n                // If the DslArg allows multiple values (e.g., from a comma-separated string)\n                // and the actual value string contains the separator, split it.\n                if (currentParamDslArg.isAllowMultipleValues() && valueFromNvp.contains(currentParamDslArg.getMultiValueSeparator()))\n                {\n                    for (final String valPart : valueFromNvp.split(Pattern.quote(currentParamDslArg.getMultiValueSeparator())))\n                    {\n                        final String trimmedValPart = valPart.trim();\n                        checkValidValue(currentParamDslArg, trimmedValPart);\n                        existingValuesForParam.add(trimmedValPart);\n                    }\n                }\n                else\n                {\n                    // Either DslArg doesn't allow multiple values, or value string doesn't contain separator. Add as is.\n                    checkValidValue(currentParamDslArg, valueFromNvp);\n                    existingValuesForParam.add(valueFromNvp);\n                }\n            }\n\n            // Collect all parsed values for this group instance\n            final Map<String, List<String>> valuesByName = new HashMap<>();\n            // Iterate over all DslArgs defined for this group type (identity + others)\n            for (final SimpleDslArg simpleDslArg : argsByName.values())\n            {\n                // processor.collect() uses valuesByArg to get stored values for simpleDslArg\n                // and constructs a SimpleDslParam.\n                final SimpleDslParam param = processor.collect(simpleDslArg);\n                if (param.hasValue())\n                {\n                    // param.getValuesAsList() will further process values if needed (e.g. if SimpleDslParam itself has splitting logic,\n                    // though with the fix above, values in valuesByArg are already split).\n                    valuesByName.put(param.getName().toLowerCase(), param.getValuesAsList());\n                }\n            }\n\n            final DslArg[] dslArgs = new DslArg[groupArg.getOtherArgs().length + 1];\n            dslArgs[0] = groupArg.getIdentity();\n            System.arraycopy(groupArg.getOtherArgs(), 0, dslArgs, 1, groupArg.getOtherArgs().length);\n            groupsByArg.computeIfAbsent(groupArg, k -> new ArrayList<>()).add(new RepeatingParamValues(dslArgs, valuesByName));\n        }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}