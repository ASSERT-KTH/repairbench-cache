{
    "generation": "        void consume(final RepeatingArgGroup groupArg, final Deque<NameValuePair> arguments)\n        {\n            final Map<DslArg, List<String>> valuesByArg = new HashMap<>();\n            final SimpleArgumentProcessor processor = new SimpleArgumentProcessor(valuesByArg, \"Did not supply a value for %s in group \" + groupArg.getName());\n\n            // Consume the identity argument for this specific group instance\n            processor.consume(groupArg.getIdentity(), arguments);\n\n            // Prepare a map of all arguments defined in the group (identity + others) by name for lookup\n            // This also serves to check for duplicate parameter definitions within the group.\n            final Map<String, SimpleDslArg> definedArgsInGroup = new HashMap<>();\n            definedArgsInGroup.put(groupArg.getIdentity().getName().toLowerCase(), groupArg.getIdentity());\n            for (SimpleDslArg dslArg : groupArg.getOtherArgs())\n            {\n                if (definedArgsInGroup.put(dslArg.getName().toLowerCase(), dslArg) != null)\n                {\n                    // This catches if an \"otherArg\" has the same name as the identity,\n                    // or if two \"otherArgs\" have the same name.\n                    throw new IllegalArgumentException(\"Duplicate parameter name '\" + dslArg.getName() + \"' (case-insensitive) within group \" + groupArg.getName());\n                }\n            }\n\n            // Loop to consume other arguments belonging to this group instance\n            while (!arguments.isEmpty())\n            {\n                final NameValuePair headArgument = arguments.peekFirst();\n                if (headArgument == NameValuePair.NULL)\n                {\n                    arguments.pollFirst(); // Consume the NULL marker\n                    continue;\n                }\n\n                if (headArgument.name == null) // Ambiguous argument\n                {\n                    throw new IllegalArgumentException(\"Unexpected ambiguous argument \" + headArgument.originalValue + \" while parsing members of group \" + groupArg.getName());\n                }\n\n                final DslArg currentGroupMemberArg = definedArgsInGroup.get(headArgument.name.toLowerCase());\n\n                if (currentGroupMemberArg == null)\n                {\n                    // The argument at the head of the deque is not defined in this group.\n                    // So, it's either for a subsequent top-level parameter or an unknown parameter.\n                    // In either case, this group's consumption of its members is done.\n                    break;\n                }\n\n                if (currentGroupMemberArg == groupArg.getIdentity())\n                {\n                    // We've encountered the identity argument again. This signals the start of the NEXT group instance.\n                    // The current group instance's arguments are all consumed.\n                    break;\n                }\n\n                // At this point, currentGroupMemberArg is one of the \"otherArgs\" of the current group instance.\n                // Check for duplicates if this arg does not allow multiple values and has already been seen for this instance.\n                if (valuesByArg.containsKey(currentGroupMemberArg) && !currentGroupMemberArg.isAllowMultipleValues())\n                {\n                    throw new IllegalArgumentException(\n                        String.format(\"Argument '%s' in group '%s' does not allow multiple values but was specified more than once for the same group instance.\",\n                                      currentGroupMemberArg.getName(), groupArg.getName()));\n                }\n\n                arguments.pollFirst(); // Consume the argument from the deque\n\n                final List<String> argSpecificValues = valuesByArg.computeIfAbsent(currentGroupMemberArg, k -> new ArrayList<>());\n\n                if (currentGroupMemberArg.isAllowMultipleValues())\n                {\n                    if (headArgument.value != null) // NameValuePair contract should ensure value is non-null (can be empty string)\n                    {\n                        final String[] splitValues = headArgument.value.split(Pattern.quote(currentGroupMemberArg.getMultipleValueSeparator()));\n                        for (final String splitValue : splitValues)\n                        {\n                            String trimmedValue = splitValue.trim();\n                            checkValidValue(currentGroupMemberArg, trimmedValue);\n                            argSpecificValues.add(trimmedValue);\n                        }\n                    }\n                    // If headArgument.value is null (e.g. from \"arg:\"):\n                    // For a multi-value arg, an empty value string might result in an empty string item after split/trim.\n                    // e.g. \"value:,\" -> [\"\",\"\"] -> add(\"\"), add(\"\"). This depends on exact split behavior and requirements.\n                    // Current behavior for \"value:\" (empty string) -> split(\"\") -> [\"\"] -> add(\"\"). This is often desired.\n                }\n                else // Not multi-value\n                {\n                    checkValidValue(currentGroupMemberArg, headArgument.value);\n                    argSpecificValues.add(headArgument.value);\n                }\n            }\n\n            // Collect all parsed values for this group instance using the processor,\n            // which handles mandatory checks based on the DslArg definitions.\n            // The valuesByArg map has been populated by both processor.consume(identity) and the loop above.\n            final Map<String, List<String>> valuesByNameForInstance = new HashMap<>();\n            for (final SimpleDslArg simpleDslArg : definedArgsInGroup.values()) // Iterate all args defined for this group type\n            {\n                final SimpleDslParam param = processor.collect(simpleDslArg); // Uses the shared valuesByArg\n                if (param.hasValue())\n                {\n                    valuesByNameForInstance.put(param.getName().toLowerCase(), param.getValuesAsList());\n                }\n                // If a mandatory arg is missing, processor.collect is expected to throw an exception.\n            }\n\n            final DslArg[] dslArgsForStorage = new DslArg[groupArg.getOtherArgs().length + 1];\n            dslArgsForStorage[0] = groupArg.getIdentity();\n            System.arraycopy(groupArg.getOtherArgs(), 0, dslArgsForStorage, 1, groupArg.getOtherArgs().length);\n            groupsByArg.computeIfAbsent(groupArg, k -> new ArrayList<>()).add(new RepeatingParamValues(dslArgsForStorage, valuesByNameForInstance));\n        }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}