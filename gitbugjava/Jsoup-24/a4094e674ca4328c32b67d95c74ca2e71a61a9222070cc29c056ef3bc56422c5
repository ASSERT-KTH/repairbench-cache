{
    "generation": "    /**\n     * Implementation of the Tag Open state.\n     */\n    void read(Tokeniser t, CharacterReader r) {\n        // Handle based on the character after the opening '<'\n        if (r.matchesLetter()) {\n            // < + letter = start tag. Prepare a start tag token.\n            t.createTagPending(true);\n            t.transition(TagName); // Transition to TagName state to consume the name.\n        } else if (r.matches('/')) {\n            // </ = end tag. Consume /\n            r.advance();\n            t.transition(EndTagOpen); // Transition to EndTagOpen state.\n        } else if (r.matches('!')) {\n            // <! = markup declaration. Consume !\n            r.advance();\n            t.transition(MarkupDeclarationOpen); // Transition to MarkupDeclarationOpen state.\n        } else if (r.matches('?')) {\n            // <? = bogus comment. Per spec: Create comment, transition to BogusComment.\n            // Jsoup's implementation handles the '?' consumption and comment creation within the BogusComment state.\n            t.error(this); // Parse error as per spec\n            // Jsoup creates the comment token when transitioning to BogusComment or inside it. Let's ensure it's ready.\n            t.createCommentPending();\n            t.transition(BogusComment);\n        } else {\n            // Anything else after < is treated as literal '<' followed by the character.\n            t.error(this); // Parse error.\n            t.emit('<'); // Emit the '<' as a character token.\n            t.transition(Data); // Switch to Data state to process the current character.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}