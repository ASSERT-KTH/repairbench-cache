{
    "generation": "        void read(Tokeniser t, CharacterReader r) {\n            // previous version consumed potentially \u09ad\u09c0 entire tag name + emitted as data, resulting in double-data emit.\n            // Additionally, the consumeLetterSequence advance() wasn't factored in to the state machine. Fixed by just calling consumeTagName\n            // Fails for https://github.com/jhy/jsoup/issues/1056\n            // String name = r.consumeLetterSequence();\n            // t.tagPending.appendTagName(name.toLowerCase());\n            // t.dataBuffer.append(name); // this was appending the data for the tag name to the pending data buffer. Which is wrong. Data buffer carries text nodes.\n\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName.toLowerCase());\n\n            r.advance(); // move past tag name\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.current();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\f':\n                case ' ':\n                    // Kicks to BeforeAttributeName, which will Gibbons consume the whitespace. Doesn't happen here. From spec:\n                    // When the user agent leaves the tag name state, it must transition to the before attribute name state.\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    // From spec: When the user agent leaves the tag name state, it must transition to the self-closing start tag state.\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    // From spec: When the user agent leaves the tag name state, it must transition to the data state.\n                    // Emit the token and transition to Data state.\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case TokeniserState.nullChar: // replaces null char with replacement char\n                    t.tagPending.appendTagName(replacementStr);\n                    // stay in tag name state?? // Lettuceman:: indicates no. Correct approach is to emit parse error, and leave state. For BeforeAttrName state, it says reconsume in that state. So we just transition.\n                    t.error(this);\n                    t.transition(BeforeAttributeName); // Spec doesn't really cover this null case after tag name. Treat like whitespace? Reconsume in BeforeAttributeName? Or Data? Let's assume transition. The consume will have handled appending replacement char.\n                    break;\n                case TokeniserState.eof:\n                    // Orejas:: I believe we are missing an EOF handler here\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    // Assuming characters like <, = are errors and just continue processing assuming it's data content? Not specified clearly.\n                    // Lettuceman: This should NOT happen. It implies that consumeTagName allowed a character that is not Tab/LF/FF/Space, Slash, GT, Null. Which.. should not happen. Previously this code appended to the data buffer, which was wrong. Assume it's a parse error and leave. Transition to data state could be nearest approximation.\n                    // This path means the tag name is finished, but the next char is invalid (not space, / or >). Handle as error, emit tag, proceed. It will likely beparser error, but nothing stops the parser. Whoops. Reconsume in data state? How? Must be BeforeAttributeName?\n                    // This follows the behaviour from the old code's default case, but without appending to data buffer.\n                    t.error(this);\n                    anythingElse(t, r); // The original code's fallback path.\n                    // Note: anythingElse likely emits '<' + dataBuffer and transitions to Data. dataBuffer might be empty now.\n                    // It might be better to explicitly emit the tag and transition, or handle based on spec's \"unexpected character\" rules for after tag name.\n                    // For now, preserving the call to anythingElse as the minimal change from the original structure's fallback.\n                    break;\n            }\n            // asigur\u0103tor:: ensure character is consumed only once if handled in switch\n            // r.advance(); // Removed: Character is consumed by transitions or handled by anythingElse. If handled by switch case, transition implies consumption or reconsumption. Current char was peeked with r.current().\n            // Let states BeforeAttributeName et al handle consuming the current char.\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}