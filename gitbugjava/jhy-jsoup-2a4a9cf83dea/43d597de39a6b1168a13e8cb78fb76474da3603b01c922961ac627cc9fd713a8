{
    "generation": "        @Override\n        public boolean matches(Element root, Element element) {\n            Element current = element; // Use 'current' to track the element being evaluated in the chain\n            // evaluate from last to first\n            for (int i = evaluators.size() - 1; i >= 0; --i) {\n                if (current == null) { // Walked off the top of the tree\n                    return false;\n                }\n\n                // If 'current' is an ancestor of 'root', then this path is out of scope.\n                // 'root' is the context element for the .select(query) call.\n                // The initial 'element' (passed to this matches method) is guaranteed by the Collector\n                // to be 'root' or one of its descendants.\n                // As 'current' traverses up via parent(), it might go \"above\" 'root'.\n                // Such matches are invalid as they are not within the root's context.\n                // Note: current == root is a valid state.\n                // root.isDescendant(current) is true if 'current' is an ancestor of 'root'.\n                if (current != root && root.isDescendant(current)) {\n                    return false;\n                }\n\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, current)) {\n                    return false;\n                }\n                \n                current = current.parent();\n            }\n            return true;\n        }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}