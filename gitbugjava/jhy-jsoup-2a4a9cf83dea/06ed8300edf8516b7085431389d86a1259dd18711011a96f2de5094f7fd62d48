{
    "generation": "        @Override\n        public boolean matches(Element root, Element element) {\n            // evaluate from last to first\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                if (element == null)\n                    return false;\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false;\n\n                // If this is the last evaluator in the chain (i.e., we just matched the outermost part\n                // of the selector chain, e.g., 'ul' in 'ul > li'), then we've successfully matched\n                // the entire chain for this 'element'.\n                if (i == 0) {\n                    return true;\n                }\n\n                // Move to the parent for the next evaluator in the chain (ancestor check).\n                element = element.parent();\n\n                // Crucial check for contextual selections:\n                // If the 'element' has ascended above the 'root' context (i.e., 'element' is now an ancestor\n                // of 'root' but not 'root' itself), and we still have more evaluators to check,\n                // it means the current path is outside the specified selection context.\n                // For a selector like 'A B' applied on 'li2.select(\"ul > li\")', 'B' ('li') must be\n                // a descendant of 'li2'. 'A' ('ul') must be an ancestor of 'B' AND also a\n                // descendant of 'li2' (or 'li2' itself). If 'element' (the potential ancestor)\n                // becomes an ancestor of 'root' (e.g., 'ul#outer' is an ancestor of 'li2'),\n                // it implies it's outside 'li2's scope for contextual selection.\n                if (element != null && element.isAncestorOf(root) && !element.equals(root)) {\n                     return false;\n                }\n            }\n            // This part should ideally not be reached if the loop logic is complete.\n            // If evaluators is empty, it might be reachable, but this evaluator type typically\n            // expects a non-empty list of evaluators for structural matching.\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}