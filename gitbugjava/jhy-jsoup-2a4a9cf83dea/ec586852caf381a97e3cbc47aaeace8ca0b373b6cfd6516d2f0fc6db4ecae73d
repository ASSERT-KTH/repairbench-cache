{
    "generation": "        @Override\n        public boolean matches(Element root, Element element) {\n            // evaluate from last to first (e.g., for \"ul > li\", first checks li, then ul)\n            // evaluators[last] is the leaf evaluator (e.g., Tag(\"li\"))\n            // evaluators[first] is the root evaluator (e.g., Tag(\"ul\"))\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                if (element == null)\n                    return false; // Reached top of document before matching all evaluators\n\n                // This critical check ensures that the upward traversal (element = element.parent())\n                // does not go beyond the initial 'root' context provided to the select method.\n                // The 'root' parameter here is the Element on which .select(..) was called.\n                // The 'element' parameter is the current candidate being evaluated against the selector chain.\n                // If we've already moved up at least once (i.e., i is not the initial evaluators.size()-1)\n                // AND the current 'element' is neither the 'root' itself nor a descendant of 'root',\n                // then this chain is invalid because it has ascended outside the 'root's scope.\n                // Note: root.equals(element) is checked separately because root.contains(element)\n                // returns false for the root itself, but root is a valid match in some contexts.\n                // Here, if 'element' is an ancestor of 'root' (or sibling, etc.), it implies we've\n                // left the subtree of 'root' while evaluating an ancestor, which is incorrect.\n                if (i < evaluators.size() - 1 && !root.equals(element) && !root.contains(element)) {\n                    return false; // The traversed element is outside the root context.\n                }\n\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false; // Current evaluator in chain doesn't match\n                element = element.parent(); // Move up to parent for next evaluator in chain\n            }\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}