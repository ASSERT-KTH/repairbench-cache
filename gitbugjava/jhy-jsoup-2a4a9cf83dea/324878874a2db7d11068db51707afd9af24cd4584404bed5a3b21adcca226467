{
    "generation": "        @Override\n        public boolean matches(Element root, Element element) {\n            // evaluate from last to first (e.g., for selector \"A B C\", it checks C on element, B on element.parent(), A on element.parent().parent())\n            for (int i = evaluators.size() -1; i >= 0; --i) {\n                // If element becomes null (e.g., reached document root and went beyond), then no match\n                if (element == null)\n                    return false;\n\n                // Check if the current element matches the evaluator\n                Evaluator eval = evaluators.get(i);\n                if (!eval.matches(root, element))\n                    return false;\n\n                // Move to the parent for the next evaluator in the chain (moving from right to left in the selector)\n                Element prevElement = element; // Keep track of the element that just matched\n                element = element.parent();\n\n                // Crucial check: If the current 'element' (which is the parent of the previously matched element)\n                // is now an ancestor of the 'root' context (but not the 'root' itself),\n                // then this path is outside the specified selection context and should fail.\n                // This ensures that the entire matched chain of elements remains within the subtree of the 'root' element.\n                // (Unless 'element' is the 'root' itself, which is a valid match point for an evaluator).\n                if (element != null && element != root && !root.isAncestorOf(element)) {\n                    // element is not null, not the root, and root is not an ancestor of element (meaning element is an ancestor of root, but not root itself)\n                    return false;\n                }\n            }\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}