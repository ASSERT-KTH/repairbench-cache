{
    "generation": "        @Override\n        public boolean matches(Element root, Element element) {\n            // This evaluator implements the parent selector ' ' (e.g., \"div p\").\n            // It checks if the element has an ancestor matching the evaluator.\n            // Root is the context element for the selector, element is the candidate element.\n\n            // Prevent matching the root element itself as its own ancestor.\n            if (root == element)\n                return false;\n\n            // Assuming evaluators contains the single evaluator for the ancestor condition.\n            // E.g., for \"ul li\", when checking 'li', this evaluator is Parent(Tag(\"ul\")),\n            // and evaluators should contain just Tag(\"ul\").\n            // A robust implementation might check evaluators.size(), but we assume it's correctly populated.\n            if (evaluators.isEmpty()) {\n                 return false; // Or handle as an error case. No ancestor condition means no match.\n            }\n            Evaluator ancestorEval = evaluators.get(0); // Get the evaluator for the required ancestor.\n\n            Element parent = element.parent();\n            while (parent != null) {\n                // Check if the current ancestor matches the evaluator's criteria.\n                if (ancestorEval.matches(root, parent))\n                    return true; // Found a matching ancestor.\n\n                // Stop searching upwards if we hit the root of the selection context.\n                // This prevents matching elements outside the intended scope.\n                if (parent == root)\n                    break;\n\n                parent = parent.parent(); // Move up to the next ancestor.\n            }\n\n            // No ancestor matched the criteria up to the root.\n            return false;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}