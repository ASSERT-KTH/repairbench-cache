{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        final int start = offset; // Keep original start for segment tracking\n        final int end = offset + len;\n\n        // Local variables for frequently accessed format settings\n        final char delimChar = getDelimiter();\n        final Character quoteCharObj = getQuoteCharacter();\n        // We assume quoteCharObj is non-null if quoteMode requires quoting (e.g., not NONE).\n        // If quoteCharObj could be null, the format validation should prevent this combination.\n        final char quoteChar = quoteCharObj.charValue();\n        final Character commentMarkerObj = getCommentMarker(); // Fetch potential comment marker\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            // Check object type for NON_NUMERIC mode\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // In NONE mode, use escape logic (which might handle delimiters/specials differently)\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Quote empty field if it's the first on a new record\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                final char firstChar = value.charAt(offset);\n                final char lastChar = value.charAt(offset + len - 1);\n\n                // Rule 1: Check for leading/trailing spaces (less than or equal to SP).\n                // Note: Constants SP, LF, CR assumed accessible.\n                if (firstChar <= SP || lastChar <= SP) {\n                    quote = true;\n                } else {\n                    // Rule 2: Check for leading comment marker if applicable.\n                    if (newRecord && isCommentMarkerSet() && commentMarkerObj != null && firstChar == commentMarkerObj.charValue()) {\n                        quote = true;\n                    } else {\n                        // Rule 3: Scan for internal special characters (delimiter, quote, CR, LF).\n                        // This loop is only needed if the prior checks didn't trigger quoting.\n                        int pos = offset; // Use pos for scanning, similar to original code\n                        while (pos < end) {\n                            final char c = value.charAt(pos);\n                            if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                                quote = true;\n                                break; // Found a character needing quoting\n                            }\n                            pos++;\n                        }\n                        // If quote became true here, the escaping logic below will handle it.\n                    }\n                }\n            }\n\n            // If MINIMAL decided against quoting, write out directly and return\n            if (!quote) {\n                out.append(value, offset, end); // Use offset/end for the full original value\n                return;\n            }\n            // Otherwise, break from switch and proceed to quoting logic below\n            break;\n\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End switch\n\n        // If quote is false after the switch (e.g., for NON_NUMERIC that wasn't Number), write directly.\n        if (!quote) {\n            out.append(value, offset, end);\n            return;\n        }\n\n        // ---- Quoting Logic ----\n        // This part executes if 'quote' is true.\n        out.append(quoteChar);\n\n        // Iterate through the value to write segments and double internal quote chars\n        int segmentStart = start; // Use original 'start' (which is offset)\n        for (int i = offset; i < end; i++) {\n            final char c = value.charAt(i);\n            if (c == quoteChar) {\n                // Write segment up to and including the quote char\n                out.append(value, segmentStart, i + 1);\n                // Next segment starts at the quote char (effectively doubling it)\n                segmentStart = i; // Correct: next segment starts at the quote char index\n            }\n        }\n\n        // Write the final segment (from last quote char, or beginning, up to the end)\n        out.append(value, segmentStart, end);\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}