{
    "generation": "import java.io.IOException;\nimport org.apache.commons.csv.QuoteMode;\n// Assuming relevant constants like SP, LF, CR are available, either defined\n// in this class/superclass or imported from org.apache.commons.csv.Constants\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\n// Stub for dependencies, replace with actual context if needed\nabstract class CSVPrinterStub {\n    abstract char getDelimiter();\n    abstract Character getQuoteCharacter();\n    abstract QuoteMode getQuoteMode();\n    abstract boolean isCommentMarkerSet();\n    abstract Character getCommentMarker();\n    abstract String getNullString(); // Needed conceptually for ALL_NON_NULL? Not used in original logic here.\n    abstract void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out) throws IOException;\n\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset; // pos tracks current position, used later if quoting needed\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharObject = getQuoteCharacter();\n        // Quote character must be set for quote modes other than NONE. Format validation should ensure this.\n        final char quoteChar = quoteCharObject != null ? quoteCharObject.charValue() : Assertions.fail(\"quotechar must not be null\");\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            // Original behavior: Always quote for ALL/ALL_NON_NULL modes here.\n            // Assumes caller handles null string representation before calling this.\n            // If ALL_NON_NULL, and object is null, this will quote the null string representation.\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            // Quote if the original object was not a number.\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // No quoting, just escape special characters (handled by printAndEscape)\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Always quote an empty field if it's the first one on the line,\n                // otherwise, it might be interpreted as an empty line.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                final char firstChar = value.charAt(start);\n                final char lastChar = value.charAt(end - 1);\n\n                // Rule 1: Quote if leading or trailing whitespace is present.\n                // Whitespace definition includes space (SP) and control characters (<= SP).\n                if (firstChar <= SP || lastChar <= SP) {\n                    quote = true;\n                }\n                // Rule 2: Quote if the field starts with the comment marker\n                // (and comments are enabled, and it's the first field).\n                else if (newRecord && isCommentMarkerSet()) {\n                    Character comment = getCommentMarker();\n                    // Check comment is not null and matches first char\n                    if (comment != null && firstChar == comment.charValue()) {\n                        quote = true;\n                    }\n                }\n\n                // Rule 3: Quote if the field contains delimiter, quote character, or record separator characters (CR, LF).\n                if (!quote) {\n                    // Scan the entire field if we haven't already decided to quote.\n                    // We update 'pos' here, as the quoting logic below might use it\n                    // to start processing from the character that triggered the quote.\n                    pos = start; // Ensure scan starts from the beginning\n                    while (pos < end) {\n                        final char c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break; // Found a character requiring quoting\n                        }\n                        pos++;\n                    }\n                    // If loop finished without break, quote is still false, pos == end.\n                    // If loop broke, quote is true, pos is index of triggering char.\n                }\n                // If quote was true from Rule 1 or 2, the loop was skipped.\n                // 'pos' remains at its initial value 'offset'. The quoting logic below\n                // will start scanning from pos=offset, which is correct.\n            }\n\n            // If no quoting is needed after all checks, write the value directly and return.\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // Otherwise, break from switch to proceed with the quoting logic below.\n            break;\n        default:\n            // Should not happen with defined QuoteMode enum values.\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // If quote mode required quoting (e.g., ALL) or MINIMAL determined quoting is needed.\n        // Note: The original code had a redundant check \"if (!quote)\" here, which is removed\n        // as the MINIMAL case now returns early if !quote, and other cases either set quote=true\n        // or return early (NONE). If quote is false here, it implies NONE mode (already returned)\n        // or potentially a future mode. For safety, if we reach here and quote is false,\n        // we write the value directly (matches the original redundant check's behavior).\n        if (!quote) {\n           out.append(value, start, end);\n           return;\n        }\n\n\n        // ---- Quoting Logic ----\n        // This part remains the same as the original code.\n        // It handles the actual quoting and escaping of the quote character itself.\n\n        // Append the initial quote character.\n        out.append(quoteChar);\n\n        // Iterate through the field's content. 'pos' was potentially updated by the MINIMAL scan loop\n        // to the index of the first character requiring quotes, or it remains 'offset' if quoting\n        // was triggered by initial conditions (like leading space) or mode (like ALL).\n        // 'start' tracks the beginning index of the substring to append in each step.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            // If the character is the quote character...\n            if (c == quoteChar) {\n                // Write the segment leading up to and including the quote character.\n                out.append(value, start, pos + 1);\n                // Set the start position for the next segment to the current position.\n                // This ensures the quote character is written again (doubled).\n                start = pos;\n            }\n            pos++; // Move to the next character.\n        }\n\n        // Write the final segment of the field (from the last 'start' position to the end).\n        out.append(value, start, pos); // pos is now == end\n        // Append the final closing quote character.\n        out.append(quoteChar);\n    }\n\n    // Dummy Assertions class for the check added for quoteChar nullness\n    private static class Assertions {\n        static char fail(String message) {\n            throw new IllegalStateException(message);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}