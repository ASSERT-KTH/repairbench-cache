{
    "generation": "import java.io.IOException;\n\nimport org.apache.commons.csv.QuoteMode;\n// Assuming relevant constants (LF, CR, SP) and methods (getDelimiter, getQuoteCharacter, getQuoteMode,\n// getCommentMarker, isCommentMarkerSet, printAndEscape) are accessible in the class context.\nimport static org.apache.commons.csv.Constants.CR;\nimport static org.apache.commons.csv.Constants.LF;\nimport static org.apache.commons.csv.Constants.SP;\n\n\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharRef = getQuoteCharacter();\n        // Use getQuoteMode() directly; handle null by defaulting to MINIMAL.\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            // Note: For ALL_NON_NULL, the check 'object != null' might be expected here\n            // or handled by the caller. Assuming caller handles it or object is non-null based on context.\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code logic (which might handle delimiters/quotes differently)\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line,\n                // as it may be the only thing on the line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char firstChar = value.charAt(start);\n                char lastChar = value.charAt(end - 1);\n\n                // Trigger quoting if:\n                // 1. The field contains the delimiter, quote character, CR, or LF.\n                // 2. The field starts or ends with whitespace (or control characters <= SP).\n                // 3. It's the first field of a record, comments are enabled, and it starts with the comment marker.\n\n                // Check for leading/trailing spaces or control characters first.\n                // Using <= SP is consistent with the original check for trailing spaces.\n                if (firstChar <= SP || lastChar <= SP) {\n                    quote = true;\n                } else if (newRecord && isCommentMarkerSet()) {\n                    // Check for comment marker start only if comments are enabled and it's the first field.\n                    Character commentMarker = getCommentMarker(); // Guarded by isCommentMarkerSet()\n                    if (commentMarker != null && firstChar == commentMarker.charValue()) {\n                        quote = true;\n                    }\n                }\n\n                // If not already decided to quote, scan the string for internal special characters\n                // that require quoting (delimiter, quote char, line breaks).\n                if (!quote) {\n                    pos = start; // Reset position for the full scan of the field content.\n                    while (pos < end) {\n                        final char c = value.charAt(pos);\n                        // Check for LF, CR, Delimiter, or the Quote Character itself.\n                        // Need to handle the case where quoteCharRef might be null.\n                        final boolean containsQuoteChar = quoteCharRef != null && c == quoteCharRef.charValue();\n                        if (c == LF || c == CR || c == delimChar || containsQuoteChar) {\n                            quote = true;\n                            break; // Found a character requiring quoting.\n                        }\n                        pos++;\n                    }\n                }\n            }\n\n            // If MINIMAL mode decided against quoting, write the value directly and return.\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // If MINIMAL mode requires quoting, fall through to the common quoting logic below.\n            break; // End of MINIMAL case\n\n        default:\n            // Handle unexpected QuoteMode values.\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // --- Common Quoting Logic ---\n        // This section is executed if 'quote' is true (due to policies ALL, ALL_NON_NULL, NON_NUMERIC, or MINIMAL).\n\n        // Ensure a quote character is actually defined before attempting to use it.\n        if (quoteCharRef == null) {\n            // This scenario indicates a configuration issue (quoting needed, but no quote char set).\n            throw new IllegalStateException(\"No quote character defined but quoting is required ('\" + quoteModePolicy + \"' mode).\");\n        }\n        final char quoteChar = quoteCharRef.charValue(); // Safe to get value now.\n\n        // Append the opening quote character.\n        out.append(quoteChar);\n\n        // Iterate through the original value to handle embedded quote characters by escaping them.\n        start = offset; // Position for the start of the current segment to append.\n        pos = offset;   // Position for scanning the input value character by character.\n\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // Found an embedded quote character. Append the segment up to and including this quote.\n                out.append(value, start, pos + 1);\n                // Set the start for the next segment *at* the position of the quote character.\n                // This ensures the quote character is written again (effectively doubling it)\n                // when the next segment (or the final segment) is appended.\n                start = pos;\n            }\n            pos++;\n        }\n\n        // Append the final segment of the value. This segment runs from the position 'start'\n        // (which is either the original start, or the position of the last embedded quote)\n        // up to the end of the value.\n        out.append(value, start, end); // Note: 'pos' is equal to 'end' at this point.\n\n        // Append the closing quote character.\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}