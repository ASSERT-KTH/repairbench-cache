{
    "generation": "    protected Object decodeAvrmc(\n            String sentence, Channel channel, SocketAddress remoteAddress) {\n\n        Parser parser = new Parser(PATTERN_AVRMC, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession =\n            getDeviceSession(channel, remoteAddress, parser.next()); // Consumes group 1 (IMEI)\n        if (deviceSession == null) {\n            return null;\n        }\n\n        String deviceModel = null;\n        Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n        if (device != null) {\n            deviceModel = device.getModel();\n        }\n\n        Position position = new Position(getProtocolName());\n\n        position.setDeviceId(deviceSession.getDeviceId());\n        DateBuilder dateBuilder = new DateBuilder()\n                .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0)); // Consumes groups 2,3,4 (Time)\n\n        String status = parser.next(); // Consumes group 5 (Status)\n        String upperCaseStatus = status.toUpperCase();\n        position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\"));\n        position.set(Position.KEY_STATUS, status);\n\n        position.setLatitude(parser.nextCoordinate()); // Consumes groups 6,7 (Latitude)\n        position.setLongitude(parser.nextCoordinate()); // Consumes groups 8,9 (Longitude)\n        position.setSpeed(parser.nextDouble(0)); // Consumes group 10 (Speed)\n        position.setCourse(parser.nextDouble(0)); // Consumes group 11 (Course)\n\n        dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0)); // Consumes groups 12,13,14 (Date)\n        position.setTime(dateBuilder.getDate());\n\n        String event = parser.next(); // Consumes group 15 (Event)\n        position.set(Position.KEY_ALARM, decodeAlarm(event));\n        position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n        position.set(Position.KEY_BATTERY, Double.parseDouble(parser.next().replaceAll(\"\\\\.\", \"\")) * 0.001); // Consumes group 16 (Battery)\n        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000); // Consumes group 17 (Odometer), added default 0\n        position.set(Position.KEY_GPS, parser.nextInt(0)); // Consumes group 18 (GPS), added default 0\n        position.set(Position.PREFIX_ADC + 1, parser.nextDouble(0) * 0.001); // Consumes group 19 (ADC1), added default 0\n\n        // Group 20 is optional ADC2. Groups 21+ are for cell info etc.\n        // Check if group 20 (ADC2) was matched by the regex.\n        // The Parser's internal index points to the next group to be consumed.\n        // If group 20 matched, it's the current target. If not, current target is group 21.\n        if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n            // If it's an AVL model, consume group 20 as ADC2.\n            // parser.nextDouble(0) will consume group 20 if it matched,\n            // or return default 0 if group 20 did not match (field absent).\n            position.set(Position.PREFIX_ADC + 2, parser.nextDouble(0) * 0.001);\n        } else {\n            // Not an AVL model. If group 20 (the optional ADC2 field) *did match* and is present,\n            // it must be consumed (skipped) to correctly align for subsequent LAC (group 21).\n            if (parser.getMatcher().group(20) != null) { // Check if optional group 20 actually matched\n                parser.next(); // Consume and discard group 20's value\n            }\n            // If group 20 did not match (i.e., ADC2 field was absent in the message),\n            // the parser's internal index effectively skips it, and the next call\n            // to parser.next<Type>() will correctly target group 21 (LAC).\n        }\n\n        // Now, proceed to parse LAC (group 21), CID (group 22), etc.\n        Integer lac = parser.nextHexInt();\n        Integer cid = parser.nextHexInt();\n        Integer mcc = parser.nextInt();\n        Integer mnc = parser.nextInt();\n        if (lac != null && cid != null && mcc != null && mnc != null) {\n            // Check for non-zero values for mcc and mnc as per some device behaviors where 0,0 might be sent for unknown\n            if (mcc != 0 || mnc != 0) {\n                position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n            }\n        }\n\n        parser.next(); // unused (this is GSM signal strength, group 25 or 26 from regex)\n\n        String checksum = parser.next(); // checksum (group 27 from regex)\n\n        if (channel != null) {\n            sendAcknowledge(status, event, checksum, channel, remoteAddress);\n            String devicePassword = AttributeUtil.getDevicePassword(\n                    getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n            sendEventResponse(event, devicePassword, channel, remoteAddress);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}