{
    "generation": "    protected Object decodeAvrmc(\n            String sentence, Channel channel, SocketAddress remoteAddress) {\n\n        Parser parser = new Parser(PATTERN_AVRMC, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession =\n            getDeviceSession(channel, remoteAddress, parser.next()); // IMEI\n        if (deviceSession == null) {\n            return null;\n        }\n\n        String deviceModel = null;\n        Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n        if (device != null) {\n            deviceModel = device.getModel();\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        DateBuilder dateBuilder = new DateBuilder()\n                .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0)); // Time (hh,mm,ss)\n\n        String status = parser.next(); // Status\n        String upperCaseStatus = status.toUpperCase();\n        position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\"));\n        position.set(Position.KEY_STATUS, status);\n\n        position.setLatitude(parser.nextCoordinate()); // Latitude\n        position.setLongitude(parser.nextCoordinate()); // Longitude\n        position.setSpeed(parser.nextDouble(0)); // Speed\n        position.setCourse(parser.nextDouble(0)); // Course\n\n        dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0)); // Date (dd,mm,yy)\n        position.setTime(dateBuilder.getDate());\n\n        String event = parser.next(); // Event\n        position.set(Position.KEY_ALARM, decodeAlarm(event));\n        position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n\n        // Battery\n        position.set(Position.KEY_BATTERY, Double.parseDouble(parser.next().replaceAll(\"\\\\.\", \"\")) * 0.001);\n        \n        // GPS Strength, Digital I/O, ADC1 - These are mandatory per pattern segment before optional parts\n        position.set(Position.KEY_GPS, parser.nextInt(0));      // GPS Strength\n        position.set(Position.KEY_INPUT, parser.nextInt(0));    // Digital Input\n        position.set(Position.KEY_OUTPUT, parser.nextInt(0));   // Digital Output\n        position.set(Position.PREFIX_ADC + 1, parser.nextDouble(0) * 0.001); // Analog Input 1 (ADC1)\n\n        // Optional block: Odometer, Network Info, potentially ADC2 for specific models\n        if (parser.hasNext()) { // Check if the optional block (starting with Odometer) is present\n            position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000); // Odometer\n\n            // ADC2 for AVL110/AVL120 models, if present after Odometer and before LAC.\n            // This check assumes that if it's one of these models and a field is available here, it IS ADC2.\n            if ((\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) && parser.hasNext()) {\n                position.set(Position.PREFIX_ADC + 2, parser.nextDouble(0) * 0.001);\n            }\n\n            // Network Information (LAC, CID, MCC, MNC)\n            // Use parser.next<Type>() which return null if field is missing/empty or unparseable\n            Integer lac = parser.hasNext() ? parser.nextHexInt() : null;\n            Integer cid = parser.hasNext() ? parser.nextHexInt() : null;\n            Integer mcc = parser.hasNext() ? parser.nextInt() : null;\n            Integer mnc = parser.hasNext() ? parser.nextInt() : null;\n\n            if (lac != null && cid != null) { // Must have at least LAC and CID\n                if (mcc != null && mnc != null) { // If MCC and MNC are also available\n                    position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n                } else { // Only LAC and CID are available\n                    position.setNetwork(new Network(CellTower.fromLacCid(lac, cid)));\n                }\n            }\n        }\n        \n        // The original code had 'parser.next(); // unused' here.\n        // Guarding it to consume a potential trailing optional field before checksum, if any.\n        if (parser.hasNext()) {\n             parser.next(); \n        }\n\n        String checksum = parser.next(); // Checksum\n\n        if (channel != null) {\n            sendAcknowledge(status, event, checksum, channel, remoteAddress);\n            String devicePassword = AttributeUtil.getDevicePassword(\n                    getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n            sendEventResponse(event, devicePassword, channel, remoteAddress);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}