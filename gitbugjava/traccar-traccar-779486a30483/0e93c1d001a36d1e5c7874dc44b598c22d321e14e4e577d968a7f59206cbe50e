{
    "generation": "    protected Object decodeAvrmc(\n            String sentence, Channel channel, SocketAddress remoteAddress) {\n\n        Parser parser = new Parser(PATTERN_AVRMC, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession =\n            getDeviceSession(channel, remoteAddress, parser.next());\n        if (deviceSession == null) {\n            return null;\n        }\n\n        String deviceModel = null;\n        Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n        if (device != null) {\n            deviceModel = device.getModel();\n        }\n\n        Position position = new Position(getProtocolName());\n\n        position.setDeviceId(deviceSession.getDeviceId());\n        DateBuilder dateBuilder = new DateBuilder()\n                .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n\n        String status = parser.next();\n        String upperCaseStatus = status.toUpperCase();\n        position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\"));\n        position.set(Position.KEY_STATUS, status);\n\n        position.setLatitude(parser.nextCoordinate());\n        position.setLongitude(parser.nextCoordinate());\n        position.setSpeed(parser.nextDouble(0));\n        position.setCourse(parser.nextDouble(0));\n\n        dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n        position.setTime(dateBuilder.getDate());\n\n        String event = parser.next();\n        position.set(Position.KEY_ALARM, decodeAlarm(event));\n        position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n        // Use nextDouble for battery to handle potential floats like \"3.727\" correctly without replaceAll hack\n        position.set(Position.KEY_BATTERY, parser.nextDouble(0) * 0.001);\n        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);\n        position.set(Position.KEY_GPS, parser.nextInt(0));\n        position.set(Position.PREFIX_ADC + 1, parser.nextDouble(0) * 0.001);\n\n        Integer lac = null, cid = null, mcc = null, mnc = null;\n\n        // Check for ADC2 field (always present before network info if network info exists)\n        if (parser.hasNext()) {\n            try {\n                double adc2 = parser.nextDouble(0) * 0.001; // Consume potential ADC2 field, use default 0\n                if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n                    position.set(Position.PREFIX_ADC + 2, adc2); // Store if model matches\n                }\n            } catch (NumberFormatException e) {\n                // ADC2 field was not a number, maybe it's network info directly? Or checksum?\n                // This indicates an unexpected format, ignore ADC2 for this message.\n                // The parser index might be wrong now, but proceed cautiously.\n            }\n\n            // Now check for network info fields, assuming they come after ADC2\n            if (parser.hasNext(2)) { // Need two fields for network info\n                String netInfo1 = parser.next();\n                String netInfo2 = parser.next();\n                try {\n                    // Network info 1: LAC and CID (8 hex digits) or \"0\"\n                    if (netInfo1.matches(\"^[0-9a-fA-F]{8}$\")) {\n                        lac = Integer.parseInt(netInfo1.substring(0, 4), 16);\n                        cid = Integer.parseInt(netInfo1.substring(4, 8), 16);\n                    } else if (\"0\".equals(netInfo1)) {\n                        lac = 0;\n                        cid = 0;\n                    }\n\n                    // Network info 2: MCC and MNC (5 or 6 decimal digits) or \"0\"\n                    if (netInfo2.matches(\"^[0-9]{5,6}$\")) {\n                        mcc = Integer.parseInt(netInfo2.substring(0, 3));\n                        mnc = Integer.parseInt(netInfo2.substring(3));\n                    } else if (\"0\".equals(netInfo2)) {\n                        mcc = 0;\n                        mnc = 0;\n                    }\n                } catch (NumberFormatException | IndexOutOfBoundsException e) {\n                    // Failed to parse network info, ignore these fields\n                    lac = null; cid = null; mcc = null; mnc = null;\n                }\n            }\n        }\n\n        // Set Network Info if valid values were parsed\n        if (lac != null && cid != null && mcc != null && mnc != null) {\n            position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n        }\n\n        // Removed the incorrect parser.next(); call here\n\n        String checksum = parser.next(); // Assume checksum is the next field\n\n        if (channel != null) {\n            sendAcknowledge(status, event, checksum, channel, remoteAddress);\n\n            String devicePassword = AttributeUtil.getDevicePassword(\n                    getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n            sendEventResponse(event, devicePassword, channel, remoteAddress);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}