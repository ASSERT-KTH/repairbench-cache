{
    "generation": "protected Object decodeAvrmc(\n        String sentence, Channel channel, SocketAddress remoteAddress) {\n\n    Parser parser = new Parser(PATTERN_AVRMC, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n\n    DeviceSession deviceSession =\n        getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n\n    String deviceModel = null;\n    Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n    if (device != null) {\n        deviceModel = device.getModel();\n    }\n\n    Position position = new Position(getProtocolName());\n\n    position.setDeviceId(deviceSession.getDeviceId());\n    DateBuilder dateBuilder = new DateBuilder()\n            .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n\n    String status = parser.next();\n    String upperCaseStatus = status.toUpperCase();\n\n    // FIX: The status V (void) must be considered as invalid\n    // Only status A, R, P, a, r, p (Active, Real-time, Panic) should be valid (case insensitive)\n    // All others, including V|v (void), are invalid\n    position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\"));    \n\n    position.set(Position.KEY_STATUS, status);\n\n    position.setLatitude(parser.nextCoordinate());\n    position.setLongitude(parser.nextCoordinate());\n    position.setSpeed(parser.nextDouble(0));\n    position.setCourse(parser.nextDouble(0));\n\n    dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n    position.setTime(dateBuilder.getDate());\n\n    String event = parser.next();\n    position.set(Position.KEY_ALARM, decodeAlarm(event));\n    position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n    // Battery can be missing or possibly invalid. Add check before parsing\n    String batteryString = parser.next();\n    if (batteryString != null && !batteryString.isEmpty()) {\n        try {\n            // sometimes battery can include \".\", sometimes not;\n            // original code tried to strip all '.', but that would cause \"3.727\" \u2192 \"3727\" which is odd\n            // In fact, the value should be parsed as-is\n            position.set(Position.KEY_BATTERY, Double.parseDouble(batteryString));\n        } catch (NumberFormatException ex) {\n            // skip battery if parsing fails\n        }\n    }\n\n    if (parser.hasNext()) { // Odometer\n        Double odometer = parser.nextDouble();\n        if (odometer != null) {\n            position.set(Position.KEY_ODOMETER, odometer * 1000);\n        }\n    }\n\n    if (parser.hasNext()) { // Gps signal bars\n        Integer gps = parser.nextInt();\n        if (gps != null) {\n            position.set(Position.KEY_GPS, gps);\n        }\n    }\n\n    if (parser.hasNext()) { // Adc1\n        Double adc1 = parser.nextDouble();\n        if (adc1 != null) {\n            position.set(Position.PREFIX_ADC + 1, adc1 * 0.001);\n        }\n    }\n\n    if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n        if (parser.hasNext()) { // Adc2 for AVL110/AVL120\n            Double adc2 = parser.nextDouble();\n            if (adc2 != null) {\n                position.set(Position.PREFIX_ADC + 2, adc2 * 0.001);\n            }\n        }\n    }\n\n    Integer lac = null, cid = null, mcc = null, mnc = null;\n\n    if (parser.hasNext()) {\n        lac = parser.nextHexInt();\n    }\n    if (parser.hasNext()) {\n        cid = parser.nextHexInt();\n    }\n    if (parser.hasNext()) {\n        mcc = parser.nextInt();\n    }\n    if (parser.hasNext()) {\n        mnc = parser.nextInt();\n    }\n    if (lac != null && cid != null && mcc != null && mnc != null\n            && (lac != 0 || cid != 0 || mcc != 0 || mnc != 0)) {\n        position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n    }\n\n    // The protocol might have more unused params before checksum, skip until you find the checksum\n    String unused = null;\n    // Keep skipping until the last field (checksum) - which always starts with \"*\"\n    String checksum = null;\n    while (parser.hasNext()) {\n        String value = parser.next();\n        if (value.startsWith(\"*\")) {\n            checksum = value.replace(\"*\", \"\");\n            break;\n        }\n        unused = value;\n    }\n\n    if (checksum == null && unused != null && unused.startsWith(\"*\")) {\n        checksum = unused.replace(\"*\", \"\");\n    }\n\n    if (channel != null) {\n        sendAcknowledge(status, event, checksum, channel, remoteAddress);\n\n        String devicePassword = AttributeUtil.getDevicePassword(\n                getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n        sendEventResponse(event, devicePassword, channel, remoteAddress);\n    }\n\n    return position;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}