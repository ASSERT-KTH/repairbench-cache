{
    "generation": "    @Override\n    protected Object decodeAvrmc(\n            String sentence, Channel channel, SocketAddress remoteAddress) {\n\n        // Only handle $AVRMC sentences\n        if (sentence == null || !sentence.startsWith(\"$AVRMC,\")) {\n            return null;\n        }\n        // Split off checksum\n        int asteriskIndex = sentence.indexOf('*');\n        if (asteriskIndex < 0) {\n            return null;\n        }\n        String dataPart = sentence.substring(0, asteriskIndex);\n        String checksum = sentence.substring(asteriskIndex + 1);\n        String[] parts = dataPart.split(\",\");\n        // We need at least up to GPS (index 14) and ADC1 (index 15)\n        if (parts.length < 16) {\n            return null;\n        }\n        // Device session\n        String imei = parts[1];\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n        // Device model (for possible second ADC)\n        String deviceModel = null;\n        Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n        if (device != null) {\n            deviceModel = device.getModel();\n        }\n        // Prepare position\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n        // Parse time hhmmss\n        String timeStr = parts[2];\n        int hour = 0, minute = 0, second = 0;\n        if (timeStr.length() >= 6) {\n            hour = Integer.parseInt(timeStr.substring(0, 2));\n            minute = Integer.parseInt(timeStr.substring(2, 4));\n            second = Integer.parseInt(timeStr.substring(4, 6));\n        }\n        // Parse date ddmmyy\n        String dateStr = parts[10];\n        int day = 0, month = 0, year = 0;\n        if (dateStr.length() >= 6) {\n            day = Integer.parseInt(dateStr.substring(0, 2));\n            month = Integer.parseInt(dateStr.substring(2, 4));\n            year = Integer.parseInt(dateStr.substring(4, 6));\n        }\n        DateBuilder db = new DateBuilder()\n                .setTime(hour, minute, second)\n                .setDateReverse(day, month, year);\n        position.setTime(db.getDate());\n        // Status and validity\n        String status = parts[3];\n        String upper = status.toUpperCase();\n        position.setValid(upper.equals(\"A\") || upper.equals(\"R\") || upper.equals(\"P\"));\n        position.set(Position.KEY_STATUS, status);\n        // Latitude\n        double latitude = 0;\n        if (!parts[4].isEmpty() && !parts[5].isEmpty()) {\n            double lv = Double.parseDouble(parts[4]);\n            int deg = (int) (lv / 100);\n            double min = lv - deg * 100;\n            latitude = deg + min / 60;\n            if (\"S\".equals(parts[5])) {\n                latitude = -latitude;\n            }\n        }\n        position.setLatitude(latitude);\n        // Longitude\n        double longitude = 0;\n        if (!parts[6].isEmpty() && !parts[7].isEmpty()) {\n            double lv = Double.parseDouble(parts[6]);\n            int deg = (int) (lv / 100);\n            double min = lv - deg * 100;\n            longitude = deg + min / 60;\n            if (\"W\".equals(parts[7])) {\n                longitude = -longitude;\n            }\n        }\n        position.setLongitude(longitude);\n        // Speed\n        try {\n            position.setSpeed(Double.parseDouble(parts[8]));\n        } catch (Exception e) {\n            position.setSpeed(0.0);\n        }\n        // Course\n        try {\n            position.setCourse(Double.parseDouble(parts[9]));\n        } catch (Exception e) {\n            position.setCourse(0.0);\n        }\n        // Event / Alarm\n        String event = parts[11];\n        position.set(Position.KEY_ALARM, decodeAlarm(event));\n        position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n        // Battery (remove decimal point, then scale)\n        try {\n            position.set(Position.KEY_BATTERY,\n                    Double.parseDouble(parts[12].replaceAll(\"\\\\.\", \"\")) * 0.001);\n        } catch (Exception e) {\n            // ignore\n        }\n        // Odometer (km \u2192 m)\n        try {\n            position.set(Position.KEY_ODOMETER,\n                    Double.parseDouble(parts[13]) * 1000);\n        } catch (Exception e) {\n            // ignore\n        }\n        // GPS info\n        try {\n            position.set(Position.KEY_GPS,\n                    Integer.parseInt(parts[14]));\n        } catch (Exception e) {\n            // ignore\n        }\n        // ADC1\n        try {\n            position.set(Position.PREFIX_ADC + 1,\n                    Double.parseDouble(parts[15]) * 0.001);\n        } catch (Exception e) {\n            // ignore\n        }\n        // ADC2 for specific models\n        int idx = 16;\n        if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n            if (parts.length > idx) {\n                try {\n                    position.set(Position.PREFIX_ADC + 2,\n                            Double.parseDouble(parts[idx]) * 0.001);\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n            idx++;\n        }\n        // Network cell tower (hex LAC/CID, decimal MCC/MNC)\n        if (parts.length > idx + 3) {\n            try {\n                int lac = Integer.parseInt(parts[idx], 16);\n                int cid = Integer.parseInt(parts[idx + 1], 16);\n                int mcc = Integer.parseInt(parts[idx + 2]);\n                int mnc = Integer.parseInt(parts[idx + 3]);\n                if (lac != 0 && cid != 0 && mcc != 0 && mnc != 0) {\n                    position.setNetwork(new Network(\n                            CellTower.from(mcc, mnc, lac, cid)));\n                }\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        // Acknowledge back to device\n        if (channel != null) {\n            sendAcknowledge(status, event, checksum, channel, remoteAddress);\n            String devicePassword = AttributeUtil.getDevicePassword(\n                    getCacheManager(), deviceSession.getDeviceId(),\n                    getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n            sendEventResponse(event, devicePassword, channel, remoteAddress);\n        }\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}