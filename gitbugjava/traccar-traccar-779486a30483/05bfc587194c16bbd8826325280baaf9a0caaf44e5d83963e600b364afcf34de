{
    "generation": "protected Object decodeAvrmc(\n        String sentence, Channel channel, SocketAddress remoteAddress) {\n\n    Parser parser = new Parser(PATTERN_AVRMC, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n\n    DeviceSession deviceSession =\n        getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n\n    String deviceModel = null;\n    Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n    if (device != null) {\n        deviceModel = device.getModel();\n    }\n\n    Position position = new Position(getProtocolName());\n\n    position.setDeviceId(deviceSession.getDeviceId());\n    DateBuilder dateBuilder = new DateBuilder()\n            .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n\n    String status = parser.next();\n    String upperCaseStatus = status.toUpperCase();\n    // Accept any one-letter status as valid, except for 'V' (void)\n    position.setValid(\n        (status.length() == 1 && !\"V\".equalsIgnoreCase(status))\n        || upperCaseStatus.equals(\"A\")\n        || upperCaseStatus.equals(\"R\")\n        || upperCaseStatus.equals(\"P\"));\n    position.set(Position.KEY_STATUS, status);\n\n    position.setLatitude(parser.nextCoordinate());\n    position.setLongitude(parser.nextCoordinate());\n    position.setSpeed(parser.nextDouble(0));\n    position.setCourse(parser.nextDouble(0));\n\n    dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n    position.setTime(dateBuilder.getDate());\n\n    String event = parser.next();\n    position.set(Position.KEY_ALARM, decodeAlarm(event));\n    position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n\n    String battery = parser.next(); // can be double or integer or not present\n    if (battery != null) {\n        try {\n            position.set(Position.KEY_BATTERY, Double.parseDouble(battery.replaceAll(\"\\\\.\", \"\")) * 0.001);\n        } catch (NumberFormatException e) {\n            // ignore if can't parse, just skip\n        }\n    }\n\n    position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n    position.set(Position.KEY_GPS, parser.nextInt());\n    position.set(Position.PREFIX_ADC + 1, parser.nextDouble() * 0.001);\n\n    if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n        position.set(Position.PREFIX_ADC + 2, parser.nextDouble() * 0.001);\n    }\n\n    Integer lac = parser.nextHexInt();\n    Integer cid = parser.nextHexInt();\n    Integer mcc = parser.nextInt();\n    Integer mnc = parser.nextInt();\n    if (lac != null && cid != null && mcc != null && mnc != null\n            && (lac != 0 || cid != 0 || mcc != 0 || mnc != 0)) {\n        position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n    }\n\n    // Skip any parameters remaining until the checksum as there may be a variable count of them\n    String lastValue = null;\n    while (parser.hasNext()) {\n        String value = parser.next();\n        if (value.startsWith(\"*\") || (value.length() > 0 && value.charAt(value.length() - 1) == '*')) {\n            lastValue = value;\n            break;\n        }\n        lastValue = value;\n    }\n\n    // Separate the checksum if necessary\n    String checksum = null;\n    if (lastValue != null) {\n        if (lastValue.contains(\"*\")) {\n            int idx = lastValue.indexOf('*');\n            // Possibility: value before * is a valid field, after * is checksum\n            if (idx == lastValue.length() - 1) { // no characters after star\n                checksum = parser.hasNext() ? parser.next() : \"\";\n            } else {\n                checksum = lastValue.substring(idx + 1);\n            }\n        } else if (parser.hasNext()) {\n            String possibleChecksum = parser.next();\n            if (possibleChecksum.startsWith(\"*\")) {\n                checksum = possibleChecksum.substring(1);\n            } else {\n                checksum = possibleChecksum;\n            }\n        }\n    }\n\n    if (channel != null) {\n\n        sendAcknowledge(status, event, checksum, channel, remoteAddress);\n\n        String devicePassword = AttributeUtil.getDevicePassword(\n                getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n        sendEventResponse(event, devicePassword, channel, remoteAddress);\n    }\n\n    return position;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}