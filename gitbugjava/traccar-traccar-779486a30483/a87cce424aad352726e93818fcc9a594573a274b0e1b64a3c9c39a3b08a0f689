{
    "generation": "protected Object decodeAvrmc(\n        String sentence, Channel channel, SocketAddress remoteAddress) {\n\n    Parser parser = new Parser(PATTERN_AVRMC, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n\n    DeviceSession deviceSession =\n        getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n\n    String deviceModel = null;\n    Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n    if (device != null) {\n        deviceModel = device.getModel();\n    }\n\n    Position position = new Position(getProtocolName());\n\n    position.setDeviceId(deviceSession.getDeviceId());\n    DateBuilder dateBuilder = new DateBuilder()\n            .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n\n    String status = parser.next();\n    String upperCaseStatus = status.toUpperCase();\n    position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\") || upperCaseStatus.equals(\"V\") || upperCaseStatus.equals(\"p\") || upperCaseStatus.equals(\"v\") || upperCaseStatus.equals(\"r\") || upperCaseStatus.equals(\"a\") || upperCaseStatus.equals(\"P\"));\n    // Fix: Also treat 'V' (void) and unrecognized as invalid, only 'A', 'R', 'P', 'p', 'r', 'a' as valid true, 'V'/'v' and others as false\n\n    // Actually, based on the protocol, \"A\"=Active/fix, \"V\"=invalid (so false validity), \"R\"/\"P\" might mean valid, but \"V\" is invalid\n    // So let's make: valid = status equalsIgnoreCase \"A\" or \"R\" or \"P\"\n    position.setValid(\n        upperCaseStatus.equals(\"A\") \n        || upperCaseStatus.equals(\"R\") \n        || upperCaseStatus.equals(\"P\")\n    );\n\n    position.set(Position.KEY_STATUS, status);\n\n    position.setLatitude(parser.nextCoordinate());\n    position.setLongitude(parser.nextCoordinate());\n    position.setSpeed(parser.nextDouble(0));\n    position.setCourse(parser.nextDouble(0));\n\n    dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n    position.setTime(dateBuilder.getDate());\n\n    String event = parser.next();\n    position.set(Position.KEY_ALARM, decodeAlarm(event));\n    position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n    // Battery voltage - may be missing\n    String batteryStr = parser.next();\n    Double battery = null;\n    try {\n        if (batteryStr != null && !batteryStr.isEmpty()) {\n            battery = Double.parseDouble(batteryStr.replaceAll(\"\\\\.\", \"\")) * 0.001;\n        }\n    } catch (NumberFormatException e) {\n        battery = null;\n    }\n    if (battery != null) {\n        position.set(Position.KEY_BATTERY, battery);\n    }\n\n    if (parser.hasNext()) position.set(Position.KEY_ODOMETER, parser.nextDouble() * 1000);\n    if (parser.hasNext()) position.set(Position.KEY_GPS, parser.nextInt());\n    if (parser.hasNext()) position.set(Position.PREFIX_ADC + 1, parser.nextDouble() * 0.001);\n\n    if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n        if (parser.hasNext()) position.set(Position.PREFIX_ADC + 2, parser.nextDouble() * 0.001);\n    }\n\n    Integer lac = null, cid = null, mcc = null, mnc = null;\n    // Try to read next hex ints/MMC/MNC but only if present\n    if (parser.hasNext()) lac = parser.nextHexInt();\n    if (parser.hasNext()) cid = parser.nextHexInt();\n    if (parser.hasNext()) mcc = parser.nextInt();\n    if (parser.hasNext()) mnc = parser.nextInt();\n\n    if (lac != null && cid != null && mcc != null && mnc != null\n            && lac > 0 && cid > 0 && mcc > 0 && mnc > 0) {\n        position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n    }\n\n    // Skip any extra fields but do not require\n    while (parser.hasNext(1)) {\n        String unusedField = parser.next();\n        // Check if this field could be the checksum (should start with '*', due to split)\n        if (unusedField != null && unusedField.length() > 0\n                && (unusedField.startsWith(\"*\") || unusedField.matches(\"[0-9A-Fa-f]{2}\"))) {\n            // We treat as checksum, end parsing\n            break;\n        }\n    }\n\n    // If still has a field, treat as checksum\n    String checksum = null;\n    if (parser.hasNext()) {\n        checksum = parser.next();\n    }\n\n    if (channel != null) {\n\n        sendAcknowledge(status, event, checksum, channel, remoteAddress);\n\n        String devicePassword = AttributeUtil.getDevicePassword(\n                getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n        sendEventResponse(event, devicePassword, channel, remoteAddress);\n    }\n\n    return position;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}