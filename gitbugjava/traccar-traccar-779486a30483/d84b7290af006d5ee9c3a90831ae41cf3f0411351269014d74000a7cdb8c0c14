{
    "generation": "    protected Object decodeAvrmc(\n            String sentence, Channel channel, SocketAddress remoteAddress) {\n\n        Parser parser = new Parser(PATTERN_AVRMC, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession =\n            getDeviceSession(channel, remoteAddress, parser.next()); // IMEI (group 1)\n        if (deviceSession == null) {\n            return null;\n        }\n\n        String deviceModel = null;\n        Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n        if (device != null) {\n            deviceModel = device.getModel();\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        DateBuilder dateBuilder = new DateBuilder();\n        String time = parser.next(); // Time HHMMSS (group 2)\n        if (time != null && time.length() == 6) {\n            dateBuilder.setTime(\n                    Integer.parseInt(time.substring(0, 2)),\n                    Integer.parseInt(time.substring(2, 4)),\n                    Integer.parseInt(time.substring(4, 6)));\n        }\n\n        String status = parser.next(); // Status (group 3)\n        String upperCaseStatus = status.toUpperCase();\n        position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\"));\n        position.set(Position.KEY_STATUS, status);\n\n        position.setLatitude(parser.nextCoordinate());  // Latitude (groups 4, 5)\n        position.setLongitude(parser.nextCoordinate()); // Longitude (groups 6, 7)\n        position.setSpeed(parser.nextDouble(0));      // Speed (group 8)\n        position.setCourse(parser.nextDouble(0));     // Course (group 9)\n\n        String date = parser.next(); // Date DDMMYY (group 10)\n        if (date != null && date.length() == 6) {\n            dateBuilder.setDateReverse(\n                    Integer.parseInt(date.substring(0, 2)),\n                    Integer.parseInt(date.substring(2, 4)),\n                    Integer.parseInt(date.substring(4, 6)));\n        }\n        position.setTime(dateBuilder.getDate());\n\n        String event = parser.next(); // Event (group 11)\n        position.set(Position.KEY_ALARM, decodeAlarm(event));\n        position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n\n        // Battery (group 12)\n        position.set(Position.KEY_BATTERY, Double.parseDouble(parser.next().replaceAll(\"\\\\.\", \"\")) * 0.001);\n        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000); // Odometer (group 13)\n        position.set(Position.KEY_GPS, parser.nextInt(0)); // GPS (group 14)\n        position.set(Position.PREFIX_ADC + 1, parser.nextDouble(0) * 0.001); // ADC 1 (group 15)\n\n        // ADC 2 (group 16 - optional in pattern)\n        // Consume group 16. Use value if model matches, otherwise discard.\n        // parser.nextDouble(0) handles cases where the optional group 16 is not present in the message (returns 0.0).\n        double adc2Value = parser.nextDouble(0);\n        if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n            position.set(Position.PREFIX_ADC + 2, adc2Value * 0.001);\n        }\n\n        Integer lac = parser.nextHexInt(0); // LAC (group 17 - optional)\n        Integer cid = parser.nextHexInt(0); // CID (group 18 - optional)\n        Integer mcc = parser.nextInt(0);    // MCC (group 19 - optional)\n        Integer mnc = parser.nextInt(0);    // MNC (group 20 - optional)\n        if (lac != null && cid != null && mcc != null && mnc != null\n                && (lac != 0 || cid != 0)) { // Also check if lac/cid are not both zero\n            position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n        }\n\n        parser.next(); // SIM card ICCID (group 21 - optional, unused in this position object)\n\n        String checksumInBody = parser.next(); // Optional checksum in body (group 22 - optional)\n\n        if (channel != null) {\n            // The checksum for acknowledge is typically the one after '*' from the NMEA sentence.\n            // If PATTERN_AVRMC's .checksum() validates it but doesn't make it available,\n            // we might need to extract it from 'sentence' string if required by sendAcknowledge.\n            // However, sendAcknowledge might also handle a null checksum parameter.\n            // Using checksumInBody if present, or null if not.\n            sendAcknowledge(status, event, checksumInBody, channel, remoteAddress);\n\n            String devicePassword = AttributeUtil.getDevicePassword(\n                    getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n            sendEventResponse(event, devicePassword, channel, remoteAddress);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}