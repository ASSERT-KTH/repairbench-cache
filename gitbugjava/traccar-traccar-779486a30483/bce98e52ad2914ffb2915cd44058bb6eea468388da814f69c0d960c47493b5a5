{
    "generation": "protected Object decodeAvrmc(\n        String sentence, Channel channel, SocketAddress remoteAddress) {\n\n    Parser parser = new Parser(PATTERN_AVRMC, sentence);\n    if (!parser.matches()) {\n        return null;\n    }\n\n    DeviceSession deviceSession =\n        getDeviceSession(channel, remoteAddress, parser.next());\n    if (deviceSession == null) {\n        return null;\n    }\n\n    String deviceModel = null;\n    Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n    if (device != null) {\n        deviceModel = device.getModel();\n    }\n\n    Position position = new Position(getProtocolName());\n\n    position.setDeviceId(deviceSession.getDeviceId());\n    DateBuilder dateBuilder = new DateBuilder()\n            .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n\n    String status = parser.next();\n    String upperCaseStatus = status.toUpperCase();\n    // Fix: 'V' or 'v' is invalid, only A, R, P (upper/lower) are valid\n    position.setValid(\n            upperCaseStatus.equals(\"A\") ||\n            upperCaseStatus.equals(\"R\") ||\n            upperCaseStatus.equals(\"P\") ||\n            upperCaseStatus.equals(\"S\") ||\n            upperCaseStatus.equals(\"T\") ||\n            upperCaseStatus.equals(\"3\") ||\n            upperCaseStatus.equals(\"X\") ||\n            upperCaseStatus.equals(\"4\")\n    );\n    position.set(Position.KEY_STATUS, status);\n\n    position.setLatitude(parser.nextCoordinate());\n    position.setLongitude(parser.nextCoordinate());\n    position.setSpeed(parser.nextDouble(0));\n    position.setCourse(parser.nextDouble(0));\n\n    dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0));\n    position.setTime(dateBuilder.getDate());\n\n    String event = parser.next();\n    position.set(Position.KEY_ALARM, decodeAlarm(event));\n    position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel));\n\n    // Battery sometimes has '.' or not, sometimes not present\n    String batteryStr = parser.next();\n    if (batteryStr != null && !batteryStr.isEmpty()) {\n        try {\n            if (batteryStr.contains(\".\")) {\n                position.set(Position.KEY_BATTERY, Double.parseDouble(batteryStr));\n            } else {\n                position.set(Position.KEY_BATTERY, Double.parseDouble(batteryStr.replaceAll(\"\\\\.\", \"\")) * 0.001);\n            }\n        } catch (NumberFormatException e) {\n            // do nothing\n        }\n    }\n\n    // Odometer\n    String odoStr = parser.next();\n    if (odoStr != null && !odoStr.isEmpty()) {\n        try {\n            position.set(Position.KEY_ODOMETER, Double.parseDouble(odoStr) * 1000);\n        } catch (NumberFormatException e) {\n            // do nothing\n        }\n    }\n\n    // GPS\n    String gpsStr = parser.next();\n    if (gpsStr != null && !gpsStr.isEmpty()) {\n        try {\n            position.set(Position.KEY_GPS, Integer.parseInt(gpsStr));\n        } catch (NumberFormatException e) {\n            // do nothing\n        }\n    }\n\n    // ADC 1\n    String adc1Str = parser.next();\n    if (adc1Str != null && !adc1Str.isEmpty()) {\n        try {\n            position.set(Position.PREFIX_ADC + 1, Double.parseDouble(adc1Str) * 0.001);\n        } catch (NumberFormatException e) {\n            // do nothing\n        }\n    }\n\n    // Additional ADC, LAC, CID, etc are all optional\n    if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n        String adc2Str = parser.next();\n        if (adc2Str != null && !adc2Str.isEmpty()) {\n            try {\n                position.set(Position.PREFIX_ADC + 2, Double.parseDouble(adc2Str) * 0.001);\n            } catch (NumberFormatException e) {\n                // do nothing\n            }\n        }\n    }\n\n    Integer lac = parser.nextHexInt();\n    Integer cid = parser.nextHexInt();\n    Integer mcc = parser.nextInt();\n    Integer mnc = parser.nextInt();\n    // Accept zeroed network parameters (some units send ,0,0,0,0,...)\n    if (lac != null && cid != null && mcc != null && mnc != null) {\n        if (lac != 0 && cid != 0 && mcc != 0 && mnc != 0) {\n            position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid)));\n        }\n    }\n\n    // Read all remaining fields as unused until checksum\n    while (true) {\n        String item = parser.next();\n        if (item == null) {\n            break;\n        }\n        // look for possible checksum\n        // checksum is after a '*' marker, but parser includes everything as field, last item\n        if (item.contains(\"*\")) {\n            String[] checksumSplit = item.split(\"\\\\*\");\n            if (checksumSplit.length == 2) {\n                // Remove any trailing whitespace or chars after the *\n                String checksum = checksumSplit[1];\n            }\n            break;\n        }\n    }\n\n    // Get checksum (it's always the last field)\n    String checksum = null;\n    int starIndex = sentence.lastIndexOf('*');\n    if (starIndex != -1 && starIndex + 1 < sentence.length()) {\n        checksum = sentence.substring(starIndex + 1);\n    }\n\n    if (channel != null) {\n\n        sendAcknowledge(status, event, checksum, channel, remoteAddress);\n\n        String devicePassword = AttributeUtil.getDevicePassword(\n                getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n        sendEventResponse(event, devicePassword, channel, remoteAddress);\n    }\n\n    return position;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}