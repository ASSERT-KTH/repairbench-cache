{
    "generation": "    protected Object decodeAvrmc(\n            String sentence, Channel channel, SocketAddress remoteAddress) {\n\n        Parser parser = new Parser(PATTERN_AVRMC, sentence); // Use the actual pattern defined in the class\n        if (!parser.matches()) {\n            return null;\n        }\n\n        DeviceSession deviceSession =\n                getDeviceSession(channel, remoteAddress, parser.next()); // Field 1: Device ID\n        if (deviceSession == null) {\n            return null;\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Determine device model early - needed for conditional parsing\n        String deviceModel = null;\n        Device device = getCacheManager().getObject(Device.class, deviceSession.getDeviceId());\n        if (device != null) {\n            deviceModel = device.getModel();\n        }\n\n        DateBuilder dateBuilder = new DateBuilder()\n                .setTime(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0)); // Field 2: Time hhmmss\n\n        String status = parser.next(); // Field 3: Status\n        String upperCaseStatus = status.toUpperCase();\n        // Status 'R' means RTK fix, 'P' means DGPS fix, both valid according to some NMEA extensions / specific protocols.\n        position.setValid(upperCaseStatus.equals(\"A\") || upperCaseStatus.equals(\"R\") || upperCaseStatus.equals(\"P\"));\n        position.set(Position.KEY_STATUS, status);\n\n        position.setLatitude(parser.nextCoordinate());  // Fields 4, 5: Latitude\n        position.setLongitude(parser.nextCoordinate()); // Fields 6, 7: Longitude\n        position.setSpeed(parser.nextDouble(0));      // Field 8: Speed knots\n        position.setCourse(parser.nextDouble(0));     // Field 9: Course\n\n        dateBuilder.setDateReverse(parser.nextInt(0), parser.nextInt(0), parser.nextInt(0)); // Field 10: Date ddmmyy\n        position.setTime(dateBuilder.getDate());\n\n        String event = parser.next(); // Field 11: Event\n        position.set(Position.KEY_ALARM, decodeAlarm(event));\n        position.set(Position.KEY_EVENT, decodeEvent(event, position, deviceModel)); // Decode event after model is known\n\n        // Field 12: Battery\n        String batteryStr = parser.next();\n        if (batteryStr != null && !batteryStr.isEmpty()) {\n            try {\n                double batteryValue;\n                if (batteryStr.contains(\".\")) {\n                    // Assume Volts (e.g., \"3.727\")\n                    batteryValue = Double.parseDouble(batteryStr);\n                } else {\n                    // Assume milliVolts (e.g., \"4076\")\n                    batteryValue = Double.parseDouble(batteryStr) * 0.001;\n                }\n                position.set(Position.KEY_BATTERY, batteryValue);\n            } catch (NumberFormatException e) {\n                // Ignore invalid battery value\n            }\n        }\n\n        // Field 13: Odometer (assume km -> m)\n        position.set(Position.KEY_ODOMETER, parser.nextDouble(0) * 1000);\n\n        // Field 14: GPS Fix Status / Satellite Count?\n        position.set(Position.KEY_GPS, parser.nextInt(0));\n\n        // Field 15: ADC1 (assume mV -> V)\n        position.set(Position.PREFIX_ADC + 1, parser.nextDouble(0) * 0.001);\n\n        // Field 16: ADC2 (mV -> V). Conditional based on device model.\n        if (\"AVL110\".equals(deviceModel) || \"AVL120\".equals(deviceModel)) {\n             if (parser.hasNext()) { // Check if field exists for this model\n                 position.set(Position.PREFIX_ADC + 2, parser.nextDouble(0) * 0.001);\n             }\n        }\n        // If not AVL110/120, ADC2 field is not consumed by parser, parser index remains correct.\n\n        // Network Info (Fields after ADC1 or optional ADC2: LAC, CID)\n        Integer lac = null;\n        Integer cid = null;\n        String lacField = parser.hasNext() ? parser.next() : null; // Potential LAC\n        String cidField = parser.hasNext() ? parser.next() : null; // Potential CID\n\n        if (lacField != null && cidField != null) {\n            // Try parsing as hex (common case)\n            lac = Parser.parseHexInt(lacField);\n            cid = Parser.parseHexInt(cidField);\n\n            if (lac == null || cid == null) {\n                // If hex parsing failed for either, try parsing both as decimal\n                Integer lacDec = null, cidDec = null;\n                try { lacDec = Integer.parseInt(lacField); } catch (NumberFormatException e) { /* ignore */ }\n                try { cidDec = Integer.parseInt(cidField); } catch (NumberFormatException e) { /* ignore */ }\n\n                // Use decimal parse results only if both were successfully parsed as decimal\n                if (lacDec != null && cidDec != null) {\n                   lac = lacDec;\n                   cid = cidDec;\n                } else {\n                    // If decimal parsing also failed or was partial, reset lac/cid to null\n                    // to avoid using inconsistent results (e.g., one hex, one decimal, or one failed)\n                    lac = null;\n                    cid = null;\n                }\n            }\n        }\n\n        if (lac != null && cid != null) {\n            // Store LAC and CID if successfully parsed and non-zero\n            if (lac != 0 || cid != 0) {\n                position.set(Position.KEY_LAC, lac);\n                position.set(Position.KEY_CID, cid);\n                // Cannot create full CellTower/Network without MCC/MNC; storing raw LAC/CID is the best available option\n            }\n        }\n\n        // Skip any remaining optional fields before the checksum\n        String checksum = null;\n        while (parser.hasNext()) {\n            String value = parser.next();\n            // The last field consumed before the loop condition fails is the checksum field value\n            if (!parser.hasNext()) {\n                 checksum = value;\n            }\n        }\n        // Note: This assumes the Parser correctly stops after the field before the '*'.\n        // Checksum validation itself is not performed here.\n\n        // Send acknowledgements etc.\n        // Checksum might be null if parsing failed or message was malformed/incomplete\n        if (channel != null && status != null && event != null && checksum != null) {\n\n            sendAcknowledge(status, event, checksum, channel, remoteAddress);\n\n            // Retrieve password using AttributeUtil\n            String devicePassword = AttributeUtil.getDevicePassword(\n                    getCacheManager(), deviceSession.getDeviceId(), getProtocolName(), DEFAULT_DEVICE_PASSWORD);\n            sendEventResponse(event, devicePassword, channel, remoteAddress);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}