{
    "generation": "    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        if (resultEqualsValue) {\n          // If the result is 'function', narrow to the Function type.\n          // Note that FUNCTION_FUNCTION_TYPE != U2U_CONSTRUCTOR_TYPE. The former\n          // is the type of the Function constructor, the latter is the type of\n          // function instances.\n          return ctorType;\n        } else {\n          // If the result is NOT 'function', remove the Function type from the\n          // possibilities.\n          return type.restrictByNotBeingType(ctorType);\n        }\n      }\n\n      // Handle the typeof x == 'object' case.\n      // Note that typeof null == 'object'.\n      // Note that typeof function == 'function'.\n      // Note that typeof classtype == 'function'.\n      if (value.equals(\"object\")) {\n        // If the result is 'object', Possible types are Object or null.\n        // We know that the current type is not a function, because\n        // functions are handled in the case above.\n        // If the type is already restricted to object/null, it is returned.\n        // If the type could be object/null and something else, restrict it.\n        // If the type cannot be object/null, return null.\n        JSType NATIVE_OBJECT_TYPE = getNativeType(OBJECT_TYPE);\n        JSType nullType = getNativeType(JSTypeNative.NULL_TYPE);\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n\n        boolean canBeObject = !type.getGreatestSubtype(NATIVE_OBJECT_TYPE)\n             .restrictByNotBeingType(ctorType).isEmptyType();\n        boolean canBeNull = !type.getGreatestSubtype(nullType).isEmptyType();\n\n        if (resultEqualsValue) {\n          if (canBeObject || canBeNull) {\n            JSType restricted = type.getGreatestSubtype(NATIVE_OBJECT_TYPE)\n                  .restrictByNotBeingType(ctorType);\n            JSType nullRestricted = type.getGreatestSubtype(nullType);\n            // Union can return bottom type if both are bottom\n            return typeRegistry.createUnionType(restricted, nullRestricted);\n          } else {\n            return null;\n          }\n        } else {\n           // The result is NOT 'object', so it's not an object or null.\n           // It can still be a function or a primitive.\n           // Remove non-function objects and null from the type.\n           JSType restricted = type.restrictByNotBeingType(NATIVE_OBJECT_TYPE);\n           restricted = restricted.restrictByNotBeingType(nullType);\n           return restricted.isEmptyType() ? null : restricted;\n        }\n      }\n\n      // Only treat unknown types as Objects if the Object type is expected.\n      return matchesExpectation(\"object\") ? type : null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}