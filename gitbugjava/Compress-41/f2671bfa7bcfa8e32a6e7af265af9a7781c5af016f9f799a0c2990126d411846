{
    "generation": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null; // Normal end of stream\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n\n        // Check for signatures that indicate the end of the zip stream\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null;\n        }\n        // If it's not a local file header, it's an error\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            // Use the numeric value in the error message for clarity\n            throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", sig.getValue()));\n        }\n\n        // It is a local file header. Read the entry data.\n        int off = WORD; // Skip signature\n        current = new CurrentEntry();\n\n        final int versionNeededToExtract = ZipShort.getValue(LFH_BUF, off); // Version needed to extract\n        off += SHORT;\n        current.entry.setPlatform((versionNeededToExtract >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n        // Not setting versionNeededToExtract in entry - should it be? ZipArchiveEntry doesn't seem to have it.\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT; // General purpose bit flag\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT; // Compression method\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD; // Last mod file time/date\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD; // CRC-32\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD; // Compressed size\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD; // Uncompressed size\n        } else {\n            // Skip CRC, compressed size, uncompressed size fields - will be in data descriptor\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT; // File name length\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT; // Extra field length\n\n        if (fileNameLen < 0) {\n            throw new IOException(\"Invalid file name length: \" + fileNameLen);\n        }\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        if (extraLen < 0) {\n            throw new IOException(\"Invalid extra field length: \" + extraLen);\n        }\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        // Store the LFH data offset\n        current.entry.setDataOffset(getDataOffset());\n\n        // Prepare the input stream for reading entry data\n        // Wrap the raw input stream with BoundedInputStream if the compressed size is known.\n        // This prevents reading beyond the current entry's data.\n        InputStream entryStream = in;\n        final long compressedSize = current.entry.getCompressedSize();\n        boolean isSizeKnown = compressedSize != ArchiveEntry.SIZE_UNKNOWN;\n\n        if (isSizeKnown) {\n            entryStream = new BoundedInputStream(in, compressedSize);\n        }\n\n        // Set up the decompression stream based on the method\n        final int method = current.entry.getMethod();\n        current.in = null; // Initialize current.in\n\n        if (method == ZipMethod.STORED.getCode()) {\n            current.in = entryStream;\n        } else if (method == ZipMethod.DEFLATED.getCode()) {\n            // InflaterInputStream works with potentially bounded stream\n            // It reads until logical end of deflated data is reached.\n            // If size is unknown (Data Descriptor), closeEntry needs to handle reading the descriptor.\n            current.in = new InflaterInputStream(entryStream, new Inflater(true));\n        } else if (method == ZipMethod.UNSHRINKING.getCode()) {\n            // These methods require the size to be known according to original logic/tests.\n            // Only provide the stream if size is known (entryStream is BoundedInputStream).\n            if (isSizeKnown) {\n                current.in = new UnshrinkingInputStream(entryStream);\n            } // else: leave current.in null, caller or closeEntry needs to handle.\n        } else if (method == ZipMethod.IMPLODING.getCode()) {\n            if (isSizeKnown) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        entryStream);\n            } // else: leave current.in null\n        } else if (method == ZipMethod.BZIP2.getCode()) {\n            if (isSizeKnown) {\n                current.in = new BZip2CompressorInputStream(entryStream);\n            } // else: leave current.in null\n        }\n        // Note: For methods where size is unknown and not STORED/DEFLATED, current.in remains null.\n        // The user reading the stream or closeEntry() will handle reading/skipping.\n        // closeEntry() is responsible for finding the data descriptor if needed.\n\n        entriesRead++;\n        return current.entry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}