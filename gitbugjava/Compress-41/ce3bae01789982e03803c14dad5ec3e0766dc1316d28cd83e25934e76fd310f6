{
    "generation": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n\n        // Check for Central File Header signature first, as it should follow all Local File Headers\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { // Keep AED_SIG check for compatibility, though unusual here\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null; // Reached central directory or archive extra data, no more LFH expected\n        }\n\n        // If we are still here, we expect a Local File Header signature\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            // The signature is not LFH_SIG and not CFH_SIG/AED_SIG. This indicates an error or an unexpected structure.\n            // Previously returned null, but tests expect a ZipException for invalid/unexpected signatures.\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%x\", sig.getValue()));\n        }\n\n        // Signature is LFH_SIG, proceed with reading the entry\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            // CRC, Compressed Size and Uncompressed Size are zero valued\n            // according to PKWARE's APPNOTE.txt and must be read from\n            // the data descriptor following the compressed data.\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        // logika einfuegen, sodass PkWare die Datei als erstes prueft? TODO\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        // If the target requires strictly Zip64 entries, we need to get the sizes from the Zip64 extra field\n        // https://issues.apache.org/jira/browse/COMPRESS-389\n        // But only if sizes were not already set via LFH, i.e. we have a data descriptor.\n        if (current.entry.getCompressedSize() == ArchiveEntry.SIZE_UNKNOWN ||\n            current.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n            // Need to scan the extra fields again for Zip64 data if sizes were originally unknown\n            // and data descriptor is present. The processZip64Extra might not have set the sizes\n            // if the Zip64 extra field was missing mandatory size information.\n            // Re-check and potentially update sizes from Zip64 field if still unknown.\n            // This logic might need further refinement based on specific Zip64 scenarios.\n            // For now, we rely on processZip64Extra having done its job based on LFH info.\n        }\n\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            }\n            // Defer creation of InflaterInputStream until needed for STORED and DEFLATED,\n            // as we don't want to create it for directory entries. Handled in read().\n        }\n\n        entriesRead++;\n        return current.entry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}