{
    "generation": "  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        boolean isVarDeclaration = left.hasChildren();\n\n        // Update the flow scope to reflect the type computed by the RHS.\n        // This is the primary responsibility of this function for NAME nodes.\n        // It ensures that the type of the variable in the current scope reflects\n        // the assigned value.\n        redeclareSimpleVar(scope, left, resultType);\n\n        // Set the JSType for the NAME node. This reflects the type of the\n        // L-value expression itself.\n        // In a var declaration, the node represents the variable being declared,\n        // so its type should be the result type.\n        // In an assignment, the node represents the variable before the\n        // assignment, but JSType is often used to propagate the assigned type;\n        // however, the original code used 'null' in assignment if leftType wasn't null.\n        // We stick to the original logic for node type setting to avoid unintended consequences.\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        // If the variable's type was inferred (not declared with @type), update\n        // the variable's type in the symbol table to track the new type.\n        // We avoid overriding declared types in the symbol table based on assignments.\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break; // End of Token.NAME case\n\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          // Infer the type of the qualified name slot in the scope. This updates\n          // the type of the property in the current flow scope.\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        // Update the JSType of the GETPROP node itself. This reflects the type\n        // of the property access expression.\n        left.setJSType(resultType);\n        // Check if the property is defined on the object it's accessed from.\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}