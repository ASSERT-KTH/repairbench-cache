{
    "generation": "    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            // Handles requests for the generic Number class, typically returns Long or Double\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        // Handle specific Number subclasses (Integer, Long, Double, Float, BigDecimal, BigInteger etc.)\n        else if (Number.class.isAssignableFrom(clazz))\n        {\n            // Attempt to use the static valueOf(String) method (common for wrappers like Integer, Long)\n            try {\n                Method valueOf = clazz.getMethod(\"valueOf\", String.class);\n                // Check if method is static, assume return type is compatible due to T and autoboxing\n                if (Modifier.isStatic(valueOf.getModifiers())) {\n                    @SuppressWarnings(\"unchecked\") // Assume valueOf returns T or compatible\n                    T result = (T) valueOf.invoke(null, str);\n                    return result;\n                }\n                // If valueOf exists but is not static, fall through to constructor attempt\n            } catch (NoSuchMethodException e) {\n                // valueOf(String) not found, ignore and try constructor below\n            } catch (IllegalAccessException e) {\n                 // Should not happen for public static method, but treat as failure\n                 throw new ParseException(\"Cannot invoke valueOf on Number class: \" + clazz.getName());\n            } catch (InvocationTargetException e) {\n                 // valueOf method threw an exception (e.g., NumberFormatException)\n                 Throwable cause = e.getCause();\n                 if (cause instanceof NumberFormatException) {\n                     // Specific message for number format issues\n                     throw new ParseException(\"Unable to parse '\" + str + \"' as a \" + clazz.getSimpleName() + \": \" + cause.getMessage());\n                 } else {\n                     // Other exceptions from valueOf\n                     throw new ParseException(\"Error invoking valueOf on Number class '\" + clazz.getName() + \"' with value '\" + str + \"': \" + cause.getMessage());\n                 }\n            }\n\n            // Attempt to use Constructor(String) as fallback (e.g., for BigDecimal, BigInteger)\n            try {\n                Constructor<T> constructor = clazz.getConstructor(String.class);\n                return constructor.newInstance(str);\n            } catch (NoSuchMethodException e1) {\n                // No valueOf(String) or Constructor(String) found for this Number type\n                throw new ParseException(\"Unsupported Number type: \" + clazz.getName() + \" (no suitable valueOf or constructor)\");\n            } catch (InstantiationException | IllegalAccessException e1) {\n                // Cannot instantiate using constructor\n                throw new ParseException(\"Cannot instantiate Number type: \" + clazz.getName());\n            } catch (InvocationTargetException e1) {\n                // Constructor threw an exception (e.g., NumberFormatException for BigInteger/BigDecimal)\n                Throwable cause = e1.getCause();\n                 // Handle common parsing exceptions from constructors\n                 if (cause instanceof NumberFormatException || cause instanceof ArithmeticException) {\n                     throw new ParseException(\"Unable to parse '\" + str + \"' as a \" + clazz.getSimpleName() + \": \" + cause.getMessage());\n                 } else {\n                    // Other exceptions from constructor\n                    throw new ParseException(\"Constructor failed for \" + clazz.getName() + \": \" + cause.getMessage());\n                 }\n            }\n        }\n        else // Type not handled by PatternOptionBuilder constants or as a Number subclass\n        {\n            // Return null for unhandled types, preserving original behavior for these cases.\n            return null;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}