{
    "generation": "    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            return (T) createObject(str);\n        }\n        // Use isAssignableFrom to handle Number and its subclasses (Integer, Long, etc.)\n        else if (Number.class.isAssignableFrom(clazz))\n        {\n            // Handle specific Number types directly to return correct type T\n            // and provide specific parsing logic / error messages.\n            try {\n                if (clazz == Long.class) {\n                    return (T) Long.valueOf(str);\n                } else if (clazz == Integer.class) {\n                    return (T) Integer.valueOf(str);\n                } else if (clazz == Short.class) {\n                    return (T) Short.valueOf(str);\n                } else if (clazz == Byte.class) {\n                    return (T) Byte.valueOf(str);\n                } else if (clazz == Float.class) {\n                    return (T) Float.valueOf(str);\n                } else if (clazz == Double.class) {\n                    return (T) Double.valueOf(str);\n                } else if (clazz == Number.class) { // Check for Number.class itself\n                    // If Number.class was explicitly requested (PatternOptionBuilder.NUMBER_VALUE)\n                    // use the generic createNumber method. May throw ParseException.\n                    return (T) createNumber(str);\n                }\n                // Otherwise, clazz is some other Number subclass (e.g., BigDecimal).\n                // Fall through to the final return null for unsupported types.\n            } catch (final NumberFormatException e) {\n                 // Catch NFE from Long.valueOf, Integer.valueOf, etc. and wrap in ParseException\n                throw new ParseException(\"Unable to parse '\" + str + \"' as a \" + clazz.getSimpleName());\n            }\n        }\n        // The original check for PatternOptionBuilder.NUMBER_VALUE is replaced by the block above.\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str); // May throw ParseException\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str); // May throw ParseException\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str); // Does not declare ParseException\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) // FileInputStream.class\n        {\n            return (T) openFile(str); // May throw ParseException\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz) // File[].class\n        {\n            return (T) createFiles(str); // Does not declare ParseException\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str); // May throw ParseException\n        }\n\n        // If none of the above conditions matched (e.g., unknown type, or unsupported Number subclass)\n        // return null as per the original logic's final else block.\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}