{
    "generation": "import org.apache.commons.cli.ParseException;\nimport org.apache.commons.cli.PatternOptionBuilder;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.Date;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Modifier;\n\n// Assume necessary helper methods like createObject, createNumber etc. exist elsewhere in the class.\n\n    /**\n     * Returns the <code>Object</code> of type <code>clazz</code>\n     * with the value of <code>str</code>.\n     *\n     * @param str the command line value\n     * @param clazz the type of argument\n     * @param <T> The type of object to create\n     * @return The instance of <code>clazz</code> initialised with\n     * the value of <code>str</code>.\n     * @throws ParseException if the value creation for the given class failed\n     */\n    @SuppressWarnings(\"unchecked\") // Casting is guarded by checks or inherent to T matching clazz\n    public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n    {\n        if (PatternOptionBuilder.STRING_VALUE == clazz)\n        {\n            // The cast is safe because T is String in this branch\n            return (T) str;\n        }\n        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n        {\n            // createObject returns Object; cast assumes T is Object or superclass.\n            // Note: Original behavior kept. Might be unsafe if T is more specific than Object.\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            // createNumber returns Number. Cast to T (Number) is safe.\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            // createDate returns Date. Cast to T (Date) is safe.\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            // createClass returns Class<?>. Cast to T (Class<?>) is safe.\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n             // createFile returns File. Cast to T (File) is safe.\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n             // This constant might be == FILE_VALUE. Assumes openFile performs necessary checks.\n             // openFile returns File. Cast to T (File) is safe.\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            // createFiles returns File[]. Cast to T (File[]) is safe.\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            // createURL returns URL. Cast to T (URL) is safe.\n            return (T) createURL(str);\n        }\n        else\n        {\n            // Handle general types using reflection: T(String) constructor or static T valueOf(String) method\n            T result = null;\n            Exception cause = null; // Store the root cause exception from reflection attempts\n\n            // 1. Try T(String) constructor\n            try {\n                Constructor<T> constructor = clazz.getConstructor(String.class);\n                result = constructor.newInstance(str);\n            } catch (NoSuchMethodException ignored) {\n                // Constructor T(String) not found, ok to proceed to valueOf\n            } catch (Exception e) {\n                cause = e; // Store exception from constructor attempt\n            }\n\n            // 2. If constructor didn't work or wasn't found, try static T valueOf(String)\n            if (result == null && cause == null) {\n                try {\n                    Method valueOfMethod = clazz.getMethod(\"valueOf\", String.class);\n                    // Check method is static and returns assignable type\n                    if (Modifier.isStatic(valueOfMethod.getModifiers()) &&\n                        clazz.isAssignableFrom(valueOfMethod.getReturnType())) {\n\n                        Object methodResult = valueOfMethod.invoke(null, str);\n\n                        // Defensive check on result type before casting\n                        if (clazz.isInstance(methodResult)) {\n                             result = clazz.cast(methodResult);\n                        } else {\n                             // Should not happen if isAssignableFrom passed, but signals an issue\n                             cause = new ClassCastException(\"valueOf method for \" + clazz.getName() + \" returned incompatible type: \" + (methodResult == null ? \"null\" : methodResult.getClass().getName()));\n                        }\n                    } else {\n                         // Found valueOf(String) but signature is wrong (e.g., not static). Treat as 'not found'.\n                         // The final 'else' block below will throw 'method not found'.\n                    }\n                } catch (NoSuchMethodException ignored) {\n                    // Method valueOf(String) not found either.\n                } catch (Exception e) {\n                     cause = e; // Store exception from valueOf attempt\n                }\n            }\n\n            // 3. Check results and throw ParseException if conversion failed or no method found\n            if (result != null) {\n                return result; // Success\n            } else {\n                String baseMsg = \"Unable to create an instance of type \" + clazz.getName() + \" from string '\" + str + \"'\";\n\n                // Unwrap InvocationTargetException to get the real cause\n                if (cause instanceof InvocationTargetException) {\n                    Throwable targetException = ((InvocationTargetException) cause).getTargetException();\n                    // Update 'cause' to the actual underlying exception/error if available\n                    if (targetException instanceof Exception) {\n                        cause = (Exception) targetException;\n                    } else if (targetException instanceof Error) {\n                         // Wrap Error in a RuntimeException to fit the ParseException constructor signature\n                         cause = new RuntimeException(\"Underlying error: \" + targetException.getMessage(), targetException);\n                    } else if (targetException != null) {\n                         // Wrap other Throwables\n                         cause = new RuntimeException(\"Underlying throwable: \" + targetException.getMessage(), targetException);\n                    }\n                    // If targetException is null, keep original InvocationTargetException details by falling through\n                }\n\n                // Create the final ParseException with an informative message\n                if (cause instanceof NumberFormatException) {\n                    // Provide a specific message for number format issues\n                    throw new ParseException(baseMsg + \". Reason: Invalid number format.\");\n                } else if (cause != null) {\n                    // Use the message from the (potentially unwrapped) cause\n                    String reason = cause.getMessage() != null ? cause.getMessage() : cause.getClass().getSimpleName();\n                    throw new ParseException(baseMsg + \". Reason: \" + reason, cause);\n                } else {\n                    // If 'cause' is still null, it means neither T(String) nor static T valueOf(String) was found/suitable\n                    throw new ParseException(baseMsg + \". Reason: No suitable public constructor T(String) or static factory method T valueOf(String) found.\");\n                }\n            }\n        }\n    }\n\n    // Dummy helper methods for context (actual implementation exists elsewhere in the original class)\n    private static Object createObject(String s) throws ParseException { throw new UnsupportedOperationException(\"Helper method not implemented in provided snippet\"); }\n    private static Number createNumber(String s) throws ParseException {\n        try {\n            // Simplified implementation based on common patterns\n            if (s.contains(\".\")) {\n                return Double.valueOf(s);\n            }\n            return Long.valueOf(s);\n        } catch (NumberFormatException e) {\n            throw new ParseException(\"Unable to parse number: \" + s);\n        }\n    }\n    private static Date createDate(String s) throws ParseException { throw new UnsupportedOperationException(\"Helper method not implemented in provided snippet\"); }\n    private static Class<?> createClass(String s) throws ParseException { throw new UnsupportedOperationException(\"Helper method not implemented in provided snippet\"); }\n    private static File createFile(String s) throws ParseException { return new File(s); } // Simple example\n    private static File openFile(String s) throws ParseException { throw new UnsupportedOperationException(\"Helper method not implemented in provided snippet\"); }\n    private static File[] createFiles(String s) throws ParseException { throw new UnsupportedOperationException(\"Helper method not implemented in provided snippet\"); }\n    private static URL createURL(String s) throws ParseException { throw new UnsupportedOperationException(\"Helper method not implemented in provided snippet\"); }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}