{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        //creator properties will be removed from regular list of properties in the end, based on name\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        // 17-Aug-2017, tatu: [databind#1728] Need to honor Merge requirement Accumulated value from ClassIntrospector.Basic\n        // TODO: rework ClassIntrospector.Basic.findPropertyIgnorals to use ConfigOverride\n        // instead if / in addition to JsonIgnoreProperties.Value\n        // ignorals = beanDesc.findPropertyIgnorals();\n\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n\n        // Implicit ones via @JsonIgnore and equivalent?\n        // Implement changes suggested by [databind#1595], wherein we only consider implicitly ignored\n        // properties after explicit ones and any setter.\n\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // (because we don't know if that could be overridden)\n\n        // Nor should we add any names explicitly defined with @JsonProperty: assumption\n        // is that @JsonIgnore should be used, NOT annotation on non-visible setter/field.\n        // Let's just collect explicitly defined ones from list of all properties:\n\n        // 13-Nov-2015, tatu: As per [databind#999] let's also consider @JsonIgnore applied\n        //    to getter, ignorable for serialization. For deserialization, however, we\n        //    should NOT ignore properties that have visible setters... so, wait until\n        //    we have filtered out all viable property definitions.\n\n        // 15-Jun-2020, tatu: As per [databind#2722], should take into account possibility\n        //   of explicit ignoral of a Creator property. But for that, need to combine\n        //   ignoral information first\n        Map<String, BeanPropertyDefinition> propMap = new LinkedHashMap<>();\n        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n            propMap.put(propDef.getName(), propDef);\n        }\n        // May need to refine `ignored` based on explicit definitions\n        {\n            Collection<String> ignoredByName = beanDesc.getIgnoredPropertyNames();\n            if (ignoredByName != null) {\n                for (String propName : ignoredByName) {\n                    // 03-Feb-2017, tatu: As per [databind#1595] do not block explicit property\n                    //    (which would be blockable via @JsonIgnoreProperties)\n                    if (!propMap.containsKey(propName)) {\n                        builder.addIgnorable(propName);\n                    }\n                }\n            }\n        }\n\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        // 16-Aug-2017, tatu: [databind#1728] needs to be done earlier, so that\n        //   we know not to try to use implicitly ignorable props.\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    // 15-Jun-2020, tatu: [databind#2722]: Was creator property ignored?\n                    //    Need to check this early, before reporting an error.\n                    if (!ignored.contains(name)) {\n                        List<String> n = new ArrayList<>();\n                        for (SettableBeanProperty cp : creatorProps) {\n                            n.add(cp.getName());\n                        }\n                        ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                                \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                                name, n);\n                    }\n                    // otherwise ignored, just skip\n                    continue;\n                }\n                // If we have both Creator Property and regular Setter, merge...\n                if (prop != null) {\n                    // 19-Oct-2016, tatu: Let's make default SettableBeanProperty support fallback setter\n                    //    iff its \"concrete\" type is CreatorProperty\n                    // Note: since 2.12, need explicit cast here:\n                    cprop.setFallbackSetter((SettableBeanProperty)prop);\n                }\n                // Type compatibility check? No, creator property already constructed...\n                // Except... need to also ensure annotations are merged. Let's not worry quite yet\n\n                prop = cprop;\n                // Add to builder? Yes. Drop from list of creator properties? Yes.\n                builder.addCreatorProperty(cprop);\n                // And remove from the list of remaining props\n                // 23-Nov-2017, tatu: Need to do this based on index, not value:\n                //   important as we do identity equality check NOT equals()\n                for (int i = 0; i < creatorProps.length; ++i) {\n                    if (creatorProps[i] == prop) {\n                        creatorProps[i] = null; // need to mark as used\n                        break;\n                    }\n                }\n                continue; // processing of this property complete\n            }\n\n            // No Creator property? Add if we found regular property.\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}