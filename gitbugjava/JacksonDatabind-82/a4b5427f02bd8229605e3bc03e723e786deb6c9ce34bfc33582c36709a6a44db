{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        // 11-Aug-2019, tatu: For [databind#2411] need to ensure we don't try to instantiate\n        //   abstract type; only need Creator properties if so.\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            // [databind#3017]: even if default ignorals NOT specified, need to check class level\n            // one -- may be specified with just `ignoreUnknown=true`\n            JsonIgnoreProperties.Value ignoralsForClass = ctxt.getAnnotationIntrospector()\n                    .findPropertyIgnorals(beanDesc.getClassInfo());\n            if (ignoralsForClass != null) {\n                builder.setIgnoreUnknownProperties(ignoralsForClass.getIgnoreUnknown());\n            }\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMember anySetter = beanDesc.findAnySetterAccessor();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: [databind#1595]: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        // 15-Jun-2017, tatu: As per [databind#1595], need to consider this IN ADDITION to explicit ones...\n        //    Also note that we do NOT want to include things ignored via `@JsonIgnoreProperties` etc, just\n        //    ones indicated by `@JsonIgnore` (or equivalent)\n\n\n        // But... how about implicit ignores? Difference is that we only ignore if there is\n        // no AnySetter - any setter would presumably be used instead.\n        // 15-Sep-2017, tatu: Actually, as per [databind#1595], we do need to add these always,\n        //   but we can only do that easily BEFORE filtering...\n        // 04-Mar-2019, tatu: Ok. Turns out this is wrong. Ignored properties are Ignored. It is\n        //    AnySetter that gets lower precedence. Ergo, MUST add ignorable properties regardless\n        //    of AnySetter existence.\n\n        // UPDATE, 20-May-2020, tatu: [databind#1595] is bit of a mess but need to ensure\n        //   that we do not add anything here; rather, handle via property introspection\n        /*\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    // 27-Apr-2016, tatu: Actually, should NOT add these here, seems like; relevant\n                    //   in cases where there is similarly named field AND setter (or getter) -- may need to revisit\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        */\n\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            // First: potential setter methods?\n            if (propDef.hasSetter()) {\n                AnnotatedMethod setter = propDef.getSetter();\n                // For [databind#1595], check for ignored setter: if so, need to ignore property\n                if (propDef.isExplicitlyIgnored()) {\n                    builder.addIgnorable(propDef.getName());\n                    continue;\n                }\n                JavaType propertyType = setter.getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                AnnotatedField field = propDef.getField();\n                 // For [databind#1595], check for ignored field: if so, need to ignore property\n                if (propDef.isExplicitlyIgnored()) {\n                    builder.addIgnorable(propDef.getName());\n                    continue;\n                }\n                JavaType propertyType = field.getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else {\n                 // 18-Nov-2016, tatu: For [databind#1391], need to skip this if there's a creator property\n                 //    (or, I guess, make getter work as fallback? For now, skip)\n                 // 29-Jul-2019, tatu: As per [databind#2398], seems like we may want to reconsider...\n                 //    ... but maybe not. Let's leave as is for now.\n                 if (useGettersAsSetters && propDef.hasGetter() && !propDef.hasConstructorParameter()) {\n                    /* May also need to consider getters\n                     * for Map/Collection properties; but with lowest precedence\n                     */\n                    AnnotatedMethod getter = propDef.getGetter();\n                    // should only consider Collections and Maps, for now?\n                    Class<?> rawPropertyType = getter.getRawType();\n                    if (Collection.class.isAssignableFrom(rawPropertyType)\n                            || Map.class.isAssignableFrom(rawPropertyType)) {\n                         // For [databind#1595], need to ensure we do not try to use ignored getter as setter\n                         if (!propDef.isExplicitlyIgnored()) {\n                             prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                         }\n                    }\n                 }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    // 13-Oct-2016, tatu: Let's add little bit more diagnostics around this failure\n                    return ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s). Check definition of properties\",\n                            name, n);\n                }\n                // For [databind#1595], check for ignored constructor parameter: if so, need to ignore property\n                if (propDef.isExplicitlyIgnored()) {\n                    builder.addIgnorable(propDef.getName());\n                    if (prop != null) { // Property based one exists? Add ignorable too? No?\n                        builder.addIgnorable(prop.getName());\n                    }\n                    continue;\n                }\n\n                if (prop != null) {\n                    // If there is a property-based setter/field, it takes precedence and creator is\n                    // linked as fallback; otherwise creator property is used as is.\n                    // Need to ensure views are properly set in both cases, however.\n                    // 14-Sep-2018, tatu: Should ideally combine view information etc but...\n                    //    for now just copy from property-based one\n                    // 20-May-2020, tatu: [databind#1328] indicates we probably should NOT do the following\n                    //    part; may be revisited in future. But for now, comment out:\n                    // cprop.setViews(prop.getViews());\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                // not added via main mechanism (except if has fallback)\n                continue;\n            }\n\n            if (prop != null) {\n                // [databind#2302]: If views specified, ensure alignment\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}