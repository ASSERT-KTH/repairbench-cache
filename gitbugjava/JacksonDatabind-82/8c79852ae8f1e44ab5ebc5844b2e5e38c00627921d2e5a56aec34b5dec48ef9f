{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        // 25-Sep-2014, tatu: No point in finding creator parameters for abstract types\n        //   (since they are never used anyway)\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        // But... maybe explicit field is separate?\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n\n        // [databind#1595]: Actually, ignore an explicitJsonProperty\n        // for properties that do have explicitly annotated setter.\n\n        /* Maybe this logic could be simplified? Still, let's recognize\n         * possibility of implicit vs explicit ignoral.\n         * 18-Nov-2016, tatu: As per [databind#1595], need to ensure we don't ignore\n         *   properties that have explicit markers for non-ignored status.\n         *  Also: see note below on precedence; goal is basically that we MUST\n         *  NOT include implicitly ignored properties in `ignored` set\n         *\n         * 08-Jul-2019, tatu: Note: this does NOT add entries in `ignored` set, which only\n         *    contains explicitly ignored properties (@JsonIgnoreProperties)\n         *    Conversely, `getIgnoredPropertyNames()` HAS traditionally included implicitly\n         *    ignored properties (@JsonIgnore).\n         *    So... I think logic is sound, relates to handling of possibly unknown properties.\n         */\n        Collection<String> ignoredProcs = beanDesc.getIgnoredPropertyNames();\n        if (ignoredProcs != null) {\n             for (String propName : ignoredProcs) {\n                 // [databind#1595] Need to check explicitly annotated props\n                  builder.addIgnorable(propName);\n             }\n        }\n\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             *\n             * 18-Nov-2016, tatu: ... and make sure we don't create SettableBeanProperty\n             *   for ignored properties. Although... possibly problematic, this, need\n             *   to reconsider? For now, let's do simple check\n             */\n            // First: if explicitly ignored, don't build setter\n            // 08-Jul-2019, tatu: Looks like this was added for [databind#1595]. But isn't\n            //   it potentially dangerous? What is `ignored` (set)? Oh, explicitly ignored\n            //   things from `@JsonIgnoreProperties`\n            if (ignored.contains(propDef.getName())) {\n                continue;\n            }\n            // [databind#1595] This check is bit simplified, not 100% sure it's needed...\n            //  but basically, should not create property for something that is implicitly\n            //  ignored, unless it is Creater property?\n            //\n            // 08-Jul-2019, tatu: Hmm. Looks like original attempt for #1595? Trying to avoid\n            //   adding `prop` if `propName` is in `ignoredProps` (implicitly ignored)\n            //   Should probably instead only check for explicit `isExplicitlyIncluded()`?\n            //   Actually, this is probably wrong: implicit ignoral should not block\n            //   explicit acceptance. Commenting out for now\n            /*\n            if (!propDef.isExplicitlyIncluded() && ignoredProcs.contains(propDef.getName())) {\n                 if (!propDef.hasConstructorParameter()) {\n                     // May need to consider CreatorProperty specially?\n                     continue;\n                 }\n            }\n            */\n\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // must check ConstructParameter AFTER others, because of [databind#318]\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        // Must have same name and type...\n                        // Important: must check type compatibility, not equality,\n                        // to play nice with generics etc.\n                        // 24-Aug-2017, tatu: But as per [databind#1726], cannot check this early\n                        //    because actual type not known for creator params.\n\n//                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)\n//                                && cp.getMember().getParameter( ((CreatorProperty) cp).getCreatorIndex() ).getRawType()\n//                                == propDef.getConstructorParameter().getRawType()) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    // 15-Mar-2017, tatu: For [databind#1551], need bit more info...\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue; // Implicitly ignored by not being added to builder\n                }\n                if (prop != null) { // If we had regular setter/field, need to link\n                    cprop.setFallbackSetter(prop);\n                }\n                // [databind#1391]: make sure we prevent addition later\n                builder.addCreatorProperty(cprop); // uses addCreatorProperty -- different from addProperty\n                /* 24-Mar-2017, tatu: Note that we DO NOT want to add this to main property list\n                 *   because it is separately handled. So need to...\n                 */\n                 continue; // Skip normal handling, already done!\n            }\n\n            // If we get this far, we have a property of one kind or another,\n            // add to builder if not yet ignored or blocked.\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}