{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.rhino.Node;\n// Removed Token import, assume Node types like isAssign are sufficient\n\nimport java.util.List;\nimport java.util.Set;\n\n// NOTE: This code includes an assumed helper function `isVarOrAssignExprLhs`\n// based on the original buggy code's usage. Its correct implementation is\n// important for the fix.\n\n    /**\n     * Checks if an object literal assignment can be safely inlined.\n     * An object literal assignment (e.g., `var x = {a: 1};` or `x = {a: 1}`)\n     * can be inlined if the variable `x` is only used in the following ways:\n     * 1. The assignment itself (var x = {...} or x = {...}).\n     * 2. Property assignments (`x.prop = ...`), where prop is not computed.\n     * 3. Property reads (`... x.prop ...`) *if* `prop` was defined in the\n     *    literal OR is assigned elsewhere (like case 2), and prop is not computed.\n     *\n     * It cannot be inlined if:\n     * - The variable (`x`) is used directly (`f(x)`, `y = x`).\n     * - A method is called on it (`x.meth()`).\n     * - A property is read that was not defined in the literal and never assigned.\n     * - The literal contains getters/setters or computed properties.\n     * - Property assignments or reads use computed properties (`x[prop] = ...`, `... x[prop] ...`).\n     * - The literal assignment is self-referential (e.g. `x = {a: x.b}`).\n     * - There are multiple distinct object literal assignments to the same variable.\n     * - There is an assignment to something other than an object literal (`x = 1`).\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      Node objLitNode = null;\n      Reference objLitAssignRef = null;\n      boolean hasVarDeclaration = false; // Track if 'var x;' seen\n\n      // Pass 1: Find the unique OBJECTLIT assignment. Check for non-literal assigns.\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        if (isVarOrAssignExprLhs(name)) {\n          if (parent.isVar()) {\n            hasVarDeclaration = true;\n          }\n          Node val = ref.getAssignedValue();\n          if (val != null) { // Assignment with value (var x = val or x = val)\n             if (!val.isObjectLit()) return false; // Assigned non-object literal\n             // Allow multiple references pointing to the *same* literal node,\n             // e.g. from complex assignments, but not different literals.\n             if (objLitNode != null && objLitNode != val) return false;\n             objLitNode = val;\n             objLitAssignRef = ref; // Keep track of the reference for the objlit assign\n          }\n          // else: 'var x;' or potentially x=... w/o value (unlikely) - OK so far\n        }\n      }\n\n      // Must have found exactly one object literal assignment to be eligible,\n      // unless it was just `var x;` and x was never used or assigned otherwise.\n      if (objLitNode == null) {\n         // Check if it was just 'var x;' declaration(s) and no other usage.\n         boolean isOnlyDeclaration = true;\n         if (!hasVarDeclaration && !refs.isEmpty()) {\n             // Has references but no var declaration or assignment found? Invalid use case.\n             isOnlyDeclaration = false;\n         } else if (!refs.isEmpty()) {\n             // Verify *all* references are part of 'var' declarations\n             for (Reference ref : refs) {\n                 // Allow VAR parent, but disallow any other usage if no objlit found\n                 if (!ref.getParent().isVar()) {\n                     isOnlyDeclaration = false;\n                     break;\n                 }\n             }\n         }\n         // Inline (as no-op) only if it was just 'var x;' and never used otherwise.\n         return isOnlyDeclaration;\n      }\n\n      // Check for disallowed features in the identified literal\n      for (Node keyNode = objLitNode.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n        if (keyNode.isGetterDef() || keyNode.isSetterDef() || keyNode.isComputedProp()) {\n          return false; // Getters, setters, and computed properties in the literal are disallowed.\n        }\n      }\n\n      // Check for self-referential assignments within the literal (e.g., x = {a: x.b})\n      for (Node keyNode = objLitNode.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n          // Keys are STRING_KEY, GETTER_DEF, SETTER_DEF, MEMBER_FUNCTION_DEF etc.\n          // We already checked GETTER/SETTER/COMPUTED. MEMBER_FUNCTION_DEF is implicitly\n          // handled because accessing the function property later will fail checks.\n          if (!keyNode.isStringKey()) continue; // Focus on simple string keys\n          Node childVal = keyNode.getLastChild(); // Value node for the key\n          if (childVal == null) continue; // Should not happen for string key\n\n          // Check if any *other* reference to the object variable itself exists within this value node.\n          for (Reference t : refs) {\n              // Don't check the main assignment ref for self-reference within its own value\n              if (t == objLitAssignRef) continue;\n              Node refNode = t.getNode();\n              // isDescendant checks if refNode is anywhere underneath childVal in the AST\n              if (NodeUtil.isDescendant(childVal, refNode)) {\n                   return false; // Found self-reference like x = {a: x.b}\n              }\n          }\n      }\n\n\n      // Pass 2: Check all references for validity based on usage context.\n      // Collect keys defined in the literal and keys assigned later via x.key = ...\n      Set<String> definedKeys = Sets.newHashSet();\n      Set<String> assignedKeys = Sets.newHashSet(); // Track keys assigned via x.key = ...\n\n      // Populate definedKeys from the literal (already checked for computed/get/set)\n      for (Node keyNode = objLitNode.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n         definedKeys.add(keyNode.getString());\n      }\n\n      // Pre-scan to populate assignedKeys and check for computed property assignments\n      for (Reference ref : refs) {\n          Node parent = ref.getParent();\n          Node gramps = ref.getGrandparent();\n           // Check for x.prop = ... (assignment where parent is GETPROP)\n           if (parent.isGetProp() && gramps.isAssign() && gramps.getFirstChild() == parent) {\n               Node propNode = parent.getLastChild();\n               if (propNode.isComputedProp()) return false; // Assignment to computed property like x[prop] = ...\n               assignedKeys.add(propNode.getString());\n           }\n      }\n\n\n      // Check each reference's usage context\n      for (Reference ref : refs) {\n        // Skip the main object literal assignment reference itself, it's implicitly OK.\n        if (ref == objLitAssignRef) {\n          continue;\n        }\n\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        if (parent.isGetProp()) {\n          // Case: x.prop ... (Property access)\n          Node propNode = parent.getLastChild();\n          if (propNode.isComputedProp()) return false; // Access via computed property x[prop]\n          String propName = propNode.getString();\n\n          // Disallow x.prop() - method call\n          if (gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Allow x.prop = y (assignment to property) - already checked in pre-scan, just continue\n          if (gramps.isAssign() && gramps.getFirstChild() == parent) {\n            continue; // This assignment usage is OK.\n          }\n\n          // Must be a read access: f(x.prop), y = x.prop, etc.\n          // Allow read only if property is defined in literal OR assigned elsewhere.\n          if (!definedKeys.contains(propName) && !assignedKeys.contains(propName)) {\n             // Property read was not defined in literal and never assigned via x.prop=... Disallow.\n             return false;\n          }\n          // Read is OK (defined in literal or assigned elsewhere).\n          continue;\n\n        } else if (isVarOrAssignExprLhs(name)) {\n          // Another assignment (x = ...) or var declaration (var x;)\n          // Pass 1 already found the unique objLit assign or handled var decls.\n          // If this is 'var x;' without assignment, tolerate it (could be redundant decl).\n           if (parent.isVar() && ref.getAssignedValue() == null) {\n               continue; // OK extra 'var x;' decl.\n           }\n           // Any other assignment (x=y, x=1, x={...} again) is disallowed because\n           // Pass 1 determined there was only one valid objLit assignment.\n           return false;\n\n        } else {\n          // Direct usage: f(x), y = x, x || y etc. (parent is not GETPROP or VAR/ASSIGN LHS)\n          return false;\n        }\n      }\n\n      // All references checked and deemed safe.\n      return true;\n    }\n\n    /**\n     * Helper function (assumed from original code context).\n     * Checks if the given NAME node is the left-hand side of an assignment\n     * or part of a VAR declaration.\n     */\n    private boolean isVarOrAssignExprLhs(Node name) {\n        Node parent = name.getParent();\n        // Check if name is the Lhs of an assignment or var declaration\n        return (parent.isAssign() && parent.getFirstChild() == name)\n               || parent.isVar();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}