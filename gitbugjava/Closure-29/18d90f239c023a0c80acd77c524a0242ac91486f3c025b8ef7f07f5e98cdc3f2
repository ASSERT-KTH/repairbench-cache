{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     *\n     * Check determines if a variable is suitable for inlining based on\n     * how it's referenced. It ensures the variable is only assigned\n     * object literals and not used in ways that would break inlining.\n     * Property accesses (x.prop) are allowed here but checked later for validity.\n     *\n     * @param refs The list of references to the variable.\n     * @return Whether the variable appears suitable for inlining.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean foundObjectLiteralAssign = false; // Track if we found any suitable assignment\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = parent.getParent();\n\n        if (parent.isGetProp()) {\n          // Handle property accesses: x.prop, x.prop = ..., x.prop()\n          Preconditions.checkState(parent.getFirstChild() == name);\n\n          // Disallow calls like x.prop() where the object might be the 'this' value.\n          if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n          // Allow other GETPROPs (like reading ... x.prop ... or assigning x.prop = ...)\n          // The validity of the specific property access (e.g., if 'prop'\n          // is defined in the literal) is checked later in the pass during the\n          // actual inlining process (maybePrepareObjectLiteral).\n          // This reference itself doesn't disqualify the variable at this stage.\n          continue;\n\n        } else if (isVarOrAssignExprLhs(name)) {\n          // Handle VAR declarations and assignments: var x; var x = ...; x = ...;\n          Node val = ref.getAssignedValue();\n          if (val == null) {\n            // A var declaration with no assignment ('var x;'). This is allowed.\n            continue;\n          }\n\n          // If it's an assignment, require it to be an object literal.\n          if (!val.isObjectLit()) {\n            // Assigned something other than an object literal (e.g., x = 1, x = foo()).\n            // This variable cannot be inlined as an object.\n            return false;\n          }\n\n          // Check the object literal itself for unsupported features.\n\n          // Check for ES5 getters/setters or self-references.\n          for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n              // ES5 get/set not supported by this pass.\n              return false;\n            }\n\n            // Original self-reference check logic:\n            // Disallow potentially problematic self-references like x = {a: x.b}.\n            // TODO(b/116204989): This check is currently strict and disallows safe,\n            // orderable assignments like x = {a: 1, b: x.a}.\n            if (child.isStringKey()) { // Check only string keys for values\n                Node childVal = child.getLastChild(); // Value node for the string key\n                // Check if childVal's subtree contains a reference 'x.something'\n                for (Reference t : refs) {\n                   // Check if this reference 't' is for the variable 'name'\n                   if (t.getNode() == name) {\n                       Node refParent = t.getParent(); // e.g., GETPROP in x.b\n                       // Traverse up from the reference's parent (refParent)\n                       while (refParent != null && !NodeUtil.isStatementBlock(refParent)) {\n                           if (refParent == childVal) {\n                               // Found self-reference: the value node ('childVal')\n                               // is an ancestor of the reference's parent ('refParent').\n                               // This implies the value expression contains 'x.something'.\n                               return false;\n                           }\n                           // Optimization: stop searching upwards if we go above the object literal node itself.\n                           // If refParent reaches val, childVal cannot be an ancestor.\n                           if (refParent == val) {\n                               break;\n                           }\n                           refParent = refParent.getParent();\n                       }\n                   }\n                }\n            }\n          }\n\n\n          // If we passed all checks for this object literal assignment.\n          foundObjectLiteralAssign = true;\n\n        } else {\n          // Any other use of the variable name itself (e.g., f(x), x + 1, return x)\n          // prevents inlining.\n          return false;\n        }\n      }\n\n      // To be inlinable, there must have been at least one valid object literal assignment\n      // found, and no disqualifying uses encountered during the loop.\n      return foundObjectLiteralAssign;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}