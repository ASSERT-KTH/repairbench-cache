{
    "generation": "\t/**\n\t * Move the given class to his grandparent (either class or package). The given {@code clazz} should be inner class.\n\t */\n\tprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n\t\t// Original parent of the class to be moved\n\t\tJDefinedClass parent = (JDefinedClass) clazz.parentContainer();\n\t\t// Target container for the class (grandparent)\n\t\tJClassContainer grandParent = parent.parentContainer();\n\n\t\t// Store the original simple name of the class. This is needed to remove it\n\t\t// from its original parent's list of classes, as the class's name might\n\t\t// be changed later if there's a collision in the grandparent.\n\t\tString originalSimpleName = clazz.name();\n\n\t\t// Map of classes in the new container (grandparent)\n\t\tMap<String, JDefinedClass> grandParentClasses;\n\n\t\t// FIXME: Pending https://java.net/jira/browse/JAXB-957\n\t\tif (grandParent.isClass()) {\n\t\t\t// Grandparent is a class, so clazz will become an inner class of grandParentClass\n\t\t\tJDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to class \" + grandParentClass.fullName());\n\n\t\t\tgrandParentClasses = getPrivateField(grandParentClass, \"classes\");\n\t\t}\n\t\telse {\n\t\t\t// Grandparent is a package, so clazz will become a top-level class in grandParentPackage\n\t\t\tJPackage grandParentPackage = (JPackage) grandParent;\n\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to package \" + grandParentPackage.name());\n\n\t\t\tgrandParentClasses = getPrivateField(grandParentPackage, \"classes\");\n\n\t\t\t// When moving to a package to become a top-level class, the 'static' modifier\n\t\t\t// (if it was a static inner class) is no longer applicable in the same way.\n\t\t\t// Top-level classes are not declared 'static'.\n\t\t\t// This ensures the 'static' keyword is removed from the class declaration.\n\t\t\tsetPrivateField(clazz.mods(), \"mods\", Integer.valueOf(clazz.mods().getValue() & ~JMod.STATIC));\n\n\t\t\t// Specific logic for updating schema component information\n\t\t\tfor (ClassOutline classOutline : outline.getClasses()) {\n\t\t\t\tif (classOutline.implClass == clazz) {\n\t\t\t\t\tXSComponent sc = classOutline.target.getSchemaComponent();\n\n\t\t\t\t\t// FIXME: Inner class is always a local declaration.\n\t\t\t\t\tassert (sc instanceof XSDeclaration && ((XSDeclaration) sc).isLocal());\n\n\t\t\t\t\tsetPrivateField(sc, \"anonymous\", Boolean.FALSE); // Mark as no longer anonymous/local\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle potential name collisions in the grandparent container.\n\t\t// If a class with the same simple name already exists in the grandparent,\n\t\t// rename the class being moved to avoid collision. A common strategy is prefixing\n\t\t// with the original parent's name.\n\t\t// Note: clazz.name() here refers to the simple name.\n\t\tif (grandParentClasses.containsKey(clazz.name())) {\n\t\t\tString newName = parent.name() + clazz.name(); // Proposed new simple name\n\t\t\twriteSummary(\"\\tRenaming class \" + clazz.fullName() + \" to class \" + newName);\n\t\t\tsetPrivateField(clazz, \"name\", newName); // clazz.name() will now return the new name\n\t\t}\n\n\t\t// Add the class (possibly with its new name) to the grandparent's list of classes.\n\t\t// clazz.name() here is the simple name, potentially updated by collision handling.\n\t\tgrandParentClasses.put(clazz.name(), clazz);\n\n\t\t// Update the class's 'outer' reference to point to its new container (the grandparent).\n\t\t// This effectively changes its parentage in the JCodeModel structure.\n\t\tsetPrivateField(clazz, \"outer\", grandParent);\n\n\t\t// --- BUG FIX: Remove the class from its original parent's list of inner classes ---\n\t\t// 'parent' is the JDefinedClass that was originally clazz's container.\n\t\t// 'originalSimpleName' is the name clazz had when it was an inner class of 'parent'.\n\t\t// We must use this original name because clazz.name() might have been changed above.\n\t\tMap<String, JDefinedClass> originalParentClasses = getPrivateField(parent, \"classes\");\n\t\tif (originalParentClasses != null) {\n\t\t\toriginalParentClasses.remove(originalSimpleName);\n\t\t}\n\t\t// --- END OF BUG FIX ---\n\t}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}