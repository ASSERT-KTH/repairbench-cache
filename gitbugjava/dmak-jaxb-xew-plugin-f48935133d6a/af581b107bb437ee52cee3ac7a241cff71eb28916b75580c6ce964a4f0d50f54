{
    "generation": "import com.sun.codemodel.JClassContainer;\nimport com.sun.codemodel.JDefinedClass;\nimport com.sun.codemodel.JMod;\nimport com.sun.codemodel.JPackage;\nimport com.sun.tools.xjc.model.ClassOutline;\nimport com.sun.tools.xjc.outline.Outline;\nimport com.sun.xml.xsom.XSComponent;\nimport com.sun.xml.xsom.XSDeclaration;\n\nimport java.util.Map;\n\n// Assuming getPrivateField, setPrivateField, and writeSummary are utility methods available in the class scope.\n\n\t/**\n\t * Move the given class to his grandparent (either class or package). The given {@code clazz} should be inner class.\n\t */\n\tprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n\t\t// Get parent and grandparent containers\n\t\tJDefinedClass parent = (JDefinedClass) clazz.parentContainer();\n\t\tJClassContainer grandParent = parent.parentContainer();\n\t\tMap<String, JDefinedClass> grandParentClasses; // Map for the grandparent's classes\n\n\t\t// --- Step 1: Remove class from original parent's internal map ---\n\t\t// Get parent's classes map using reflection\n\t\tMap<String, JDefinedClass> parentClasses = getPrivateField(parent, \"classes\");\n\t\t// Remove the class using its current name (before potential rename)\n\t\tif (parentClasses != null) {\n\t\t\tif (parentClasses.remove(clazz.name()) != null) {\n\t\t\t\twriteSummary(\"\\tDetached inner class \" + clazz.fullName() + \" from parent \" + parent.fullName());\n\t\t\t} else {\n\t\t\t\t// This might happen if the class wasn't properly in the parent's map? Log a warning.\n\t\t\t\twriteSummary(\"\\tWARN: Class \" + clazz.name() + \" not found in parent \" + parent.fullName() + \"'s internal map for removal.\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Log a warning/error as this is unexpected if parent is a JDefinedClass\n\t\t\twriteSummary(\"\\tWARN: Could not get 'classes' map from parent class \" + parent.fullName());\n\t\t}\n\n\t\t// --- Step 2: Determine grandparent type and get its class map ---\n\t\t// Also perform specific adjustments based on target container type\n\t\t// FIXME: Pending https://java.net/jira/browse/JAXB-957\n\t\tif (grandParent.isClass()) {\n\t\t\t// Grandparent is a Class\n\t\t\tJDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" into outer class \" + grandParentClass.fullName());\n\t\t\tgrandParentClasses = getPrivateField(grandParentClass, \"classes\");\n\t\t}\n\t\telse {\n\t\t\t// Grandparent is a Package\n\t\t\tJPackage grandParentPackage = (JPackage) grandParent;\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" into package \" + grandParentPackage.name());\n\t\t\tgrandParentClasses = getPrivateField(grandParentPackage, \"classes\");\n\n\t\t\t// When moving to a package, the class becomes a top-level class.\n\t\t\t// Ensure the 'static' modifier (relevant for nested classes) is removed.\n\t\t\tif ((clazz.mods().getValue() & JMod.STATIC) != 0) {\n\t\t\t\twriteSummary(\"\\tRemoving static modifier from class \" + clazz.name() + \" as it moves to package scope.\");\n\t\t\t\tsetPrivateField(clazz.mods(), \"mods\", Integer.valueOf(clazz.mods().getValue() & ~JMod.STATIC));\n\t\t\t}\n\n\t\t\t// Update associated schema component metadata if necessary\n\t\t\tfor (ClassOutline classOutline : outline.getClasses()) {\n\t\t\t\tif (classOutline.implClass == clazz) {\n\t\t\t\t\tXSComponent sc = classOutline.target.getSchemaComponent();\n\t\t\t\t\t// Check if it's a local declaration (as expected for inner classes)\n\t\t\t\t\tif (sc instanceof XSDeclaration && ((XSDeclaration) sc).isLocal()) {\n\t\t\t\t\t\t// Mark it as non-anonymous as it's moving to a potentially top-level scope\n\t\t\t\t\t\t// Note: Using reflection implies this field isn't publicly mutable.\n\t\t\t\t\t\tsetPrivateField(sc, \"anonymous\", Boolean.FALSE);\n\t\t\t\t\t\twriteSummary(\"\\tMarked schema component for \" + clazz.name() + \" as non-anonymous.\");\n\t\t\t\t\t} else {\n                         // Log if the assumption about the schema component is wrong\n                         writeSummary(\"\\tWARN: Schema component for \" + clazz.name() + \" (\" + (sc!=null?sc.getClass().getName():\"null\") + \") was not a local XSDeclaration as expected.\");\n                    }\n\t\t\t\t\tbreak; // Assume only one ClassOutline matches\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        // Check if we successfully got the grandparent's class map\n        if (grandParentClasses == null) {\n             writeSummary(\"\\tERROR: Could not get 'classes' map from grandparent container: \" + grandParent.toString() + \". Aborting move.\");\n             // Abort the move. Ideally, we'd revert the removal from the parent, but that's complex.\n             // Failing here might leave the model inconsistent, but proceeding would cause NPEs.\n             return;\n        }\n\n\n\t\t// --- Step 3: Handle potential name collision in grandparent ---\n\t\tString originalName = clazz.name();\n\t\tString finalName = originalName;\n\t\tif (grandParentClasses.containsKey(originalName)) {\n\t\t\t// Collision detected: Rename the class by prepending the original parent's name\n\t\t\tfinalName = parent.name() + originalName;\n\t\t\twriteSummary(\"\\tName collision in \" + (grandParent.isClass() ? \"class \" + ((JDefinedClass)grandParent).fullName() : \"package \" + ((JPackage)grandParent).name())\n                    + \". Renaming class \" + originalName + \" to \" + finalName);\n\t\t\tsetPrivateField(clazz, \"name\", finalName);\n\t\t}\n\n\t\t// --- Step 4: Add the class (with final name) to the grandparent's map ---\n\t\tgrandParentClasses.put(finalName, clazz);\n        writeSummary(\"\\tAdded class \" + finalName + \" to \" + (grandParent.isClass() ? \"class \" + ((JDefinedClass)grandParent).fullName() : \"package \" + ((JPackage)grandParent).name()) + \"'s map.\");\n\n\n\t\t// --- Step 5: Update the class's 'outer' reference to point to the new container ---\n\t\t// Finally modify the class so that it refers back the container:\n\t\tsetPrivateField(clazz, \"outer\", grandParent);\n        writeSummary(\"\\tUpdated outer container reference for class \" + finalName + \".\");\n\t}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}