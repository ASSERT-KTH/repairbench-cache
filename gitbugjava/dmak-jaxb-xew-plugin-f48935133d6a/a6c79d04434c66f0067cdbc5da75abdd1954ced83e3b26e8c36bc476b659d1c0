{
    "generation": "import java.util.Map;\nimport javax.xml.namespace.QName;\n\nimport com.sun.codemodel.JClassContainer;\nimport com.sun.codemodel.JDefinedClass;\nimport com.sun.codemodel.JMod;\nimport com.sun.codemodel.JPackage;\nimport com.sun.tools.xjc.outline.ClassOutline;\nimport com.sun.tools.xjc.outline.Outline;\nimport com.sun.xml.xsom.XSComponent;\nimport com.sun.xml.xsom.XSDeclaration;\n\n// Assuming getPrivateField, setPrivateField, writeSummary are defined elsewhere appropriately.\n\n\t/**\n\t * Move the given class to his grandparent (either class or package). The given {@code clazz} should be inner class.\n\t */\n\tprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n\t\t// Get parent and grandparent\n\t\tJDefinedClass parent = (JDefinedClass) clazz.parentContainer();\n\t\tJClassContainer grandParent = parent.parentContainer();\n        String originalFullName = clazz.fullName(); // Store original name for logging/removal\n        String originalSimpleName = clazz.name(); // Store original simple name for removal\n\n\t\t// 1. Remove class from its original parent's list of inner classes\n\t\t// Use the original simple name for removal before any potential renaming happens later.\n\t\tMap<String, JDefinedClass> parentClasses = getPrivateField(parent, \"classes\");\n\t\tif (parentClasses != null) {\n\t\t\t// Ensure we are removing the correct entry using the name it had in the parent.\n\t\t\tparentClasses.remove(originalSimpleName);\n\t\t} else {\n\t\t\t// Log a warning if classes map is unexpectedly null, but proceed if possible\n\t\t\tSystem.err.println(\"Warning: Could not retrieve 'classes' map from parent: \" + parent.fullName() + \" while moving \" + originalFullName);\n\t\t}\n\n\t\t// Allows to track class name collisions in the grandparent:\n\t\tMap<String, JDefinedClass> grandParentClasses;\n\n\t\t// 2. Prepare for adding to grandparent\n\t\t// FIXME: Pending https://java.net/jira/browse/JAXB-957\n\t\tif (grandParent.isClass()) {\n\t\t\t// Grandparent is a class\n\t\t\tJDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\t\t\twriteSummary(\"\\tMoving inner class \" + originalFullName + \" to class \" + grandParentClass.fullName());\n\t\t\tgrandParentClasses = getPrivateField(grandParentClass, \"classes\");\n\t\t}\n\t\telse {\n\t\t\t// Grandparent is a package\n\t\t\tJPackage grandParentPackage = (JPackage) grandParent;\n\t\t\twriteSummary(\"\\tMoving inner class \" + originalFullName + \" to package \" + grandParentPackage.name());\n\t\t\tgrandParentClasses = getPrivateField(grandParentPackage, \"classes\");\n\n\t\t\t// In this scenario class should have \"static\" modifier reset (removed) otherwise it won't compile\n\t\t\t// as a top-level class within a package. Nested static classes are allowed, but not top-level static classes.\n\t\t\tif (clazz.mods() != null) {\n\t\t\t    // Remove static modifier if present\n                int currentMods = clazz.mods().getValue();\n                if ((currentMods & JMod.STATIC) != 0) { // Check if static is actually set\n                    int newMods = currentMods & ~JMod.STATIC;\n\t\t\t        setPrivateField(clazz.mods(), \"mods\", Integer.valueOf(newMods));\n                }\n\t\t\t} else {\n\t\t\t    System.err.println(\"Warning: Could not retrieve 'mods' from class: \" + originalFullName);\n\t\t\t}\n\n\t\t\t// Update schema component if necessary\n\t\t\tClassOutline targetClassOutline = null;\n\t\t\t// Find the ClassOutline associated with the JDefinedClass being moved\n\t\t\tfor (ClassOutline classOutline : outline.getClasses()) {\n\t\t\t\tif (classOutline.implClass == clazz) {\n\t\t\t\t\ttargetClassOutline = classOutline;\n\t\t\t\t\tbreak; // Found the class, no need to continue loop\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If outline exists, try to update its schema component representation\n            if (targetClassOutline != null && targetClassOutline.target != null) {\n                XSComponent sc = targetClassOutline.target.getSchemaComponent();\n                if (sc instanceof XSDeclaration) { // Check type before casting and accessing fields\n                    XSDeclaration decl = (XSDeclaration) sc;\n                    // FIXME: Inner class is always a local declaration. Re-evaluating this assumption.\n                    // If the class is moved to package level, it's conceptually not local/anonymous anymore.\n                    // Check if it was considered local before modifying.\n                    if (decl.isLocal()) {\n                        // Set anonymous to FALSE as it's now a top-level class.\n                        setPrivateField(sc, \"anonymous\", Boolean.FALSE);\n                    }\n                }\n            } else {\n                 // Log warning if the corresponding outline/target couldn't be found.\n                 // This might indicate an inconsistency or that the class wasn't directly from schema outline.\n                 System.err.println(\"Warning: Could not find ClassOutline or target for: \" + originalFullName + \" during move.\");\n            }\n\t\t}\n\n\t\tif (grandParentClasses == null) {\n             // Log an error if classes map is unexpectedly null, as we cannot add the class.\n             System.err.println(\"Error: Could not retrieve 'classes' map from grandparent: \"\n                 + (grandParent.isClass() ? ((JDefinedClass)grandParent).fullName() : ((JPackage)grandParent).name())\n                 + \" while moving \" + originalFullName + \". Aborting move for this class.\");\n             // Abort the operation for this class. The class was already removed from the parent,\n             // so it's now potentially orphaned. Throwing an exception might be better.\n             // Consider adding it back to parentClasses if an error occurs here? Needs careful thought on transactional safety.\n             // For now, just return.\n             return;\n        }\n\n\n\t\t// 3. Handle potential name collisions in grandparent and rename if necessary\n\t\tString currentName = clazz.name(); // Get the current simple name (might be the original or already changed by prior operations?)\n        String finalName = currentName;\n\t\tif (grandParentClasses.containsKey(finalName)) {\n            // Collision detected. Create a new name by prepending the original parent's simple name.\n            String newName = parent.name() + finalName; // e.g., ParentClassInnerClass\n\t\t\twriteSummary(\"\\tRenaming class \" + originalFullName + \" to \" + newName + \" due to collision in \" + (grandParent.isClass() ? ((JDefinedClass)grandParent).fullName() : ((JPackage)grandParent).name()));\n\t\t\tsetPrivateField(clazz, \"name\", newName); // Update the name field of the JDefinedClass\n            finalName = newName; // Use the new name for adding to the map\n\n            // Potential improvement: Check if the *new* name also collides and use a number suffix if needed.\n            // For now, assume ParentName + ClassName is unique enough.\n\t\t}\n\n\n\t\t// 4. Add the class (with its final name) to the grandparent's list of classes\n\t\tgrandParentClasses.put(finalName, clazz);\n\n\t\t// 5. Finally modify the class so that it refers back the container (its new outer class/package):\n\t\tsetPrivateField(clazz, \"outer\", grandParent);\n\t}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}