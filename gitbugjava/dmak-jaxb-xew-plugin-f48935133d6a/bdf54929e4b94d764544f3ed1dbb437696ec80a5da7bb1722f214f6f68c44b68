{
    "generation": "import java.util.Map;\nimport com.sun.codemodel.JClassContainer;\nimport com.sun.codemodel.JDefinedClass;\nimport com.sun.codemodel.JMod;\nimport com.sun.codemodel.JPackage;\nimport com.sun.tools.xjc.outline.ClassOutline;\nimport com.sun.tools.xjc.outline.Outline;\nimport com.sun.xml.xsom.XSComponent;\nimport com.sun.xml.xsom.XSDeclaration;\n\n// Assuming helper methods like getPrivateField, setPrivateField, and writeSummary exist elsewhere.\n// import static some.package.ReflectionUtils.*; \n// import static some.package.LogUtils.*; \n\n\t/**\n\t * Move the given class to his grandparent (either class or package). The given {@code clazz} should be inner class.\n\t */\n\tprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n\t\t// 1. Get parent and grandparent\n\t\tJDefinedClass parent = (JDefinedClass) clazz.parentContainer();\n\t\tJClassContainer grandParent = parent.parentContainer();\n\t\tString originalName = clazz.name(); // Store original name before potential rename\n\n        // Determine target container description for logging\n        String targetContainerName;\n        String targetType;\n        if (grandParent.isClass()) {\n            targetContainerName = ((JDefinedClass)grandParent).fullName();\n            targetType = \"class\";\n        } else {\n            targetContainerName = ((JPackage)grandParent).name();\n            targetType = \"package\";\n        }\n        writeSummary(\"\\tAttempting to move inner class \" + clazz.fullName() + \" to \" + targetType + \" \" + targetContainerName);\n\n\t\t// 2. Remove class from parent's container FIRST\n\t\tMap<String, JDefinedClass> parentClasses = getPrivateField(parent, \"classes\");\n\t\tif (parentClasses != null) {\n\t\t\tJDefinedClass removed = parentClasses.remove(originalName);\n            if (removed == null) {\n                 // Log a warning if the class wasn't found, though theoretically it should be there.\n                 writeSummary(\"\\tWarning: Class \" + originalName + \" not found in parent \" + parent.fullName() + \"'s classes map during move.\");\n            } else {\n                 writeSummary(\"\\tRemoved class \" + originalName + \" from original parent \" + parent.fullName());\n            }\n\t\t} else {\n\t\t\t// Log a more severe warning or error, as this indicates a problem accessing the parent's state.\n\t\t\twriteSummary(\"\\tWarning: Could not retrieve classes map from parent \" + parent.fullName() + \". Move might be incomplete.\");\n            // Depending on requirements, might consider throwing an exception here.\n\t\t}\n\n\t\t// 3. Prepare class for the new container (specific logic based on target type)\n\t\tMap<String, JDefinedClass> grandParentClasses; // To store classes of the target container\n\n\t\t// FIXME: Pending https://java.net/jira/browse/JAXB-957\n\t\tif (grandParent.isClass()) {\n\t\t\t// Moving to nest within another class\n\t\t\tJDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\t\t\tgrandParentClasses = getPrivateField(grandParentClass, \"classes\");\n            // Potentially, static modifier might need adjustment depending on context,\n            // but the original code only modified it when moving to a package.\n\t\t}\n\t\telse { // Moving to a package (becoming top-level or sibling top-level)\n\t\t\tJPackage grandParentPackage = (JPackage) grandParent;\n\t\t\tgrandParentClasses = getPrivateField(grandParentPackage, \"classes\");\n\n\t\t\t// In this scenario class should have \"static\" modifier reset otherwise it won't compile:\n            // A class directly within a package cannot be 'static'.\n            int currentMods = clazz.mods().getValue();\n            if ((currentMods & JMod.STATIC) != 0) {\n                writeSummary(\"\\tResetting STATIC modifier for \" + clazz.name() + \" as it moves to package \" + grandParentPackage.name());\n\t\t\t    setPrivateField(clazz.mods(), \"mods\", Integer.valueOf(currentMods & ~JMod.STATIC));\n            }\n\n\t\t\t// Update schema component properties if moving to package (making it non-local)\n\t\t\tfor (ClassOutline classOutline : outline.getClasses()) {\n\t\t\t\tif (classOutline.implClass == clazz) {\n\t\t\t\t\tXSComponent sc = classOutline.target.getSchemaComponent();\n                    // Check if the schema component is a declaration and is currently local\n\t\t\t\t\tif (sc instanceof XSDeclaration && ((XSDeclaration) sc).isLocal()) {\n                        writeSummary(\"\\tMarking schema component for \" + clazz.name() + \" as non-local/non-anonymous.\");\n                        // FIXME: Inner class is always a local declaration? Original assertion:\n\t\t\t\t\t\tassert (((XSDeclaration) sc).isLocal());\n                        // Mark it as not anonymous (assuming this relates to being non-local)\n\t\t\t\t\t\tsetPrivateField(sc, \"anonymous\", Boolean.FALSE);\n\t\t\t\t\t}\n\t\t\t\t\tbreak; // Found the corresponding outline, stop searching\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        // Check if we could retrieve the grandparent's class map\n        if (grandParentClasses == null) {\n             writeSummary(\"\\tError: Could not retrieve classes map from grandparent \" + targetContainerName + \". Aborting move operation for \" + originalName + \".\");\n             // Critical error: cannot add the class to the grandparent.\n             // The class has already been removed from the parent. The model is now inconsistent.\n             // Consider re-adding to parent or throwing a runtime exception.\n             // For now, just return, leaving the class potentially orphaned.\n             // Re-adding might be complex if renaming happened. Throwing might be safer.\n             // throw new IllegalStateException(\"Could not retrieve classes map from grandparent \" + targetContainerName);\n             return;\n        }\n\n\t\t// 4. Handle potential name collision in the grandparent container and determine final name\n        String finalName = originalName;\n\t\tif (grandParentClasses.containsKey(originalName)) {\n            // Collision detected: rename the class using the parent's name as a prefix.\n            finalName = parent.name() + originalName;\n\t\t\twriteSummary(\"\\tCollision detected in \" + targetContainerName + \". Renaming class \" + originalName + \" to \" + finalName);\n\t\t\tsetPrivateField(clazz, \"name\", finalName); // Update the class's name field\n\t\t}\n\n        // 5. Add the class (with its final name) to the grandparent's map\n\t\tgrandParentClasses.put(finalName, clazz);\n        writeSummary(\"\\tAdded class \" + finalName + \" to \" + targetContainerName);\n\n\t\t// 6. Finally modify the class's 'outer' field so that it refers back to the new container (grandparent)\n\t\tsetPrivateField(clazz, \"outer\", grandParent);\n        writeSummary(\"\\tUpdated outer container reference for class \" + finalName + \" to \" + targetContainerName);\n\t}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}