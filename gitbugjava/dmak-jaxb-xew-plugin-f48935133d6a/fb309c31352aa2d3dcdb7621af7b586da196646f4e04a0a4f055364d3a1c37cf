{
    "generation": "\t/**\n\t * Move the given class to his grandparent (either class or package). The given {@code clazz} should be inner class.\n\t */\n\tprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n\t\t// Original parent of the class\n\t\tJDefinedClass parent = (JDefinedClass) clazz.parentContainer();\n\t\t// New container for the class (grandparent)\n\t\tJClassContainer grandParent = parent.parentContainer();\n\n\t\t// Store the original simple name for removal from the parent.\n\t\t// This must be done before clazz.name might be changed due to collision handling.\n\t\tString originalSimpleClassName = clazz.name();\n\n\t\t// --- Step 1: Remove class from its original parent's \"classes\" map ---\n\t\t// This is the key fix: the class needs to be detached from its original parent.\n\t\tMap<String, JDefinedClass> parentInnerClasses = getPrivateField(parent, \"classes\");\n\t\tif (parentInnerClasses.remove(originalSimpleClassName) == null) {\n\t\t\t// Log a warning if the class wasn't found in its supposed parent.\n\t\t\t// This might indicate an inconsistent model state prior to this operation,\n\t\t\t// but we attempt to proceed.\n\t\t\twriteSummary(\"\\tWarning: Class \" + originalSimpleClassName + \" not found in original parent \" + parent.fullName() + \"'s inner classes during move operation.\");\n\t\t} else {\n\t\t\twriteSummary(\"\\tRemoved inner class \" + originalSimpleClassName + \" from \" + parent.fullName() + \".\");\n\t\t}\n\n\t\t// Allows to track class name collisions: (This is the original 'classes' variable name)\n\t\tMap<String, JDefinedClass> classes; // This will hold the 'classes' map of the grandparent\n\n\t\t// FIXME: Pending https://java.net/jira/browse/JAXB-957\n\t\tif (grandParent.isClass()) {\n\t\t\t// Grandparent is a class, so clazz will become an inner class of grandParent.\n\t\t\tJDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\n\t\t\t// Log uses clazz.fullName() which reflects its state before its name or outer fields are changed.\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to class \" + grandParentClass.fullName());\n\n\t\t\tclasses = getPrivateField(grandParentClass, \"classes\");\n\t\t}\n\t\telse {\n\t\t\t// Grandparent is a package, so clazz will become a (effectively) top-level class in that package.\n\t\t\tJPackage grandParentPackage = (JPackage) grandParent;\n\n\t\t\t// Log uses clazz.fullName() which reflects its state before its name or outer fields are changed.\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to package \" + grandParentPackage.name());\n\n\t\t\tclasses = getPrivateField(grandParentPackage, \"classes\");\n\n\t\t\t// In this scenario class should have \"static\" modifier reset otherwise it won't compile:\n\t\t\t// Top-level classes (or classes directly under a package) cannot have the 'static' modifier.\n\t\t\tsetPrivateField(clazz.mods(), \"mods\", Integer.valueOf(clazz.mods().getValue() & ~JMod.STATIC));\n\n\t\t\t// Additional schema-related adjustments when moving to a package.\n\t\t\tfor (ClassOutline classOutline : outline.getClasses()) {\n\t\t\t\tif (classOutline.implClass == clazz) {\n\t\t\t\t\tXSComponent sc = classOutline.target.getSchemaComponent();\n\n\t\t\t\t\t// FIXME: Inner class is always a local declaration.\n\t\t\t\t\t// This assertion and update imply that moving to package level makes it non-local/non-anonymous\n\t\t\t\t\t// in terms of schema component representation.\n\t\t\t\t\tassert (sc instanceof XSDeclaration && ((XSDeclaration) sc).isLocal());\n\n\t\t\t\t\tsetPrivateField(sc, \"anonymous\", Boolean.FALSE);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handle name collisions in the new container (grandparent).\n\t\t// clazz.name() is still originalSimpleClassName at this point.\n\t\t// If the grandparent already contains a class with the same simple name, rename clazz.\n\t\tif (classes.containsKey(clazz.name())) {\n\t\t\t// New name is formed by prepending the original parent's simple name.\n\t\t\t// E.g., if Parent.Inner is moved and GrandParent already has Inner,\n\t\t\t// new name becomes ParentInner.\n\t\t\tString newName = parent.name() + clazz.name(); // clazz.name() is originalSimpleClassName here\n\t\t\t// Log uses clazz.fullName() which reflects its state before name change.\n\t\t\twriteSummary(\"\\tRenaming class \" + clazz.fullName() + \" to class \" + newName); // Original log used parent.name() + clazz.name() for the new name.\n\t\t\tsetPrivateField(clazz, \"name\", newName); // Update the class's simple name.\n\t\t}\n\n\t\t// Add class (with its final name) to the grandparent's \"classes\" map.\n\t\t// clazz.name() now refers to the (potentially new) collision-free simple name.\n\t\tclasses.put(clazz.name(), clazz);\n\n\t\t// Finally modify the class so that it refers back the container:\n\t\t// Update class's \"outer\" field to point to the new container (grandparent).\n\t\t// This establishes the new parent-child relationship in the CodeModel.\n\t\tsetPrivateField(clazz, \"outer\", grandParent);\n\t}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}