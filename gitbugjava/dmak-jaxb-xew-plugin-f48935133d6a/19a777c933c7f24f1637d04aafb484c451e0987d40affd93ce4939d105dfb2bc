{
    "generation": "\t/**\n\t * Move the given class to his grandparent (either class or package). The given {@code clazz} should be inner class.\n\t */\n\tprivate void moveClassLevelUp(Outline outline, JDefinedClass clazz) {\n\t\t// Modify the container so it now refers the class. Container can be a class or package.\n\t\tJDefinedClass parent = (JDefinedClass) clazz.parentContainer();\n\t\tJClassContainer grandParent = parent.parentContainer();\n\n\t\t// --- BEGIN FIX ---\n\t\t// Store the original simple name of the class. This is needed for removal\n\t\t// from the parent's class map, as clazz.name() might change later due to collision resolution.\n\t\tString originalSimpleName = clazz.name();\n\n\t\t// Remove the class from its original parent's list of inner classes.\n\t\t// This uses reflection to access the private 'classes' map of the parent JDefinedClass.\n\t\t@SuppressWarnings(\"unchecked\") // Type of 'classes' field is known from JCodeModel source\n\t\tMap<String, JDefinedClass> parentInternalClasses = getPrivateField(parent, \"classes\");\n\n\t\tif (parentInternalClasses != null) {\n\t\t\tparentInternalClasses.remove(originalSimpleName);\n\t\t} else {\n\t\t\t// This case implies an issue with getPrivateField or unexpected JCodeModel state.\n\t\t\t// Log a warning, as the class might not be correctly unlinked from its old parent.\n\t\t\t// Depending on the strictness of getPrivateField, this might not be reachable if it throws on failure.\n\t\t\twriteSummary(\"\\t[WARNING] Could not access inner classes map of original parent \" + parent.fullName() +\n\t\t\t\t\t\" to remove class \" + originalSimpleName + \". Proceeding, but this may lead to issues.\");\n\t\t}\n\t\t// --- END FIX ---\n\t\t\n\t\t// This map will hold classes for the grandParent container.\n\t\tMap<String, JDefinedClass> grandParentClassesMap;\n\n\t\t// FIXME: Pending https://java.net/jira/browse/JAXB-957\n\t\tif (grandParent.isClass()) {\n\t\t\t// Element class should be added as its container child:\n\t\t\tJDefinedClass grandParentClass = (JDefinedClass) grandParent;\n\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to class \" + grandParentClass.fullName());\n\n\t\t\tgrandParentClassesMap = getPrivateField(grandParentClass, \"classes\");\n\t\t}\n\t\telse { // grandParent is a JPackage\n\t\t\tJPackage grandParentPackage = (JPackage) grandParent;\n\n\t\t\twriteSummary(\"\\tMoving inner class \" + clazz.fullName() + \" to package \" + grandParentPackage.name());\n\n\t\t\tgrandParentClassesMap = getPrivateField(grandParentPackage, \"classes\");\n\n\t\t\t// In this scenario class should have \"static\" modifier reset otherwise it won't compile:\n\t\t\t// Top-level classes in a package are not 'static'. Inner classes might be.\n\t\t\t// Only call setPrivateField if the modifier actually changes.\n\t\t\tint currentMods = clazz.mods().getValue();\n\t\t\tint newMods = currentMods & ~JMod.STATIC;\n\t\t\tif (newMods != currentMods) {\n\t\t\t    setPrivateField(clazz.mods(), \"mods\", Integer.valueOf(newMods));\n\t\t\t}\n\n\t\t\tfor (ClassOutline classOutline : outline.getClasses()) {\n\t\t\t\tif (classOutline.implClass == clazz) {\n\t\t\t\t\tXSComponent sc = classOutline.target.getSchemaComponent();\n\n\t\t\t\t\t// FIXME: Inner class is always a local declaration. (Original comment)\n\t\t\t\t\tassert (sc instanceof XSDeclaration && ((XSDeclaration) sc).isLocal());\n\n\t\t\t\t\tsetPrivateField(sc, \"anonymous\", Boolean.FALSE);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If grandParentClassesMap is null (e.g. getPrivateField failed), subsequent operations\n\t\t// like .containsKey or .put would cause a NullPointerException.\n\t\t// This matches original behavior if getPrivateField were to return null for grandparent.\n\t\tif (grandParentClassesMap == null) {\n\t\t    // This indicates a critical issue, likely with reflection or JCodeModel structure.\n\t\t    // Log an error and potentially stop, as the class cannot be properly moved.\n\t\t    String grandParentName = grandParent.isClass() ? ((JDefinedClass)grandParent).fullName() : ((JPackage)grandParent).name();\n\t\t    writeSummary(\"\\t[ERROR] Failed to get classes map from new parent container \" + grandParentName +\n\t\t                 \". Class \" + clazz.name() + \" cannot be added to it.\");\n\t\t    // Depending on desired robustness, could throw an exception here.\n\t\t    // For this fix, we'll let it potentially NPE later if not handled, to mirror original code's lack of null check for `classes`.\n\t\t}\n\n\n\t\tif (grandParentClassesMap != null && grandParentClassesMap.containsKey(clazz.name())) {\n\t\t\tString newName = parent.name() + clazz.name();\n\t\t\twriteSummary(\"\\tRenaming class \" + clazz.fullName() + \" to class \" + newName);\n\t\t\tsetPrivateField(clazz, \"name\", newName);\n\t\t\t// After this, clazz.name() returns the new name.\n\t\t}\n\n\t\tif (grandParentClassesMap != null) {\n\t\t    grandParentClassesMap.put(clazz.name(), clazz); // clazz.name() is the final name\n\t\t}\n\n\t\t// Finally modify the class so that it refers back the container:\n\t\tsetPrivateField(clazz, \"outer\", grandParent);\n\t}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}