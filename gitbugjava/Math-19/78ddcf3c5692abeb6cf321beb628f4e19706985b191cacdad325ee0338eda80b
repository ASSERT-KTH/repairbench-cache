{
    "generation": "    /**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n        final int dimension = init.length;\n\n        // Initialize boundaries to null (defaulting to unbound optimization)\n        boundaries = null;\n\n        // Check bounds if they are provided (both lower and upper must be non-null)\n        if (lB != null && uB != null) {\n            // Check dimensions match the initial guess\n            if (lB.length != dimension) {\n                throw new DimensionMismatchException(lB.length, dimension);\n            }\n            if (uB.length != dimension) {\n                throw new DimensionMismatchException(uB.length, dimension);\n            }\n\n            boolean hasFinite = false;\n            boolean hasInfinite = false;\n            for (int i = 0; i < dimension; i++) {\n                // Check: lower boundary must be less than or equal to upper boundary.\n                if (lB[i] > uB[i]) {\n                    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                        lB[i], uB[i], false);\n                }\n                // Check for NaN values (robustness check, BaseOptimizer might already check)\n                if (Double.isNaN(lB[i]) || Double.isNaN(uB[i])) {\n                     throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n                }\n\n                // Classify bounds for this dimension\n                if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n                    hasInfinite = true;\n                } else {\n                    hasFinite = true;\n                }\n            }\n\n            // Check for mixed finite and infinite bounds, which is unsupported.\n            if (hasFinite && hasInfinite) {\n                throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n            }\n\n            // If all bounds are finite, set internal boundaries and perform checks.\n            if (hasFinite) { // This implies !hasInfinite due to the check above\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Check for potential overflow when calculating the range (upper - lower).\n                // Also check if the initial guess is within the finite bounds.\n                for (int i = 0; i < dimension; i++) {\n                    final double range = boundaries[1][i] - boundaries[0][i];\n                    if (Double.isInfinite(range)) {\n                        // Throw exception if the range calculation overflows to infinity.\n                        throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_TOO_LARGE,\n                                                           range, Double.MAX_VALUE, false);\n                    }\n                    // Check initial point bounds\n                     if (init[i] < boundaries[0][i]) {\n                         throw new OutOfRangeException(init[i], boundaries[0][i], boundaries[1][i]);\n                     }\n                     if (init[i] > boundaries[1][i]) {\n                         throw new OutOfRangeException(init[i], boundaries[0][i], boundaries[1][i]);\n                     }\n                }\n            }\n            // If !hasFinite, it means all bounds are infinite (or lB/uB were null).\n            // In this case, 'boundaries' remains null, indicating an unbound problem.\n        } else if (lB != null || uB != null) {\n            // If only one of lB or uB is null, it's an error in setup.\n            throw new MathIllegalArgumentException(LocalizedFormats.INVALID_BOUNDS);\n        }\n        // If both lB and uB are null, 'boundaries' remains null.\n\n\n        // Check inputSigma if it is provided.\n        if (inputSigma != null) {\n            if (inputSigma.length != dimension) {\n                throw new DimensionMismatchException(inputSigma.length, dimension);\n            }\n            for (int i = 0; i < dimension; i++) {\n                // Sigma values must be non-negative.\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                // If finite boundaries are set, sigma must not be larger than the range.\n                if (boundaries != null) {\n                    final double range = boundaries[1][i] - boundaries[0][i];\n                    // The range is guaranteed to be finite here due to the earlier check.\n                    if (inputSigma[i] > range) {\n                         throw new OutOfRangeException(inputSigma[i], 0, range);\n                    }\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}