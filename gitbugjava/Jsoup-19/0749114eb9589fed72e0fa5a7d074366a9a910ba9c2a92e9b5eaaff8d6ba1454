{
    "generation": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // Check the protocol of the original value, without resolving first. Allows for custom protocols.\n        String value = attr.getValue(); // Get the original value as set in the attribute\n        String LcValueToCheck = value.trim().toLowerCase(); // Trim and lower for checking prefixes\n\n        if (LcValueToCheck.isEmpty()) return false; // Empty values are not valid protocols\n\n        boolean Mvalid = false;\n        // Check 1: Does the trimmed, lowercased value start with an allowed protocol?\n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString() + \":\";\n            if (LcValueToCheck.startsWith(prot)) {\n                valid = true;\n                break;\n            }\n        }\n\n        String absValue = \"\"; // Initialize absValue, will store resolved URL if needed\n\n        if (!valid) {\n            // Check 2: If not, maybe it's a relative URL or requires base URI resolution.\n            // Resolve using absUrl and check the protocol of the absolute URL.\n            // absUrl will return \"\" if e.g. no base Uri specified or mailto:\n            absValue = el.absUrl(attr.getKey()); // Resolve URL using attribute key\n            if (absValue.isEmpty()) {\n                 // Cannot resolve (e.g., relative URL without baseUri, or malformed like \"evil:\", or unsupported like \"mailto:\") -> invalid UNLESS checked in Check 1\n                 // Since Check 1 failed, and resolution failed, consider it invalid.\n                 return false;\n            }\n            String lcAbsValue = absValue.toLowerCase(); // Lowercase for checking resolved URL\n            for (Protocol protocol : protocols) {\n                String prot = protocol.toString() + \":\";\n                if (lcAbsValue.startsWith(prot)) {\n                    valid = true; // Valid based on resolved absolute URL's protocol\n                    break;\n                }\n            }\n        }\n\n        // If valid either way (original check or resolved check):\n        if (valid) {\n            if (!preserveRelativeLinks) {\n                 // If validation passed based on the original value (Check 1),\n                 // we might still need to calculate absValue if it wasn't done in Check 2.\n                 // This handles cases like \"cid:\" or \"data:\" where absUrl might return empty/fail.\n                 if (absValue.isEmpty()) { // absValue is empty only if Check 1 passed and Check 2 was skipped\n                     absValue = el.absUrl(attr.getKey()); // Calculate absValue now\n                 }\n\n                 // Update attribute value:\n                 // If absUrl produced a non-empty result (meaning resolution likely succeeded), use it.\n                 // Otherwise (absUrl failed or returned empty e.g. for mailto:, cid:), keep the original value.\n                 // We use the original 'value' variable which holds the untrimmed, original case value.\n                 if (!absValue.isEmpty()) {\n                     attr.setValue(absValue);\n                 } else {\n                     // Fallback to original value if absUrl resolution failed or was empty.\n                     // This preserves values like \"cid:12345\" or \"mailto:test@example.com\"\n                     attr.setValue(value);\n                 }\n            }\n            // else: preserveRelativeLinks is true, so do nothing to the attribute value, just confirm validity.\n            return true;\n        } else {\n            // Neither original check nor resolved check found a valid protocol.\n            return false;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}