{
    "generation": "    @Override\n    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                // A NAME node that's the first child of a GETPROP is not a global name reference,\n                // it's the base of the qualified name. The GETPROP node itself will handle the\n                // actual reference check. Return early to avoid processing it independently.\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n                  // Function expression names are not global.\n                  return;\n                }\n                // Function declaration name.\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          name = n.getQualifiedName();\n          if (name == null) {\n            return;\n          }\n\n          // Check if the base of the qualified name is local. If so, this GETPROP\n          // doesn't represent a global name reference, even if the full name isn't\n          // declared locally. e.g., `local_var.foo`.\n          Node base = NodeUtil.getRootOfQualifiedName(n);\n          if (base != null && base.isName()) {\n             String baseName = base.getString();\n             Var v = scope.getVar(baseName);\n             // If the base name corresponds to a Var that is NOT global and NOT extern,\n             // then this GETPROP is operating on a non-global variable, so we can ignore it.\n             if (v != null && !v.isGlobal() && !v.isExtern()) {\n                return; // Not a potential global name reference.\n             }\n             // If v is null, or it's global/extern, we fall through to the checks below.\n          } else {\n             // Base is not a simple name (e.g., `({}).foo` or `this.foo`). Not a global name reference\n             // of the type we are tracking here. `this` is handled separately if needed.\n             return;\n          }\n\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              // NOTE(nicksantos): We used to have a GETPROP case here, but\n              // it is unnecessary. We should only care about GETPROPs that\n              // are props of other GETPROPs if they are assigning to\n              // that property.\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          // name is already set above\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        handleGet(module, scope, n, parent, name);\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}