{
    "generation": "    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     *\n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        // Calculate the potential length of the encoded data, respecting the chunking flag\n        long len;\n        if (isChunked) {\n            // Calculate chunked length using the static helper method which assumes MIME parameters\n            // Assumes getEncodeLength correctly calculates the length including separators for chunking.\n            len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        } else {\n            // Calculate unchunked length directly using the standard Base64 formula:\n            // length = ceil(binaryData.length / 3) * 4\n            // Integer division trick for ceiling: (a + b - 1) / b for ceil(a/b)\n            // However, Base64 pads to multiples of 3 bytes *before* encoding.\n            // So, the length is based on padded input size: ceil(input_bytes / 3) * 4\n            // The formula ((input_bytes + 2) / 3) * 4 correctly calculates this.\n            len = ((long)binaryData.length + 2) / 3 * 4;\n        }\n\n        // Check if the calculated length exceeds the maximum allowed size.\n        // We should respect maxResultSize only if it's positive. A non-positive value typically indicates no limit.\n        // The original code didn't handle non-positive maxResultSize explicitly.\n        // Assuming maxResultSize is intended as a positive limit:\n        if (maxResultSize > 0 && len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n\n        // Create a Base64 encoder instance with the specified settings.\n        // The constructor choice reflects the isChunked flag:\n        // - new Base64(urlSafe): Uses default chunking (assumed to be MIME_CHUNK_SIZE with CHUNK_SEPARATOR).\n        // - new Base64(0, CHUNK_SEPARATOR, urlSafe): Disables chunking by setting line length to 0.\n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}