{
    "generation": "    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     *\n     * Uses {@link #formatLongOctalBytes} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     *\n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer according to the TAR specification\n     * (requires <= length-1 octal digits or binary representation within length).\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Determine the maximum value that can be represented in octal for the given field length.\n        // formatLongOctalBytes requires value <= (1L << 3 * (length - 1)) - 1\n        // This check is implicitly handled by formatLongOctalBytes, but we can optimize slightly.\n        long maxAsOctalChar;\n        // The original code used a heuristic based on typical field types (UID/Size)\n        // Let's retain that heuristic as a first check.\n        if (length == TarConstants.UIDLEN) { // UIDLEN is typically 8\n            maxAsOctalChar = TarConstants.MAXID; // 07777777 octal\n        } else {\n            // Assuming size field or other field, use MAXSIZE limit\n            // MAXSIZE is 077777777777L octal, typically for length 12\n            maxAsOctalChar = TarConstants.MAXSIZE;\n        }\n\n        final boolean negative = value < 0;\n        // Try octal if value is non-negative and fits the heuristic maximum.\n        // formatLongOctalBytes will perform the precise check for the given length.\n        if (!negative && value <= maxAsOctalChar) {\n            try {\n                // formatLongOctalBytes adds NUL/space trailer and checks if value fits length-1 digits\n                return formatLongOctalBytes(value, buf, offset, length);\n            } catch (final IllegalArgumentException e) {\n                // If value is too large for octal representation in the given length,\n                // fall through to binary representation.\n                // This can happen if maxAsOctalChar heuristic was too large for the actual 'length'.\n            }\n        }\n\n        // Handle binary case: marker byte + (length-1) bytes of value in two's complement BE.\n        // Reference: GNU tar specification for binary numeric fields.\n        if (length < 1) {\n             throw new IllegalArgumentException(\"Length must be at least 1.\");\n        }\n\n        final int numValueBytes = length - 1;\n        long minBinaryValue;\n        long maxBinaryValue;\n\n        // Calculate the range representable by numValueBytes in two's complement.\n        if (numValueBytes >= 8) {\n             // If length >= 9, numValueBytes >= 8, can represent full 64-bit long range.\n             minBinaryValue = Long.MIN_VALUE; // -(1L << 63)\n             maxBinaryValue = Long.MAX_VALUE; // (1L << 63) - 1\n        } else { // 0 <= numValueBytes <= 7\n             if (numValueBytes == 0) { // length = 1\n                 // Only 0 can be represented (marker byte 0x80)\n                 minBinaryValue = 0;\n                 maxBinaryValue = 0;\n             } else { // 1 <= numValueBytes <= 7 -> 8 to 56 value bits\n                 // Total bits available for value representation (including sign)\n                 final int numValueBits = numValueBytes * 8;\n                 // Min value is -(2^(numValueBits-1))\n                 minBinaryValue = -(1L << (numValueBits - 1));\n                 // Max value is 2^(numValueBits-1) - 1\n                 maxBinaryValue = (1L << (numValueBits - 1)) - 1;\n             }\n        }\n\n        // Check if the value fits within the calculated binary range.\n        if (value < minBinaryValue || value > maxBinaryValue) {\n             // Throw exception consistent with original code's message pattern\n             throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\n        }\n\n        // Write the binary representation.\n        // 1. Marker byte (highest bit set indicates binary format, sign indicated by 0x80 vs 0xFF)\n        buf[offset] = (byte) (negative ? 0xFF : 0x80);\n        // 2. Value bytes (two's complement Big Endian)\n        long val = value;\n        // Iterate from the last byte of the value field down to the first byte after the marker\n        // This writes length-1 bytes.\n        for (int i = offset + length - 1; i > offset; i--) {\n            buf[i] = (byte) val;\n            // Use unsigned right shift to fill with zeros, preserving the sign bit's original position\n            // during the shift process until it's shifted out for lower bytes.\n            val >>>= 8;\n        }\n\n        return offset + length;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}