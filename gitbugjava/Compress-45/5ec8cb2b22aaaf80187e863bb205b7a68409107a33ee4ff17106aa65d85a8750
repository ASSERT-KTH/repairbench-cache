{
    "generation": "    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     *\n     * Uses {@link #formatUnsignedOctalString} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     *\n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        // Handle non-negative values fitting in standard octal representation.\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        // Handle binary representation for values that don't fit in octal or are negative.\n        // This format uses a marker byte (0x80 for positive, 0xFF for negative)\n        // followed by the magnitude of the value in the remaining bytes.\n        // Assumes formatLongBinary and formatBigIntegerBinary handle writing the\n        // marker byte and the value magnitude, and throw IllegalArgumentException if\n        // the magnitude doesn't fit in length-1 bytes.\n\n        if (length < 9) {\n            // Use formatLongBinary for lengths typically used for UID/GID (e.g., 8).\n            // It should handle the marker and magnitude encoding for 64-bit longs.\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            // Use formatBigIntegerBinary for larger lengths (e.g., 12 for size).\n            // It handles values that might exceed Long.MAX_VALUE magnitude using BigInteger logic.\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n\n        // Mark the buffer segment as containing binary data by setting the high bit of the first byte.\n        // Note: formatLongBinary/formatBigIntegerBinary are expected to write the correct\n        // marker (0x80 or 0xFF) based on negativity. However, the original code\n        // unconditionally overwrote buf[offset] here. We keep this original behavior\n        // for safety, although it might be redundant if the helper methods already set it correctly.\n        // If helper methods set 0x80/0xFF, this sets 0x80 for positive and 0xFF for negative, matching them.\n        // If helper methods only set the value part (offset+1 onwards), this correctly sets the marker.\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}