{
    "generation": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    boolean nodeChanged; // Tracks if visit(node) caused a change in the current iteration\n    do {\n      // First, traverse the children recursively.\n      // Changes made deep down the tree will be handled by recursive calls.\n      // Their changes might set the instance 'codeChanged' flag, but we are\n      // interested in whether 'visit(node)' *itself* causes a change\n      // to decide if the *current* node's loop needs repeating.\n      Node c = node.getFirstChild();\n      while(c != null) {\n        // Store the next sibling *before* the recursive call.\n        // The recursive call might modify the child node structure,\n        // including removing the node or replacing it.\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n\n      // Now, visit the current node. We reset the 'codeChanged' flag\n      // before the visit to isolate the changes made by this specific visit.\n      // This assumes 'codeChanged' is an instance variable used to track changes.\n      this.codeChanged = false;\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n\n      // Check if the visit to *this* node resulted in a change.\n      nodeChanged = this.codeChanged;\n\n      // Repeat the loop only if visit(node) changed something.\n      // This prevents unnecessary re-traversal of children if changes\n      // occurred deeper in the tree, as those are handled recursively.\n    } while (nodeChanged);\n\n    exitNode(node);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}