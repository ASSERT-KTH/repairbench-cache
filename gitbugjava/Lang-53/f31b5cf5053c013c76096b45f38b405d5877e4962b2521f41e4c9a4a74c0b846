{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 / Rounding ---------------------- START ---------------\n        // Store original value for rounding decisions\n        // Note: LANG-346 bug identified that the rounding decision logic used the\n        // possibly-modified calendar state instead of the original state.\n        Calendar originalVal = (Calendar) val.clone();\n\n        // Use millisecond arithmetic for truncation of smaller fields to avoid Calendar issues (LANG-59)\n        // This performs truncation up to the second level, regardless of rounding state.\n        // Rounding behavior is handled below based on the original values.\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean modified = false;\n\n        // truncate milliseconds\n        if (field > Calendar.MILLISECOND) { // Clear milliseconds if field is Second or higher\n            int millis = val.get(Calendar.MILLISECOND);\n            if (millis > 0) {\n                time -= millis;\n                modified = true;\n            }\n        }\n\n        // truncate seconds\n        if (field > Calendar.SECOND) { // Clear seconds if field is Minute or higher\n            int seconds = val.get(Calendar.SECOND);\n            if (seconds > 0) {\n                time -= (seconds * 1000L);\n                modified = true;\n            }\n        }\n\n        // truncate minutes\n        if (field > Calendar.MINUTE) { // Clear minutes if field is Hour or higher\n            int minutes = val.get(Calendar.MINUTE);\n             if (minutes > 0) {\n                time -= (minutes * 60000L);\n                modified = true;\n            }\n        }\n\n        // reset time in working Calendar 'val' if modified by truncation\n        if (modified) {\n            date.setTime(time);\n            val.setTime(date); // val is now truncated below the target field level (ms, s, m cleared appropriately)\n        }\n        // ----------------- Fix for LANG-59 / Rounding ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            int currentField = fields[i][0]; // The primary Calendar field for this level\n\n            // Check if the target field 'field' is one of the fields handled at this level\n            boolean targetFound = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    targetFound = true;\n                    break;\n                }\n            }\n\n            // If target field is found, apply rounding based on 'roundUp' flag from previous level processing\n            if (targetFound) {\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // Special case: SEMI_MONTH\n                        // If date is 1, round up to 16. Otherwise skip forward 1 month (date is already 1 by truncation).\n                        if (originalVal.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            // Roll back to 1st of month, then add 1 month\n                            val.add(Calendar.DATE, -15); // Should be safe as day is 1 after truncation cycle\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field == Calendar.AM_PM) {\n                        // Special case: AM_PM\n                        // If rounding up from AM, round to 12 PM (noon).\n                        // If rounding up from PM, round to 12 AM (next day midnight).\n                        if (originalVal.get(Calendar.AM_PM) == Calendar.PM) {\n                            // Was PM, round up to next day 00:00\n                            val.add(Calendar.DATE, 1); // val is already 00:00, just add day\n                        } else {\n                            // Was AM, round up to same day 12:00\n                            val.set(Calendar.HOUR_OF_DAY, 12); // val is 00:00, set hour to 12\n                        }\n                    } else {\n                        // General case: Add 1 to the primary field of this level\n                        val.add(currentField, 1);\n                    }\n                }\n                return; // Modification complete\n            }\n\n            // Target field is larger than the current level 'i'. Process this level.\n            // Determine 'roundUp' needed for the next level based on the *original* value of the field(s) at this level.\n            // Then, zero out the field(s) in the working 'val'.\n\n            int offset = 0; // Offset from minimum for the current field's value in originalVal\n            boolean offsetSet = false; // Flag if offset/roundUp calculated by special rules\n\n            // Special rounding rules for SEMI_MONTH and AM_PM targets affect how lower fields determine roundUp\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (currentField == Calendar.DATE) { // Are we processing the DATE level?\n                        // Use original date to determine offset and roundUp decision\n                        offset = originalVal.get(Calendar.DATE) - 1; // 0-based day of month\n                        if (offset >= 15) {\n                            offset -= 15; // Offset within the second half (0-14 range approx)\n                        }\n                        // Round up if offset > 7 (more than half of 15 days)\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (currentField == Calendar.HOUR_OF_DAY) { // Are we processing the HOUR_OF_DAY level?\n                        // Use original hour to determine offset (within AM or PM period) and roundUp decision\n                        offset = originalVal.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12; // Hour within PM (0-11 range)\n                        }\n                        // Round up if offset > 6 (more than half of 12 hours)\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // Standard rounding calculation for currentField if no special rule applied\n            if (!offsetSet) {\n                // Use original value to determine offset and roundUp decision\n                int originalValue = originalVal.get(currentField);\n                int min = originalVal.getActualMinimum(currentField);\n                int max = originalVal.getActualMaximum(currentField);\n                offset = originalValue - min; // Offset from minimum\n                // Set roundUp if offset is more than halfway between min and max\n                roundUp = offset * 2 > (max - min); // Using multiplication avoids int division errors\n            }\n\n            // Now, zero out the current field in the working 'val'.\n            // This happens AFTER roundUp is determined based on originalVal.\n            if (val.get(currentField) != val.getActualMinimum(currentField)) {\n                 // Calculate offset based on current val state just for zeroing\n                 int currentValOffset = val.get(currentField) - val.getActualMinimum(currentField);\n                 val.add(currentField, -currentValOffset); // Subtract offset to reach minimum\n                 // Note: Using add with negative offset is safer than set for fields like MONTH/YEAR\n                 // which might affect other fields if set directly. For simple fields like SECOND, set is fine too.\n                 // Let's stick to original's set logic for zeroing:\n                 // val.set(currentField, val.getActualMinimum(currentField));\n                 // Rechecking original code: `val.set(fields[i][0], val.get(fields[i][0]) - offset);` where offset was based on current val.\n                 // This is equivalent to `val.set(currentField, val.getActualMinimum(currentField));`\n                 val.set(currentField, val.getActualMinimum(currentField));\n            }\n        }\n        // Should never normally reach here, as loop should find field or return earlier\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}