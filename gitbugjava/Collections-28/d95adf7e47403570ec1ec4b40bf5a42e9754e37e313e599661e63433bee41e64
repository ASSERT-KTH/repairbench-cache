{
    "generation": "        /**\n         * Removes the last returned element.\n         * <p>\n         * This method can be called only once per call to {@link #next()}.\n         *\n         * @throws IllegalStateException if {@link #next()} has not yet been called,\n         * or {@link #remove()} has already been called after the last call to {@link #next()}.\n         * @throws ConcurrentModificationException if the Trie was modified during iteration.\n         * @throws UnsupportedOperationException if the removed node was an internal node.\n         */\n        @Override\n        public void remove() {\n            // Check modification count from PatriciaTrie.this.modCount\n            if (modCountExpected != PatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            // Check if next() has been called (current should be non-null)\n            if (current == null) {\n                throw new IllegalStateException(\"next() has not been called\");\n            }\n\n            // Check if remove() was already called\n            if (!canRemove) {\n                throw new IllegalStateException(\"remove() already called for this element\");\n            }\n\n            final TrieEntry<K, V> nodeToRemove = current; // Node to remove\n\n            modCountExpected = ++PatriciaTrie.this.modCount; // Increment mod count\n\n            TrieEntry<K, V> parent = findParent(nodeToRemove);\n\n            if (parent == null) { // Removing the root\n                if (!nodeToRemove.isExternalNode()) {\n                    // Cannot remove internal root entries (original behavior)\n                    // Note: PatriciaTrie doesn't allow storing values in internal nodes,\n                    // so this case might imply removing the structural root node, which is invalid.\n                    throw new UnsupportedOperationException(\"Cannot remove internal entry!\");\n                }\n                // Root is external, removing it clears the trie\n                PatriciaTrie.this.clear(); // This handles size and root=null\n                // Size is handled by clear(), no decrement needed here.\n            } else { // Removing a non-root node\n                if (!nodeToRemove.isExternalNode()) {\n                    // Cannot remove internal non-root entries (original behavior)\n                    throw new UnsupportedOperationException(\"Cannot remove internal entry!\");\n                }\n\n                // nodeToRemove is external and not root.\n                // Find the original sibling before modifying parent's links\n                TrieEntry<K, V> originalSibling = (parent.left == nodeToRemove) ?\n                                                  parent.right : parent.left;\n\n                // Original logic: Replace child pointer in parent with nodeToRemove.predecessor\n                // This predecessor link is crucial for PATRICIA structure but might be involved in bugs.\n                if (parent.left == nodeToRemove) {\n                    parent.left = nodeToRemove.predecessor;\n                } else if (parent.right == nodeToRemove) {\n                    parent.right = nodeToRemove.predecessor;\n                } else {\n                    // Should not happen if findParent worked correctly\n                    throw new IllegalStateException(\"Cannot determine parent relation for removal\");\n                }\n\n                // If the parent remains internal after update (needs uplifting)\n                // An internal node has bitIndex >= 0\n                if (parent.isInternalNode()) {\n                    // Find grandparent\n                    TrieEntry<K, V> grandParent = findParent(parent);\n\n                    // Find the actual child node to uplift (the one that's not the back-pointer)\n                    // The child to uplift is the original sibling found earlier.\n                    TrieEntry<K, V> childToUplift = originalSibling;\n\n                    // Check if childToUplift is consistent (should not be null if parent was internal)\n                    if (childToUplift == null) {\n                         throw new IllegalStateException(\"Child to uplift is null for an internal parent\");\n                    }\n\n\n                    // Update grandparent's link\n                    if (grandParent == null) { // Parent was root\n                        PatriciaTrie.this.root = childToUplift;\n                        // Update new root's predecessor\n                        if (PatriciaTrie.this.root != null) {\n                            PatriciaTrie.this.root.predecessor = PatriciaTrie.this.root;\n                        }\n                    } else {\n                        if (grandParent.left == parent) {\n                            grandParent.left = childToUplift;\n                        } else { // grandParent.right == parent\n                            grandParent.right = childToUplift;\n                        }\n                        // Update child's predecessor to point past the removed parent\n                        childToUplift.predecessor = parent.predecessor;\n                    }\n\n                    // Parent node is bypassed, effectively removed. Decrement size again.\n                    --PatriciaTrie.this.size;\n\n                } else { // Parent becomes external node (bitIndex is now -1 conceptually)\n                    // Parent now has only back-pointers (or null). It should adopt the key/value of the sibling.\n\n                    // *** THE FIX ***\n                    // The sibling is the 'originalSibling' found before modifying parent's links.\n                    TrieEntry<K, V> sibling = originalSibling;\n\n                    // Check if sibling is null (shouldn't happen if parent was internal originally)\n                    if (sibling == null) {\n                        throw new IllegalStateException(\"Sibling node is unexpectedly null when parent becomes external\");\n                    }\n\n                    // Parent adopts the key/value of the sibling.\n                    parent.key = sibling.getKeyOrNull();\n                    parent.value = sibling.getValue();\n                    parent.left = null;  // Now external\n                    parent.right = null; // Now external\n                    parent.bitIndex = -1; // Mark as external\n\n                    // Update parent's predecessor\n                    // If parent became external, its predecessor should point back up correctly.\n                    // Re-calculating seems safest given the structural change.\n                    if (parent != PatriciaTrie.this.root) {\n                        parent.predecessor = findPredecessor(parent.getKeyOrNull());\n                    } else {\n                        // Root's predecessor is itself\n                        parent.predecessor = parent;\n                    }\n                }\n\n                // Decrement size for the removed nodeToRemove\n                --PatriciaTrie.this.size;\n            }\n\n            // Mark that remove() was called, invalidate current\n            canRemove = false;\n            current = null;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}