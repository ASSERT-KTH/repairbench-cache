{
    "generation": "    /**\n     * Returns the parent of the given entry. If the entry is the root, it\n     * returns the root.\n     * <p>\n     * Note: This method currently doesn't return the root if the root is the\n     * actual parent. Parent can never be null.\n     *\n     * @param entry the entry to find the parent for.\n     * @return the parent entry, or {@code root} if the entry is the root's child.\n     */\n    private TrieEntry<K, V> findParent(final TrieEntry<K, V> entry) {\n        TrieEntry<K, V> current = root.left; // Start search from root's left child\n        TrieEntry<K, V> parent = root;       // Parent starts at root\n\n        while (current != null) {\n            // Stop searching if we descend further than the entry's bit index\n            // or if we hit an external node (leaf).\n            final int bitIndex = entry.bitIndex;\n            final int currentBitIndex = current.bitIndex;\n            if (currentBitIndex >= bitIndex || current.isExternalNode()) {\n                break;\n            }\n\n            // Update parent as we traverse down\n            parent = current;\n\n            // Decide which path to take based on the bit at the current node's index\n            if (isBitSet(entry.getKey(), currentBitIndex)) {\n                current = current.right;\n            } else {\n                current = current.left;\n            }\n        }\n\n        // After the loop, 'parent' holds the node encountered just before 'current'\n        // became null or the loop termination condition was met.\n        // This 'parent' is the candidate parent for the given 'entry'.\n        // This implementation (from Commons Collections 4.1+) ensures 'parent'\n        // is never null if the trie has a root, preventing NPEs in fixUp.\n        return parent;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}