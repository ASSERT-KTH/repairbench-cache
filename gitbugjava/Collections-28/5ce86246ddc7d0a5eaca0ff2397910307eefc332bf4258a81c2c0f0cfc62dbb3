{
    "generation": "    /**\n     * Removes a single entry from the Trie.\n     * <p>\n     * If the entry is internal, it swaps it with a leaf predecessor.\n     *\n     * @param h the Entry to remove.\n     * @return the value of the removed entry.\n     * @throws IllegalStateException if the structure is corrupted, e.g., an internal node has no predecessor.\n     */\n    V removeEntry(TrieEntry<K, V> h) {\n        // Handle removal of the root node if it's the only node (external)\n        // or if h is null (though iterator should prevent null).\n        if (h == null) {\n             // Should not happen with valid usage, but return null defensively.\n             return null;\n        }\n        if (h == root && h.isExternalNode()) {\n            final V oldValue = h.value;\n            root = null;\n            setSize(0); // Assumes setSize(int) method exists\n            incrementModCount(); // Assumes incrementModCount() method exists\n            // Optionally clear fields of 'h' here if needed (e.g., clearNode(h))\n            return oldValue;\n        }\n\n        // If 'h' is an internal node, swap its data with its predecessor 'p',\n        // then proceed to remove the node 'p'. The predecessor is always external.\n        if (!h.isExternalNode()) { // Assumes isExternalNode() method exists\n            TrieEntry<K, V> p = previousEntry(h); // Assumes previousEntry(TrieEntry) method exists\n            // Internal nodes must have a predecessor in a valid trie.\n            if (p == null) {\n                 throw new IllegalStateException(\"Internal node \" + h + \" has no predecessor.\");\n            }\n            // Copy data from predecessor 'p' to 'h'.\n            h.key = p.key;\n            h.value = p.value;\n            // Now, the node to physically remove is the original predecessor 'p'.\n            h = p; // Reassign 'h' to point to the node we will physically remove.\n        }\n\n        // At this point, 'h' refers to the node to be physically removed,\n        // and it's guaranteed to be an external node.\n        final V oldValue = h.value;\n\n        // Unlink 'h' from the doubly-linked predecessor/successor chain.\n        final TrieEntry<K, V> predecessor = h.predecessor;\n        final TrieEntry<K, V> successor = h.successor;\n        if (predecessor != null) {\n            predecessor.successor = successor;\n        }\n        if (successor != null) {\n            successor.predecessor = predecessor;\n        }\n\n        // Get the parent 'p' of the node 'h' to be removed.\n        final TrieEntry<K, V> p = h.parent;\n\n        // 'h' must have a parent unless it was the root (handled earlier).\n        if (p == null) {\n             // This state should not be reachable if the root handling and internal node swap are correct.\n             throw new IllegalStateException(\"Node \" + h + \" to be removed has null parent unexpectedly.\");\n        }\n\n        // Remove 'h' as a child of 'p'.\n        if (h == p.left) {\n            p.left = null;\n        } else { // h == p.right\n            p.right = null;\n        }\n\n        // Fixup: After removing 'h', the parent 'p' might become redundant or\n        // need its structural predecessor (uplink) updated.\n        // This is relevant only if 'p' is an internal node AND its bit test\n        // was relevant for distinguishing 'h' (p.bitIndex > h.bitIndex).\n        if (!p.isExternalNode() && p.bitIndex > h.bitIndex) { // Assumes isExternalNode() and bitIndex exist\n            // Check if 'p' used 'h' as its structural predecessor (uplink).\n            if (p.predecessor == h) {\n                // 'p's uplink pointed to the node we just removed ('h'). We need to fix 'p'.\n                // Find the node 'previous' that logically precedes 'p' in the trie structure.\n                TrieEntry<K, V> previous = previousEntry(p); // Assumes previousEntry(TrieEntry) exists\n                // Check if 'previous' is suitable to become the new uplink for 'p'\n                // based on its bitIndex relative to 'p's bitIndex.\n                if (previous != null && previous.bitIndex >= p.bitIndex) {\n                    // 'previous' is structurally before 'p's split point and is the correct new predecessor (uplink) for 'p'.\n                    p.predecessor = previous;\n                } else {\n                    // No suitable 'previous' node found to be the new uplink.\n                    // This implies that 'p's bit test is now redundant because\n                    // its structural integrity (via the uplink to 'h') is broken.\n                    // 'p' must be removed and replaced by its *other* child.\n                    // Since p.predecessor was 'h' (which must be in the left subtree of 'p'),\n                    // the other child must be p.right.\n                    final TrieEntry<K, V> child = p.right; // The remaining child of 'p'.\n                    final TrieEntry<K, V> gparent = p.parent; // Grandparent of 'p'.\n\n                    // Link grandparent directly to the child, effectively removing 'p'.\n                    if (gparent != null) {\n                        if (p == gparent.left) {\n                            gparent.left = child;\n                        } else { // p == gparent.right\n                            gparent.right = child;\n                        }\n                    } else {\n                        // 'p' was the root, so the child becomes the new root.\n                        root = child;\n                    }\n\n                    // Update the child's parent pointer to skip 'p'.\n                    if (child != null) {\n                        child.parent = gparent;\n                    }\n                    // 'p' is now removed from the tree structure.\n                }\n            }\n        }\n\n        // Decrement size and increment modification count.\n        size--; // Assumes size is an instance variable\n        incrementModCount(); // Assumes incrementModCount() method exists\n\n        // Optionally clear fields of the removed node 'h' to help GC\n        // For example: clearNode(h); // Assumes clearNode helper exists\n\n        return oldValue;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}