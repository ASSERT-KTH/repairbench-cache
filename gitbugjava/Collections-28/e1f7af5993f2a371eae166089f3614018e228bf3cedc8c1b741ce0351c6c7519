{
    "generation": "    /**\n     * Removes an external entry from the Trie.\n     * <p>\n     * If {@code h} is an external node, we replace its parent {@code p} with\n     * {@code h}'s sibling {@code s}. We then update the bitIndex of {@code s}\n     * and the uplink of the node on the other side of the uplink.\n     *\n     * @param h the external entry to remove.\n     * @throws IllegalArgumentException if {@code h} is not an external node.\n     */\n    private void removeExternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            root = null;\n            return;\n        }\n\n        if (!h.isExternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n        }\n\n        final TrieEntry<K, V> p = h.parent;\n        final TrieEntry<K, V> sibling = p.left == h ? p.right : p.left;\n\n        if (p.parent == null) { // If 'p' was the root.\n            sibling.parent = null; // Sibling is the new root.\n            root = sibling;\n            // Fix uplink of the sibling if it is internal.\n            if (root != null && root.isInternalNode()) {\n                fixUplink(sibling.left == null ? sibling.right : sibling.left);\n            }\n        } else { // If 'p' was not the root.\n            final TrieEntry<K, V> grandParent = p.parent;\n            // Update the grandparent's child pointer.\n            if (grandParent.left == p) {\n                grandParent.left = sibling;\n            } else {\n                // If it wasn't left, it must be right.\n                grandParent.right = sibling;\n            }\n            // Update the sibling's parent pointer.\n            // This was the location of the bug fixed in COLLECTIONS-511 / r1595741 & r1595979\n            // The parent pointer must always be updated.\n            sibling.parent = grandParent;\n\n            // Fix uplink of the sibling if it is internal.\n            if (sibling.isInternalNode()) {\n                fixUplink(sibling.left == null ? sibling.right : sibling.left);\n            }\n            // If sibling is external, check if its uplink needs fixing\n            // because 'p' was removed.\n            else if (sibling.uplink == p) {\n                // The sibling's uplink was pointing to the node 'p' being removed.\n                // It should now point to the node that 'p' was pointing to.\n                // This doesn't seem right based on Patricia Trie structure.\n                // Re-evaluating fixUplink's role: It traverses *up* from an external node.\n                // When 'p' is removed and replaced by 'sibling', if 'sibling' is external,\n                // we need to ensure nodes *below* grandparent that pointed to 'p' are updated.\n                // The fixUplink call when sibling is internal handles subtrees.\n                // If sibling is external, we might need to fix uplinks starting from sibling itself.\n                 fixUplink(sibling); // Call fixUplink starting from the external sibling node.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}