{
    "generation": "    private Object decodeCan(Channel channel, SocketAddress remoteAddress, String sentence) throws ParseException {\n        Position position = new Position(getProtocolName());\n\n        int index = 0;\n        // Remove checksum if present\n        if (sentence.endsWith(\"$\")) {\n            sentence = sentence.substring(0, sentence.length() - 1);\n            int checksumIndex = sentence.lastIndexOf(',');\n            if (checksumIndex != -1) {\n                sentence = sentence.substring(0, checksumIndex);\n            }\n        }\n        String[] values = sentence.split(\",\");\n\n        index += 1; // header\n        index += 1; // protocol version\n\n        if (index >= values.length) {\n            throw new ParseException(\"Missing device ID\", index);\n        }\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, values[index++]);\n        if (deviceSession == null) {\n            return null; // Device unknown\n        }\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        index += 1; // device name\n        index += 1; // report type\n        index += 1; // canbus state\n\n        long reportMask = 0;\n        if (index < values.length && !values[index].isEmpty()) {\n            try {\n                reportMask = Long.parseLong(values[index], 16);\n            } catch (NumberFormatException e) {\n                throw new ParseException(\"Invalid reportMask: \" + values[index], index);\n            }\n        } else if (index >= values.length) {\n             throw new ParseException(\"Missing reportMask\", index);\n        } // else: reportMask is empty string, parsed as 0\n        index++;\n\n        long reportMaskExt = 0;\n\n        // Helper lambda to safely parse integer and ignore errors\n        java.util.function.Consumer<Integer> parseIntAndSet = (bitIndex) -> {\n            if (index < values.length && !values[index].isEmpty()) {\n                try { Integer.parseInt(values[index]); } catch (NumberFormatException e) { /* Ignore */ }\n            }\n            index++;\n        };\n        // Helper lambda to safely parse double and ignore errors\n        java.util.function.Consumer<Integer> parseDoubleAndSet = (bitIndex) -> {\n            if (index < values.length && !values[index].isEmpty()) {\n                try { Double.parseDouble(values[index]); } catch (NumberFormatException e) { /* Ignore */ }\n            }\n            index++;\n        };\n\n        // Process fields based on reportMask, always increment index if bit is set\n        if (BitUtil.check(reportMask, 0)) { // VIN\n            if (index < values.length) { position.set(Position.KEY_VIN, values[index]); } index++;\n        }\n        if (BitUtil.check(reportMask, 1)) { // Ignition\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_IGNITION, Integer.parseInt(values[index]) > 0); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 2)) { // Odometer\n            if (index < values.length) { position.set(Position.KEY_OBD_ODOMETER, values[index]); } index++;\n        }\n        if (BitUtil.check(reportMask, 3)) { // Fuel Used\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_FUEL_USED, Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 5)) { // RPM\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_RPM, Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 4)) { // OBD Speed\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_OBD_SPEED, UnitsConverter.knotsFromKph(Integer.parseInt(values[index]))); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 6)) { // Coolant Temp\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 7)) { // Fuel Consumption\n            if (index < values.length && !values[index].isEmpty()) { String v = values[index]; if (v.length() > 1) { try { position.set(Position.KEY_FUEL_CONSUMPTION, Double.parseDouble(v.substring(1))); } catch (NumberFormatException e) { /* Ignore */ } } } index++;\n        }\n        if (BitUtil.check(reportMask, 8)) { // Fuel Level\n            if (index < values.length && !values[index].isEmpty()) { String v = values[index]; if (v.length() > 1) { try { position.set(Position.KEY_FUEL_LEVEL, Double.parseDouble(v.substring(1))); } catch (NumberFormatException e) { /* Ignore */ } } } index++;\n        }\n        if (BitUtil.check(reportMask, 9)) { // Range\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"range\", Long.parseLong(values[index]) * 100); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 10)) { // Throttle\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_THROTTLE, Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 11)) { // Hours\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_HOURS, UnitsConverter.msFromHours(Double.parseDouble(values[index]))); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 12)) { // Driving Time\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_DRIVING_TIME, Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 13)) { // Idle Hours\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"idleHours\", Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 14)) { // Idle Fuel Consumption\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"idleFuelConsumption\", Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 15)) { // Axle Weight\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.KEY_AXLE_WEIGHT, Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 16)) { // Tachograph Info\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"tachographInfo\", Integer.parseInt(values[index], 16)); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 17)) { // Indicators\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"indicators\", Integer.parseInt(values[index], 16)); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 18)) { // Lights\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"lights\", Integer.parseInt(values[index], 16)); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 19)) { // Doors\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"doors\", Integer.parseInt(values[index], 16)); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 20)) { // Vehicle Overspeed\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"vehicleOverspeed\", Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        if (BitUtil.check(reportMask, 21)) { // Engine Overspeed\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"engineOverspeed\", Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } index++;\n        }\n        for (int i = 22; i <= 28; i++) { if (BitUtil.check(reportMask, i)) { if (index < values.length) { index++; } } } // Skip unused fields, check bounds\n\n        if (BitUtil.check(reportMask, 29)) { // Report Mask Ext\n             if (index < values.length && !values[index].isEmpty()) { try { reportMaskExt = Long.parseLong(values[index], 16); } catch (NumberFormatException e) { throw new ParseException(\"Invalid reportMaskExt: \" + values[index], index); } }\n             if (index < values.length) { index++; } // Check bounds before incrementing\n        }\n\n        // Process fields based on reportMaskExt, always increment index if bit is set\n        if (BitUtil.check(reportMaskExt, 0)) { // AdBlue Level\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"adBlueLevel\", Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 1)) { // Axle Weight 1\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"axleWeight1\", Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 2)) { // Axle Weight 3\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"axleWeight3\", Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 3)) { // Axle Weight 4\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(\"axleWeight4\", Integer.parseInt(values[index])); } catch (NumberFormatException e) { /* Ignore */ } } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 4)) { if (index < values.length) { index++; } } // Tachograph Overspeed\n        if (BitUtil.check(reportMaskExt, 5)) { if (index < values.length) { index++; } } // Tachograph Motion\n        if (BitUtil.check(reportMaskExt, 6)) { if (index < values.length) { index++; } } // Tachograph Direction\n        if (BitUtil.check(reportMaskExt, 7)) { // ADC 1\n            if (index < values.length && !values[index].isEmpty()) { try { position.set(Position.PREFIX_ADC + 1, Integer.parseInt(values[index]) * 0.001); } catch (NumberFormatException e) { /* Ignore */ } } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 8)) { if (index < values.length) { index++; } } // Pedal Breaking Factor\n        if (BitUtil.check(reportMaskExt, 9)) { if (index < values.length) { index++; } } // Engine Breaking Factor\n        if (BitUtil.check(reportMaskExt, 10)) { if (index < values.length) { index++; } } // Total Accelerator Kick-downs\n        if (BitUtil.check(reportMaskExt, 11)) { if (index < values.length) { index++; } } // Total Effective Engine Speed\n        if (BitUtil.check(reportMaskExt, 12)) { if (index < values.length) { index++; } } // Total Cruise Control Time\n        if (BitUtil.check(reportMaskExt, 13)) { if (index < values.length) { index++; } } // Total Accelerator Kick-down Time\n        if (BitUtil.check(reportMaskExt, 14)) { if (index < values.length) { index++; } } // Total Brake Application\n        if (BitUtil.check(reportMaskExt, 15)) { // Driver 1 Card\n            if (index < values.length) { position.set(\"driver1Card\", values[index]); } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 16)) { // Driver 2 Card\n            if (index < values.length) { position.set(\"driver2Card\", values[index]); } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 17)) { // Driver 1 Name\n            if (index < values.length) { position.set(\"driver1Name\", values[index]); } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 18)) { // Driver 2 Name\n            if (index < values.length) { position.set(\"driver2Name\", values[index]); } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 19)) { // Registration\n            if (index < values.length) { position.set(\"registration\", values[index]); } if (index < values.length) { index++; }\n        }\n        if (BitUtil.check(reportMaskExt, 20)) { if (index < values.length) { index++; } } // Expansion Information\n        if (BitUtil.check(reportMaskExt, 21)) { if (index < values.length) { index++; } } // Rapid Brakings\n        if (BitUtil.check(reportMaskExt, 22)) { if (index < values.length) { index++; } } // Rapid Accelerations\n        if (BitUtil.check(reportMaskExt, 23)) { if (index < values.length) { index++; } } // Engine Torque\n        for (int i = 24; i <= 31; i++) { if (BitUtil.check(reportMaskExt, i)) { if (index < values.length) { index++; } } } // Skip unused fields\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyyMMddHHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        // Location Block\n        if (BitUtil.check(reportMask, 30)) {\n            // Skip empty fields before validity\n            while (index < values.length && values[index].isEmpty()) { index++; }\n\n            boolean blockHasGps = true; // Assume true initially, set false if issues found\n            // Validity\n            if (index < values.length && !values[index].isEmpty()) { try { position.setValid(Integer.parseInt(values[index]) > 0); } catch (NumberFormatException e) { position.setValid(false); blockHasGps = false; } } else { position.setValid(false); blockHasGps = false; } if (index < values.length) { index++; }\n            // Speed\n            if (index < values.length && !values[index].isEmpty()) { try { position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(values[index]))); } catch (NumberFormatException e) { blockHasGps = false; } } else { blockHasGps = false; } if (index < values.length) { index++; }\n            // Course\n            if (index < values.length && !values[index].isEmpty()) { try { position.setCourse(Integer.parseInt(values[index])); } catch (NumberFormatException e) { blockHasGps = false; } } else { blockHasGps = false; } if (index < values.length) { index++; }\n            // Altitude\n            if (index < values.length && !values[index].isEmpty()) { try { position.setAltitude(Double.parseDouble(values[index])); } catch (NumberFormatException e) { blockHasGps = false; } } else { blockHasGps = false; } if (index < values.length) { index++; }\n            // Longitude\n            if (index < values.length && !values[index].isEmpty()) { try { position.setLongitude(Double.parseDouble(values[index])); } catch (NumberFormatException e) { blockHasGps = false; } } else { blockHasGps = false; } if (index < values.length) { index++; }\n            // Latitude\n            if (index < values.length && !values[index].isEmpty()) { try { position.setLatitude(Double.parseDouble(values[index])); } catch (NumberFormatException e) { blockHasGps = false; } } else { blockHasGps = false; } if (index < values.length) { index++; }\n            // Time\n            Date gpsTime = null; if (index < values.length && !values[index].isEmpty()) { try { gpsTime = dateFormat.parse(values[index]); position.setTime(gpsTime); } catch (ParseException | NumberFormatException e) { blockHasGps = false; } } else { blockHasGps = false; } if (index < values.length) { index++; }\n\n            if (!blockHasGps) { // If any field was missing/invalid\n                position.setValid(false); // Ensure validity is false\n                position.setFixTime(null); // Clear potentially partial time\n                position.setLatitude(0); position.setLongitude(0); // Clear coordinates\n                getLastLocation(position, null);\n            }\n        } else {\n            position.setValid(false);\n            getLastLocation(position, null);\n        }\n\n        // Cell Info (Bit 31)\n        if (BitUtil.check(reportMask, 31)) {\n            if (index < values.length) { index += 4; } // cell - check bounds before skipping\n            if (index < values.length) { index += 1; } // reserved - check bounds before skipping\n        }\n\n        // Device Time\n        Date deviceTime = null;\n        if (index < values.length && !values[index].isEmpty()) {\n             try {\n                 deviceTime = dateFormat.parse(values[index]);\n                 position.setDeviceTime(deviceTime);\n             } catch (ParseException e) { /* Ignore invalid device time */ }\n        }\n        // Don't increment index after last field access\n\n         // Time logic: Use GPS time if available and valid. Otherwise, use device time.\n         if (position.getFixTime() == null && deviceTime != null) {\n             getLastLocation(position, deviceTime); // Use device time for location estimate\n             position.setTime(deviceTime);\n             // If we estimated a location, mark position as valid\n             if (position.getLatitude() != 0 || position.getLongitude() != 0) {\n                position.setValid(true);\n             } else {\n                 // If getLastLocation failed, keep validity potentially false (depends on getLastLocation behavior)\n                 // Let's assume getLastLocation sets validity if successful\n             }\n         }\n\n         if (ignoreFixTime && deviceTime != null) {\n             position.setTime(deviceTime); // Override fix time if needed\n             // If overriding time potentially invalidates GPS fix, ensure validity reflects this?\n             // Assuming ignoreFixTime implies deviceTime is the primary source of truth.\n             if (position.getLatitude() == 0 && position.getLongitude() == 0) {\n                 getLastLocation(position, deviceTime);\n                 if (position.getLatitude() != 0 || position.getLongitude() != 0) {\n                     position.setValid(true);\n                 } else {\n                     position.setValid(false); // Can't be valid without coordinates\n                 }\n             } else {\n                  position.setValid(true); // Has coordinates and a time source\n             }\n\n         }\n\n        // If still no time, BaseProtocolDecoder might set server time.\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}