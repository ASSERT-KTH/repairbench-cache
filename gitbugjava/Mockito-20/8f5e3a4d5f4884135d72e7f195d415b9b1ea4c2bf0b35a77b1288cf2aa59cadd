{
    "generation": "    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n\n        // Select the appropriate instantiator based on settings\n        // Use the internal Instantiator interface and implementations\n        org.mockito.internal.creation.instance.Instantiator instantiator;\n        if (settings.isUsingConstructor()) {\n            // Explicitly requested constructor use\n            instantiator = new org.mockito.internal.creation.instance.ConstructorInstantiator(\n                    settings.getOuterClassInstance(), settings.getConstructorArgs());\n        } else if (settings.isSpy() && settings.getSpiedInstance() == null) {\n            // Spy based on class requires constructor invocation (usually default constructor)\n            // Pass null for args to let ConstructorInstantiator find the default constructor.\n            instantiator = new org.mockito.internal.creation.instance.ConstructorInstantiator(\n                    settings.getOuterClassInstance(), null);\n        } else {\n            // Standard mock or spy on existing instance: Use the default instantiator (likely Objenesis)\n            // Assumes 'this.classInstantiator' is compatible with org.mockito.internal.creation.instance.Instantiator\n            instantiator = this.classInstantiator;\n        }\n\n        T mockInstance = null;\n        try {\n            // Instantiate the proxy class using the selected instantiator\n            // Assumes the internal Instantiator interface uses newInstance method\n            mockInstance = instantiator.newInstance(mockedProxyType);\n\n            // Set the interceptor\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            // Ensure type compatibility\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (ClassCastException cce) {\n            // Provide a more informative error message for ClassCastException\n            throw new MockitoException(join(\n                    \"ClassCastException occurred while creating the mockito mock:\",\n                    \"  Requested type to mock: '\" + describeClass(settings.getTypeToMock()) + \"'\",\n                    \"  Generated proxy type: '\" + describeClass(mockedProxyType) + \"'\",\n                    \"  Proxy instance class: '\" + describeClass(mockInstance) + \"'\", // describeClass should handle null safely\n                    \"  Instance created by: \" + instantiator.getClass().getSimpleName(),\n                    \"\",\n                    \"You might experience classloading issues, potentially related to multiple classloaders.\",\n                    \"Underlying exception: \" + cce\n            ), cce);\n        } catch (org.mockito.creation.instance.InstantiationException e) { // Catch the specific InstantiationException\n            // Use the simple name of the type being mocked, as expected by tests\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'\", e);\n        }\n        // Catch other potential instantiation errors, though InstantiationException should cover most cases\n        catch (Exception e) {\n             throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'\", e);\n        }\n    }\n\n    // Helper methods assumed to be available in the class scope:\n    // abstract MockHandlerInterface asInternalMockHandler(MockHandler handler);\n    // abstract <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mockInstance);\n    // static String describeClass(Class<?> type); // Example: type == null ? \"null\" : type.getName();\n    // static String describeClass(Object instance); // Example: instance == null ? \"null\" : instance.getClass().getName();\n    // static String join(String... lines); // From Mockito's StringJoiner\n    // private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator;\n    // private final org.mockito.internal.creation.instance.Instantiator classInstantiator; // Assumed field",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}