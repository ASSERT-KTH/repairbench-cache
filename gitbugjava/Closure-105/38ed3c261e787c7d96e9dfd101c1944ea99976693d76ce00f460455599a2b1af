{
    "generation": "import com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.List;\n\n// Assume PeepholeFoldConstants, InlineCostEstimator, NodeUtil are defined elsewhere\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // --- Initial checks ---\n    // Ensure the call is of the form: [..].join(<immutable>)\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    // GETPROP's second child is the property name.\n    Node functionName = left.getLastChild();\n\n    // Check if it's ARRAYLIT.join\n    if (arrayNode == null || !arrayNode.isArrayLit() ||\n        functionName == null || !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    // We already checked isImmutableValue, but getStringValue might fail for non-primitive Number etc.\n    if (joinString == null) {\n        // This may happen for new Number(5). We consider this non-foldable.\n        return;\n    }\n\n    // --- Prepare folding ---\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    // Flag indicating if the StringBuilder (`sb`) has content from the\n    // previous array element(s). Used to decide whether to add `joinString`.\n    boolean sbHasContent = false;\n    // Flag to track if any merging of adjacent immutables or stringification\n    // of non-string immutables occurred.\n    boolean didFold = false;\n    Node elem = arrayNode.getFirstChild();\n    int originalChildrenSize = arrayNode.getChildCount();\n    boolean containsNonImmutable = false;\n\n    // --- Iterate and fold adjacent immutable elements ---\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        // Append joinString *before* adding the element's string value\n        // if sb already contains content from a previous element.\n        if (sbHasContent) {\n          sb.append(joinString);\n           // If we append a non-empty join string, that counts as folding.\n          if (!joinString.isEmpty()) {\n              didFold = true;\n          }\n        }\n        String elemValue = NodeUtil.getStringValue(elem);\n        if (elemValue == null) {\n          // Cannot get string value for immutable element, should not happen? Bail out.\n          return;\n        }\n        sb.append(elemValue);\n        // If the element wasn't originally a string, converting it counts as folding.\n        if (!elem.isString()) {\n            didFold = true;\n        }\n        sbHasContent = true;\n      } else {\n        containsNonImmutable = true;\n        // Non-immutable element: finalize previous folded string (if any)\n        if (sbHasContent) {\n          // Add the folded string accumulated so far.\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder(); // Reset sb\n          sbHasContent = false; // Reset flag\n          didFold = true; // Finalizing a non-empty sb means folding happened.\n        }\n        // Add the non-immutable element (cloned, as it will be part of a new structure)\n        arrayFoldedChildren.add(elem.cloneTree());\n      }\n      elem = elem.getNext();\n    }\n\n    // --- Finalize last folded string (if any) ---\n    if (sbHasContent) {\n      // Add the remaining folded string.\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n       // If the only action was processing a single initial immutable string,\n       // it doesn't count as a fold unless subsequent elements were joined.\n       // However, the didFold flag should already capture merges and stringification.\n       // If sb has content here, it means at least one immutable element was processed.\n       // If the final list size is smaller than original, it's definitely a fold.\n       if (arrayFoldedChildren.size() < originalChildrenSize) {\n            didFold = true;\n       }\n    }\n\n    // --- Check if any effective change occurred ---\n    // If the list size is the same, no non-immutables were involved (and cloned),\n    // and no merging/stringification occurred, then nothing changed.\n    if (arrayFoldedChildren.size() == originalChildrenSize && !didFold && !containsNonImmutable) {\n        return;\n    }\n\n\n    // --- Estimate cost and decide on replacement ---\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacementNode = null;\n\n    switch (arrayFoldedChildren.size()) {\n      case 0: // Folded to empty string \"\" e.g. [].join()\n        replacementNode = Node.newString(\"\");\n        break; // Add break\n\n      case 1: // Folded to single element e.g., ['a','b'].join() -> \"ab\", [foo].join() -> \"\" + foo\n        Node foldedNode = arrayFoldedChildren.get(0);\n        // If the single element isn't a string constant, it must be coerced.\n        if (foldedNode.getType() != Token.STRING) {\n          // Coerce non-string results (like a single variable element) to string: \"\" + node\n          replacementNode = new Node(Token.ADD, Node.newString(\"\"), foldedNode);\n        } else {\n          // Result is a single string constant\n          replacementNode = foldedNode;\n        }\n        break; // Add break\n\n      default: // Folded to new array join: [folded elems].join(separator)\n        // Example: ['a', foo, 'b', 'c'].join(',') -> [\"a\", foo, \"b,c\"].join(',')\n\n        // Create the new array literal for the call\n        Node newArrayLit = new Node(Token.ARRAYLIT);\n        for (Node node : arrayFoldedChildren) {\n          newArrayLit.addChildToBack(node); // Add the actual nodes (clones/new strings)\n        }\n        // Build the new call structure: newArray.join(right)\n        Node newJoin = new Node(Token.GETPROP, newArrayLit, Node.newString(\"join\"));\n        // Clone 'right' for safety, as it's part of the new structure.\n        Node newCall = new Node(Token.CALL, newJoin, right.cloneTree());\n        replacementNode = newCall;\n        break; // Add break\n    }\n\n    // --- Check size and perform replacement ---\n    if (replacementNode == null) {\n       // Should not happen given the switch logic\n       return;\n    }\n\n    // Estimate cost of the replacement\n    // Copy source info before calculating cost, as cost might depend on it.\n    replacementNode.copyInformationFromForTree(n);\n    int foldedSize = InlineCostEstimator.getCost(replacementNode);\n\n    // Only replace if the folded code is smaller than the original.\n    // Using \">\" ensures we don't replace with code of the same size or larger.\n    if (foldedSize >= originalSize) {\n      return; // Not smaller\n    }\n\n    // Perform replacement\n    parent.replaceChild(n, replacementNode);\n    t.getCompiler().reportCodeChange();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}