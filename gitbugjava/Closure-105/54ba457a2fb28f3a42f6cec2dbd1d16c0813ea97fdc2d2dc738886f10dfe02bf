{
    "generation": "import com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.InlineCostEstimator;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n// Note: NodeTraversal, Compiler classes are assumed to exist elsewhere.\n// Placeholders provided for context if needed:\n/*\nclass NodeTraversal {\n  private Compiler compiler;\n  public NodeTraversal(Compiler compiler) { this.compiler = compiler; }\n  public Compiler getCompiler() { return compiler; }\n}\nclass Compiler {\n  public void reportCodeChange() {}\n}\n*/\n\n/**\n * Folds array joins, such as ['a', 'b'].join('') -> \"ab\".\n * Handles constant elements (strings, numbers, booleans, null, undefined)\n * and leaves non-constant elements in place, potentially merging adjacent\n * constants. ['a', x, 'b', 'c'].join(',') -> ['a', x, 'b,c'].join(',')\n */\nclass PeepholeFoldConstants { // Assumed class name\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // Ensure the structure is array.join(separator)\n    // n is the CALL node, left is the GETPROP node (array.join), right is the separator argument.\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = left.getLastChild(); // The property name \"join\"\n\n    // Check if it's an array literal and the function is \"join\"\n    if (arrayNode.getType() != Token.ARRAYLIT ||\n        !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    // Need a constant string separator to perform folding.\n    if (joinString == null) {\n      return;\n    }\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder currentConstantSegment = new StringBuilder();\n    Node elem = arrayNode.getFirstChild();\n    boolean canFoldEverythingToConstant = true; // Assume full folding is possible initially\n    Node lastConstant = null; // Keep track of last constant node for source info\n\n    // Iterate through the elements of the array literal\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        // Append the constant value, using joinString as separator if needed\n        if (currentConstantSegment.length() > 0) {\n          currentConstantSegment.append(joinString);\n        }\n        currentConstantSegment.append(NodeUtil.getStringValue(elem));\n        lastConstant = elem; // Remember last constant node processed\n      } else {\n        // Encountered a non-constant element\n        canFoldEverythingToConstant = false;\n\n        // Add the constant segment accumulated so far (if any)\n        if (currentConstantSegment.length() > 0) {\n          Node foldedString = Node.newString(currentConstantSegment.toString());\n          // Copy source info from the last constant node that contributed to this segment\n          if (lastConstant != null) {\n              foldedString.copyInformationFrom(lastConstant);\n          }\n          arrayFoldedChildren.add(foldedString);\n          currentConstantSegment = new StringBuilder(); // Reset for the next segment\n        }\n        // Add the non-constant element (cloned, as original nodes will be detached)\n        arrayFoldedChildren.add(elem.cloneTree());\n        lastConstant = null; // Reset last constant tracker\n      }\n      Node next = elem.getNext(); // Store next before detaching/modifying elem if necessary\n      elem = next;\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacement = null;\n\n    if (canFoldEverythingToConstant) {\n      // All elements were constants, the result is a single string.\n      Node foldedString = Node.newString(currentConstantSegment.toString());\n      // Copy source info from the original call node `n` if no specific constant was found,\n      // otherwise, use the last constant's info potentially.\n      foldedString.copyInformationFrom(n);\n      replacement = foldedString;\n    } else {\n      // Mixed constants and non-constants.\n      // Add the final constant segment if it exists.\n      if (currentConstantSegment.length() > 0) {\n         Node foldedString = Node.newString(currentConstantSegment.toString());\n         // Copy source info from the last constant node that contributed.\n         if (lastConstant != null) {\n             foldedString.copyInformationFrom(lastConstant);\n         } else {\n             // Fallback to original call node info if last segment had no source node\n             foldedString.copyInformationFrom(n);\n         }\n         arrayFoldedChildren.add(foldedString);\n      }\n\n      // If the resulting array has the same or more elements than the original,\n      // then no structural simplification was possible (e.g., [foo, bar].join(',') ).\n      if (arrayFoldedChildren.size() >= arrayNode.getChildCount()) {\n         return; // No reduction in elements.\n      }\n\n      // If folding resulted in an empty list (e.g., `['', '']` with `canFoldEverythingToConstant=true`\n      // should have been handled above, resulting in `\"\"`), this path implies multiple elements remain.\n      // Build the new array literal node\n      Node newArray = new Node(Token.ARRAYLIT);\n      // Copy source info from original array\n      newArray.copyInformationFrom(arrayNode);\n      for (Node node : arrayFoldedChildren) {\n        newArray.addChildToBack(node); // Nodes are already new strings or clones\n      }\n\n      // Build the new GETPROP node\n      Node newGetProp = new Node(Token.GETPROP, newArray, Node.newString(\"join\"));\n      newGetProp.copyInformationFrom(left); // Copy source info from original GETPROP\n\n      // Build the new CALL node\n      Node newCall = new Node(Token.CALL, newGetProp);\n      newCall.copyInformationFrom(n); // Copy source info from original CALL\n      newCall.addChildToBack(right.cloneTree()); // Add cloned separator argument\n\n      replacement = newCall;\n    }\n\n    // Perform replacement if beneficial and the node actually changed\n    if (replacement != null) {\n      int replacementSize = InlineCostEstimator.getCost(replacement);\n      // Only replace if the new node is smaller or equal in size and is semantically different.\n      // Note: isEquivalentTo checks structure and values, not just cost.\n      if (replacementSize <= originalSize && !n.isEquivalentTo(replacement)) {\n        parent.replaceChild(n, replacement);\n        t.getCompiler().reportCodeChange();\n      }\n    }\n  }\n} // End assumed class",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}