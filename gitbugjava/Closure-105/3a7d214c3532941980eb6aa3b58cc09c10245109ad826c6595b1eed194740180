{
    "generation": "import com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.List;\n\n// This class definition is just for context; assume it's part of a larger class\n// like PeepholeFoldConstants where NodeUtil and InlineCostEstimator are accessible.\nclass DummyPeepholeFoldConstants {\n\n  // Assume NodeUtil, InlineCostEstimator, and Compiler are available through instance members or context.\n  // For example: private final AbstractCompiler compiler; (needed for reportCodeChange)\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // Structure check: n = CALL, left = GETPROP, right = separator\n    // left = GETPROP, left.firstChild = arrayNode, left.lastChild = \"join\"\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    // Use getLastChild() for robustness, as arrayNode might have JSDoc info attached\n    // between the node and its children/next sibling.\n    Node functionName = left.getLastChild();\n\n    // Guard against unexpected structure or non-string property access\n    // Make sure the property is the string \"join\".\n    if (arrayNode == null || !arrayNode.isArrayLit() || functionName == null || !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    // NodeUtil.getStringValue correctly converts immutable types (number, boolean, null, undefined) to string.\n    // According to ECMA-262, the separator is converted to String.\n    // If for some reason it returns null (unexpected for immutables), bail out.\n    if (joinString == null) {\n        // This is unlikely for immutable values but provides robustness.\n        return;\n    }\n\n\n    // Build the new list of children, merging adjacent immutable elements.\n    List<Node> arrayFoldedChildren = Lists.newArrayList();\n    StringBuilder currentStringBuilder = null; // Accumulator for adjacent immutables\n\n    for (Node elem = arrayNode.getFirstChild(); elem != null; elem = elem.getNext()) {\n      // Check for actual element nodes; skip empty slots like in [,,,]\n      if (elem.isEmpty()) {\n           // Add separator if previous element was immutable.\n           if (currentStringBuilder != null) {\n               currentStringBuilder.append(joinString);\n           }\n           // Handle consecutive separators from empty slots.\n           // If the last element added was non-immutable, add separator before this empty one.\n           // If the last element was immutable (merged to SB), the separator is handled above.\n           // If the string builder is null now, means the last element was non-immutable or start.\n           else if (!arrayFoldedChildren.isEmpty()) {\n              // Need to create an empty string to hold the separator? No, let's treat empty like undefined.\n              // According to JS, [1, , 3].join(',') -> \"1,,3\". Empty becomes empty string.\n              // Treat EMPTY node like an immutable value evaluating to \"\".\n               if (currentStringBuilder == null) {\n                   currentStringBuilder = new StringBuilder();\n               } else {\n                   currentStringBuilder.append(joinString);\n               }\n               // Append nothing for the empty slot itself.\n               // getStringValue(EMPTY) should arguably be \"\". Let's assume NodeUtil handles this or use \"\".\n               currentStringBuilder.append(\"\"); // Append empty string for the empty slot\n\n           } else {\n               // Started with an empty slot. Initialize SB.\n                currentStringBuilder = new StringBuilder();\n                currentStringBuilder.append(\"\"); // Append empty string for the empty slot\n           }\n           continue; // Skip adding EMPTY node to children list directly\n      }\n\n      if (NodeUtil.isImmutableValue(elem)) {\n        // Append to the current string builder\n        if (currentStringBuilder == null) {\n          currentStringBuilder = new StringBuilder();\n        } else {\n          // Add separator if the builder isn't empty (meaning a previous immutable was added)\n          currentStringBuilder.append(joinString);\n        }\n        currentStringBuilder.append(NodeUtil.getStringValue(elem));\n      } else {\n        // Non-immutable element encountered\n        if (currentStringBuilder != null) {\n          // Finalize the previous string segment\n          Node foldedString = Node.newString(currentStringBuilder.toString());\n          // TODO(johnlenz): Copy source info more precisely? Might not be needed as parent replaces `n`.\n          arrayFoldedChildren.add(foldedString);\n          currentStringBuilder = null; // Reset builder\n        }\n        // Add the non-immutable element (reuse original node, do not clone)\n        arrayFoldedChildren.add(elem);\n      }\n    }\n\n    // Finalize any remaining string segment built from immutable values\n    if (currentStringBuilder != null) {\n      Node foldedString = Node.newString(currentStringBuilder.toString());\n      arrayFoldedChildren.add(foldedString);\n    }\n\n    // Calculate size of original expression for comparison\n    int originalSize = InlineCostEstimator.getCost(n);\n\n    // Handle the result based on the number of children in the folded array\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // Original array was empty ([].join(...)) or contained only empty slots/foldable elements resulting in empty.\n        Node emptyStringNode = Node.newString(\"\");\n        // Cost of \"\" is 2. This should always be <= originalSize for [].join(...).\n        // No size check needed, as replacing [].join() or similar with \"\" is always beneficial.\n        emptyStringNode.copyInformationFrom(n);\n        parent.replaceChild(n, emptyStringNode);\n        t.getCompiler().reportCodeChange();\n        break;\n\n      case 1:\n        // Array folded into a single element.\n        Node singleElement = arrayFoldedChildren.get(0);\n        Node replacementNode;\n        int estimatedFoldedSize;\n\n        // Determine the replacement node and its estimated cost\n        if (singleElement.isString()) {\n            // Result is the folded string literal (e.g., \"a,b\")\n            replacementNode = singleElement;\n            // Ensure replacement node has source info before calculating cost\n            replacementNode.copyInformationFrom(n);\n            estimatedFoldedSize = InlineCostEstimator.getCost(replacementNode);\n        } else if (NodeUtil.isImmutableValue(singleElement)) {\n            // Single immutable element that wasn't a string originally (e.g., [5].join(','))\n            // Result is the string representation (e.g., \"5\").\n            replacementNode = Node.newString(NodeUtil.getStringValue(singleElement));\n            replacementNode.copyInformationFrom(n);\n            estimatedFoldedSize = InlineCostEstimator.getCost(replacementNode);\n        } else {\n            // Single element was non-immutable (e.g., [foo].join(','))\n            // Result is \"\" + element (to ensure string coercion like JS)\n            // Create the ADD node first\n            replacementNode = new Node(Token.ADD, Node.newString(\"\"), singleElement);\n            // Copy source info onto the new ADD node structure\n            replacementNode.copyInformationFromForTree(n);\n            // Cost: Cost(\"\") + Cost(+) + Cost(element) -> 2 + 1 + Cost(element) = 3 + Cost(element)\n            estimatedFoldedSize = 3 + InlineCostEstimator.getCost(singleElement);\n        }\n\n        // Only replace if the folded version is smaller or equal in size.\n        // Using \">\" seems conventional for \"only optimize if smaller\"\n        if (estimatedFoldedSize > originalSize) {\n           return;\n        }\n\n        // Perform replacement\n        parent.replaceChild(n, replacementNode);\n        t.getCompiler().reportCodeChange();\n        break;\n\n      default:\n        // Partially folded: Result is [folded1, foo, folded2].join(separator)\n\n        // Calculate the estimated size of the new expression \"[c1, c2,...].join(separator)\"\n        // Using the original code's method for cost calculation for consistency:\n        int foldedSize = 0;\n        for (Node node : arrayFoldedChildren) {\n            // Cost of node inside array literal (e.g., cost(\"abc\"), cost(foo))\n            foldedSize += InlineCostEstimator.getCost(node);\n        }\n        // Add comma costs within the array literal\n        if (!arrayFoldedChildren.isEmpty()) {\n            // N elements require N-1 commas\n            foldedSize += arrayFoldedChildren.size() - 1;\n        }\n        // Add fixed overhead for \"[].join()\" structure\n        int kJoinOverhead = \"[].join()\".length(); // 10, includes [], .join, ()\n        foldedSize += kJoinOverhead;\n        // Add cost of separator argument\n        foldedSize += InlineCostEstimator.getCost(right);\n\n        // Only replace if the folded version is smaller or equal in size.\n        if (foldedSize > originalSize) {\n          return;\n        }\n\n        // Check if the new array contents are structurally identical to the old ones.\n        // If so, no change is needed (avoids unnecessary node manipulation/reporting change).\n        // This check prevents replacing ['a','b'] with [\"a\",\"b\"] if cost is identical.\n        boolean structuralChange = false;\n        if (arrayFoldedChildren.size() != arrayNode.getChildCount()) {\n            structuralChange = true;\n        } else {\n            Node origChild = arrayNode.getFirstChild();\n            for (Node newChild : arrayFoldedChildren) {\n                // Use isEquivalentTo for a more robust check than identity,\n                // handles cases where new string nodes are created with same value, etc.\n                // Also handles comparing original nodes with themselves.\n                if (origChild == null || !newChild.isEquivalentTo(origChild)) {\n                    structuralChange = true;\n                    break;\n                }\n                origChild = origChild.getNext();\n            }\n        }\n\n        if (!structuralChange) {\n            // Content is equivalent, no benefit in replacing.\n            return;\n        }\n\n        // Perform the replacement: Modify the original array node's children.\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          // Nodes in arrayFoldedChildren are either original non-immutables\n          // or newly created STRING nodes. Add them back to the arrayNode.\n          arrayNode.addChildToBack(node);\n        }\n        // Mark that the AST was changed. The overall structure `n` (the CALL node) is preserved.\n        t.getCompiler().reportCodeChange();\n        break;\n    }\n  }\n} // End dummy class definition",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}