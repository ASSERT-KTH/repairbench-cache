{
    "generation": "import com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.InlineCostEstimator;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.List;\n\n/**\n * Contains the fixed version of tryFoldStringJoin.\n * Note: Actual file would not have the DummyPeepholeFoldConstants class wrapper.\n * Assumes necessary imports and class context (like being part of PeepholeFoldConstants).\n */\nfinal class FixedPeepholeFoldConstants { // Wrapper class for context\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // Ensure the call is of the form array.join(separator)\n    // 'left' is the GETPROP node (array.join)\n    // 'right' is the separator argument node\n    // 'n' is the CALL node\n    if (!left.isGetProp() || !NodeUtil.isImmutableValue(right)) {\n      // Separator must be immutable (or at least safely convertible to string) for safe folding.\n      // isImmutableValue covers common cases like string/number literals.\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionNameNode = left.getLastChild(); // Property name (\"join\")\n\n    // Check that it's an array literal and the function is \"join\"\n    if (!arrayNode.isArrayLit() || !functionNameNode.isString() ||\n        !functionNameNode.getString().equals(\"join\")) {\n      return;\n    }\n\n    // Check for side effects in the original call structure, excluding the array elements\n    // which are checked individually later. Side effects in accessing the array,\n    // the 'join' property, or the separator are rare for literals but important.\n     if (NodeUtil.mayHaveSideEffects(left, t.getCompiler()) ||\n         NodeUtil.mayHaveSideEffects(right, t.getCompiler())) {\n         return;\n     }\n\n\n    String joinString = NodeUtil.getArrayElementStringValue(right); // Use safe string conversion\n    if (joinString == null) {\n      // This shouldn't happen if NodeUtil.isImmutableValue(right) is true,\n      // but check just in case getArrayElementStringValue fails.\n      return;\n    }\n\n    List<Node> arrayFoldedChildren = Lists.newArrayList();\n    StringBuilder sb = new StringBuilder();\n    Node elem = arrayNode.getFirstChild();\n    int originalChildCount = arrayNode.getChildCount();\n    boolean sideEffectInFoldedElements = false; // Track if any element we fold away had side effects\n\n    // Merge adjacent foldable (immutable, side-effect free) elements.\n    while (elem != null) {\n      Node nextElem = elem.getNext(); // Store next element in case 'elem' is detached/moved\n\n      // Use getArrayElementStringValue for robust conversion matching join's behavior.\n      String elemStringVal = NodeUtil.getArrayElementStringValue(elem);\n      boolean elementHasSideEffects = NodeUtil.mayHaveSideEffects(elem, t.getCompiler());\n\n      // Check if elem can be represented as a string value for joining AND has no side effects\n      if (elemStringVal != null && !elementHasSideEffects) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        sb.append(elemStringVal);\n        // Mark that some element contributing to sb *might* have had side effects later\n        // sideEffectInFoldedElements = sideEffectInFoldedElements || elementHasSideEffects; // Already checked elementHasSideEffects is false\n      } else { // Element is not foldable (not immutable, not easily stringifiable, or has side effects)\n        sideEffectInFoldedElements = sideEffectInFoldedElements || elementHasSideEffects; // Track side effects in non-folded elements too if needed? No, only matters if we REMOVE the element by folding.\n        // Add the pending string segment if any\n        if (sb.length() > 0) {\n          // Use original node 'n' for source info context? Or perhaps 'elem'? Using 'n' seems reasonable.\n          arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(n));\n          sb = new StringBuilder(); // Reset sb\n        }\n        // Add the non-foldable/side-effectful element itself\n        // Detach elem from the original list before adding to the new list\n        // elem.detach(); // This modification during iteration is tricky. Better to handle detachment at the end.\n        arrayFoldedChildren.add(elem);\n      }\n      elem = nextElem;\n    }\n\n    // Add any remaining string segment\n    if (sb.length() > 0) {\n      arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(n));\n    }\n\n    // Calculate size of the original expression\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node containingNodeToReplace = n; // The CALL node 'n' is what we might replace or modify\n\n\n    // Handle the results based on the number of elements in the folded array\n    switch (arrayFoldedChildren.size()) {\n      case 0: // Original array was empty.\n        if (originalChildCount == 0) {\n            // No elements, so no side effects from them.\n            Node emptyStringNode = Node.newString(\"\").copyInformationFrom(containingNodeToReplace);\n            // Cost of \"\" is 2. Assume it's always smaller than original [].join(...).\n            if (2 < originalSize) {\n                 parent.replaceChild(containingNodeToReplace, emptyStringNode);\n                 t.getCompiler().reportCodeChange();\n            }\n        }\n        // If original was not empty, but folded list is empty (e.g. [undefined].join('')),\n        // the result should be \"\". This case falls under case 1 below.\n        break;\n\n      case 1:\n        Node foldedNode = arrayFoldedChildren.get(0);\n        // If the single resulting element is a string literal...\n        if (foldedNode.isString()) {\n           // We can replace the entire call with the string literal, ONLY IF\n           // no element that got folded *into* this string had side-effects.\n           // sideEffectInFoldedElements tracks if any *kept* elements had side effects.\n           // We need a flag specific to elements *removed* during folding.\n           // Let's simplify: if ANY element in the original array had side effects,\n           // only proceed if the final result is this single string AND all original children were folded.\n           boolean originalHadSideEffects = false;\n           for (Node originalChild = arrayNode.getFirstChild(); originalChild != null; originalChild = originalChild.getNext()) {\n               if (NodeUtil.mayHaveSideEffects(originalChild, t.getCompiler())) {\n                   originalHadSideEffects = true;\n                   break;\n               }\n           }\n\n           if (originalHadSideEffects) {\n               // If original had side effects, cannot replace the call with a simple string,\n               // as side effects would be lost.\n               return;\n           }\n\n           // Now safe to consider replacing with the string node.\n           int foldedCost = InlineCostEstimator.getCost(foldedNode);\n           // Check if the replacement is smaller than the original call node\n           if (foldedCost < originalSize) {\n             // foldedNode is newly created, no need to detach.\n             parent.replaceChild(containingNodeToReplace, foldedNode);\n             t.getCompiler().reportCodeChange();\n           }\n        } else {\n          // Single element is non-foldable (e.g., [foo].join(',')). Call cannot be removed.\n          // Check if the array structure was modified at all. If not ([foo]->[foo]), do nothing.\n          if (originalChildCount == 1 && arrayFoldedChildren.get(0) == arrayNode.getFirstChild()) {\n               // Check if reference is same AND structurally equivalent (belt-and-suspenders)\n               if (arrayNode.getFirstChild().isEquivalentTo(arrayFoldedChildren.get(0))) {\n                 return; // No change\n               }\n          }\n          // If structure changed (e.g. ['a', foo, 'b'].join('') folds to [\"ab\", foo], size 2 -> default),\n          // or if size is 1 non-string but somehow different from original (unlikely),\n          // fall through to default logic to rebuild array if beneficial.\n          // If we reached here with size 1 non-string, it MUST be the original single non-foldable element.\n          return; // No optimization possible for [foo].join(',') -> foo\n        }\n        break;\n\n      default: // Size > 1\n        // Check if any effective folding occurred compared to the original array.\n        boolean changed = (arrayFoldedChildren.size() != originalChildCount);\n        if (!changed) {\n           Node currentOriginal = arrayNode.getFirstChild();\n           boolean contentChanged = false;\n           for (int i = 0; i < arrayFoldedChildren.size(); i++) {\n               Node currentFolded = arrayFoldedChildren.get(i);\n               // Check structural equivalence; reference check isn't enough for new nodes\n               if (!currentOriginal.isEquivalentTo(currentFolded)) {\n                   contentChanged = true;\n                   break;\n               }\n               currentOriginal = currentOriginal.getNext();\n           }\n           if (!contentChanged) {\n               return; // No change needed\n           }\n           changed = true; // Content changed even if size didn't\n        }\n\n        // If we are changing the array structure, calculate the cost of the new structure.\n        // Estimate cost of the new expression: [folded1, folded2, ...].join(separator)\n        int foldedSize = 0;\n        // Cost of the new array literal\n        foldedSize += 2; // Brackets []\n        boolean first = true;\n        for (Node node : arrayFoldedChildren) {\n            if (!first) {\n                foldedSize++; // Comma\n            }\n            // Use getCost for all children (new strings or original nodes)\n            foldedSize += InlineCostEstimator.getCost(node);\n            first = false;\n        }\n\n        // Add cost of separator and join call itself\n        foldedSize += InlineCostEstimator.getCost(right); // Separator cost\n        // Cost of \".join\" property access + call parentheses \"()\"\n        foldedSize += \".join\".length() + 2;\n\n        // Only replace if the folded version is smaller (or equal? Use >= to prevent churn)\n        if (foldedSize >= originalSize) {\n          return; // Not smaller\n        }\n\n        // Apply the changes: replace elements in the original array node.\n        // This modifies the array node in place; the CALL node 'n' remains.\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n           // Nodes in arrayFoldedChildren are either new Node.newString() or original non-foldable nodes.\n           // Original nodes are detached by detachChildren(). New nodes have no parent.\n           // Ensure node is detached if it somehow still has a parent (shouldn't happen).\n           if (node.getParent() != null) {\n                node.detach();\n           }\n          arrayNode.addChildToBack(node);\n        }\n        // Report modification of the CALL node 'n' as its behavior changed due to modified child array.\n        t.getCompiler().reportCodeChange();\n        break;\n    }\n  }\n} // End dummy class wrapper",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}