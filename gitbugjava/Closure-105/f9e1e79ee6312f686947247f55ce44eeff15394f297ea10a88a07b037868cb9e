{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // Ensure the structure is what we expect: array.join(separator)\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild(); // The array literal node\n    Node functionName = arrayNode.getNext(); // The \"join\" string node\n\n    // Check if it's an array literal and the function is \"join\"\n    if (arrayNode == null || !arrayNode.isArrayLit() ||\n        functionName == null || !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    // We can't fold non-string join separators.\n    if (joinString == null) {\n      return;\n    }\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    Node elem = arrayNode.getFirstChild();\n    boolean changed = false;\n    int originalChildCount = arrayNode.getChildCount();\n\n    // Iterate through the array elements, folding adjacent literals\n    while (elem != null) {\n      Node nextElem = elem.getNext(); // Store next element before potential modification/cloning\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb.length() > 0) {\n          sb.append(joinString);\n        }\n        // NodeUtil.getStringValue handles conversion from number, boolean, null etc.\n        String elemStr = NodeUtil.getStringValue(elem);\n        // Should not happen for known immutable types, but check defensively.\n        if (elemStr == null) {\n          // Treat as non-foldable\n          if (sb.length() > 0) {\n            // Try to preserve source info from the element before this problematic one\n            Node sourceInfoNode = sb.length() > 0 && arrayFoldedChildren.isEmpty() ? arrayNode.getFirstChild() : elem;\n            arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(sourceInfoNode));\n            sb = new StringBuilder();\n            changed = true;\n          }\n          arrayFoldedChildren.add(elem.cloneTree());\n          // Mark change if we add a non-literal element\n          changed = true;\n        } else {\n          int lengthBeforeAppend = sb.length();\n          sb.append(elemStr);\n          // Mark changed if we are appending to a non-empty sb (merging literals)\n          if (lengthBeforeAppend > 0) {\n               changed = true;\n          }\n        }\n      } else {\n        // Non-foldable element found\n        if (sb.length() > 0) {\n          // Use source info from the non-literal node as it marks the end of the literal sequence\n          arrayFoldedChildren.add(Node.newString(sb.toString()).copyInformationFrom(elem));\n          sb = new StringBuilder();\n          changed = true; // Flushed string builder\n        }\n        arrayFoldedChildren.add(elem.cloneTree());\n        changed = true; // Involving a non-immutable element always implies change\n      }\n      elem = nextElem;\n    }\n\n    // Add any remaining accumulated string literal\n    if (sb.length() > 0) {\n      Node lastOriginalChild = arrayNode.getLastChild();\n      Node sourceInfoNode = lastOriginalChild != null ? lastOriginalChild : arrayNode;\n      Node foldedString = Node.newString(sb.toString()).copyInformationFrom(sourceInfoNode);\n      arrayFoldedChildren.add(foldedString);\n      // If we added a final string, and the list has more than one element now,\n      // or the original array had more than one element, consider it changed.\n      // Also counts as change if original was empty and now we have a string.\n       if (arrayFoldedChildren.size() > 1 || originalChildCount > 1 || (originalChildCount == 0 && arrayFoldedChildren.size() == 1) ) {\n          changed = true;\n       } else if (originalChildCount == 1 && arrayNode.getFirstChild() != null) {\n           // Check if the single resulting string is different from the original single element's string form.\n           String originalValueStr = NodeUtil.getStringValue(arrayNode.getFirstChild());\n           // If original couldn't be converted or is different from the result, it's a change.\n           if (originalValueStr == null || !originalValueStr.equals(foldedString.getString())) {\n               changed = true;\n           }\n       }\n    }\n\n    // If the folding process resulted in no change, exit.\n    if (!changed) {\n       return;\n    }\n\n\n    // Calculate original size once.\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacementNode = null;\n\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // Input: [].join(...) -> Output: \"\"\n        replacementNode = Node.newString(\"\");\n        break;\n\n      case 1: {\n        // Input: [x].join(...) or ['a','b'].join('') etc. -> Output: single node\n        Node foldedNode = arrayFoldedChildren.get(0);\n        if (foldedNode.isString()) {\n          // Result is already a string literal (e.g., \"a,b\", or \"1\")\n          replacementNode = foldedNode;\n        } else {\n          // Result is a single non-literal (e.g., foo from [foo].join(','))\n          // JS result is String(foo). Represent this as \"\" + foo for explicitness.\n          replacementNode = new Node(Token.ADD, Node.newString(\"\"), foldedNode);\n          // Copy source info from the original call node 'n' to the new ADD node.\n          replacementNode.copyInformationFromForTree(n);\n        }\n        break;\n      }\n\n      default: {\n        // Input: ['a', foo, 'b', 'c'].join(',') -> Output: [\"a\", foo, \"b,c\"].join(',')\n        // Estimate cost of the new expression: [folded1, nonLiteral, ...].join(separator)\n        Node newArrayNode = new Node(Token.ARRAYLIT);\n        for (Node node : arrayFoldedChildren) {\n          newArrayNode.addChildToBack(node); // Nodes are already clones or new strings\n        }\n        newArrayNode.copyInformationFrom(arrayNode); // Copy array source info\n\n        Node newGetPropNode = new Node(Token.GETPROP, newArrayNode, functionName.cloneNode());\n        newGetPropNode.copyInformationFrom(left); // Copy getprop source info\n\n        // Must clone 'right' (separator) as it might be used elsewhere.\n        Node newCallNode = new Node(Token.CALL, newGetPropNode, right.cloneTree());\n        // Copy overall source info for the call.\n        newCallNode.copyInformationFromForTree(n);\n\n        int estimatedNewCost = InlineCostEstimator.getCost(newCallNode);\n\n        // Only replace/modify if cost is less than or equal. Allows equal for simplification.\n        if (estimatedNewCost > originalSize) {\n          return;\n        }\n\n        // Avoid trivial changes like ['a', 5] -> [\"a\", \"5\"] if cost is identical\n        // and child count is the same.\n        if (estimatedNewCost == originalSize && arrayFoldedChildren.size() == originalChildCount) {\n            // This check is potentially complex and might prevent useful normalization.\n            // Let's remove it for now and rely on the basic cost check.\n            // If specific cases need prevention, they can be added back.\n        }\n\n        // Perform the modification by updating the original array node's children.\n        arrayNode.detachChildren();\n        for(Node nodeToAdd : arrayFoldedChildren) {\n            arrayNode.addChildToBack(nodeToAdd);\n        }\n        // Node 'n' itself (the CALL node) is kept, but its operand (the ARRAYLIT) is modified.\n        t.getCompiler().reportCodeChange();\n        return; // Modification done in place, exit.\n      }\n    } // End switch\n\n    // Handle replacement cases (0 and 1)\n    if (replacementNode != null) {\n      int replacementCost = InlineCostEstimator.getCost(replacementNode);\n\n      // Only replace if cost is less than or equal. (Allow equal for simplification)\n      if (replacementCost > originalSize) {\n        return;\n      }\n\n      if (n == parent || !n.hasParent()) {\n        // Should not happen in typical AST structures handled by PeepholeOptimizationsPass.\n        return;\n      }\n      parent.replaceChild(n, replacementNode);\n      // Ensure the replacement node gets the source info from the original call node 'n'.\n      // Case 1 ADD node already copies info. String nodes (case 0 or case 1 literal) need it.\n      if (!replacementNode.isAdd()) {\n         replacementNode.copyInformationFromForTree(n);\n      }\n      t.getCompiler().reportCodeChange();\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}