{
    "generation": "import com.google.common.collect.Lists;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n// NOTE: This code snippet assumes the existence of NodeUtil, InlineCostEstimator, NodeTraversal,\n// AbstractCompiler, and Lists classes/methods with expected functionalities from the Closure Compiler codebase.\n\nclass FixFoldStringJoin { // Helper class to contain the fixed method\n\n  // Assume these are accessible from the context where the method is used.\n  // static class NodeUtil { ... }\n  // static class InlineCostEstimator { ... }\n  // static class Lists { ... }\n  // static class NodeTraversal { AbstractCompiler getCompiler(); ... }\n  // static class AbstractCompiler { void reportCodeChange(); ... }\n\n\n  /** Helper to get string value for join, treating null/undefined/hole as empty string. */\n  private String getStringValueForJoin(Node n) {\n    // According to JS .join spec, null and undefined elements are treated as empty strings.\n    // Array holes are also treated similarly.\n    if (n == null || n.isNull() || n.isVoid() || n.isEmpty()) {\n        return \"\";\n    }\n    // For other immutable types (string, number, boolean), rely on NodeUtil.getStringValue.\n    // Assumes NodeUtil.getStringValue correctly converts numbers and booleans to strings.\n    return NodeUtil.getStringValue(n);\n  }\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // Structure must be call(getprop(potentialArray, \"join\"), joiner)\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext(); // Should be the \"join\" string node\n\n    // Check array literal and function name\n    if (arrayNode == null || !arrayNode.isArrayLit() ||\n        functionName == null || !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    // getStringValue handles null/undefined joiner returning \"\", number/boolean conversion.\n    // JS default for null/undefined joiner is \",\", this fold might be incorrect if 'right'\n    // is explicitly null/undefined. We proceed assuming common literal joiners.\n    String joinString = NodeUtil.getStringValue(right);\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    boolean lastElemWasImmutable = false;\n    // Track if any non-string immutable values were folded, which might\n    // require converting the joiner node to a string node later.\n    boolean needsJoinerStringified = !right.isString();\n\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      // Handle array holes [, , elem] - treated as empty strings\n      if (elem.isEmpty()) {\n        if (lastElemWasImmutable) {\n          sb.append(joinString);\n        }\n        // No need to append \"\", just track that we processed an immutable empty slot.\n        lastElemWasImmutable = true;\n        needsJoinerStringified = true; // Joining implies string context\n      } else if (NodeUtil.isImmutableValue(elem)) {\n        // Append joiner if concatenating immutable values\n        if (lastElemWasImmutable) {\n          sb.append(joinString);\n        }\n        sb.append(getStringValueForJoin(elem)); // Handles null/undefined as \"\"\n        lastElemWasImmutable = true;\n        if (!elem.isString()) {\n            needsJoinerStringified = true; // Number/bool/null/void require string context\n        }\n      } else { // Non-immutable element\n        // Flush the accumulated string if any immutable elements preceded this one.\n        if (lastElemWasImmutable) {\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder(); // Reset builder\n        }\n        // Add the non-immutable element directly.\n        arrayFoldedChildren.add(elem);\n        lastElemWasImmutable = false; // Reset flag\n        needsJoinerStringified = true; // Non-immutable element requires string context for join\n      }\n      elem = elem.getNext();\n    }\n\n    // After the loop, add the final accumulated string if the last elements were immutable.\n    if (lastElemWasImmutable) {\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    int foldedElementCount = arrayFoldedChildren.size();\n\n    switch (foldedElementCount) {\n      case 0: { // e.g., [].join(), [,].join() -> \"\"\n        Node emptyStringNode = Node.newString(\"\");\n        int estimatedFoldedCost = InlineCostEstimator.getCost(emptyStringNode);\n        // Only replace if cost is lower/equal, but always fold empty or hole-only arrays.\n        if (estimatedFoldedCost > originalSize && arrayNode.hasChildren() && !arrayNode.getFirstChild().isEmpty()) {\n           // Avoid replacing non-empty original with larger \"\" node, unless original was like [,]\n           return;\n        }\n        emptyStringNode.copyInformationFromForTree(n);\n        parent.replaceChild(n, emptyStringNode);\n        t.getCompiler().reportCodeChange();\n        break;\n      }\n\n      case 1: {\n        Node foldedElement = arrayFoldedChildren.get(0);\n        Node replacementNode;\n        int estimatedFoldedCost;\n\n        // Handle special case: [null].join() or [undefined].join() or [,].join() -> \"\"\n        Node originalFirstChild = arrayNode.hasChildren() ? arrayNode.getFirstChild() : null;\n        boolean isSingleNullUndefinedOrHole = foldedElementCount == 1 &&\n             (arrayNode.getChildCount() == 1 || (arrayNode.getChildCount() > 0 && originalFirstChild.getNext() == null)) && // check original structure had effectively one element\n             originalFirstChild != null && (originalFirstChild.isNull() || originalFirstChild.isVoid() || originalFirstChild.isEmpty());\n\n        if (isSingleNullUndefinedOrHole) {\n            replacementNode = Node.newString(\"\");\n            estimatedFoldedCost = InlineCostEstimator.getCost(replacementNode);\n        } else if (foldedElement.isString()) {\n            // If the single element is already a string, result is that string. Clone it.\n            replacementNode = foldedElement.cloneTree();\n            estimatedFoldedCost = InlineCostEstimator.getCost(replacementNode);\n        } else {\n          // Otherwise, coerce to string: \"\" + element\n          replacementNode = new Node(Token.ADD, Node.newString(\"\"), foldedElement.cloneTree());\n          // Estimate cost: cost(\"\") + cost(+) + cost(element)\n          estimatedFoldedCost = InlineCostEstimator.getCost(Node.newString(\"\")) + 1\n              + InlineCostEstimator.getCost(foldedElement);\n        }\n        replacementNode.copyInformationFromForTree(n);\n\n        if (estimatedFoldedCost > originalSize) {\n          return; // Fold didn't reduce size\n        }\n\n        parent.replaceChild(n, replacementNode);\n        t.getCompiler().reportCodeChange();\n        break;\n      }\n\n      default: { // foldedElementCount > 1\n        // If the array structure hasn't changed meaningfully, bail.\n        // Simple check: if count is the same and joiner was already string, assume no benefit.\n        // A more complex check could compare elements, but count is a decent heuristic.\n        if (foldedElementCount == arrayNode.getChildCount() && !needsJoinerStringified) {\n           return;\n        }\n\n        // Estimate cost of the new structure: [elem1, elem2, ...].join(joiner)\n        Node joinerNodeForCost = right;\n        // If joiner needs stringification (e.g., was number, or elements forced string context)\n        if (needsJoinerStringified && !right.isString()) {\n            // Use a temporary string node for cost estimation\n            joinerNodeForCost = Node.newString(joinString);\n        }\n        int joinerCost = InlineCostEstimator.getCost(joinerNodeForCost);\n        int kCallOverhead = 7; // Cost of \".join()\" parts\n\n        // Calculate cost of the new array literal elements + commas + brackets\n        int arrayLiteralCost = 2; // Start with cost of []\n        boolean first = true;\n        for (Node elemNode : arrayFoldedChildren) {\n          if (!first) {\n            arrayLiteralCost += 1; // cost of comma\n          }\n          arrayLiteralCost += InlineCostEstimator.getCost(elemNode);\n          first = false;\n        }\n\n        int estimatedFoldedCost = arrayLiteralCost + joinerCost + kCallOverhead;\n\n        if (estimatedFoldedCost > originalSize) {\n          return; // Fold didn't reduce size\n        }\n\n        // Modify the original array node in place\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          // Clone nodes when adding them to the modified array\n          arrayNode.addChildToBack(node.cloneTree());\n        }\n        arrayNode.copyInformationFrom(arrayNode); // Update info on modified node\n\n        // Ensure the joiner ('right') node is a string if needed\n        if (needsJoinerStringified && !right.isString()) {\n            Node replacementJoiner = Node.newString(joinString);\n            replacementJoiner.copyInformationFrom(right);\n            // Replace the original joiner node in the CALL structure\n            n.replaceChild(right, replacementJoiner);\n        }\n\n        // Report change as the array node (and possibly joiner) was modified.\n        t.getCompiler().reportCodeChange();\n        break; // Break from switch\n      }\n    } // end switch\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}