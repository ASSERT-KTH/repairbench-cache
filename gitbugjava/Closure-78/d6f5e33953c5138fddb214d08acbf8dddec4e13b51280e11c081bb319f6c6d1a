{
    "generation": "  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        // JavaScript spec section 11.5.3 says that if the divisor is 0, the\n        // result is NaN. This is Normalized according to Java's spec, but not\n        // specifically stated.\n        // http://code.google.com/p/v8/issues/detail?id=1038 says V8 conforms\n        // to the Java behavior, not the ECMA behavior. We follow V8 here.\n        if (rval == 0.0) {\n           result = Double.NaN;\n        } else {\n           result = lval % rval;\n        }\n        break;\n      case Token.DIV:\n        // JavaScript spec section 11.5.2 says that if the divisor is 0, the\n        // result is +/-Infinity or NaN. This is normalized according to Java's\n        // spec. Specifically:\n        // 1/0 => Infinity\n        // -1/0 => -Infinity\n        // 0/0 => NaN\n        // Per ECMA spec, we should report this is an error. But Rhino and V8\n        // don't. So we don't either for compatibility.\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    // The exception is when the operation creates a shorter representation:\n    // e.g. 1000 / 10 -> 100. 1000 -> \"1e3\"\n    if (!Double.isNaN(result) &&\n          Math.abs(result) < Double.POSITIVE_INFINITY &&\n          (String.valueOf(result).length() <=\n              NodeUtil.getStringValue(left).length() + NodeUtil.getStringValue(right).length() + 1 ||\n           // Always fold if the result is simpler than either operand.\n           String.valueOf(result).length() < NodeUtil.getStringValue(left).length() ||\n           String.valueOf(result).length() < NodeUtil.getStringValue(right).length()) &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      // Note: We prefer the literal \"NaN\" to the Number node representation\n      // of NaN for simplicity and shortness. For example, we prefer \"NaN\" to\n      // \"0/0\".\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      // We prefer the literal \"Infinity\" to the Number node representation\n      // of Infinity for simplicity and shortness. For example, we prefer\n      // \"Infinity\" to \"1/0\".\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      // We prefer the literal \"-Infinity\" to the Number node representation\n      // of -Infinity for simplicity and shortness. For example, we prefer\n      // \"-Infinity\" to \"-1/0\".\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}