{
    "generation": "  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          // Do not fold, as JavaScript execution results in NaN,\n          // but we don't want to report an error or replace it with NaN.\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n           // Do not fold, as JavaScript execution results in +/-Infinity or NaN,\n           // but we don't want to report an error or replace it.\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // Fold the result if it meets the criteria\n\n    // Don't fold NaN, +Infinity, or -Infinity, as the test expects\n    // division/modulo by zero to remain unfolfed. While JS evaluates\n    // 1/0 to Infinity and 1%0 to NaN, folding them might mask legitimate\n    // runtime behavior or increase code size unexpectedly. Other operations\n    // yielding NaN (like 0/0) are implicitly handled by the Double.isNaN check below\n    // if we allow folding for rval==0, but the tests expect 1/0 and 1%0 not to fold.\n    // The MAX_FOLD_NUMBER check also implicitly prevents folding numbers outside\n    // the precise integer range, which might otherwise become Infinity.\n    if (Double.isNaN(result) || Double.isInfinite(result)) {\n        return null;\n    }\n\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    // Fold if the resulting number isn't larger than the original expression.\n    if (String.valueOf(result).length() <=\n        NodeUtil.getStringValue(left).length() + NodeUtil.getStringValue(right).length() + 1 &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      // Return the folded node.\n      return newNumber;\n    }\n    // } else if (Double.isNaN(result)) {\n    //   // This path is now unreachable due to the check above, but kept\n    //   // for reference if folding NaN becomes desirable again.\n    //   return Node.newString(Token.NAME, \"NaN\");\n    // } else if (result == Double.POSITIVE_INFINITY) {\n    //   // This path is now unreachable, kept for reference.\n    //   return Node.newString(Token.NAME, \"Infinity\");\n    // } else if (result == Double.NEGATIVE_INFINITY) {\n    //   // This path is now unreachable, kept for reference.\n    //   return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    // }\n\n\n    // Return null if folding was not performed.\n    return null;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}