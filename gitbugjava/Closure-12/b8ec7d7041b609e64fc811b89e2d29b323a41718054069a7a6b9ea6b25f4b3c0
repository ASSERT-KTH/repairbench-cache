{
    "generation": "  /**\n   * Checks if the given node has an associated exception handler.\n   * This is true if the node is part of a try block that has a\n   * corresponding catch block.\n   *\n   * @param cfgNode The CFG node (basic block) containing the instruction.\n   * @return true if an exception handler exists for this node.\n   */\n  private boolean hasExceptionHandler(Node cfgNodeValue) {\n    // NOTE(lh) The original code used the basic block Node as the parameter.\n    // The CFG node object (DiGraphNode) is needed to check edges.\n    // Find the DiGraphNode in the CFG whose value is cfgNodeValue.\n    DiGraphNode<Node, Branch> cfgNode = cfg.getNode(cfgNodeValue);\n\n    // If the node is not found in the graph, assume no handler.\n    // This might happen for nodes not representing executable code or detached nodes.\n    if (cfgNode == null) {\n      return false;\n    }\n\n    // Look for an outgoing edge representing exceptional control flow (ON_EX).\n    List<DiGraphEdge<Node, Branch>> outEdges = cfg.getOutEdges(cfgNode);\n    if (outEdges == null) {\n        // Defensive check, should not happen for nodes in the graph.\n        return false;\n    }\n\n    for (DiGraphEdge<Node, Branch> edge : outEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        // An ON_EX edge exists. Check where it leads.\n        // If the destination is not the implicit \"bubble up/throw\" node,\n        // then it must lead to a CATCH block.\n        DiGraphNode<Node, Branch> target = edge.getDestination();\n        if (target != cfg.getImplicitReturn()) {\n          return true; // Found an edge leading to an explicit handler.\n        }\n      }\n    }\n\n    // No ON_EX edge found, or the existing ON_EX edge leads to the implicit handler.\n    return false;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}