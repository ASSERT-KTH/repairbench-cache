{
    "generation": "import com.google.javascript.jscomp.ControlFlowGraph;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n * Determines if the given AST node is inside a TRY block and has a\n * corresponding CATCH handler, or if any node reachable from it has\n * an outgoing ON_EX edge.\n *\n * This method requires access to the {@code ControlFlowGraph} instance,\n * assumed to be available as a field named {@code graph}.\n *\n * @param astNode The AST node to check.\n * @return {@code true} if an exception handler is potentially reachable.\n */\nprivate boolean hasExceptionHandler(Node astNode) {\n  // This method requires access to the ControlFlowGraph, assumed to be in `this.graph`.\n  // If `this.graph` is not available, this code will not compile as-is.\n  // Ensure the graph is computed before calling this.\n  if (this.graph == null) {\n      // Or handle appropriately if graph computation might fail.\n      throw new IllegalStateException(\"ControlFlowGraph not available.\");\n  }\n\n  // Find the CFG node associated with the AST node or its nearest\n  // AST ancestor that has an associated CFG node.\n  DiGraphNode<Node, Branch> startNode = null;\n  Node cfgAstNode = astNode;\n  while (cfgAstNode != null) {\n    // Skip block nodes, as they don't typically represent execution points themselves\n    // in the way expressions or statements do for exception handling checks.\n    if (!cfgAstNode.isBlock()) {\n        startNode = graph.getDirectedGraphNode(cfgAstNode);\n        if (startNode != null) {\n          break;\n        }\n    }\n    cfgAstNode = cfgAstNode.getParent();\n  }\n\n  // If no CFG node is found for the AST node or its relevant ancestors,\n  // assume no handler is reachable from this point via the CFG.\n  if (startNode == null) {\n    return false;\n  }\n\n  // Perform a graph traversal (BFS) starting from startNode\n  // to see if any node reachable from it has an ON_EX edge.\n  Queue<DiGraphNode<Node, Branch>> worklist = new LinkedList<>();\n  Set<DiGraphNode<Node, Branch>> visited = new HashSet<>();\n\n  worklist.add(startNode);\n  visited.add(startNode);\n\n  while (!worklist.isEmpty()) {\n    DiGraphNode<Node, Branch> current = worklist.poll();\n    Node currentNodeValue = current.getValue(); // AST node associated with CFG node\n\n    // Avoid NPE if somehow a null value gets into the graph node\n    if (currentNodeValue == null) {\n        continue;\n    }\n\n    // Check outgoing edges of the current CFG node.\n    List<DiGraphEdge<Node, Branch>> outEdges = graph.getOutEdges(currentNodeValue);\n    if (outEdges != null) {\n      for (DiGraphEdge<Node, Branch> edge : outEdges) {\n        Branch edgeType = edge.getValue();\n        // If an exceptional edge is found, an exception handler is reachable.\n        if (edgeType == Branch.ON_EX) {\n          return true;\n        }\n\n        // Follow all edges (including conditional, unconditional) to find successors.\n        Node successorValue = edge.getDestination();\n        DiGraphNode<Node, Branch> successorNode = graph.getDirectedGraphNode(successorValue);\n\n        // If the successor exists and hasn't been visited, add it to the worklist.\n        // Ensure successorNode is not null before adding to visited set.\n        if (successorNode != null && visited.add(successorNode)) {\n          worklist.add(successorNode);\n        }\n      }\n    }\n  }\n\n  // No ON_EX edge was found in the subgraph reachable from startNode.\n  return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}