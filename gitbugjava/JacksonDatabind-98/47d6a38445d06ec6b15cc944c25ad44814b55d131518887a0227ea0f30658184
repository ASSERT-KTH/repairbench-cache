{
    "generation": "import com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.util.TokenBuffer;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\n\nimport java.io.IOException;\n\n// NOTE: The surrounding class structure and imports like _properties, _beanType etc are assumed to exist.\n// Only the function body is provided as requested.\n\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    // 13-Aug-2019, tatu: Need to handle case of explicit null type id?\n                    // Let's delegate to `_deserialize`, which should handle it?\n                    // Or... actually, `null` means we didn't see the property.\n\n                    // 16-Jan-2020, tatu: [databind#2580], need placeholder for missing value\n                    //    so that it can possibly be provided by default value / merge etc.\n                    // 13-Sep-2020, tatu: Actually need null value handling for databind#2580\n                    if (buffer.assignParameter(extProp.getProperty(), null)) {\n                       // Something stored, need to use null value. Fine.\n                    }\n                    continue;\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                // 13-Aug-2019, tatu: Let's allow by not reporting an error, default\n                //    processing should be fine? Or if prop needed for Creator, buffer has it?\n                //   If missing required prop, Creator should fail. If optional, null is fine.\n                 // 16-Jan-2020, tatu: [databind#2580], need placeholder for missing value\n                 // 13-Sep-2020, tatu: Actually need null value handling for databind#2580\n                if (buffer.assignParameter(prop, null)) {\n                    // ok, got stored\n                }\n                continue;\n            }\n\n            // NOTE: null check for `_tokens[i]` removed from original code, seems like checks\n            // above cover the necessary conditions where `_deserialize` shouldn't be called.\n            // If `typeId` is non-null AND `_tokens[i]` is non-null, we should deserialize.\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    final JavaType typePropType = typeProp.getType();\n                    final Object typeValue;\n\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    // 18-Jan-2020, tatu: ... requires that we find the deserializer, create buffer\n                    if (typePropType.hasRawClass(String.class)) {\n                        // common case, type id is String; easy\n                        typeValue = typeId;\n                    } else {\n                        // But if not String, need to deserialize from String\n                        // Use TokenBuffer to wrap the String typeId and deserialize\n                        TokenBuffer tb = ctxt.bufferForInputBuffering(p);\n                        tb.writeString(typeId);\n\n                        JsonDeserializer<Object> deser = typeProp.getValueDeserializer();\n                        // We absolutely need a deserializer, finding one otherwise\n                        // is tricky, error-prone. Better safe than sorry.\n                        if (deser == null) {\n                             // 18-Jan-2020, tatu: Let's try `findContextualValueDeserializer` etc just in case?\n                             deser = ctxt.findContextualValueDeserializer(typePropType, typeProp);\n                             if (deser == null) {\n                                 // Must be able to deserialize expected type for creator param; fail if not\n                                 return ctxt.reportBadDefinition(typePropType, String.format(\n                                         \"Cannot find JsonDeserializer for creator property '%s' (type %s); needed to deserialize type id '%s'\",\n                                         typeProp.getName(), typePropType, typeId));\n                             }\n                        }\n                        // important: need to be careful to create actual parser, not just delegating one\n                        //   lest we get infinite recursion for complex types like enums\n                        //   (because delegating parser would just pass `p` which is original parser)\n                        JsonParser valueParser = tb.asParser(); // Use non-delegating parser\n                        valueParser.nextToken(); // important: move to value token\n\n                        // 13-Sep-2020, tatu: Actually need check for `VALUE_STRING` token to guard against\n                        //    exploits like [databind#2819]\n                        if (valueParser.currentToken() == JsonToken.VALUE_STRING) {\n                            typeValue = deser.deserialize(valueParser, ctxt);\n                        } else {\n                            // Should not happen but maybe type id comes from... number? boolean?\n                            // Either way, not usable currently without structural support; let's report\n                            return ctxt.reportInputMismatch(typeProp,\n                                \"Problem deserializing type id '%s' as %s: expected String value, got %s\",\n                                typeId, typePropType, valueParser.currentToken());\n                        }\n\n                        // Also, should check that we are left with end marker?\n                         if (valueParser.nextToken() != null) {\n                             // NOTE: maybe could also support structured type ids? Why not. Future improvement.\n                             return ctxt.reportInputMismatch(typeProp,\n                                     \"Trailing token(s) found after reading type id property '%s' value: %s\",\n                                     typeProp.getName(), valueParser.currentToken());\n                         }\n                    }\n                    buffer.assignParameter(typeProp, typeValue);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                // 13-Aug-2019, tatu: As per [databind#2431], may need to skip missing values\n                // 13-Sep-2020, tatu: Also related to [databind#2580]; missing property? Let's not set,\n                //    to allow potential defaulting, merging to work\n                if (values[i] == null) {\n                    TokenBuffer tb = _tokens[i];\n                    if (tb == null) { // missing property case? (see above checks)\n                        continue;\n                    }\n                    // Or explicit null? Could perhaps support but...\n                    // TODO: figure out what's the real use case for explicitly passed null property\n                    // and why `values[i]` would be null.\n                    // (note: was problem with test `TestExternalTypeId#testExternalTypeWithNull`)\n                    continue;\n                }\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}