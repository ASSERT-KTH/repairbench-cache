{
    "generation": "    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                // 13-Dec-2015, tatu: ... OR, maybe property is declared as ignorable?\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                // 13-Dec-2015, tatu: As per [databind#1028], may be acceptable for optional props\n                if (prop.isRequired() ||\n                        ctxt.isEnabled(DeserializationFeature.FAIL_ON_MISSING_EXTERNAL_TYPE_ID_PROPERTY)) {\n                    ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), extProp.getTypePropertyName());\n                } else {\n                    // Simply skip the property, results in `null` value assigned by creator/setter\n                    continue;\n                }\n            }\n\n            // 05-Sep-2019, tatu: Note that `typeId` is ALWAYS `String` at this point;\n            //    if POJO has type id property of different type, conversion needed later on\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    // 16-Aug-2018, tatu: ... also, as per [databind#2113], need to handle `null`\n                    Object typeValue;\n                    // 05-Sep-2019, tatu: We should only use `TokenBuffer` if type is NOT String\n                    //    (or, more generally, something that can't be assigned from String)\n                    // First check: property type is `String`?\n                    if (typeProp.getType().hasRawClass(String.class)) {\n                        typeValue = typeId;\n                    } else {\n                        // Use TokenBuffer to wrap typeId String as a token stream, then deserialize\n                        TokenBuffer tb = new TokenBuffer(p, ctxt);\n                        tb.writeString(typeId);\n    \n                        // important: find deserializer capable of handling actual type from String token\n                        JsonDeserializer<Object> deser = ctxt.findContextualValueDeserializer(typeProp.getType(), typeProp);\n    \n                        // 05-Sep-2019, tatu: Need to be careful to use \"scalar\" settings when reading\n                        //   from buffer... although shouldn't matter greatly for primitives\n                        JsonParser bufferedParser = tb.asParser(p); // != null\n                        bufferedParser.nextToken(); // advances to VALUE_STRING\n                        typeValue = deser.deserialize(bufferedParser, ctxt);\n                        tb.close();\n                        // 29-Jul-2020, tatu: [databind#2793]: Need to ensure no extra tokens left (if any)\n                        //    Can be multiple? For now, assume just one optional END_OBJECT\n                        //    (will this ever work? How would END_OBJECT get there? For now, comment out)\n                        /*\n                        if (bufferedParser.nextToken() != null) {\n                             ctxt.reportWrongTokenException(typeProp.getType(), JsonToken.END_OBJECT,\n                                     \"Expected END_OBJECT after external type id ('%s') property-based value\",\n                                     typeProp.getName());\n                        }\n                        */\n                    }\n                    buffer.assignParameter(typeProp, typeValue);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                 // 13-Dec-2015, tatu: Is this check useful? What would `values[i]` be?\n                 // (null if skipped above due to missing prop)\n                 if (values[i] != null) {\n                    prop.set(bean, values[i]);\n                 } else {\n                     // What if it's required?\n                    if (prop.isRequired()) {\n                        ctxt.reportInputMismatch(prop, \"Missing required property '%s' for external type id '%s'\",\n                                prop.getName(), _properties[i].getTypePropertyName());\n                    }\n                 }\n            }\n        }\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}