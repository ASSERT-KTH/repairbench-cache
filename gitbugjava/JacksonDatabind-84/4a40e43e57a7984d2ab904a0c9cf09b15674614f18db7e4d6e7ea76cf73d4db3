{
    "generation": "    protected JavaType _fromClass(Class<?> cl, TypeBindings bindings)\n    {\n        // Handle primitives/void upfront\n        if (cl.isPrimitive()) {\n            if (cl == Integer.TYPE) { return _constructSimple(cl, bindings, TYPE_INT); }\n            if (cl == Long.TYPE) { return _constructSimple(cl, bindings, TYPE_LONG); }\n            if (cl == Boolean.TYPE) { return _constructSimple(cl, bindings, TYPE_BOOLEAN); }\n            if (cl == Double.TYPE) { return _constructSimple(cl, bindings, TYPE_DOUBLE); }\n            if (cl == Float.TYPE) { return _constructSimple(cl, bindings, TYPE_FLOAT); }\n            if (cl == Byte.TYPE) { return _constructSimple(cl, bindings, TYPE_BYTE); }\n            if (cl == Short.TYPE) { return _constructSimple(cl, bindings, TYPE_SHORT); }\n            if (cl == Character.TYPE) { return _constructSimple(cl, bindings, TYPE_CHAR); }\n            // should not get here; but if we do...\n            throw new IllegalArgumentException(\"Unrecognized primitive type: \"+cl.getName());\n        }\n        if (cl == Void.TYPE) { return _constructSimple(cl, bindings, TYPE_VOID); }\n\n        // Some other base types that need special handling\n        // (partially to support some serialization, partly to speed up)\n        final String clsName = cl.getName();\n        if (clsName.equals(\"java.lang.Object\")) {\n            return _constructSimple(cl, bindings, TYPE_OBJECT);\n        }\n        // \u00e9chancillon: must use `clsName` here: can't use `isAssignableFrom()`!\n        if (clsName.equals(\"java.lang.String\")) {\n            return _constructSimple(cl, bindings, TYPE_STRING);\n        }\n        // We may want to specialize handling of Number, Date/Time GAEs too,\n        // but for now, Object/String are baseline needed for bootstrapping\n\n        // Ok: no easy shortcut, let's figure out type hierarchy etc\n        // 18-Oct-2015, tatu: Need to be able to handle potentially recursive types\n        final String key;\n        if (bindings == null || bindings.isEmpty()) {\n            key = clsName;\n        } else {\n            // 17-Mar-2017, tatu: As per [databind#1569] need to consider name mangling...\n            //   Note: probably should NOT use EMPTY bindings -- but for now, has to do\n            //   Actually: no. `getBoundName` should be fine.\n            key = bindings.getBoundName(clsName);\n            if (key == null) {\n                 key = bindings.getCacheKey(clsName);\n            }\n        }\n\n        JavaType type = _typeCache.get(key);\n        if (type != null) {\n            return type;\n        }\n\n        // 18-Oct-2015, tatu: Need to be able to handle potentially recursive types\n        Map<String,JavaType> known = _knownSimpleTypes;\n        if (known == null) {\n             // 18-Nov-2016, tatu: If we do check, must create the map.\n             known = _knownSimpleTypes = new HashMap<>();\n        } else {\n            // If type is known, we have recursion...\n             type = known.get(key);\n             if (type != null) {\n                  return type;\n             }\n        }\n\n        // Not known, Ok; Need to create and possibly cache for later recursion check\n        SimpleType newType = new SimpleType(cl, bindings, null, null);\n        known.put(key, newType);\n\n        // Then resolve super types, interfaces\n        JavaType superClass = null;\n        JavaType[] superInterfaces = null;\n\n        // Must calculate super-/interfaces. Note that this is non-trivial\n        // for structured types, as parameters may need resolution.\n        if (cl.isInterface()) { // interfaces are pure abstract; no Object superclass\n             superInterfaces = _resolveSuperInterfaces(newType, cl, bindings);\n        } else {\n             superClass = _resolveSuperClass(newType, cl, bindings);\n             superInterfaces = _resolveSuperInterfaces(newType, cl, bindings);\n        }\n        newType.setHierarchy(superClass, superInterfaces);\n\n        // Type modifiers? Allow post-processing\n        if (_modifiers != null) {\n             for (TypeModifier mod : _modifiers) {\n                  // 12-Aug-2016, tatu: `SimpleType` specifically can be modified\n                  //    as per [databind#1338], probably needs to be coerced...\n                  // Important: must pass original cache key, not one calculated from\n                  // potentially mangled name, as that is what needs possibly replacing\n                  newType = (SimpleType) mod.modifyType(newType, cl, bindings, this);\n             }\n        }\n        // And only store fully resolved type once done.\n        type = newType;\n        _typeCache.put(key, type);\n        known.remove(key);\n\n        return type;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}