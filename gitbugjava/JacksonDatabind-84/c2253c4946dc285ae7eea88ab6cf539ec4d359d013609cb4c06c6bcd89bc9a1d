{
    "generation": "    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        final ClassKey key = new ClassKey(rawType);\n        // This is the main function-level cache\n        JavaType type = _typeCache.get(key);\n\n        if (type != null) {\n            // 15-Jan-2016, tatu: Need to handle ResolvedRecursiveType...\n            if (type instanceof ResolvedRecursiveType) {\n                // Two main cases: referring back to the type currently being resolved\n                // (handled by ClassStack); or referring to a type that has not been\n                // resolved AFTER placeholder was added. Second case is the more\n                // complex one; need to determine how to wait, how to handle.\n\n                // Found a placeholder, need to check if it's for type we are resolving\n                ResolvedRecursiveType rrt = (ResolvedRecursiveType) type;\n                if (context.find(rawType) != null) {\n                    // Ok, we seem to be resolving the type (possibly indirectly);\n                    // need to return the placeholder temporarily. Let caller figure out what to do.\n                    return type;\n                }\n                // If not direct recursion, should be resolved reference; placeholder is just\n                // for thread-safety / concurrent resolution issues.\n\n                // 21-Feb-2016, tatu: Actually, we must have resolved it already...\n                //   so, must be able to find it:\n                type = rrt.getSelfReferencedType();\n                if (type == null) { // Sanity check... usually never occurs\n                     _reportProblem(rawType, \"Could not resolve recursive type definition\");\n                }\n            }\n            return type;\n        }\n\n        // Nope: need to construct and cache. Add placeholder to handle recursive definitions\n        if (context == null) {\n            context = new ClassStack(rawType);\n        } else {\n            ClassStack prev = context.find(rawType);\n            if (prev != null) {\n                // Ok, then, this is a recursive self-reference, which we can handle.\n                // Need to just return a placeholder marker type\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, bindings);\n                prev.addSelfReference(selfRef);\n                return selfRef;\n            }\n            // Otherwise, need context, possibly push new frame\n            context = context.child(rawType);\n        }\n\n        // Ok, need to create and put placeholder in cache for now.\n        ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, bindings);\n        _typeCache.put(key, selfRef);\n\n        // Try to figure out type components:\n        List<JavaType> HACK = Collections.emptyList(); // static is fine, just need immutability\n        JavaType superClass = null;\n        List<JavaType> interfaces = HACK;\n\n        // Handle arrays first...\n        if (rawType.isArray()) {\n            if (rawType == byte[].class) { // Special handling for byte[]\n                type = PrimitiveArrayType.construct(SimpleType.constructUnsafe(Byte.TYPE), bindings);\n            } else {\n                type = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings), bindings);\n            }\n        } else {\n            // Then primitive types\n            if (rawType.isPrimitive()) {\n                // We should have exact types for primitives; but none for void\n                // (should we check for void?)\n                // Also; only need unsafe instances as we don't care about handlers, bindings\n                if (rawType == Boolean.TYPE) { type = SimpleType.constructUnsafe(Boolean.TYPE); }\n                else if (rawType == Integer.TYPE) { type = SimpleType.constructUnsafe(Integer.TYPE); }\n                else if (rawType == Long.TYPE) { type = SimpleType.constructUnsafe(Long.TYPE); }\n                // others should be added if/when needed...\n                else {\n                    // Should we validate that it's primitive? Or fail later? Let's fail later.\n                    type = SimpleType.constructUnsafe(rawType);\n                }\n            } else {\n                // Then Enum types\n                if (rawType.isEnum()) {\n                    type = EnumType.construct(rawType, bindings);\n                } else if (rawType.isInterface()) {\n                    // \"important\" interfaces, pre-defined? Maybe Map/List/Set?\n                    // Nah, let's not assume anything about those.\n                    interfaces = _resolveSuperInterfaces(context, rawType, bindings);\n                    // And possible super-interface:\n                    // Interfaces have null super class, but may have super interfaces\n                    // May not have super-class, but we do use Object.class default for some checks\n                    superClass = _resolveSuperClass(context, rawType, bindings);\n                    type = InterfaceType.construct(rawType, bindings, superClass, interfaces);\n                } else { // And finally, regular classes\n                    superClass = _resolveSuperClass(context, rawType, bindings);\n                    interfaces = _resolveSuperInterfaces(context, rawType, bindings);\n                    type = SimpleType.construct(rawType, bindings, superClass, interfaces);\n                    // 15-Jan-2016, tatu: If we have generic type, need to resolve its type parameters.\n                    //    Need to do this AFTER construction, before setting references, to make\n                    //    sure reference itself is resolved. Not 100% sure this is the best place,\n                    //    seems to work...\n                    if (type.hasGenericTypes()) {\n                        _resolveSelfReferences(type, bindings);\n                    }\n                }\n            }\n            // TODO: optimize by perhaps calling resolve-methods only when type has generic parameters?\n            // Or perhaps that would not help much...\n\n            // 15-Jan-2016, tatu: Make sure we resolve self-references if we did\n            //    create non-trivial type.\n            // 21-Feb-2016, tatu: ... but note that this needs to be done before\n            //    calling setReference, to avoid race conditions -- that is, need\n            //    to link type completely before making it available via placeholder.\n            //    But seems like we can't easily do that. Check [databind#1332] for details.\n            //    (Perhaps someday could handle this better?)\n/* // 21-Feb-2016, tatu: Too eager; causes [databind#1332]\n            if (!type.equals(selfRef)) {\n                _resolveSelfReferences(type, bindings);\n            }\n */\n        }\n        selfRef.setReference(type); // Resolve placeholder AFTER resolving refs\n\n        // And possible self-references within type?\n        List<ResolvedRecursiveType> refs = context.getSelfReferences();\n        if (refs != null) {\n            for (ResolvedRecursiveType ref : refs) {\n                ref.setReference(type);\n            }\n        }\n\n        return type;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}