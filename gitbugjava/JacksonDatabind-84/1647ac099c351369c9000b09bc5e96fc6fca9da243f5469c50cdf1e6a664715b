{
    "generation": "// Assume this is inside com.fasterxml.jackson.databind.type.TypeFactory\n// Based on Jackson 2.8+ structure which fixed related issues like FasterXML/jackson-databind#1269\n// This version ensures hierarchy is resolved correctly even if base types are cached first.\n\n/**\n * Factory method for constructing {@link JavaType} instances for specified\n * {@link Class}.\n *<p>\n * NOTE: this is an internal method and is not meant to be called by outside code.\n * It does not check for primitive types; you MUST NOT call this method for\n * primitive types.\n */\n@SuppressWarnings(\"deprecation\")\nprotected JavaType _fromClass(Class<?> clz, TypeBindings bindings)\n{\n    // Ok, non-primitive; let's see if we already have it...\n    // 18-Oct-2016, tatu: Need to use `ClassKey` for custom caching, working with `LRUMap`\n    // 05-Jan-2017, tatu: ... possibly, but for now baseline just uses Class\n    JavaType type = _findCachedType(clz);\n\n    if (type != null) {\n        // 15-Jan-2016, tatu: Important! If type is resolved, should NOT create new\n        //    instance, regardless of bindings. Otherwise, we may have issues with\n        //    identity, like [databind#1091]\n        // Let's retain finer-grained type... unless we should not? For [databind#1091],\n        // seems we must; but perhaps that should be configuration option?\n        /*\n        if ((bindings != null) && !bindings.isEmpty()) {\n            // TODO: Maybe should try to apply? But for now, require exact match\n            // Or... maybe this is wrong? What if 'bindings' has more specific type?\n        }\n        */\n        return type;\n    }\n\n    // 18-Oct-2016, tatu: Need to be able to defer resolution for recursive types\n    // 13-Nov-2017, tatu: ... and possibly others, so use Object as key\n    Object key = _createClassKey(clz);\n    ResolvedRecursiveType selfRef = new ResolvedRecursiveType(clz, bindings);\n    _typeCache.put(key, selfRef);\n\n    // First, need to resolve super types (possibly recursively)\n    boolean maybeAbstract = false;\n    JavaType superClass = null;\n    List<JavaType> superInterfaces;\n\n    if (clz.isArray()) {\n        type = ArrayType.construct(_constructType(clz.getComponentType(), bindings), bindings);\n    } else {\n        // Must resolve super-type first; needed for interfaces, classes\n        // Need to be careful here: need to consider generic information possibly passed\n        // For interfaces, generic type parameters come from declarations, not super-types\n        if (clz.isInterface()) {\n            // We only need class type parameters for the interface itself. The super interfaces\n            // are resolved using the bindings from the interface declaration.\n            type = _constructInterfaceType(clz, bindings);\n            // And for interfaces, super class is always Object, so:\n            superClass = null;\n            superInterfaces = _resolveSuperInterfaces(type, clz, bindings);\n        } else if (clz.isEnum()) {\n            type = _constructEnumType(clz, bindings);\n            superClass = _resolveSuperClass(type, clz, bindings); // Should be Enum<E>\n            superInterfaces = _resolveSuperInterfaces(type, clz, bindings);\n        } else { // regular class\n            // Nope: only need bindings for the class itself; super types are resolved\n            // using the bindings from the declaration.\n            type = _constructSimpleType(clz, bindings, null, null);\n            superClass = _resolveSuperClass(type, clz, bindings);\n            superInterfaces = _resolveSuperInterfaces(type, clz, bindings);\n            if (!type.isContainerType()) {\n                // A non-final non-container class is considered potentially abstract.\n                maybeAbstract = !Modifier.isFinal(clz.getModifiers());\n            }\n        }\n        // Then handlers for super-types: needs to be done after constructing\n        // the type itself for handling of recursive types.\n        // 18-Oct-2016, tatu: Super-types must be handled regardless of type itself\n        // For all types (except Object.class), need to connect to super types now:\n        if (clz != Object.class) {\n            // May need to be done for Enum/Interface too... let's assume for now: NO\n             if (type instanceof SimpleType) {\n                 ((SimpleType) type).setHierarchy(superClass, superInterfaces);\n             } else if (type instanceof HierarchicType) { // Ensure InterfaceType/EnumType get hierarchy set\n                 ((HierarchicType) type).setSuperType(superClass);\n                 // Interfaces usually set during construction, but double-check\n                 if (superInterfaces != null && !superInterfaces.isEmpty()) {\n                     ((HierarchicType) type).setInterfaces(superInterfaces);\n                 }\n             }\n         }\n\n        // Handlers can be added regardless of type being resolved yet or not\n        type = _applyModifiers(clz, bindings, type);\n\n        // TypeHandlers?: should probably be done after specialization\n        // 18-Oct-2016, tatu: Should probably be done right here; handlers are not type-specific\n        // ... Or are they? What about custom handlers passed via annotations?\n        // Let's assume not for now.\n\n        // Finally: any annotations that would affect abstract/concrete type distinction?\n        // 09-Mar-2018, tatu: Actually this needs to be done AFTER `setHierarchy()` call above\n        //    as it depends on knowing super-types (for @JsonSubTypes)\n        if (maybeAbstract) {\n            maybeAbstract = _isPotentialAbstract(type);\n            if (maybeAbstract) {\n                type = mapAbstractType(type.getConfig(), type);\n            }\n        }\n    }\n    selfRef.setReference(type);\n\n    // 18-Oct-2016, tatu: Need to ensure we didn't already resolve the type (due to concurrency)\n    JavaType prev = _typeCache.putIfAbsent(key, type);\n    if (prev != null) {\n        return prev;\n    }\n    return type;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}