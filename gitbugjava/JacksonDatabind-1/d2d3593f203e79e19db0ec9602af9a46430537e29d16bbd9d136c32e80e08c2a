{
    "generation": "    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n            // We are done with null values; nothing more to do\n            return; // <<< [FIX] Added return statement\n        }\n        \n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                // 11-Nov-2015, tatu: Need to use correct `isEmpty()` overload...\n                if (ser.isEmpty(prov, value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            // 10-Jul-2015, tatu: How could this work for tabular data? Let's fail for now\n             _handleSelfReference(bean, jgen, prov, ser);\n             // usually would throw exception; if not, need to call placeholder serializer\n             // 05-Feb-2016, tatu: As per [databind#1123], maybe we SHOULD call placeholder?\n             // This seems questionable for tabular data, but...\n             // 21-Oct-2016, tatu: Let's assume `_handleSelfReference` now takes care of things\n             //    either way. That is, call returns iff placeholder write is needed.\n             // ... which is not the case: must explicitly call here?\n             return; // ??? Should we perhaps call 'serializeAsPlaceholder'?\n        }\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}