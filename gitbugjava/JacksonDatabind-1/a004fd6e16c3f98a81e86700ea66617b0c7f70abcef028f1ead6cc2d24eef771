{
    "generation": "    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            // [databind#223]: need to use null serializer from provider\n            // And then MUST return: value null, handled\n            prov.defaultSerializeNull(jgen);\n            return;\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                 // 13-Oct-2015, tatu: Need to use correct isEmpty() overload...\n                if (ser.isEmpty(prov, value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n        if (value == bean) {\n            // 23-Jun-2016, tatu: Need to add explicit handling because non-Object serialization\n            //    context cannot rely on type serializer checks. But, alas, method signature\n            //    does not allow passing necessary info... lasciato per ora.\n             _handleSelfReference(bean, jgen, prov, ser); // NOTE: Needed signature change may break older code if `_handleSelfReference` not updated\n             // Note: Above call might require signature update depending on the exact version/context\n             // For the specific fix of #223, the null handling change is the crucial part.\n             // Keeping original call structure if necessary:\n             // _handleSelfReference(bean, ser); \n        }\n\n        // type serializer usually handled by serializer; value serializer often must handle it\n        if (_typeSerializer == null) {\n            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}