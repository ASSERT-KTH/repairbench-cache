{
    "generation": "    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        // Use a ConstrainableInputStream to allow rewinding independently of the source input stream's mark/reset support.\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            // Make a defensive copy of the byte buffer, as the memory is reusable from readToByteBuffer\n            // See https://github.com/jhy/jsoup/issues/1894 - This is a defensive fix for potential buffer reuse issues, applied here although the original provided code might not have had it.\n            ByteBuffer ClonedForDecode = ByteBuffer.allocate(firstBytes.limit());\n            firstBytes.rewind();\n            ClonedForDecode.put(firstBytes);\n            firstBytes.rewind(); // rewind for potentially finding BOM later, or resetting back to stream start\n            ClonedForDecode.flip();\n            // default charset is used here only for the first parse attempt,yielding candidate doc. If implicit charset found, potentially re-decodes.\n            String docData = Charset.forName(defaultCharset).decode(ClonedForDecode).toString(); // Use defaultCharset for initial parse attempt\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null; // set doc to null so the stream is re-read with the detected charset\n            } else if (!fullyRead) { // if charset not found, but stream wasn't fully read, need to retry parse with specified encoding\n                doc = null;\n            }\n            // else, the doc that was parsed is valid, and can be returned (happens if doc is all UTF-8)\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) { // need to parse form stream, with appropriate charset determined from BOM or meta\n            if (charsetName == null) // if no explicit charset found, use default\n                charsetName = defaultCharset;\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) { // creating the buffered reader ignores the input pos, so must skip here\n                long skipped = reader.skip(1); // BOM is a single character\n                Validate.isTrue(skipped == 1); // if this fails, there's an InputStreamReader bug. Validated by test case.\n            }\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            // Assign the found charset to the doc, so it can be used for output\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n\n            // START OF FIX\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            if (!charset.canEncode()) {\n                 // If the detected charset can't be encoded (e.g., ISO-2022-CN), fall back to UTF-8.\n                 // This method also updates the document's meta charset elements.\n                 doc.charset(Charset.forName(defaultCharset)); // defaultCharset is likely UTF-8\n            }\n            // END OF FIX\n        }\n        input.close(); // tidy up\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}