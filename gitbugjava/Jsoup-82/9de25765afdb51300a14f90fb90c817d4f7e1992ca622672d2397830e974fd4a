{
    "generation": "import org.jsoup.helper.DataUtil; // Assuming access to static helpers like detectCharsetFromBom, etc.\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.nodes.*;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\n\n// Assume context provides:\n// - static final fields: bufferSize, firstReadBufferSize, defaultCharset (e.g., \"UTF-8\")\n// - static helper methods: DataUtil.readToByteBuffer, DataUtil.detectCharsetFromBom, DataUtil.getCharsetFromContentType, DataUtil.validateCharset\n// - internal class: DataUtil.BomCharset\n\n/**\n * Parses the input stream into a Document.\n * @param input input stream to parse. You should buffer this.\n * @param charsetName character set of input stream. Set to {@code null} to determine automatically.\n * @param baseUri base URI of document, to resolve relative links against.\n * @param parser alternate parser to use.\n * @return parsed document\n * @throws IOException on IO error\n */\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    // Wrap input stream for constraints, useful for reading limited bytes for detection\n    // Max size 0 means no limit, just wrap for bufferSize mark/reset support.\n    input = ConstrainableInputStream.wrap(input, DataUtil.bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // Mark the input stream to allow resetting after reading the initial bytes for BOM/meta detection\n    input.mark(DataUtil.bufferSize);\n    // Read initial bytes. readToByteBuffer consumes data, resulting buffer has position=0, limit=read.\n    ByteBuffer firstBytes = DataUtil.readToByteBuffer(input, DataUtil.firstReadBufferSize - 1); // -1 because readToByteBuffer reads one extra byte to check for end of stream.\n    fullyRead = input.read() == -1; // Check if we read the whole stream\n    input.reset(); // Reset stream to the mark for potential full re-read\n\n    // 1. Check for BOM - overrides any other declaration\n    DataUtil.BomCharset bomCharset = DataUtil.detectCharsetFromBom(firstBytes); // Reads from firstBytes, advances position\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset; // Use charset from BOM\n    }\n    // Rewind buffer so subsequent decodes start from the beginning.\n    firstBytes.rewind();\n\n    if (charsetName == null) { // 2. If no BOM, try reading meta tags from initial bytes parsed as defaultCharset\n        try {\n            // Decode assumes defaultCharset is valid (e.g., UTF-8)\n            String docData = Charset.forName(DataUtil.defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri); // Parse initial fragment\n\n            // Find meta charset elements: <meta http-equiv=content-type>, <meta charset>\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null;\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = DataUtil.getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // 3. Check for XML declaration <?xml encoding='...'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration) {\n                    decl = (XmlDeclaration) first;\n                } else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    // Prevents unlikely but possible mismatch between XML decl and HTML contents\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n\n            // Validate and potentially update charsetName\n            foundCharset = DataUtil.validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(DataUtil.defaultCharset)) {\n                // Found a non-default charset in meta/xml, need to re-parse the whole stream\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\"); // Normalize\n                charsetName = foundCharset;\n                doc = null; // Discard partial parse\n            } else if (!fullyRead) {\n                // If stream wasn't fully read, and we didn't find a new charset (or it's the default),\n                // we must parse the rest of the stream using the default charset.\n                doc = null; // Discard partial parse\n            }\n            // If fullyRead and no different charset found (or found==default), the initial parse ('doc') is the final document.\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException e) {\n            // Should not happen with defaultCharset, but throw if it does. Could fallback? No, fail fast.\n            throw new IOException(\"Unsupported or invalid default charset: \" + DataUtil.defaultCharset, e);\n        }\n    } else {\n        // Charset was specified by BOM or content type header (or user argument)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        // We need to parse the whole stream with this charset.\n        doc = null;\n    }\n\n    // Re-parse if needed (doc == null indicates detection required re-parse or stream wasn't fully read initially)\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = DataUtil.defaultCharset; // Default to UTF-8 if nothing found/specified\n\n        // Create reader with the determined charset. InputStreamReader handles BOMs.\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), DataUtil.bufferSize);\n\n        try {\n            doc = parser.parseInput(reader, baseUri); // Parse the full stream\n        } catch (UncheckedIOException e) {\n            // E.g. if underlying stream is closed prematurely during parse.\n            throw e.ioException(); // Propagate IO exceptions during parsing\n        }\n\n        // Set document output charset based on determined charset\n        Charset parsedCharset;\n        try {\n             parsedCharset = Charset.forName(charsetName);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            // Charset may be valid for decoding (used by InputStreamReader) but not encodable or invalid for Charset.forName? Unlikely.\n            // If validation passed, this should be safe. If not, fallback.\n            parsedCharset = Charset.forName(DataUtil.defaultCharset);\n        }\n        doc.outputSettings().charset(parsedCharset);\n\n        // Fallback for problematic charsets for output encoding. Check specific known problematic ones like ISO-2022-CN.\n        // The standard .canEncode() check is insufficient for stateful encodings.\n        // Using equalsIgnoreCase for robustness as charset names can vary in case.\n        if (charsetName.equalsIgnoreCase(\"ISO-2022-CN\")) {\n            doc.outputSettings().charset(Charset.forName(DataUtil.defaultCharset)); // Fallback to default (UTF-8)\n            doc.updateMetaCharsetElement(true); // Update meta tag in DOM to match output charset\n        }\n    }\n    // Ensure the input stream is closed\n    input.close();\n\n    // Ensure the Document's charset reflects the final output setting\n    // (which might be different from the detected input charset if fallback occurred)\n    if (doc != null) { // doc is null only if input stream was null initially\n         doc.charset(doc.outputSettings().charset());\n    }\n\n    return doc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}