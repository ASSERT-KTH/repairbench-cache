{
    "generation": "import org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n// NOTE: This is a placeholder class to make the provided function compile.\n// The actual context would involve the real ArchiveStreamFactory class.\nclass ArchiveStreamFactory {\n\n    // Added DEFAULT_RCDSIZE constant based on its use in TarArchiveInputStream\n    // Assuming its value is 512, which is standard for TAR block size.\n    private static final int TAR_DEFAULT_RCDSIZE = 512;\n\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     *\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known or the stream is too short\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        int signatureLength = -1;\n        try {\n            // Read signature bytes; signatureLength will be actual bytes read or -1\n            signatureLength = in.read(signature);\n            in.reset();\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        }\n        if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        }\n        if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        }\n        if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer\n        final byte[] dumpSignature = new byte[32];\n        in.mark(dumpSignature.length);\n        try {\n            // Read dump signature bytes\n            // Note: We reuse signatureLength variable, it's safe as we reset 'in' before reading dumpSignature\n            signatureLength = in.read(dumpSignature);\n            in.reset();\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n        if (DumpArchiveInputStream.matches(dumpSignature, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs 512 bytes; read the first block\n        final byte[] tarHeader = new byte[TAR_DEFAULT_RCDSIZE]; // Use constant for clarity\n        in.mark(tarHeader.length);\n        try {\n            // Read tar header bytes\n            // Note: We reuse signatureLength variable again.\n            signatureLength = in.read(tarHeader);\n            in.reset();\n        } catch (IOException e) {\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        if (TarArchiveInputStream.matches(tarHeader, signatureLength)) {\n            return new TarArchiveInputStream(in);\n        }\n\n        // COMPRESS-117 / COMPRESS-207 / COMPRESS-171 TAR fallback check:\n        // If the header check failed, try parsing the read block.\n        // Requires at least a full block (512 bytes) to have been read.\n        if (signatureLength >= TAR_DEFAULT_RCDSIZE) {\n            TarArchiveInputStream tais = null;\n            try {\n                // Use a temporary stream based on the buffer read, DO NOT consume the original 'in'\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarHeader, 0, signatureLength));\n                // Try to read the first entry - if it succeeds, it's very likely TAR.\n                // This addresses COMPRESS-171 where non-TAR data could pass this check\n                // if getNextEntry just returned null instead of throwing an exception.\n                if (tais.getNextTarEntry() != null) {\n                    // Success! The fallback check identifies it as TAR.\n                    // Return a new Tar stream based on the original input stream.\n                    return new TarArchiveInputStream(in);\n                }\n                // If getNextTarEntry() returned null, the stream is likely not TAR or is empty/corrupt.\n            } catch (Exception e) { // NOPMD\n                // IOException, IllegalArgumentException from getNextEntry or constructor\n                // indicate that the buffer doesn't represent a valid TAR header.\n                // Fall through to the final exception.\n            } finally {\n                // Ensure the temporary stream is closed.\n                if (tais != null) {\n                    try {\n                        tais.close();\n                    } catch (IOException ignored) {\n                        // Closing a ByteArrayInputStream based stream is trivial, ignore.\n                    }\n                }\n            }\n        } // end TAR fallback check\n\n        // If no archive format matched after all checks\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}