{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedByte(); // header\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        if (BitUtil.check(flags, 4)) {\n            sendResponse(channel, remoteAddress, index, type, buf);\n        }\n\n        if (type == MSG_DATA) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n\n            DeviceSession deviceSession = null;\n\n            // Need at least length (1) and key (1) bytes to process a block\n            while (buf.isReadable() && buf.readableBytes() > 1) {\n                int dataBlockLength = buf.readUnsignedByte(); // length of block (key + data)\n                if (dataBlockLength == 0 || dataBlockLength > buf.readableBytes()) {\n                    // Invalid length (zero or exceeds remaining buffer), stop processing\n                    break;\n                }\n                // endIndex points *after* the key + data for this block\n                int endIndex = buf.readerIndex() + dataBlockLength;\n                int key = buf.readUnsignedByte();\n\n                if (keys.contains(key)) {\n                    // Only add previous position if it has some data (location or time or deviceId)\n                    if (position.getFixTime() != null || hasLocation || position.getDeviceId() > 0) {\n                        if (!hasLocation && position.getDeviceId() > 0) { // Only get last location if needed and possible\n                            getLastLocation(position, position.getFixTime()); // Use current position time if available\n                        }\n                        positions.add(position);\n                    }\n                    // Start new position\n                    keys.clear();\n                    hasLocation = false;\n                    position = new Position(getProtocolName());\n                    if (deviceSession != null) { // Carry over device id if known\n                        position.setDeviceId(deviceSession.getDeviceId());\n                    }\n                }\n                keys.add(key);\n\n                // Calculate available data length for the current key\n                int dataLength = endIndex - buf.readerIndex();\n\n                switch (key) {\n                    case 0x01: // IMEI\n                        if (dataLength == 15) { // IMEI is 15 bytes\n                            String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                            deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                            if (deviceSession != null) {\n                                position.setDeviceId(deviceSession.getDeviceId());\n                            }\n                        }\n                        break;\n                    case 0x02: // Alarm\n                        if (dataLength >= 4) { // Need at least 4 bytes for alarm\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                        }\n                        break;\n                    case 0x14: // Battery\n                        if (dataLength >= 3) { // 1 byte level + 2 bytes voltage\n                           position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                           position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                        }\n                        break;\n                    case 0x20: // Location basic\n                        // lat(4)+lon(4)+speed(2)+course(2)+alt(2)+hdop(2)+odom(4)+sats(1) = 23 bytes\n                        if (dataLength >= 23) {\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                            position.setCourse(buf.readUnsignedShortLE());\n                            position.setAltitude(buf.readShortLE());\n                            int hdop = buf.readUnsignedShortLE();\n                            position.setValid(hdop > 0);\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                            hasLocation = true; // Set hasLocation only if data is read successfully\n                        }\n                        break;\n                    case 0x21: // Cell towers\n                        if (dataLength >= 3) { // MCC (2) + MNC (1)\n                            int mcc = buf.readUnsignedShortLE();\n                            int mnc = buf.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            // bytes per tower = 1 (RSSI) + 2 (LAC) + 2 (CID) = 5\n                            while (endIndex - buf.readerIndex() >= 5) {\n                                int rssi = buf.readByte();\n                                int lac = buf.readUnsignedShortLE();\n                                int cid = buf.readUnsignedShortLE();\n                                position.getNetwork().addCellTower(CellTower.from(mcc, mnc, lac, cid, rssi));\n                            }\n                        }\n                        break;\n                    case 0x22: // Wifi APs\n                         // bytes per AP = 1 (RSSI) + 6 (MAC) = 7\n                        if (dataLength >= 7) {\n                             if (position.getNetwork() == null) {\n                                 position.setNetwork(new Network());\n                             }\n                             while (endIndex - buf.readerIndex() >= 7) {\n                                 int rssi = buf.readByte();\n                                 String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                 position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                         mac.substring(0, mac.length() - 1), rssi));\n                             }\n                        }\n                        break;\n                    case 0x23: // Tag location\n                         if (dataLength >= 14) { // 6 (Tag ID) + 4 (Lat) + 4 (Lon) = 14 bytes\n                             position.set(\"tagId\", readTagId(buf));\n                             position.setLatitude(buf.readIntLE() * 0.0000001);\n                             position.setLongitude(buf.readIntLE() * 0.0000001);\n                             position.setValid(true);\n                             hasLocation = true;\n                         }\n                         break;\n                    case 0x24: // Time and status\n                         if (dataLength >= 8) { // 4 (Time) + 4 (Status) = 8 bytes\n                             position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                             long status = buf.readUnsignedIntLE();\n                             position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                             position.set(Position.KEY_STATUS, status);\n                         }\n                         break;\n                    case 0x28: // Beacon info\n                        if (dataLength >= 9) { // 1 (Flags) + 6 (Tag ID) + 1 (RSSI) + 1 (1m RSSI) = 9 bytes minimum\n                            int beaconFlags = buf.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(buf));\n                            position.set(\"tagRssi\", (int) buf.readByte());\n                            position.set(\"tag1mRssi\", (int) buf.readByte());\n                            if (BitUtil.check(beaconFlags, 7)) {\n                                // Check if lat/lon data exists (8 bytes)\n                                if (endIndex - buf.readerIndex() >= 8) {\n                                    position.setLatitude(buf.readIntLE() * 0.0000001);\n                                    position.setLongitude(buf.readIntLE() * 0.0000001);\n                                    position.setValid(true);\n                                    hasLocation = true;\n                                }\n                            }\n                            if (BitUtil.check(beaconFlags, 6)) {\n                                // Read description if it exists\n                                int descriptionLength = endIndex - buf.readerIndex();\n                                if (descriptionLength > 0) {\n                                    position.set(\"description\", buf.readCharSequence(\n                                            descriptionLength, StandardCharsets.US_ASCII).toString());\n                                }\n                            }\n                        }\n                        break;\n                    case 0x2A: // Wifi location\n                         // 1 (Flags) + 6 (MAC) + 1 (RSSI) + 4 (Lat) + 4 (Lon) = 16 bytes\n                         if (dataLength >= 16) {\n                             buf.readUnsignedByte(); // flags\n                             buf.skipBytes(6); // mac\n                             buf.readUnsignedByte(); // rssi\n                             position.setLatitude(buf.readIntLE() * 0.0000001);\n                             position.setLongitude(buf.readIntLE() * 0.0000001);\n                             position.setValid(true);\n                             hasLocation = true;\n                         }\n                         break;\n                    case 0x30: // Steps\n                        if (dataLength >= 8) { // 4 (Timestamp) + 4 (Steps) = 8 bytes\n                           buf.readUnsignedIntLE(); // timestamp\n                           position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x31: // Activity\n                        // bytes per entry = 4 (Time) + 4 (Activity) = 8\n                        if (dataLength >= 8) {\n                           int i = 1;\n                           while (endIndex - buf.readerIndex() >= 8) {\n                               position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                               position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                               i += 1;\n                           }\n                        }\n                        break;\n                    case 0x37: // Bark count\n                        // Assumed format: 4 unknown bytes + 4 bytes bark count LE\n                        // Total data length must be 8 bytes.\n                        if (dataLength >= 8) {\n                            // Move reader index to the start of the 4-byte count (last 4 bytes)\n                            buf.readerIndex(endIndex - 4);\n                            position.set(\"barkCount\", buf.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x40: // Heart rate\n                         if (dataLength >= 5) { // 4 (Timestamp) + 1 (Heart Rate) = 5 bytes\n                            buf.readUnsignedIntLE(); // timestamp\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) {\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                         }\n                         break;\n                    default:\n                        // Unknown key, data will be skipped by setting reader index below\n                        break;\n                }\n                // Ensure reader index is set to the end of the current block,\n                // skipping any unread data within the block.\n                buf.readerIndex(endIndex);\n            }\n\n            // Add the last processed position if it has potentially useful data\n            if (position.getFixTime() != null || hasLocation || position.getDeviceId() > 0 || !position.getAttributes().isEmpty()) {\n                 if (!hasLocation && position.getDeviceId() > 0) {\n                     getLastLocation(position, position.getFixTime()); // Use current position time if available\n                 }\n                 positions.add(position);\n            }\n\n            if (deviceSession == null && !positions.isEmpty()) {\n                 // If IMEI wasn't received (key 0x01) or failed to create session,\n                 // try to get session from channel context (might exist from previous messages)\n                 deviceSession = getDeviceSession(channel, remoteAddress);\n            }\n\n            if (deviceSession != null) {\n                 // Ensure all valid positions have the device ID\n                 for (Position p : positions) {\n                      if (p.getDeviceId() == 0) {\n                           p.setDeviceId(deviceSession.getDeviceId());\n                      }\n                 }\n                 // Remove positions that still couldn't be assigned a deviceId\n                 positions.removeIf(p -> p.getDeviceId() == 0);\n\n                 return positions.isEmpty() ? null : positions;\n\n            } else {\n                 // If we couldn't associate positions with a device, return null\n                 // This prevents returning positions with deviceId = 0\n                 return null;\n            }\n        }\n\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}