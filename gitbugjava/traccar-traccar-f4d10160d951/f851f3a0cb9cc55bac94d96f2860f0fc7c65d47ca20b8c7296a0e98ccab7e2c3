{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedByte(); // header\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        if (BitUtil.check(flags, 4)) {\n            sendResponse(channel, remoteAddress, index, type, buf);\n        }\n\n        if (type == MSG_DATA) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n\n            DeviceSession deviceSession = null;\n\n            while (buf.isReadable()) {\n                // Check readable bytes before reading length and key\n                if (buf.readableBytes() < 2) {\n                    break;\n                }\n                int fieldLengthMarker = buf.getUnsignedByte(buf.readerIndex()); // Peek at length byte\n                if (fieldLengthMarker == 0) { // Stop if length marker is 0 (potential padding/terminator)\n                     break;\n                }\n                // Check if declared length exceeds available bytes (including key byte)\n                if (fieldLengthMarker > buf.readableBytes()) {\n                    break; // Avoid reading past buffer end\n                }\n\n                // Read field length and calculate end index for this field's data\n                // endIndex is the index AFTER the last byte of this field's data\n                int endIndex = buf.readUnsignedByte() + buf.readerIndex();\n                int key = buf.readUnsignedByte();\n\n                // Check if calculated endIndex is valid relative to buffer bounds\n                if (endIndex > buf.writerIndex() || endIndex < buf.readerIndex()) {\n                    // Invalid endIndex suggests data corruption. Stop processing this message.\n                    break;\n                }\n\n                if (keys.contains(key)) {\n                    // If a key repeats, finalize the previous position object\n                    if (!hasLocation && position.getLatitude() == 0 && position.getLongitude() == 0) {\n                        // Try to get last known location if current position object lacks coordinates\n                        getLastLocation(position, position.getDeviceTime()); // Pass time if available\n                    }\n                    // Only add the position if it contains meaningful data\n                    if (position.getAttributes().size() > 0 || position.getFixTime() != null || (position.getValid() != null && position.getValid()) || (position.getLatitude() != 0 || position.getLongitude() != 0)) {\n                       positions.add(position);\n                    }\n                    // Start a new position object\n                    keys.clear();\n                    hasLocation = false;\n                    position = new Position(getProtocolName());\n                    // Associate new position with device immediately if session exists\n                    if (deviceSession != null) {\n                        position.setDeviceId(deviceSession.getDeviceId());\n                    }\n                }\n                keys.add(key);\n\n                // Where the data for the current key should end\n                int dataEndIndex = endIndex;\n\n                switch (key) {\n                    case 0x01: // IMEI (15 bytes data)\n                        if (buf.readerIndex() + 15 <= dataEndIndex) {\n                            deviceSession = getDeviceSession(\n                                    channel, remoteAddress, buf.readCharSequence(15, StandardCharsets.US_ASCII).toString());\n                            if (deviceSession != null) {\n                                position.setDeviceId(deviceSession.getDeviceId());\n                            } else {\n                                return null; // Critical error: cannot identify device\n                            }\n                        }\n                        break;\n                    case 0x02: // Alarm (4 bytes data)\n                         if (buf.readerIndex() + 4 <= dataEndIndex) {\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true); // Specific flag for bark alarm?\n                            }\n                         }\n                        break;\n                    case 0x14: // Battery (1 byte level + 2 bytes voltage = 3 bytes data)\n                        if (buf.readerIndex() + 3 <= dataEndIndex) {\n                             position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                             position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001); // Voltage\n                        }\n                        break;\n                    case 0x20: // Location GPS (22 bytes data)\n                        if (buf.readerIndex() + 22 <= dataEndIndex) {\n                            hasLocation = true;\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                            position.setCourse(buf.readUnsignedShortLE());\n                            position.setAltitude(buf.readShortLE());\n                            int hdop = buf.readUnsignedShortLE();\n                            position.setValid(hdop > 0 && hdop < 999); // Validity based on HDOP range\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                        }\n                        break;\n                    case 0x21: // Location LBS (Cell Towers)\n                         // Min length: mcc(2)+mnc(1)+1 cell[rssi(1)+lac(2)+cid(2)=5] = 8 bytes data\n                         if (buf.readerIndex() + 8 <= dataEndIndex) {\n                            int mcc = buf.readUnsignedShortLE();\n                            int mnc = buf.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            // Read cell towers until the end of this field's data\n                            while (buf.readerIndex() + 5 <= dataEndIndex) { // 5 bytes per cell\n                                int rssi = buf.readByte();\n                                int lac = buf.readUnsignedShortLE();\n                                int cid = buf.readUnsignedShortLE();\n                                position.getNetwork().addCellTower(CellTower.from(mcc, mnc, lac, cid, rssi));\n                            }\n                         }\n                        break;\n                    case 0x22: // Location WiFi\n                         // Min length: 1 AP[rssi(1)+mac(6)=7] = 7 bytes data\n                         if (buf.readerIndex() + 7 <= dataEndIndex) {\n                             if (position.getNetwork() == null) {\n                                 position.setNetwork(new Network());\n                             }\n                             // Read WiFi APs until the end of this field's data\n                             while (buf.readerIndex() + 7 <= dataEndIndex) { // 7 bytes per AP\n                                 int rssi = buf.readByte();\n                                 String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                 position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                         mac.substring(0, mac.length() - 1), rssi));\n                             }\n                         }\n                        break;\n                    case 0x23: // Location Tag (tagId(7)+lat(4)+lon(4)=15 bytes data)\n                        if (buf.readerIndex() + 15 <= dataEndIndex) {\n                            position.set(\"tagId\", readTagId(buf));\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true); // Assume valid if tag location provided\n                            hasLocation = true;\n                        }\n                        break;\n                    case 0x24: // Time and Status (time(4)+status(4)=8 bytes data)\n                        if (buf.readerIndex() + 8 <= dataEndIndex) {\n                            position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                            long status = buf.readUnsignedIntLE();\n                            // Extract battery level from status (assuming bits 24-31)\n                            position.set(Position.KEY_BATTERY_LEVEL, (int)(status >> 24) & 0xFF);\n                            position.set(Position.KEY_STATUS, status);\n                        }\n                        break;\n                    case 0x28: // Location Beacon\n                        // Min length: flags(1)+id(7)+rssi(1)+1mRssi(1) = 10 bytes data\n                        if (buf.readerIndex() + 10 <= dataEndIndex) {\n                            int beaconFlags = buf.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(buf));\n                            position.set(\"tagRssi\", (int) buf.readByte());\n                            position.set(\"tag1mRssi\", (int) buf.readByte());\n                            // Check flag for included location data\n                            if (BitUtil.check(beaconFlags, 7)) {\n                                if (buf.readerIndex() + 8 <= dataEndIndex) { // Check bytes for lat/lon\n                                    position.setLatitude(buf.readIntLE() * 0.0000001);\n                                    position.setLongitude(buf.readIntLE() * 0.0000001);\n                                    position.setValid(true); // Assume valid if beacon provides location\n                                    hasLocation = true;\n                                }\n                            }\n                            // Check flag for included description\n                            if (BitUtil.check(beaconFlags, 6)) {\n                                int remainingBytes = dataEndIndex - buf.readerIndex();\n                                if (remainingBytes > 0) {\n                                    position.set(\"description\", buf.readCharSequence(\n                                            remainingBytes, StandardCharsets.US_ASCII).toString());\n                                }\n                            }\n                        }\n                        break;\n                    case 0x2A: // WiFi Positioning Result (flags(1)+mac(6)+rssi(1)+lat(4)+lon(4)=15 bytes data)\n                        if (buf.readerIndex() + 15 <= dataEndIndex) {\n                             buf.readUnsignedByte(); // flags\n                             buf.skipBytes(6); // mac\n                             buf.readUnsignedByte(); // rssi\n                             position.setLatitude(buf.readIntLE() * 0.0000001);\n                             position.setLongitude(buf.readIntLE() * 0.0000001);\n                             position.setValid(true); // Assume valid if WiFi positioning provides location\n                             hasLocation = true;\n                         }\n                        break;\n                    case 0x30: // Steps (timestamp(4)+steps(4)=8 bytes data)\n                        if (buf.readerIndex() + 8 <= dataEndIndex) {\n                            buf.readUnsignedIntLE(); // timestamp (ignore)\n                            position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x31: // Activity (time(4)+activity(4)=8 bytes data per entry)\n                        // Ensure there's at least one entry and length is multiple of 8\n                        if (buf.readerIndex() + 8 <= dataEndIndex && (dataEndIndex - buf.readerIndex()) % 8 == 0) {\n                            int i = 1;\n                            while (buf.readerIndex() + 8 <= dataEndIndex) {\n                                position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                                position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                                i += 1;\n                            }\n                        }\n                        break;\n                    case 0x37: // Bark Count (timestamp(4)+count(4)=8 bytes data) (FIX ADDED)\n                        if (buf.readerIndex() + 8 <= dataEndIndex) {\n                            buf.readUnsignedIntLE(); // timestamp (ignore)\n                            position.set(\"barkCount\", buf.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x40: // Heart Rate (timestamp(4)+hr(1)=5 bytes data)\n                         if (buf.readerIndex() + 5 <= dataEndIndex) {\n                            buf.readUnsignedIntLE(); // timestamp (ignore)\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) { // Basic validity check for heart rate\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                         }\n                        break;\n                    default:\n                        // Unknown key: data will be skipped by readerIndex adjustment below\n                        break;\n                }\n                // Ensure reader index is set to the end of the field's data,\n                // regardless of whether processing was successful or skipped.\n                buf.readerIndex(dataEndIndex);\n            }\n\n            // Add the last collected position object if it contains meaningful data\n            if (!hasLocation && position.getLatitude() == 0 && position.getLongitude() == 0) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n             if (positions.isEmpty() || position.getAttributes().size() > 0 || position.getFixTime() != null || (position.getValid() != null && position.getValid()) || (position.getLatitude() != 0 || position.getLongitude() != 0)) {\n               positions.add(position);\n            }\n\n            // Final processing and validation\n            if (deviceSession != null) {\n                // Associate deviceId if somehow missed (should be set earlier)\n                // Set server time if position time is missing\n                for (Position p : positions) {\n                    if (p.getDeviceId() == 0) {\n                        p.setDeviceId(deviceSession.getDeviceId());\n                    }\n                    if (p.getFixTime() == null) {\n                        p.setTime(new Date()); // Use server time as fallback\n                    }\n                }\n            } else {\n                // If no device session was identified (e.g., no IMEI field received),\n                // we cannot link the positions to a device. Return null.\n                return null;\n            }\n\n            return positions.isEmpty() ? null : positions;\n\n        }\n\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}