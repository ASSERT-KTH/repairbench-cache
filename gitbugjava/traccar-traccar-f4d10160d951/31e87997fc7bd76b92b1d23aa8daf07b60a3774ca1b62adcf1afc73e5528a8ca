{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedByte(); // header\n        int flags = buf.readUnsignedByte();\n        int length = buf.readUnsignedShortLE(); // length of payload after type\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        int startIndex = buf.readerIndex(); // Index at the start of data payload\n        int endIndexOverall = startIndex + length; // Index right after the data payload as defined by length field\n\n        // Ensure the calculated end index is not beyond the actual buffer writer index\n        if (endIndexOverall > buf.writerIndex()) {\n            Log.warning(\"Declared length (\" + length + \") exceeds buffer readable bytes (\"\n                    + buf.readableBytes() + \" remaining) in Minifinder2 message. Truncating to buffer size.\");\n            endIndexOverall = buf.writerIndex(); // Adjust to prevent read errors\n        }\n\n\n        if (BitUtil.check(flags, 4)) {\n            // Assuming sendResponse doesn't modify the buffer's reader index\n            sendResponse(channel, remoteAddress, index, type, buf.retainedDuplicate());\n        }\n\n        if (type == MSG_DATA) {\n\n            List<Position> positions = new LinkedList<>();\n            DeviceSession deviceSession = null; // Determined by first 0x01 key\n            Position currentPosition = null; // Holds the position being built\n            Set<Integer> currentKeys = null; // Keys for the current position\n            boolean currentHasLocation = false;\n\n            while (buf.readerIndex() < endIndexOverall) {\n                // Check if there are enough bytes for block length and key (at least 2 bytes)\n                if (endIndexOverall - buf.readerIndex() < 2) {\n                    if (endIndexOverall > buf.readerIndex()) { // Log if there were unexpected leftover bytes\n                         Log.warning(\"Truncated block header (\" + (endIndexOverall - buf.readerIndex())\n                                 + \" bytes remaining) in Minifinder2 message. Stopping parse.\");\n                    }\n                    break; // Not enough data for a valid block header\n                }\n\n                int blockStartIndex = buf.readerIndex();\n                int blockLength = buf.readUnsignedByte(); // Length includes key byte + value bytes\n\n                if (blockLength == 0) {\n                    Log.warning(\"Zero block length encountered in Minifinder2 message, stopping parse.\");\n                    break; // Avoid potential infinite loop or reading past end\n                }\n\n                // Calculate expected reader index after processing this block\n                int nextBlockReaderIndex = blockStartIndex + blockLength;\n\n                // Check if block length is valid within overall payload boundaries\n                if (nextBlockReaderIndex > endIndexOverall) {\n                    Log.warning(\"Block length \" + blockLength + \" exceeds remaining packet length (\"\n                            + (endIndexOverall - blockStartIndex) + \") in Minifinder2 message, stopping parse.\");\n                    break; // Avoid reading past declared payload end\n                }\n\n                // We've already checked blockLength > 0. blockLength=1 means only key, no value bytes.\n                int key = buf.readUnsignedByte();\n                int valueLength = blockLength - 1; // Calculate length of the value data\n\n                // Check if buffer actually contains enough bytes for the declared value length *before* the next block\n                // (This check prevents IndexOutOfBounds if a case tries to read valueLength bytes)\n                if (buf.readerIndex() + valueLength > nextBlockReaderIndex) {\n                    // This implies an internal inconsistency or buffer truncation issues not caught earlier.\n                     Log.warning(\"Buffer underflow or inconsistency: needed \" + valueLength + \" value bytes for key \"\n                             + String.format(\"0x%02X\", key) + \", but block ends at \" + nextBlockReaderIndex\n                             + \" (current index \" + buf.readerIndex() + \"). Stopping parse.\");\n                     break;\n                }\n\n                // Define end index for value reading within the switch cases if needed, relative to current reader index\n                int valueEndIndex = buf.readerIndex() + valueLength;\n\n                // Logic to start a new position or use the existing one\n                if (currentPosition == null || (currentKeys != null && currentKeys.contains(key))) {\n                    // Finalize the previous position if it exists and seems valid\n                    if (currentPosition != null && currentKeys != null) {\n                        if (deviceSession != null) { // Ensure deviceId is set from session if available\n                            currentPosition.setDeviceId(deviceSession.getDeviceId());\n                        }\n                        // A position is valid if it has a deviceId and either time or location info\n                        if (currentPosition.getDeviceId() != 0) {\n                            if (!currentHasLocation) { // If no location data was explicitly parsed...\n                                 // Try to fetch last known location, using time as a hint if available\n                                 getLastLocation(currentPosition, currentPosition.getFixTime());\n                                 // Update currentHasLocation if getLastLocation succeeded\n                                 if (currentPosition.getLatitude() != 0.0 || currentPosition.getLongitude() != 0.0) {\n                                    currentHasLocation = true;\n                                 }\n                            }\n                            // Add position if it has time or location info\n                            if (currentPosition.getFixTime() != null || currentHasLocation) {\n                                positions.add(currentPosition);\n                            } else { Log.info(\"Discarding incomplete position (no time/location) before key \" + String.format(\"0x%02X\", key) + \" repetition\"); }\n                        } else { Log.info(\"Discarding position block (no deviceId) before key \" + String.format(\"0x%02X\", key) + \" repetition\"); }\n                    }\n                    // Start a new position object\n                    currentPosition = new Position(getProtocolName());\n                    currentKeys = new HashSet<>();\n                    currentHasLocation = false;\n                    if (deviceSession != null) { // Carry over device session if already known\n                        currentPosition.setDeviceId(deviceSession.getDeviceId());\n                    }\n                }\n                // Add the current key to the set for the position being built\n                 if (currentKeys != null) {\n                    currentKeys.add(key);\n                 } else {\n                     // This state should be unreachable if currentPosition is handled correctly\n                     Log.error(\"Internal state error: currentKeys is null when processing key \" + String.format(\"0x%02X\", key));\n                     buf.readerIndex(nextBlockReaderIndex); // Attempt to skip block and continue\n                     continue;\n                 }\n\n                 // Process key-value pair based on the key\n                 try { // Add try-catch around switch for robustness against parsing errors within cases\n                     switch (key) {\n                         case 0x01: // IMEI / Device ID\n                             if (valueLength >= 15) {\n                                 String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                                 if (deviceSession == null) { // Get session only once per message if possible\n                                     deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                                 }\n                                 if (deviceSession != null) {\n                                     currentPosition.setDeviceId(deviceSession.getDeviceId());\n                                 } else { Log.warning(\"Device session not found for IMEI: \" + imei); }\n                             } else {\n                                 Log.warning(\"Incorrect length (\" + valueLength + \") for IMEI field (0x01) in Minifinder2\");\n                             }\n                             break; // Rely on index setting below to handle exact position\n                         case 0x02: // Alarm / Bark event\n                             if (valueLength >= 4) {\n                                 long alarm = buf.readUnsignedIntLE();\n                                 currentPosition.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                                 if (BitUtil.check(alarm, 31)) {\n                                     currentPosition.set(\"bark\", true); // Special flag for bark alarm\n                                 }\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Alarm field (0x02) in Minifinder2\"); }\n                             break;\n                         case 0x14: // Battery Info\n                             if (valueLength >= 3) {\n                                 currentPosition.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); // Percentage\n                                 currentPosition.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001); // Voltage\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Battery field (0x14) in Minifinder2\"); }\n                             break;\n                         case 0x20: // Location Data\n                              if (valueLength >= 21) {\n                                  currentHasLocation = true;\n                                  currentPosition.setLatitude(buf.readIntLE() * 0.0000001);\n                                  currentPosition.setLongitude(buf.readIntLE() * 0.0000001);\n                                  currentPosition.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                                  currentPosition.setCourse(buf.readUnsignedShortLE());\n                                  currentPosition.setAltitude(buf.readShortLE());\n                                  int hdop = buf.readUnsignedShortLE();\n                                  currentPosition.setValid(hdop > 0 && hdop < 500); // Use HDOP for validity (threshold might need adjustment)\n                                  currentPosition.set(Position.KEY_HDOP, hdop * 0.1);\n                                  currentPosition.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                                  currentPosition.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                              } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Location field (0x20) in Minifinder2\"); }\n                              break;\n                         case 0x21: // Cell Tower Data\n                              if (valueLength >= 3) { // Need MCC(2) + MNC(1) at minimum\n                                  int mcc = buf.readUnsignedShortLE();\n                                  int mnc = buf.readUnsignedByte();\n                                  if (currentPosition.getNetwork() == null) {\n                                      currentPosition.setNetwork(new Network());\n                                  }\n                                  // Each cell tower record: rssi(1) + lac(2) + cid(2) = 5 bytes\n                                  while (buf.readerIndex() <= valueEndIndex - 5) {\n                                      int rssi = buf.readByte();\n                                      int lac = buf.readUnsignedShortLE();\n                                      int cid = buf.readUnsignedShortLE();\n                                      // Basic validation for cell info\n                                      if (mcc >= 100 && mcc <= 999 && mnc >= 0 && mnc <= 999 && lac > 0 && lac < 65535 && cid > 0) {\n                                         currentPosition.getNetwork().addCellTower(CellTower.from(mcc, mnc, lac, cid, rssi));\n                                      } else {\n                                         Log.warning(\"Invalid cell data skipped: MCC=\" + mcc + \", MNC=\" + mnc + \", LAC=\" + lac + \", CID=\" + cid);\n                                      }\n                                  }\n                              } else if (valueLength > 0) { // Log if not empty but too short for MCC/MNC\n                                  Log.warning(\"Incorrect length (\" + valueLength + \") for Cell field (0x21) in Minifinder2\");\n                              }\n                             break;\n                         case 0x22: // WiFi Access Points\n                              // Each AP record: rssi(1) + mac(6) = 7 bytes\n                              if (valueLength >= 7 && (valueLength % 7 == 0)) { // Check if length is multiple of 7\n                                  if (currentPosition.getNetwork() == null) {\n                                      currentPosition.setNetwork(new Network());\n                                  }\n                                  while (buf.readerIndex() <= valueEndIndex - 7) {\n                                      int rssi = buf.readByte();\n                                      // Read MAC and format it\n                                      String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                      currentPosition.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                              mac.substring(0, mac.length() - 1), rssi));\n                                  }\n                              } else if (valueLength > 0) { // Log if not empty but not a multiple of 7\n                                  Log.warning(\"Incorrect length (\" + valueLength + \") for WiFi field (0x22) in Minifinder2\");\n                              }\n                             break;\n                         case 0x23: // Tag Location (e.g., BLE tag reported by device)\n                             if (valueLength >= 14) { // Expects tagId (6) + lat (4) + long (4)\n                                 currentPosition.set(\"tagId\", readTagId(buf)); // Assuming readTagId reads 6 bytes\n                                 currentPosition.setLatitude(buf.readIntLE() * 0.0000001);\n                                 currentPosition.setLongitude(buf.readIntLE() * 0.0000001);\n                                 currentPosition.setValid(true); // Assume reported tag location is valid\n                                 currentHasLocation = true; // This contributes location info\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Tag Location field (0x23) in Minifinder2\"); }\n                             break;\n                         case 0x24: // Time and Status\n                             if (valueLength >= 8) { // Expects time (4) + status (4)\n                                 currentPosition.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                                 long status = buf.readUnsignedIntLE();\n                                 // Original code used BitUtil.from(status, 24) - assuming it meant 8 bits from bit 24\n                                 currentPosition.set(Position.KEY_BATTERY_LEVEL, (int)((status >> 24) & 0xFF));\n                                 currentPosition.set(Position.KEY_STATUS, status);\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Time/Status field (0x24) in Minifinder2\"); }\n                             break;\n                         case 0x28: // BLE Beacon Data (as seen by device)\n                              if (valueLength >= 9) { // flags (1) + tagId (6) + rssi (1) + 1mRssi (1) = 9 bytes minimum\n                                  int beaconFlags = buf.readUnsignedByte();\n                                  currentPosition.set(\"tagId\", readTagId(buf));\n                                  currentPosition.set(\"tagRssi\", (int) buf.readByte());\n                                  currentPosition.set(\"tag1mRssi\", (int) buf.readByte()); // Tx Power / Calibrated RSSI\n                                  if (BitUtil.check(beaconFlags, 7)) { // Location might follow\n                                      if (buf.readerIndex() <= valueEndIndex - 8) { // Check for lat(4) + long(4)\n                                          currentPosition.setLatitude(buf.readIntLE() * 0.0000001);\n                                          currentPosition.setLongitude(buf.readIntLE() * 0.0000001);\n                                          currentPosition.setValid(true); // Assume valid if provided\n                                          currentHasLocation = true;\n                                      } else { Log.warning(\"Not enough bytes for Beacon Lat/Lon in field 0x28\"); }\n                                  }\n                                  if (BitUtil.check(beaconFlags, 6)) { // Description might follow\n                                      int remaining = valueEndIndex - buf.readerIndex();\n                                      if (remaining > 0) {\n                                          // Read description, ensure not reading past valueEndIndex\n                                          currentPosition.set(\"description\", buf.readCharSequence(remaining, StandardCharsets.US_ASCII).toString());\n                                      }\n                                  }\n                              } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Beacon field (0x28) in Minifinder2\"); }\n                             break;\n                         case 0x2A: // WiFi Location (reported by device based on an AP?)\n                              if (valueLength >= 16) { // flags (1) + mac (6) + rssi (1) + lat (4) + long (4) = 16 bytes\n                                  buf.readUnsignedByte(); // flags - ignore?\n                                  buf.skipBytes(6); // mac - ignore? could store it: position.set(\"wifiApMac\", ByteBufUtil.hexDump(buf.readSlice(6))...)\n                                  buf.readUnsignedByte(); // rssi - ignore? could store it: position.set(\"wifiApRssi\", buf.readByte())\n                                  currentPosition.setLatitude(buf.readIntLE() * 0.0000001);\n                                  currentPosition.setLongitude(buf.readIntLE() * 0.0000001);\n                                  currentPosition.setValid(true); // Assume valid\n                                  currentHasLocation = true;\n                              } else { Log.warning(\"Incorrect length (\" + valueLength + \") for field 0x2A in Minifinder2\"); }\n                              break;\n                         case 0x30: // Step Count Data\n                             if (valueLength >= 8) { // Assuming timestamp (4) + steps (4)\n                                 buf.readUnsignedIntLE(); // Read and ignore timestamp? Could store if needed.\n                                 currentPosition.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Steps field (0x30) in Minifinder2\"); }\n                             break;\n                         case 0x31: // Activity Data (e.g., walking/running time/count)\n                              if (valueLength >= 8 && (valueLength % 8 == 0)) { // Each entry: time(4) + activity(4) = 8 bytes\n                                 int i = 1;\n                                 while (buf.readerIndex() <= valueEndIndex - 8) {\n                                     currentPosition.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE()); // Duration? Timestamp?\n                                     currentPosition.set(\"activity\" + i, buf.readUnsignedIntLE()); // Count? Type?\n                                     i += 1;\n                                 }\n                              } else if (valueLength > 0) { // Log if not empty but not multiple of 8\n                                   Log.warning(\"Incorrect length (\" + valueLength + \") for Activity field (0x31) in Minifinder2\");\n                              }\n                             break;\n                         case 0x37: // Bark Count Data (added based on test case)\n                             if (valueLength >= 8) { // Assuming timestamp (4) + count (4) structure\n                                 buf.readUnsignedIntLE(); // Read and ignore timestamp?\n                                 // Test expects Long, read unsigned int and cast\n                                 currentPosition.set(\"barkCount\", buf.readUnsignedIntLE());\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Bark Count field (0x37) in Minifinder2\"); }\n                             break;\n                         case 0x40: // Heart Rate Data\n                             if (valueLength >= 5) { // Assuming timestamp (4) + heartRate (1)\n                                 buf.readUnsignedIntLE(); // Read and ignore timestamp?\n                                 int heartRate = buf.readUnsignedByte();\n                                 if (heartRate > 1 && heartRate < 255) { // Basic sanity check for heart rate\n                                     currentPosition.set(Position.KEY_HEART_RATE, heartRate);\n                                 }\n                             } else { Log.warning(\"Incorrect length (\" + valueLength + \") for Heart Rate field (0x40) in Minifinder2\"); }\n                             break;\n                         default:\n                             Log.info(\"Unknown Minifinder2 key: \" + String.format(\"0x%02X\", key) + \" with value length \" + valueLength);\n                             // Value bytes will be skipped by setting reader index below\n                             break;\n                     }\n                 } catch (Exception e) {\n                      Log.warning(\"Error parsing Minifinder2 key \" + String.format(\"0x%02X\", key) + \": \" + e.getMessage(), e);\n                      // Attempt to recover by skipping to the next block\n                 }\n\n                // Ensure reader index is positioned correctly for the next block,\n                // even if a case read too much, too little, skipped due to error, or didn't read full valueLength.\n                if (buf.readerIndex() > nextBlockReaderIndex) {\n                     Log.warning(\"Decoder for key \" + String.format(\"0x%02X\", key) + \" read past intended block boundary (\" + buf.readerIndex() + \" > \" + nextBlockReaderIndex + \"). Resetting index.\");\n                } else if (buf.readerIndex() < nextBlockReaderIndex) {\n                    Log.info(\"Decoder for key \" + String.format(\"0x%02X\", key) + \" did not read full value length (\" + buf.readerIndex() + \" < \" + nextBlockReaderIndex + \"). Advancing index.\");\n                }\n                // Set reader index rigorously to the calculated end of the current block\n                buf.readerIndex(nextBlockReaderIndex);\n\n            } // End while loop parsing blocks\n\n            // Finalize the last position that was being built\n            if (currentPosition != null) {\n                if (deviceSession != null) {\n                    currentPosition.setDeviceId(deviceSession.getDeviceId());\n                }\n                // Check validity again before adding\n                if (currentPosition.getDeviceId() != 0) {\n                     if (!currentHasLocation) {\n                         getLastLocation(currentPosition, currentPosition.getFixTime());\n                         if (currentPosition.getLatitude() != 0.0 || currentPosition.getLongitude() != 0.0) {\n                            currentHasLocation = true;\n                         }\n                     }\n                     if (currentPosition.getFixTime() != null || currentHasLocation) {\n                        positions.add(currentPosition);\n                    } else { Log.info(\"Discarding final incomplete position (no time/location)\"); }\n                } else { Log.info(\"Discarding final position block (no deviceId)\"); }\n            }\n\n            return positions.isEmpty() ? null : positions;\n\n        } // End if (type == MSG_DATA)\n\n        return null; // Return null if type was not MSG_DATA or if no positions were generated\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}