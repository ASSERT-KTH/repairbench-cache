{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedByte(); // header\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length - potentially unreliable, use buffer limits instead\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        if (BitUtil.check(flags, 4)) {\n            sendResponse(channel, remoteAddress, index, type, buf);\n        }\n\n        // MSG_DATA type might contain multiple position records split by repeating keys\n        if (type == MSG_DATA) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n            DeviceSession deviceSession = null; // Session needs to be determined within the loop for the list\n\n            while (buf.isReadable()) {\n                int dataStartIndex = buf.readerIndex();\n                if (buf.readableBytes() < 1) {\n                    break; // Not enough data for length byte\n                }\n                int dataLength = buf.readUnsignedByte();\n                if (dataLength == 0) {\n                    break; // Avoid infinite loop, potentially indicates end\n                }\n                int keyIndex = buf.readerIndex();\n                int endIndex = keyIndex + dataLength; // endIndex is after the value data associated with the key\n\n                if (endIndex > buf.writerIndex()) {\n                    // Log warning: Invalid length field, exceeds buffer limits\n                    break;\n                }\n                if (!buf.isReadable()) { // Check if key can be read\n                    // Log warning: Not enough data for key\n                    break;\n                }\n                int key = buf.readUnsignedByte();\n\n                // Handle splitting logic for MSG_DATA based on repeated keys\n                if (keys.contains(key)) {\n                    if (!hasLocation && position.getDeviceId() != 0) {\n                        getLastLocation(position, null); // Get last known location if current record has none\n                    }\n                    // Only add non-empty positions\n                    if (position.getDeviceId() != 0 || !position.getAttributes().isEmpty() || position.getFixTime() != null || position.getValid() != null) {\n                        positions.add(position); // Add the completed position\n                    }\n                    keys.clear();\n                    hasLocation = false;\n                    position = new Position(getProtocolName()); // Start new position\n                    if (deviceSession != null) { // Carry over deviceId to new position instance\n                        position.setDeviceId(deviceSession.getDeviceId());\n                    }\n                }\n                keys.add(key);\n\n                // Decode key data into the current 'position'\n                switch (key) {\n                    case 0x01:\n                        if (endIndex - buf.readerIndex() >= 15) {\n                            String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                            deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                            if (deviceSession != null) {\n                                position.setDeviceId(deviceSession.getDeviceId());\n                            }\n                        }\n                        break;\n                    case 0x02:\n                        if (endIndex - buf.readerIndex() >= 4) {\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                        }\n                        break;\n                    case 0x14:\n                        if (endIndex - buf.readerIndex() >= 3) {\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                        }\n                        break;\n                    case 0x20:\n                        if (endIndex - buf.readerIndex() >= 23) {\n                            hasLocation = true;\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                            position.setCourse(buf.readUnsignedShortLE());\n                            position.setAltitude(buf.readShortLE());\n                            int hdop = buf.readUnsignedShortLE();\n                            position.setValid(hdop > 0);\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                        }\n                        break;\n                    case 0x21:\n                        if (endIndex - buf.readerIndex() >= 3) { // MCC (2) + MNC (1)\n                            int mcc = buf.readUnsignedShortLE();\n                            int mnc = buf.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            while (buf.readerIndex() < endIndex && endIndex - buf.readerIndex() >= 5) { // RSSI (1) + LAC (2) + CID (2)\n                                int rssi = buf.readByte();\n                                position.getNetwork().addCellTower(CellTower.from(\n                                        mcc, mnc, buf.readUnsignedShortLE(), buf.readUnsignedShortLE(), rssi));\n                            }\n                        }\n                        break;\n                    case 0x22:\n                        if (position.getNetwork() == null) {\n                            position.setNetwork(new Network());\n                        }\n                        while (buf.readerIndex() < endIndex && endIndex - buf.readerIndex() >= 7) { // RSSI (1) + MAC (6)\n                            int rssi = buf.readByte();\n                            String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                            position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                    mac.substring(0, mac.length() - 1), rssi));\n                        }\n                        break;\n                    case 0x23:\n                         if (endIndex - buf.readerIndex() >= 14) { // Tag ID (6) + Lat (4) + Lon (4)\n                            position.set(\"tagId\", readTagId(buf));\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                        }\n                        break;\n                    case 0x24:\n                        if (endIndex - buf.readerIndex() >= 8) { // Time (4) + Status (4)\n                            position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                            long status = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                            position.set(Position.KEY_STATUS, status);\n                        }\n                        break;\n                    case 0x28:\n                        if (endIndex - buf.readerIndex() >= 8) { // Flags (1) + Tag ID (6) + RSSI (1)\n                            int beaconFlags = buf.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(buf));\n                            position.set(\"tagRssi\", (int) buf.readByte());\n                            if (endIndex - buf.readerIndex() >= 1) { // 1m RSSI (1)\n                                position.set(\"tag1mRssi\", (int) buf.readByte());\n                            }\n                            if (BitUtil.check(beaconFlags, 7) && endIndex - buf.readerIndex() >= 8) { // Lat (4) + Lon (4)\n                                position.setLatitude(buf.readIntLE() * 0.0000001);\n                                position.setLongitude(buf.readIntLE() * 0.0000001);\n                                position.setValid(true);\n                                hasLocation = true;\n                            }\n                            if (BitUtil.check(beaconFlags, 6)) {\n                                int descriptionLength = endIndex - buf.readerIndex();\n                                if (descriptionLength > 0) {\n                                    position.set(\"description\", buf.readCharSequence(\n                                            descriptionLength, StandardCharsets.US_ASCII).toString());\n                                }\n                            }\n                        }\n                        break;\n                    case 0x2A:\n                        if (endIndex - buf.readerIndex() >= 16) { // Flags (1) + MAC (6) + RSSI (1) + Lat (4) + Lon (4)\n                            buf.readUnsignedByte(); // flags\n                            buf.skipBytes(6); // mac\n                            buf.readUnsignedByte(); // rssi\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                        }\n                        break;\n                    case 0x30:\n                        if (endIndex - buf.readerIndex() >= 8) { // Timestamp (4) + Steps (4)\n                            buf.readUnsignedIntLE(); // timestamp\n                            position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x31:\n                        int i = 1;\n                        while (buf.readerIndex() < endIndex && endIndex - buf.readerIndex() >= 8) { // Time (4) + Activity (4)\n                            position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                            position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                            i += 1;\n                        }\n                        break;\n                    case 0x37: // Bark count (added for test case)\n                        if (endIndex - buf.readerIndex() >= 8) { // Timestamp (4) + Count (4) ?\n                             buf.readUnsignedIntLE(); // Assume timestamp based on other similar keys\n                             position.set(\"barkCount\", buf.readUnsignedIntLE());\n                         }\n                         break;\n                    case 0x40:\n                        if (endIndex - buf.readerIndex() >= 5) { // Timestamp (4) + HR (1)\n                            buf.readUnsignedIntLE(); // timestamp\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) {\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                        }\n                        break;\n                    default:\n                        // Unknown key, data will be skipped by setting readerIndex below\n                        break;\n                }\n\n                // Ensure readerIndex is advanced to endIndex, even if the key was unknown or reading failed mid-way\n                if (buf.readerIndex() > endIndex) {\n                    // Log error: Read past end index within switch case for key 'key'\n                    break; // Exit loop, message is likely corrupt\n                } else {\n                    // Skip any remaining bytes in this block if not fully read by switch case\n                    buf.readerIndex(endIndex);\n                }\n            } // End while loop for MSG_DATA\n\n            // Final position handling for MSG_DATA\n            if (!hasLocation && position.getDeviceId() != 0) {\n                getLastLocation(position, null);\n            }\n            // Only add the last non-empty position\n            if (position.getDeviceId() != 0 || !position.getAttributes().isEmpty() || position.getFixTime() != null || position.getValid() != null) {\n                positions.add(position); // Add the last position being worked on\n            }\n\n            if (positions.isEmpty()) {\n                return null; // No valid positions decoded\n            }\n\n            // Ensure all positions have the deviceId if the session was established\n            if (deviceSession != null) {\n                for (Position p : positions) {\n                    // Ensure deviceId is set, especially if key 0x01 wasn't first or position was created before session found\n                    if (p.getDeviceId() == 0) {\n                       p.setDeviceId(deviceSession.getDeviceId());\n                    }\n                }\n                return positions;\n            } else {\n                // If deviceSession is still null, we can't associate the data, return null\n                // unless a position somehow got a deviceId via getLastLocation? Check if any position has deviceId.\n                boolean hasAnyDeviceId = false;\n                for(Position p : positions) {\n                    if(p.getDeviceId() != 0) {\n                        hasAnyDeviceId = true;\n                        break;\n                    }\n                }\n                return hasAnyDeviceId ? positions : null;\n            }\n\n        } else { // Handle non-MSG_DATA types (e.g., Login, Alarm) where attributes might be present\n\n            Position position = new Position(getProtocolName());\n            DeviceSession deviceSession = null;\n            boolean dataFound = false; // Track if any useful data is decoded\n\n            while (buf.isReadable()) { // Loop through key-value pairs\n                int dataStartIndex = buf.readerIndex();\n                if (buf.readableBytes() < 1) break;\n                int dataLength = buf.readUnsignedByte();\n                if (dataLength == 0) break;\n                int keyIndex = buf.readerIndex();\n                int endIndex = keyIndex + dataLength;\n\n                if (endIndex > buf.writerIndex()) break; // Invalid length\n                if (!buf.isReadable()) break; // Not enough data for key\n                int key = buf.readUnsignedByte();\n\n                // Decode key data into the single 'position' object\n                switch (key) {\n                    case 0x01: // IMEI / Device ID\n                        if (endIndex - buf.readerIndex() >= 15) {\n                            String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                            deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                            if (deviceSession != null) {\n                                position.setDeviceId(deviceSession.getDeviceId());\n                                dataFound = true; // Found device ID is considered useful data\n                            }\n                        }\n                        break;\n                    case 0x02: // Alarm\n                        if (endIndex - buf.readerIndex() >= 4) {\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                            dataFound = true; // Found alarm data\n                        }\n                        break;\n                    case 0x14: // Battery\n                         if (endIndex - buf.readerIndex() >= 3) {\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                            dataFound = true;\n                         }\n                        break;\n                    case 0x24: // Time/Status - Important for non-location messages too\n                        if (endIndex - buf.readerIndex() >= 8) {\n                            position.setTime(new Date(buf.readUnsignedIntLE() * 1000)); // Set time\n                            long status = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                            position.set(Position.KEY_STATUS, status);\n                            dataFound = true;\n                        }\n                        break;\n                    case 0x37: // Bark count (added for test case)\n                        if (endIndex - buf.readerIndex() >= 8) {\n                            buf.readUnsignedIntLE(); // timestamp\n                            position.set(\"barkCount\", buf.readUnsignedIntLE());\n                            dataFound = true; // Found bark count\n                        }\n                        break;\n                    // Add other non-location keys if they can appear in non-MSG_DATA messages\n                    // e.g., 0x30 (Steps), 0x40 (Heart Rate) might be relevant\n                    case 0x30: // Steps\n                        if (endIndex - buf.readerIndex() >= 8) { // Timestamp (4) + Steps (4)\n                            buf.readUnsignedIntLE(); // timestamp\n                            position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                            dataFound = true;\n                        }\n                        break;\n                    case 0x40: // Heart Rate\n                        if (endIndex - buf.readerIndex() >= 5) { // Timestamp (4) + HR (1)\n                            buf.readUnsignedIntLE(); // timestamp\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) {\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                            dataFound = true; // Even if HR is 0 or 1, the key was present\n                        }\n                        break;\n                    // Location-specific keys (0x20, 0x21, 0x22, 0x23, 0x28, 0x2A) are usually part of MSG_DATA\n                    // and are omitted here to avoid returning partial location data from non-location messages.\n                    default:\n                        // Unknown key for this message type, data will be skipped\n                        break;\n                }\n\n                // Ensure readerIndex is advanced to endIndex\n                if (buf.readerIndex() > endIndex) {\n                    // Log error: Read past end index within switch case for key 'key'\n                    break; // Exit loop\n                } else {\n                    buf.readerIndex(endIndex);\n                }\n            } // End while loop for non-MSG_DATA\n\n            // Return the single position if we identified the device AND found some relevant data\n            if (deviceSession != null && dataFound) {\n                 // If no time was present (key 0x24), position might lack time.\n                 // getLastLocation might be needed if returning attribute-only positions is undesirable.\n                 // For now, return what was decoded.\n                return position;\n            } else {\n                // No device session or no relevant data fields found for this message type\n                return null;\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}