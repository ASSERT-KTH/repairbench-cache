{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf messageBuffer = (ByteBuf) msg; // Renamed to avoid conflict with 'buf' used for item payload\n\n        messageBuffer.readUnsignedByte(); // header\n        int flags = messageBuffer.readUnsignedByte();\n        // This length field specifies the length of the block: (checksum, index, type, TLVs)\n        int payloadBlockLength = messageBuffer.readUnsignedShortLE();\n        messageBuffer.readUnsignedShortLE(); // checksum\n        int index = messageBuffer.readUnsignedShortLE();\n        int type = messageBuffer.readUnsignedByte();\n\n        // The fixed part of the payload (checksum, index, type) is 2+2+1=5 bytes.\n        // So, the actual length of the TLV data block is payloadBlockLength - 5.\n        int tlvDataLength = payloadBlockLength - 5;\n        if (tlvDataLength < 0) {\n            // Invalid length, indicates a malformed packet\n            return null;\n        }\n\n        if (BitUtil.check(flags, 4)) {\n            // Pass the main buffer; its readerIndex is at the start of the TLV block.\n            // sendResponse might inspect data from this point or just use index/type.\n            sendResponse(channel, remoteAddress, index, type, messageBuffer);\n        }\n\n        if (type == MSG_DATA) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n\n            DeviceSession deviceSession = null;\n\n            // Create a slice for the TLV data block to ensure we only parse within this boundary\n            ByteBuf tlvFrameBuffer = messageBuffer.readSlice(tlvDataLength);\n\n            while (tlvFrameBuffer.readableBytes() > 1) { // Need at least 1 byte for L_kv and 1 byte for K\n                int lengthOfKeyAndValue = tlvFrameBuffer.readUnsignedByte(); // This is L_kv (length of Key + Value_data)\n\n                if (lengthOfKeyAndValue == 0) {\n                    // Length 0 might be a padding or termination marker. Stop processing.\n                    break;\n                }\n                if (tlvFrameBuffer.readableBytes() < lengthOfKeyAndValue) {\n                    // Not enough bytes remaining in tlvFrameBuffer for this item's stated K+V length.\n                    // Indicates a corrupted TLV block.\n                    break;\n                }\n\n                // Create a slice for the current TLV item's (Key + Value_data).\n                // Name this slice 'buf' to align with original variable name in switch cases.\n                ByteBuf buf = tlvFrameBuffer.readSlice(lengthOfKeyAndValue);\n                \n                if (!buf.isReadable()) { // Should have at least Key byte\n                    break; // Should not happen if lengthOfKeyAndValue > 0\n                }\n                int key = buf.readUnsignedByte(); // Read Key. 'buf' now contains only Value_data.\n\n                if (keys.contains(key)) {\n                    if (!hasLocation) {\n                        getLastLocation(position, null);\n                    }\n                    positions.add(position);\n                    keys.clear();\n                    hasLocation = false;\n                    position = new Position(getProtocolName());\n                }\n                keys.add(key);\n\n                // All switch cases now read from 'buf', which is a slice containing only the Value_Data for the current key.\n                switch (key) {\n                    case 0x01: // IMEI\n                        if (buf.readableBytes() >= 15) { // Value_Data for IMEI is 15 bytes\n                             String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                             deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                             if (deviceSession != null) {\n                                 position.setDeviceId(deviceSession.getDeviceId());\n                             }\n                        }\n                        break;\n                    case 0x02: // Alarm\n                        if (buf.readableBytes() >= 4) { // Alarm value is 4 bytes\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                        }\n                        break;\n                    case 0x14: // Battery\n                        if (buf.readableBytes() >= 3) { // Level (1) + Voltage (2)\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                        }\n                        break;\n                    case 0x20: // Location\n                        if (buf.readableBytes() >= 21) { // Sum of all fields\n                            hasLocation = true;\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                            position.setCourse(buf.readUnsignedShortLE());\n                            position.setAltitude(buf.readShortLE());\n                            int hdop = buf.readUnsignedShortLE();\n                            position.setValid(hdop > 0);\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                        }\n                        break;\n                    case 0x21: // Cell Towers\n                        if (buf.readableBytes() >= 3) { // mcc (2) + mnc (1)\n                            int mcc = buf.readUnsignedShortLE();\n                            int mnc = buf.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            while (buf.readableBytes() >= 5) { // rssi (1) + lac (2) + cid (2) = 5 bytes per tower\n                                int rssi = buf.readByte();\n                                position.getNetwork().addCellTower(CellTower.from(\n                                        mcc, mnc, buf.readUnsignedShortLE(), buf.readUnsignedShortLE(), rssi));\n                            }\n                        }\n                        break;\n                    case 0x22: // WiFi Access Points\n                        if (position.getNetwork() == null) {\n                            position.setNetwork(new Network());\n                        }\n                        while (buf.readableBytes() >= 7) { // rssi (1) + mac (6) = 7 bytes per AP\n                            int rssi = buf.readByte();\n                            String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                            position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                    mac.substring(0, mac.length() - 1), rssi));\n                        }\n                        break;\n                    case 0x23: // Tag Location\n                        // Assuming readTagId consumes from 'buf' and its length is variable.\n                        position.set(\"tagId\", readTagId(buf));\n                        if (buf.readableBytes() >= 8) { // lat (4) + lon (4)\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                        }\n                        break;\n                    case 0x24: // Time and Status\n                        if (buf.readableBytes() >= 8) { // time (4) + status (4)\n                            position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                            long status = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                            position.set(Position.KEY_STATUS, status);\n                        }\n                        break;\n                    case 0x28: // Beacon\n                        if (buf.readableBytes() >= 1) { // beaconFlags (1)\n                            int beaconFlags = buf.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(buf)); // Consumes from 'buf'\n                            if (buf.readableBytes() >= 2) { // rssi (1) + 1mRssi (1)\n                                position.set(\"tagRssi\", (int) buf.readByte());\n                                position.set(\"tag1mRssi\", (int) buf.readByte());\n                            }\n                            if (BitUtil.check(beaconFlags, 7)) { // Location data\n                                if (buf.readableBytes() >= 8) { // lat (4) + lon (4)\n                                    position.setLatitude(buf.readIntLE() * 0.0000001);\n                                    position.setLongitude(buf.readIntLE() * 0.0000001);\n                                    position.setValid(true);\n                                    hasLocation = true;\n                                }\n                            }\n                            if (BitUtil.check(beaconFlags, 6)) { // Description\n                                if (buf.isReadable()) { // Read remaining bytes as description\n                                    position.set(\"description\", buf.readCharSequence(\n                                            buf.readableBytes(), StandardCharsets.US_ASCII).toString());\n                                }\n                            }\n                        }\n                        break;\n                    case 0x2A: // Another location type\n                        if (buf.readableBytes() >= 16) { // flags(1)+mac(6)+rssi(1)+lat(4)+lon(4)\n                            buf.readUnsignedByte(); // flags (discard)\n                            buf.skipBytes(6); // mac (discard)\n                            buf.readUnsignedByte(); // rssi (discard)\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                        }\n                        break;\n                    case 0x30: // Steps\n                        if (buf.readableBytes() >= 8) { // timestamp (4) + steps (4)\n                            buf.readUnsignedIntLE(); // timestamp (discard)\n                            position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x31: // Activity\n                        int i = 1;\n                        while (buf.readableBytes() >= 8) { // activityTime (4) + activityType (4)\n                            position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                            position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                            i += 1;\n                        }\n                        break;\n                    case 0x37: // Bark Count (NEWLY ADDED CASE)\n                        // Value_Data is 8 bytes: unknown_part (4 bytes LE), barkCount (4 bytes LE)\n                        if (buf.readableBytes() == 8) {\n                            buf.readUnsignedIntLE(); // Skip first 4 bytes\n                            long barkCount = buf.readUnsignedIntLE();\n                            position.set(\"barkCount\", barkCount);\n                        }\n                        break;\n                    case 0x40: // Heart rate\n                        if (buf.readableBytes() >= 5) { // timestamp (4) + heartRate (1)\n                            buf.readUnsignedIntLE(); // timestamp (discard)\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) { // Filter out invalid low values\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                        }\n                        break;\n                    default:\n                        // Unhandled key. Value data in 'buf' will be skipped as the outer loop\n                        // moves to the next TLV item based on lengthOfKeyAndValue.\n                        break;\n                }\n                // Any unread bytes in 'buf' (Value_Data for current key) are automatically skipped\n                // because 'buf' is a slice of 'tlvFrameBuffer', and 'tlvFrameBuffer' advances by 'lengthOfKeyAndValue'.\n            }\n\n            if (!hasLocation) {\n                getLastLocation(position, null);\n            }\n            positions.add(position); // Add the last (or only) position object being worked on\n\n            if (deviceSession != null) {\n                for (Position p : positions) {\n                    p.setDeviceId(deviceSession.getDeviceId());\n                }\n            } else {\n                // If no deviceSession (e.g. IMEI was missing or invalid), the message is unidentifiable.\n                return null;\n            }\n\n            return positions;\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}