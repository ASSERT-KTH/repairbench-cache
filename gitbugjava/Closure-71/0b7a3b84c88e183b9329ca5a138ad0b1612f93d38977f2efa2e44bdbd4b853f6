{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    if (objectType == null) {\n      // Don't know the type of the object? Assume it's public.\n      // TODO(nicksantos): This introduces a hole in the access controls.\n      // We should be able to check the access controls without knowing the\n      // exact object type. See bug 1802063.\n      return;\n    }\n    String propertyName = getprop.getLastChild().getString();\n\n    // Determine if this is a prototype/static assignment in global scope.\n    boolean isPrototypeOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on the prototype chain with visibility info.\n    // For prototype overrides, start search from the immediate supertype's prototype.\n    // For other accesses (instance properties, reads), start from the objectType itself\n    // and search up the prototype chain.\n    JSDocInfo definingDocInfo = null;\n    ObjectType ownerObjectType = null;\n    ObjectType currentSearchType = isPrototypeOverride ? objectType.getImplicitPrototype() : objectType;\n\n    for (; currentSearchType != null;\n         currentSearchType = currentSearchType.getImplicitPrototype()) {\n      definingDocInfo = currentSearchType.getOwnPropertyJSDocInfo(propertyName);\n      if (definingDocInfo != null &&\n          definingDocInfo.getVisibility() != Visibility.INHERITED) {\n        ownerObjectType = currentSearchType;\n        break;\n      }\n    }\n\n    // If we didn't find the property on the prototype chain check the original\n    // object type directly. This could be the case for instance properties defined\n    // in constructors, or static properties accessed directly on the constructor.\n    if (ownerObjectType == null) {\n       definingDocInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n       if (definingDocInfo != null && definingDocInfo.getVisibility() != Visibility.INHERITED) {\n         ownerObjectType = objectType;\n       }\n    }\n\n    if (ownerObjectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    // Found the property definition. Extract info.\n    // Check source file equality using the compiler's source file representation.\n    StaticSourceFile definingSource = definingDocInfo.getSourceName() == null ?\n        null : compiler.getSourceFileByName(definingDocInfo.getSourceName());\n    StaticSourceFile currentSource = t.getSourceFile();\n    boolean sameInput = definingSource != null && currentSource != null &&\n        definingSource.getName().equals(currentSource.getName());\n\n    Visibility visibility = definingDocInfo.getVisibility();\n    // Get the class type where the property was defined.\n    JSType ownerType = normalizeClassType(ownerObjectType);\n    boolean isAssign = parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n\n    // Check 1: Private visibility violations\n    if (visibility == Visibility.PRIVATE && !sameInput) {\n      if (definingDocInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n        // Allowed: Special case for goog.inherits using private constructors.\n      } else {\n        // Private property accessed from outside the defining file.\n        if (isAssign && !isPrototypeOverride) {\n           // Case: this.privateProp = ... in subclass constructor/method (different file)\n           // Report PRIVATE_OVERRIDE error. Owner type is the class where it was defined.\n           compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE, ownerType.toString()));\n        } else {\n           // Case: Sub.prototype.privateProp = ... (different file) -> Test 6\n           // Case: var x = obj.privateProp; (different file)\n           // Report BAD_PRIVATE_PROPERTY_ACCESS error.\n           compiler.report(\n               t.makeError(getprop,\n                   BAD_PRIVATE_PROPERTY_ACCESS,\n                   propertyName,\n                   // Report the type name of the object being accessed.\n                   validator.getReadableJSTypeName(\n                       getprop.getFirstChild(), true)));\n        }\n        return; // Access denied.\n      }\n    }\n\n    // Check 2: Prototype override visibility mismatch\n    // Only check this if the private access check didn't fail (i.e., same file or not private).\n    if (isPrototypeOverride) {\n      // Check if overriding JSDoc specifies a visibility.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      if (overridingInfo != null) {\n        Visibility overridingVisibility = overridingInfo.getVisibility();\n        // Check for mismatch if overriding visibility is specified and different from original.\n        // Note: Overriding a private property in the same file is allowed,\n        // but the new visibility must be private or inherited/unspecified.\n        if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), ownerType.toString(), // ownerType is where original prop defined\n                  overridingVisibility.name()));\n          return; // Exit.\n        }\n      }\n      // If we are here, the prototype override is allowed.\n    }\n    // Check 3: Protected visibility violations (for non-prototype-override access)\n    // Only check this if the private access check didn't fail.\n    else if (visibility == Visibility.PROTECTED && !sameInput) {\n      // Protected properties accessible only in defining file (handled by sameInput check)\n      // or from within a subclass. Check if current context is in a subclass.\n      // 'currentClass' should be the JSType of the class containing the access site.\n      // It is updated by the visit method.\n      // Ensure ownerType is not null before checking subtype relationship.\n       if (currentClass == null || ownerType == null || !currentClass.isSubtype(ownerType)) {\n         compiler.report(\n             t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                 propertyName,\n                 validator.getReadableJSTypeName(\n                     getprop.getFirstChild(), true)));\n         return; // Access denied.\n       }\n      // Allowed: Accessing protected member from subclass in different file.\n    }\n\n    // If none of the checks above failed, the access is allowed.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}