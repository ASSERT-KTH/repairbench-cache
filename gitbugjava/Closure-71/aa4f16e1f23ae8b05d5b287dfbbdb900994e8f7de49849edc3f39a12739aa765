{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n\n    // If the type is null, unknown, or ambiguous, we can't check visibility.\n    // Checking for null is sufficient as dereference should handle unknowns.\n    if (objectType == null) {\n      return;\n    }\n    // Avoid checking visibility for unknown/ambiguous types returned by dereference.\n    if (objectType.isUnknownType() || objectType.isAllType() || objectType.isEmptyType()) {\n        return;\n    }\n\n\n    String propertyName = getprop.getLastChild().getString();\n\n    // Is this potentially an override? (Assignment to a property)\n    boolean isOverride = parent.getType() == Token.ASSIGN &&\n                         parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class/prototype with visibility\n    // information.\n    // If this is an override attempt, we start searching from the *superclass*\n    // to find the property being overridden.\n    // If it's a normal access, we start from the object's type itself.\n    ObjectType searchStartType = objectType;\n    if (isOverride) {\n      searchStartType = objectType.getImplicitPrototype();\n      // If the object has no implicit prototype (e.g., it's not a class instance),\n      // this assignment cannot be overriding a property with visibility.\n      // Or if the search start type is null after getting the prototype.\n      if (searchStartType == null) {\n        return;\n      }\n    }\n\n    JSDocInfo propertyDocInfo = null; // JSDoc of the accessed/overridden property\n    ObjectType propertyOwnerObjectType = null; // Type that owns the property definition found\n    for (ObjectType currentSearchType = searchStartType;\n         currentSearchType != null;\n         currentSearchType = currentSearchType.getImplicitPrototype()) {\n      propertyDocInfo = currentSearchType.getOwnPropertyJSDocInfo(propertyName);\n      if (propertyDocInfo != null &&\n          propertyDocInfo.getVisibility() != Visibility.INHERITED) {\n        propertyOwnerObjectType = currentSearchType;\n        break;\n      }\n    }\n\n    // If this was not an override check, and we didn't find the property on the\n    // superclass chain starting from objectType, check the object's type itself.\n    // This handles cases where the property is defined directly on the instance type.\n    if (!isOverride && propertyOwnerObjectType == null) {\n        propertyDocInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (propertyDocInfo != null &&\n            propertyDocInfo.getVisibility() != Visibility.INHERITED) {\n            propertyOwnerObjectType = objectType;\n        }\n    }\n\n    // If we couldn't find a visibility modifier, assume it's public.\n    if (propertyOwnerObjectType == null) {\n      return;\n    }\n\n    // Found visibility information\n    Visibility visibility = propertyDocInfo.getVisibility();\n    JSType ownerType = normalizeClassType(propertyOwnerObjectType);\n    boolean sameInput = t.getInput().getName().equals(propertyDocInfo.getSourceName());\n\n\n    if (isOverride) {\n      // Check an ASSIGN statement that's potentially overriding a property\n      // on a superclass (propertyDocInfo is from superclass).\n      JSDocInfo overridingInfo = parent.getJSDocInfo(); // JSDoc on the ASSIGN itself\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check 1: Trying to override a private property from a different file.\n      if (visibility == Visibility.PRIVATE && !sameInput) {\n        // Report PRIVATE_OVERRIDE for instance properties (e.g., in constructor - not global scope)\n        // Report BAD_PRIVATE_PROPERTY_ACCESS for prototype properties (global scope)\n        if (t.inGlobalScope()) {\n           compiler.report(\n              t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else {\n           compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE, ownerType.toString()));\n        }\n        return; // Error reported, stop processing.\n      }\n\n      // Check 2: Visibility mismatch between override and overridden property.\n      if (overridingVisibility != Visibility.INHERITED &&\n          overridingVisibility != visibility) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), ownerType.toString(),\n                overridingVisibility.name()));\n        return; // Error reported, stop processing.\n      }\n      // If override checks pass, the assignment itself is considered valid\n      // from a visibility standpoint. No further access checks needed for the assignment.\n\n    } else {\n      // Check a normal property access (not an assignment treated as override).\n      if (sameInput) {\n        // private/protected access is always allowed in the same file.\n        return;\n      }\n\n      // Access from a different file.\n      if (visibility == Visibility.PRIVATE) {\n          // Check if access is outside the defining class's file and context.\n          // Note: sameInput check already handled same file access.\n          if (currentClass == null || ownerType.differsFrom(currentClass)) {\n              // Allow private constructor access as a special case.\n              if (propertyDocInfo.isConstructor() &&\n                  isValidPrivateConstructorAccess(parent)) {\n                  return;\n              }\n\n              // private access is not allowed outside the file from a different\n              // enclosing class context.\n              compiler.report(\n                  t.makeError(getprop,\n                      BAD_PRIVATE_PROPERTY_ACCESS,\n                      propertyName,\n                      validator.getReadableJSTypeName(\n                          getprop.getFirstChild(), true)));\n              return; // Error reported, stop processing.\n          }\n      } else if (visibility == Visibility.PROTECTED) {\n          // Protected properties can be accessed in the same file (handled above),\n          // overridden in a subclass (handled by isOverride logic if applicable), or\n          // accessed from inside a subclass. Check the last case for non-override access.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n              compiler.report(\n                  t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                      propertyName,\n                      validator.getReadableJSTypeName(\n                          getprop.getFirstChild(), true)));\n              return; // Error reported, stop processing.\n          }\n      }\n      // Public access requires no further checks.\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}