{
    "generation": "import com.google.javascript.jscomp.AbstractCompiler; // Assuming these imports\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.DiagnosticType;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.Scope;\nimport com.google.javascript.jscomp.TypeValidator;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.JSDocInfo.Visibility;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport javax.annotation.Nullable; // Assuming nullable annotations\n\n// Assume fields like compiler, validator, currentClass are available in the class containing this method\n// Assume helper methods dereference, isValidPrivateConstructorAccess exist\n// Assume DiagnosticType constants BAD_PRIVATE_PROPERTY_ACCESS, BAD_PROTECTED_PROPERTY_ACCESS,\n// PRIVATE_OVERRIDE, VISIBILITY_MISMATCH are defined in the class or accessible.\n\n  /** Helper to normalize a type for comparisons involving classes and prototypes. */\n  private JSType normalizeClassType(@Nullable ObjectType objectType) {\n    if (objectType == null) {\n      return null;\n    }\n    // If it's a prototype, get the function it's the prototype of.\n    if (objectType.isFunctionPrototypeType() && objectType.getOwnerFunction() != null) {\n      return objectType.getOwnerFunction();\n    }\n    // If it's an instance, get its constructor.\n    FunctionType constructor = objectType.getConstructor();\n    if (constructor != null) {\n        return constructor;\n    }\n    // Otherwise, return the type itself (e.g., if it's already a constructor)\n    return objectType;\n  }\n\n  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    Node objectNode = getprop.getFirstChild();\n    // Use JSType directly, as dereference might handle union types etc.\n    // Use restrictByNotNullOrUndefined to handle potential null/undefined in unions.\n    JSType jsType = objectNode.getJSType();\n    if (jsType == null) {\n        return; // Not enough type info\n    }\n    // If the type is a union, check each type in the union.\n    // For simplicity here, we focus on the object type part. A full solution might iterate.\n    ObjectType objectType = ObjectType.cast(jsType.restrictByNotNullOrUndefined());\n\n    if (objectType == null) {\n      // If the type is not an object after restricting, we can't check visibility.\n      return;\n    }\n\n    String propertyName = getprop.getLastChild().getString();\n\n    boolean isAssign = parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n\n    // --- Override Check ---\n    // Check happens ONLY if this is an assignment.\n    if (isAssign) {\n      ObjectType proto = objectType.getImplicitPrototype();\n      JSDocInfo superDocInfo = null;\n      ObjectType superOwnerType = null;\n\n      // Find the property definition on the superclass hierarchy.\n      for (; proto != null; proto = proto.getImplicitPrototype()) {\n        superDocInfo = proto.getOwnPropertyJSDocInfo(propertyName);\n        if (superDocInfo != null &&\n            superDocInfo.getVisibility() != Visibility.INHERITED) {\n          superOwnerType = proto;\n          break;\n        }\n      }\n\n      // If we are overriding a property defined on a superclass...\n      if (superOwnerType != null) {\n        Visibility superVisibility = superDocInfo.getVisibility();\n        boolean superInDifferentFile = !t.getInput().getName().equals(superDocInfo.getSourceName());\n        // isPrototypeAssign specifically checks for assignments like Foo.prototype.bar = ... in global scope\n        boolean isPrototypeAssign = t.inGlobalScope() && isAssign;\n\n        // Check 1: Overriding a @private property from a different file.\n        if (superVisibility == Visibility.PRIVATE && superInDifferentFile) {\n            // Report PRIVATE_OVERRIDE for 'this.prop = ...' cases (isPrototypeAssign=false)\n            // but skip for 'Class.prototype.prop = ...' cases (isPrototypeAssign=true),\n            // letting the Access Check below report BAD_PRIVATE_PROPERTY_ACCESS instead, per test expectations.\n            if (!isPrototypeAssign) {\n                 compiler.report(\n                     t.makeError(getprop, PRIVATE_OVERRIDE,\n                         propertyName, superOwnerType.toString()));\n                 return; // Disallow this override.\n            }\n            // If it IS isPrototypeAssign, we skip the PRIVATE_OVERRIDE report here and proceed.\n        }\n\n        // Check 2: Visibility mismatch.\n        JSDocInfo overridingInfo = parent.getJSDocInfo(); // JSDoc on the ASSIGN node\n        // Also consider JSDoc directly on the overriding property, e.g., @private this.foo = ...\n        // The 'objectType' represents the type being assigned to (e.g., SubFoo instance or SubFoo.prototype)\n        JSDocInfo localDocInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        // Prefer JSDoc on the ASSIGN node if present, otherwise use JSDoc on the property itself.\n        JSDocInfo effectiveOverridingInfo = (overridingInfo != null) ? overridingInfo : localDocInfo;\n\n        // Determine the overriding visibility, defaulting to INHERITED if none specified.\n        Visibility overridingVisibility = Visibility.INHERITED;\n        if (effectiveOverridingInfo != null && effectiveOverridingInfo.getVisibility() != Visibility.INHERITED) {\n            overridingVisibility = effectiveOverridingInfo.getVisibility();\n        }\n\n\n        // We only report mismatch if the overriding property has an *explicit* visibility\n        // that differs from the super property's visibility.\n        if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != superVisibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  propertyName, superOwnerType.toString(),\n                  superVisibility.name(), overridingVisibility.name()));\n           return; // Mismatched visibility is an error.\n        }\n        // If we passed override checks, proceed to normal access checks below.\n      }\n    }\n\n    // --- Access Check ---\n    // Find the *most specific* JSDoc for the property being accessed (could be local or inherited).\n    // This determines the visibility rules for the access itself.\n    JSDocInfo docInfo = null;\n    ObjectType ownerType = null;\n    ObjectType currentSearchType = objectType;\n    for (; currentSearchType != null;\n         currentSearchType = currentSearchType.getImplicitPrototype()) {\n      docInfo = currentSearchType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        ownerType = currentSearchType;\n        break;\n      }\n    }\n\n    if (ownerType == null) {\n      // No visibility found anywhere (neither locally nor inherited), treat as public.\n      return;\n    }\n\n    // Found JSDoc. Perform access checks based on *this* JSDoc.\n    Visibility visibility = docInfo.getVisibility();\n    boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n\n    // Note: If an illegal override (like PRIVATE_OVERRIDE for 'this.prop=') was caught above,\n    // we would have returned already. The prototype assignment case falls through intentionally.\n\n    if (sameInput) {\n        // Private/protected access is allowed in the same file.\n        return;\n    }\n\n    // Access from a different file.\n    if (visibility == Visibility.PRIVATE) {\n        // Check if it's a valid private constructor access across files.\n        if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n             return; // Allowed.\n        }\n\n        // Report private access OR prototype-override from a different file.\n        // This path catches normal private access from another file, AND\n        // the Class.prototype.privateProp = ... case from another file.\n        compiler.report(\n            t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n                propertyName,\n                validator.getReadableJSTypeName(objectNode, true))); // Use objectNode's type name for the message\n        return; // Disallowed access.\n\n    } else if (visibility == Visibility.PROTECTED) {\n        // Check if we are in a subclass of the owner type.\n        JSType ownerClassType = normalizeClassType(ownerType);\n        // Assume currentClass is the type of the class/scope we are currently in (needs to be maintained by the calling class).\n        JSType currentClassNormalized = normalizeClassType(ObjectType.cast(currentClass));\n\n        boolean isSubclass = (currentClassNormalized != null && ownerClassType != null &&\n                              currentClassNormalized.isSubtype(ownerClassType));\n        if (!isSubclass) {\n             // Report protected access from outside a subclass (and not in same file).\n             compiler.report(\n                t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(objectNode, true))); // Use objectNode's type name\n             return; // Disallowed access.\n        }\n        // else: Protected access from subclass in different file is allowed.\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}