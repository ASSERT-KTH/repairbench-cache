{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    // We only check property access on GETPROP nodes.\n    if (!getprop.isGetProp()) {\n      return;\n    }\n\n    Node objectNode = getprop.getFirstChild();\n    Node propertyNode = getprop.getLastChild();\n\n    // We only handle string property names.\n    if (!propertyNode.isString()) {\n      return;\n    }\n    String propertyName = propertyNode.getString();\n\n    // Get the type of the object whose property is being accessed.\n    JSType objectNodeType = objectNode.getJSType();\n    if (objectNodeType == null) {\n      // Fallback for assignments like Foo.prototype.bar = function() {};\n      // Use the type of the assignment expression itself.\n       if (parent.isAssign() && getprop == parent.getFirstChild()) {\n         objectNodeType = parent.getJSType();\n       }\n       if (objectNodeType == null) {\n           // Cannot determine the type; potentially a coding error or complex case.\n           return;\n       }\n    }\n\n    // Ensure we are working with an ObjectType.\n    ObjectType objectType = ObjectType.cast(dereference(objectNodeType));\n    if (objectType == null) {\n      return; // Not an object type we can check visibility on.\n    }\n\n    // Determine if the GETPROP is the left-hand side of an assignment.\n    boolean isLhs = parent.isAssign() && parent.getFirstChild() == getprop;\n\n    // Determine the start type for searching the property definition.\n    // If LHS (assignment): We're checking override rules against the superclass/prototype property.\n    // If RHS (access): We're checking access rules for the property found starting from the object's type.\n    ObjectType searchStartType = objectType;\n    if (isLhs) {\n        // Note: getImplicitPrototype() handles navigating up the type hierarchy.\n        searchStartType = objectType.getImplicitPrototype();\n    }\n\n    // Find the first definition of the property up the prototype chain\n    // that has explicit visibility information.\n    JSDocInfo definedDocInfo = null;\n    ObjectType definedType = null; // The ObjectType where the defining property was found.\n    for (ObjectType currentSearchType = searchStartType;\n         currentSearchType != null;\n         currentSearchType = currentSearchType.getImplicitPrototype()) {\n\n        definedDocInfo = currentSearchType.getOwnPropertyJSDocInfo(propertyName);\n        if (definedDocInfo != null &&\n            definedDocInfo.getVisibility() != Visibility.INHERITED) {\n            definedType = currentSearchType;\n            break; // Found the relevant definition.\n        }\n    }\n\n    // If no definition with explicit visibility was found, assume public access is allowed.\n    if (definedType == null) {\n        return;\n    }\n\n    // Extract information from the property definition found.\n    Visibility definedVisibility = definedDocInfo.getVisibility();\n    String definedSource = definedDocInfo.getSourceName();\n    // Ensure definedSource is not null before comparing\n    boolean definedInSameInput = definedSource != null && definedSource.equals(t.getInput().getName());\n\n    // Get the class/interface type that owns the property definition.\n    JSType ownerType = normalizeClassType(definedType);\n    if (ownerType == null) {\n       // Could not determine owner, possibly an issue with normalizeClassType or the type system.\n       // Cannot perform visibility checks reliably.\n       return;\n    }\n\n\n    if (isLhs) {\n        // --- Check rules for LHS (Assignments / Overrides) ---\n\n        // Get the JSDoc associated with the assignment itself, if any.\n        JSDocInfo assigningDocInfo = parent.getJSDocInfo();\n        if (assigningDocInfo == null) {\n           // JSDoc might be attached to the GETPROP node in assignments like:\n           // /** @override */ this.prop = ...\n           assigningDocInfo = getprop.getJSDocInfo();\n        }\n        Visibility assigningVisibility = assigningDocInfo == null ?\n            Visibility.INHERITED : assigningDocInfo.getVisibility();\n\n        // Check 1: Cannot override a private property defined in another file.\n        if (definedVisibility == Visibility.PRIVATE && !definedInSameInput) {\n            compiler.report(\n                t.makeError(getprop, PRIVATE_OVERRIDE,\n                    propertyName, // Property name {0}\n                    ownerType.toString())); // Type name {1}\n            return;\n        }\n\n        // Check 2: Visibility of the override must match the original property,\n        // if the override specifies an explicit visibility.\n        if (assigningVisibility != Visibility.INHERITED &&\n            assigningVisibility != definedVisibility) {\n            compiler.report(\n                t.makeError(getprop, VISIBILITY_MISMATCH,\n                    propertyName,           // Property name {0}\n                    definedVisibility.name(), // Original visibility {1}\n                    ownerType.toString(),     // Type where original is defined {2}\n                    assigningVisibility.name())); // Visibility in the override/assignment {3}\n            return;\n        }\n\n        // Check 3: Is override of protected property allowed?\n        // Check if the defining class is related to the current class context\n        // This mirrors the read access check but applies during override attempt.\n        if (definedVisibility == Visibility.PROTECTED && !definedInSameInput) {\n          // We must be in a subclass of the owner type to override a protected property from another file.\n          // We use 'objectType' (the type being assigned to, e.g., SubClass.prototype)\n          // to check the subclass relationship against 'ownerType'.\n          JSType currentAssigningClass = normalizeClassType(objectType);\n          if (currentAssigningClass == null || !currentAssigningClass.isSubtype(ownerType)) {\n                compiler.report(\n                    t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                        propertyName,\n                        validator.getReadableJSTypeName(objectNode, true)));\n                 return;\n            }\n        }\n\n    } else {\n        // --- Check rules for RHS (Read Access) ---\n\n        // Access is always allowed if the definition is in the same file.\n        if (definedInSameInput) {\n            return;\n        }\n\n        // Access from a different file.\n        if (definedVisibility == Visibility.PRIVATE) {\n            // Allow access to private constructors via helper function if valid.\n            if (definedDocInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n                 return;\n            }\n\n            // Otherwise, private access is restricted to the defining class.\n            // currentClass is the class context of the access location.\n            if (currentClass == null || ownerType.differsFrom(currentClass)) {\n                 compiler.report(\n                    t.makeError(getprop,\n                        BAD_PRIVATE_PROPERTY_ACCESS,\n                        propertyName, // Property name {0}\n                        // Type where property is accessed {1}\n                        validator.getReadableJSTypeName(objectNode, true)));\n                 return;\n            }\n        } else if (definedVisibility == Visibility.PROTECTED) {\n            // Protected access is allowed only from subclasses.\n            // Check if the current class context is a subtype of the defining class.\n            if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                 compiler.report(\n                    t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                        propertyName, // Property name {0}\n                        // Type where property is accessed {1}\n                        validator.getReadableJSTypeName(objectNode, true)));\n                 return;\n            }\n        }\n        // Public access is implicitly allowed if none of the above restrictions apply.\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}