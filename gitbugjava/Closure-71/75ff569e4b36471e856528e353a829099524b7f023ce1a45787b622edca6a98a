{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    // Get the object type being accessed\n    JSType jsType = getprop.getFirstChild().getJSType();\n    if (jsType == null) {\n        return; // Cannot check visibility if type is unknown\n    }\n    ObjectType objectType = ObjectType.cast(dereference(jsType));\n    if (objectType == null) {\n      // If the type is not an object type, we can't check visibility.\n      return;\n    }\n    String propertyName = getprop.getLastChild().getString();\n\n    // --- Step 1: Check for basic access violations (private/protected) ---\n\n    // Find the JSDoc info that *effectively* defines the property's visibility\n    // by searching down the prototype chain starting from the object's own type.\n    JSDocInfo effectiveDocInfo = null;\n    ObjectType ownerObjectType = null; // The object type where effective visibility was found\n    for (ObjectType currentSearchType = objectType;\n         currentSearchType != null;\n         currentSearchType = currentSearchType.getImplicitPrototype()) {\n      effectiveDocInfo = currentSearchType.getOwnPropertyJSDocInfo(propertyName);\n      if (effectiveDocInfo != null &&\n          effectiveDocInfo.getVisibility() != Visibility.INHERITED) {\n        ownerObjectType = currentSearchType;\n        break;\n      }\n    }\n\n    // If we found visibility information, check if the access is allowed.\n    if (ownerObjectType != null) {\n        Visibility visibility = effectiveDocInfo.getVisibility();\n        JSType ownerType = normalizeClassType(ownerObjectType); // Type where property is defined\n        boolean sameInput = t.getInput().getName().equals(effectiveDocInfo.getSourceName());\n\n        // Check violations only if the access is outside the defining file.\n        if (!sameInput) {\n            if (visibility == Visibility.PRIVATE) {\n                // Private access is allowed only if accessed from within the same logical class structure,\n                // unless it's a specifically allowed constructor access.\n                // Check if current class is different from the owner class.\n                if (currentClass == null || ownerType.differsFrom(currentClass)) {\n                    // Allow access to private constructors in specific whitelisted cases.\n                    if (!(effectiveDocInfo.isConstructor() && isValidPrivateConstructorAccess(parent))) {\n                         compiler.report(\n                            t.makeError(getprop,\n                                BAD_PRIVATE_PROPERTY_ACCESS,\n                                propertyName,\n                                validator.getReadableJSTypeName(\n                                    getprop.getFirstChild(), true)));\n                         // If access is bad, don't proceed to override checks.\n                         return;\n                    }\n                }\n            } else if (visibility == Visibility.PROTECTED) {\n                // Protected access is allowed if in the same file (handled above),\n                // or if accessed from within a subclass.\n                if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n                     compiler.report(\n                        t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                            propertyName,\n                            validator.getReadableJSTypeName(\n                                getprop.getFirstChild(), true)));\n                     // If access is bad, don't proceed to override checks.\n                     return;\n                }\n            }\n        }\n    }\n    // If no visibility was found (ownerObjectType == null) or if access was allowed,\n    // proceed to check for override issues if it's an assignment.\n\n\n    // --- Step 2: Check for override violations if this is an assignment ---\n\n    boolean isAssignment = parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n    if (isAssignment) {\n        // Find the property defined on a *superclass*.\n        ObjectType superObjectChain = objectType.getImplicitPrototype(); // Start search from direct superclass prototype/instance\n        JSDocInfo superDocInfo = null;\n        ObjectType definingSuperClass = null;\n        for (; superObjectChain != null;\n             superObjectChain = superObjectChain.getImplicitPrototype()) {\n          superDocInfo = superObjectChain.getOwnPropertyJSDocInfo(propertyName);\n          if (superDocInfo != null &&\n              superDocInfo.getVisibility() != Visibility.INHERITED) {\n            definingSuperClass = superObjectChain;\n            break; // Found the first JSDoc with visibility on the superclass chain\n          }\n        }\n\n        // If we found a property on the superclass chain with visibility information.\n        if (definingSuperClass != null) {\n             Visibility superVisibility = superDocInfo.getVisibility();\n             JSType superOwnerType = normalizeClassType(definingSuperClass); // The superclass where it's defined\n             boolean superSameInput = t.getInput().getName().equals(superDocInfo.getSourceName());\n\n             // Check (a): Overriding a private property from a different file.\n             if (superVisibility == Visibility.PRIVATE && !superSameInput) {\n                  // Prevent overriding private properties from different files.\n                  compiler.report(\n                      t.makeError(getprop, PRIVATE_OVERRIDE, propertyName,\n                          superOwnerType.toString()));\n                  return; // Report override error\n             }\n\n             // Check (b): Visibility mismatch between superclass and subclass override.\n             // Get JSDoc for the overriding property (on the assignment itself).\n             JSDocInfo overridingInfo = parent.getJSDocInfo();\n             Visibility overridingVisibility = overridingInfo == null ?\n                 Visibility.INHERITED : overridingInfo.getVisibility();\n\n             // If the overriding property has explicit visibility, it must match the superclass property.\n             if (overridingVisibility != Visibility.INHERITED &&\n                 overridingVisibility != superVisibility) {\n               compiler.report(\n                   t.makeError(getprop, VISIBILITY_MISMATCH,\n                       superVisibility.name(), superOwnerType.toString(),\n                       overridingVisibility.name()));\n               return; // Report mismatch error\n             }\n        }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}