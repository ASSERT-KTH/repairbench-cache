{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     *\n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null) { // Check str == null separately\n            return -1;\n        }\n\n        int strLen = str.length();\n\n        // Handle empty string search case: returns startIndex if startIndex <= size, else size.\n        // This mimics JDK String.indexOf behavior.\n        if (strLen == 0) {\n            return (startIndex <= size ? startIndex : size);\n        }\n\n        // If startIndex is beyond the possible range, return -1 immediately.\n        // This check is safe because we've handled strLen == 0 already.\n        if (startIndex >= size) {\n             return -1;\n        }\n\n        // If string length is 1, delegate to char indexOf\n        if (strLen == 1) {\n            // No need for extra startIndex check here, as startIndex < size is guaranteed.\n            return indexOf(str.charAt(0), startIndex);\n        }\n\n        // Cannot find string longer than the current size\n        if (strLen > size) {\n            return -1;\n        }\n\n        // Use current buffer and calculate the correct upper bound for the loop\n        char[] thisBuf = buffer;\n        // loopEnd is the last possible starting index for a match: size - strLen\n        // The loop should iterate from startIndex up to and including loopEnd.\n        int loopEnd = size - strLen;\n\n        // If the effective startIndex is already past the last possible match start, return -1\n        if (startIndex > loopEnd) {\n             return -1;\n        }\n\n        // Naive string search implementation using the correct bounds based on 'size'\n        outer:\n        for (int i = startIndex; i <= loopEnd; i++) { // Iterate up to the last possible start index\n            for (int j = 0; j < strLen; j++) {\n                // Access check: Max i = loopEnd = size - strLen. Max j = strLen - 1.\n                // Max i + j = (size - strLen) + (strLen - 1) = size - 1.\n                // This index is guaranteed to be within the valid range [0, size - 1]\n                // and also within the buffer capacity [0, buffer.length - 1] since size <= buffer.length.\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer; // Mismatch, advance outer loop to the next possible start index 'i'\n                }\n            }\n            return i; // Found a match starting at index i\n        }\n\n        return -1; // No match found\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}