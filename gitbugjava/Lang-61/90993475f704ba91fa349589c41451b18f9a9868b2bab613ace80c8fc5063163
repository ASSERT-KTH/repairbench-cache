{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        // Clamp startIndex to the valid range [0, size]\n        // Note: The original code clamped to [0, infinity), but the check\n        // startIndex >= size handled the upper bound. Clamping to 0 is correct.\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n\n        // Early exit conditions\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n\n        int strLen = str.length();\n        if (strLen == 1) {\n            // Optimization for single character search\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            // Empty string is always found at the starting index\n            return startIndex;\n        }\n        if (strLen > size) {\n            // The string to find is longer than the content of the builder\n            return -1;\n        }\n\n        // The search should occur within the actual content (size), not the buffer capacity (buffer.length).\n        // Calculate the maximum possible starting index in the buffer for the string str to fit.\n        // The last possible starting position is size - strLen.\n        int loopEnd = size - strLen;\n\n        // Use the local buffer reference for performance and consistency during the search\n        char[] thisBuf = buffer;\n        \n        // Label for breaking out of the outer loop upon mismatch\n        outer:\n        // Iterate through possible starting indices from startIndex up to loopEnd (inclusive)\n        for (int i = startIndex; i <= loopEnd; i++) {\n            // Compare characters of str with the substring in the buffer starting at index i\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    // Character mismatch, move to the next possible starting index in the buffer\n                    continue outer;\n                }\n            }\n            // All characters matched, return the starting index i\n            return i;\n        }\n\n        // String not found in the specified range\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}