{
    "generation": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment; // Default to inserting the comment itself\n\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            // Check if data looks like <?...> or <!...> and has content after the marker\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                // Correctly extract the content, e.g., \"xml version='1.0'\" from \"?xml version='1.0'\"\n                // The original code used data.substring(1, data.length() -1), which incorrectly assumed the data ended with a matching '>'.\n                String innerData = data.substring(1);\n\n                // Avoid parsing if innerData is empty, which could happen for \"?>\" or \"!>\"\n                if (!innerData.isEmpty()) {\n                    // Parse the inner data wrapped in <> to extract tag name and attributes\n                    // Using a temporary base URI and the XML parser settings\n                    Document doc = Jsoup.parse(\"<\" + innerData + \">\", baseUri, Parser.xmlParser());\n                    \n                    // Safely get the first element child, if parsing was successful\n                    // Check body() first as parse() might wrap in html/body implicitly even in xml mode for fragments\n                    Element el = null;\n                    if (doc.body() != null && doc.body().childNodeSize() > 0) {\n                         Node firstChild = doc.body().childNode(0);\n                         if (firstChild instanceof Element) {\n                             el = (Element) firstChild;\n                         }\n                    }\n                    // If not found in body, check doc's direct children (less common for fragment parsing but possible)\n                    if (el == null && doc.childNodeSize() > 0) {\n                        Node firstChild = doc.childNode(0);\n                        if (firstChild instanceof Element) {\n                            el = (Element) firstChild;\n                        }\n                    }\n\n\n                    if (el != null) {\n                        // Successfully parsed the inner data as an element.\n                        // Create the appropriate node (XmlDeclaration or potentially other node types like DocumentType).\n                        // The second arg to XmlDeclaration constructor indicates if it starts with \"!\", influencing its syntax representation (<? vs <! sort).\n                        insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                        // Copy attributes from the parsed element to the new node.\n                        insert.attributes().addAll(el.attributes());\n                    }\n                    // If el is null, parsing failed or produced no usable elements.\n                    // In this case, 'insert' remains the original Comment node, which is a reasonable fallback.\n                }\n            }\n        }\n        // Insert the determined node (either the parsed XmlDeclaration or the original Comment)\n        insertNode(insert);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}