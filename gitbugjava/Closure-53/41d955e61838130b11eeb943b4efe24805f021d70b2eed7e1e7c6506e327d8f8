{
    "generation": "    /**\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n     * Note that the resulting expression will always evaluate to\n     * true, as would the x = {...} expression.\n     * This method is only called for assignments (x = {...}), not declarations (var x = {...}).\n     */\n    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        // Note: This assumes that the object literal is well-formed.\n        String propertyName = key.getString();\n        Node value = key.removeFirstChild(); // Detach value from key\n        // TODO(user): Copy type information.\n        nodes.add(\n            new Node(Token.ASSIGN,\n                     Node.newString(Token.NAME, varmap.get(propertyName)), value));\n        all.remove(propertyName);\n      }\n\n      // Handle properties present in the variable map but not in the literal\n      // by assigning 'undefined' to their corresponding temporary variables.\n      // TODO(user): Better source information.\n      for (String propertyName : all) {\n        nodes.add(\n            new Node(Token.ASSIGN,\n                     Node.newString(Token.NAME, varmap.get(propertyName)),\n                     // Use the object literal node for source info\n                     NodeUtil.newUndefinedNode(val)));\n      }\n\n      Node replacement;\n      // All assignments evaluate to true eventually (assign is truthy in JS)\n      // We add an explicit TRUE at the end ensure the whole comma expression is True.\n      nodes.add(new Node(Token.TRUE));\n\n      if (nodes.size() == 1) {\n        // If there were no assignments (empty object literal),\n        // the replacement is just 'true'.\n        replacement = nodes.get(0);\n        Preconditions.checkState(replacement.getType() == Token.TRUE);\n      } else {\n        // Join assignments and TRUE using COMMA operator.\n        // Build a left-associative tree: ( (a,b), c)\n        // The structure produced is COMMA(COMMA(..., assignN), TRUE)\n        // e.g. for [assign1, assign2, TRUE] -> COMMA(COMMA(assign1, assign2), TRUE)\n        nodes = Lists.reverse(nodes); // [TRUE, assignN, ..., assign1]\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        // Loop builds the left-nested structure: COMMA( new_comma, nodes[i] )\n        // It runs nodes.size() - 2 times.\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i)); // Add nodes[0..N-3] as right child\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);           // Add new comma node as left child\n          cur = t;                          // Recurse left\n        }\n        // After loop, i = nodes.size() - 2.\n        // cur points to the leftmost COMMA node.\n        // Add the final two elements from the reversed list (assign2, assign1).\n        // nodes.get(i) is assign2, nodes.get(i+1) is assign1.\n        cur.addChildToFront(nodes.get(i));     // Add assign2 (becomes second child)\n        cur.addChildToFront(nodes.get(i + 1)); // Add assign1 (becomes first child)\n        // Resulting in innermost COMMA(assign1, assign2)\n      }\n\n      // ref is the NAME node in the assignment (e.g., 'a' in a = {})\n      // ref.getParent() is the ASSIGN node (a = {})\n      Node assignNode = ref.getParent();\n      Preconditions.checkState(assignNode.getType() == Token.ASSIGN,\n          \"Expected ASSIGN node, found %s\", Token.name(assignNode.getType()));\n\n      replacement.copyInformationFromForTree(assignNode);\n\n      // Replace the original ASSIGN node with the new comma expression.\n      Node assignParent = assignNode.getParent();\n      assignParent.replaceChild(assignNode, replacement);\n      // Code change reporting is likely handled by the caller or traversal.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}