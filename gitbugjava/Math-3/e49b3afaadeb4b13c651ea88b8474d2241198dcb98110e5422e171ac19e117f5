{
    "generation": "    /**\n     * Compute a linear combination accurately.\n     * This method computes the sum of the products\n     * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n     * It does so by using specific multiplication and addition algorithms to\n     * preserve accuracy and reduce cancellation effects.\n     * <br/>\n     * It is based on the 2005 paper\n     * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n     * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n     * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n     *\n     * @param a Factors.\n     * @param b Factors.\n     * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n     * @throws DimensionMismatchException if arrays dimensions don't match\n     */\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        // Handle dimension 0 case.\n        if (len == 0) {\n            return 0.0;\n        }\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        // Compute products and split into high and low parts (Algorithm TwoProduct).\n        // This loop is based on Algorithms 4.4 / TwoProduct and 4.7 / AccDot from the paper.\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai; // Split a_i\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi; // Split b_i\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi; // High part of product = standard product\n            // Low part of product = error term, calculated via Dekker's product algorithm variation\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow; // Accumulate low parts naively for now\n        }\n\n\n        // Handle dimension 1 case. Avoids ArrayIndexOutOfBoundsException below.\n        // The result is the accurate product a[0]*b[0] = prodHigh[0] + prodLowSum.\n        if (len == 1) {\n            double result = prodHigh[0] + prodLowSum;\n            if (Double.isNaN(result)) {\n                // Fallback for NaN (e.g., Inf * 0). Use standard IEEE754 multiplication.\n                result = a[0] * b[0];\n            }\n            return result;\n        }\n\n        // Now len >= 2. Sum the high parts accurately.\n        // Based on Algorithm Sum2 for the first two elements and FastTwoSum loop for the rest.\n        // sHighPrev holds the current high part of the sum, sLowSum accumulates the low parts.\n        double prodHighCur = prodHigh[0]; // First high part P_0\n        double prodHighNext = prodHigh[1]; // Second high part P_1\n        double sHighPrev = prodHighCur + prodHighNext; // s_1 = P_0 + P_1 (high part)\n        double sPrime = sHighPrev - prodHighNext;     // Error extraction helper\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime); // t_1 = Low part of P_0 + P_1\n\n        final int lenMinusOne = len - 1;\n        // Loop runs from i=1 to len-2, processing prodHigh[i+1] = prodHigh[2]...prodHigh[len-1]\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1]; // P_{i+1}\n            final double sHighCur = sHighPrev + prodHighNext; // s_{i+1} = s_i + P_{i+1} (high part)\n            sPrime = sHighCur - prodHighNext; // Error extraction helper\n            // Accumulate low part of sum: t_{i+1} = t_i + Low(s_i + P_{i+1})\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur; // Update high part for next iteration\n        }\n\n        // Final result is sum of high parts (sHighPrev) + sum of all low parts (prodLowSum + sLowSum)\n        // The sum (prodLowSum + sLowSum) is done with standard addition.\n        // A more robust version could use an accurate summation for this too, but this matches the paper's AccDot.\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n\n    /** Split factor for splitting doubles in two */\n    private static final double SPLIT_FACTOR = (1 << 27) + 1; // 2^27+1\n\n    /** Exception class for dimension mismatch (assuming it exists elsewhere) */\n    private static class DimensionMismatchException extends Exception {\n        public DimensionMismatchException(int lenA, int lenB) {\n            super(\"Dimension mismatch: \" + lenA + \" != \" + lenB);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}