{
    "generation": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()\n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock\n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            // Example: verify(mockTwo).simpleMethod(mockOne.otherMethod());\n            // In the above example, when 'mockOne.otherMethod()' is evaluated, the invocation\n            // occurs on 'mockOne' but verification is happening on 'mockTwo'\n            if (verificationMode instanceof MockAwareVerificationMode) {\n                MockAwareVerificationMode mockAwareMode = (MockAwareVerificationMode) verificationMode;\n                // Check if the verification is for the mock that is currently invoked\n                if (mockAwareMode.getMock() == invocation.getMock()) {\n                    // Verification is for the current mock, proceed with verification\n                    VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                    verificationMode.verify(data);\n                    return null; // Verification handled, return null\n                } else {\n                    // Invocation is on a different mock than the one being verified.\n                    // This happens when an argument to the verified method is itself a mock invocation.\n                    // We need to put the verification mode back so that the verification framework\n                    // can capture the invocation on the correct mock later.\n                    mockingProgress.verificationStarted(verificationMode);\n                    // Let the invocation proceed normally to retrieve the value needed for verification args.\n                    // Fall through to the stubbing/playback logic below.\n                }\n            } else {\n                 // Not a MockAwareVerificationMode, assume it applies to the current invocation.\n                 // This case might be relevant for simpler verification modes or custom ones.\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                 verificationMode.verify(data);\n                 return null; // Verification handled, return null\n            }\n        }\n\n        // This part is reached if:\n        // 1. No verification was in progress (verificationMode == null).\n        // 2. Verification was in progress, but the current invocation is on a *different* mock\n        //    (e.g., evaluating an argument for the verify() call).\n\n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            // This cleanup is particularly important if the invocation occurred during verification setup on a different mock.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}