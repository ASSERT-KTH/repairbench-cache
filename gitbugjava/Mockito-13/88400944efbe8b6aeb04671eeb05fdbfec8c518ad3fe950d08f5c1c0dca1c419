{
    "generation": "    public Object handle(Invocation invocation) throws Throwable {\n        // 1. Handle stubbing voids (`Mockito.stubVoid()`, `doAnswer()`, etc.)\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // Ongoing stubbing using doReturn() style.\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n\n        // 2. Pull verification mode, if any.\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        // 3. Is verify() happening?\n        if (verificationMode != null) {\n            // Is the verification targeted at the *current* invocation's mock?\n            boolean isMockAware = verificationMode instanceof MockAwareVerificationMode;\n            boolean isCorrectMockForVerification = isMockAware\n                    && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock();\n\n            if (isCorrectMockForVerification) {\n                // Yes, this is the invocation we want to verify.\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                verificationMode.verify(data);\n                return null; // Verification finished for this invocation.\n            } else {\n                // No, this is an invocation on a different mock during verification\n                // (e.g. the mock.otherMethod() call inside verify(mockTwo).simpleMethod(mock.otherMethod())).\n                // Put the verification mode back so it's available for the correct invocation.\n                mockingProgress.verificationStarted(verificationMode);\n                // Proceed to handle this invocation normally (e.g., find stub, return value) below.\n                // *** We must NOT validate state or report ongoing stubbing for this intermediate invocation. ***\n            }\n        } else {\n            // 4. If not verifying, validate state *before* handling invocation/stubbing\n            // Catches unfinished stubbing/verification, misplaced matchers etc.\n             mockingProgress.validateState();\n\n            // Prepare for potential stubbing (e.g., `when(mock.foo())`)\n            invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n            OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n            mockingProgress.reportOngoingStubbing(ongoingStubbing);\n            // Proceed to stub lookup (step 5)\n        }\n\n        // 5. Handle invocation by finding stubbed answer or returning default answer\n        // This part is reached for normal invocations, OR for invocations on different mocks during verification.\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            // Found a stubbed answer\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            // No stub found, use default answer\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // If we were starting a stubbing (`when(mock.foo())`), the potential stubbing might have been overwritten\n            // by delegated calls if mock is a spy/partial mock. Reset it.\n            // This should only happen if verificationMode was initially null (i.e., not verifying).\n            if (verificationMode == null) {\n                 invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            }\n            return ret;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}