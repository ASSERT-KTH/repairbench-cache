{
    "generation": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()\n        if (verificationMode != null) {\n            // We need to check if verification was started on the correct mock\n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n\n            // If we are verifying, we need to check if the invocation applies to the mock we are verifying\n            MockAwareVerificationMode mockAwareMode = null;\n            boolean isMockAware = verificationMode instanceof MockAwareVerificationMode;\n            if (isMockAware) {\n                 mockAwareMode = (MockAwareVerificationMode) verificationMode;\n            }\n\n            // Check if the verification mode applies to the current invocation's mock\n            if (!isMockAware || mockAwareMode.getMock() == invocation.getMock()) {\n                // It's the mock we want to verify: verify the invocation\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                verificationMode.verify(data);\n                // Verification consumes the invocation, return null\n                return null;\n            } else {\n                // It's an invocation on a different mock during verification.\n                // This happens in scenarios like verify(mock1).doSomething(mock2.getId());\n                // The invocation on mock2 comes through here. We need to handle it normally,\n                // but we must first restore the verification state for mock1.\n                mockingProgress.reportVerificationMode(verificationMode);\n                // Let the execution fall through to the regular invocation handling below.\n            }\n        }\n\n        // Handle regular invocation (i.e., not verification) OR invocation on a different mock during verification\n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}