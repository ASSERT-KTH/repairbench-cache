{
    "generation": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        // Check for identity or standard equality first (optimization)\n        // Issue #176: Mockito cannot handle parameterised return types for non-generic interface methods\n        // This handles the case where the method objects are actually the same or equal.\n        if (m1 == m2 || m1.equals(m2)) {\n            return true;\n        }\n\n        // Robust comparison for bridge methods: check name and parameter types.\n        // This addresses the issue where Method.equals() returns false due to bridge methods\n        // generated by the compiler for generic types, even though the methods are semantically equivalent\n        // from the user's perspective.\n        if (!m1.getName().equals(m2.getName())) {\n            return false;\n        }\n\n        Class<?>[] params1 = m1.getParameterTypes();\n        Class<?>[] params2 = m2.getParameterTypes();\n        if (!java.util.Arrays.equals(params1, params2)) {\n            return false;\n        }\n        \n        // If name and parameters match, they represent the same method call signature for mocking purposes.\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}