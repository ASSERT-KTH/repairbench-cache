{
    "generation": "    /**\n     * Checks if an object literal assignment can be safely inlined.\n     * An object literal assignment is potentially inlinable if the variable\n     * it's assigned to is consistently used as an object literal and its\n     * properties are accessed in ways that don't rely on object identity\n     * or unexpected prototype chain lookups.\n     *\n     * Specifically, we check for references of the following type:\n     * <pre>\n     *   var x = { ... }; // OK\n     *   x = { ... };     // OK\n     *   f(x.prop);       // OK if prop is defined in literal\n     *   x.prop = val;    // OK, treats prop as potentially valid\n     *   delete x.prop;   // NOT OK - changes object structure\n     *   x.prop();        // NOT OK - 'this' might be used\n     *   foo(x);          // NOT OK - object identity might matter\n     *   x = other;       // NOT OK - variable value changes\n     *   var y = x;       // NOT OK - aliasing\n     * </pre>\n     *\n     * @param refs A list of references to the variable being considered for\n     *             inlining.\n     * @return True if the object literal can be inlined, false otherwise.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false; // Has an object literal assignment been found?\n      // Tracks properties defined in the literal or assigned later.\n      Set<String> validProperties = Sets.newHashSet();\n\n      for (Reference ref : refs) {\n        Node name = ref.getNode(); // The NAME node for the variable\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Handle direct references to the variable (e.g., 'x = ...', 'var x = ...', 'foo(x)')\n        if (!parent.isGetProp()) {\n          // Allow only VAR declarations or simple assignments to the variable.\n          if (!isVarOrAssignExprLhs(name)) {\n             // Any other direct usage (e.g., passing 'x' to a function, returning 'x',\n             // using 'x' in a binary op) prevents inlining.\n             return false;\n          }\n\n          // Check the value assigned in VAR/Assign\n          Node val = ref.getAssignedValue();\n          if (val == null) {\n            // A var declaration with no assignment (e.g., var x;). Continue checking other refs.\n            continue;\n          }\n\n          // We require the assigned value to be an object literal.\n          if (!val.isObjectLit()) {\n            // If the variable is ever assigned something other than an object literal, bail out.\n            return false;\n          }\n\n          // Check for problematic patterns within the object literal itself (self-reference, getters/setters)\n          if (!isValidObjectLiteral(val, refs)) {\n              return false;\n          }\n\n          // Record properties defined in this literal\n          for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n              // Property names are STRING_KEY, GETTER_DEF, SETTER_DEF. Getters/setters already rejected by isValidObjectLiteral.\n              if (child.isStringKey()) {\n                  validProperties.add(child.getString());\n              }\n          }\n\n          // We found a valid object literal assignment. Mark as potentially inlinable.\n          ret = true;\n\n        } else {\n          // Handle property accesses (e.g., x.prop, x.prop(), delete x.prop)\n          Preconditions.checkState(parent.isGetProp());\n          Preconditions.checkState(parent.getFirstChild() == name);\n\n          // Disallow calls like x.prop() because 'this' might be the object.\n          if (gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Disallow deleting properties, as it changes the object's structure\n          // in a way that inlining doesn't preserve.\n          if (gramps.isDelProp()) {\n            return false;\n          }\n\n          // Check the property name being accessed.\n          String propName = parent.getLastChild().getString();\n\n          // If the property access is the LHS of a VAR or simple assignment\n          // (e.g., x.prop = 1; var y = x.prop;), it's potentially okay.\n          // We add the property name to the set of known properties.\n          if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n            validProperties.add(propName);\n          } else {\n            // If it's not an assignment LHS, it's some kind of read/use.\n            // We only allow reads/uses of properties that were originally\n            // defined in the object literal(s) or later assigned. Accessing\n            // potentially inherited properties (not explicitly defined/set) is unsafe.\n            if (!validProperties.contains(propName)) {\n               // Allow reading properties defined on Object.prototype if the object is empty?\n               // No, the current logic conservatively assumes unknown properties read => bail.\n              return false;\n            }\n            // Note: Even if the property is in validProperties, complex uses\n            // (other than simple reads captured implicitly by not returning false here)\n            // might still be problematic, but CALL and DELPROP are handled above.\n            // Other complex AST structures involving GETPROP might need explicit checks if issues arise.\n          }\n        }\n      } // End loop over references\n\n      // To be inlinable, we must have found at least one object literal assignment (`ret` is true)\n      // AND none of the references violated the safety conditions (no early `return false`).\n      return ret;\n    }\n\n    /**\n     * Helper function to check for self-references and getters/setters\n     * within an object literal node.\n     */\n    private boolean isValidObjectLiteral(Node val, List<Reference> refs) {\n        Preconditions.checkArgument(val.isObjectLit());\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported by this optimization.\n                return false;\n            }\n\n            // Check for self-referential assignments like x = {b: x.a}\n            // We look for cases where the value part of a property (child.getFirstChild())\n            // contains a reference ('t') back to the object variable itself.\n            Node childVal = child.getFirstChild();\n            if (childVal != null) { // Might be null for {key,} (ES trailing comma)\n                for (Reference t : refs) {\n                    Node refNode = t.getNode(); // The NAME node of the reference\n                    // Check if refNode is contained within childVal's subtree\n                    if (childVal.contains(refNode) && val.contains(childVal)) {\n                         // Check if the reference is actually to the *variable* being defined,\n                         // not some other variable with the same name in a different scope.\n                         // NOTE: This simple check might be overly conservative if scopes overlap complexly,\n                         // but `contains` is a decent heuristic. A more robust check might involve scope analysis.\n                         // TODO(b/1): Improve self-reference check accuracy.\n\n                        // Basic check seems sufficient for typical cases like: var x = { a: x.b };\n                        return false; // Found potential self-reference.\n                    }\n                }\n            }\n        }\n        return true; // No getters/setters or obvious self-references found.\n    }\n\n\n    /**\n     * Simplified check: is the node the LHS of a var or assignment?\n     * TODO(user): Move this into NodeUtil? Seems generally useful.\n     * This differs from NodeUtil.isVarOrSimpleAssignLhs which checks parent/gramps.\n     */\n    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      // Check for 'var x = ...;' where n is NAME 'x'\n      if (parent.isVar()) {\n        // Make sure it's the NAME node in the VAR, not the initializer.\n        // VAR\n        //   NAME x  <-- n\n        //     OBJLIT {...}\n        return parent.getFirstChild() == n;\n      }\n      // Check for 'x = ...;' where n is NAME 'x'\n      // EXPR_RESULT\n      //   ASSIGN\n      //     NAME x  <-- n\n      //     OBJLIT {...}\n      if (parent.isAssign() && parent.getParent().isExprResult()) {\n        return parent.getFirstChild() == n;\n      }\n      return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}