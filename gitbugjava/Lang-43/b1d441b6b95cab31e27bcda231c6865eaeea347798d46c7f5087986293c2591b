{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position (must be positioned *after* the opening quote)\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes ('')\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        // Record the starting index within the pattern; this is the position after the opening quote.\n        int start = pos.getIndex();\n        // Convert the pattern to a character array for efficient access.\n        char[] c = pattern.toCharArray();\n        // Keep track of the start index of the current segment of text to be appended.\n        int lastHold = start;\n\n        // Iterate through the pattern starting from the position after the opening quote.\n        for (int i = pos.getIndex(); i < c.length; i++) {\n            // Check if the current character is a QUOTE (' character).\n            if (c[i] == QUOTE) {\n                // If escaping is enabled, check if this is an escaped quote ('').\n                if (escapingOn && i + 1 < c.length && c[i + 1] == QUOTE) {\n                    // Found an escaped quote ('').\n                    // Append the segment of text from the last hold position up to the current quote.\n                    if (appendTo != null) {\n                        appendTo.append(c, lastHold, i - lastHold);\n                        // Append a single literal quote character.\n                        appendTo.append(QUOTE);\n                    }\n                    // Advance the parse position past the escaped quote ('').\n                    pos.setIndex(i + 2);\n                    // Update the starting position for the next segment.\n                    lastHold = pos.getIndex();\n                    // Increment loop counter 'i' to skip the second quote of the pair.\n                    i++;\n                    // Continue to the next iteration of the loop.\n                    continue; // continue parsing from the position after the escaped quote\n                } else {\n                    // Found the closing quote character.\n                    // Append the final segment of text from the last hold position up to the closing quote.\n                    if (appendTo != null) {\n                        appendTo.append(c, lastHold, i - lastHold);\n                    }\n                    // Advance the parse position past the closing quote.\n                    pos.setIndex(i + 1);\n                    // Return the StringBuffer (or null if appendTo was null).\n                    return appendTo; // Successfully parsed the quoted string\n                }\n            }\n            // If the character is not a quote (or the first part of an escape sequence),\n            // simply continue the loop to process the next character.\n            // The character will be included in the next segment appended.\n        }\n\n        // If the loop completes without finding a closing quote, the string is unterminated.\n        // Throw an exception indicating the error and the position where the quoted string started.\n        // (start - 1) gives the position of the opening quote.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string starting at position \" + (start - 1));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}