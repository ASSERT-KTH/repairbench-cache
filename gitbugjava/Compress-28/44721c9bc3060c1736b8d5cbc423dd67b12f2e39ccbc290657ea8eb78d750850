{
    "generation": "    /**\n     * Reads bytes from the current tar archive entry.\n     *\n     * This method is aware of the boundaries of the current\n     * entry in the archive and will deal with them as if they\n     * were this stream's start and EOF.\n     *\n     * @param buf The buffer into which to place bytes read.\n     * @param offset The offset at which to place bytes read.\n     * @param numToRead The number of bytes to read.\n     * @return The number of bytes read, or -1 at EOF.\n     * @throws IOException on error\n     */\n    @Override\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n        // Check 1: Stream has hit EOF, or entry is fully read\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n        // Check 2: No current entry selected\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        // Check 3: Clamp numToRead to the number of bytes remaining in the entry\n        // Use Math.min explicitly as available() might return a value lower than\n        // entrySize - entryOffset due to Integer.MAX_VALUE limit or is.available() check.\n        long remainingInEntry = entrySize - entryOffset;\n        int realNumToRead = Math.min(numToRead, (int) Math.min(remainingInEntry, Integer.MAX_VALUE));\n\n        // If calculated bytes to read is 0, we are at the end of the entry.\n        if (realNumToRead <= 0) {\n            // This case should theoretically be covered by entryOffset >= entrySize check,\n            // but included for robustness.\n            return -1;\n        }\n\n        // Read from the underlying stream\n        int bytesRead = is.read(buf, offset, realNumToRead);\n\n        if (bytesRead == -1) {\n            // EOF detected by the underlying stream\n            hasHitEOF = true; // Mark stream EOF\n            // Since we determined realNumToRead > 0 based on remainingInEntry,\n            // hitting EOF here means the entry data is truncated.\n            throw new IOException(\"Truncated TAR entry: \" + currEntry.getName()\n                                + \" (expected \" + entrySize\n                                + \" bytes, but encountered EOF at \" + entryOffset + \")\");\n        }\n\n        // If read was successful (bytesRead >= 0)\n        // Note: read(buf, offset, len) should return > 0 if len > 0, unless EOF is hit.\n        // A return value of 0 is possible if len == 0.\n        if (bytesRead > 0) { // Only count and update offset if bytes were actually read\n            count(bytesRead); // Update physical bytes read count from underlying stream\n            entryOffset += bytesRead; // Update position within the current entry\n        }\n\n        return bytesRead;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}