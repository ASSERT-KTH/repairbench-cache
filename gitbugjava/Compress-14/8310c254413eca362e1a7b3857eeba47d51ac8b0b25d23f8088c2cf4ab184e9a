{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        // Use offset+length for boundary checks, calculations relative to buffer start\n        final int limit = offset + length;\n        int     start = offset;\n        // Effective end of octal digits, reduced by trailers\n        int     effectiveEnd = limit;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        // Check for all NULs first - special case returns 0.\n        boolean allNUL = true;\n        // Use limit for the boundary\n        for (int i = start; i < limit; i++){\n            // Check buffer bounds to prevent IndexOutOfBoundsException\n            if (i >= buffer.length) {\n                 throw new IllegalArgumentException(\"Attempt to read past end of buffer: offset \" + offset\n                     + \", length \" + length + \", buffer size \" + buffer.length);\n            }\n            if (buffer[i] != 0){\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        // Use limit here, ensure start stays within buffer bounds implicitly via loop condition\n        while (start < limit && buffer[start] == ' '){\n            start++;\n        }\n\n        // Check for leading NUL after spaces - special case returns 0 (commons-compress 1.4 behavior)\n        // This needs to be after skipping spaces but before trailer checks.\n        // (If buffer is all spaces, start == limit, this check is skipped, returns 0 later)\n        // Ensure start is still a valid index before checking buffer[start]\n        if (start < limit && buffer[start] == 0) {\n             return 0L;\n        }\n\n        // Check mandatory trailer: last byte must be NUL or space.\n        // Ensure index limit - 1 is valid relative to buffer bounds and offset.\n        if (limit - 1 < offset || limit - 1 >= buffer.length) {\n             throw new IllegalArgumentException(\n                     \"Invalid length/offset for mandatory trailer check: length=\" + length + \", offset=\" + offset + \", buffer size=\" + buffer.length);\n        }\n        final byte trailer1 = buffer[limit - 1];\n        if (trailer1 == 0 || trailer1 == ' '){\n            effectiveEnd--; // Reduce effective end index by one, excluding the trailer\n        } else {\n            // As per documentation \"The buffer must contain a trailing space or NUL\"\n            // if the last byte is not one of these, it's an error.\n             throw new IllegalArgumentException(\n                     exceptionMessage(buffer, offset, length, limit - 1, trailer1));\n        }\n\n        // Check optional second trailer: byte before mandatory trailer (space/NUL)\n        // The index to check is effectiveEnd - 1 (original index limit - 2).\n        // Only check if there's still data potentially before this second trailer\n        // i.e., effectiveEnd - 1 is a valid index and it's at or after start.\n        // Also ensure effectiveEnd - 1 is within buffer bounds.\n        // Note: effectiveEnd was already decremented if trailer1 was valid.\n        if (effectiveEnd - 1 >= start && effectiveEnd - 1 < buffer.length) {\n             final byte trailer2 = buffer[effectiveEnd - 1];\n             if (trailer2 == 0 || trailer2 == ' ') {\n                 effectiveEnd--; // Reduce effective end index again\n             }\n        }\n        // If start == effectiveEnd now, it implies the portion between leading spaces\n        // and trailer(s) was empty. Loop won't run, returns 0.\n\n        // Parse octal digits between start and the calculated effectiveEnd\n        for ( ;start < effectiveEnd; start++) {\n            // Ensure start index remains within buffer bounds\n             if (start >= buffer.length) {\n                 throw new IllegalArgumentException(\"Attempt to parse past end of buffer: offset \" + offset\n                     + \", length \" + length + \", buffer size \" + buffer.length + \", current index \" + start);\n            }\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                // Any non-octal digit (including NUL, handled above for leading NUL) in this section is an error.\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n\n    // Helper method needed for the exception message generation.\n    // Assuming it exists elsewhere in the original class (e.g., TarUtils).\n    // Provide a minimal stub if needed for compilation context, or assume it's available.\n    private static String exceptionMessage(byte[] buffer, final int offset,\n            final int length, int error_offset, byte currentByte) {\n         // In a real environment, this would call the existing TarUtils.exceptionMessage\n         // For repair purposes, we focus on the parseOctal logic.\n         // Minimal placeholder:\n         String dataSnippet = \"[buffer data unavailable]\"; // Or implement fully if needed\n         try {\n              dataSnippet = new String(buffer, offset, Math.min(length, buffer.length - offset), \"ISO-8859-1\").replaceAll(\"\\u0000\", \"{NUL}\");\n         } catch (Exception e) { /* ignore */ }\n\n        return \"Invalid byte \" + currentByte + \" at offset \" + (error_offset - offset) + \" in '\" + dataSnippet + \"' len \" + length;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}