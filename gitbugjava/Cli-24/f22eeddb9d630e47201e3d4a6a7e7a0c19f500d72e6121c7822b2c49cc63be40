{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // Protection against bad arguments like nextLineTabStop >= width\n        // which could be passed by the caller (e.g. renderOptions).\n        // If the requested indent is greater than or equal to the width,\n        // wrapping with that indent is impossible.\n        // Instead of throwing an error (CLI-162), we cap the indent\n        // to a maximum sensible value: width - 1 (or 0 if width is 0 or 1).\n        // This allows at least one character after the padding, preventing infinite loops.\n        int indent = nextLineTabStop;\n        if (indent >= width) {\n             // Cap indent: use width - 1 if possible, otherwise 0.\n             indent = Math.max(0, width - 1);\n        }\n\n        // Use the potentially capped indent for padding\n        final String padding = createPadding(indent);\n\n        // The rest of the text is processed line by line\n        while (true)\n        {\n            // Add padding and the remainder of the text (trimmed)\n            text = padding + text.substring(pos).trim();\n            // Find the next wrap position in the padded text\n            pos = findWrapPos(text, width, 0);\n\n            // If the rest fits on one line, append it and exit the loop\n            if (pos == -1)\n            {\n                sb.append(text);\n                return sb;\n            }\n\n            // Handle edge case (CLI-134 adjustment): if the wrap position is exactly\n            // at the end of the padding ('pos == indent') and the text overflows ('text.length() > width'),\n            // we must ensure we break at 'width' to include at least the first character\n            // following the padding. Otherwise, appending 'text.substring(0, pos)'\n            // might just append the padding again, leading to an infinite loop.\n            if (pos == indent && text.length() > width)\n            {\n                pos = width;\n            }\n\n            // Append the wrapped line (trimmed) and continue the loop\n            // with the remaining text.\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}