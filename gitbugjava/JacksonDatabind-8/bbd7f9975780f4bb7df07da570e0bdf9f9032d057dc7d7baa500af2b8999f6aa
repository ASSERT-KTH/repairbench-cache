{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n            if (oldExplicit) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return; // already had explicit, new one not explicit: keep old\n                }\n                // Both explicit? Should verify, but how? Current code lets new one stay\n                // For [databind#667]: just avoid throwing exception if detected conflicting constructors\n                // NOTE: (28-May-2017, tatu): Need to revisit this decision; may need more complex handling, maybe\n                //    via contextual AnnotationIntrospector\n            } else {\n                // Old one not explicit. Explicit new one might override, non-explicit might too.\n                // Need not do anything special -- fall through will replace.\n            }\n\n            // 16-Feb-2014, tatu: Unless we are overriding creator in sub-class, this is poinltess...\n            //    Let's add [databind#667] exception back for 2.9, reconsideration\n            // 28-May-2017, tatu: As per comment above, revisit. But one specific case is clear:\n            //   do NOT throw exception, if declaring classes differ. This covers the case of\n            //   proper overriding/masking for sub-classes. Let's NOT throw exception then.\n\n            // 12-Jul-2019, tatu: Actually, the logic is simply wrong. We SHOULD be fine with multiple\n            //   creators, iff they are distinct (of different type). Let's remove the check altogether\n            /*\n            if (oldOne.getDeclaringClass() == newOne.getDeclaringClass()) {\n                 throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                      +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            }\n            */\n            // otherwise, which one to choose? Just override for now\n        }\n\n        // If we get this far, we know that the new creator is candidate for inclusion\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}