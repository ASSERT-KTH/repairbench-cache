{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true; // Flag it as soon as we have ANY creator for this type\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        if (oldOne != null) { // If we had an existing creator...\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n            // Was the old one explicit?\n            if (oldExplicit) {\n                // If new one is not explicit, ignore it\n                if (!explicit) {\n                    return;\n                }\n                // Both are explicit: verify\n                // Are they the same actual member? If so, ok (no-op)\n                // Except, should keep the one discovered first (more specific)\n                if (oldOne.getMember().equals(newOne.getMember())) {\n                    // Maybe verify access? But otherwise fine. Let's simply return\n                    return;\n                }\n                // Different members; conflict? Only if in same class\n                Class<?> oldClass = oldOne.getDeclaringClass();\n                Class<?> newClass = newOne.getDeclaringClass();\n\n                if (oldClass == newClass) {\n                    // Same class, different explicit members: conflict.\n                    // Maybe indicate which one is kept? Or throw exception? For now, keep old\n                    // [databind#667]: avoid one particular class of bogus problems\n                    // For now let's keep existing one, maybe log warning in future?\n                    // 25-Feb-2017, tatu: Based on databind#1523, let's actually throw the exception,\n                    //    since this was the intent, and implicit overriding/masking is bad.\n                     throw new IllegalArgumentException(String.format(\"Conflicting %s creators: already had explicitly marked %s, encountered %s\",\n                             TYPE_DESCS[typeIndex], oldOne, newOne));\n                    // return; // whoops previous logic was to silently ignore...\n                }\n                // Different classes: sub-class definition overrides super-class one?\n                if (newClass.isAssignableFrom(oldClass)) { // new is superclass/interface of old?\n                    // Should keep old one, accessible via subclass. So NOP\n                    return;\n                }\n                // otherwise, new is from subclass, overrides parent, fall through\n            } else {\n                // Old one was not explicit: if new one is, fine, replaces non-explicit. Otherwise choose.\n                 if (!explicit) { // Neither is explicit, choose more specific one\n                     Class<?> oldClass = oldOne.getDeclaringClass();\n                     Class<?> newClass = newOne.getDeclaringClass();\n                     // If new is super type of old, keep old\n                     if (newClass.isAssignableFrom(oldClass)) { // new is superclass/interface of old?\n                          return; // keep old\n                     }\n                      // If old is super type of new, keep new (fall through)\n                      // Unrelated hierarchies? Fall through, new one replaces old one.\n                 }\n                 // otherwise fall through, keep the new one\n            }\n            // If we get this far, we will be replacing the old one below\n        }\n\n        // If we reach here, 'newOne' is the chosen creator.\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}