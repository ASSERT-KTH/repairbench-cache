{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true; // Mark that we found *some* non-default creator\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        if (oldOne != null) { // If a creator of this type already exists...\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n            // Check 1: Is the new one the exact same as the old one?\n            // NOTE: relies on `Annotated*` classes having working `equals()` implementation\n            // for the underlying AnnotatedElement (Member)\n            if (oldOne.getAnnotated().equals(newOne.getAnnotated())) { // Check if they represent the same constructor/method\n                // If it's the same, we only care if the 'explicit' status needs updating.\n                if (!oldExplicit && explicit) {\n                    // Old one wasn't marked explicit, but this new finding is. Update the flag.\n                   _explicitCreators |= mask;\n                   // Keep the new one; may have more annotation info? Seems safer.\n                   _creators[typeIndex] = _fixAccess(newOne);\n                }\n                // Whether updated or not, it's not a conflict, so we are done.\n                return;\n            }\n\n            // Check 2: Handle explicit vs non-explicit conflicts/overrides.\n            // If new one is not explicit, but old one was, keep old one\n            if (!explicit && oldExplicit) {\n                // nothing to do, old one is fine\n                return;\n            }\n            // If new one is explicit, but old one was not -> new one takes precedence (below)\n            // If both non-explicit -> new one takes precedence (below)\n            // If both explicit -> conflict\n            if (explicit && oldExplicit) {\n                // This is the case for explicit conflict\n                // [databind#667]: Needs to be handled explicitly, report\n                throw new IllegalArgumentException(String.format(\n                        \"Conflicting %s creators: already had explicitly marked %s, encountered %s\",\n                        TYPE_DESCS[typeIndex], oldOne, newOne));\n            }\n\n            // Otherwise, we will be replacing the old one with the new one.\n            // This occurs if:\n            // - Old one was not explicit, new one is (new one wins)\n            // - Neither is explicit (new one wins by replacement, potential override)\n            // This also handles the case where new one is in sub-class, overrides non-explicit super-class creator.\n            // Or explicit creator in sub-class overrides non-explicit one in super-class.\n        }\n\n        // If we didn't return or throw, assign the new creator (potentially replacing old one).\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}