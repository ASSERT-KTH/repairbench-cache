{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true; // Mark that we have a non-default creator\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        if (oldOne != null) { // If a creator already exists for this typeIndex...\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n            if (oldExplicit) {\n                // Case 1: Existing creator was explicit\n                if (!explicit) {\n                    // New one is not explicit, keep existing explicit one\n                    return; // Ignore newOne\n                }\n                // Both are explicit: Conflict? Check declaring class to allow overrides.\n                Class<?> oldClass = oldOne.getDeclaringClass();\n                Class<?> newClass = newOne.getDeclaringClass();\n\n                if (oldClass == newClass) {\n                    // Same declaring class, both explicit: definite conflict.\n                    // 12-Jun-2020, tatu: Initially message said \"already had explicitly marked\",\n                    //   but explicit flag may have been different. Corrected message slightly\n                     throw new IllegalArgumentException(String.format(\n                         \"Conflicting %s creators: already had explicitly marked %s, encountered explicitly marked %s\",\n                         TYPE_DESCS[typeIndex], oldOne, newOne));\n                }\n                \n                // New creator is in a subclass of the old creator's declaring class? => allow override\n                // (This is hypothetical, likely doesn't make sense in practice maybe?)\n                if (oldClass.isAssignableFrom(newClass)) { // new is subclass\n                     // fall through to replace\n                } else if (newClass.isAssignableFrom(oldClass)) { // new is superclass: keep existing\n                     return; // Ignore newOne\n                } else {\n                     // Unrelated classes, both explicit: conflict. Use more detailed message.\n                     throw new IllegalArgumentException(String.format(\n                         \"Conflicting %s creators: explicitly marked %s from %s vs %s from %s\",\n                         TYPE_DESCS[typeIndex], oldOne, oldClass.getName(), newOne, newClass.getName()));\n                }\n                // If we fell through (subclass override case), proceed to replace oldOne with newOne.\n\n            } else {\n                // Case 2: Existing creator was NOT explicit\n                // If new one is explicit, it simply replaces the non-explicit old one.\n                // If new one is also non-explicit, let it replace the old one.\n                // This resolves the issue (databind#667 reported again) where the original code threw an exception\n                // for non-explicit creators like StringBuilder(String) vs StringBuilder(CharSequence).\n                // Original code had `if (oldOne.getClass() == newOne.getClass())` check\n                // which was not needed and caused the problem.\n                if (explicit) {\n                     // Fall through to replace with the explicit new one\n                } else {\n                     // Fall through to replace with the non-explicit new one\n                     // TODO: May need more sophisticated tie-breaking for multiple non-explicit creators later\n                }\n            }\n        }\n\n        // If we reach here, newOne takes precedence.\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}