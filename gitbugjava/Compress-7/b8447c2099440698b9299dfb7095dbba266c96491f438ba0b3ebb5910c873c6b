{
    "generation": "    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        // Tar file names are character arrays terminated by NUL,\n        // and restricted to US-ASCII. If they contain bytes with the\n        // sign bit set, they are improperly encoded and should be\n        // treated as ISO-8859-1 chars. Less portable implementations\n        // treat the bytes as being encoded using the local default\n        // charset. TarUtils is not particularly portable in either case.\n        //\n        // See http://www.gnu.org/software/tar/manual/html_node/Standard.html\n        //\n        // Treat the bytes as ISO-8859-1 characters.\n        // See https://issues.apache.org/jira/browse/COMPRESS-114\n\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            final byte b = buffer[i];\n            if (b == 0) { // NUL terminator\n                break;\n            }\n            // Convert byte to char, interpreting byte as unsigned value (0-255)\n            // corresponding to ISO-8859-1 code points.\n            // Standard Java cast (char)b treats byte as signed (-128 to 127),\n            // which leads to sign extension for values >= 128, resulting in incorrect\n            // characters. Masking with 0xFF ensures the value is treated as unsigned.\n            result.append((char) (b & 0xFF));\n        }\n\n        return result.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}