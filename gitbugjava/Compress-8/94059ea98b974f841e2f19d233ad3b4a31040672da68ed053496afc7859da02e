{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        // 1. Check minimum length\n        if (length < 2) {\n            throw new IllegalArgumentException(\"Length must be at least 2 bytes: \" + length);\n        }\n\n        long    result = 0;\n        int     i = offset;\n        final int end = offset + length;\n        boolean trailerFound = false;\n        int     trailerPos = -1; // Position where the trailer NUL/space was found\n\n        // Skip leading spaces\n        while (i < end && buffer[i] == ' ') {\n            i++;\n        }\n\n        // Remember where potential digits should start (after spaces)\n        int startOfDigits = i; \n\n        // Handle case where only spaces were found up to the end (violates trailer requirement)\n        // Or if the first non-space character is NUL (effectively zero, but needs validation)\n        if (i == end) {\n             // We consumed only spaces. A trailer (NUL or space) is required.\n             // Since we reached 'end', the only possible valid trailer is if buffer[end-1] is NUL/space.\n             // But the loop structure below handles missing trailers better. Let's remove this specific check.\n             // If we only had spaces, the main loop won't run, trailerFound remains false -> exception.\n        } else if (buffer[i] == 0) {\n            // First non-space char is NUL. Treat as zero value, but validate the rest.\n            trailerFound = true; // NUL acts as the trailer\n            trailerPos = i;\n            // Check remaining bytes must be NUL or space\n            for (int j = trailerPos + 1; j < end; j++) {\n                if (buffer[j] != 0 && buffer[j] != ' ') {\n                    throw new IllegalArgumentException(\n                        \"Expected NUL or space after initial NUL, but found '\" + (char)buffer[j] + \"' (\"+buffer[j]+\") at index \" + j);\n                }\n            }\n            return 0L; // Valid sequence like \" \\0\" or \" \\0\\0\" or \" \\0 \"\n        }\n\n\n        // Start parsing digits - i is already positioned after leading spaces and non-NUL check\n        while (i < end) {\n            final byte currentByte = buffer[i];\n\n            if (currentByte == 0 || currentByte == ' ') {\n                // Found potential trailer NUL or space\n                trailerFound = true;\n                trailerPos = i;\n                break; // Exit parsing loop\n            }\n\n            // Check for invalid characters (anything not '0'-'7')\n            if (currentByte < '0' || currentByte > '7') {\n                 throw new IllegalArgumentException(\n                         exceptionMessage(buffer, offset, length, i, currentByte));\n            }\n\n            // Valid octal digit found, accumulate result\n            result = (result << 3) + (currentByte - '0');\n            i++;\n        }\n\n        // Post-loop validation\n\n        // If no trailer was found before reaching the end\n        if (!trailerFound) {\n            // Examples: \"123\", \"   \", [' ', 0, 0, 0] (for length 4)\n            throw new IllegalArgumentException(\"Missing required NUL or space terminator in octal value.\");\n        }\n\n        // If a trailer WAS found at trailerPos...\n        // Ensure that all characters AFTER the trailer character are also NUL or space.\n        for (int j = trailerPos + 1; j < end; j++) {\n            if (buffer[j] != 0 && buffer[j] != ' ') {\n                // This catches errors like \"123X \", \" 0 07 \", \" 0\\00007 \"\n                throw new IllegalArgumentException(\n                    \"Expected NUL or space after octal value, but found '\" + (char)buffer[j] + \"' (\"+buffer[j]+\") at index \" + j);\n            }\n        }\n\n        // If we skipped spaces and immediately hit the trailer (startOfDigits == trailerPos)\n        // This implies an empty string \"\" followed by a trailer, e.g. \"  \\0\" or \"   \" (if terminated)\n        // This represents zero.\n        if (startOfDigits == trailerPos && result == 0) {\n             // This check isn't strictly necessary as result is already 0\n             // but confirms the intent for empty value after spaces.\n             return 0L;\n        }\n\n        // Otherwise, digits were parsed, return the result.\n        return result;\n    }\n\n    // Helper function to generate exception messages (implementation assumed available)\n    private static String exceptionMessage(byte[] buffer, int offset, int length, int idx, byte currentByte) {\n       // A simple message matching the typical format might suffice.\n       // The original used TarUtils.parseName which might not be available here.\n       String excerpt;\n       try {\n           // Try to get a readable excerpt around the error\n           int excerptStart = Math.max(offset, idx - 10);\n           int excerptEnd = Math.min(offset + length, idx + 10);\n            // Replace NULs for clearer display if needed\n           excerpt = new String(buffer, excerptStart, excerptEnd - excerptStart, \"UTF-8\").replace('\\0', '*');\n       } catch (Exception e) {\n           excerpt = \"(cannot decode excerpt)\";\n       }\n        return \"Invalid byte \" + currentByte + \" at offset \" + idx + \" in specified range [\"+offset+\", \"+(offset+length)+\"). Octal value expected, buffer excerpt near invalid byte: ...\" + excerpt + \"...\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}