{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected,\n     *         or if the buffer length is less than 2 bytes, or if the buffer contains invalid characters.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        // 1. Minimum Length Check\n        if (length < 2) {\n            // Javadoc explicitly states length must be at least 2.\n            throw new IllegalArgumentException(\"Length must be at least 2\");\n        }\n\n        long    result = 0;\n        int     end = offset + length;\n        int     pos = offset;\n        boolean stillPadding = true; // For leading spaces and '0's\n\n        // Check for \"all NULs\" special case FIRST\n        // Handles javadoc rule and cases like [0, 0, ' '] which should fail vs [0, 0, 0] which should return 0.\n        boolean allNuls = true;\n        for (int i = offset; i < end; i++) {\n            if (buffer[i] != 0) {\n                allNuls = false;\n                break;\n            }\n        }\n        if (allNuls) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (pos < end && buffer[pos] == ' ') {\n            pos++;\n        }\n\n        // If after skipping spaces we are at the end, or if the first non-space\n        // character is NUL (and it's not the \"all NULs\" case), then it's invalid.\n        if (pos == end) {\n             // Only spaces found, no digits or terminator\n             // This violates the requirement of digits followed by NUL/space.\n             throw new IllegalArgumentException(\"Cannot parse value from buffer containing only spaces\");\n        }\n        // Check for NUL immediately after spaces (and not the all-NUL case which returns 0)\n        // This logic is derived from the failing test cases [0,0,' '] and [' ',0,0,0]\n        // which expect an exception, implying NUL is only a terminator or part of the all-NUL case.\n        if (buffer[pos] == 0) {\n             throw new IllegalArgumentException(\"Cannot parse value from buffer starting with NUL byte unless all bytes are NUL\");\n        }\n\n\n        // Main loop: process digits until terminator or end\n        for (; pos < end; pos++){\n            final byte currentByte = buffer[pos];\n\n            // NUL or Space signifies the end of the octal number\n            if (currentByte == 0 || currentByte == ' ') {\n                // Verify that the rest of the buffer contains only NUL or space\n                // This catches invalid embedded terminators like \" 0 07 \" or \" 0\\00007 \".\n                for(int i = pos + 1; i < end; i++) {\n                    if (buffer[i] != 0 && buffer[i] != ' ') {\n                         // Found an invalid character after the first terminator.\n                         throw new IllegalArgumentException(\n                                 \"Invalid byte \" + buffer[i] + \" at offset \" + i\n                                 + \" found after NUL/space terminator at offset \" + pos);\n                    }\n                }\n                // If we reached here, the termination is valid.\n                return result;\n            }\n\n            // If we are here, currentByte is not NUL and not space. It must be part of the octal number.\n\n            // Handle padding state ('0's before significant digits '1'-'7')\n            if (stillPadding) {\n                if (currentByte == '0') {\n                    // Allow leading zeros, stay in padding mode.\n                    continue;\n                }\n                // First non-'0' (and non-space) byte encountered. End padding mode.\n                stillPadding = false;\n                // Fall through to process this first significant digit.\n            }\n\n            // Check if character is a valid octal digit ('0'-'7')\n            if (currentByte < '0' || currentByte > '7'){\n                // Found an invalid character (not 0-7, not space, not NUL) where a digit was expected.\n                 throw new IllegalArgumentException(\n                         \"Invalid byte \" + currentByte + \" at offset \" + pos);\n            }\n\n            // Process the octal digit\n            // CheckStyle:MagicNumber OFF already present in original code\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON already present in original code\n\n        } // End of loop\n\n        // If loop finishes without returning, it means we hit the 'end'\n        // without a NUL or space terminator following the last digit(s). This is an error.\n        throw new IllegalArgumentException(\"Missing mandatory trailing NUL or space character.\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}