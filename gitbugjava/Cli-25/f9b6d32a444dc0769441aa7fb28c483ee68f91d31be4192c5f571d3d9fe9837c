{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer. All output lines are padded with the specified\n     * amount of spaces.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab. This is used\n     *                   as the padding amount for all lines.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text) {\n        // Sanitize nextLineTabStop\n        if (nextLineTabStop < 0) {\n            nextLineTabStop = 0;\n        }\n\n        // Ensure width is usable\n        if (width <= 0) {\n            // Cannot wrap, append text as is (potentially overflowing width)\n            // Append padding? Let's be consistent and pad.\n            if (text != null && text.length() > 0) {\n                 sb.append(createPadding(nextLineTabStop)).append(rtrim(text)).append(defaultNewLine);\n            }\n            return sb; // Exit early if width is not positive.\n        }\n\n        final String padding = createPadding(nextLineTabStop);\n\n        // Calculate the width available for actual text content on each line.\n        int effectiveWidth = width - padding.length();\n\n        // If padding consumes all width or more, we cannot fit content reasonably.\n        if (effectiveWidth <= 0) {\n             // Append padding and the entire text on one line (will overflow width).\n             if (text != null && text.length() > 0) { // Only add if text exists\n                  sb.append(padding).append(rtrim(text)).append(defaultNewLine);\n             }\n             return sb;\n        }\n\n        int currentPos = 0;\n        while (currentPos < text.length()) {\n            // Skip leading whitespace from the chunk start position.\n            int start = currentPos;\n            while (start < text.length() && Character.isWhitespace(text.charAt(start))) {\n                start++;\n            }\n            // If only whitespace remains, we are done.\n            if (start >= text.length()) {\n                break;\n            }\n\n            // Find wrap position in the remaining text (from 'start') to fit 'effectiveWidth'.\n            // findWrapPos searches for the last whitespace index 'idx' such that\n            // text.substring(start, idx) fits within the width parameter (here, effectiveWidth).\n            // It returns idx + 1 (the position after the space).\n            // It returns -1 if the remainder from 'start' fits entirely.\n            // It returns 'start' if the first word from 'start' is longer than the width parameter.\n            int wrapPos = findWrapPos(text, effectiveWidth, start);\n\n            String lineText;\n            if (wrapPos == -1) {\n                // No wrap point found within effectiveWidth for the remainder.\n                // The rest of the text fits on this line.\n                lineText = text.substring(start);\n                currentPos = text.length(); // Mark as done.\n            } else if (wrapPos == start) {\n                 // Word starting at 'start' is longer than effectiveWidth.\n                 // Break the word at effectiveWidth to make progress.\n                 int breakPoint = start + effectiveWidth;\n                 if (breakPoint > text.length()) { // Avoid StringIndexOutOfBounds\n                     breakPoint = text.length();\n                 }\n                 lineText = text.substring(start, breakPoint);\n                 currentPos = breakPoint; // Advance past the broken part for next iteration.\n            } else {\n                 // Normal wrap at whitespace. wrapPos is index after the space.\n                 lineText = text.substring(start, wrapPos);\n                 currentPos = wrapPos; // Next iteration starts after the space found.\n            }\n\n            // Append the padded line with the extracted text chunk.\n            sb.append(padding); // Add padding\n            sb.append(rtrim(lineText)); // Add trimmed text chunk\n            sb.append(defaultNewLine); // Add newline\n        }\n\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}