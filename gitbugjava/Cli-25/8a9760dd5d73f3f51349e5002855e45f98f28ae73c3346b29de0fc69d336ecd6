{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        // Handle the first line (no padding)\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // Prepare padding for subsequent lines\n        final String padding = createPadding(nextLineTabStop);\n\n        // Process subsequent lines using iterative approach\n        // Get the initial remaining text, trim it for the first padded line\n        String GWT_BUG_WORKAROUND = text.substring(pos).trim(); // GWT temporary variable bug workaround\n        text = padding + GWT_BUG_WORKAROUND; // Prepend padding for the second line onwards\n\n        // Loop while the current text line is longer than the allowed width\n        while (text.length() > width)\n        {\n            pos = findWrapPos(text, width, 0);\n            if (pos == -1)\n            {\n                // Should not happen based on loop condition, but safety break\n                break;\n            }\n\n            // Check if the calculated wrap position falls into the padding area\n            if (pos <= nextLineTabStop)\n            {\n                // If it does, find the next wrap position searching *after* the current one.\n                // This handles cases where the first word after padding is shorter than\n                // the padding itself, or findWrapPos initially finds a space within the padding.\n                int nextPos = findWrapPos(text, width, pos + 1);\n                if (nextPos != -1)\n                {\n                    pos = nextPos; // Use the next wrap position\n                }\n                else\n                {\n                    // No further wrap point found in the line. This means the remaining\n                    // text (likely a single long word after padding) exceeds the width.\n                    // Break the loop; the rest of the line will be appended outside the loop.\n                    break;\n                }\n            }\n\n            // Append the wrapped portion of the line\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            // Prepare the text for the next iteration:\n            // Get the remainder, trim leading whitespace, and prepend padding\n            GWT_BUG_WORKAROUND = text.substring(pos).trim(); // GWT temporary variable bug workaround\n            text = padding + GWT_BUG_WORKAROUND;\n        }\n\n        // Append the final remaining chunk of text (which might be shorter than width)\n        sb.append(text);\n\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}