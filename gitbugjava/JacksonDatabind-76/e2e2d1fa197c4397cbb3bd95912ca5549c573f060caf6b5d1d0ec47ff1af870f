{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = null; // Keep null until needed\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator prop? Build early\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    t = p.nextToken(); // Check next token\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                         return wrapInstantiationProblem(e, ctxt);\n                    }\n                    // assign buffered properties stored in buffer BEFORE processing unwrapped properties\n                    for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) {\n                        pv.assign(bean);\n                    }\n\n                    // check for type id now\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                         return ctxt.reportBadDefinition(_beanType, String.format(\n                                 \"Cannot create polymorphic instances with unwrapped values. Class %s did not resolve to default type %s\",\n                                 bean.getClass().getName(), _beanType.getRawClass().getName()));\n                    }\n\n                    // Ensure token buffer exists for unwrapped properties\n                    if (tokens == null) {\n                        tokens = new TokenBuffer(p, ctxt);\n                        tokens.writeStartObject(); // Start the virtual object for unwrapped props\n                    }\n\n                    // Buffer remaining properties from stream into tokens\n                    while (t == JsonToken.FIELD_NAME) {\n                        // Need to copy name when building early; otherwise already buffered\n                        tokens.writeFieldName(p.getCurrentName());\n                        p.nextToken(); // value\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n                    tokens.writeEndObject();\n\n                    // We have the bean, and buffer has unwrapped props. Process them.\n                    // Pass current token parser 'p' along, but unwrapped handler should mostly\n                    // use the 'tokens' buffer.\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                // Not yet complete, continue buffering creator props\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // ignorable property?\n            Set<String> ignored = _ignorableProps;\n            if (ignored != null && ignored.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n\n            // If not creator, objectId, regular bean property, or ignorable,\n            // it must be an unwrapped property (or handled by AnySetter). Buffer using TokenBuffer.\n            if (tokens == null) {\n                tokens = new TokenBuffer(p, ctxt);\n                tokens.writeStartObject(); // Start the virtual object for unwrapped props\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n\n            // \"any property\"?\n            // Note: cannot call bufferAnyProperty() method because we need to call processUnwrapped()\n            // which relies on TokenBuffer only containing unwrapped/any properties\n            if (_anySetter != null) {\n                // We can't call buffer.bufferAnyProperty because that assumes we can process\n                // buffered properties after bean creation, but processUnwrapped needs the AnySetter itself.\n                // For now, let's assume AnySetter implies it's handled like unwrapped properties.\n                // A potential improvement would be to buffer AnySet values separately if needed.\n                 ; // Already buffered to tokens above\n            }\n        }\n\n        // Reached END_OBJECT\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            // As per [databind#1389] should perhaps not handle caught Exception, but...\n            return wrapInstantiationProblem(e, ctxt);\n        }\n\n        // assign buffered properties stored in buffer BEFORE processing unwrapped properties\n        for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) {\n            pv.assign(bean);\n        }\n\n        // Then process unwrapped properties (from TokenBuffer). Close buffer properly\n        if (tokens != null) {\n            // check for type id now\n            if (bean.getClass() != _beanType.getRawClass()) {\n                 return ctxt.reportBadDefinition(_beanType, String.format(\n                         \"Cannot create polymorphic instances with unwrapped values (due to external type id property?). Class %s did not resolve to default type %s\",\n                         bean.getClass().getName(), _beanType.getRawClass().getName()));\n            }\n            tokens.writeEndObject(); // Close the virtual object\n            // Pass current token parser 'p' along, but unwrapped handler should mostly\n            // use the 'tokens' buffer.\n            return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        }\n        // If no tokens were buffered (only creator/bean props), just return the bean\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}