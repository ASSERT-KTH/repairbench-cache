{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 01-Sep-2017, tatu: Although we need to buffer all properties,\n        //   may need to buffer into separate TokenBuffer if Built-Based Creators\n        //   are used: this is because Builder may be needed to process\n        //   unwrapped properties.\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Last creator property to assign?\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        // 24-Aug-2016, tatu: As per [databind#1347], need to wrap problem\n                        bean = wrapInstantiationProblem(e, ctxt);\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: do not call p.copyCurrentStructure() as that implies reading closing END_OBJECT\n                        tokens.writeFieldName(p.getCurrentName());\n                        p.nextToken(); // value token\n                        tokens.copyCurrentStructure(p); // copies value structure, advances p\n                        t = p.getCurrentToken(); // p points to FIELD_NAME or END_OBJECT\n                    }\n                    // We must be pointing to `END_OBJECT`, so:\n                    tokens.writeEndObject();\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n                        //   it's too complicated, so bail out\n                        // 17-Dec-2013, tatu: Need to allow this case for Builder methods that\n                        //    return differing type...\n\n                         // 03-Feb-2017, tatu: ... except, may need to check Builder settings?\n                         //     Ok, for now let's assume this is fine.\n\n//                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        // note: this call returns null\n                        return ctxt.reportBadDefinition(_beanType, String.format(\n\"Cannot create polymorphic instances with unwrapped values. Resetting parser to ignore remaining tokens (%s)\", p.currentToken()));\n\n//                        return null;\n                    }\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                continue; // otherwise, keep collecting creator properties\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // Things marked as ignorable should not be passed to any setter\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // Most likely an unwrapped property, need to buffer\n            // 29-Aug-2010, tatu: Does this actually work? Seems problematic, buffering-wise.\n            //  Need to change this to perhaps bufferign tokens... Yeah, looks like it.\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            // \"any property\"?\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: let's call handler method\n            // 01-Sep-2017, tatu: Should this be done here? Or outside?\n            //    For now, do here, assuming it's ok to call within loop.\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            // 24-Aug-2016, tatu: As per [databind#1347], need to wrap problem\n            bean = wrapInstantiationProblem(e, ctxt);\n            // signal downstream handlers, if possible\n            return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n        }\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}