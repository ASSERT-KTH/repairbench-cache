{
    "generation": "    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        // 13-Jun-2015, tatu: As per [databind#784] allow @JsonGetter to specify\n        //    name override. Might make sense to refactor further...\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)\n                    // [databind#44] Add support for @JsonUnwrapped too:\n                    || _hasAnnotation(a, JsonUnwrapped.class)) {\n                // Can be used to indicate that property is to be serialized,\n                // but without specifying name: names are deduced implicitly.\n                // But we need to return non-null locally to indicate it is\n                // recognized...\n                // ... and, need to use empty String (not null), similarly to how\n                // empty name from @JsonProperty is indicated.\n                name = \"\";\n            } else {\n                // no explicit indicators, ignore\n                return null;\n            }\n        }\n        // just explicit name (`\"\"`) means \"use default name\"; null means \"no indicator\"\n        return PropertyName.construct(name);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}