{
    "generation": "    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n                /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                 *   it's actually bit tricky to do it more efficiently (meta-annotations\n                 *   add more lookups; AnnotationMap costs etc)\n                 */\n            // Check for other annotations that indicate inclusion\n            // [databind#2120]: Need to check @JsonUnwrapped too\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)\n                    // IMPORTANT: must also check @JsonUnwrapped, since it also\n                    // indicates processing if discovered, but does not imply\n                    // explicit name\n                    || _hasAnnotation(a, JsonUnwrapped.class)\n            ) {\n                // Found annotation that indicates inclusion, but not name\n                name = \"\";\n            } else {\n                // No serialization-indicating annotations found\n                return null;\n            }\n        }\n        // If name is null or empty, PropertyName.construct() will return\n        // `USE_DEFAULT` (which may be overridden later); we specifically want\n        // null marker only if no annotations were found.\n        // Empty String has specific default name meaning (usually \"use default\")\n        return PropertyName.construct(name);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}