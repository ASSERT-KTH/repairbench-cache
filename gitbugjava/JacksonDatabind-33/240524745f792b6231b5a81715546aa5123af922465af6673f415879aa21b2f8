{
    "generation": "    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        String name = null;\n\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            name = jg.value();\n        } else {\n            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n            if (pann != null) {\n                name = pann.value();\n            } else if (_hasAnnotation(a, JsonSerialize.class)\n                    || _hasAnnotation(a, JsonView.class)\n                    || _hasAnnotation(a, JsonRawValue.class)\n                    // [databind#498]: also consider @JsonUnwrapped\n                    || _hasAnnotation(a, JsonUnwrapped.class)\n                    ) {\n                // If any of these annotations found, indicates property HAS to be\n                // serialized; but without explicit name.\n                // Special case: empty String can be used to disable name, requirement\n                // is that there is AN annotation. Seems confusing, backwards,\n                // but is the current logic. Underlying problem is that there isn't\n                // dedicated mechanism for marking inclusion, independent of naming\n                name = \"\";\n            } else {\n                 return null;\n            }\n        }\n        // An empty String for name is indicator that there is no name associated\n        // (which usually means \"use default\", but here means \"no name\")\n        // But null means that there is no explicit name OR indication of inclusion\n        // So we need to construct instance to represent empty name.\n        return PropertyName.construct(name);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}