{
    "generation": "    @Override\n    public PropertyName findNameForSerialization(Annotated a)\n    {\n        // @JsonGetter is simplest, has precedence\n        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n        if (jg != null) {\n            String s = jg.value();\n            // always indicates property relationship, even if empty String:\n            return PropertyName.construct(s);\n        }\n\n        // @JsonProperty has next precedence\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            String s = pann.value();\n             // always indicates property relationship, even if empty String:\n             return PropertyName.construct(s);\n        }\n\n        // 15-Oct-2015, tatu: Important; check JsonSerialize AFTER specific markers\n        //    Also: JsonRawValue should be checked before others\n        // 06-Nov-2015, tatu: Ok, further, `@JsonUnwrapped` needs consideration...\n        // but otherwise things like @JsonSerialize, @JsonView, @JsonRawValue imply existence\n        // (and more importantly, JsonUnwrapped!)\n        if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class)\n                || _hasAnnotation(a, JsonRawValue.class)\n                // [databind#442]: @JsonUnwrapped needs to be considered too\n                || _hasAnnotation(a, JsonUnwrapped.class)) {\n             // And for these, implicit name is PROPERTY_NAME_USE_DEFAULT\n             return PropertyName.USE_DEFAULT;\n        }\n\n        // If nothing above, no indication of virtual property\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}