{
    "generation": "    private SimpleRobotRules parseContent(String url, byte[] content, String contentType, Collection<String> robotNames, boolean exactUserAgentMatching) {\n\n        // If there's nothing there, treat it like we have no restrictions.\n        if ((content == null) || (content.length == 0)) {\n            return new SimpleRobotRules(RobotRulesMode.ALLOW_ALL);\n        }\n\n        int bytesLen = content.length;\n        int offset = 0;\n        Charset encoding = StandardCharsets.US_ASCII;\n\n        // Check for BOMs first to determine encoding\n        if ((bytesLen >= 3) && (content[0] == (byte) 0xEF) && (content[1] == (byte) 0xBB) && (content[2] == (byte) 0xBF)) {\n            offset = 3;\n            bytesLen -= 3;\n            encoding = StandardCharsets.UTF_8;\n        } else if ((bytesLen >= 2) && (content[0] == (byte) 0xFF) && (content[1] == (byte) 0xFE)) {\n            offset = 2;\n            bytesLen -= 2;\n            encoding = StandardCharsets.UTF_16LE;\n        } else if ((bytesLen >= 2) && (content[0] == (byte) 0xFE) && (content[1] == (byte) 0xFF)) {\n            offset = 2;\n            bytesLen -= 2;\n            encoding = StandardCharsets.UTF_16BE;\n        }\n\n        // Check content type for charset parameter if no BOM detected\n        if (encoding == StandardCharsets.US_ASCII && contentType != null) {\n            int beginIndex = contentType.toLowerCase(Locale.ROOT).indexOf(\"charset=\");\n            if (beginIndex != -1) {\n                int startIndex = beginIndex + \"charset=\".length();\n                int endIndex = contentType.indexOf(';', startIndex);\n                if (endIndex == -1) {\n                    endIndex = contentType.length();\n                }\n                String charsetSpec = contentType.substring(startIndex, endIndex).trim();\n                if (charsetSpec.startsWith(\"\\\"\") && charsetSpec.endsWith(\"\\\"\")) {\n                    charsetSpec = charsetSpec.substring(1, charsetSpec.length() - 1).trim();\n                }\n                try {\n                    encoding = Charset.forName(charsetSpec);\n                } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n                    LOGGER.trace(\"Unsupported charset specified in content-type for {}: {}\", url, charsetSpec);\n                }\n            }\n        }\n\n        String contentAsStr = new String(content, offset, bytesLen, encoding);\n\n        // Existing HTML processing logic\n        boolean isHtmlType = ((contentType != null) && contentType.toLowerCase(Locale.ROOT).startsWith(\"text/html\"));\n        boolean hasHTML = false;\n        if (isHtmlType || SIMPLE_HTML_PATTERN.matcher(contentAsStr).find()) {\n            if (!USER_AGENT_PATTERN.matcher(contentAsStr).find()) {\n                LOGGER.trace(\"Found non-robots.txt HTML file: \" + url);\n                return new SimpleRobotRules(RobotRulesMode.ALLOW_ALL);\n            } else {\n                if (isHtmlType) {\n                    LOGGER.debug(\"HTML content type returned for robots.txt file: \" + url);\n                } else {\n                    LOGGER.debug(\"Found HTML in robots.txt file: \" + url);\n                }\n                hasHTML = true;\n            }\n        }\n\n        // Remaining parsing code as before\n        StringTokenizer lineParser = new StringTokenizer(contentAsStr, \"\\n\\r\\u0085\\u2028\\u2029\");\n        ParseState parseState = new ParseState(url, robotNames);\n\n        while (lineParser.hasMoreTokens()) {\n            // ... process each line as before ...\n        }\n\n        // ... return rules as before ...\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}