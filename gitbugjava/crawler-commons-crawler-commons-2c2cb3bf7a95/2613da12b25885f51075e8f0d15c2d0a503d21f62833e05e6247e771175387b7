{
    "generation": "private SimpleRobotRules parseContent(String url, byte[] content, String contentType, Collection<String> robotNames, boolean exactUserAgentMatching) {\n\n    // If there's nothing there, treat it like we have no restrictions.\n    if ((content == null) || (content.length == 0)) {\n        return new SimpleRobotRules(RobotRulesMode.ALLOW_ALL);\n    }\n\n    int bytesLen = content.length;\n    int offset = 0;\n    Charset encoding = StandardCharsets.US_ASCII;\n\n    // Check for a UTF-8 BOM at the beginning (EF BB BF)\n    if ((bytesLen >= 3) && (content[0] == (byte) 0xEF) && (content[1] == (byte) 0xBB) && (content[2] == (byte) 0xBF)) {\n        offset = 3;\n        bytesLen -= 3;\n        encoding = StandardCharsets.UTF_8;\n    }\n    // Check for UTF-16LE BOM at the beginning (FF FE)\n    else if ((bytesLen >= 2) && (content[0] == (byte) 0xFF) && (content[1] == (byte) 0xFE)) {\n        offset = 2;\n        bytesLen -= 2;\n        encoding = StandardCharsets.UTF_16LE;\n    }\n    // Check for UTF-16BE BOM at the beginning (FE FF)\n    else if ((bytesLen >= 2) && (content[0] == (byte) 0xFE) && (content[1] == (byte) 0xFF)) {\n        offset = 2;\n        bytesLen -= 2;\n        encoding = StandardCharsets.UTF_16BE;\n    }\n\n    String contentAsStr;\n    // Try UTF-8 decoding first, fall back if necessary\n    try {\n        contentAsStr = new String(content, offset, bytesLen, encoding);\n    } catch (Exception e) {\n        // fallback for invalid encoding, use ISO-8859-1\n        contentAsStr = new String(content, offset, bytesLen, StandardCharsets.ISO_8859_1);\n    }\n\n    // Decide if we need to do special HTML processing.\n    boolean isHtmlType = ((contentType != null) && contentType.toLowerCase(Locale.ROOT).startsWith(\"text/html\"));\n\n    // If it looks like it contains HTML, but doesn't have a user agent\n    // field, then\n    // assume somebody messed up and returned back to us a random HTML page\n    // instead\n    // of a robots.txt file.\n    boolean hasHTML = false;\n    if (isHtmlType || SIMPLE_HTML_PATTERN.matcher(contentAsStr).find()) {\n        if (!USER_AGENT_PATTERN.matcher(contentAsStr).find()) {\n            LOGGER.trace(\"Found non-robots.txt HTML file: \" + url);\n            return new SimpleRobotRules(RobotRulesMode.ALLOW_ALL);\n        } else {\n            // We'll try to strip out HTML tags below.\n            if (isHtmlType) {\n                LOGGER.debug(\"HTML content type returned for robots.txt file: \" + url);\n            } else {\n                LOGGER.debug(\"Found HTML in robots.txt file: \" + url);\n            }\n\n            hasHTML = true;\n        }\n    }\n\n    // Break on anything that might be used as a line ending. Since\n    // tokenizer doesn't return empty tokens, a \\r\\n sequence still\n    // works since it looks like an empty string between the \\r and \\n.\n    StringTokenizer lineParser = new StringTokenizer(contentAsStr, \"\\n\\r\\u0085\\u2028\\u2029\");\n    ParseState parseState = new ParseState(url, robotNames);\n\n    while (lineParser.hasMoreTokens()) {\n        String line = lineParser.nextToken();\n\n        // Get rid of HTML markup, in case some brain-dead webmaster has\n        // created an HTML\n        // page for robots.txt. We could do more sophisticated processing\n        // here to better\n        // handle bad HTML, but that's a very tiny percentage of all\n        // robots.txt files.\n        if (hasHTML) {\n            line = line.replaceAll(\"<[^>]+>\", \"\");\n        }\n\n        // trim out comments and whitespace\n        int hashPos = line.indexOf(\"#\");\n        if (hashPos >= 0) {\n            line = line.substring(0, hashPos);\n        }\n\n        line = line.trim();\n        if (line.length() == 0) {\n            continue;\n        }\n\n        // Fix: decode percent-encoded characters in directive values as needed\n        // Only for ALLOW and DISALLOW directives, decode path values\n        RobotToken token = tokenize(line);\n\n        switch (token.getDirective()) {\n            case USER_AGENT:\n                handleUserAgent(parseState, token);\n                break;\n\n            case DISALLOW:\n            case ALLOW: {\n                parseState.setFinishedAgentFields(true);\n                // Try to decode percent-encoded path (RFC 3986 style)\n                String value = token.getValue();\n                if (value != null) {\n                    String decodedValue = value;\n                    // Try to decode only if there's a % in the value\n                    if (value.contains(\"%\")) {\n                        try {\n                            // RFC: robots.txt paths are not full URLs, so only decode path\n                            // Prevent + -> space conversion (as in .decode), use UTF-8 (as per modern usage)\n                            decodedValue = java.net.URLDecoder.decode(value, \"UTF-8\");\n                        } catch (Exception ignore) {\n                            // keep value as-is if decoding fails\n                        }\n                    }\n                    // If value could not be represented after decoding due to encoding, skip addition\n                    if (!containsReplacementCharacter(decodedValue)) {\n                        if (token.getDirective() == Directive.DISALLOW) {\n                            handleDisallow(parseState, new RobotToken(token.getDirective(), decodedValue));\n                        } else {\n                            handleAllow(parseState, new RobotToken(token.getDirective(), decodedValue));\n                        }\n                    } else {\n                        // If contains invalid chars, try with original value (unescaped)\n                        if (token.getDirective() == Directive.DISALLOW) {\n                            handleDisallow(parseState, token);\n                        } else {\n                            handleAllow(parseState, token);\n                        }\n                    }\n                } else {\n                    // fallback, shouldn't happen\n                    if (token.getDirective() == Directive.DISALLOW) {\n                        handleDisallow(parseState, token);\n                    } else {\n                        handleAllow(parseState, token);\n                    }\n                }\n                break;\n            }\n\n            case CRAWL_DELAY:\n                parseState.setFinishedAgentFields(true);\n                handleCrawlDelay(parseState, token);\n                break;\n\n            case SITEMAP:\n                parseState.setFinishedAgentFields(true);\n                handleSitemap(parseState, token);\n                break;\n\n            case HTTP:\n                parseState.setFinishedAgentFields(true);\n                handleHttp(parseState, token);\n                break;\n\n            case UNKNOWN:\n                reportWarning(parseState, \"Unknown directive in robots.txt file: {}\", line);\n                parseState.setFinishedAgentFields(true);\n                break;\n\n            case MISSING:\n                reportWarning(parseState, \"Unknown line in robots.txt file (size {}): {}\", content.length, line);\n                parseState.setFinishedAgentFields(true);\n                break;\n\n            default:\n                // All others we just ignore\n                // TODO KKr - which of these should be setting\n                // finishedAgentFields to true?\n                // TODO KKr - handle no-index\n                // TODO KKr - handle request-rate and visit-time\n                break;\n        }\n    }\n\n    this._numWarningsDuringLastParse.set(parseState._numWarnings);\n    SimpleRobotRules result = parseState.getRobotRules();\n    if (result.getCrawlDelay() > _maxCrawlDelay) {\n        // Some evil sites use a value like 3600 (seconds) for the crawl\n        // delay, which would cause lots of problems for us.\n        LOGGER.debug(\"Crawl delay exceeds max value - so disallowing all URLs: {}\", url);\n        return new SimpleRobotRules(RobotRulesMode.ALLOW_NONE);\n    } else {\n        result.sortRules();\n        return result;\n    }\n}\n\n/**\n * Utility to check if string contains Unicode replacement character (\ufffd),\n * which hints at decoding errors.\n */\nprivate static boolean containsReplacementCharacter(String str) {\n    return str != null && str.indexOf('\\uFFFD') >= 0;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}