{
    "generation": "  /**\n   * Infers template types for a function call based on the argument types.\n   * This function specifically focuses on inferring template types that are\n   * declared directly on the function being called (callee's own template types),\n   * not template types inherited from an enclosing class.\n   *\n   * The inferred types are used to specialize the function signature for this\n   * specific call, and the call node's JSType is updated with the specialized\n   * return type. The type of the callee definition itself is not modified.\n   *\n   * @param n The call Node.\n   * @param fnType The function type of the callee.\n   * @return True if any function-specific template types were inferred and applied.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    // Get template types declared directly on the function (not from outer scopes like classes).\n    ImmutableList<TemplateType> ownKeys = fnType.getOwnTemplateKeys();\n    if (ownKeys.isEmpty()) {\n      // If the function itself doesn't declare template types, there's nothing to infer here.\n      // Class template types are resolved based on the receiver type elsewhere.\n      return false;\n    }\n\n    // Attempt to infer types for all template types (own and potentially class ones)\n    // based on the call's arguments matching the function's parameter types.\n    // The inferTemplateTypesFromParameters function handles the actual inference logic.\n    Map<TemplateType, JSType> inferredAll =\n        inferTemplateTypesFromParameters(fnType, n);\n\n    // We are only interested in the inferences made for the function's *own* template types.\n    // Filter the inference results to exclude class template types.\n    Map<TemplateType, JSType> inferredOwn = new HashMap<>();\n    for (TemplateType key : ownKeys) {\n      if (inferredAll.containsKey(key)) {\n        JSType inferredType = inferredAll.get(key);\n        // Store the inference if a non-null type was found.\n        if (inferredType != null) {\n          inferredOwn.put(key, inferredType);\n        }\n      }\n    }\n\n    // Create a replacer that will substitute only the inferred *own* template types.\n    // If inferredOwn is empty (no own types were inferred), the replacer will do nothing.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferredOwn);\n\n    // Create a specialized version of the function type for this specific call\n    // by applying the inferred types for the function's own templates.\n    // Template types from outer scopes (like classes) remain unaffected by this replacer;\n    // they should be resolved based on the receiver type.\n    FunctionType specializedFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(specializedFnType);\n\n    // Update the JSType of the call expression node itself (n)\n    // with the return type from the specialized function signature.\n    // Crucially, DO NOT modify the JSType of the callee node (n.getFirstChild()). Modifying\n    // the callee based on a specific call site is incorrect.\n    n.setJSType(specializedFnType.getReturnType());\n\n    // Return true iff the replacer actually substituted any types, indicating that\n    // inference succeeded for at least one function-specific template type.\n    return replacer.madeChanges;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}