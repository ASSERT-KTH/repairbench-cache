{
    "generation": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   *\n   * This function infers template types for a function call based on the\n   * arguments and specializes the function's type for this specific call.\n   *\n   * @param n The call node.\n   * @param fnType The generic type of the function being called.\n   * @return True if template types were inferred and the function type was\n   *     specialized; false otherwise.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false; // No templates to infer.\n    }\n\n    // Try to infer the template types based on parameters.\n    Map<TemplateType, JSType> inferred =\n        inferTemplateTypesFromParameters(fnType, n);\n\n    // Build the map for the replacer.\n    // It includes inferred types (T -> inferred_type) and identity mappings\n    // (T -> T) for any template types that were not inferred.\n    // This prevents uninferred template types from being replaced by UNKNOWN.\n    Map<TemplateType, JSType> replacements = Maps.newHashMap(inferred);\n    for (TemplateType key : keys) {\n      // Ensure every template key from the function type is in the map.\n      // If it wasn't inferred, map it to itself to preserve it.\n      replacements.putIfAbsent(key, key);\n    }\n\n    // Create a replacer that uses the 'replacements' map.\n    // The TemplateTypeReplacer keeps track of whether any type substitutions\n    // resulted in an actual change via its 'madeChanges' field.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, replacements);\n\n    // Apply the replacer to the function type to get the specialized type.\n    // Uninferred types (mapped to themselves) will remain as template types.\n    // Inferred types will be substituted.\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    // Check if the replacer actually made any changes.\n    // If not, the specialized type is the same as the original fnType,\n    // so no updates are needed, and we indicate no changes were made.\n    if (!replacer.madeChanges) {\n      return false;\n    }\n\n    // If changes were made, update the JSTypes.\n    Node callTarget = n.getFirstChild();\n    // Update the JSType of the call target (e.g., obj.method) to the specialized type\n    // This allows subsequent argument checking by TypeCheck to use the specialized signature.\n    callTarget.setJSType(replacementFnType);\n    // Set the JSType of the call node (the result of the call) based on the specialized return type.\n    n.setJSType(replacementFnType.getReturnType());\n\n    // Return true to indicate that template types were inferred and\n    // the function type was specialized for this call.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}