{
    "generation": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   *\n   * <p>This function takes a CALL node N and the FunctionType FN bomb\u00e9 of the\n   * function being called, and tries to infer the template types involved.\n   * It uses the argument types and the declared parameter types (including 'this')\n   * to perform the inference. The inferred types are then used to specialize\n   * the function type, and the resulting specialized type is applied to the\n   * call target and the call node itself.\n   *\n   * @param n The CALL node.\n   * @param fnType The {@link FunctionType} of the function being called.\n   * @return True if any template types were inferred and replaced.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    // Get the template keys associated with the function type.\n    // This includes keys from the receiver type (if it's generic) and\n    // keys specific to the function/method declaration.\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      // If there are no template types, there's nothing to infer.\n      return false;\n    }\n\n    // Try to infer the template types based on the arguments passed in the call.\n    // This involves matching argument types against parameter types (including 'this').\n    // Potential issues with conflicting constraints (like in Issue 1058)\n    // or ambiguous matches (like in Templatized11) are handled within\n    // inferTemplateTypesFromParameters and its callees (JSType#inferTemplatedTypes).\n    // The result 'inferred' maps template types to their inferred JSTypes.\n    Map<TemplateType, JSType> inferred =\n        inferTemplateTypesFromParameters(fnType, n);\n\n\n    // Replace all template types listed in 'keys' within the original function\n    // signature (fnType) with their inferred types from the 'inferred' map.\n    // If a template type listed in 'keys' was not successfully inferred (i.e.,\n    // it's not present in the 'inferred' map), the TemplateTypeReplacer\n    // defaults to replacing it with the UNKNOWN type.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild(); // The node being called (e.g., the GETPROP)\n\n    // Create the specialized function type by visiting the original fnType\n    // and applying the replacements defined in the replacer.\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    // Ensure the result of the visit/replacement is still a function type.\n    // If the replacement process somehow results in a non-function type,\n    // this indicates a problem, potentially with the inferred types or the\n    // structure of fnType.\n    Preconditions.checkNotNull(replacementFnType, \"Function type %s visited with %s resulted in null\", fnType, inferred);\n\n    // Update the JSType of the node being called (e.g., obj.method) to the\n    // specialized function type. This allows subsequent checks to use the\n    // specialized signature.\n    callTarget.setJSType(replacementFnType);\n    // Update the JSType of the entire call expression node 'n' (e.g., obj.method(arg))\n    // to the return type of the specialized function. This determines the type\n    // of the value produced by the call.\n    n.setJSType(replacementFnType.getReturnType());\n\n    // Return true if the replacer actually made any changes (i.e., if any\n    // template types were substituted). This indicates that specialization occurred.\n    return replacer.madeChanges;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}