{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long instant;\n        try {\n            // Try Gregorian calculation first.\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // Okay, Gregorian calculation succeeded.\n\n            if (instant < iCutoverMillis) {\n                // Instant is before the cutover estimate. It might be Julian.\n                // Calculate the Julian instant anyway to detect the gap.\n                long julianInstant = iJulianChronology.getDateTimeMillis\n                    (year, monthOfYear, dayOfMonth,\n                     hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n                if (julianInstant >= iCutoverMillis) {\n                    // The Julian instant is on or after the cutover, but the\n                    // Gregorian instant is before the cutover. This means the\n                    // date is in the cutover gap.\n                    throw new IllegalArgumentException(\"Specified date does not exist\");\n                }\n                // Both Gregorian and Julian instants are before the cutover.\n                // The date must be verified by the Julian calendar rules.\n                // Note: We return the Julian instant, not the Gregorian one,\n                // because the GJChronology uses Julian rules before the cutover.\n                return julianInstant;\n            } else {\n                // Instant is on or after the cutover estimate. Assume Gregorian.\n                return instant;\n            }\n\n        } catch (IllegalArgumentException e) {\n            // Gregorian calculation failed. This can happen if the date is invalid\n            // in Gregorian (eg Gregorian leap year rules) but valid in Julian.\n            // It can also happen if the date is truly invalid (eg Feb 30).\n\n            // Calculate the Julian instant. If this fails too, the original exception\n            // (or a new one from Julian) will propagate correctly.\n            long julianInstant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // Julian calculation succeeded.\n\n            if (julianInstant < iCutoverMillis) {\n                // The Julian instant is before the cutover. Since the Gregorian\n                // calculation failed, we assume this is a valid Julian date\n                // before the cutover (like 1500-02-29).\n                return julianInstant;\n            } else {\n                // The Julian instant is on or after the cutover. However, the\n                // Gregorian calculation failed. This means the date doesn't\n                // exist in the Gregorian calendar after the cutover but would\n                // have existed in Julian (like 1700-02-29). Therefore, it is\n                // invalid in GJChronology.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}