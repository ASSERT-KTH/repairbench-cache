{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Calculate using Julian first, as it comes chronologically before Gregorian\n        // This fixes bugs related to dates like 1500-02-29 which is valid Julian but invalid Gregorian\n        long julianInstant;\n        try {\n             julianInstant = iJulianChronology.getDateTimeMillis(\n                year, monthOfYear, dayOfMonth,\n                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // If Julian calculation fails, it might be a Gregorian date after the cutover,\n            // or just an invalid date. Try Gregorian. If it also fails, the exception\n            // will propagate correctly. If it succeeds, the logic below handles it.\n             return iGregorianChronology.getDateTimeMillis(\n                year, monthOfYear, dayOfMonth,\n                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n             // Note: If Gregorian succeeds here, it must be >= cutover, otherwise\n             // something is wrong. But the checks below handle the cutover comparison.\n             // This path is mainly for invalid dates under Julian (e.g., 1500-02-30)\n             // or dates valid only in Gregorian post-cutover.\n        }\n\n\n        // If the Julian instant is before the cutover, it's the correct instant.\n        if (julianInstant < iCutoverMillis) {\n            return julianInstant;\n        }\n\n        // If julianInstant is >= cutover, the date might be Gregorian, or in the gap.\n        // Calculate the Gregorian instant.\n        long gregorianInstant;\n        try {\n            gregorianInstant = iGregorianChronology.getDateTimeMillis(\n                year, monthOfYear, dayOfMonth,\n                hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // Gregorian calculation failed (e.g., for a date in the gap like 1582-10-10).\n            // Since the Julian calculation succeeded and yielded an instant >= cutover,\n            // this signifies the date must be in the non-existent gap.\n            throw new IllegalArgumentException(\"Specified date does not exist\", e);\n        }\n\n        // If Gregorian instant is >= cutover, it's the correct instant.\n        if (gregorianInstant >= iCutoverMillis) {\n            return gregorianInstant;\n        } else {\n            // If we get here:\n            // - Julian calculation succeeded with instant >= cutover.\n            // - Gregorian calculation succeeded with instant < cutover.\n            // This combination defines the cutover gap.\n            throw new IllegalArgumentException(\"Specified date does not exist\");\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}