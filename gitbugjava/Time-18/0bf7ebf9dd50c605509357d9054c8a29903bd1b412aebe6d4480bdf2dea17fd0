{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long instant;\n        try {\n            // First try using Gregorian chronology. This will throw an exception\n            // if the date is invalid in Gregorian (like 1500-02-29).\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // The Gregorian date calculation failed.\n            // This might be because the date is invalid in Gregorian but valid in Julian\n            // (eg. 1500-02-29), especially for dates before the cutover.\n            // Let's try the Julian chronology. If this also throws, the date is invalid in both.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // If the Julian calculation succeeded, we need to ensure the resulting instant\n            // falls *before* the cutover time. If it falls at or after the cutover,\n            // it means the date specified using components (which failed Gregorian validation)\n            // corresponds to a time instant within or after the Gregorian switch, implying\n            // it falls into the 'gap' or is otherwise inconsistent.\n            if (instant >= iCutoverMillis) {\n                // The instant calculated using Julian fields occurs after the cutover.\n                // This indicates the original date specification is invalid within GJChronology,\n                // typically falling into the cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            // If we are here, the date was invalid Gregorian, but valid Julian and falls before the cutover.\n            // So, we return the Julian instant.\n            return instant;\n        }\n\n        // The Gregorian calculation succeeded. Now, check if the resulting instant\n        // falls before the cutover. If it does, the date should actually be Julian.\n        if (instant < iCutoverMillis) {\n            // The Gregorian instant is before the cutover. This date should be treated as Julian.\n            // Recalculate using Julian chronology.\n            long julianInstant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            \n            // Sanity check: If the Julian instant is at or after the cutover,\n            // it implies the date falls within the 'gap' where dates were skipped\n            // during the Gregorian calendar adoption.\n            if (julianInstant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            // The date is valid and falls before the cutover, return the Julian instant.\n            return julianInstant;\n        } else {\n            // The Gregorian instant is at or after the cutover. This is the correct instant.\n            return instant;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}