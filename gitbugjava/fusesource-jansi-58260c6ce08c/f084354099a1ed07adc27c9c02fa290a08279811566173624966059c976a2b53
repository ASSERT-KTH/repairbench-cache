{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k; // j: offset of BEGIN_TOKEN, k: offset of END_TOKEN\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) { // No more BEGIN_TOKEN found\n                if (i == 0) { // Entire input has no tokens\n                    target.append(input);\n                    return target;\n                }\n                // Append the rest of the string\n                target.append(input.substring(i));\n                return target;\n            }\n\n            // Append text before the BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Find the END_TOKEN, starting search from position j.\n            // This allows END_TOKEN to appear like \"@|foo|@\" where \"|@\" is END_TOKEN,\n            // or even \"@||@\" where spec is empty.\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) { // No END_TOKEN found after current BEGIN_TOKEN\n                // This means an unmatched BEGIN_TOKEN.\n                // Original code appended the entire input string, which is a bug.\n                // Corrected: append the remainder of input from the start of this unmatched BEGIN_TOKEN.\n                target.append(input.substring(j));\n                return target;\n            }\n\n            // The spec string is input.substring(j + BEGIN_TOKEN_LEN, k).\n            // This requires k >= j + BEGIN_TOKEN_LEN.\n            // If k < j + BEGIN_TOKEN_LEN, it's an error indicating overlapping or invalid tokens.\n            // This was the cause of StringIndexOutOfBoundsException for inputs like \"@|@\"\n            // and is changed to throw IllegalArgumentException as per test expectations.\n            // Example: input=\"@|@\", BEGIN_TOKEN=\"@|\", END_TOKEN=\"|@\", BEGIN_TOKEN_LEN=2.\n            // j=0 (start of \"@|\"), k=1 (start of \"|@\").\n            // Condition k < j + BEGIN_TOKEN_LEN becomes 1 < 0 + 2, which is 1 < 2 (true).\n            if (k < j + BEGIN_TOKEN_LEN) {\n                throw new IllegalArgumentException(\n                        \"Invalid input: END_TOKEN at index \" + k + \" found before BEGIN_TOKEN at index \" + j +\n                        \" (length \" + BEGIN_TOKEN_LEN + \") was properly closed. Input: \\\"\" + input + \"\\\"\");\n            }\n            \n            // Extract the specification string between BEGIN_TOKEN and END_TOKEN.\n            // Original code modified j: j += BEGIN_TOKEN_LEN; then spec = input.substring(j, k);\n            // Using a new variable for specStart is clearer and avoids modifying j prematurely.\n            int specStart = j + BEGIN_TOKEN_LEN;\n            String spec = input.substring(specStart, k);\n\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            if (items.length == 1) {\n                // No CODE_TEXT_SEPARATOR found in spec, e.g. \"@|bold|@\"\n                // Original code appended the entire input string, which is a bug.\n                // Corrected: Treat the entire spec as text, with default/no codes.\n                // This calls the private helper method render(String text, String... codes).\n                String replacement = render(spec, new String[0]);\n                target.append(replacement);\n            } else { // items.length == 2, e.g. \"@|fg_red text|@\"\n                // items[0] is code part, items[1] is text part\n                String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n                target.append(replacement);\n            }\n\n            // Advance i to the position after the END_TOKEN for the next iteration\n            i = k + END_TOKEN_LEN;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}