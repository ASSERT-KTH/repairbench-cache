{
    "generation": "import java.io.IOException;\n\n// NOTE: This code assumes the existence of the following constants and methods,\n//       which are expected to be defined elsewhere in the surrounding class:\n//       - String BEGIN_TOKEN;     (e.g., \"@|\")\n//       - String END_TOKEN;       (e.g., \"|@\")\n//       - int BEGIN_TOKEN_LEN;    (e.g., BEGIN_TOKEN.length())\n//       - int END_TOKEN_LEN;      (e.g., END_TOKEN.length())\n//       - String CODE_TEXT_SEPARATOR; (e.g., \" \")\n//       - String CODE_LIST_SEPARATOR; (e.g., \",\")\n//       - String render(String text, String... codes); // The helper render method\n\npublic class AnsiRenderer { // Added dummy class for context\n\n    // Dummy constants and method for compilation and illustration\n    private static final String BEGIN_TOKEN = \"@|\";\n    private static final String END_TOKEN = \"|@\";\n    private static final int BEGIN_TOKEN_LEN = BEGIN_TOKEN.length();\n    private static final int END_TOKEN_LEN = END_TOKEN.length();\n    private static final String CODE_TEXT_SEPARATOR = \" \";\n    private static final String CODE_LIST_SEPARATOR = \",\";\n\n    private static String render(String text, String... codes) {\n        // Dummy implementation\n        return \"[\" + String.join(\",\", codes) + \"]\" + text + \"[reset]\";\n    }\n\n\n    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             if the input string has an invalid syntax.\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) {\n                // No more tokens found, append the rest of the string\n                if (i == 0) {\n                    // If no tokens were found in the entire string\n                    target.append(input);\n                } else {\n                    // Append the remaining part after the last token\n                    target.append(input.substring(i));\n                }\n                return target;\n            }\n\n            // Append text before the token\n            target.append(input.substring(i, j));\n\n            // Calculate the start position for the spec, right after the begin token\n            int specStart = j + BEGIN_TOKEN_LEN;\n\n            // Find the end token, searching *after* the begin token.\n            // This prevents finding an END_TOKEN that overlaps or precedes the spec start.\n            k = input.indexOf(END_TOKEN, specStart);\n\n            // Check if the end token was found\n            if (k == -1) {\n                // Unclosed token error\n                throw new IllegalArgumentException(\"Unclosed ANSI Renderer tag starting at index \" + j);\n            }\n\n            // Extract the spec between the tokens\n            String spec = input.substring(specStart, k);\n\n            // Split the spec into codes and text based on the first separator\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            if (items.length < 2) {\n                 // Malformed token error: The spec must contain at least one separator\n                 // to distinguish codes from the text to be rendered.\n                 // Examples of malformed specs: \"\", \"bold\", \" \" (if separator is space)\n                throw new IllegalArgumentException(\"Malformed ANSI Renderer tag '\"\n                        + spec + \"' at index \" + j + \": Missing separator '\" + CODE_TEXT_SEPARATOR + \"' separating codes from text.\");\n            }\n\n            // Render the replacement text with ANSI codes\n            // items[0] contains the codes (possibly empty), items[1] contains the text.\n            String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n\n            // Append the rendered replacement\n            target.append(replacement);\n\n            // Update the starting position for the next search, ensuring it's after the end token\n            i = k + END_TOKEN_LEN;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}