{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             If the input string has an invalid token syntax\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            // Find the start of the next BEGIN_TOKEN\n            j = input.indexOf(BEGIN_TOKEN, i);\n\n            if (j == -1) { // No more BEGIN_TOKENs found in the rest of the string\n                if (i == 0) { // No BEGIN_TOKENs were found in the entire input string\n                    target.append(input); // Append the whole input as is\n                } else {\n                    // Append the remaining part of the string after the last processed token\n                    target.append(input.substring(i));\n                }\n                return target; // Processing is complete\n            }\n\n            // Append the text segment before this BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Find the start of the corresponding END_TOKEN.\n            // Original code searched from 'j', allowing END_TOKEN to start before BEGIN_TOKEN content.\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) { // No END_TOKEN found for the current BEGIN_TOKEN (unclosed token)\n                // Original behavior: target.append(input); return target;\n                // This was buggy as it appended the entire original input, potentially duplicating prior content.\n                // Corrected behavior: Append from the start of the unclosed BEGIN_TOKEN to the end of the input.\n                target.append(input.substring(j));\n                return target; // Processing is complete as the rest is unparseable or to be treated literally.\n            }\n\n            // Validate token structure: END_TOKEN must not start before BEGIN_TOKEN's content part.\n            // The spec content is between (j + BEGIN_TOKEN_LEN) and k.\n            // So, (j + BEGIN_TOKEN_LEN) must not be greater than k.\n            // This fixes the StringIndexOutOfBoundsException for inputs like \"@|@\" and ensures\n            // an IllegalArgumentException is thrown as expected by tests like testRenderInvalidEndBeforeStart.\n            if (k < j + BEGIN_TOKEN_LEN) {\n                throw new IllegalArgumentException(\n                        \"Invalid token sequence: END_TOKEN at index \" + k +\n                        \" found before BEGIN_TOKEN (starting at \" + j + \")'s spec content could start (at index \" +\n                        (j + BEGIN_TOKEN_LEN) + \").\");\n            }\n            \n            // Update j to point to the start of the spec content, after BEGIN_TOKEN.\n            j += BEGIN_TOKEN_LEN;\n            String spec = input.substring(j, k);\n\n            // Split the spec into codes and the text_to_format.\n            // Example: spec \"bold,red Hello\" -> items[0]=\"bold,red\", items[1]=\"Hello\"\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            \n            String codesPart;\n            String textPart;\n\n            if (items.length == 1) {\n                // This means the spec did not contain the CODE_TEXT_SEPARATOR.\n                // Examples: \"@|bold|@\" (spec=\"bold\"), or \"@||@\" (spec=\"\").\n                // Original behavior: target.append(input); return target;\n                // This was buggy for the same reasons as the k == -1 case.\n                // Corrected behavior: Assume the entire spec string consists of codes,\n                // and the text_to_format is an empty string.\n                codesPart = spec; // The whole spec string is treated as codes.\n                textPart = \"\";    // Text to format is considered empty.\n            } else { // items.length == 2 (normal case, separator was found)\n                codesPart = items[0];\n                textPart = items[1];\n            }\n            \n            // Recursively call render (assuming an overload `render(String, String[])` exists)\n            // to process the extracted text part with the specified codes.\n            String replacement = render(textPart, codesPart.split(CODE_LIST_SEPARATOR));\n            target.append(replacement);\n\n            // Advance the processing index 'i' to the position right after the processed END_TOKEN.\n            i = k + END_TOKEN_LEN;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}