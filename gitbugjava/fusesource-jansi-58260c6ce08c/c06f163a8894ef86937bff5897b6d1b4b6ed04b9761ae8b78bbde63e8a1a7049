{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             If the input contains invalid Jansi markup syntax\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) { // No more BEGIN_TOKEN found\n                if (i == 0) { // Input contains no tokens at all\n                    target.append(input);\n                    return target;\n                }\n                // Append the remaining part of the string\n                target.append(input.substring(i));\n                return target;\n            }\n\n            // Append text before the BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Find the END_TOKEN starting from where BEGIN_TOKEN was found\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) {\n                // Original code appended the *entire* input here, which was incorrect.\n                // Throw an exception for unterminated markup, as it's an invalid state.\n                throw new IllegalArgumentException(\"Input contains an unterminated Jansi markup code starting at index \" + j);\n                // Alternative: append the rest literally by uncommenting below\n                // target.append(input.substring(j));\n                // return target;\n            }\n\n            int specStart = j + BEGIN_TOKEN_LEN;\n\n            // Check for invalid token structure: END_TOKEN must appear after BEGIN_TOKEN's content could start.\n            // This catches cases like \"@|@\". Here j=0, k=1, BEGIN_TOKEN_LEN=2 -> specStart=2.\n            // The condition specStart > k (2 > 1) is true, indicating an error.\n            if (specStart > k) {\n                 throw new IllegalArgumentException(\n                     \"Invalid Jansi markup syntax: END_TOKEN found immediately after BEGIN_TOKEN or Specifies zero-length token name. \" +\n                     \"Markup starting at index \" + j);\n            }\n\n            String spec = input.substring(specStart, k);\n\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            if (items.length == 1) {\n                // Original code appended the *entire* input here, which was incorrect.\n                // Missing CODE_TEXT_SEPARATOR (e.g., \"@|red|@\") indicates invalid syntax.\n                 throw new IllegalArgumentException(\n                    \"Invalid Jansi markup syntax: Missing '\" + CODE_TEXT_SEPARATOR +\n                    \"' separator in token spec '\" + spec + \"' starting at index \" + j);\n                 // Original buggy code (replaced):\n                 // target.append(input);\n                 // return target;\n            }\n\n            // Assumes a helper method render(String text, String[] codes) exists\n            // (likely another overload or private method in the same AnsiRenderer class)\n            // which takes the text and the code names to generate the ANSI sequence.\n            String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n\n            target.append(replacement);\n\n            // Move index past the processed token\n            i = k + END_TOKEN_LEN;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}