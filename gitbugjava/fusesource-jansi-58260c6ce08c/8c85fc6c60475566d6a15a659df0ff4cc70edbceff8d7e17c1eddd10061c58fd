{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             If the input string has a malformed token structure.\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) { // No more BEGIN_TOKEN found from current position i\n                if (i == 0) { // No BEGIN_TOKEN was found in the entire input string\n                    target.append(input);\n                    return target;\n                }\n                // Append the remaining part of the input string (from last processed position to end)\n                target.append(input.substring(i));\n                return target;\n            }\n\n            // BEGIN_TOKEN found at index j. Append text from current position i up to j.\n            target.append(input.substring(i, j));\n            \n            // Search for END_TOKEN. The original code searches from 'j' (start of BEGIN_TOKEN).\n            // This is important for detecting malformed cases like \"@|@\" where END_TOKEN might overlap BEGIN_TOKEN.\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) { // No END_TOKEN found for the current BEGIN_TOKEN\n                // Append the remainder of the input, starting from the current BEGIN_TOKEN.\n                // This treats the unclosed BEGIN_TOKEN and subsequent text as literal.\n                target.append(input.substring(j)); // FIXED from target.append(input)\n                return target;\n            }\n\n            // Check for malformed token structure: END_TOKEN is found too early.\n            // The content of the token is defined as input.substring(j + BEGIN_TOKEN_LEN, k).\n            // This requires that (j + BEGIN_TOKEN_LEN) <= k.\n            // If k < (j + BEGIN_TOKEN_LEN), it's an error.\n            if (k < j + BEGIN_TOKEN_LEN) { // PRIMARY FIX for the testRenderInvalidEndBeforeStart\n                throw new IllegalArgumentException(\n                    \"END_TOKEN found before BEGIN_TOKEN content. BEGIN_TOKEN started at \" + j +\n                    \", END_TOKEN found at \" + k + \", content should start at \" + (j + BEGIN_TOKEN_LEN) + \".\"\n                );\n            }\n            \n            // Advance j to point to the start of the spec string (the content between BEGIN_TOKEN and END_TOKEN)\n            j += BEGIN_TOKEN_LEN;\n            String spec = input.substring(j, k);\n\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            if (items.length == 1) {\n                // This case implies a token like \"@|code|@\" where there's no explicit text part.\n                // The original code `target.append(input); return target;` is likely a bug,\n                // as it discards previous processing and appends the entire original input.\n                // For this focused fix, this part remains as in the original buggy code.\n                target.append(input); \n                return target;\n            }\n            \n            // Recursively call render for the content, with specified codes.\n            // This assumes a private helper like: private static String render(String text, String[] codes)\n            // For Jansi, this would be AnsiRenderer.render(items[1], items[0].split(CODE_LIST_SEPARATOR))\n            String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n\n            target.append(replacement);\n\n            // Advance current position i to after the processed END_TOKEN\n            i = k + END_TOKEN_LEN;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}