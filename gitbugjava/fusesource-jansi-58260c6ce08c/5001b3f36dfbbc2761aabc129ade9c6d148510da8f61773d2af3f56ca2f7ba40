{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i); // j is the start index of BEGIN_TOKEN\n            if (j == -1) {\n                // No more BEGIN_TOKEN found in the remaining part of the input.\n                if (i == 0) {\n                    // If no BEGIN_TOKEN was ever found (i.e., we started scanning from index 0 and found nothing).\n                    // In this case, the entire input string is considered plain text.\n                    target.append(input);\n                    return target;\n                }\n                // If BEGIN_TOKENs were found and processed earlier, append the remaining plain text.\n                target.append(input.substring(i));\n                return target;\n            }\n\n            // Append the plain text segment before the current BEGIN_TOKEN.\n            target.append(input.substring(i, j));\n\n            // Search for END_TOKEN starting from the position where BEGIN_TOKEN was found.\n            k = input.indexOf(END_TOKEN, j);\n\n            // Fix for testRenderMissingEnd:\n            // If BEGIN_TOKEN is found but END_TOKEN is missing, it's an invalid format.\n            if (k == -1) {\n                throw new IllegalArgumentException(\"Missing '\" + END_TOKEN + \"' after '\" + BEGIN_TOKEN + \"' at index \" + j + \" in input: '\" + input + \"'\");\n            }\n\n            // The actual content (spec) of the ANSI sequence starts after BEGIN_TOKEN_LEN characters past j.\n            int specContentStart = j + BEGIN_TOKEN_LEN;\n\n            // Fix for testRenderInvalidEndBeforeStart:\n            // If END_TOKEN appears before the expected start of the content, it's an invalid syntax.\n            // For example, \"@||@\". BEGIN_TOKEN_LEN=2. j=0. specContentStart=2. k=1. (1 < 2) is true.\n            if (k < specContentStart) {\n                throw new IllegalArgumentException(\"Invalid Ansi spec: '\" + END_TOKEN + \"' at index \" + k + \" appears before content expected to start at index \" + specContentStart + \" for '\" + BEGIN_TOKEN + \"' at index \" + j + \" in input: '\" + input + \"'\");\n            }\n\n            // Extract the spec string, which is between the end of BEGIN_TOKEN and the start of END_TOKEN.\n            String spec = input.substring(specContentStart, k);\n\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            \n            String replacement;\n            // The logic for handling `items.length == 1` was problematic.\n            // If `CODE_TEXT_SEPARATOR` is not found, `items.length` will be 1,\n            // and `items[0]` contains the entire `spec`. In this case, the `spec`\n            // is assumed to contain only color codes, and the text to be rendered is empty.\n            if (items.length == 1) {\n                // This handles cases like \"@|bold|@\" or \"@|red;bold|@\", where \"bold\" or \"red;bold\" are codes\n                // and the text to apply them to is empty.\n                // This aligns with testRenderEmptyCodeText2 expecting \"\" for \"@|a|@\".\n                replacement = render(\"\", items[0].split(CODE_LIST_SEPARATOR));\n            } else {\n                // `items[0]` contains the color code(s), `items[1]` contains the text.\n                replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n            }\n\n            // Append the rendered replacement text to the target.\n            target.append(replacement);\n\n            // Advance the scan pointer `i` past the end of the current ANSI sequence.\n            i = k + END_TOKEN_LEN;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}