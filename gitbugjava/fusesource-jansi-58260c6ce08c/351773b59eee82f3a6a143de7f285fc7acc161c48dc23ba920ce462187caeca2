{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             if the input contains invalid Ansi-Renderer syntax.\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        // Assume these constants are defined elsewhere in the class\n        // static final String BEGIN_TOKEN = \"@|\";\n        // static final String END_TOKEN = \"|@\";\n        // static final int BEGIN_TOKEN_LEN = BEGIN_TOKEN.length();\n        // static final int END_TOKEN_LEN = END_TOKEN.length();\n        // static final String CODE_TEXT_SEPARATOR = \" \";\n        // static final String CODE_LIST_SEPARATOR = \",\";\n        // static String render(String text, String... codes) throws IllegalArgumentException; // Helper\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) { // No more BEGIN_TOKEN found\n                if (i == 0) { // Input had no tokens at all\n                    target.append(input);\n                } else { // Append the rest of the string after the last processed token\n                    target.append(input.substring(i));\n                }\n                return target; // All done\n            }\n\n            // Append the literal text part before the BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Find the END_TOKEN, starting search from the position of BEGIN_TOKEN\n            // Using 'j' as the starting point for search, as in the original code\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) {\n                // Unterminated token: Treat the BEGIN_TOKEN and subsequent text literally\n                // Append the remainder of the string starting from the BEGIN_TOKEN's position\n                target.append(input.substring(j));\n                return target; // No more processing possible\n            }\n\n            // Calculate the expected start index of the spec content (codes and text)\n            int specStart = j + BEGIN_TOKEN_LEN;\n\n            // Check for invalid markup: END_TOKEN occurs before the spec content could start\n            if (k < specStart) {\n                 throw new IllegalArgumentException(\n                         \"Invalid Jansi markup syntax: END_TOKEN found at index \" + k\n                         + \" but expected minimum start index for content is \" + specStart);\n            }\n\n            // Extract the specification string between BEGIN_TOKEN and END_TOKEN\n            String spec = input.substring(specStart, k);\n\n            // Split the spec into codes and text based on the separator\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n\n            // Check if the spec is malformed (missing the separator or empty codes part)\n            if (items.length != 2 || items[0].isEmpty()) {\n                throw new IllegalArgumentException(\n                        \"Invalid Jansi markup syntax: Malformed specification '\" + spec\n                        + \"' - expected format is 'code[,code...] text'\");\n            }\n\n            String replacement;\n            try {\n                // Call the helper render method to process codes and text\n                // This assumes the helper 'render(String, String...)' exists and works correctly\n                replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n            } catch (IllegalArgumentException e) {\n                // Catch potential errors from code lookup/processing in the helper render\n                // and wrap them in a more context-specific exception\n                throw new IllegalArgumentException(\"Invalid ANSI code specification '\" + items[0] + \"' in '\" + spec + \"': \" + e.getMessage(), e);\n            }\n\n            // Append the rendered replacement text\n            target.append(replacement);\n\n            // Continue searching for the next BEGIN_TOKEN after the current END_TOKEN\n            i = k + END_TOKEN_LEN;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}