{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             If the input string has invalid token syntax\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int currentPos = 0; // Represents 'i' in the original code\n\n        while (true) {\n            int beginTokenIdx = input.indexOf(BEGIN_TOKEN, currentPos); // Represents 'j' initially\n\n            if (beginTokenIdx == -1) { // No more BEGIN_TOKENs found\n                // Append the remainder of the input from the current position\n                target.append(input.substring(currentPos));\n                return target;\n            }\n\n            // Append the text before the BEGIN_TOKEN\n            target.append(input.substring(currentPos, beginTokenIdx));\n\n            // Search for the END_TOKEN, starting from the position of the BEGIN_TOKEN.\n            // This allows detection of END_TOKENs that might overlap BEGIN_TOKENs.\n            int endTokenIdx = input.indexOf(END_TOKEN, beginTokenIdx); // Represents 'k'\n\n            if (endTokenIdx == -1) { // No END_TOKEN found after the BEGIN_TOKEN\n                // This means the token is unclosed. Append the rest of the input as literal,\n                // including the BEGIN_TOKEN itself.\n                target.append(input.substring(beginTokenIdx));\n                return target;\n            }\n\n            // Calculate where the content (spec) inside the tokens should start\n            int specContentStartIdx = beginTokenIdx + BEGIN_TOKEN_LEN;\n\n            // Check for invalid token syntax: END_TOKEN occurs before BEGIN_TOKEN is fully parsed,\n            // or END_TOKEN overlaps with BEGIN_TOKEN making the spec content invalid.\n            // This specifically addresses the scenario like \"@|@\" for BEGIN_TOKEN=\"@|\", END_TOKEN=\"|@\"\n            if (endTokenIdx < specContentStartIdx) {\n                throw new IllegalArgumentException(\n                    \"Invalid syntax: END_TOKEN at position \" + endTokenIdx +\n                    \" found before spec content could start at \" + specContentStartIdx +\n                    \". (BEGIN_TOKEN started at \" + beginTokenIdx + \")\"\n                );\n            }\n\n            String spec = input.substring(specContentStartIdx, endTokenIdx);\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n\n            if (items.length == 1) {\n                // The spec does not conform to \"codes<SEPARATOR>text\" format.\n                throw new IllegalArgumentException(\n                    \"Invalid spec format: '\" + spec + \"'. Expected 'codes\" +\n                    CODE_TEXT_SEPARATOR + \"text'.\"\n                );\n            }\n\n            String codesString = items[0];\n            String textToRender = items[1];\n            String[] codes = codesString.split(CODE_LIST_SEPARATOR);\n\n            // Assuming AnsiRenderer.render(String, String[]) is a helper method in the same class\n            // (or a static import) that handles the actual ANSI code generation.\n            // This matches the common pattern where a public method orchestrates calls to\n            // private or overloaded helpers.\n            String replacement = AnsiRenderer.render(textToRender, codes);\n            target.append(replacement);\n\n            // Move currentPos to the position immediately after the processed END_TOKEN\n            currentPos = endTokenIdx + END_TOKEN_LEN;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}