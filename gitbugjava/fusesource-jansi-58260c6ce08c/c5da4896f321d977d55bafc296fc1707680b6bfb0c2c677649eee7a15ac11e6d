{
    "generation": "import java.io.IOException;\n\n// Assuming these constants are defined elsewhere in the class:\n// import static org.fusesource.jansi.AnsiRenderer.BEGIN_TOKEN; -> \"@|\"\n// import static org.fusesource.jansi.AnsiRenderer.END_TOKEN; -> \"|@\"\n// import static org.fusesource.jansi.AnsiRenderer.CODE_TEXT_SEPARATOR; -> \";\"\n// import static org.fusesource.jansi.AnsiRenderer.CODE_LIST_SEPARATOR; -> \",\"\n// private static final int BEGIN_TOKEN_LEN = BEGIN_TOKEN.length(); -> 2\n// private static final int END_TOKEN_LEN = END_TOKEN.length(); -> 2\n// private static String render(final String text, final String[] codes) { ... } -> Helper method\n\npublic class AnsiRenderer {\n\n    // Dummy constants and helper for compilation standalone\n    private static final String BEGIN_TOKEN = \"@|\";\n    private static final String END_TOKEN = \"|@\";\n    private static final String CODE_TEXT_SEPARATOR = \";\";\n    private static final String CODE_LIST_SEPARATOR = \",\";\n    private static final int BEGIN_TOKEN_LEN = BEGIN_TOKEN.length();\n    private static final int END_TOKEN_LEN = END_TOKEN.length();\n\n    // Dummy helper method\n    private static String render(final String text, final String[] codes) {\n        // This is just a placeholder for the actual rendering logic\n        return \"<\" + String.join(\",\", codes) + \">\" + text + \"</>\";\n    }\n\n\n    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             If the input contains invalid ansi render sequences.\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) { // No more BEGIN_TOKEN found\n                if (i == 0) { // If no BEGIN_TOKEN was ever found in the input\n                    target.append(input);\n                    return target;\n                }\n                // Append the rest of the string after the last processed token\n                target.append(input.substring(i));\n                return target;\n            }\n\n            // Append the text before the BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Find the END_TOKEN starting from the position of the BEGIN_TOKEN\n            // Searching from j is important to detect cases like \"@|@\"\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) { // No matching END_TOKEN found after BEGIN_TOKEN\n                // The original code appended the entire input, which is likely incorrect.\n                // Throwing an exception might be more appropriate for an unterminated sequence.\n                // However, to minimize changes beyond fixing the specific test, we keep the original behavior.\n                target.append(input);\n                return target;\n                // Consider: throw new IllegalArgumentException(\"Unmatched begin token '\" + BEGIN_TOKEN + \"' at position \" + j);\n            }\n\n            // Check if END_TOKEN appears immediately after or inside BEGIN_TOKEN.\n            // This catches invalid sequences like \"@|@\" where k would be less than\n            // the position immediately after BEGIN_TOKEN.\n            // For \"@|@\": j=0, k=1, BEGIN_TOKEN_LEN=2. k < j + BEGIN_TOKEN_LEN -> 1 < 0 + 2 -> true.\n            if (k < j + BEGIN_TOKEN_LEN) {\n                 throw new IllegalArgumentException(\n                         \"Invalid input: Found END_TOKEN '\" + END_TOKEN + \"' at position \" + k +\n                         \" before BEGIN_TOKEN '\" + BEGIN_TOKEN + \"' at position \" + j + \" finished.\");\n            }\n\n            // Calculate the start of the specification string (content between tokens)\n            int specStart = j + BEGIN_TOKEN_LEN;\n            String spec = input.substring(specStart, k);\n\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            if (items.length == 1) {\n                // The original code appended the entire input, which is likely incorrect.\n                // This happens if the spec doesn't contain CODE_TEXT_SEPARATOR (e.g., \"@|red|@\").\n                // Throwing an exception for malformed spec might be better.\n                // Keep original behavior to minimize changes beyond fixing the specific test.\n                target.append(input);\n                return target;\n                 // Consider: throw new IllegalArgumentException(\"Invalid specification '\" + spec + \"' found near position \" + j + \". Must contain '\" + CODE_TEXT_SEPARATOR + \"'\");\n            }\n\n            // Recursively render the text with the specified codes\n            String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n\n            target.append(replacement);\n\n            // Continue searching after the END_TOKEN\n            i = k + END_TOKEN_LEN;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}