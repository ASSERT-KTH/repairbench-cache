{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i); // j is the start index of BEGIN_TOKEN\n            if (j == -1) { // No more BEGIN_TOKENs found\n                if (i == 0) { // No BEGIN_TOKENs in the entire input\n                    target.append(input);\n                } else { // Append the rest of the input string\n                    target.append(input.substring(i));\n                }\n                return target;\n            }\n\n            // Append text before the BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Find the corresponding END_TOKEN.\n            // Search for END_TOKEN can start from j (start of BEGIN_TOKEN) to detect overlaps.\n            k = input.indexOf(END_TOKEN, j);\n\n            if (k == -1) { // No END_TOKEN found after this BEGIN_TOKEN\n                // Treat the rest of the string from this BEGIN_TOKEN as literal text.\n                // (Original code appended the entire 'input', which was a bug)\n                target.append(input.substring(j));\n                return target;\n            }\n\n            // BEGIN_TOKEN is at index j, END_TOKEN is at index k.\n            // The spec string is between the end of BEGIN_TOKEN and the start of END_TOKEN.\n            // So, spec content should start at j + BEGIN_TOKEN_LEN.\n            int specStartIndex = j + BEGIN_TOKEN_LEN;\n\n            // Check for invalid sequence: END_TOKEN occurs before BEGIN_TOKEN is fully processed,\n            // or END_TOKEN overlaps BEGIN_TOKEN in a way that there's no room for a spec.\n            // This means k (start of END_TOKEN) < specStartIndex.\n            if (k < specStartIndex) {\n                throw new IllegalArgumentException(\n                        \"Invalid token sequence: END_TOKEN at index \" + k +\n                        \" found before BEGIN_TOKEN (at \" + j + \") was fully processed. \" +\n                        \"Expected END_TOKEN at or after index \" + specStartIndex + \".\");\n            }\n\n            // Extract the specification string.\n            String spec = input.substring(specStartIndex, k);\n\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            \n            String codesValue;\n            String textValue;\n\n            if (items.length == 1) {\n                // The spec string does not contain the CODE_TEXT_SEPARATOR.\n                // This means items[0] is the codes string, and the text to render is empty.\n                // (Original code appended the entire 'input' and returned, which was a bug)\n                codesValue = items[0];\n                textValue = \"\";\n            } else { // items.length == 2 (due to the limit parameter in split)\n                codesValue = items[0];\n                textValue = items[1];\n            }\n            \n            // Recursively call render for the text part with applied codes.\n            // This assumes another `render` method overload exists: static String render(String text, String[] codes)\n            String replacement = render(textValue, codesValue.split(CODE_LIST_SEPARATOR));\n            target.append(replacement);\n\n            // Advance index i to continue parsing after the processed END_TOKEN.\n            i = k + END_TOKEN_LEN;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}