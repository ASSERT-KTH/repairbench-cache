{
    "generation": "import java.io.IOException;\nimport static org.fusesource.jansi.AnsiRenderer.*; // Assuming constants are defined here\n\n/**\n * Renders the given input to the target Appendable.\n *\n * @param input\n *            source to render\n * @param target\n *            render onto this target Appendable.\n * @return the given Appendable\n * @throws IOException\n *             If an I/O error occurs\n * @throws IllegalArgumentException\n *             If the input string has invalid markup\n */\npublic static Appendable render(final String input, Appendable target) throws IOException {\n\n    int i = 0;\n    int j, k;\n\n    while (true) {\n        // Find the beginning of the next token\n        j = input.indexOf(BEGIN_TOKEN, i);\n        // If no more tokens are found\n        if (j == -1) {\n            // If we haven't processed anything yet (i == 0), the input has no tokens\n            if (i == 0) {\n                target.append(input);\n                return target;\n            }\n            // Append the remaining text after the last token\n            target.append(input.substring(i));\n            return target;\n        }\n\n        // Append the text before the token\n        target.append(input.substring(i, j));\n\n        // Calculate the starting position for searching the end token, which is after the begin token\n        int specStart = j + BEGIN_TOKEN_LEN;\n\n        // Find the end of the token, starting the search *after* the begin token\n        k = input.indexOf(END_TOKEN, specStart);\n\n        // If the end token is not found after the start token, it's an error\n        if (k == -1) {\n            // The original code appended the entire input here, which was incorrect.\n            // Throw an exception for unterminated tokens.\n            throw new IllegalArgumentException(\"Unterminated ANSI markup token starting at index \" + j + \" in input: \" + input);\n        }\n\n        // Extract the specification between the tokens\n        String spec = input.substring(specStart, k);\n\n        // Parse the specification into codes and text\n        String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n        // If the separator is missing, the spec is invalid\n        if (items.length < 2) {\n            // The original code appended the entire input here, which was incorrect.\n            // Throw an exception for invalid specification format.\n            throw new IllegalArgumentException(\"Invalid ANSI markup specification: '\" + spec + \"' (missing separator '\" + CODE_TEXT_SEPARATOR + \"') starting at index \" + j + \" in input: \" + input);\n        }\n\n        // Render the text with the specified codes (assuming a helper render method exists)\n        String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n\n        // Append the rendered replacement text\n        target.append(replacement);\n\n        // Advance the index past the end token for the next iteration\n        i = k + END_TOKEN_LEN;\n    }\n}\n\n// Dummy helper method signature assuming it exists elsewhere in the class or is imported.\n// This method is not part of the fix but needed for the provided code to compile conceptually.\nprivate static String render(final String text, final String... codes) {\n    // Implementation would apply ANSI codes to the text\n    // For the purpose of this fix, the implementation details are not required.\n    // Example placeholder:\n    StringBuilder sb = new StringBuilder();\n    // Append ANSI codes based on 'codes' array\n    sb.append(text);\n    // Append ANSI reset code\n    return sb.toString();\n}\n\n// Assume necessary constants are defined in the class or imported, e.g.:\n// private static final String BEGIN_TOKEN = \"@|\";\n// private static final int BEGIN_TOKEN_LEN = BEGIN_TOKEN.length();\n// private static final String END_TOKEN = \"|@\";\n// private static final int END_TOKEN_LEN = END_TOKEN.length();\n// private static final String CODE_TEXT_SEPARATOR = \" \";\n// private static final String CODE_LIST_SEPARATOR = \";\";\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}