{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0;\n        int j, k;\n\n        while (true) {\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) {\n                // No more BEGIN_TOKEN found from index i onwards.\n                // Append the rest of the input and finish.\n                if (i == 0) {\n                    // No BEGIN_TOKEN found in the entire input\n                    target.append(input);\n                    return target;\n                }\n                // Append the remaining part of the input after the last processed sequence\n                target.append(input.substring(i));\n                return target;\n            }\n            \n            // Append the text before the current BEGIN_TOKEN\n            target.append(input.substring(i, j));\n            \n            // Search for the END_TOKEN. It must appear strictly after the BEGIN_TOKEN.\n            // j + BEGIN_TOKEN_LEN ensures we search *after* the BEGIN_TOKEN itself.\n            k = input.indexOf(END_TOKEN, j + BEGIN_TOKEN_LEN);\n\n            if (k == -1) {\n                // BEGIN_TOKEN was found, but no matching END_TOKEN was found afterwards.\n                // This indicates a malformed or unclosed ANSI escape sequence.\n                throw new IllegalArgumentException(\"Unclosed or malformed ANSI escape sequence at index \" + j + \" in input: '\" + input + \"'\");\n            }\n            \n            // Move 'j' to point right after the BEGIN_TOKEN, which is the start of the 'spec' string.\n            j += BEGIN_TOKEN_LEN;\n            String spec = input.substring(j, k);\n\n            String replacement;\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            \n            // The 'spec' format is generally \"codes:text\".\n            // If the separator is missing, it means either:\n            // 1. Only codes are provided (e.g., \"bold\") and text is empty.\n            // 2. The spec itself is empty (e.g., \"@||@\").\n            // If items.length is 1, it implies no separator was found.\n            if (items.length == 1) {\n                // If spec is empty (e.g., from \"@||@\"), items[0] will be empty.\n                // If spec is \"bold\" (e.g., from \"@|bold|@\"), items[0] will be \"bold\".\n                // In both cases, the text part is implicitly empty.\n                replacement = render(\"\", items[0].split(CODE_LIST_SEPARATOR));\n            } else {\n                // Standard case: \"codes:text\"\n                replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n            }\n\n            target.append(replacement);\n\n            // Move 'i' past the current END_TOKEN to continue scanning for the next sequence.\n            i = k + END_TOKEN_LEN;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}