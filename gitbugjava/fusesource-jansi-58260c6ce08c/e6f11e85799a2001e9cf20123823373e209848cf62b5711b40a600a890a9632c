{
    "generation": "    /**\n     * Renders the given input to the target Appendable.\n     *\n     * @param input\n     *            source to render\n     * @param target\n     *            render onto this target Appendable.\n     * @return the given Appendable\n     * @throws IOException\n     *             If an I/O error occurs\n     * @throws IllegalArgumentException\n     *             If the input string has invalid markup syntax\n     */\n    public static Appendable render(final String input, Appendable target) throws IOException {\n\n        int i = 0; // Current position in input string\n        int j, k; // Position of BEGIN_TOKEN and END_TOKEN\n\n        while (true) {\n            // Find the next BEGIN_TOKEN\n            j = input.indexOf(BEGIN_TOKEN, i);\n            if (j == -1) {\n                // No more BEGIN_TOKEN found, append the rest of the input\n                if (i == 0) {\n                    // If no token was ever found, append the whole input\n                    target.append(input);\n                } else {\n                    // Append the substring after the last processed token\n                    target.append(input.substring(i));\n                }\n                return target; // Processing finished\n            }\n\n            // Append the literal text part before the BEGIN_TOKEN\n            target.append(input.substring(i, j));\n\n            // Calculate where the spec content should start\n            int specStart = j + BEGIN_TOKEN_LEN;\n\n            // Find the END_TOKEN starting from the position of BEGIN_TOKEN\n            // This allows for cases like \"@|@|\", though they might be invalid depending on spec format.\n            k = input.indexOf(END_TOKEN, j);\n\n            // Check if END_TOKEN was found\n            if (k == -1) {\n                // No matching END_TOKEN found after BEGIN_TOKEN\n                throw new IllegalArgumentException(\"Missing closing token '\" + END_TOKEN + \"' after opening token at index \" + j);\n            }\n\n            // Check if the END_TOKEN appears logically after the BEGIN_TOKEN allowing for spec content.\n            // k must be >= specStart for a valid token sequence.\n            // Handles cases like \"@|@\" where END_TOKEN is found before BEGIN_TOKEN finishes.\n            if (k < specStart) {\n                 throw new IllegalArgumentException(\n                     \"Invalid token sequence: closing token '\" + END_TOKEN + \"' at index \" + k +\n                     \" found before the end of the opening token '\" + BEGIN_TOKEN + \"' starting at index \" + j);\n            }\n\n            // Extract the specification string between the tokens\n            String spec = input.substring(specStart, k);\n\n            // Process the specification\n            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);\n            // Check if the spec format is valid (must contain the separator)\n            if (items.length != 2) {\n                throw new IllegalArgumentException(\n                    \"Invalid specification format inside tokens: '\" + spec + \"' at index \" + j +\n                    \". Expected format 'code(,code)*\" + CODE_TEXT_SEPARATOR + \"text'.\");\n            }\n\n            // Render the replacement text based on the codes and the text part\n            // Assumes a helper render(String text, String... codes) method exists\n            String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));\n\n            // Append the rendered replacement\n            target.append(replacement);\n\n            // Advance the current position past the processed token\n            i = k + END_TOKEN_LEN;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}