{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // Note: `parentNode` alone is not sufficient determination for whitespace normalization handling,\n        // as the node may have been adopted. Use Element.preserveWhitespace(parentNode) instead.\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n        boolean trimLeading = false, trimTrailing = false;\n\n        if (normaliseWhite) {\n            trimLeading = (trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document;\n            trimTrailing = trimLikeBlock && nextSibling() == null;\n\n            // if this text is just whitespace, and the next node would start on a new line, skip this text:\n            Node next = nextSibling();\n            Node prev = previousSibling();\n            boolean isBlank = isBlank(); // Trigger cache\n            boolean couldSkip = false;\n            if (next instanceof Element) {\n                couldSkip = ((Element) next).shouldIndent(out); // next will indent\n            } else if (next instanceof TextNode) {\n                couldSkip = ((TextNode) next).isBlank(); // next is blank text, sibling combiner considerations\n            } else if (next == null && parentNode instanceof Document) {\n                couldSkip = true; // Trimming outer document trailing space\n            }\n\n            // Previously tested `|| (prev instanceof Element && ((Element) prev).isBlock())` - but isBlock includes <br>\n            // which is not desired in this case. See https://github.com/jhy/jsoup/issues/1916\n\n            // Add specific check for blank node after <br>\n            // https://github.com/jhy/jsoup/issues/1447\n            if (!couldSkip && isNode(prev, \"br\") && !TextNode.lastCharIsWhitespace(accum)) {\n                // If the previous node was a <br>, and the accumulating buffer doesn't end in whitespace,\n                // we are pretty printing and this node is blank - so skip it. Avoids double indent.\n                couldSkip = true;\n            }\n\n            if (couldSkip && isBlank) return; // skip this text node\n\n            // Originally had `|| (siblingIndex > 0 && isNode(prev, \"br\"))` in indent check - moved that logic into the couldSkip check above\n            if (\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) || // first node in format-as-block, and not blank\n                (out.outline() && (siblingNodes().size() > 0 || parentIsBlock(parent)) && !isBlank) // outline mode, and not blank\n            ) {\n                indent(accum, depth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n\n    // Helper method to check parent type and nullity\n    private boolean parentIsBlock(Element parent) {\n        return parent != null && parent.tag().isBlock();\n    }\n\n    // Helper copied from Node for context\n    private static boolean isNode(Node node, String name) {\n        return node != null && node.nodeName().equals(name);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}