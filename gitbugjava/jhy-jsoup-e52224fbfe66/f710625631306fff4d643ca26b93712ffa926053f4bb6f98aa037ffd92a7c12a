{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // Element.preserveWhitespace handles parentNode == null (treats as not preserving whitespace).\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        if (normaliseWhite) {\n            final boolean isBlank = isBlank(); // Cache isBlank() result\n            final Node prev = previousSibling();\n            final Node next = nextSibling();\n\n            // Section 1: Determine if this TextNode should be skipped entirely.\n            // This applies only if the text node is blank.\n            if (isBlank) {\n                // Conditions for skipping a blank text node:\n                boolean nextWillIndent = (next instanceof Element && ((Element) next).shouldIndent(out));\n                boolean nextIsBlankText = (next instanceof TextNode && ((TextNode) next).isBlank());\n                boolean prevIsBlock = (prev instanceof Element && ((Element) prev).isBlock());\n                boolean prevIsBr = isNode(prev, \"br\"); // isNode handles null prev correctly.\n\n                // If any of these conditions are met, this blank text node is considered redundant for pretty printing.\n                if (nextWillIndent || nextIsBlankText || prevIsBlock || prevIsBr) {\n                    return; // Skip this blank text node.\n                }\n            }\n\n            // Section 2: If not skipped, determine indentation for this TextNode.\n            // This section is reached if isBlank is false, or if isBlank is true but the node was not deemed skippable.\n            boolean indentText = false;\n            final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n\n            // Original indentation conditions, with refinement for the <br> case:\n            if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank)) {\n                // First node in a block container, and not blank.\n                indentText = true;\n            } else if ((out.outline() && siblingNodes().size() > 0 && !isBlank)) {\n                // Outline mode, and not blank.\n                indentText = true;\n            } else if ((isNode(prev, \"br\") && !isBlank)) {\n                // Follows a <br> tag, and this text node is not blank.\n                // If it were blank and prevIsBr, it would have been skipped by the logic in Section 1.\n                indentText = true;\n            }\n\n            if (indentText) {\n                indent(accum, depth, out);\n            }\n\n            // Section 3: Determine trimming settings and emit the text.\n            // These variables were calculated earlier in the original code but are only needed if the node is not skipped.\n            final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n            boolean trimLeading = (trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document;\n            boolean trimTrailing = trimLikeBlock && next == null; // Use cached 'next'\n\n            Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n\n        } else {\n            // Not normalising whitespace (e.g., in <pre> or if prettyPrint is false), print text as is.\n            Entities.escape(accum, coreValue(), out, false, false, false, false);\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}