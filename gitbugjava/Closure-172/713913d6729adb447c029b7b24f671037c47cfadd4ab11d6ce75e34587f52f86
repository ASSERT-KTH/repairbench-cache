{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      // However, assignments to the prototype property of variables\n      // that are not constructors/interfaces (like function parameters\n      // typed as {Object}) should be inferred. See b/5887044.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          Node lhs = n.getFirstChild(); // Get LHS of assignment (e.g., a.prototype)\n          // Only consider it a declaration if the base (e.g., 'a') is a known\n          // constructor or interface.\n          boolean definitelyDeclaration = false;\n          if (lhs != null && lhs.isGetProp()) { // Ensure LHS is like base.prototype\n              Node base = lhs.getFirstChild();\n              if (base != null) { // Ensure base exists\n                  JSType baseType = base.getJSType();\n                  // If we don't know the type, or it's not a function type,\n                  // it's unlikely to be a constructor/interface declaration.\n                  if (baseType != null && baseType.isFunctionType()) {\n                      FunctionType fnType = baseType.toMaybeFunctionType();\n                      // Check if the base function type is explicitly a constructor or interface\n                      if (fnType != null && (fnType.isConstructor() || fnType.isInterface())) {\n                          definitelyDeclaration = true;\n                      }\n                  }\n              }\n          }\n          // If we determined it's definitely a prototype declaration on a Ctor/Interface, return false (declared)\n          if (definitelyDeclaration) {\n              return false;\n          }\n          // Otherwise (e.g., base is not Ctor/Interface, base type unknown, or LHS isn't simple base.prototype),\n          // let subsequent logic decide based on JSDoc, RHS value etc.\n      }\n\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        // Function literal assigned to a qualified name.\n\n        // Explore edge cases where FUNCTIONs should be inferred.\n        // 1) The coding convention suggests that FUNCTION properties should\n        //    always be declared with JSDoc. Check for JSDoc->declared.\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            // Make sure this isn't an inner function reference.\n            // We use isUnscopedQualifiedName to ignore functions that are part\n            // of an object literal: { V: function() {} }\n            // NOTE(nicksantos): This is smelly. Let's remove it.\n            // TODO(nicksantos): Maybe use scope.isLocal instead?\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          // This doesn't work very well with AstFunctionContents, because\n          // AstFunctionContents isn't specific to the scope where this qname is\n          // first defined. For example, if you have:\n          // var goog = {}; goog.foo = function() {}; function f() { goog.foo = 3; }\n          // Then the qname goog.foo will escape f, and this heuristic will\n          // treat the function literal assignment as declared, even though we\n          // don't want it to be.\n          // TODO(nicksantos): Fix this. This isInferrable qualifies names as\n          // escaping when they shouldn't.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}