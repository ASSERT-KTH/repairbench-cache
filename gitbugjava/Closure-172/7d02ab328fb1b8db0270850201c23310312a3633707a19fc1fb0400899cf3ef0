{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true; // Inferred if no type info for RHS\n      }\n\n      // 1. Check JSDoc for explicit declaration info\n      if (info != null) {\n        boolean isDeclaredByJsDoc = info.hasType()\n            || info.hasEnumParameterType()\n            // Note: A @const property with an unknown type is inferred.\n            || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info);\n        if (isDeclaredByJsDoc) {\n            return false; // Declared by JSDoc\n        }\n        // If JSDoc exists but doesn't declare it, it remains potentially inferred.\n        // We might still override below if it's Ctor.prototype.\n      }\n\n      // 2. Check for prototype assignment\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          Node baseNode = null;\n          // Need the LHS of the assignment or the object in the GETPROP\n          Node nodeToCheck = n;\n          // If n is the ASSIGN node, check its LHS.\n          if (n.isAssign()) {\n              nodeToCheck = n.getFirstChild();\n          }\n\n          // Ensure the node represents a GETPROP '.prototype'\n          if (nodeToCheck != null && nodeToCheck.isGetProp() && \"prototype\".equals(nodeToCheck.getString())) {\n              baseNode = nodeToCheck.getFirstChild();\n          }\n\n          if (baseNode != null) {\n              JSType baseType = baseNode.getJSType();\n              if (baseType != null) {\n                   baseType = baseType.restrictByNotNullOrUndefined();\n                   // If the base IS a constructor or interface, it's declared.\n                   if (!baseType.isUnknownType() && !baseType.isAllType() &&\n                       (baseType.isConstructor() || baseType.isInterface())) {\n                        // Even if non-declaring JSDoc was present, this rule takes precedence.\n                        return false; // Declared\n                   } else {\n                       // If the base is NOT a constructor/interface (e.g. Object, Function, unknown),\n                       // then assignment to its 'prototype' property is INFERRED.\n                       return true; // Inferred because it's obj.prototype where obj isn't Ctor/Interface\n                   }\n              }\n          }\n          // If we couldn't determine base type, or it wasn't a '.prototype' GETPROP, fall through.\n      }\n\n      // 3. Apply heuristics for function assignments (if not handled by prototype case, and no JSDoc info)\n      boolean inferred = true; // Default assumption if not declared by JSDoc or Ctor.prototype\n      if (info == null && rhsValue != null && rhsValue.isFunction()) {\n            // Check if this looks like the first declaration in the scope\n            // TODO(nicksantos): This isQualifiedName check is imprecise.\n            // We should move this into the typed scope creator.\n            if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n\n                // Functions assigned in conditional blocks are inferred.\n                for (Node current = n.getParent();\n                     current != null && !(current.isScript() || current.isFunction());\n                     current = current.getParent()) {\n                   if (NodeUtil.isControlStructure(current)) {\n                     return true; // Inferred (conditional assignment)\n                   }\n                }\n\n                // Functions assigned locally (not escaped) in the top level\n                // of a function/script are potentially declarations.\n                AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n                if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n                    // Not escaped from root scope => treat as declared\n                    inferred = false; // Declared by function heuristic\n                }\n                // else: escaped, remains inferred=true\n            }\n            // else: already declared or scoped name, remains inferred=true\n            // (Modifying an existing function is inferred)\n      }\n\n      // 4. Final result\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}