{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          // Check the type of the object whose prototype is being assigned.\n          // n is typically the ASSIGN or VAR node.\n          Node lvalue = n.getFirstChild();\n          if (lvalue != null && lvalue.isGetProp()) {\n              Node baseNode = lvalue.getFirstChild();\n              // We need the type of the base object (e.g., 'a' in 'a.prototype = ...').\n              // Get the type from the node itself. This might be null if type\n              // information isn't available yet, in which case we'll fall through.\n              JSType baseType = baseNode.getJSType();\n\n              // If the base type is known to be a constructor or interface,\n              // then assignment to its prototype is a declaration.\n              if (baseType != null && (baseType.isConstructor() || baseType.isInterface())) {\n                  return false; // Declared\n              }\n              // Otherwise (e.g., baseType is Object, null, or unknown),\n              // treat it like a regular property assignment and let the logic below decide.\n          }\n          // Fall through if not a GETPROP or baseType doesn't indicate constructor/interface.\n      }\n\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      // This part handles function assignments without explicit types.\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          // Function expression with JSDoc is considered declared.\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            // TODO(b/165992817): Understand why this uses `n` instead of the lvalue node.\n            // If n is ASSIGN, n.isUnscopedQualifiedName() is always false.\n            // This whole block might be ineffective for assignments.\n            // For now, preserving original logic, though it seems suspect for assignments.\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               current != null && !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          // getFunctionAnalysisResults might not be available if not run.\n          AstFunctionContents contents = null;\n          Node scopeRoot = scope.getRootNode();\n          if (scopeRoot.isFunction()) {\n            contents = getFunctionAnalysisResults(scopeRoot);\n          }\n          // If we don't have analysis results, or the name isn't escaped,\n          // treat it as declared.\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false; // Treat as declared\n          }\n          // Otherwise (escaped), it remains inferred. Return true below.\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}