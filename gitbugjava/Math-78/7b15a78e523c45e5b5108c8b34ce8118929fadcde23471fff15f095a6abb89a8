{
    "generation": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n\n            // Prepare the function object outside the loop for clarity, but it needs the interpolator state\n            final UnivariateRealFunction f = new UnivariateRealFunction() {\n                public double value(final double t) throws FunctionEvaluationException {\n                    try {\n                        interpolator.setInterpolatedTime(t);\n                        return handler.g(t, interpolator.getInterpolatedState());\n                    } catch (DerivativeException e) {\n                        // Wrap DerivativeException for FunctionEvaluationException compatibility\n                        throw new FunctionEvaluationException(e, t);\n                    } catch (EventException e) {\n                        // Wrap EventException for FunctionEvaluationException compatibility\n                        throw new FunctionEvaluationException(e, t);\n                    }\n                }\n            };\n\n            for (int i = 0; i < n; ++i) {\n\n                // Step endpoint and value\n                final double tb = ta + h;\n                final double gb = f.value(tb); // Evaluate using the function wrapper, handles exceptions\n\n                // Check for potential event crossing using the sign before the step (g0Positive)\n                // and the sign at the end of the sub-step (gb).\n                if (g0Positive ^ (gb >= 0)) {\n\n                    // Define interval endpoints for the solver, possibly adjusting if ga or gb is zero.\n                    double solverTa = ta;\n                    double solverTb = tb;\n                    double solverGa = ga;\n                    double solverGb = gb;\n\n                    boolean skipSolver = false; // Flag to skip solver call if interval is invalid or root is at endpoint\n\n                    // Adjust ta if ga == 0 to avoid BrentSolver precondition violation f(a)*f(b) < 0\n                    if (ga == 0.0) {\n                        // Shift ta slightly into the interval away from the root\n                        // Use a shift relative to convergence or ULP, ensuring it's non-zero\n                        double shift = Math.max(convergence * 1.0e-2, Math.ulp(ta));\n                        if (!forward) {\n                            shift = -shift; // Shift appropriately for backward integration\n                        }\n                        solverTa = ta + shift;\n                        // Handle cases where ta=0 or shift doesn't change ta numerically\n                        if (solverTa == ta) {\n                            solverTa = ta + (forward ? convergence * 1.0e-2 : -convergence * 1.0e-2); // Fallback shift\n                        }\n                        try {\n                           solverGa = f.value(solverTa); // Re-evaluate function at shifted start\n                        } catch (FunctionEvaluationException fee) {\n                             // If evaluation fails at shifted point, rethrow wrapped exception\n                             final Throwable cause = fee.getCause();\n                             if ((cause != null) && (cause instanceof DerivativeException)) throw (DerivativeException) cause;\n                             if ((cause != null) && (cause instanceof EventException))    throw (EventException) cause;\n                             throw new EventException(fee);\n                        }\n                    }\n\n                    // Adjust tb if gb == 0\n                    if (gb == 0.0) {\n                        // Shift tb slightly into the interval away from the root\n                        double shift = Math.max(convergence * 1.0e-2, Math.ulp(tb));\n                        if (forward) {\n                            shift = -shift; // Shift back towards ta\n                        }\n                        solverTb = tb + shift;\n                        // Handle cases where tb=0 or shift doesn't change tb numerically\n                        if (solverTb == tb) {\n                             solverTb = tb + (forward ? -convergence * 1.0e-2 : convergence * 1.0e-2); // Fallback shift\n                        }\n                         try {\n                            solverGb = f.value(solverTb); // Re-evaluate function at shifted end\n                         } catch (FunctionEvaluationException fee) {\n                             final Throwable cause = fee.getCause();\n                             if ((cause != null) && (cause instanceof DerivativeException)) throw (DerivativeException) cause;\n                             if ((cause != null) && (cause instanceof EventException))    throw (EventException) cause;\n                             throw new EventException(fee);\n                         }\n                    }\n\n                    // Check if the adjusted interval is valid for Brent's requirement (f(a)*f(b) < 0)\n                    if (solverGa * solverGb >= 0) {\n                        // Even after adjustments, signs are not strictly opposite.\n                        // This implies the root is likely exactly at the original ta or tb,\n                        // or the g0Positive check indicated a crossing incorrectly (corner case).\n\n                        if (ga == 0.0) { // Check if original start was the root\n                            if (!isSameEvent(ta, previousEventTime, convergence)) {\n                                // Root is at ta, and it's a new event\n                                pendingEventTime = ta;\n                                if (pendingEvent && isSameEvent(t1, pendingEventTime, convergence)) return false; // Accept step\n                                pendingEvent = true; return true; // Reject step\n                            }\n                            // else: ta is previous event, ignore and continue search in next sub-interval\n                            skipSolver = true;\n                        } else if (gb == 0.0) { // Check if original end was the root\n                             if (!isSameEvent(tb, previousEventTime, convergence)) {\n                                 // Root is at tb, and it's a new event\n                                pendingEventTime = tb;\n                                if (pendingEvent && isSameEvent(t1, pendingEventTime, convergence)) return false; // Accept step\n                                pendingEvent = true; return true; // Reject step\n                             }\n                             // else: tb is previous event, ignore and continue search\n                             skipSolver = true;\n                        } else {\n                            // Signs are the same and non-zero. Indicates g0Positive check was misleading\n                            // or root is very close to ta/previousEventTime. Skip this interval.\n                            skipSolver = true;\n                        }\n                    }\n\n\n                    if (!skipSolver) {\n                        // We have a valid interval [solverTa, solverTb] where solverGa * solverGb < 0.\n                        increasing = gb >= ga; // Base slope on original interval points for consistency\n\n                        final BrentSolver solver = new BrentSolver();\n                        solver.setAbsoluteAccuracy(convergence);\n                        solver.setMaximalIterationCount(maxIterationCount);\n\n                        final double root = (solverTa <= solverTb) ?\n                                            solver.solve(f, solverTa, solverTb) :\n                                            solver.solve(f, solverTb, solverTa);\n\n                        // Check if the found root is distinct from the previous event\n                        if (!isSameEvent(root, previousEventTime, convergence)) {\n                            pendingEventTime = root;\n                            if (pendingEvent && isSameEvent(t1, pendingEventTime, convergence)) {\n                                // We were waiting for this event, and the step ends exactly there. Accept it.\n                                return false;\n                            }\n                            // Otherwise, this is a new event, or a pending event that the step doesn't end at. Reject.\n                            pendingEvent = true;\n                            return true;\n                        }\n                        // else: root is same as previous event, ignore it and continue search.\n                    }\n                    // else: solver was skipped for this sub-interval.\n\n                } // End of potential event handling `if (g0Positive ^ (gb >= 0))`\n\n                // Update state for next sub-interval\n                ta = tb;\n                ga = gb;\n\n            } // End of loop through sub-intervals\n\n            // No event detected during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            // Handle exceptions potentially thrown by f.value() or solver.solve()\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            // Wrap other FunctionEvaluationExceptions (e.g., from underlying g() or solver convergence)\n            throw new EventException(e);\n        } catch (ConvergenceException e) {\n            // Re-throw ConvergenceException directly (can be thrown by solver)\n            throw e;\n        }\n    }\n\n     /** Check if two event times are the same within a tolerance. Handles NaN. */\n    private boolean isSameEvent(double t1, double t2, double tolerance) {\n       // Check for NaN first is safer\n       if (Double.isNaN(t1) || Double.isNaN(t2)) {\n           return false;\n       }\n       return Math.abs(t1 - t2) <= tolerance;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}