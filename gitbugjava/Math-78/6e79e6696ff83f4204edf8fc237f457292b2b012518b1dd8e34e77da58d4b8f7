{
    "generation": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            // Prevent divisions by zero if step size is zero for any reason\n             final double dt = t1 - t0;\n             if (Math.abs(dt) < convergence) {\n                  // we cannot do anything on such a small step, don't trigger any events\n                  return false;\n             }\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(dt) / maxCheckInterval));\n            final double h  = dt / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0; // Initialize tb = ta before the loop\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb = ta + h; // tb is the end of the sub-interval [ta, tb]\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence using the sign at the start of the main step (g0Positive)\n                // and the sign at the end of the sub-step (gb).\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change detected between t0 and tb:\n                    // an event is expected to lie in the sub-interval [ta, tb].\n\n                    // variation direction, with respect to the integration direction (using ga at ta, gb at tb)\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n\n                    // Determine solver interval [left, right] ensuring left <= right\n                    double left = Math.min(ta, tb);\n                    double right = Math.max(ta, tb);\n\n                    // Evaluate function at base interval endpoints\n                    double fa = f.value(left);\n                    double fb = f.value(right);\n\n                    // Adjust interval endpoints if function is zero at the endpoint to avoid BrentSolver exception\n                    // The BrentSolver requires f(left) * f(right) < 0.\n                    if (fa == 0.0) {\n                        // Shift left endpoint slightly into the interval (towards right)\n                        // Use a fraction of convergence, ensuring the shift has the correct sign relative to interval width\n                        left += convergence * 0.1 * Math.signum(right - left);\n                        fa = f.value(left); // Re-evaluate fa\n                    }\n                    if (fb == 0.0) {\n                        // Shift right endpoint slightly into the interval (towards left)\n                        // Use a fraction of convergence, ensuring the shift has the correct sign relative to interval width\n                        right -= convergence * 0.1 * Math.signum(right - left);\n                        fb = f.value(right); // Re-evaluate fb\n                    }\n\n                    // Check bracketing condition again after potential adjustment\n                    if (fa * fb >= 0) {\n                         // Bracketing failed even after adjustment.\n                         // This should not happen in tests like closeEvents,\n                         // but indicates a possibly complex root situation (e.g. tangency).\n                         throw new ConvergenceException(\n                                \"Event detection failed: function values at endpoints do not have different signs\" +\n                                \" after potential adjustment for zero values.\" +\n                                \" Endpoints: [\" + left + \", \" + right + \"], Values: [\" + fa + \", \" + fb + \"]\");\n                    }\n\n                    // Solve for the root in the adjusted interval [left, right]\n                    final double root = solver.solve(f, left, right);\n\n                    // Check if the found root is too close to the start of the interval (ta) AND the previous event\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have found (again) the previous event at the start of the interval, ignore it\n                        // Continue search from tb. Update ta, ga for the next iteration.\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        // Found a new distinct event.\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // We were already waiting for this event, and the step ends on it. Accept step.\n                            return false;\n                        }\n                        // New event detected within the step, or pending event moved. Reject step.\n                        pendingEvent = true;\n                        return true;\n                    } else {\n                        // Root is close to previousEventTime but not close to ta.\n                        // This means we re-found the previous event further inside the interval. Ignore it.\n                        // Continue search from tb. Update ta, ga for the next iteration.\n                        ta = tb;\n                        ga = gb;\n                   }\n                   // If we reached here, the event was ignored, loop continues with updated ta/ga.\n\n                } else {\n                    // no sign change detected between t0 and tb: continue search\n                    ta = tb;\n                    ga = gb;\n                }\n\n            } // End of loop over sub-steps n\n\n            // No event detected during the whole step, or all detected events were ignored\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false; // Accept step\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            // Wrap raw FunctionEvaluationException in EventException\n             // ConvergenceException thrown above is not caught here.\n             throw new EventException(e);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}