{
    "generation": "import org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\n\n// Add dummy classes and methods needed for compilation if they are not available in the context.\n// These are just placeholders.\n// class Position {\n//     public static final String KEY_SATELLITES = \"sat\";\n//     public static final String KEY_HDOP = \"hdop\";\n//     public static final String KEY_VDOP = \"vdop\";\n//     public static final String KEY_ODOMETER = \"odometer\";\n//     public static final String KEY_HOURS = \"hours\";\n//     public static final String KEY_POWER = \"power\";\n//     public static final String KEY_BATTERY = \"battery\";\n//     public static final String PREFIX_ADC = \"adc\";\n//     public static final String KEY_STATUS = \"status\";\n//     public static final String KEY_IGNITION = \"ignition\";\n//     public static final String PREFIX_IN = \"in\";\n//     public static final String PREFIX_OUT = \"out\";\n//     public static final String KEY_GEOFENCE = \"geofence\";\n//     public static final String KEY_DRIVER_UNIQUE_ID = \"driverUniqueId\";\n//     public static final String PREFIX_TEMP = \"temp\";\n//     public static final String KEY_EVENT = \"event\"; // Added based on usage in test case\n\n//     public void setValid(boolean valid) {}\n//     public void set(String key, Object value) {}\n//     public void setLatitude(double latitude) {}\n//     public double getLatitude() { return 0.0; }\n//     public void setLongitude(double longitude) {}\n//     public double getLongitude() { return 0.0; }\n//     public void setSpeed(double speed) {}\n//     public void setCourse(double course) {}\n//     public void setAltitude(double altitude) {}\n//     public void setNetwork(Network network) {}\n// }\n\n// class Network {\n//     public Network(CellTower cellTower) {}\n// }\n\n// class CellTower {\n//     public static CellTower from(int mcc, int mnc, int lac, int cid, int rssi) { return new CellTower(); }\n// }\n\n// class UnitsConverter {\n//     public static double knotsFromKph(double kph) { return kph / 1.852; }\n// }\n\n// class BitUtil {\n//     public static boolean check(int number, int index) { return (number & (1 << index)) != 0; }\n// }\n\n\npublic class GoSafeProtocolDecoder { // Changed class name for isolation\n\n    private void decodeFragment(Position position, String fragment) {\n\n        int dataIndex = fragment.indexOf(':');\n        if (dataIndex == -1 || dataIndex + 1 > fragment.length()) {\n             return; // Invalid fragment format\n        }\n        int index = 0;\n        String[] values;\n        if (fragment.length() == dataIndex + 1) {\n            values = new String[0];\n        } else {\n            // Use split with -1 limit to keep trailing empty strings\n            values = fragment.substring(dataIndex + 1).split(\";\", -1);\n        }\n\n        String type = fragment.substring(0, dataIndex);\n\n        try { // Add a general try-catch block for safety during parsing\n            switch (type) {\n                case \"GPS\":\n                    // Field 0: Validity\n                    if (index < values.length) {\n                        position.setValid(values[index].equals(\"A\"));\n                    }\n                    index++;\n                    // Field 1: Satellites\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_SATELLITES, Integer.parseInt(values[index]));\n                    }\n                    index++;\n                    // Field 2: Latitude (e.g., N31.551856)\n                    if (index < values.length && values[index].length() > 1) {\n                        double latitude = Double.parseDouble(values[index].substring(1));\n                        if (values[index].charAt(0) == 'S') {\n                            latitude = -latitude;\n                        }\n                        position.setLatitude(latitude);\n                    }\n                    index++;\n                    // Field 3: Longitude (e.g., E74.366920)\n                    if (index < values.length && values[index].length() > 1) {\n                        double longitude = Double.parseDouble(values[index].substring(1));\n                        if (values[index].charAt(0) == 'W') {\n                            longitude = -longitude;\n                        }\n                        position.setLongitude(longitude);\n                    }\n                    index++;\n                    // Field 4: Speed (Kph)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(values[index])));\n                    }\n                    index++;\n                    // Field 5: Course\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.setCourse(Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    // Field 6: Altitude\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.setAltitude(Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    // Field 7: HDOP\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_HDOP, Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    // Field 8: VDOP\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_VDOP, Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    break;\n                case \"GSM\":\n                    index++; // Skip registration status (field 0)\n                    index++; // Skip signal strength (field 1)\n                    // Fields 2-6: Network Info (MCC, MNC, LAC, CID, RSSI)\n                    if (index + 4 < values.length // Check if all 5 required fields exist\n                            && !values[index].isEmpty() && !values[index + 1].isEmpty()\n                            && !values[index + 2].isEmpty() && !values[index + 3].isEmpty()\n                            && !values[index + 4].isEmpty()) {\n                        try {\n                            int mcc = Integer.parseInt(values[index]);\n                            int mnc = Integer.parseInt(values[index + 1]);\n                            int lac = Integer.parseInt(values[index + 2], 16);\n                            int cid = Integer.parseInt(values[index + 3], 16);\n                            int rssi = Integer.parseInt(values[index + 4]);\n                            position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid, rssi)));\n                        } catch (NumberFormatException e) {\n                            // Ignore invalid network data - log warning?\n                        }\n                    }\n                    index += 5; // Increment index by 5 (fields 2, 3, 4, 5, 6)\n                    break;\n                case \"COT\":\n                    // Field 0: Odometer\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_ODOMETER, Long.parseLong(values[index]));\n                    }\n                    index++;\n                    // Field 1: Hours (H-M-S)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        String[] hours = values[index].split(\"-\");\n                        long hoursValue = 0;\n                        if (hours.length > 0 && !hours[0].isEmpty()) {\n                            hoursValue += Integer.parseInt(hours[0]) * 3600L;\n                        }\n                        if (hours.length > 1 && !hours[1].isEmpty()) {\n                            hoursValue += Integer.parseInt(hours[1]) * 60L;\n                        }\n                        if (hours.length > 2 && !hours[2].isEmpty()) {\n                            hoursValue += Integer.parseInt(hours[2]);\n                        }\n                        position.set(Position.KEY_HOURS, hoursValue * 1000); // Store as milliseconds\n                    }\n                    index++;\n                    break;\n                case \"ADC\":\n                    // Field 0: Power\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_POWER, Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    // Field 1: Battery\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_BATTERY, Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    // Field 2: ADC1\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.PREFIX_ADC + 1, Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    // Field 3: ADC2\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.PREFIX_ADC + 2, Double.parseDouble(values[index]));\n                    }\n                    index++;\n                    break;\n                case \"DTT\":\n                    // Field 0: Status (Hex)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(Position.KEY_STATUS, Integer.parseInt(values[index], 16));\n                    }\n                    index++;\n                    // Field 1: IO (Hex)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        int io = Integer.parseInt(values[index], 16);\n                        position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                        position.set(Position.PREFIX_IN + 1, BitUtil.check(io, 1));\n                        position.set(Position.PREFIX_IN + 2, BitUtil.check(io, 2));\n                        position.set(Position.PREFIX_IN + 3, BitUtil.check(io, 3));\n                        position.set(Position.PREFIX_IN + 4, BitUtil.check(io, 4));\n                        position.set(Position.PREFIX_OUT + 1, BitUtil.check(io, 5));\n                        position.set(Position.PREFIX_OUT + 2, BitUtil.check(io, 6));\n                        position.set(Position.PREFIX_OUT + 3, BitUtil.check(io, 7));\n                    }\n                    index++;\n                    // Field 2 & 3: Geofence\n                    String geofence = \"\";\n                    if (index < values.length) {\n                        geofence += values[index];\n                    }\n                    index++;\n                    if (index < values.length) {\n                        geofence += values[index];\n                    }\n                    index++;\n                    if (!geofence.isEmpty()) {\n                         position.set(Position.KEY_GEOFENCE, geofence);\n                    }\n                    // Field 4: Event Status\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(\"eventStatus\", values[index]);\n                    }\n                    index++;\n                    // Field 5: Packet Type\n                    if (index < values.length && !values[index].isEmpty()) {\n                        position.set(\"packetType\", values[index]);\n                    }\n                    index++;\n                    break;\n                case \"ETD\":\n                    if (index < values.length) {\n                        position.set(\"eventData\", values[index]);\n                    }\n                    index++;\n                    break;\n                case \"OBD\":\n                    if (index < values.length) {\n                        position.set(\"obd\", values[index]);\n                    }\n                    index++;\n                    break;\n                case \"TAG\":\n                    if (index < values.length) {\n                        position.set(\"tagData\", values[index]);\n                    }\n                    index++;\n                    break;\n                case \"IWD\": // Wireless Accessory Data\n                     while (index + 2 < values.length) { // Need at least index, type, and value(s)\n                        String sensorIndexStr = values[index];\n                        String dataTypeStr = values[index + 1];\n\n                        if (sensorIndexStr.isEmpty() || dataTypeStr.isEmpty()) {\n                            index += 2; // Skip incomplete index/type pair\n                            // Attempt to skip potential value field(s) - highly uncertain\n                            if (index < values.length) {\n                                index++;\n                            }\n                            continue;\n                        }\n\n                        try {\n                            int sensorIndex = Integer.parseInt(sensorIndexStr);\n                            int dataType = Integer.parseInt(dataTypeStr);\n                            index += 2; // Consume sensorIndex and dataType\n\n                            if (dataType == 0) { // Driver ID\n                                if (index < values.length && !values[index].isEmpty()) {\n                                    position.set(Position.KEY_DRIVER_UNIQUE_ID, values[index]);\n                                }\n                                index++; // Consume driver ID\n                            } else if (dataType == 1) { // Temperature\n                                // Format: SensorIndex;1;SerialNumber;TemperatureValue\n                                if (index + 1 < values.length) { // Need serial number and temperature value\n                                    index++; // Skip temperature sensor serial number (values[index])\n                                    if (!values[index].isEmpty()) { // Check temperature value\n                                        position.set(Position.PREFIX_TEMP + sensorIndex, Double.parseDouble(values[index]));\n                                    }\n                                    index++; // Consume temperature value\n                                } else {\n                                    // Not enough fields for temperature data type\n                                    break; // Exit loop as data seems truncated/malformed\n                                }\n                            } else {\n                                // Unknown data type, assume 1 value field to skip\n                                if (index < values.length) {\n                                    index++;\n                                }\n                            }\n                        } catch (NumberFormatException e) {\n                            // Failed parsing sensorIndex or dataType, data is likely corrupt\n                            break; // Exit loop\n                        }\n                    }\n                    break;\n                default:\n                    // Log unknown fragment type?\n                    break;\n            }\n        } catch (Exception e) {\n            // Log error or handle potential parsing issues gracefully\n            // For now, just catching to prevent crashes on unexpected data\n            // Consider logging e\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}