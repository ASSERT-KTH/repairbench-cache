{
    "generation": "import org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\n\n// Add other necessary imports here if needed, e.g.:\n// import org.slf4j.Logger;\n// import org.slf4j.LoggerFactory;\n\n// Assume the class containing this method exists\n\n    // private static final Logger Log = LoggerFactory.getLogger(GoSafeProtocolDecoder.class); // Optional: for logging errors\n\n    private void decodeFragment(Position position, String fragment) {\n\n        int dataIndex = fragment.indexOf(':');\n        if (dataIndex < 0) { // No colon found, invalid fragment format\n            // Log.warn(\"Invalid fragment format (no colon): \" + fragment); // Optional logging\n            return;\n        }\n\n        String type = fragment.substring(0, dataIndex);\n        // Check if data part exists, even if empty\n        String data = (dataIndex == fragment.length() - 1) ? \"\" : fragment.substring(dataIndex + 1);\n        // Use -1 limit to preserve trailing empty strings, crucial for optional fields at the end\n        String[] values = data.split(\";\", -1);\n\n        int index = 0;\n\n        try { // Add a general try-catch for robustness within fragment types\n            switch (type) {\n                case \"GPS\":\n                    // Field 1: Validity (e.g., \"A\" or \"V\")\n                    if (index < values.length) {\n                        position.setValid(values[index].equals(\"A\"));\n                    }\n                    index++;\n                    // Field 2: Satellites in use\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            position.set(Position.KEY_SATELLITES, Integer.parseInt(values[index]));\n                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse satellites: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 3: Latitude (e.g., N31.551856)\n                    if (index < values.length && values[index].length() > 1) { // Need at least direction char + value\n                        try {\n                            position.setLatitude(Double.parseDouble(values[index].substring(1)));\n                            if (values[index].charAt(0) == 'S') {\n                                position.setLatitude(-position.getLatitude());\n                            }\n                        } catch (NumberFormatException | StringIndexOutOfBoundsException e) { /* Log.warn(\"Failed to parse latitude: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 4: Longitude (e.g., E74.366920)\n                    if (index < values.length && values[index].length() > 1) { // Need at least direction char + value\n                        try {\n                            position.setLongitude(Double.parseDouble(values[index].substring(1)));\n                            if (values[index].charAt(0) == 'W') {\n                                position.setLongitude(-position.getLongitude());\n                            }\n                        } catch (NumberFormatException | StringIndexOutOfBoundsException e) { /* Log.warn(\"Failed to parse longitude: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 5: Speed (KPH)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(values[index])));\n                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse speed: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 6: Course\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            position.setCourse(Double.parseDouble(values[index]));\n                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse course: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 7: Altitude\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            position.setAltitude(Double.parseDouble(values[index]));\n                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse altitude: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 8: HDOP\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            position.set(Position.KEY_HDOP, Double.parseDouble(values[index]));\n                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse HDOP: \" + values[index], e); */ }\n                    }\n                    index++;\n                    // Field 9: VDOP\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            position.set(Position.KEY_VDOP, Double.parseDouble(values[index]));\n                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse VDOP: \" + values[index], e); */ }\n                    }\n                    index++;\n                    break;\n                case \"GSM\":\n                    index++; // Skip registration status (field 1)\n                    index++; // Skip signal strength (field 2) - often redundant with cell tower RSSI\n                    Integer mcc = null, mnc = null, lac = null, cid = null, rssi = null;\n                    // Field 3: MCC\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { mcc = Integer.parseInt(values[index]); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 4: MNC\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { mnc = Integer.parseInt(values[index]); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 5: LAC (Hex)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { lac = Integer.parseInt(values[index], 16); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 6: CID (Hex)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { cid = Integer.parseInt(values[index], 16); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 7: RSSI\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { rssi = Integer.parseInt(values[index]); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Construct CellTower if essential fields are valid\n                    if (mcc != null && mnc != null && lac != null && cid != null) {\n                        position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid, rssi)));\n                    }\n                    break;\n                case \"COT\":\n                    // Field 1: Odometer\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { position.set(Position.KEY_ODOMETER, Long.parseLong(values[index])); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 2: Hours (format H-M-S)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            String[] hours = values[index].split(\"-\");\n                            long totalSeconds = 0;\n                            if (hours.length > 0 && !hours[0].isEmpty()) {\n                                totalSeconds += Long.parseLong(hours[0]) * 3600;\n                            }\n                            if (hours.length > 1 && !hours[1].isEmpty()) {\n                                totalSeconds += Integer.parseInt(hours[1]) * 60;\n                            }\n                            if (hours.length > 2 && !hours[2].isEmpty()) {\n                                totalSeconds += Integer.parseInt(hours[2]);\n                            }\n                            position.set(Position.KEY_HOURS, totalSeconds * 1000L); // Store as milliseconds\n                        } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    break;\n                case \"ADC\":\n                    // Field 1: Power (External Voltage)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { position.set(Position.KEY_POWER, Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 2: Battery (Internal Battery Voltage)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { position.set(Position.KEY_BATTERY, Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 3: ADC1\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { position.set(Position.PREFIX_ADC + 1, Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 4: ADC2\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { position.set(Position.PREFIX_ADC + 2, Double.parseDouble(values[index])); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    break;\n                case \"DTT\":\n                    // Field 1: Status (Hex)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try { position.set(Position.KEY_STATUS, Integer.parseInt(values[index], 16)); } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 2: IO (Hex)\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            int io = Integer.parseInt(values[index], 16);\n                            position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                            position.set(Position.PREFIX_IN + 1, BitUtil.check(io, 1));\n                            position.set(Position.PREFIX_IN + 2, BitUtil.check(io, 2));\n                            position.set(Position.PREFIX_IN + 3, BitUtil.check(io, 3));\n                            position.set(Position.PREFIX_IN + 4, BitUtil.check(io, 4));\n                            position.set(Position.PREFIX_OUT + 1, BitUtil.check(io, 5));\n                            position.set(Position.PREFIX_OUT + 2, BitUtil.check(io, 6));\n                            position.set(Position.PREFIX_OUT + 3, BitUtil.check(io, 7));\n                        } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                    index++;\n                    // Field 3 & 4: Geofence ID (concatenated)\n                    String geofence = \"\";\n                    if (index < values.length) {\n                        geofence += values[index]; // Assume content is string ID part 1\n                    }\n                    index++;\n                    if (index < values.length) {\n                        geofence += values[index]; // Assume content is string ID part 2\n                    }\n                    index++;\n                    if (!geofence.isEmpty()) {\n                        position.set(Position.KEY_GEOFENCE, geofence);\n                    }\n                    // Field 5: Event Status\n                    if (index < values.length) {\n                        position.set(\"eventStatus\", values[index]); // Assumed string value\n                    }\n                    index++;\n                    // Field 6: Packet Type\n                    if (index < values.length) {\n                        position.set(\"packetType\", values[index]); // Assumed string value\n                    }\n                    index++;\n                    break;\n                case \"ETD\":\n                    // Field 1: Event Data\n                    if (index < values.length) {\n                        position.set(\"eventData\", values[index]); // Assumed string value\n                    }\n                    index++;\n                    break;\n                case \"OBD\":\n                    // Field 1: OBD Data\n                    if (index < values.length) {\n                        position.set(\"obd\", values[index]); // Assumed string value\n                    }\n                    index++;\n                    break;\n                case \"TAG\":\n                    // Field 1: Tag Data\n                    if (index < values.length) {\n                        position.set(\"tagData\", values[index]); // Assumed string value\n                    }\n                    index++;\n                    break;\n                case \"IWD\":\n                     // Use nested try-catch for IWD loop robustness\n                     try {\n                        while (index < values.length) {\n                            // Need at least sensor index (field i) and data type (field i+1)\n                            if (index + 1 >= values.length) {\n                                break; // Not enough fields left for a complete entry\n                            }\n                            String sensorIndexStr = values[index];\n                            String dataTypeStr = values[index + 1];\n\n                            // Sensor index and data type are required; if empty, data is likely corrupt\n                            if (sensorIndexStr.isEmpty() || dataTypeStr.isEmpty()) {\n                                // Log.warn(\"Empty sensor index or data type in IWD: \" + fragment + \" at index \" + index); // Optional log\n                                index = values.length; // Assume rest of IWD data is corrupt, break loop\n                                break;\n                            }\n\n                            int sensorIndex = Integer.parseInt(sensorIndexStr); // Can throw NFE\n                            int dataType = Integer.parseInt(dataTypeStr);     // Can throw NFE\n\n                            if (dataType == 0) { // Driver ID (needs 1 value field: index+2)\n                                if (index + 2 < values.length) {\n                                    position.set(Position.KEY_DRIVER_UNIQUE_ID, values[index + 2]);\n                                    index += 3; // Consumed index, type, value\n                                } else {\n                                    // Log.warn(\"Missing value for IWD Driver ID: \" + fragment); // Optional log\n                                    index = values.length; // Not enough fields, break loop\n                                }\n                            } else if (dataType == 1) { // Temperature (needs 2 fields: serial (index+2) + value (index+3))\n                                if (index + 3 < values.length) {\n                                    String tempValueStr = values[index + 3];\n                                    if (!tempValueStr.isEmpty()) {\n                                        try {\n                                            position.set(Position.PREFIX_TEMP + sensorIndex, Double.parseDouble(tempValueStr));\n                                        } catch (NumberFormatException e) { /* Log.warn(\"Failed to parse IWD temperature value: \" + tempValueStr, e); */ }\n                                    }\n                                    index += 4; // Consumed index, type, serial, value\n                                } else {\n                                    // Log.warn(\"Missing serial/value for IWD Temperature: \" + fragment); // Optional log\n                                    index = values.length; // Not enough fields, break loop\n                                }\n                            } else { // Unknown type - assume 1 value field (index+2) to skip\n                                // Log.warn(\"Unknown IWD data type: \" + dataType + \" in fragment: \" + fragment); // Optional log\n                                if (index + 2 < values.length) {\n                                    index += 3; // Skip index, type, unknown value\n                                } else {\n                                    index = values.length; // Not enough fields to skip, break loop\n                                }\n                            }\n                        }\n                     } catch (NumberFormatException e) {\n                         // Error parsing required sensorIndex or dataType, stop processing IWD for this fragment\n                         // Log.warn(\"Error parsing IWD sensor/type in fragment: \" + fragment, e); // Optional log\n                     } catch (ArrayIndexOutOfBoundsException e) {\n                         // Should be prevented by checks, but safety catch\n                         // Log.error(\"ArrayIndexOutOfBounds in IWD parsing for fragment: \" + fragment, e); // Optional log\n                     }\n                    break;\n                default:\n                    // Unknown fragment type, ignore\n                    // Log.warn(\"Unknown fragment type: \" + type); // Optional log\n                    break;\n            }\n        } catch (Exception e) {\n            // Catch any other unexpected errors during fragment processing\n            // Log.error(\"Error decoding fragment '\" + fragment + \"'\", e); // Optional log\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}