{
    "generation": "    private void decodeFragment(Position position, String fragment) {\n\n        int dataIndex = fragment.indexOf(':');\n        if (dataIndex < 0 || dataIndex == fragment.length() - 1) {\n            // Invalid fragment format or empty data, nothing to decode\n            return;\n        }\n\n        int index = 0;\n        // Split defensively, ensuring trailing empty strings are captured if needed\n        String[] values = fragment.substring(dataIndex + 1).split(\";\", -1);\n\n        // Helper function to safely parse Integer\n        Integer parseIntSafe(String s) {\n            if (s == null || s.isEmpty()) {\n                return null;\n            }\n            try {\n                return Integer.parseInt(s);\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n\n        // Helper function to safely parse Integer (Hex)\n        Integer parseIntHexSafe(String s) {\n            if (s == null || s.isEmpty()) {\n                return null;\n            }\n            try {\n                return Integer.parseInt(s, 16);\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n\n        // Helper function to safely parse Long\n        Long parseLongSafe(String s) {\n            if (s == null || s.isEmpty()) {\n                return null;\n            }\n            try {\n                return Long.parseLong(s);\n            } catch (NumberFormatException e) {\n                return null;\n            }\n        }\n\n        // Helper function to safely parse Double\n        Double parseDoubleSafe(String s) {\n             if (s == null || s.isEmpty()) {\n                 return null;\n             }\n             try {\n                 return Double.parseDouble(s);\n             } catch (NumberFormatException e) {\n                 return null;\n             }\n        }\n\n\n        switch (fragment.substring(0, dataIndex)) {\n            case \"GPS\":\n                // Validity\n                if (index < values.length) {\n                    position.setValid(values[index].equals(\"A\"));\n                }\n                index++;\n\n                // Satellites\n                if (index < values.length) {\n                    Integer satellites = parseIntSafe(values[index]);\n                    if (satellites != null) {\n                        position.set(Position.KEY_SATELLITES, satellites);\n                    }\n                }\n                index++;\n\n                // Latitude\n                if (index < values.length && values[index].length() > 1) {\n                    try {\n                        double latitude = Double.parseDouble(values[index].substring(1));\n                        if (values[index].charAt(0) == 'S') {\n                            latitude = -latitude;\n                        }\n                        position.setLatitude(latitude);\n                    } catch (NumberFormatException | StringIndexOutOfBoundsException e) {\n                        // Ignore invalid latitude format\n                    }\n                }\n                index++;\n\n                // Longitude\n                if (index < values.length && values[index].length() > 1) {\n                     try {\n                        double longitude = Double.parseDouble(values[index].substring(1));\n                        if (values[index].charAt(0) == 'W') {\n                            longitude = -longitude;\n                        }\n                        position.setLongitude(longitude);\n                     } catch (NumberFormatException | StringIndexOutOfBoundsException e) {\n                         // Ignore invalid longitude format\n                     }\n                }\n                index++;\n\n                // Speed (KPH, convert to Knots)\n                if (index < values.length) {\n                    Double speedKph = parseDoubleSafe(values[index]);\n                    if (speedKph != null) {\n                        position.setSpeed(UnitsConverter.knotsFromKph(speedKph));\n                    }\n                }\n                index++;\n\n                // Course\n                if (index < values.length) {\n                    Double course = parseDoubleSafe(values[index]); // Course might be decimal\n                    if (course != null) {\n                        position.setCourse(course);\n                    }\n                }\n                index++;\n\n                // Altitude\n                if (index < values.length) {\n                     Double altitude = parseDoubleSafe(values[index]); // Altitude might be decimal\n                     if (altitude != null) {\n                         position.setAltitude(altitude);\n                     }\n                }\n                index++;\n\n                // HDOP\n                if (index < values.length) {\n                    Double hdop = parseDoubleSafe(values[index]);\n                    if (hdop != null) {\n                        position.set(Position.KEY_HDOP, hdop);\n                    }\n                }\n                index++;\n\n                // VDOP\n                if (index < values.length) {\n                     Double vdop = parseDoubleSafe(values[index]);\n                     if (vdop != null) {\n                         position.set(Position.KEY_VDOP, vdop);\n                     }\n                }\n                index++;\n                break;\n\n            case \"GSM\":\n                index += 1; // registration status (skip)\n                index += 1; // signal strength (skip)\n\n                Integer mcc = null, mnc = null, lac = null, cid = null, rssi = null;\n\n                if (index < values.length) { mcc = parseIntSafe(values[index]); } index++;\n                if (index < values.length) { mnc = parseIntSafe(values[index]); } index++;\n                if (index < values.length) { lac = parseIntHexSafe(values[index]); } index++;\n                if (index < values.length) { cid = parseIntHexSafe(values[index]); } index++;\n                if (index < values.length) { rssi = parseIntSafe(values[index]); } index++;\n\n                if (mcc != null && mnc != null && lac != null && cid != null) {\n                    CellTower cellTower = CellTower.from(mcc, mnc, lac, cid);\n                    if (rssi != null) {\n                        cellTower.setSignalStrength(rssi);\n                    }\n                    position.setNetwork(new Network(cellTower));\n                }\n                break;\n\n            case \"COT\":\n                // Odometer\n                if (index < values.length) {\n                    Long odometer = parseLongSafe(values[index]);\n                    if (odometer != null) {\n                        position.set(Position.KEY_ODOMETER, odometer);\n                    }\n                }\n                index++;\n\n                // Hours\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        String[] hours = values[index].split(\"-\");\n                        long h = hours.length > 0 ? parseLongSafe(hours[0]) != null ? parseLongSafe(hours[0]) : 0 : 0;\n                        long m = hours.length > 1 ? parseLongSafe(hours[1]) != null ? parseLongSafe(hours[1]) : 0 : 0;\n                        long s = hours.length > 2 ? parseLongSafe(hours[2]) != null ? parseLongSafe(hours[2]) : 0 : 0;\n                        position.set(Position.KEY_HOURS, (h * 3600 + m * 60 + s) * 1000L);\n                    } catch (Exception e) { // Catch potential split or parse issues broadly\n                         // Ignore invalid hours format\n                    }\n                }\n                index++; // Increment index for the hours field\n                break;\n\n            case \"ADC\":\n                // Power\n                if (index < values.length) {\n                    Double power = parseDoubleSafe(values[index]);\n                    if (power != null) {\n                        position.set(Position.KEY_POWER, power);\n                    }\n                }\n                index++;\n\n                // Battery\n                if (index < values.length) {\n                    Double battery = parseDoubleSafe(values[index]);\n                    if (battery != null) {\n                        position.set(Position.KEY_BATTERY, battery);\n                    }\n                }\n                index++;\n\n                // ADC 1\n                if (index < values.length) {\n                    Double adc1 = parseDoubleSafe(values[index]);\n                    if (adc1 != null) {\n                        position.set(Position.PREFIX_ADC + 1, adc1);\n                    }\n                }\n                index++;\n\n                // ADC 2\n                if (index < values.length) {\n                    Double adc2 = parseDoubleSafe(values[index]);\n                    if (adc2 != null) {\n                        position.set(Position.PREFIX_ADC + 2, adc2);\n                    }\n                }\n                index++;\n                break;\n\n            case \"DTT\":\n                // Status\n                if (index < values.length) {\n                    Integer status = parseIntHexSafe(values[index]);\n                    if (status != null) {\n                        position.set(Position.KEY_STATUS, status);\n                    }\n                }\n                index++;\n\n                // IO\n                if (index < values.length && !values[index].isEmpty()) { // Check if IO value exists and is not empty\n                    Integer io = parseIntHexSafe(values[index]);\n                    if (io != null) {\n                        position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                        position.set(Position.PREFIX_IN + 1, BitUtil.check(io, 1));\n                        position.set(Position.PREFIX_IN + 2, BitUtil.check(io, 2));\n                        position.set(Position.PREFIX_IN + 3, BitUtil.check(io, 3));\n                        position.set(Position.PREFIX_IN + 4, BitUtil.check(io, 4));\n                        position.set(Position.PREFIX_OUT + 1, BitUtil.check(io, 5));\n                        position.set(Position.PREFIX_OUT + 2, BitUtil.check(io, 6));\n                        position.set(Position.PREFIX_OUT + 3, BitUtil.check(io, 7));\n                    }\n                }\n                index++; // Always increment index for the IO field position\n\n                // Geofence\n                String geofence1 = index < values.length ? values[index] : \"\"; index++;\n                String geofence2 = index < values.length ? values[index] : \"\"; index++;\n                position.set(Position.KEY_GEOFENCE, geofence1 + geofence2);\n\n                // Event Status\n                if (index < values.length) { position.set(\"eventStatus\", values[index]); } index++;\n\n                // Packet Type\n                if (index < values.length) { position.set(\"packetType\", values[index]); } index++;\n                break;\n\n            case \"ETD\":\n                if (index < values.length) { position.set(\"eventData\", values[index]); } index++;\n                break;\n\n            case \"OBD\":\n                if (index < values.length) { position.set(\"obd\", values[index]); } index++;\n                break;\n\n            case \"TAG\":\n                if (index < values.length) { position.set(\"tagData\", values[index]); } index++;\n                break;\n\n            case \"IWD\":\n                while (index < values.length) {\n                    // Sensor Index\n                    Integer sensorIndex = parseIntSafe(values[index]);\n                    index++;\n                    if (sensorIndex == null) { continue; } // Skip entry if index is invalid/missing\n\n                    // Data Type\n                    if (index >= values.length) { break; } // Need data type\n                    Integer dataType = parseIntSafe(values[index]);\n                    index++;\n                    if (dataType == null) { continue; } // Skip entry if data type is invalid/missing\n\n                    if (dataType == 0) { // Driver ID\n                        if (index < values.length) {\n                            position.set(Position.KEY_DRIVER_UNIQUE_ID, values[index]);\n                        } else {\n                           break; // Missing value for type 0\n                        }\n                        index++;\n                    } else if (dataType == 1) { // Temperature\n                        // Skip Serial Number field\n                        if (index >= values.length) { break; } // Missing serial number field\n                        index++;\n\n                        // Temperature Value\n                        if (index < values.length) {\n                            Double temperature = parseDoubleSafe(values[index]);\n                            if (temperature != null) {\n                                position.set(Position.PREFIX_TEMP + sensorIndex, temperature);\n                            }\n                        } else {\n                             break; // Missing temperature value field\n                        }\n                        index++;\n                    } else {\n                        // Unknown data type - Stop processing IWD\n                        break;\n                    }\n                }\n                break;\n            default:\n                // Unknown fragment type, ignore\n                break;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}