{
    "generation": "    private void decodeFragment(Position position, String fragment) {\n\n        int dataIndex = fragment.indexOf(':');\n        if (dataIndex == -1) {\n             // Invalid fragment format, ignore or log\n             return;\n        }\n        int index = 0;\n        String[] values;\n        if (fragment.length() == dataIndex + 1) {\n            values = new String[0];\n        } else {\n            // Use split with -1 limit to preserve trailing empty strings, which might be present\n            values = fragment.substring(dataIndex + 1).split(\";\", -1);\n        }\n\n        String type = fragment.substring(0, dataIndex);\n\n        // Wrap decoding in a try-catch to prevent unexpected errors from stopping processing,\n        // though specific NumberFormatExceptions are handled inline.\n        try {\n            switch (type) {\n                case \"GPS\":\n                    if (index < values.length) { // Validity\n                        position.setValid(values[index].equals(\"A\"));\n                    }\n                    index++;\n\n                    if (index < values.length) { // Satellites\n                        String satellitesStr = values[index];\n                        if (!satellitesStr.isEmpty()) {\n                           try {\n                               position.set(Position.KEY_SATELLITES, Integer.parseInt(satellitesStr));\n                           } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Latitude\n                        String latValue = values[index];\n                        // Check if the value has at least the direction character and a number part\n                        if (latValue.length() > 1) {\n                            String latNumStr = latValue.substring(1);\n                            if (!latNumStr.isEmpty()) {\n                                try {\n                                    double latitude = Double.parseDouble(latNumStr);\n                                    // Apply direction sign\n                                    if (latValue.charAt(0) == 'S') {\n                                        latitude = -latitude;\n                                    }\n                                    position.setLatitude(latitude);\n                                } catch (NumberFormatException e) { /* ignore parse error */ }\n                            }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Longitude\n                        String lonValue = values[index];\n                         // Check if the value has at least the direction character and a number part\n                         if (lonValue.length() > 1) {\n                            String lonNumStr = lonValue.substring(1);\n                            if (!lonNumStr.isEmpty()) {\n                                try {\n                                    double longitude = Double.parseDouble(lonNumStr);\n                                    // Apply direction sign\n                                    if (lonValue.charAt(0) == 'W') {\n                                        longitude = -longitude;\n                                    }\n                                    position.setLongitude(longitude);\n                                } catch (NumberFormatException e) { /* ignore parse error */ }\n                            }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Speed\n                        String speedKphStr = values[index];\n                        if (!speedKphStr.isEmpty()) {\n                            try {\n                                // Use Double.parseDouble, as speed might not always be integer kph\n                                position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(speedKphStr)));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Course\n                        String courseStr = values[index];\n                        if (!courseStr.isEmpty()) {\n                            try {\n                                // Course is often represented as double\n                                position.setCourse(Double.parseDouble(courseStr));\n                             } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Altitude\n                        String altitudeStr = values[index];\n                        if (!altitudeStr.isEmpty()) {\n                             try {\n                                // Altitude can be double\n                                position.setAltitude(Double.parseDouble(altitudeStr));\n                             } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // HDOP\n                        String hdopStr = values[index];\n                        if (!hdopStr.isEmpty()) {\n                             try {\n                                position.set(Position.KEY_HDOP, Double.parseDouble(hdopStr));\n                             } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // VDOP\n                        String vdopStr = values[index];\n                        if (!vdopStr.isEmpty()) {\n                             try {\n                                position.set(Position.KEY_VDOP, Double.parseDouble(vdopStr));\n                             } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n                    break; // End of GPS case\n\n                case \"GSM\":\n                    index++; // Skip registration status field\n                    index++; // Skip signal strength field\n\n                    // Initialize variables to store parsed GSM info\n                    Integer mcc = null, mnc = null, lac = null, cid = null, rssi = null;\n\n                    // Parse MCC, MNC, LAC, CID, RSSI safely\n                    if (index < values.length) {\n                        String mccStr = values[index];\n                        if (!mccStr.isEmpty()) { try { mcc = Integer.parseInt(mccStr); } catch (NumberFormatException e) {} }\n                    }\n                    index++;\n                    if (index < values.length) {\n                        String mncStr = values[index];\n                        if (!mncStr.isEmpty()) { try { mnc = Integer.parseInt(mncStr); } catch (NumberFormatException e) {} }\n                    }\n                    index++;\n                    if (index < values.length) {\n                        String lacStr = values[index];\n                        if (!lacStr.isEmpty()) { try { lac = Integer.parseInt(lacStr, 16); } catch (NumberFormatException e) {} }\n                    }\n                    index++;\n                    if (index < values.length) {\n                        String cidStr = values[index];\n                        if (!cidStr.isEmpty()) { try { cid = Integer.parseInt(cidStr, 16); } catch (NumberFormatException e) {} }\n                    }\n                    index++;\n                    // Optional: Parse RSSI if present\n                    if (index < values.length) {\n                        String rssiStr = values[index];\n                        if (!rssiStr.isEmpty()) { try { rssi = Integer.parseInt(rssiStr); } catch (NumberFormatException e) {} }\n                    }\n                    index++; // Increment even if RSSI is missing/last field\n\n                    // Only set network if essential Cell Tower info was parsed successfully\n                    if (mcc != null && mnc != null && lac != null && cid != null) {\n                        CellTower cellTower = CellTower.from(mcc, mnc, lac, cid);\n                        if (rssi != null) {\n                            cellTower.setSignalStrength(rssi);\n                        }\n                        position.setNetwork(new Network(cellTower));\n                    }\n                    break;\n\n                case \"COT\":\n                    if (index < values.length) { // Odometer\n                        String odometerStr = values[index];\n                        if (!odometerStr.isEmpty()) {\n                            try {\n                                position.set(Position.KEY_ODOMETER, Long.parseLong(odometerStr));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Engine Hours\n                        String hoursValue = values[index];\n                        if (!hoursValue.isEmpty()) {\n                            try {\n                                String[] hours = hoursValue.split(\"-\");\n                                // Use long for calculations to avoid potential overflow with large hour values\n                                long h = 0, m = 0, s = 0;\n                                if (hours.length > 0 && !hours[0].isEmpty()) {\n                                    h = Long.parseLong(hours[0]);\n                                }\n                                if (hours.length > 1 && !hours[1].isEmpty()) {\n                                    m = Long.parseLong(hours[1]);\n                                }\n                                if (hours.length > 2 && !hours[2].isEmpty()) {\n                                    s = Long.parseLong(hours[2]);\n                                }\n                                // Store total milliseconds\n                                position.set(Position.KEY_HOURS, (h * 3600L + m * 60L + s) * 1000L);\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n                    break;\n\n                case \"ADC\":\n                    if (index < values.length) { // Power (External Voltage)\n                        String powerStr = values[index];\n                        if (!powerStr.isEmpty()) {\n                            try {\n                                position.set(Position.KEY_POWER, Double.parseDouble(powerStr));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // Battery (Internal Battery Voltage)\n                        String batteryStr = values[index];\n                        if (!batteryStr.isEmpty()) {\n                            try {\n                                position.set(Position.KEY_BATTERY, Double.parseDouble(batteryStr));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // ADC1\n                        String adc1Str = values[index];\n                        if (!adc1Str.isEmpty()) {\n                            try {\n                                position.set(Position.PREFIX_ADC + 1, Double.parseDouble(adc1Str));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // ADC2\n                        String adc2Str = values[index];\n                        if (!adc2Str.isEmpty()) {\n                             try {\n                                position.set(Position.PREFIX_ADC + 2, Double.parseDouble(adc2Str));\n                             } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n                    break;\n\n                case \"DTT\":\n                    if (index < values.length) { // Status (Hex)\n                        String statusStr = values[index];\n                        if (!statusStr.isEmpty()) {\n                            try {\n                                position.set(Position.KEY_STATUS, Integer.parseInt(statusStr, 16));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    if (index < values.length) { // IO (Hex)\n                        String ioStr = values[index];\n                        if (!ioStr.isEmpty()) {\n                            try {\n                                int io = Integer.parseInt(ioStr, 16);\n                                // Decode individual bits for digital inputs/outputs/ignition\n                                position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                                position.set(Position.PREFIX_IN + 1, BitUtil.check(io, 1));\n                                position.set(Position.PREFIX_IN + 2, BitUtil.check(io, 2));\n                                position.set(Position.PREFIX_IN + 3, BitUtil.check(io, 3));\n                                position.set(Position.PREFIX_IN + 4, BitUtil.check(io, 4));\n                                position.set(Position.PREFIX_OUT + 1, BitUtil.check(io, 5));\n                                position.set(Position.PREFIX_OUT + 2, BitUtil.check(io, 6));\n                                position.set(Position.PREFIX_OUT + 3, BitUtil.check(io, 7));\n                            } catch (NumberFormatException e) { /* ignore parse error */ }\n                        }\n                    }\n                    index++;\n\n                    // Geofence ID (Concatenation of two fields)\n                    String geofence = \"\";\n                    if (index < values.length) {\n                        geofence += values[index];\n                    }\n                    index++;\n                    if (index < values.length) {\n                       geofence += values[index];\n                    }\n                    index++;\n                    // Only set if the combined geofence string is not empty\n                    if (!geofence.isEmpty()) {\n                        position.set(Position.KEY_GEOFENCE, geofence);\n                    }\n\n                    if (index < values.length) { // Event Status\n                        position.set(\"eventStatus\", values[index]);\n                    }\n                    index++;\n\n                    if (index < values.length) { // Packet Type\n                        position.set(\"packetType\", values[index]);\n                    }\n                    index++;\n                    break;\n\n                case \"ETD\": // Extended Data\n                    if (index < values.length) {\n                        position.set(\"eventData\", values[index]);\n                    }\n                    index++;\n                    break;\n                case \"OBD\": // OBD Data\n                     if (index < values.length) {\n                        position.set(\"obd\", values[index]);\n                    }\n                    index++;\n                   break;\n                case \"TAG\": // Tag Data (e.g., RFID)\n                     if (index < values.length) {\n                        position.set(\"tagData\", values[index]);\n                    }\n                    index++;\n                    break;\n                case \"IWD\": // Wireless Sensor Data (iWire/1-Wire)\n                    while (index < values.length) {\n                        // Sensor Index\n                        String sensorIndexStr = values[index];\n                        int sensorIndex;\n                        if (!sensorIndexStr.isEmpty()) {\n                            try {\n                                sensorIndex = Integer.parseInt(sensorIndexStr);\n                            } catch (NumberFormatException e) { break; } // Stop processing IWD if index is invalid\n                        } else {\n                            index++; continue; // Skip entry if sensor index is empty\n                        }\n                        index++;\n\n                        // Data Type\n                        if (index >= values.length) { break; } // Check bounds before accessing next value\n                        String dataTypeStr = values[index];\n                        int dataType;\n                        if (!dataTypeStr.isEmpty()) {\n                            try {\n                                dataType = Integer.parseInt(dataTypeStr);\n                            } catch (NumberFormatException e) { break; } // Stop processing IWD if type is invalid\n                        } else {\n                             index++; continue; // Skip entry if data type is empty\n                        }\n                        index++;\n\n                        // Process based on Data Type\n                        if (dataType == 0) { // Driver ID (iButton)\n                            if (index < values.length) {\n                                position.set(Position.KEY_DRIVER_UNIQUE_ID, values[index]);\n                                index++;\n                            } else { break; } // Missing value for driver ID\n                        } else if (dataType == 1) { // Temperature Sensor\n                            // Skip the sensor's serial number field\n                            if (index < values.length) {\n                               index++;\n                            } else { break; } // Missing serial number field\n\n                            // Parse the temperature value\n                            if (index < values.length) {\n                               String tempStr = values[index];\n                                if (!tempStr.isEmpty()) {\n                                    try {\n                                        position.set(Position.PREFIX_TEMP + sensorIndex, Double.parseDouble(tempStr));\n                                    } catch (NumberFormatException e) { /* ignore parse error for temp value */ }\n                                }\n                                index++;\n                            } else { break; } // Missing temperature value field\n                        } else {\n                             // Unknown data type, we don't know how many fields it uses.\n                             // Stop processing IWD block to avoid misinterpreting data.\n                             break;\n                        }\n                    }\n                    break;\n                default:\n                    // Unknown fragment type, ignore it\n                    break;\n            }\n        } catch (Exception e) {\n            // Log unexpected exceptions during fragment decoding for debugging\n            // Log.warning(\"Error decoding fragment '\" + type + \"': \" + fragment, e);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}