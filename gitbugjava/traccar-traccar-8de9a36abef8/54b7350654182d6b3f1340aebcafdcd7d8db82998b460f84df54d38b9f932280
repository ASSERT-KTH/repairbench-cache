{
    "generation": "    private void decodeFragment(Position position, String fragment) {\n\n        int dataIndex = fragment.indexOf(':');\n        if (dataIndex < 0 || dataIndex == fragment.length() - 1) {\n            // Handle cases like \"TAG:\" or missing \":\" or empty data part\n            return; // Or log error, depending on desired behavior\n        }\n        int index = 0;\n        String[] values = fragment.substring(dataIndex + 1).split(\";\", -1); // Use -1 limit to preserve trailing empty strings\n\n        String type = fragment.substring(0, dataIndex);\n\n        switch (type) {\n            case \"GPS\":\n                // Validity\n                if (index < values.length) {\n                    position.setValid(values[index].equals(\"A\"));\n                }\n                index++;\n\n                // Satellites\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_SATELLITES, Integer.parseInt(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Latitude\n                if (index < values.length && values[index].length() > 1) { // Need at least direction and value\n                    try {\n                        position.setLatitude(Double.parseDouble(values[index].substring(1)));\n                        if (values[index].charAt(0) == 'S') {\n                            position.setLatitude(-position.getLatitude());\n                        }\n                    } catch (NumberFormatException | StringIndexOutOfBoundsException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Longitude\n                if (index < values.length && values[index].length() > 1) { // Need at least direction and value\n                    try {\n                        position.setLongitude(Double.parseDouble(values[index].substring(1)));\n                        if (values[index].charAt(0) == 'W') {\n                            position.setLongitude(-position.getLongitude());\n                        }\n                    } catch (NumberFormatException | StringIndexOutOfBoundsException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Speed\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.setSpeed(UnitsConverter.knotsFromKph(Integer.parseInt(values[index])));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Course\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.setCourse(Integer.parseInt(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Altitude\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.setAltitude(Integer.parseInt(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // HDOP\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_HDOP, Double.parseDouble(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // VDOP\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_VDOP, Double.parseDouble(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                // No need to increment index here as it's the last field checked explicitly\n                break;\n            case \"GSM\":\n                index += 1; // registration status (skip)\n                index += 1; // signal strength (skip)\n                if (index + 4 < values.length) { // Ensure enough fields exist\n                    try {\n                        int mcc = Integer.parseInt(values[index++]);\n                        int mnc = Integer.parseInt(values[index++]);\n                        int lac = Integer.parseInt(values[index++], 16);\n                        int cid = Integer.parseInt(values[index++], 16);\n                        int rssi = Integer.parseInt(values[index++]);\n                        position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid, rssi)));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                break;\n            case \"COT\":\n                // Odometer\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_ODOMETER, Long.parseLong(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Hours\n                if (index < values.length && !values[index].isEmpty()) {\n                    String[] hours = values[index].split(\"-\");\n                    try {\n                         long totalSeconds = 0;\n                         if (hours.length > 0 && !hours[0].isEmpty()) {\n                             totalSeconds += Integer.parseInt(hours[0]) * 3600L;\n                         }\n                         if (hours.length > 1 && !hours[1].isEmpty()) {\n                             totalSeconds += Integer.parseInt(hours[1]) * 60L;\n                         }\n                         if (hours.length > 2 && !hours[2].isEmpty()) {\n                             totalSeconds += Integer.parseInt(hours[2]);\n                         }\n                         position.set(Position.KEY_HOURS, totalSeconds * 1000);\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                // No need to increment index here as it's the last field checked explicitly\n                break;\n            case \"ADC\":\n                // Power\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_POWER, Double.parseDouble(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Battery\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_BATTERY, Double.parseDouble(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // ADC 1\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.PREFIX_ADC + 1, Double.parseDouble(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // ADC 2\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.PREFIX_ADC + 2, Double.parseDouble(values[index]));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                // No need to increment index here as it's the last field checked explicitly\n                break;\n            case \"DTT\":\n                // Status\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        position.set(Position.KEY_STATUS, Integer.parseInt(values[index], 16));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // IO\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        int io = Integer.parseInt(values[index], 16);\n                        position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                        position.set(Position.PREFIX_IN + 1, BitUtil.check(io, 1));\n                        position.set(Position.PREFIX_IN + 2, BitUtil.check(io, 2));\n                        position.set(Position.PREFIX_IN + 3, BitUtil.check(io, 3));\n                        position.set(Position.PREFIX_IN + 4, BitUtil.check(io, 4));\n                        position.set(Position.PREFIX_OUT + 1, BitUtil.check(io, 5));\n                        position.set(Position.PREFIX_OUT + 2, BitUtil.check(io, 6));\n                        position.set(Position.PREFIX_OUT + 3, BitUtil.check(io, 7));\n                    } catch (NumberFormatException e) { /* ignore or log */ }\n                }\n                index++;\n\n                // Geofence\n                String geofence = \"\";\n                if (index < values.length) {\n                    geofence += values[index];\n                }\n                index++;\n                if (index < values.length) {\n                    geofence += values[index];\n                }\n                index++;\n                if (!geofence.isEmpty()) {\n                    position.set(Position.KEY_GEOFENCE, geofence);\n                }\n\n                // Event Status\n                if (index < values.length) {\n                    position.set(\"eventStatus\", values[index]);\n                }\n                index++;\n\n                // Packet Type\n                if (index < values.length) {\n                    position.set(\"packetType\", values[index]);\n                }\n                // No need to increment index here as it's the last field checked explicitly\n                break;\n            case \"ETD\":\n                if (index < values.length) {\n                    position.set(\"eventData\", values[index]);\n                }\n                break;\n            case \"OBD\":\n                if (index < values.length) {\n                    position.set(\"obd\", values[index]);\n                }\n                break;\n            case \"TAG\":\n                if (index < values.length) {\n                    position.set(\"tagData\", values[index]);\n                }\n                break;\n            case \"IWD\":\n                while (index < values.length) {\n                    int sensorIndex = -1;\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            sensorIndex = Integer.parseInt(values[index]);\n                        } catch (NumberFormatException e) { /* ignore or log */ }\n                    }\n                    index++; // Increment for sensorIndex field\n\n                    int dataType = -1;\n                    if (index < values.length && !values[index].isEmpty()) {\n                        try {\n                            dataType = Integer.parseInt(values[index]);\n                        } catch (NumberFormatException e) { /* ignore or log */ }\n                    }\n                    index++; // Increment for dataType field\n\n                    if (dataType == 0) { // Driver ID\n                        if (index < values.length) {\n                             position.set(Position.KEY_DRIVER_UNIQUE_ID, values[index]);\n                        }\n                        index++; // Increment for driver ID value\n                    } else if (dataType == 1) { // Temperature\n                        index += 1; // Skip temperature sensor serial number\n                        if (sensorIndex != -1 && index < values.length && !values[index].isEmpty()) {\n                            try {\n                                position.set(Position.PREFIX_TEMP + sensorIndex, Double.parseDouble(values[index]));\n                            } catch (NumberFormatException e) { /* ignore or log */ }\n                        }\n                        index++; // Increment for temperature value\n                    } else {\n                        // Unknown data type or structure mismatch\n                        // Attempt to skip remaining fields for this entry if possible,\n                        // or break if the structure is unreliable\n                        // Based on original logic, let's assume we can't reliably continue.\n                        break;\n                    }\n                }\n                break;\n            default:\n                // Unknown fragment type, ignore or log\n                break;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}