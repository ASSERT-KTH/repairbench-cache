{
    "generation": "private void decodeFragment(Position position, String fragment) {\n\n    int dataIndex = fragment.indexOf(':');\n    if (dataIndex == -1) {\n        return;\n    }\n    String key = fragment.substring(0, dataIndex);\n    String data = fragment.length() <= dataIndex + 1 ? \"\" : fragment.substring(dataIndex + 1);\n    String[] values = data.isEmpty() ? new String[0] : data.split(\";\");\n    int idx = 0;\n\n    switch (key) {\n\n        case \"GPS\":\n            // Skip GS02 time field (HHMMSS)\n            if (idx < values.length && values[idx].matches(\"\\\\d{6}\")) {\n                idx++;\n            }\n            // Validity\n            if (idx < values.length) {\n                position.setValid(\"A\".equals(values[idx]));\n                idx++;\n            }\n            // Satellites (only if purely numeric)\n            if (idx < values.length && values[idx].matches(\"\\\\d+\")) {\n                position.set(Position.KEY_SATELLITES, Integer.parseInt(values[idx]));\n                idx++;\n            }\n            // Latitude\n            if (idx < values.length\n                    && values[idx].length() > 1\n                    && (values[idx].charAt(0) == 'N' || values[idx].charAt(0) == 'S')) {\n                char hemi = values[idx].charAt(0);\n                String val = values[idx].substring(1);\n                if (!val.isEmpty()) {\n                    double lat = Double.parseDouble(val);\n                    if (hemi == 'S') {\n                        lat = -lat;\n                    }\n                    position.setLatitude(lat);\n                }\n                idx++;\n            }\n            // Longitude\n            if (idx < values.length\n                    && values[idx].length() > 1\n                    && (values[idx].charAt(0) == 'E' || values[idx].charAt(0) == 'W')) {\n                char hemi = values[idx].charAt(0);\n                String val = values[idx].substring(1);\n                if (!val.isEmpty()) {\n                    double lon = Double.parseDouble(val);\n                    if (hemi == 'W') {\n                        lon = -lon;\n                    }\n                    position.setLongitude(lon);\n                }\n                idx++;\n            }\n            // Speed (convert Kph to knots)\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.setSpeed(UnitsConverter.knotsFromKph(\n                        Integer.parseInt(values[idx])));\n            }\n            idx++;\n            // Course\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.setCourse(Integer.parseInt(values[idx]));\n            }\n            idx++;\n            // Altitude\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.setAltitude(Integer.parseInt(values[idx]));\n            }\n            idx++;\n            // HDOP\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.KEY_HDOP, Double.parseDouble(values[idx]));\n            }\n            idx++;\n            // VDOP\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.KEY_VDOP, Double.parseDouble(values[idx]));\n            }\n            break;\n\n        case \"GSM\":\n            // Skip registration status & signal strength\n            idx += 2;\n            if (values.length > idx + 4) {\n                int mcc = Integer.parseInt(values[idx++]);\n                int mnc = Integer.parseInt(values[idx++]);\n                int lac = Integer.parseInt(values[idx++], 16);\n                int cid = Integer.parseInt(values[idx++], 16);\n                int rssi = Integer.parseInt(values[idx++]);\n                position.setNetwork(new Network(\n                        CellTower.from(mcc, mnc, lac, cid, rssi)));\n            }\n            break;\n\n        case \"COT\":\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.KEY_ODOMETER, Long.parseLong(values[idx]));\n            }\n            idx++;\n            if (idx < values.length && !values[idx].isEmpty()) {\n                String[] hours = values[idx].split(\"-\");\n                int total = 0;\n                if (hours.length > 0 && !hours[0].isEmpty()) {\n                    total += Integer.parseInt(hours[0]) * 3600;\n                }\n                if (hours.length > 1 && !hours[1].isEmpty()) {\n                    total += Integer.parseInt(hours[1]) * 60;\n                }\n                if (hours.length > 2 && !hours[2].isEmpty()) {\n                    total += Integer.parseInt(hours[2]);\n                }\n                position.set(Position.KEY_HOURS, total * 1000);\n            }\n            break;\n\n        case \"ADC\":\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.KEY_POWER, Double.parseDouble(values[idx]));\n            }\n            idx++;\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.KEY_BATTERY, Double.parseDouble(values[idx]));\n            }\n            idx++;\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.PREFIX_ADC + 1,\n                        Double.parseDouble(values[idx]));\n            }\n            idx++;\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.PREFIX_ADC + 2,\n                        Double.parseDouble(values[idx]));\n            }\n            break;\n\n        case \"DTT\":\n            if (idx < values.length && !values[idx].isEmpty()) {\n                position.set(Position.KEY_STATUS,\n                        Integer.parseInt(values[idx], 16));\n            }\n            idx++;\n            if (idx < values.length && !values[idx].isEmpty()) {\n                int io = Integer.parseInt(values[idx], 16);\n                position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                for (int i = 1; i <= 4; i++) {\n                    position.set(Position.PREFIX_IN + i, BitUtil.check(io, i));\n                }\n                for (int i = 1; i <= 3; i++) {\n                    position.set(Position.PREFIX_OUT + i, BitUtil.check(io, i + 4));\n                }\n            }\n            idx++;\n            if (values.length > idx + 1) {\n                position.set(Position.KEY_GEOFENCE,\n                        values[idx] + values[idx + 1]);\n            }\n            idx += 2;\n            if (idx < values.length) {\n                position.set(\"eventStatus\", values[idx]);\n            }\n            idx++;\n            if (idx < values.length) {\n                position.set(\"packetType\", values[idx]);\n            }\n            break;\n\n        case \"ETD\":\n            if (idx < values.length) {\n                position.set(\"eventData\", values[idx]);\n            }\n            break;\n\n        case \"OBD\":\n            if (idx < values.length) {\n                position.set(\"obd\", values[idx]);\n            }\n            break;\n\n        case \"TAG\":\n            if (idx < values.length) {\n                position.set(\"tagData\", values[idx]);\n            }\n            break;\n\n        case \"IWD\":\n            while (idx + 1 < values.length) {\n                int sensorIndex = Integer.parseInt(values[idx++]);\n                int dataType = Integer.parseInt(values[idx++]);\n                if (dataType == 0) {\n                    if (idx < values.length) {\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID,\n                                values[idx++]);\n                    }\n                } else if (dataType == 1) {\n                    idx++; // skip serial\n                    if (idx < values.length) {\n                        position.set(Position.PREFIX_TEMP + sensorIndex,\n                                Double.parseDouble(values[idx++]));\n                    }\n                }\n            }\n            break;\n\n        default:\n            break;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": true
}