{
    "generation": "import org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\n\n// Add necessary imports if they are not already present\n\nprivate void decodeFragment(Position position, String fragment) {\n\n    int dataIndex = fragment.indexOf(':');\n    if (dataIndex < 0 || dataIndex == fragment.length() - 1) {\n        // Invalid fragment format or empty data\n        return;\n    }\n\n    int index = 0;\n    String[] values = fragment.substring(dataIndex + 1).split(\";\", -1); // Use -1 limit to keep trailing empty strings\n\n    String type = fragment.substring(0, dataIndex);\n\n    switch (type) {\n        case \"GPS\":\n            // Field order: Validity;Satellites;Latitude;Longitude;Speed;Course;Altitude;HDOP;VDOP\n            if (index < values.length) { // Validity\n                position.setValid(values[index].equals(\"A\"));\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // Satellites\n                try {\n                    position.set(Position.KEY_SATELLITES, Integer.parseInt(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty() && values[index].length() > 1) { // Latitude\n                try {\n                    position.setLatitude(Double.parseDouble(values[index].substring(1)));\n                    if (values[index].charAt(0) == 'S') {\n                        position.setLatitude(-position.getLatitude());\n                    }\n                } catch (NumberFormatException | StringIndexOutOfBoundsException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty() && values[index].length() > 1) { // Longitude\n                try {\n                    position.setLongitude(Double.parseDouble(values[index].substring(1)));\n                    if (values[index].charAt(0) == 'W') {\n                        position.setLongitude(-position.getLongitude());\n                    }\n                } catch (NumberFormatException | StringIndexOutOfBoundsException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // Speed (assuming knots)\n                try {\n                    position.setSpeed(Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // Course\n                try {\n                    position.setCourse(Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // Altitude\n                try {\n                    position.setAltitude(Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // HDOP\n                try {\n                    position.set(Position.KEY_HDOP, Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // VDOP\n                try {\n                    position.set(Position.KEY_VDOP, Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            // index++; // No need to increment after the last field\n            break;\n        case \"GSM\":\n            // Field order: Reg Status;Signal Strength;MCC;MNC;LAC;CID;RSSI\n            index += 1; // skip registration status\n            index += 1; // skip signal strength (parsed later as RSSI)\n\n            Integer mcc = null, mnc = null, lac = null, cid = null, rssi = null;\n\n            if (index < values.length && !values[index].isEmpty()) {\n                try {\n                    mcc = Integer.parseInt(values[index]);\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) {\n                try {\n                    mnc = Integer.parseInt(values[index]);\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) {\n                try {\n                    lac = Integer.parseInt(values[index], 16);\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) {\n                try {\n                    cid = Integer.parseInt(values[index], 16);\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) {\n                try {\n                    rssi = Integer.parseInt(values[index]);\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            // index++; // No need to increment after the last field\n\n            if (mcc != null && mnc != null && lac != null && cid != null) {\n                position.setNetwork(new Network(CellTower.from(mcc, mnc, lac, cid, rssi)));\n            }\n            break;\n        case \"COT\":\n            // Field order: Odometer;Hours\n            if (index < values.length && !values[index].isEmpty()) { // Odometer\n                try {\n                    position.set(Position.KEY_ODOMETER, Long.parseLong(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // Hours (format H-M-S)\n                long totalSeconds = 0;\n                String[] hours = values[index].split(\"-\");\n                try {\n                    if (hours.length > 0 && !hours[0].isEmpty()) {\n                        totalSeconds += Long.parseLong(hours[0]) * 3600;\n                    }\n                    if (hours.length > 1 && !hours[1].isEmpty()) {\n                        totalSeconds += Long.parseLong(hours[1]) * 60;\n                    }\n                    if (hours.length > 2 && !hours[2].isEmpty()) {\n                        totalSeconds += Long.parseLong(hours[2]);\n                    }\n                    position.set(Position.KEY_HOURS, totalSeconds * 1000); // Stored as milliseconds\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            // index++; // No need to increment after the last field\n            break;\n        case \"ADC\":\n            // Field order: Power;Battery;ADC1;ADC2\n            if (index < values.length && !values[index].isEmpty()) { // Power\n                try {\n                    position.set(Position.KEY_POWER, Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // Battery\n                try {\n                    position.set(Position.KEY_BATTERY, Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // ADC1\n                try {\n                    position.set(Position.PREFIX_ADC + 1, Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // ADC2\n                try {\n                    position.set(Position.PREFIX_ADC + 2, Double.parseDouble(values[index]));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            // index++; // No need to increment after the last field\n            break;\n        case \"DTT\":\n            // Field order: Status;IO;Geofence1;Geofence2;EventStatus;PacketType\n            if (index < values.length && !values[index].isEmpty()) { // Status (hex)\n                try {\n                    position.set(Position.KEY_STATUS, Integer.parseInt(values[index], 16));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            if (index < values.length && !values[index].isEmpty()) { // IO (hex)\n                try {\n                    int io = Integer.parseInt(values[index], 16);\n                    position.set(Position.KEY_IGNITION, BitUtil.check(io, 0));\n                    position.set(Position.PREFIX_IN + 1, BitUtil.check(io, 1));\n                    position.set(Position.PREFIX_IN + 2, BitUtil.check(io, 2));\n                    position.set(Position.PREFIX_IN + 3, BitUtil.check(io, 3));\n                    position.set(Position.PREFIX_IN + 4, BitUtil.check(io, 4));\n                    position.set(Position.PREFIX_OUT + 1, BitUtil.check(io, 5));\n                    position.set(Position.PREFIX_OUT + 2, BitUtil.check(io, 6));\n                    position.set(Position.PREFIX_OUT + 3, BitUtil.check(io, 7));\n                } catch (NumberFormatException e) { /* ignore */ }\n            }\n            index++;\n            String geofence1 = \"\";\n            if (index < values.length) {\n                geofence1 = values[index];\n            }\n            index++;\n            String geofence2 = \"\";\n            if (index < values.length) {\n                geofence2 = values[index];\n            }\n            index++;\n            position.set(Position.KEY_GEOFENCE, geofence1 + geofence2); // Geofence (concatenation of two fields)\n\n            if (index < values.length) { // Event status\n                position.set(\"eventStatus\", values[index]);\n            }\n            index++;\n            if (index < values.length) { // Packet type (optional)\n                position.set(\"packetType\", values[index]);\n            }\n            // index++; // No need to increment after the last field\n            break;\n        case \"ETD\":\n            if (index < values.length) {\n                position.set(\"eventData\", values[index]);\n            }\n            break;\n        case \"OBD\":\n            if (index < values.length) {\n                position.set(\"obd\", values[index]);\n            }\n            break;\n        case \"TAG\":\n            if (index < values.length) {\n                position.set(\"tagData\", values[index]);\n            }\n            break;\n        case \"IWD\":\n            // Field order repeats: SensorIndex;DataType;Value(s)...\n            while (index < values.length) {\n                Integer sensorIndex = null;\n                if (index < values.length && !values[index].isEmpty()) {\n                     try {\n                        sensorIndex = Integer.parseInt(values[index]);\n                    } catch (NumberFormatException e) { /* ignore parsing error, index still increments */ }\n                }\n                index++;\n\n                Integer dataType = null;\n                if (index < values.length && !values[index].isEmpty()) {\n                    try {\n                        dataType = Integer.parseInt(values[index]);\n                    } catch (NumberFormatException e) { /* ignore parsing error, index still increments */ }\n                }\n                index++;\n\n                if (dataType == null) {\n                     // If dataType is missing or invalid, we cannot reliably parse the rest.\n                     // It's safer to break than risk misinterpreting subsequent data.\n                     break;\n                }\n\n                if (dataType == 0) { // Driver ID\n                    if (index < values.length) { // Check value exists\n                        if (sensorIndex != null) { // Only set if sensorIndex was valid\n                            position.set(Position.KEY_DRIVER_UNIQUE_ID, values[index]);\n                        }\n                    }\n                    index++;\n                } else if (dataType == 1) { // Temperature\n                    index += 1; // skip temperature sensor serial number\n                    if (index < values.length && !values[index].isEmpty()) { // Check value exists and is not empty\n                        if (sensorIndex != null) { // Only set if sensorIndex was valid\n                            try {\n                                position.set(Position.PREFIX_TEMP + sensorIndex, Double.parseDouble(values[index]));\n                            } catch (NumberFormatException e) { /* ignore */ }\n                        }\n                    }\n                    index++;\n                } else {\n                    // Unknown data type - The number of fields is unknown. Break the loop\n                    // to avoid potential ArrayIndexOutOfBoundsException or incorrect parsing.\n                    break;\n                }\n            }\n            break;\n        default:\n            // Unknown fragment type, ignore\n            break;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}