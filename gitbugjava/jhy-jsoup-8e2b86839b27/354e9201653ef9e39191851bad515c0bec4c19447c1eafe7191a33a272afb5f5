{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n    /**\n     * Check if this element should be formatted as a block element during output.\n     * The determination is made based on the element's tag type (e.g., P, DIV are block),\n     * and any style attribute overrides (e.g. style=\"display: inline;\").\n     *\n     * @param out the output settings - not used in current logic, but might be needed for future refinements.\n     * @return true if format as block, false otherwise\n     */\n    private boolean isFormatAsBlock(Document.OutputSettings out) { // Note: out param is currently unused but kept for signature compatibility\n        // Check for CSS display override in the style attribute\n        String styleAttr = attr(\"style\");\n        if (!styleAttr.isEmpty()) {\n            String styleVal = styleAttr.toLowerCase().trim();\n\n            // Regex to find \"display: inline\" rule, handling whitespace and semicolons.\n            // Pattern looks for display:inline either at the start/end of the string or bounded by semicolons.\n            // Using \\b word boundary around inline ensures it doesn't match inline-block etc.\n            Pattern inlinePattern = Pattern.compile(\"(^|;)\\\\s*display\\\\s*:\\\\s*inline\\\\b\");\n            Matcher inlineMatcher = inlinePattern.matcher(styleVal);\n            if (inlineMatcher.find()) {\n                // Check if the match is followed by a semicolon or the end of the string to ensure it's a complete rule value\n                String following = styleVal.substring(inlineMatcher.end()).trim();\n                if (following.isEmpty() || following.startsWith(\";\")) {\n                    return false; // Style dictates inline formatting.\n                }\n            }\n\n            // Regex to find \"display: block\" rule.\n            // Using \\b word boundary around block.\n            Pattern blockPattern = Pattern.compile(\"(^|;)\\\\s*display\\\\s*:\\\\s*block\\\\b\");\n            Matcher blockMatcher = blockPattern.matcher(styleVal);\n            if (blockMatcher.find()) {\n                // Check if the match is followed by a semicolon or the end of the string\n                String following = styleVal.substring(blockMatcher.end()).trim();\n                 if (following.isEmpty() || following.startsWith(\";\")) {\n                    return true; // Style dictates block formatting.\n                 }\n            }\n            \n            // Note: This simple check doesn't handle all CSS complexity (e.g., !important, multiple display properties, comments, complex selectors).\n            // It prioritizes explicit 'display: inline' or 'display: block' overrides found directly in the style attribute.\n            // Other display values like 'inline-block', 'flex', 'grid', etc., will fall through to the default tag behavior.\n        }\n\n        // No definitive 'display: inline' or 'display: block' style found.\n        // Fall back to the default formatting behavior of the tag.\n        // The original logic parts '|| (parent() != null && parent().tag().formatAsBlock())' and '|| out.outline()'\n        // were removed as they incorrectly influenced the block/inline determination based on parent or output settings.\n        return tag.formatAsBlock();\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}