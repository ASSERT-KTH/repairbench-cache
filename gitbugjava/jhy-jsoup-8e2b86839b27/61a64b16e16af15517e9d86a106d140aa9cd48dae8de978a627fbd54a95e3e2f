{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n// Note: This requires importing Pattern and Matcher from java.util.regex\n// Ideally, the Pattern should be a static final field in the class for efficiency,\n// but placing it here keeps the change contained within the function as requested.\n\n    private boolean isFormatAsBlock(Document.OutputSettings out) {\n        // Check for CSS override 'display: inline'\n        String style = attr(\"style\"); // Get the style attribute value\n        if (!style.isEmpty()) { // Optimization: only check if style attribute exists and is not empty\n            // Pattern to find 'display: inline' style - case insensitive, handles variable whitespace\n            // Compiling pattern here is less efficient than a static field, but keeps the change local.\n            Pattern displayInlinePattern = Pattern.compile(\"display\\\\s*:\\\\s*inline\\\\s*;?\", Pattern.CASE_INSENSITIVE);\n            Matcher matcher = displayInlinePattern.matcher(style);\n            if (matcher.find()) {\n                // If 'display: inline' is found in the style attribute, treat as inline for formatting.\n                return false;\n            }\n        }\n\n        // If no 'display: inline' override, use the original logic:\n        // Formats as block if the tag is inherently block, or the parent is block,\n        // or outline mode is enabled (which implies block-like formatting).\n        return tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline();\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}