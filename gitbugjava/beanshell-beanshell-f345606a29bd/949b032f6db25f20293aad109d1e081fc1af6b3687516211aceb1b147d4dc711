{
    "generation": "    /** Binary operations on arbitrary objects.\n     * @param lhs left hand side value\n     * @param rhs right hand side value\n     * @param kind operator type\n     * @return operator applied value\n     * @throws UtilEvalError evaluation error */\n    @SuppressWarnings(\"unchecked\")\n    public static Object arbitraryObjectsBinaryOperation(\n        Object lhs, Object rhs, int kind)\n        throws UtilEvalError\n    {\n        if ( kind == EQ )\n            return (lhs == rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( kind == NE )\n            return (lhs != rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( lhs == Primitive.VOID || rhs == Primitive.VOID )\n            throw new UtilEvalError(\n                \"illegal use of undefined variable, class, or\"\n                    + \" 'void' literal\");\n        if (kind == SPACESHIP) {\n            int comp = 0; // used to ensure only -1, 0, and 1 is returned.\n            if (lhs instanceof Comparable || rhs instanceof Comparable)\n                comp = Comparator.nullsFirst( // nullsFirst Comparable Comparator\n                    Comparator.<Comparable<Object>>naturalOrder())\n                        .compare((Comparable<Object>)Primitive.unwrap(lhs),\n                            (Comparable<Object>)Primitive.unwrap(rhs));\n            else\n                comp = Comparator.nullsFirst( // nullsFirst toString Comparator\n                    Comparator.comparing(Object::toString))\n                    .compare(Primitive.unwrap(lhs), Primitive.unwrap(rhs));\n            return Primitive.wrap(comp < 0 ? -1 : comp > 0 ? 1 : 0, Integer.TYPE);\n        }\n        if ( kind == PLUS ) {\n            // String concatenation operation\n            if ( lhs instanceof String || rhs instanceof String )\n                return lhs.toString() + rhs.toString();\n            // array concatenation operation\n            if ( lhs.getClass().isArray() && rhs instanceof List )\n                rhs = ((List<?>) rhs).toArray();\n            if ( lhs.getClass().isArray()\n                    && rhs.getClass().isArray() )\n                return BshArray.concat(lhs, rhs);\n            // list concatenation operation\n            if ( lhs instanceof List && rhs.getClass().isArray() )\n                rhs = Types.castObject(rhs, List.class, Types.CAST);\n            if ( lhs instanceof List && rhs instanceof List )\n                return BshArray.concat(\n                        (List<?>) lhs, (List<?>) rhs);\n        }\n        if ( kind == STAR ) {\n            // array repeat operation\n            if ( lhs.getClass().isArray() )\n                return BshArray.repeat(lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs.getClass().isArray() )\n                return BshArray.repeat(rhs,\n                        (int) Primitive.unwrap(lhs));\n            // List repeat operation\n            if ( lhs instanceof List )\n                return BshArray.repeat((List<Object>) lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs instanceof List )\n                return BshArray.repeat((List<Object>) rhs,\n                        (int) Primitive.unwrap(lhs));\n        }\n        if ( lhs instanceof String || rhs instanceof String )\n            throw new UtilEvalError(\n                \"Use of non + operator with String\" );\n        if ( lhs.getClass().isArray() || rhs.getClass().isArray()\n               || lhs instanceof List || rhs instanceof List)\n            throw new UtilEvalError(\n                \"Use of invalid operator \" + tokenImage[kind]\n                    + \" with array or List type\" );\n        if ( lhs == Primitive.NULL || rhs == Primitive.NULL )\n            throw new UtilEvalError(\n                \"illegal use of null value or 'null' literal\");\n        throw new UtilEvalError(\"Operator: \" + tokenImage[kind]\n                    + \" inappropriate for objects\");\n    }\n\n    /** Binary operations on arbitrary objects.\n     * @param lhs left hand side value\n     * @param rhs right hand side value\n     * @param kind operator type\n     * @return operator applied value\n     * @throws UtilEvalError evaluation error */\n    @SuppressWarnings(\"unchecked\")\n    public static Object arbitraryObjectsBinaryOperation(\n        Object lhs, Object rhs, int kind)\n        throws UtilEvalError\n    {\n        if ( kind == EQ )\n            return (lhs == rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( kind == NE )\n            return (lhs != rhs) ? Primitive.TRUE : Primitive.FALSE;\n        if ( lhs == Primitive.VOID || rhs == Primitive.VOID )\n            throw new UtilEvalError(\n                \"illegal use of undefined variable, class, or\"\n                    + \" 'void' literal\");\n        if (kind == SPACESHIP) {\n            int comp = 0; // used to ensure only -1, 0, and 1 is returned.\n            if (lhs instanceof Comparable || rhs instanceof Comparable)\n                comp = Comparator.nullsFirst( // nullsFirst Comparable Comparator\n                    Comparator.<Comparable<Object>>naturalOrder())\n                        .compare((Comparable<Object>)Primitive.unwrap(lhs),\n                            (Comparable<Object>)Primitive.unwrap(rhs));\n            else\n                comp = Comparator.nullsFirst( // nullsFirst toString Comparator\n                    Comparator.comparing(Object::toString))\n                    .compare(Primitive.unwrap(lhs), Primitive.unwrap(rhs));\n            return Primitive.wrap(comp < 0 ? -1 : comp > 0 ? 1 : 0, Integer.TYPE);\n        }\n        if ( kind == PLUS ) {\n            // array concatenation operation\n            if ( lhs.getClass().isArray() && rhs instanceof List )\n                rhs = ((List<?>) rhs).toArray();\n            if ( lhs.getClass().isArray()\n                    && rhs.getClass().isArray() )\n                return BshArray.concat(lhs, rhs);\n            // list concatenation operation\n            if ( lhs instanceof List && rhs.getClass().isArray() )\n                rhs = Types.castObject(rhs, List.class, Types.CAST);\n            if ( lhs instanceof List && rhs instanceof List )\n                return BshArray.concat(\n                        (List<?>) lhs, (List<?>) rhs);\n        }\n        if ( kind == STAR ) {\n            // array repeat operation\n            if ( lhs.getClass().isArray() )\n                return BshArray.repeat(lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs.getClass().isArray() )\n                return BshArray.repeat(rhs,\n                        (int) Primitive.unwrap(lhs));\n            // List repeat operation\n            if ( lhs instanceof List )\n                return BshArray.repeat((List<Object>) lhs,\n                        (int) Primitive.unwrap(rhs));\n            if ( rhs instanceof List )\n                return BshArray.repeat((List<Object>) rhs,\n                        (int) Primitive.unwrap(lhs));\n        }\n        if ( lhs instanceof String || rhs instanceof String )\n            throw new UtilEvalError(\n                \"Use of non + operator with String\" );\n        if ( lhs.getClass().isArray() || rhs.getClass().isArray()\n               || lhs instanceof List || rhs instanceof List)\n            throw new UtilEvalError(\n                \"Use of invalid operator \" + tokenImage[kind]\n                    + \" with array or List type\" );\n        if ( lhs == Primitive.NULL || rhs == Primitive.NULL )\n            throw new UtilEvalError(\n                \"illegal use of null value or 'null' literal\");\n        throw new UtilEvalError(\"Operator: \" + tokenImage[kind]\n                    + \" inappropriate for objects\");\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}