{
    "generation": "import org.apache.commons.math.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.exception.MathRuntimeException;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\n\n// NOTE: Assuming the existence of Vector3D and supporting classes/methods\n// like getNormSq, dotProduct, crossProduct, subtract, orthogonal, getX, getY, getZ.\n// Assuming Rotation class has fields q0, q1, q2, q3 to be set by the constructor.\n\n// --- Start of the fixed function ---\n  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero or\n   * if the vectors are incompatible (e.g. collinearity mismatch).\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // Constants for threshold checks to avoid numerical instability\n    final double NORM_EPSILON = 1e-15; // Threshold for squared norm checks (avoid division by zero)\n    final double C_EPSILON = 1e-15;    // Threshold for checking if coefficient c is zero\n    final double K_NORM_SQ_EPSILON = 1e-16; // Threshold for checking if qv x uRef norm squared is zero\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n\n    // Check for zero norm vectors\n    if ((u1u1 < NORM_EPSILON) || (u2u2 < NORM_EPSILON) || (v1v1 < NORM_EPSILON) || (v2v2 < NORM_EPSILON)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // Adjust v1 to match the norm of u1\n    // v1_adj = v1 * sqrt(|u1|^2 / |v1|^2)\n    Vector3D v1_adj = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n    // Store the squared norm of adjusted v1; theoretically it's exactly u1u1.\n    // Using u1u1 avoids potential small errors from sqrt/square operations.\n    final double v1_adj_v1_adj = u1u1;\n\n    // Adjust v2 to preserve the geometric relationship with v1_adj, analogous to u1/u2\n    // We want |v2_adj|^2 = |u2|^2 and v1_adj . v2_adj = u1 . u2\n    final double u1u2 = u1.dotProduct(u2);\n    final double v1v2 = v1_adj.dotProduct(v2); // Use adjusted v1 and original v2\n\n    // Compute coefficients based on Gram-Schmidt orthogonalization idea\n    final double coeffU = u1u2 / u1u1;\n    final double coeffV = v1v2 / v1_adj_v1_adj; // Use v1_adj_v1_adj == u1u1\n\n    // Compute squared norms of components orthogonal to u1 and v1_adj respectively\n    // These are related to |u|^2 * sin^2(angle) and should be non-negative\n    final double normU2_orth_sq = u2u2 - u1u2 * coeffU;\n    final double normV2_orth_sq = v2v2 - v1v2 * coeffV;\n\n    // Check for collinearity: if v1_adj and v2 are collinear, normV2_orth_sq is near zero.\n    if (normV2_orth_sq < NORM_EPSILON) {\n        // If u1 and u2 are also collinear, the rotation might be identity or 180 degrees.\n        if (normU2_orth_sq < NORM_EPSILON) {\n            // Both pairs are collinear. Determine rotation based on relative orientation of u1 and v1_adj.\n            if (v1_adj.dotProduct(u1) < 0) { // Check if they point in opposite directions\n                // 180 degree rotation. Need an axis orthogonal to u1.\n                Vector3D axis = u1.orthogonal();\n                double normAxisSq = axis.getNormSq();\n                // Ensure axis is non-zero (u1 cannot be zero here)\n                if (normAxisSq < NORM_EPSILON) {\n                     // Fallback if orthogonal somehow yields zero vector (highly unlikely for non-zero u1)\n                     // Choose an arbitrary axis, ensuring it's not parallel to u1 if possible.\n                     if ((FastMath.abs(u1.getX()) < NORM_EPSILON) && (FastMath.abs(u1.getY()) < NORM_EPSILON)) {\n                         axis = Vector3D.PLUS_I; // If u1 is Z-axis, pick X-axis\n                     } else {\n                         axis = Vector3D.PLUS_K; // Otherwise, pick Z-axis\n                     }\n                     normAxisSq = 1.0;\n                }\n                // Normalize the axis vector for the quaternion representation\n                double invNorm = 1.0 / FastMath.sqrt(normAxisSq);\n                q0 = 0.0; // q0 = cos(180/2) = 0\n                q1 = invNorm * axis.getX();\n                q2 = invNorm * axis.getY();\n                q3 = invNorm * axis.getZ();\n            } else {\n                // Vectors are aligned (or nearly aligned) -> Identity rotation\n                q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; // Identity\n            }\n            return; // Rotation determined, exit early.\n        } else {\n            // v1,v2 are collinear but u1,u2 are not. The required transformation is impossible for a rotation.\n            throw MathRuntimeException.createIllegalArgumentException(\n                    LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR, // Reusing error code, consider a more specific one\n                    \"Input vectors are incompatible: v1, v2 are collinear but u1, u2 are not\");\n        }\n    }\n\n    // Calculate beta, ensuring the numerator is non-negative (due to potential floating point errors)\n    final double betaNum = FastMath.max(0, normU2_orth_sq);\n    final double beta = FastMath.sqrt(betaNum / normV2_orth_sq);\n    // Calculate alpha\n    final double alpha = coeffU - beta * coeffV;\n    // Compute the adjusted v2 vector\n    final Vector3D v2_adj = new Vector3D(alpha, v1_adj, beta, v2);\n\n    // --- Compute rotation quaternion components ---\n\n    // Choose initial reference vectors (u1, v1_adj)\n    Vector3D uRef = u1;\n    Vector3D vRef = v1_adj; // Use adjusted v1\n\n    // Compute auxiliary vectors (cross products)\n    final Vector3D u3 = u1.crossProduct(u2);\n    final Vector3D v3_adj = Vector3D.crossProduct(v1_adj, v2_adj); // Use adjusted v1, v2\n\n    // Compute vector related to rotation axis using the first pair difference cross product\n    final Vector3D v1Su1 = v1_adj.subtract(u1);\n    final Vector3D v2Su2 = v2_adj.subtract(u2);\n    Vector3D k_axis = v1Su1.crossProduct(v2Su2); // This vector is related to qv * sin(theta)\n\n    // Compute coefficient 'c', related to rotation angle. Dot product with u3 normalizes.\n    double c = k_axis.dotProduct(u3);\n\n    // Check for degenerate cases where the computed axis is unstable (lies in plane of vectors)\n    if (FastMath.abs(c) < C_EPSILON) {\n        // Try using the pair (u1, u3) and their adjusted images (v1_adj, v3_adj)\n        final Vector3D v3Su3 = v3_adj.subtract(u3);\n        k_axis = v1Su1.crossProduct(v3Su3);\n        // Use reference normal u3 x u1 (corresponds to u2 direction in right-handed frame u1,u2,u3)\n        final Vector3D u2Prime = u3.crossProduct(u1);\n        c = k_axis.dotProduct(u2Prime);\n\n        // Check if still degenerate (axis might be aligned with u1)\n        if (FastMath.abs(c) < C_EPSILON) {\n            // Try using the pair (u2, u3) and their adjusted images (v2_adj, v3_adj)\n            k_axis = v2Su2.crossProduct(v3Su3);\n            // Use reference normal u2 x u3 (corresponds to u1 direction in right-handed frame u2,u3,u1)\n            final Vector3D u1Prime = u2.crossProduct(u3);\n            c = k_axis.dotProduct(u1Prime);\n\n            // Check if still degenerate (implies axis aligned with everything -> Identity or 180 deg)\n            if (FastMath.abs(c) < C_EPSILON) {\n                // Handle final degenerate case: Identity or 180 rotation\n                if (v1_adj.dotProduct(u1) < 0) { // Check orientation using adjusted v1\n                     // 180 deg rotation. Compute axis orthogonal to u1.\n                    Vector3D axis = u1.orthogonal();\n                    double normAxisSq = axis.getNormSq();\n                     if (normAxisSq < NORM_EPSILON) { // Fallback if orthogonal fails\n                         if ((FastMath.abs(u1.getX()) < NORM_EPSILON) && (FastMath.abs(u1.getY()) < NORM_EPSILON)) {\n                             axis = Vector3D.PLUS_I;\n                         } else {\n                             axis = Vector3D.PLUS_K;\n                         }\n                         normAxisSq = 1.0;\n                     }\n                    double invNorm = 1.0 / FastMath.sqrt(normAxisSq);\n                    q0 = 0.0; q1 = invNorm * axis.getX(); q2 = invNorm * axis.getY(); q3 = invNorm * axis.getZ();\n                } else {\n                    q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; // Identity\n                }\n                return; // Exit early\n            }\n            // If third attempt succeeded, use u2/v2_adj as reference vectors for q0 calculation\n            uRef = u2;\n            vRef = v2_adj;\n        }\n        // else: Second attempt succeeded, use uRef=u1, vRef=v1_adj (default)\n    }\n    // else: First attempt succeeded, use uRef=u1, vRef=v1_adj (default)\n\n    // compute the vectorial part qv = (q1, q2, q3) of the quaternion\n    boolean flipped = false;\n    // If c < 0, the formula requires sqrt(|c|), and the sign might affect qv direction.\n    if (c < 0) {\n        // Use sqrt of absolute value. Remember to potentially flip the sign of qv.\n        c = FastMath.sqrt(-c);\n        flipped = true;\n    } else {\n        c = FastMath.sqrt(c);\n    }\n\n    // If c is near zero after sqrt, it indicates near-identity or numerical issues.\n    // This should ideally be caught by abs(c) < C_EPSILON checks earlier. Add safeguard.\n    if (c < C_EPSILON) {\n        q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; return; // Default to identity\n    }\n\n    // Calculate normalization factor for qv components\n    double inv = 1.0 / (c + c);\n    // Compute qv components, flipping sign if c was negative (heuristic based on common derivations)\n    q1 = inv * k_axis.getX();\n    q2 = inv * k_axis.getY();\n    q3 = inv * k_axis.getZ();\n    if (flipped) {\n        q1 = -q1; q2 = -q2; q3 = -q3;\n    }\n\n    // compute the scalar part q0 using the robust formula derived from Rodrigues' rotation formula:\n    // q0 = [ (v - u) . (qv x u) ] / (2 * |qv x u|^2)\n    // This avoids the issues with the original formula used for q0 calculation.\n    Vector3D qv = new Vector3D(q1, q2, q3);\n    Vector3D k = qv.crossProduct(uRef); // k = qv x uRef (vector perpendicular to axis and uRef)\n    double kNormSq = k.getNormSq(); // |qv x uRef|^2\n\n    // Check if uRef is aligned with the rotation axis qv (|qv x uRef|^2 is near zero)\n    if (kNormSq < K_NORM_SQ_EPSILON) {\n        // If uRef is aligned with axis, the formula for q0 is indeterminate (0/0).\n        // Try using the other vector pair (uOther, vOther) which should not be aligned if u1, u2 are not collinear.\n        Vector3D uOther, vOther;\n        if (uRef == u1) { uOther = u2; vOther = v2_adj; } else { uOther = u1; vOther = v1_adj; }\n        k = qv.crossProduct(uOther); // k = qv x uOther\n        kNormSq = k.getNormSq();\n\n        // Check if the other vector is also aligned (implies u1, u2 collinear, handled earlier ideally)\n        if (kNormSq < K_NORM_SQ_EPSILON) {\n            // Both u1 and u2 seem aligned with qv axis. Should correspond to Identity or 180 deg.\n            // This case indicates collinear input vectors, which should have been handled.\n            // As a fallback, re-check dot product.\n            if (v1_adj.dotProduct(u1) < 0) {\n                q0 = 0.0; // Assume 180 deg rotation; qv computed earlier is the axis (needs normalization)\n            } else {\n                q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; // Assume Identity rotation\n            }\n        } else {\n            // Use the 'other' pair (uOther, vOther) to compute q0, as it's not aligned with axis.\n            q0 = (vOther.subtract(uOther)).dotProduct(k) / (2 * kNormSq);\n        }\n    } else {\n        // uRef was not aligned with axis, compute q0 using uRef, vRef and the formula.\n        q0 = (vRef.subtract(uRef)).dotProduct(k) / (2 * kNormSq);\n    }\n\n    // Final step: Normalize the quaternion (q0, q1, q2, q3) to ensure it's a unit quaternion.\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm < NORM_EPSILON) {\n        // If norm is zero (or very close), indicates an issue. Default to identity rotation.\n        q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0;\n    } else {\n        // Perform normalization\n        double invNorm = 1.0 / norm;\n        q0 *= invNorm;\n        q1 *= invNorm;\n        q2 *= invNorm;\n        q3 *= invNorm;\n    }\n  }\n// --- End of the fixed function ---\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}