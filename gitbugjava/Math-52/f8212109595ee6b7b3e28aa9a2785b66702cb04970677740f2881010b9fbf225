{
    "generation": "import org.apache.commons.math.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.MathRuntimeException;\n\n// Assuming the context of the Rotation class with fields q0, q1, q2, q3\n// and appropriate definitions for MathRuntimeException and LocalizedFormats.\n\n/** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero,\n   * or if rotation is not vectorial (e.g. mapping non-collinear to collinear)\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // fields of the Rotation class\n    double q0, q1, q2, q3;\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize v1 in order to have (v1'|v1') = (u1|u1)\n    Vector3D v1_scaled = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n    double u1u2   = u1.dotProduct(u2);\n    // Use v1_scaled for dot product, and original v2 for normsq and linear combination\n    double v1v2   = v1_scaled.dotProduct(v2);\n    double coeffU = u1u2 / u1u1;\n    double coeffV = v1v2 / u1u1; // Denominator is u1u1 = |v1_scaled|^2\n    // Muv_num / u1u1 = |u1 x u2|^2 / u1u1^2\n    double Muv_num = u2u2 - u1u2 * coeffU;\n    // Muv_den / u1u1 = |v1_scaled x v2_orig|^2 / u1u1^2\n    double Muv_den = v2v2 - v1v2 * coeffV;\n\n    double beta;\n    // Check if v1_scaled and v2 are collinear (denominator is zero)\n    // We use a small tolerance since norms are involved.\n    final double V1V2_EPS = 1.0e-15; // Tolerance for collinearity check\n    if (FastMath.abs(Muv_den) < V1V2_EPS * v2v2 * u1u1) { // Relative tolerance check\n        // Check if u1 and u2 are also collinear\n        if (FastMath.abs(Muv_num) < V1V2_EPS * u2u2 * u1u1) { // Relative tolerance check\n             // Both pairs collinear. The angle constraint is trivially satisfied.\n             // Beta is indeterminate; v2 adjustment is not uniquely defined.\n             // Set beta = 0, implying v2_adjusted = alpha * v1_scaled.\n             // This effectively ignores v2 and defines rotation based on u1 -> v1_scaled.\n             beta = 0.0;\n        } else { // Denominator zero, numerator non-zero (v1,v2 collinear, u1,u2 not)\n             // Cannot map non-collinear pair to a collinear one preserving angles/norms.\n             // Note: LocalizedFormats.ROTATION_NOT_VECTORIAL might need to be defined\n             throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ROTATION_NOT_VECTORIAL);\n        }\n    } else { // Denominator is non-zero\n        // beta^2 = Muv_num / Muv_den\n        double arg = Muv_num / Muv_den;\n        // Clamp argument before sqrt for numerical stability (can be slightly < 0)\n        beta = FastMath.sqrt(FastMath.max(0.0, arg));\n    }\n\n    double alpha  = coeffU - beta * coeffV;\n    Vector3D v2_adjusted = new Vector3D(alpha, v1_scaled, beta, v2); // Uses original v2 in combination\n\n    // preliminary computation\n    Vector3D uRef  = u1;\n    Vector3D vRef  = v1_scaled; // Use scaled v1\n    Vector3D v1Su1 = v1_scaled.subtract(u1);\n    Vector3D v2Su2 = v2_adjusted.subtract(u2); // Use adjusted v2\n    Vector3D k     = v1Su1.crossProduct(v2Su2);\n    Vector3D u3    = u1.crossProduct(u2);\n    double c_dot   = k.dotProduct(u3); // Store dot product with sign\n\n    // Check for degenerate cases using a tolerance\n    final double C_DOT_EPS = 1e-15;\n    if (FastMath.abs(c_dot) < C_DOT_EPS) {\n      // Degenerate cases\n      Vector3D v3 = Vector3D.crossProduct(v1_scaled, v2_adjusted);\n      Vector3D v3Su3 = v3.subtract(u3);\n      k = v1Su1.crossProduct(v3Su3);\n      Vector3D u2Prime = u1.crossProduct(u3);\n      c_dot = k.dotProduct(u2Prime); // Update c_dot\n\n      if (FastMath.abs(c_dot) < C_DOT_EPS) {\n        k = v2Su2.crossProduct(v3Su3);\n        Vector3D u1Prime = u2.crossProduct(u3);\n        c_dot = k.dotProduct(u1Prime); // Update c_dot\n\n        if (FastMath.abs(c_dot) < C_DOT_EPS) {\n          // All attempts failed, implies identity rotation\n          this.q0 = 1.0; this.q1 = 0.0; this.q2 = 0.0; this.q3 = 0.0;\n          return;\n        }\n        // Use u2/v2 for reference if third case succeeded (ref vectors not used here, kept for consistency with original)\n        // uRef = u2; // Not needed for the chosen q0 calculation method\n        // vRef = v2_adjusted;\n      }\n    }\n\n    // compute the vectorial part\n    double kNormSq = k.getNormSq();\n    double c_abs = FastMath.abs(c_dot);\n\n    // Check for numerical issues where c_dot or k is near zero after checks\n    if (c_abs == 0.0 || kNormSq == 0.0) {\n        // Should be caught by degenerate checks, fallback to identity for safety\n         this.q0 = 1.0; this.q1 = 0.0; this.q2 = 0.0; this.q3 = 0.0; return;\n    }\n\n    double c_abs_sqrt = FastMath.sqrt(c_abs);\n    double inv = 0.5 / c_abs_sqrt; // 1.0 / (2 * sqrt(|c_dot|))\n    q1 = inv * k.getX();\n    q2 = inv * k.getY();\n    q3 = inv * k.getZ();\n\n    // compute the scalar part using normalization and sign of c_dot\n    double q1q1 = q1 * q1;\n    double q2q2 = q2 * q2;\n    double q3q3 = q3 * q3;\n    // Ensure q0^2 is non-negative due to potential numerical errors in q1,q2,q3\n    double q0q0 = FastMath.max(0.0, 1.0 - q1q1 - q2q2 - q3q3);\n    q0 = FastMath.sqrt(q0q0);\n\n    // Apply the sign correction based on the sign of c_dot\n    if (c_dot < 0.0) {\n        q0 = -q0;\n    }\n\n    // Assign computed values to the fields\n    this.q0 = q0;\n    this.q1 = q1;\n    this.q2 = q2;\n    this.q3 = q3;\n\n    // Optional: Explicitly re-normalize for perfect unit norm, though often not strictly needed\n    // double norm = FastMath.sqrt(this.q0 * this.q0 + this.q1 * this.q1 + this.q2 * this.q2 + this.q3 * this.q3);\n    // if (norm == 0) { // Should not happen with valid inputs and checks\n    //     this.q0 = 1.0; this.q1 = 0.0; this.q2 = 0.0; this.q3 = 0.0;\n    // } else {\n    //     double normInv = 1.0 / norm;\n    //     this.q0 *= normInv;\n    //     this.q1 *= normInv;\n    //     this.q2 *= normInv;\n    //     this.q3 *= normInv;\n    // }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}