{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    final double u1u1 = u1.getNormSq();\n    final double u2u2 = u2.getNormSq();\n    final double v1v1 = v1.getNormSq();\n    final double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize v1 in order to have (v1'|v1') = (u1|u1)\n    final Vector3D v1p = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n    final double v1pv1p = v1p.getNormSq(); // Use this for consistency, should be approx u1u1\n\n    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n    final double u1u2   = u1.dotProduct(u2);\n    final double v1pv2  = v1p.dotProduct(v2); // Use v1p here\n    final double coeffU = u1u2 / u1u1;\n    // Handle potential division by zero if v1pv1p is zero (e.g., due to massive underflow)\n    final double coeffV = (v1pv1p == 0) ? 0.0 : v1pv2 / v1pv1p;\n\n    final double betaDenom = v2v2 - v1pv2 * coeffV;\n    final double betaNum   = u2u2 - u1u2 * coeffU;\n    final double betaArg;\n\n    // Check for potential issues: negative sqrt argument or division by zero/very small number\n    // This might happen with collinear vectors or numerical instability\n    // Use a tolerance related to the vector norms\n    final double normTolerance = 1e-15; // A small tolerance value\n    if (betaNum < 0 && betaNum > -normTolerance * u1u1 * u2u2) {\n         // Clamp small negative values possibly due to floating point errors\n         betaNum = 0.0;\n    }\n\n    if (betaNum < 0) {\n        // If betaNum is significantly negative, vectors u1, u2 might be problematic\n        // Or the geometry is inconsistent. The original code didn't check this.\n        // Throwing an error might be more appropriate for ill-defined input.\n        // As a minimal fix, prevent NaN from sqrt: set betaArg = 0, leading to beta=0.\n        // This might not produce the intended rotation but avoids NaN.\n        betaArg = 0.0;\n    } else if (FastMath.abs(betaDenom) < normTolerance * v1v1 * v2v2) {\n        // Denominator is close to zero. This happens if v1p and v2 are nearly collinear.\n        if (betaNum < normTolerance * u1u1 * u2u2) {\n            // Numerator is also close to zero (u1, u2 nearly collinear). Beta is indeterminate (0/0).\n            // Set beta to 0 as a plausible fallback.\n            betaArg = 0.0;\n        } else {\n            // Numerator is non-zero, denominator is zero. This implies infinite beta.\n            // Geometrically inconsistent input. Original code would produce Infinity/NaN.\n            // Throw error or fallback? Fallback to beta=0 to avoid NaN/Infinity.\n            betaArg = 0.0; // Or potentially throw new MathIllegalArgumentException(...)\n        }\n    } else {\n         betaArg = betaNum / betaDenom;\n    }\n\n\n    final double beta  = FastMath.sqrt(betaArg);\n    final double alpha = coeffU - beta * coeffV;\n    final Vector3D v2p = new Vector3D(alpha, v1p, beta, v2);\n\n    // preliminary computation\n    final Vector3D v1Su1 = v1p.subtract(u1);\n    final Vector3D v2Su2 = v2p.subtract(u2);\n    Vector3D k     = v1Su1.crossProduct(v2Su2);\n    final Vector3D u3    = u1.crossProduct(u2);\n    final double u3Norm = u3.getNorm();\n    double kNorm = k.getNorm();\n    double c       = k.dotProduct(u3);\n\n    // Use a relative tolerance for zero check based on norms\n    final double zeroTol = 1.0e-15; // Tolerance for checking if dot product is effectively zero\n\n    if (FastMath.abs(c) < zeroTol * kNorm * u3Norm) {\n      final Vector3D v3 = Vector3D.crossProduct(v1p, v2p);\n      final Vector3D v3Su3 = v3.subtract(u3);\n      k = v1Su1.crossProduct(v3Su3); // Reuse k\n      final Vector3D u2Prime = u1.crossProduct(u3); // u3 = u1 x u2\n      kNorm = k.getNorm(); // Update kNorm\n      final double u2PrimeNorm = u2Prime.getNorm();\n      c = k.dotProduct(u2Prime); // Reuse c\n\n      if (FastMath.abs(c) < zeroTol * kNorm * u2PrimeNorm) {\n        k = v2Su2.crossProduct(v3Su3); // Reuse k\n        // Note: original code uses u2.crossProduct(u3) here, which is u2 x (u1 x u2) = u1*(u2.u2) - u2*(u2.u1)\n        // Let's call this u1Prime for clarity in the dot product check.\n        final Vector3D u1Prime = u2.crossProduct(u3);\n        kNorm = k.getNorm(); // Update kNorm\n        final double u1PrimeNorm = u1Prime.getNorm();\n        c = k.dotProduct(u1Prime); // Reuse c\n\n        if (FastMath.abs(c) < zeroTol * kNorm * u1PrimeNorm) {\n          // Identity rotation\n          q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; return;\n        }\n        // Case where third choice of k worked is intentionally falling through to use this k and c\n      }\n       // Case where second choice of k worked is intentionally falling through to use this k and c\n    }\n     // Case where first choice of k worked is intentionally falling through to use this k and c\n\n    // compute the vectorial part q = (q1, q2, q3)\n    // Fix potential NaN from sqrt of negative c by using abs(c)\n    final double absC = FastMath.abs(c);\n    final double cSqrt = FastMath.sqrt(absC);\n\n    // Check if cSqrt is numerically zero\n    // Use a tolerance relative to kNorm? If k is zero, c is zero.\n    // If k is non-zero, check if c is disproportionately small.\n    // If c was deemed non-zero in the checks above, cSqrt should be non-zero too.\n    // However, check for safety against division by zero.\n    if (cSqrt < zeroTol * kNorm) { // Use a tolerance, e.g., related to kNorm or absolute small value\n        // c is effectively zero, implies identity rotation or degenerate input.\n        // Should have been caught by the identity checks if geometry is consistent.\n        // Fallback to identity as the most likely case for numerical zero c.\n         q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; return;\n    }\n\n    final double inv = 1.0 / (cSqrt + cSqrt);\n    q1 = inv * k.getX();\n    q2 = inv * k.getY();\n    q3 = inv * k.getZ();\n\n    // compute the scalar part q0 using the robust formula q0 = sqrt(1 - |q|^2)\n    // This assumes the quaternion with non-negative scalar part is desired (angle <= pi).\n    final double qNormSq = q1 * q1 + q2 * q2 + q3 * q3;\n\n    if (qNormSq > 1.0) {\n        // Numerical errors resulted in |q|^2 > 1.\n        // This typically corresponds to a rotation angle very close to pi.\n        // Set q0 = 0 and re-normalize the vector part q to have norm 1.\n        q0 = 0.0;\n        final double norm = FastMath.sqrt(qNormSq);\n        // Avoid division by zero if norm is zero (should not happen if cSqrt was non-zero)\n        if (norm > zeroTol) { // Avoid division by zero\n            final double normInv = 1.0 / norm;\n            q1 *= normInv;\n            q2 *= normInv;\n            q3 *= normInv;\n        } else {\n            // q vector was numerically zero, but c was non-zero? Contradiction or instability.\n            // Fallback to identity.\n             q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; return;\n        }\n    } else {\n        // Normal case: q0 = sqrt(1 - |q|^2)\n        q0 = FastMath.sqrt(1.0 - qNormSq);\n    }\n\n    // Final safety check for NaN propagation (should be unlikely with the fixes)\n    if (Double.isNaN(q0) || Double.isNaN(q1) || Double.isNaN(q2) || Double.isNaN(q3)) {\n        // Should not happen if logic above is sound. Fallback to identity.\n        q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0;\n    }\n\n    // The quaternion (q0, q1, q2, q3) is now computed.\n    // The Rotation class ensures normalization if necessary upon construction/use.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}