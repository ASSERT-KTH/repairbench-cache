{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero or\n   * if the vectors u<sub>1</sub>, u<sub>2</sub> are not linearly independent while\n   * v<sub>1</sub>, v<sub>2</sub> are or vice-versa.\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // Compute tolerance for near-zero checks based on input vector magnitudes\n    // A tolerance proportional to the square root of the machine epsilon times the norms might be appropriate.\n    // Using a simpler fixed tolerance based on ULP of 1.0 for now.\n    final double epsilon = 1e-15; // Tolerance for floating point comparisons\n\n    // Keep references to original vectors\n    Vector3D u1_orig = u1;\n    Vector3D u2_orig = u2;\n    Vector3D v1_orig = v1;\n    Vector3D v2_orig = v2;\n\n    // normalize v1_orig in order to have (v1_adj|v1_adj) = (u1_orig|u1_orig)\n    Vector3D v1_adj = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1_orig);\n\n    // adjust v2_orig in order to have (u1_orig|u2_orig) = (v1_adj|v2_adj) and (v2_adj|v2_adj) = (u2_orig|u2_orig)\n    double u1u2   = u1_orig.dotProduct(u2_orig);\n\n    // Denominator for beta calculation: |v2_orig_perp_v1_orig|^2 = |v1_orig x v2_orig|^2 / |v1_orig|^2\n    double v1x v2_normSq = Vector3D.crossProduct(v1_orig, v2_orig).getNormSq();\n    double denBeta = v1x v2_normSq / v1v1;\n\n    // Numerator for beta calculation: |u2_orig_perp_u1_orig|^2 = |u1_orig x u2_orig|^2 / |u1_orig|^2\n    double u1x u2_normSq = Vector3D.crossProduct(u1_orig, u2_orig).getNormSq();\n    double numBeta = u1x u2_normSq / u1u1;\n\n    // Check for collinearity: u1 || u2 <=> |u1 x u2| ~ 0\n    boolean uParallel = (u1x u2_normSq) < (epsilon * u1u1 * u2u2);\n    // Check v1 || v2 <=> |v1 x v2| ~ 0\n    boolean vParallel = (v1x v2_normSq) < (epsilon * v1v1 * v2v2);\n\n    if (uParallel != vParallel) {\n         throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n                                                                   uParallel ? \"u1/u2 parallel, v1/v2 not\" : \"u1/u2 not parallel, v1/v2 parallel\");\n    }\n\n    Vector3D v2_adj;\n    double beta;\n    if (vParallel) { // Includes case where both are parallel (denBeta is near zero)\n        // Beta is indeterminate (0/0 if uParallel, num/0 otherwise, but that's error case).\n        // The rotation is mainly u1 -> v1_adj. Set beta=0 for calculation, logic below handles degeneracy.\n        beta = 0;\n    } else { // denBeta is significantly positive (v1,v2 not parallel)\n        // numBeta should also be positive if uParallel is false\n        numBeta = FastMath.max(0, numBeta); // Ensure non-negative due to FP\n        beta = FastMath.sqrt(numBeta / denBeta);\n    }\n\n    // Calculate alpha using adjusted v1 and original v2\n    double v1adj_v2orig = v1_adj.dotProduct(v2_orig); // v1' . v2\n    double coeffU = u1u2 / u1u1;\n    double coeffV = v1adj_v2orig / u1u1; // v1'.v2 / |v1'|^2 = v1'.v2 / u1u1\n    double alpha  = coeffU - beta * coeffV;\n    v2_adj = new Vector3D(alpha, v1_adj, beta, v2_orig);\n\n\n    // preliminary computation\n    Vector3D uRef  = u1_orig;\n    Vector3D vRef  = v1_adj;\n    Vector3D v1Su1 = v1_adj.subtract(u1_orig);\n    Vector3D v2Su2 = v2_adj.subtract(u2_orig);\n    Vector3D k     = v1Su1.crossProduct(v2Su2);\n    Vector3D u3    = Vector3D.crossProduct(u1_orig, u2_orig); // Zero vector if u1 || u2\n    double kNorm = k.getNorm();\n    double u3Norm = u3.getNorm();\n    double cNorm = kNorm * u3Norm;\n    double c       = k.dotProduct(u3);\n\n    // Use relative tolerance for c == 0 check, guarding against zero norm\n    if (cNorm == 0 || FastMath.abs(c) < (epsilon * cNorm)) {\n      Vector3D v3 = Vector3D.crossProduct(v1_adj, v2_adj);\n      Vector3D v3Su3 = v3.subtract(u3);\n      k = v1Su1.crossProduct(v3Su3);\n      kNorm = k.getNorm();\n      Vector3D u2Prime = Vector3D.crossProduct(u1_orig, u3);\n      double u2PrimeNorm = u2Prime.getNorm();\n      cNorm = kNorm * u2PrimeNorm;\n      c = k.dotProduct(u2Prime);\n\n      if (cNorm == 0 || FastMath.abs(c) < (epsilon * cNorm)) {\n        k = v2Su2.crossProduct(v3Su3);\n        kNorm = k.getNorm();\n        Vector3D u3Prime = Vector3D.crossProduct(u2_orig, u3);\n        double u3PrimeNorm = u3Prime.getNorm();\n        cNorm = kNorm * u3PrimeNorm;\n        c = k.dotProduct(u3Prime);\n\n        if (cNorm == 0 || FastMath.abs(c) < (epsilon * cNorm)) {\n          // Identity rotation\n          q0 = 1.0;\n          q1 = 0.0;\n          q2 = 0.0;\n          q3 = 0.0;\n          return;\n        }\n        // Use u2/v2 for scalar part calculation\n        uRef = u2_orig;\n        vRef = v2_adj;\n      }\n    }\n\n    // compute the vectorial part\n    c = FastMath.max(0.0, c); // Ensure c is non-negative\n    double cSqrt = FastMath.sqrt(c);\n\n    // Use a tolerance check for cSqrt ~ 0\n    if (cSqrt < epsilon) {\n         // If c is near zero after trying all pairs, default to identity\n         q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0;\n         return;\n    }\n\n    double inv = 1.0 / (2.0 * cSqrt);\n    q1 = inv * k.getX();\n    q2 = inv * k.getY();\n    q3 = inv * k.getZ();\n\n    // compute the scalar part\n    Vector3D q_vec = new Vector3D(q1, q2, q3);\n    double q_vec_normSq = q_vec.getNormSq();\n    Vector3D k_q0  = Vector3D.crossProduct(uRef, q_vec);\n    double normSq_k_q0 = k_q0.getNormSq();\n\n    // Check if uRef is parallel to rotation axis q_vec\n    boolean refAligned = normSq_k_q0 < (epsilon * uRef.getNormSq() * q_vec_normSq);\n\n    if (refAligned) {\n        Vector3D otherU, otherV;\n        if (uRef == u1_orig) { // Identity check\n            otherU = u2_orig; otherV = v2_adj;\n        } else { // uRef == u2_orig\n            otherU = u1_orig; otherV = v1_adj;\n        }\n\n        k_q0 = Vector3D.crossProduct(otherU, q_vec);\n        normSq_k_q0 = k_q0.getNormSq();\n\n        boolean otherAligned = normSq_k_q0 < (epsilon * otherU.getNormSq() * q_vec_normSq);\n\n        if (otherAligned) {\n            // Both u1 and u2 are aligned with rotation axis. u1 || u2.\n            // Should have resulted in c == 0 and identity return.\n            // If reached, decide between 0/180 deg rotation based on vRef vs uRef.\n             double dot = vRef.dotProduct(uRef);\n             // If q_vec is non-zero (implies rot is 180) and dot is negative:\n             if (dot < 0 && q_vec_normSq > epsilon) {\n                 q0 = 0.0; // 180 degrees rotation\n             } else {\n                 q0 = 1.0; // 0 degrees rotation (Identity)\n                 q1 = 0.0; q2 = 0.0; q3 = 0.0; // Enforce zero vector part\n             }\n        } else {\n             // If normSq_k_q0 is zero here (division by zero), it implies otherU || q_vec,\n             // which means both were aligned -> handled above. So normSq_k_q0 should be > 0.\n            if (normSq_k_q0 < epsilon) { // Avoid division by zero just in case\n                 // This case should not be reached if otherAligned check is correct. Fallback?\n                 q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; // Default to identity\n            } else {\n                // Use the other vector pair to compute q0 (with fixed sign)\n                q0 = -otherV.dotProduct(k_q0) / (2 * normSq_k_q0);\n            }\n        }\n\n    } else {\n         // If normSq_k_q0 is zero here (division by zero), it implies refAligned=true -> handled above.\n         // So normSq_k_q0 should be > 0.\n         if (normSq_k_q0 < epsilon) { // Avoid division by zero just in case\n             // This case should not be reached if refAligned check is correct. Fallback?\n             q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; // Default to identity\n         } else {\n             // Use the primary vector pair (uRef, vRef) (with fixed sign)\n             q0 = -vRef.dotProduct(k_q0) / (2 * normSq_k_q0);\n         }\n    }\n\n    // Normalize the quaternion (q0, q1, q2, q3)\n    double norm = FastMath.sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);\n    // Use a tolerance for the norm check as well\n    if (norm < epsilon) {\n       // If norm is zero, implies identity rotation was likely intended or input was degenerate\n       q0 = 1.0;\n       q1 = 0.0;\n       q2 = 0.0;\n       q3 = 0.0;\n    } else {\n       double invNorm = 1.0 / norm;\n       q0 *= invNorm;\n       q1 *= invNorm;\n       q2 *= invNorm;\n       q3 *= invNorm;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}