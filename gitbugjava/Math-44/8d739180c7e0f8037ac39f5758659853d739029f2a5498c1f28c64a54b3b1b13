{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        double currentT = interpolator.getGlobalCurrentTime();\n        resetOccurred = false; // Reset class member for this step\n\n        // initialize the events states if needed\n        if (! statesInitialized) {\n            // Initialize states at previousT using the interpolator\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        // Comparator for sorting events by time\n        final Comparator<EventState> stateComparator = new Comparator<EventState>() {\n            /** {@inheritDoc} */\n            public int compare(EventState es0, EventState es1) {\n                // handle NaN event times, ensuring they are sorted last\n                if (Double.isNaN(es0.getEventTime()) && Double.isNaN(es1.getEventTime())) {\n                    return 0;\n                } else if (Double.isNaN(es0.getEventTime())) {\n                    // Consistent sorting of NaN: Always treat NaN as larger than any number.\n                    // The orderingSign ensures that for forward integration (+1), NaN > number,\n                    // and for backward integration (-1), NaN < number (which means it comes later in time).\n                    return orderingSign;\n                } else if (Double.isNaN(es1.getEventTime())) {\n                    return -orderingSign;\n                }\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n        };\n\n        // Set to hold events occurring during the current interval being processed\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(stateComparator);\n\n        // Initial check for events over the whole step [previousT, currentT]\n        // Ensure interpolator is initially set to the full step for evaluation\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(currentT);\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                occuringEvents.add(state);\n            }\n        }\n\n        // Process events chronologically\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove(); // Remove current event from the set\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n\n            // get state at event time - clone needed for stepAccepted and potential System.arraycopy on stop\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState().clone();\n\n            // trigger the event handler's action determination (may update internal state of currentEvent)\n            currentEvent.stepAccepted(eventT, eventY); // Pass the cloned state\n            isLastStep = currentEvent.stop(); // Check if event triggers stop\n\n            // handle the step segment [previousT, eventT] using step handlers\n            for (final StepHandler handler : stepHandlers) {\n                // Pass the interpolator restricted to [previousT, eventT]\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length); // Update main state array y with state at eventT\n                return eventT; // Terminate step\n            }\n\n            // Perform reset if requested AFTER step handlers for the segment are done\n            if (currentEvent.reset(eventT, y)) { // Pass the main state array y, reset modifies it in place\n                // State y has been modified by the resetState method.\n                computeDerivatives(eventT, y, yDot); // Compute derivatives for the new state\n                resetOccurred = true;\n                return eventT; // Terminate step, signal reset\n            }\n\n            // Event handled, no reset/stop. Prepare for remaining interval.\n            previousT = eventT; // Advance start of interval for next segment/evaluation\n\n            // Check if the remaining interval is non-negligible\n            if (orderingSign * (currentT - eventT) <= 0) {\n                // Interval is zero or negative length, cannot have events. Break the loop.\n                break;\n            }\n\n            // Re-evaluate ALL events over the remaining interval [eventT, currentT]\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // Rebuild the occurring events set based on evaluation over [eventT, currentT]\n            occuringEvents.clear(); // Clear previous findings\n            for (final EventState state : eventsStates) {\n                 // Check if the event occurs in the remaining interval [eventT, currentT]\n                 if (state.evaluateStep(interpolator)) {\n                     // Add the event if it occurs strictly after the current event time.\n                     // This aims to prevent infinite loops if an event is detected exactly at eventT again.\n                     // Comparison needs to consider integration direction.\n                     if (orderingSign * (state.getEventTime() - eventT) > 0) {\n                         occuringEvents.add(state);\n                     }\n                 }\n            }\n            // Loop continues with the (potentially updated) set of occurring events\n\n        } // End of while loop for event processing\n\n        // No more events detected or handled in the interval.\n\n        // Handle the final part of the step, from last event time 'previousT' to 'currentT'\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState(); // Use state at currentT\n\n        // Notify all event states about the accepted step end time 'currentT'\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop(); // Check for stop condition at the very end\n        }\n        // Check if the end of the step coincides with the end of integration.\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        // Call step handlers for the final segment [previousT, currentT]\n        interpolator.setSoftPreviousTime(previousT); // Set bounds for the final segment\n        interpolator.setSoftCurrentTime(currentT);\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        // Step finished successfully. State y is updated implicitly by integrator later.\n\n        return currentT; // Return the original step end time\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}