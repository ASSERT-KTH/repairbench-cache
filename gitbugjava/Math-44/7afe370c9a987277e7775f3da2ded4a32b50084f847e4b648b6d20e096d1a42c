{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            resetOccurred = false;\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // trigger the event\n                interpolator.setInterpolatedTime(eventT);\n                // Get state vector at event time (don't clone, handlers should modify the main vector 'y')\n                // final double[] eventY = interpolator.getInterpolatedState(); // Original code had this\n                // Using the main state vector 'y' is more appropriate if handlers modify it via resetState\n                final double[] eventY = y; // Let's assume resetState works on y\n\n                // Update event state BEFORE checking stop/reset.\n                // The state passed to stepAccepted should be the state *before* potential reset.\n                // Cloning ensures the event state uses the pre-reset state for its internal checks.\n                currentEvent.stepAccepted(eventT, interpolator.getInterpolatedState().clone());\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // the event asked to stop integration\n                    // Update state y to the state at event time before stopping\n                    System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                // Check if the event triggers a state reset\n                // The call currentEvent.reset(eventT, y) internally calls handler.resetState(eventT, y)\n                // The issue is that EventState.reset ignores the potentially new array returned by resetState.\n                // Pass the main state vector 'y'.\n                if (currentEvent.reset(eventT, y)) {\n                    // Reset occurred. The state array y might or might not have been modified\n                    // depending on the handler's resetState implementation and EventState's behavior.\n                    // To ensure the state is correct according to the EventHandler contract,\n                    // we must get the state returned by resetState.\n                    // Workaround: Call resetState again directly, as EventState.reset doesn't propagate the result.\n                    EventHandler handler = currentEvent.getHandler();\n                    double[] newState = handler.resetState(eventT, y); // Get the actual reset state\n                    // If resetState returned a new array instance, copy it into y.\n                    // If it modified y in place, newState might be == y, but copy is safe.\n                    if (newState != y) {\n                         System.arraycopy(newState, 0, y, 0, y.length); // Update main state array y only if necessary\n                    }\n\n                    // Now y contains the post-reset state. Recompute derivatives.\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    // Integration restarts from eventT, states are implicitly synchronized by the next step start.\n                    return eventT;\n                }\n\n\n                // No reset requested by this event. Prepare handling of the remaining part of the step.\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                // Re-evaluate the event state AFTER potentially advancing time and calling step handlers\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step in the remaining interval\n                    occuringEvents.add(currentEvent);\n                }\n\n            }\n\n            // No event caused a premature return. Finish the step to currentT.\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            System.arraycopy(currentY, 0, y, 0, y.length); // Update main state vector to the final state of the step\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, y); // Update all event states with final time and state\n                isLastStep = isLastStep || state.stop(); // Check stop condition again\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the full step (or remaining part), after all events if any\n            for (StepHandler handler : stepHandlers) {\n                // Pass the interpolator finalized for the full step\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}