{
    "generation": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    // 1. Traverse constructor to determine its type.\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType instanceType = null;\n    FunctionType ct = null;\n\n    // 2. Determine constructor FunctionType (ct) and instance type.\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        // Use getNativeType from the TypeInference class context (assuming JSTypeNative exists)\n        instanceType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      } else {\n        ct = constructorType.toMaybeFunctionType();\n        // Handle NoObjectType and similar types that are FunctionType but toMaybeFunctionType returns null.\n        if (ct == null && constructorType instanceof FunctionType) {\n          ct = (FunctionType) constructorType;\n        }\n        // Ensure it's actually a constructor function.\n        if (ct != null && ct.isConstructor()) {\n          instanceType = ct.getInstanceType();\n        } else {\n          // If it's not a constructor, nullify ct so we don't use it for args.\n          ct = null;\n          // instanceType remains null, will default to UNKNOWN below.\n        }\n      }\n    }\n\n    // Fallback instance type if resolution failed or not a constructor.\n    if (instanceType == null) {\n      // Use getNativeType from the TypeInference class context\n      instanceType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n\n    // 3. Set the JSType for the 'new' expression node itself.\n    n.setJSType(instanceType);\n\n    // 4. Process arguments: Perform backward inference based on parameter types, then traverse.\n    // This follows the pattern used in traverseCall/inferFunctionArguments.\n    Node arg = constructor.getNext();\n    // Safely get the first parameter node.\n    Node param = (ct == null || ct.getParametersNode() == null) ? null : ct.getParametersNode().getFirstChild();\n    boolean isVarargs = false;\n    JSType varargsParamType = null;\n\n    while (arg != null) {\n        // Determine the type of the parameter corresponding to this argument.\n        // Default to unknown if no parameter matches (e.g., too many args, or ct was null).\n        JSType paramType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n        if (param != null) {\n            if (param.isVarArgs()) {\n                // If it's varargs, use its type for all remaining arguments.\n                paramType = param.getJSType();\n                isVarargs = true;\n                varargsParamType = paramType; // Store varargs type.\n                // Don't advance the param node; it applies to all further args.\n            } else {\n                paramType = param.getJSType();\n                param = param.getNext(); // Advance to the next parameter.\n            }\n        } else if (isVarargs) {\n            // If we've run out of declared parameters but are in varargs mode.\n            paramType = varargsParamType;\n        }\n        // Else: Param is null and not varargs, means too many arguments. paramType remains UNKNOWN.\n\n\n        // ---> Perform backward inference for the current argument <---\n        // Before traversing the argument's subtree, infer its type based on the\n        // expected parameter type. This is crucial for cases like object literals\n        // passed as arguments, where properties should be inferred.\n        // This requires calling the appropriate internal inference logic of the\n        // TypeInference class (e.g., inferSlotType, inferRecordProperty, etc.).\n        // The exact call depends on the internal API, but it must happen here.\n        // Conceptual example: scope = inferArgumentType(scope, arg, paramType);\n        if (ct != null && paramType != null && !paramType.isUnknownType()) {\n             // This step needs to correctly invoke the backward inference engine\n             // potentially via a call like 'inferSlotType' or similar on 'this' or 'scope',\n             // depending on the argument's node type (NAME, OBJECTLIT, etc).\n             // For example: scope = inferDeclaratively(scope, arg, paramType);\n             // Or specific calls based on arg.getType()...\n             // Without the exact API, we note the *need* for this step here.\n             // Let's assume the subsequent traverse call handles this implicitly\n             // if the context (expected type) is correctly set up or detectable.\n             // OR, if specific inference method needs to be called:\n             // scope = backwardInfer(scope, arg, paramType); // Placeholder for actual internal call\n        }\n\n\n        // ---> Traverse the argument node's subtree <---\n        // This processes the argument's own structure and updates the scope.\n        // If backward inference didn't happen explicitly above, this traversal\n        // needs to be able to detect the context (argument to 'new', expected type)\n        // and perform the inference within its visit methods (e.g., visitObjectLit).\n        scope = traverse(arg, scope);\n\n\n        // Move to the next argument.\n        arg = arg.getNext();\n        // Parameter node advancement is handled within the loop logic above.\n    }\n\n    // 5. Return the final scope after processing the constructor and all arguments.\n    return scope;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}