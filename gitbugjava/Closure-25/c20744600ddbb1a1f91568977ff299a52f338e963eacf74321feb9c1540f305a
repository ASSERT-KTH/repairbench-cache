{
    "generation": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    // Traverse the constructor node to determine its type.\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType instanceType = null;\n    FunctionType ct = null;\n\n    // Determine the constructor type and the instance type it produces.\n    if (constructorType != null) {\n        constructorType = constructorType.restrictByNotNullOrUndefined();\n        if (constructorType.isUnknownType()) {\n            instanceType = getNativeType(UNKNOWN_TYPE);\n        } else {\n            ct = constructorType.toMaybeFunctionType();\n            // Handle cases like NoObjectType which implement FunctionType but where\n            // toMaybeFunctionType returns null. NoObjectType can validly construct objects.\n            if (ct == null && constructorType instanceof FunctionType) {\n                // If constructorType is a NoObjectType, then toMaybeFunctionType will\n                // return null. But NoObjectType implements the FunctionType\n                // interface, precisely because it can validly construct objects.\n                ct = (FunctionType) constructorType;\n            }\n            // Check if it's actually a constructor.\n            if (ct != null && ct.isConstructor()) {\n                instanceType = ct.getInstanceType();\n            } else {\n                // If it's not a constructor or resolution failed, the instance type is unknown.\n                instanceType = getNativeType(UNKNOWN_TYPE);\n                ct = null; // Ensure we don't use parameters from a non-constructor.\n            }\n        }\n    } else {\n        // If the constructor type itself is unknown.\n        instanceType = getNativeType(UNKNOWN_TYPE);\n    }\n\n    // Set the JSType for the new expression node (e.g., 'new F()').\n    // This should ideally be the instance type, default to Unknown if null.\n    n.setJSType(instanceType != null ? instanceType : getNativeType(UNKNOWN_TYPE));\n\n    // Traverse the arguments passed to the constructor.\n    Node arg = constructor.getNext();\n    if (ct != null) { // Only perform parameter-based inference if we have a valid constructor type.\n        Iterator<Node> paramIt = ct.getParameters().iterator();\n        boolean isVarArgs = ct.isVarArgs();\n        // Note: getVarArgsType() can return null if not specified.\n        JSType varArgsType = isVarArgs ? ct.getVarArgsType() : null; \n        // Default varArgsType to Unknown if it's null but required.\n        if (isVarArgs && varArgsType == null) {\n            varArgsType = getNativeType(UNKNOWN_TYPE);\n        }\n\n        while (arg != null) {\n            JSType paramType = null;\n            if (paramIt.hasNext()) {\n                // Get the JSType associated with the parameter Node\n                // Note: getJSType() on the parameter node can be null.\n                paramType = paramIt.next().getJSType();\n            } else if (isVarArgs) {\n                paramType = varArgsType;\n            }\n\n            // Default parameter type to Unknown if resolution failed or not available.\n            if (paramType == null) {\n                paramType = getNativeType(UNKNOWN_TYPE);\n            }\n\n            // Traverse the argument node itself first to determine its type.\n            scope = traverse(arg, scope);\n\n            // Now, apply backward inference: Refine the argument's type based on\n            // the expected parameter type. Do not infer if param is void.\n            // Also, only infer onto names or GETPROP/GETELEM, as these represent L-values\n            // where the type information can be updated in the scope.\n            if (!paramType.isVoidType()) {\n                JSType argType = arg.getJSType();\n                // Check if the argument is a name or property access and has a known type.\n                if (argType != null && (arg.isName() || NodeUtil.isGet(arg))) {\n                   // Use inferQualifiedSlot which handles both NAME and GETPROP/GETELEM.\n                   // It attempts to refine the type of the slot represented by 'arg'\n                   // by meeting its current type ('argType') with the expected parameter type ('paramType').\n                   scope.inferQualifiedSlot(arg, argType, paramType);\n                }\n            }\n            arg = arg.getNext();\n        }\n    } else {\n        // If the constructor type is unknown or invalid, just traverse arguments\n        // without attempting parameter-based inference.\n        while (arg != null) {\n            scope = traverse(arg, scope);\n            arg = arg.getNext();\n        }\n    }\n\n    return scope;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}