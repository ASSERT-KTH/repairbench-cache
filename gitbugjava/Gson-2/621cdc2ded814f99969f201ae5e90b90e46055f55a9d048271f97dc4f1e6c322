{
    "generation": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n        // Return a new adapter that delegates and performs runtime checks\n        return new TypeAdapter<T2>() {\n          @Override\n          public void write(JsonWriter out, T2 value) throws IOException {\n            // Delegate writing to the original adapter. Type safety is guaranteed\n            // because the factory only returns this adapter if T2 is a subtype of T1.\n            typeAdapter.write(out, (T1) value);\n          }\n\n          @Override\n          public T2 read(JsonReader in) throws IOException {\n            // Delegate reading to the original adapter\n            T1 value = typeAdapter.read(in);\n            // Runtime check: ensure the deserialized value is assignable to the requested type T2.\n            // This is necessary because the T1 adapter might deserialize a different subtype of T1\n            // than the requested T2. For example, when T1 is Number.class and T2 is Double.class,\n            // the T1 adapter might return an Integer which cannot be cast to a Double.\n            if (value != null && !requestedType.isInstance(value)) {\n              // The type adapter created a value of the wrong type\n              // Throw ClassCastException or JsonSyntaxException? Gson throws JsonSyntaxException e.g.\n              // for wrong JsonElement type, so let's stick to that.\n              throw new JsonSyntaxException(\n                  \"Expected a \" + requestedType.getName() + \" but was \" + value.getClass().getName()\n                  + \"; synthesized type adapter failed type check\"); // Added more context to message\n            }\n            // The cast is safe because we checked isInstance()\n            return (T2) value;\n          }\n        };\n      }\n\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}