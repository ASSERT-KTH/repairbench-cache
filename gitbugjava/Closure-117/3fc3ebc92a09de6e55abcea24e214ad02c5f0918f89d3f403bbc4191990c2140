{
    "generation": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible. This is usually true when the goal\n   *     is to describe the type *of* the expression n. If false, the original\n   *     type is used, and for GETPROP nodes, an attempt is made to find the\n   *     defining type.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n\n    // The best type name is the actual type name.\n\n    // If we're analyzing a GETPROP and *not* dereferencing, the goal might be\n    // to find where the property was originally defined. Climb the prototype\n    // chain to find the owner.\n    // This is useful for messages explaining where a property originates.\n    if (!dereference && n.isGetProp()) {\n      // Safe handling of potential null base type\n      JSType baseType = getJSType(n.getFirstChild());\n      ObjectType objectType = baseType == null ? null : baseType.dereference();\n\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          // Interfaces\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // Classes\n          // Climb the prototype chain to find the owner of the property.\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // If we found the defining type, and it has a readable name (like\n        // a constructor or prototype), return the qualified property name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          // e.g., \"Foo.prototype.bar\"\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    // If it's not a GETPROP, or if we are dereferencing, or if the GETPROP\n    // logic failed to produce a name, get the type of the node n itself.\n    // This path is taken when we want the type *of* the expression n (usually when dereference=true).\n    JSType type = getJSType(n);\n\n    // Handle cases where type information is unavailable.\n    if (type == null || type.isUnknownType() || type.isAllType()) {\n      // Fallback to node's qualified name if possible.\n      String qualifiedName = n.getQualifiedName();\n      if (qualifiedName != null) {\n        return qualifiedName;\n      }\n      // TODO(b/116138134): Include node source information for better debugging.\n      // If no qualified name, return a placeholder.\n      return (type == null || type.isUnknownType()) ? \"?\" : type.toString();\n    }\n\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced; // Use the dereferenced object type\n      }\n      // If dereference resulted in null or didn't change the type, 'type' holds\n      // the best available type (original or dereferenced object type).\n      // Need null check in case original type was somehow null after initial checks\n      // or dereferenced type is null, though ideally handled by dereference().\n      if (type == null) {\n         return \"<?>\"; // Should be rare\n      }\n    }\n\n\n    // Prefer the type's toString if it represents a constructor or prototype,\n    // as these typically have readable names (e.g., \"MyClass\", \"MyClass.prototype\").\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n\n    // If the type's toString isn't helpful (e.g., for anonymous objects or\n    // complex union/function types), try the node's qualified name if available.\n    // This helps provide context for object literals or complex types.\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function signatures like \"function(string, number): boolean\".\n      return \"function\";\n    } else {\n      // Fallback to the type's toString representation for other cases\n      // (e.g., primitive types, union types, anonymous object types).\n      return type.toString();\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}