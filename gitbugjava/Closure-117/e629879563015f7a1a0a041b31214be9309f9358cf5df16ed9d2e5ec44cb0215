{
    "generation": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n\n    // The best type name is the actual type name.\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    // This is useful for messages like \"property X defined on Foo.prototype\".\n    // However, if the property is defined on the instance itself, this\n    // logic can return \"InstanceType.prop\" which might mask the actual type\n    // of the property (e.g., if this.prop is {TypeA} but defined on InstanceType).\n    // So, we only return the \"DefiningType.propName\" format if the property\n    // was found on a prototype, or the base object itself is a prototype,\n    // or we are dealing with an interface.\n    if (n.isGetProp()) {\n      Node objectNode = n.getFirstChild();\n      JSType baseType = getJSType(objectNode);\n      ObjectType objectType = baseType.dereference();\n\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        ObjectType initialObjectType = objectType; // Store the initial type\n        boolean isInterfaceProperty = false;\n\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          // Handle interfaces\n          ObjectType defininingInterface = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n          // If the property is defined on an interface, use that.\n          if (defininingInterface != null) {\n             objectType = defininingInterface;\n             isInterfaceProperty = true;\n          }\n          // interfaces have no implicit prototype in the same way classes do,\n          // so don't walk the prototype chain below.\n        } else if (!objectType.isEnumElementType()) { // Don't walk prototype chain for enum elements\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Check if the property was found on a prototype or interface.\n        // We consider it found on a prototype if the defining objectType is\n        // different from the initial objectType, OR if the initial objectType\n        // itself was a prototype. Interfaces are handled separately.\n        boolean foundOnPrototype = objectType != null && objectType != initialObjectType;\n        boolean initialIsPrototype = initialObjectType != null && initialObjectType.isFunctionPrototypeType();\n\n        boolean useDefiningType = objectType != null\n            && (isInterfaceProperty // Property was defined on an interface\n                || foundOnPrototype // Property was found on a superclass prototype\n                || initialIsPrototype); // Property is on a prototype object directly\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name based on the defining type.\n        if (useDefiningType &&\n            (objectType.getConstructor() != null || // Includes classes and interfaces\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n        // Otherwise (property found on instance, or not found, or other cases),\n        // fall through to the general logic below which uses the type of the node 'n'.\n      }\n    }\n\n    // Fallback logic: Get the type name based on the node's JSType.\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    // Prefer the type's toString if it's identifiable (constructor/prototype).\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      // Don't return \"Type.prototype\" for prototype properties accessed directly,\n      // let the qualified name logic handle it below if possible.\n      if (!(type.isFunctionPrototypeType() && n.isGetProp())) {\n          return type.toString();\n      }\n    }\n\n    // Next, try the qualified name of the node.\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      // Avoid qualified names that just refer to the prototype property of a function.\n      if (!qualifiedName.endsWith(\".prototype\")) {\n          return qualifiedName;\n      }\n    }\n\n    // Use \"function\" for unnamed function types.\n    if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    }\n\n    // Finally, use the type's toString as a last resort.\n    // This may include \".prototype\" for prototype types handled above.\n    return type.toString();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}