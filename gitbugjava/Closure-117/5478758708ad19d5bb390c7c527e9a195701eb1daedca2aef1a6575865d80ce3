{
    "generation": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\". // Note: This comment describes a behavior that might\n   *                               // be achieved for property definitions, but this\n   *                               // function primarily aims to name the *type* of the node `n`.\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n    // The best type name is the actual type name.\n    JSType type = getJSType(n);\n\n    // getJSType may return null if the node has not been typed yet.\n    // Try to use the node's qualified name in this case.\n    if (type == null) {\n      if (n.isName()) {\n        // If it's a simple name, use that.\n        return n.getString();\n      } else {\n        String qName = n.getQualifiedName();\n        // If we can't find a qualified name, return <unknown type>.\n        return qName != null ? qName : \"<unknown type>\";\n      }\n    }\n\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    // Check if the type has a clear, readable name.\n    // Constructors, prototypes, interfaces, and enums usually do.\n    // Avoid anonymous types, function literal types, and object literal types.\n    boolean isGoodType = type.isFunctionPrototypeType() ||\n        type.isEnumType() ||\n        type.isInterface() ||\n        (type.isNominalConstructorOrInterface()) || // Covers classes and named interfaces\n        (type.toObjectType() != null && type.toObjectType().getConstructor() != null\n            && !type.isFunctionType() // exclude function types\n            && !type.isOrdinaryFunction()); // exclude function types\n\n    if (isGoodType) {\n      // For enum elements, use the enum name.\n      if (type.isEnumElementType()) {\n        type = type.toMaybeEnumElementType().getEnumType();\n      }\n\n      String typeStr = type.toString();\n      // Avoid anonymous types or complex function signatures represented in the string.\n      // Check for common indicators of non-simple names.\n      if (typeStr != null && !typeStr.isEmpty() && !typeStr.contains(\"{\") && !typeStr.contains(\"function(\")) {\n        // If it looks like a real type name (e.g., \"MyClass\", \"MyInterface\", \"MyEnum\")\n        return typeStr;\n      }\n    }\n\n    // If the type name from type.toString() wasn't suitable (e.g., anonymous type),\n    // or if the type wasn't considered \"good\" initially,\n    // try the qualified name associated with the Node.\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n       // Use the qualified name as a fallback if the type name is complex/anonymous.\n       // This might be better for e.g. aliased variables or complex expressions.\n       return qualifiedName;\n    }\n\n    // If qualified name is also not available or wasn't chosen,\n    // provide a fallback based on the type's kind.\n    if (type.isFunctionType()) {\n      // Don't show complex function names for anonymous functions.\n      return \"function\";\n    }\n\n    // Final fallback: use type.toString(), even if it's complex/anonymous,\n    // or a generic placeholder if toString() is null/empty.\n    String typeStr = type.toString();\n    return (typeStr == null || typeStr.isEmpty()) ? \"type\" : typeStr;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}