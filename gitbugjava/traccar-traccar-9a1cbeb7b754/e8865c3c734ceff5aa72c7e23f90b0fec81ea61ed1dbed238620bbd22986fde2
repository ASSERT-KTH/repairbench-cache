{
    "generation": "    private List<Position> decodeBinaryE(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n        List<Position> positions = new LinkedList<>();\n\n        // Advance reader index past the initial \"$$\" and protocol type, up to the first comma\n        buf.readerIndex(buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',') + 1);\n        \n        String imei = buf.readSlice(15).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1 + 3 + 1); // Skip ',' + 'CCE' + ','\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.readUnsignedIntLE(); // remaining cache\n        int count = buf.readUnsignedShortLE();\n\n        for (int i = 0; i < count; i++) {\n            // Ensure enough bytes for the position's length and index fields\n            if (buf.readableBytes() < 4) { \n                break; // Not enough bytes for the next position header, stop processing\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            int positionStartReaderIndex = buf.readerIndex();\n            int positionLength = buf.readUnsignedShortLE(); // Length of the data part of this position block\n            buf.readUnsignedShortLE(); // Index (2 bytes)\n\n            // Calculate the expected end index for this position's data\n            int positionDataEndIndex = positionStartReaderIndex + 4 + positionLength;\n\n            // If the declared positionLength would go beyond the buffer's actual end\n            if (positionDataEndIndex > buf.writerIndex()) {\n                // This position is malformed. Consume the remaining buffer and stop.\n                buf.readerIndex(buf.writerIndex());\n                break; \n            }\n\n            // Block 1: 1-byte parameters\n            int paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                // Check if we are past the declared end of this position's data or no more readable bytes\n                if (buf.readerIndex() >= positionDataEndIndex || buf.readableBytes() < 1) break; \n                \n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) break; // Not enough for 2-byte ID\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n                \n                if (buf.readableBytes() < 1) break; // Not enough for 1-byte value\n                switch (id) {\n                    case 0x01: position.set(Position.KEY_EVENT, buf.readUnsignedByte()); break;\n                    case 0x05: position.setValid(buf.readUnsignedByte() > 0); break;\n                    case 0x06: position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); break;\n                    case 0x07: position.set(Position.KEY_RSSI, buf.readUnsignedByte()); break;\n                    case 0x14: position.set(Position.KEY_OUTPUT, buf.readUnsignedByte()); break;\n                    case 0x15: position.set(Position.KEY_INPUT, buf.readUnsignedByte()); break;\n                    case 0x47:\n                        int lockState = buf.readUnsignedByte();\n                        if (lockState > 0) {\n                            position.set(Position.KEY_LOCK, lockState == 2);\n                        }\n                        break;\n                    case 0x97: position.set(Position.KEY_THROTTLE, buf.readUnsignedByte()); break;\n                    case 0x9D: position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte()); break;\n                    case 0xFE69: position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); break;\n                    default: buf.readUnsignedByte(); break; // Consume unknown 1-byte parameter\n                }\n            }\n\n            // Block 2: 2-byte parameters\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readerIndex() >= positionDataEndIndex || buf.readableBytes() < 1) break; \n\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) break; // Not enough for 2-byte ID\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n\n                if (buf.readableBytes() < 2) break; // Not enough for 2-byte value\n                switch (id) {\n                    case 0x08: position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE())); break;\n                    case 0x09: position.setCourse(buf.readUnsignedShortLE()); break;\n                    case 0x0A: position.set(Position.KEY_HDOP, buf.readUnsignedShortLE()); break;\n                    case 0x0B: position.setAltitude(buf.readShortLE()); break;\n                    case 0x16: position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x19: position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x1A: position.set(Position.KEY_POWER, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x40: position.set(Position.KEY_EVENT, buf.readUnsignedShortLE()); break;\n                    case 0x91: case 0x92: position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShortLE()); break;\n                    case 0x98: position.set(Position.KEY_FUEL_USED, buf.readUnsignedShortLE()); break;\n                    case 0x99: position.set(Position.KEY_RPM, buf.readUnsignedShortLE()); break;\n                    case 0x9C: position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShortLE()); break;\n                    case 0x9F: position.set(Position.PREFIX_TEMP + 1, buf.readUnsignedShortLE()); break;\n                    case 0xC9: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShortLE()); break;\n                    default: buf.readUnsignedShortLE(); break; // Consume unknown 2-byte parameter\n                }\n            }\n\n            // Block 3: 4-byte parameters\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readerIndex() >= positionDataEndIndex || buf.readableBytes() < 1) break; \n\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) break; // Not enough for 2-byte ID\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n\n                if (buf.readableBytes() < 4) break; // Not enough for 4-byte value\n                switch (id) {\n                    case 0x02: position.setLatitude(buf.readIntLE() * 0.000001); break;\n                    case 0x03: position.setLongitude(buf.readIntLE() * 0.000001); break;\n                    case 0x04: position.setTime(new Date((946684800L + buf.readUnsignedIntLE()) * 1000)); break; // 2000-01-01\n                    case 0x0C: case 0x9B: position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE()); break;\n                    case 0x0D: position.set(\"runtime\", buf.readUnsignedIntLE()); break;\n                    case 0x25: position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(buf.readUnsignedIntLE())); break;\n                    case 0xA0: position.set(Position.KEY_FUEL_USED, buf.readUnsignedIntLE() * 0.001); break;\n                    case 0xA2: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedIntLE() * 0.01); break;\n                    default: buf.readUnsignedIntLE(); break; // Consume unknown 4-byte parameter\n                }\n            }\n\n            // Block 4: variable-length parameters\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readerIndex() >= positionDataEndIndex || buf.readableBytes() < 1) break; // Not even enough for ID\n\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) break; // Not enough for 2-byte ID\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n                \n                if (buf.readableBytes() < 1) { // Need at least one byte for length field\n                    break;\n                }\n                int length = buf.readUnsignedByte(); // Length of the *data* part of the parameter\n\n                // If the declared length of the data part would go beyond buffer's actual end\n                if (buf.readerIndex() + length > buf.writerIndex()) {\n                    buf.readerIndex(buf.writerIndex()); // Consume remaining buffer and stop\n                    break; // Break the inner loop for parameters\n                }\n\n                // Store current reader index as the start of the data block for this parameter\n                int dataStartIndex = buf.readerIndex();\n\n                switch (id) {\n                    case 0x2A: case 0x2B: case 0x2C: case 0x2D:\n                    case 0x2E: case 0x2F: case 0x30: case 0x31:\n                        if (length >= 3) { // Ensure enough bytes for label (1) + short (2)\n                            buf.readUnsignedByte(); // label\n                            position.set(Position.PREFIX_TEMP + (id - 0x2A), buf.readShortLE() * 0.01);\n                        }\n                        break;\n                    case 0xFE31: // Alarm data\n                        if (length >= 2) { // Ensure enough bytes for protocol (1) + type (1)\n                            buf.readUnsignedByte(); // alarm protocol\n                            buf.readUnsignedByte(); // alarm type\n                        }\n                        break;\n                    case 0xFEA8: // Battery info\n                        if (length >= 3) { // Ensure enough bytes for status (1) + level (1) + alert (1)\n                            buf.readUnsignedByte(); // battery status\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            buf.readUnsignedByte(); // battery alert\n                        }\n                        break;\n                    default:\n                        // For unknown or unparsed IDs, the data is simply skipped by the final readerIndex set.\n                        break;\n                }\n                // Always ensure the readerIndex advances exactly by the declared 'length' for the current parameter's data\n                buf.readerIndex(dataStartIndex + length);\n            }\n\n            // After parsing all parameters for this position, ensure readerIndex is at the expected end of this position's data\n            // This is crucial to correctly skip any unparsed bytes within the position block\n            // and to start reading the next position from the correct point.\n            if (buf.readerIndex() < positionDataEndIndex) {\n                 buf.readerIndex(positionDataEndIndex);\n            } else if (buf.readerIndex() > positionDataEndIndex) {\n                // This scenario means we've read more than declared by positionLength.\n                // This shouldn't happen with the current robust parameter parsing.\n                // If it does, it indicates a protocol misunderstanding or corrupt data.\n                // We'll set it to the expected end anyway, but it means data was over-read.\n                buf.readerIndex(positionDataEndIndex); // Re-align, potentially discarding data read in excess\n            }\n\n            positions.add(position);\n        }\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}