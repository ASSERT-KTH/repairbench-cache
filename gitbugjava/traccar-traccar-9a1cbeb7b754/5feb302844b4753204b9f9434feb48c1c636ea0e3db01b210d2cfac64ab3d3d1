{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\n// Assume other necessary imports exist (BaseProtocolDecoder, DeviceSession, Position, UnitsConverter etc.)\n// For example:\n// import org.traccar.BaseProtocolDecoder;\n// import org.traccar.DeviceSession;\n// import org.traccar.Protocol;\n// import org.traccar.helper.UnitsConverter;\n// import org.traccar.model.Position;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.LinkedList;\nimport java.util.List;\n\n\n    private List<Position> decodeBinaryE(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n        List<Position> positions = new LinkedList<>();\n\n        // Initial check for minimum data before comma search\n        if (buf.readableBytes() < 1) {\n            return null;\n        }\n        int commaIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (commaIndex < 0) {\n            return null; // Comma not found, invalid format\n        }\n\n        // Check minimum length for header fields up to 'count' byte\n        // Need bytes up to comma + 1 (comma) + 15 (imei) + 5 (separators) + 4 (cache) + 2 (count)\n        int minHeaderLength = (commaIndex - buf.readerIndex()) + 1 + 15 + 5 + 4 + 2;\n        if (buf.readableBytes() < minHeaderLength) {\n             return null; // Not enough data for essential header fields\n        }\n\n        buf.readerIndex(commaIndex + 1);\n        String imei = buf.readSlice(15).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1 + 3 + 1); // Skip \",CCE,\"\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.readUnsignedIntLE(); // remaining cache\n        int count = buf.readUnsignedShortLE();\n\n        for (int i = 0; i < count; i++) {\n            // Check minimum readable bytes for fixed position header fields (length, index, 4 param counts)\n            if (buf.readableBytes() < 2 + 2 + 1 + 1 + 1 + 1) {\n                break; // Not enough data for the next position record header\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            buf.readUnsignedShortLE(); // overall length (unused in this decoder logic)\n            buf.readUnsignedShortLE(); // index (unused)\n\n            // Parameter Block 1 (Byte values)\n            if (buf.readableBytes() < 1) { break; } // Ensure count byte is readable\n            int paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { buf.readerIndex(buf.writerIndex()); break; } // Ensure ID byte(s) readable\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idByteCount = extension ? 2 : 1;\n                if (buf.readableBytes() < idByteCount + 1) { buf.readerIndex(buf.writerIndex()); break; } // Ensure ID + 1 byte value readable\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                switch (id) {\n                    case 0x01: position.set(Position.KEY_EVENT, buf.readUnsignedByte()); break;\n                    case 0x05: position.setValid(buf.readUnsignedByte() > 0); break;\n                    case 0x06: position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); break;\n                    case 0x07: position.set(Position.KEY_RSSI, buf.readUnsignedByte()); break;\n                    case 0x14: position.set(Position.KEY_OUTPUT, buf.readUnsignedByte()); break;\n                    case 0x15: position.set(Position.KEY_INPUT, buf.readUnsignedByte()); break;\n                    case 0x47:\n                        int lockState = buf.readUnsignedByte();\n                        if (lockState > 0) { position.set(Position.KEY_LOCK, lockState == 2); }\n                        break;\n                    case 0x97: position.set(Position.KEY_THROTTLE, buf.readUnsignedByte()); break;\n                    case 0x9D: position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte()); break;\n                    case 0xFE69: position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); break;\n                    default: buf.readUnsignedByte(); break; // Skip unknown value\n                }\n            }\n            if (buf.readableBytes() == 0 && i < count - 1) { break; } // Stop if buffer ends prematurely\n\n            // Parameter Block 2 (Short LE values)\n            if (buf.readableBytes() < 1) { break; }\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                 if (buf.readableBytes() < 1) { buf.readerIndex(buf.writerIndex()); break; }\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idByteCount = extension ? 2 : 1;\n                 if (buf.readableBytes() < idByteCount + 2) { buf.readerIndex(buf.writerIndex()); break; } // Ensure ID + 2 bytes value readable\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                switch (id) {\n                    case 0x08: position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE())); break;\n                    case 0x09: position.setCourse(buf.readUnsignedShortLE()); break;\n                    case 0x0A: position.set(Position.KEY_HDOP, buf.readUnsignedShortLE() * 0.1); break; // Applied HDOP scaling\n                    case 0x0B: position.setAltitude(buf.readShortLE()); break;\n                    case 0x16: position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x19: position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x1A: position.set(Position.KEY_POWER, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x40: position.set(Position.KEY_EVENT, buf.readUnsignedShortLE()); break;\n                    case 0x91: case 0x92: position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShortLE()); break;\n                    case 0x98: position.set(Position.KEY_FUEL_USED, buf.readUnsignedShortLE() * 0.1); break; // Applied fuel used scaling\n                    case 0x99: position.set(Position.KEY_RPM, buf.readUnsignedShortLE()); break;\n                    case 0x9C: position.set(Position.KEY_COOLANT_TEMP, (double) buf.readUnsignedShortLE() - 40.0); break; // Applied coolant temp offset\n                    case 0x9F: position.set(Position.PREFIX_TEMP + 1, buf.readShortLE() * 0.1); break; // Applied temp scaling\n                    case 0xC9: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShortLE() * 0.01); break; // Applied fuel consumption scaling\n                    default: buf.readUnsignedShortLE(); break; // Skip unknown value\n                }\n            }\n             if (buf.readableBytes() == 0 && i < count - 1) { break; }\n\n            // Parameter Block 3 (Int LE values)\n             if (buf.readableBytes() < 1) { break; }\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { buf.readerIndex(buf.writerIndex()); break; }\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idByteCount = extension ? 2 : 1;\n                if (buf.readableBytes() < idByteCount + 4) { buf.readerIndex(buf.writerIndex()); break; } // Ensure ID + 4 bytes value readable\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                switch (id) {\n                    case 0x02: position.setLatitude(buf.readIntLE() * 0.000001); break;\n                    case 0x03: position.setLongitude(buf.readIntLE() * 0.000001); break;\n                    case 0x04: position.setTime(new Date((946684800L + buf.readUnsignedIntLE()) * 1000)); break; // Use Long constant\n                    case 0x0C: case 0x9B: position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE()); break; // Odometer (meters?)\n                    case 0x0D: position.set(Position.KEY_HOURS, buf.readUnsignedIntLE() * 1000L); break; // Runtime (seconds) stored as ms\n                    case 0x25: position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(buf.readUnsignedIntLE())); break;\n                    case 0xA0: position.set(Position.KEY_FUEL_USED, buf.readUnsignedIntLE() * 0.001); break; // Scaled fuel used\n                    case 0xA2: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedIntLE() * 0.01); break; // Scaled fuel consumption\n                    default: buf.readUnsignedIntLE(); break; // Skip unknown value\n                }\n            }\n            if (buf.readableBytes() == 0 && i < count - 1) { break; }\n\n            // Parameter Block 4 (Variable Length values)\n             if (buf.readableBytes() < 1) { break; }\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { buf.readerIndex(buf.writerIndex()); break; }\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idByteCount = extension ? 2 : 1;\n                if (buf.readableBytes() < idByteCount + 1) { buf.readerIndex(buf.writerIndex()); break; } // Ensure ID + length byte readable\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                int length = buf.readUnsignedByte();\n\n                if (buf.readableBytes() < length) {\n                    // Not enough data for payload length declared. Assume corrupt data.\n                    buf.readerIndex(buf.writerIndex()); // Consume the rest of the buffer\n                    break; // Exit this inner loop (j)\n                }\n\n                // Now safe to process 'length' bytes\n                switch (id) {\n                    case 0x2A: case 0x2B: case 0x2C: case 0x2D:\n                    case 0x2E: case 0x2F: case 0x30: case 0x31:\n                        if (length >= 3) { // Expect 1 byte label + 2 bytes value\n                            buf.readUnsignedByte(); // skip label\n                            position.set(Position.PREFIX_TEMP + (id - 0x2A), buf.readShortLE() * 0.01); // Scaled temp\n                            if (length > 3) { buf.skipBytes(length - 3); } // Skip any extra bytes\n                        } else { buf.skipBytes(length); } // Skip if length is incorrect\n                        break;\n                    case 0xFE31: // Alarm data\n                        if (length >= 2) { // Expect 1 byte protocol + 1 byte type\n                            buf.readUnsignedByte(); // skip alarm protocol\n                            buf.readUnsignedByte(); // skip alarm type\n                            if (length > 2) { buf.skipBytes(length - 2); } // Skip remainder\n                        } else { buf.skipBytes(length); }\n                        break;\n                    case 0xFEA8: // Battery info\n                        if (length >= 3) { // Expect 1 byte status + 1 byte level + 1 byte alert\n                            buf.readUnsignedByte(); // skip battery status\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            buf.readUnsignedByte(); // skip battery alert\n                            if (length > 3) { buf.skipBytes(length - 3); } // Skip any extra bytes\n                        } else { buf.skipBytes(length); }\n                        break;\n                    default:\n                        buf.skipBytes(length); // Skip data for unknown IDs\n                        break;\n                }\n            } // End inner loop (j)\n\n            // Only add the position if the buffer wasn't fully consumed prematurely during its processing.\n            // This prevents adding partially processed positions if an error occurred mid-way.\n            // If readerIndex reached writerIndex, it means a break happened due to insufficient data.\n            if (buf.readerIndex() == buf.writerIndex() && i < count - 1) {\n                // Buffer ended unexpectedly during this position's processing, and it's not the last expected position.\n                break; // Stop processing further positions\n            } else {\n                 positions.add(position); // Add position if processed normally or if it's the last one\n            }\n\n             if (buf.readableBytes() == 0 && i < count - 1) { // Break outer loop if buffer ended early before next position iteration\n                 break;\n             }\n\n        } // End outer loop (i)\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}