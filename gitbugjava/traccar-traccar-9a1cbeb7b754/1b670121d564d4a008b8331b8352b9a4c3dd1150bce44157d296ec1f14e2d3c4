{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport org.traccar.DeviceSession;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.Position;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.LinkedList;\nimport java.util.List;\n\n// Add necessary imports if they are missing in the original file context\n// import io.netty.buffer.ByteBuf;\n// import io.netty.channel.Channel;\n// import org.traccar.DeviceSession;\n// import org.traccar.helper.UnitsConverter;\n// import org.traccar.model.Position;\n// import java.net.SocketAddress;\n// import java.nio.charset.StandardCharsets;\n// import java.util.Date;\n// import java.util.LinkedList;\n// import java.util.List;\n\n\n    private List<Position> decodeBinaryE(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n        List<Position> positions = new LinkedList<>();\n\n        // Find the first comma and skip it\n        int commaIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (commaIndex == -1) {\n            return null; // Invalid format\n        }\n        // Ensure we can read up to the comma and the 15-byte IMEI after it\n        if (buf.readableBytes() < (commaIndex - buf.readerIndex() + 1 + 15)) {\n            return null; // Not enough data\n        }\n        buf.readerIndex(commaIndex + 1);\n\n        String imei = buf.readSlice(15).toString(StandardCharsets.US_ASCII);\n\n        // Skip \",CCE,\" equivalent? Original: buf.skipBytes(1 + 3 + 1); Assuming 5 bytes skip\n        if (buf.readableBytes() < 5) {\n            return null; // Not enough data\n        }\n        buf.skipBytes(5);\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        // Check readable bytes before reading cache and count\n        if (buf.readableBytes() < (4 + 2)) {\n            return null; // Not enough data\n        }\n        buf.readUnsignedIntLE(); // remaining cache\n        int count = buf.readUnsignedShortLE();\n\n        for (int i = 0; i < count; i++) {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            // Check readable bytes before reading record length and index\n            if (buf.readableBytes() < (2 + 2)) {\n                break; // Stop processing records if buffer ends prematurely\n            }\n            buf.readUnsignedShortLE(); // record length\n            buf.readUnsignedShortLE(); // record index\n\n            // Process parameter blocks, breaking loops if buffer ends prematurely\n\n            // Block 1: Byte parameters\n            if (buf.readableBytes() < 1) { break; }\n            int paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { break; } // Need at least 1 byte for ID/flag\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) { break; } // Need 2 bytes for extended ID\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n\n                if (buf.readableBytes() < 1) { break; } // Need 1 byte for value\n                switch (id) {\n                    case 0x01: position.set(Position.KEY_EVENT, buf.readUnsignedByte()); break;\n                    case 0x05: position.setValid(buf.readUnsignedByte() > 0); break;\n                    case 0x06: position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); break;\n                    case 0x07: position.set(Position.KEY_RSSI, buf.readUnsignedByte()); break;\n                    case 0x14: position.set(Position.KEY_OUTPUT, buf.readUnsignedByte()); break;\n                    case 0x15: position.set(Position.KEY_INPUT, buf.readUnsignedByte()); break;\n                    case 0x47:\n                        int lockState = buf.readUnsignedByte();\n                        if (lockState > 0) {\n                            position.set(Position.KEY_LOCK, lockState == 2);\n                        }\n                        break;\n                    case 0x97: position.set(Position.KEY_THROTTLE, buf.readUnsignedByte()); break;\n                    case 0x9D: position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte()); break;\n                    case 0xFE69: position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); break; // Extended ID\n                    default: buf.skipBytes(1); break; // Skip 1 byte value\n                }\n            }\n            if (!buf.isReadable()) { break; } // Stop if buffer is fully read\n\n            // Block 2: Short LE parameters\n            if (buf.readableBytes() < 1) { break; }\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { break; } // Need ID byte(s)\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) { break; }\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n\n                if (buf.readableBytes() < 2) { break; } // Need 2 bytes for value\n                switch (id) {\n                    case 0x08: position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE())); break;\n                    case 0x09: position.setCourse(buf.readUnsignedShortLE()); break;\n                    case 0x0A: position.set(Position.KEY_HDOP, buf.readUnsignedShortLE() * 0.1); break; // Apply scaling\n                    case 0x0B: position.setAltitude(buf.readShortLE()); break;\n                    case 0x16: position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x19: position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x1A: position.set(Position.KEY_POWER, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x40: position.set(Position.KEY_EVENT, buf.readUnsignedShortLE()); break;\n                    case 0x91: case 0x92: position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShortLE()); break;\n                    case 0x98: position.set(Position.KEY_FUEL_USED, buf.readUnsignedShortLE()); break;\n                    case 0x99: position.set(Position.KEY_RPM, buf.readUnsignedShortLE()); break;\n                    case 0x9C: position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShortLE()); break; // Keep original scaling\n                    case 0x9F: position.set(Position.PREFIX_TEMP + 1, buf.readUnsignedShortLE()); break; // Keep original scaling/type\n                    case 0xC9: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShortLE()); break;\n                    default: buf.skipBytes(2); break; // Skip 2 bytes value\n                }\n            }\n            if (!buf.isReadable()) { break; }\n\n            // Block 3: Int LE parameters\n            if (buf.readableBytes() < 1) { break; }\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { break; } // Need ID byte(s)\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) { break; }\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n\n                if (buf.readableBytes() < 4) { break; } // Need 4 bytes for value\n                switch (id) {\n                    case 0x02: position.setLatitude(buf.readIntLE() * 0.000001); break;\n                    case 0x03: position.setLongitude(buf.readIntLE() * 0.000001); break;\n                    case 0x04: position.setTime(new Date((946684800 + buf.readUnsignedIntLE()) * 1000)); break; // 2000-01-01\n                    case 0x0C: case 0x9B: position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE()); break;\n                    case 0x0D: position.set(\"runtime\", buf.readUnsignedIntLE()); break;\n                    case 0x25: position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(buf.readUnsignedIntLE())); break;\n                    case 0xA0: position.set(Position.KEY_FUEL_USED, buf.readUnsignedIntLE() * 0.001); break;\n                    case 0xA2: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedIntLE() * 0.01); break;\n                    default: buf.skipBytes(4); break; // Skip 4 bytes value\n                }\n            }\n            if (!buf.isReadable()) { break; }\n\n            // Block 4: Variable length parameters\n            if (buf.readableBytes() < 1) { break; }\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) { break; } // Need ID byte(s)\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int id;\n                if (extension) {\n                    if (buf.readableBytes() < 2) { break; }\n                    id = buf.readUnsignedShort();\n                } else {\n                    id = buf.readUnsignedByte();\n                }\n\n                if (buf.readableBytes() < 1) { break; } // Need 1 byte for length\n                int length = buf.readUnsignedByte();\n\n                // *** FIX: Check if buffer has enough bytes for the declared length ***\n                if (buf.readableBytes() < length) {\n                    // Not enough data for declared length. Packet corrupted/truncated. Stop processing.\n                    buf.skipBytes(buf.readableBytes()); // Consume rest of buffer\n                    break; // Break inner loop (variable params)\n                }\n\n                // Process based on ID, consuming 'length' bytes\n                int readerIndexBefore = buf.readerIndex();\n                switch (id) {\n                    case 0x2A: case 0x2B: case 0x2C: case 0x2D: case 0x2E: case 0x2F: case 0x30: case 0x31:\n                        if (length >= 3) {\n                            buf.readUnsignedByte(); // label\n                            position.set(Position.PREFIX_TEMP + (id - 0x2A), buf.readShortLE() * 0.01);\n                            buf.skipBytes(length - 3); // Skip remaining declared bytes\n                        } else {\n                            buf.skipBytes(length); // Length invalid for this type, skip reported length\n                        }\n                        break;\n                    case 0xFE31: // Extended ID\n                        if (length >= 2) {\n                            buf.readUnsignedByte(); // alarm protocol\n                            buf.readUnsignedByte(); // alarm type\n                            buf.skipBytes(length - 2); // Skip remaining declared bytes\n                        } else {\n                            buf.skipBytes(length); // Length invalid, skip reported length\n                        }\n                        break;\n                    case 0xFEA8: // Extended ID\n                        if (length >= 3) {\n                            buf.readUnsignedByte(); // battery status\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            buf.readUnsignedByte(); // battery alert\n                            buf.skipBytes(length - 3); // Skip remaining declared bytes\n                        } else {\n                            buf.skipBytes(length); // Length invalid, skip reported length\n                        }\n                        break;\n                    default:\n                        buf.skipBytes(length); // Skip 'length' bytes for unknown ID\n                        break;\n                }\n                 // Safeguard: Ensure reader index didn't go backward or drastically forward unexpectedly\n                 if (buf.readerIndex() < readerIndexBefore || buf.readerIndex() > readerIndexBefore + length) {\n                      // Reset reader index and skip the originally declared length\n                      buf.readerIndex(readerIndexBefore);\n                      buf.skipBytes(length);\n                 }\n            }\n            // Check buffer readability before potentially adding the position or starting next record\n            if (!buf.isReadable() && i < count - 1) { break; }\n\n            // Only add position if valid time and coordinates were decoded\n            if (position.getFixTime() != null && position.getLatitude() != 0 && position.getLongitude() != 0) {\n                positions.add(position);\n            }\n\n            // Check if the buffer is readable before next iteration\n            if (!buf.isReadable()) { break; }\n        }\n\n        return positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}