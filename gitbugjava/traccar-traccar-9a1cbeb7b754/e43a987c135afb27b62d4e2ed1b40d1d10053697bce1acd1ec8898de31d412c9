{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.LinkedList;\nimport java.util.List;\n\n// Assume Position, DeviceSession, UnitsConverter, BaseProtocolDecoder and other necessary classes are defined elsewhere.\n// Stub for Position constants if needed\n/*\nclass Position {\n    public static final String KEY_EVENT = \"event\"; public static final String KEY_SATELLITES = \"sat\"; public static final String KEY_RSSI = \"rssi\"; public static final String KEY_OUTPUT = \"output\"; public static final String KEY_INPUT = \"input\"; public static final String KEY_LOCK = \"lock\"; public static final String KEY_THROTTLE = \"throttle\"; public static final String KEY_FUEL_LEVEL = \"fuel\"; public static final String KEY_BATTERY_LEVEL = \"batteryLevel\"; public static final String KEY_HDOP = \"hdop\"; public static final String PREFIX_ADC = \"adc\"; public static final String KEY_BATTERY = \"battery\"; public static final String KEY_POWER = \"power\"; public static final String KEY_OBD_SPEED = \"obdSpeed\"; public static final String KEY_FUEL_USED = \"fuelUsed\"; public static final String KEY_RPM = \"rpm\"; public static final String KEY_COOLANT_TEMP = \"coolantTemp\"; public static final String PREFIX_TEMP = \"temp\"; public static final String KEY_FUEL_CONSUMPTION = \"fuelConsumption\"; public static final String KEY_ODOMETER = \"odometer\"; public static final String KEY_DRIVER_UNIQUE_ID = \"driverUniqueId\";\n    public Position(String protocol) {} public void setDeviceId(long id) {} public void set(String key, Object value) {} public void setValid(boolean valid) {} public void setSpeed(double speed) {} public void setCourse(double course) {} public void setAltitude(double altitude) {} public void setLatitude(double lat) {} public void setLongitude(double lon) {} public void setTime(Date time) {}\n}\nclass DeviceSession { public long getDeviceId() { return 0; } }\nclass UnitsConverter { public static double knotsFromKph(double kph) { return kph / 1.852; } }\nabstract class BaseProtocolDecoder { abstract DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress, String... uniqueIds); abstract String getProtocolName(); }\nclass MeitrackProtocolDecoder extends BaseProtocolDecoder { @Override public DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress, String... uniqueIds) { return new DeviceSession(); } @Override public String getProtocolName() { return \"meitrack\"; }\n*/\n    private List<Position> decodeBinaryE(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n        List<Position> positions = new LinkedList<>();\n\n        int commaIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (commaIndex == -1) {\n             return null; // Comma not found\n        }\n        // Check if enough bytes for IMEI (15) and suffix (,CCE,) (5) after comma\n        // Also check if the comma index is valid relative to reader index\n        if (commaIndex < buf.readerIndex() || buf.writerIndex() < commaIndex + 1 + 15 + 5) {\n             return null; // Not enough data for header part or invalid comma index\n        }\n        buf.readerIndex(commaIndex + 1);\n        String imei = buf.readSlice(15).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1 + 3 + 1); // Skip ,CCE,\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        // Check for cache size (4) and count (2)\n        if (buf.readableBytes() < 4 + 2) {\n            return null;\n        }\n        buf.readUnsignedIntLE(); // remaining cache\n        int count = buf.readUnsignedShortLE();\n\n        for (int i = 0; i < count; i++) {\n            // Check readable bytes for the fixed part of the position block header:\n            // record length (2), index (2), byte param count (1)\n            if (buf.readableBytes() < 2 + 2 + 1) {\n                break; // Not enough data for the next position record header\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            buf.readUnsignedShortLE(); // record length field (value not used here)\n            buf.readUnsignedShortLE(); // record index field (value not used here)\n\n            // --- Byte Parameters ---\n            int paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) break; // Need byte for ID type check (FE or regular ID)\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idBytes = extension ? 2 : 1;\n                if (buf.readableBytes() < idBytes + 1) break; // Need ID bytes + 1 data byte\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                // Read data based on ID\n                switch (id) {\n                    case 0x01: position.set(Position.KEY_EVENT, buf.readUnsignedByte()); break;\n                    case 0x05: position.setValid(buf.readUnsignedByte() > 0); break;\n                    case 0x06: position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); break;\n                    case 0x07: position.set(Position.KEY_RSSI, buf.readUnsignedByte()); break;\n                    case 0x14: position.set(Position.KEY_OUTPUT, buf.readUnsignedByte()); break;\n                    case 0x15: position.set(Position.KEY_INPUT, buf.readUnsignedByte()); break;\n                    case 0x47:\n                        int lockState = buf.readUnsignedByte();\n                        if (lockState > 0) position.set(Position.KEY_LOCK, lockState == 2);\n                        break;\n                    case 0x97: position.set(Position.KEY_THROTTLE, buf.readUnsignedByte()); break;\n                    case 0x9D: position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte()); break;\n                    case 0xFE69: position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); break;\n                    default: buf.skipBytes(1); break; // Skip 1 data byte\n                }\n            }\n\n            // --- Short Parameters ---\n            if (buf.readableBytes() < 1) break; // Need byte param count\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) break; // Need byte for ID type check\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idBytes = extension ? 2 : 1;\n                if (buf.readableBytes() < idBytes + 2) break; // Need ID bytes + 2 data bytes\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                // Read data based on ID\n                switch (id) {\n                    case 0x08: position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE())); break;\n                    case 0x09: position.setCourse(buf.readUnsignedShortLE()); break;\n                    case 0x0A: position.set(Position.KEY_HDOP, buf.readUnsignedShortLE() * 0.1); break; // Apply scaling (assuming 0.1)\n                    case 0x0B: position.setAltitude(buf.readShortLE()); break;\n                    case 0x16: position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x19: position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x1A: position.set(Position.KEY_POWER, buf.readUnsignedShortLE() * 0.01); break;\n                    case 0x40: position.set(Position.KEY_EVENT, buf.readUnsignedShortLE()); break;\n                    case 0x91: case 0x92: position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShortLE()); break;\n                    case 0x98: position.set(Position.KEY_FUEL_USED, buf.readUnsignedShortLE() * 0.1); break; // Apply scaling (assuming 0.1 L)\n                    case 0x99: position.set(Position.KEY_RPM, buf.readUnsignedShortLE()); break;\n                    case 0x9C: position.set(Position.KEY_COOLANT_TEMP, (double) buf.readShortLE() - 40.0); break; // Apply offset (assuming deg C)\n                    case 0x9F: position.set(Position.PREFIX_TEMP + 1, buf.readShortLE() * 0.1); break; // Apply scaling (assuming 0.1 deg C)\n                    case 0xC9: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShortLE() * 0.1); break; // Apply scaling (assuming 0.1 L/100km)\n                    default: buf.skipBytes(2); break; // Skip 2 data bytes\n                }\n            }\n\n            // --- Int Parameters ---\n            if (buf.readableBytes() < 1) break; // Need byte param count\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) break; // Need byte for ID type check\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idBytes = extension ? 2 : 1;\n                if (buf.readableBytes() < idBytes + 4) break; // Need ID bytes + 4 data bytes\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                // Read data based on ID\n                switch (id) {\n                    case 0x02: position.setLatitude(buf.readIntLE() * 0.000001); break;\n                    case 0x03: position.setLongitude(buf.readIntLE() * 0.000001); break;\n                    case 0x04: position.setTime(new Date((946684800L + buf.readUnsignedIntLE()) * 1000)); break; // Use long literal\n                    case 0x0C: case 0x9B: position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE()); break;\n                    case 0x0D: position.set(\"runtime\", buf.readUnsignedIntLE()); break;\n                    case 0x25: position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(buf.readUnsignedIntLE())); break;\n                    case 0xA0: position.set(Position.KEY_FUEL_USED, buf.readUnsignedIntLE() * 0.001); break; // Check scaling\n                    case 0xA2: position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedIntLE() * 0.01); break; // Check scaling\n                    default: buf.skipBytes(4); break; // Skip 4 data bytes\n                }\n            }\n\n            // --- Variable Length Parameters ---\n            if (buf.readableBytes() < 1) break; // Need byte param count\n            paramCount = buf.readUnsignedByte();\n            for (int j = 0; j < paramCount; j++) {\n                if (buf.readableBytes() < 1) break; // Need byte for ID type check\n                boolean extension = buf.getUnsignedByte(buf.readerIndex()) == 0xFE;\n                int idBytes = extension ? 2 : 1;\n                if (buf.readableBytes() < idBytes + 1) break; // Need ID bytes + 1 length byte\n\n                int id = extension ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                int length = buf.readUnsignedByte();\n\n                if (buf.readableBytes() < length) {\n                    // Not enough data for declared length, indicates corrupt message\n                    buf.readerIndex(buf.writerIndex()); // Consume rest of buffer to prevent partial reads/loops\n                    break; // Exit this inner loop, position might be incomplete\n                }\n\n                int bytesConsumedInData = 0; // Track bytes consumed within the specific case\n\n                switch (id) {\n                    case 0x2A: case 0x2B: case 0x2C: case 0x2D:\n                    case 0x2E: case 0x2F: case 0x30: case 0x31:\n                        // Expecting 1 byte label + 2 bytes value = 3 bytes\n                        if (length >= 3) {\n                            buf.readUnsignedByte(); // label (ignore)\n                            position.set(Position.PREFIX_TEMP + (id - 0x2A), buf.readShortLE() * 0.01);\n                            bytesConsumedInData = 3;\n                        }\n                        // Skip any remaining bytes defined by length, beyond those consumed\n                        if (length > bytesConsumedInData) {\n                             buf.skipBytes(length - bytesConsumedInData);\n                        }\n                        break;\n                    case 0xFE31:\n                        // Expecting 1 byte protocol + 1 byte type = 2 bytes\n                        if (length >= 2) {\n                             buf.readUnsignedByte(); // alarm protocol (ignore)\n                             buf.readUnsignedByte(); // alarm type (ignore)\n                             bytesConsumedInData = 2;\n                        }\n                         // Skip any remaining bytes specified by length\n                        if (length > bytesConsumedInData) {\n                           buf.skipBytes(length - bytesConsumedInData);\n                        }\n                        break;\n                    case 0xFEA8:\n                         // Expecting 1 byte status + 1 byte level + 1 byte alert = 3 bytes\n                        if (length >= 3) {\n                            buf.readUnsignedByte(); // battery status (ignore)\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            buf.readUnsignedByte(); // battery alert (ignore)\n                            bytesConsumedInData = 3;\n                        }\n                         // Skip any remaining bytes specified by length\n                         if (length > bytesConsumedInData) {\n                            buf.skipBytes(length - bytesConsumedInData);\n                         }\n                        break;\n                    default:\n                         // Skip the declared length for unknown IDs or if length was too small\n                        buf.skipBytes(length);\n                        break;\n                }\n            }\n\n            positions.add(position);\n\n            // Check if buffer is exhausted prematurely before next record iteration\n             if (buf.readableBytes() == 0 && i < count - 1) {\n                // Log warning? (\"Buffer exhausted after reading %d records, expected %d\", i + 1, count)\n                break;\n            }\n        }\n\n        return positions;\n    }\n/* } // End of class definition stub */",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}