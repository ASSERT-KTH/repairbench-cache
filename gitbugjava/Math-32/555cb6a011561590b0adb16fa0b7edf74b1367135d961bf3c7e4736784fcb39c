{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            // RLP 2017-08-10: The attribute may be Boolean.TRUE, Boolean.FALSE\n            // or a BoundaryAttribute instance. Determine which case and act\n            // accordingly. Previously this just cast to Boolean which threw\n            // ClassCastException if attribute was BoundaryAttribute.\n            final Object attribute = tree.getAttribute();\n            if (Boolean.TRUE.equals(attribute)) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                // the instance is empty or is a lower dimension object\n                // (line, point). In either case the size is 0.\n                setSize(0);\n                // The barycenter of an empty set is undefined, let's use NaN\n                // Historically, (0,0) was used. NaN is probably more robust\n                // mathematically, but keeping compatibility may be important.\n                // Let's check if this change breaks other tests.\n                // Original code: setBarycenter(new Vector2D(0, 0));\n                // Using NaN as it is more correct for empty/lower-dimensional sets.\n                // If tests fail, consider reverting to new Vector2D(0, 0).\n                // For consistency with the infinite case, NaN seems better.\n                setBarycenter(Vector2D.NaN);\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                // this happens for PolygonsSet created from methods like :\n                // new PolygonsSet(tree.getCut().getMinus(), tree.getPlus()).\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                // BEWARE: potential numerical issues for very small polygons\n                if (sum == 0) {\n                    // the polygon is degenerate (a line or point)\n                    setSize(0d);\n                    // Barycenter is undefined for a degenerate polygon, use NaN\n                    setBarycenter(Vector2D.NaN);\n                } else {\n                    setSize(sum / 2);\n                    setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}