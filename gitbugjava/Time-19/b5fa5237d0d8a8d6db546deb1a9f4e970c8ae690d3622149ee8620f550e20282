{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br /> // offset = Std, UTC = 00:00\n     * Input: 00:30  Output: 00:30<br /> // offset = Std, UTC = 00:30\n     * Input: 01:00  Output: 02:00<br /> // offset = Std, UTC = 01:00 (maps to 02:00 DST)\n     * Input: 01:30  Output: 02:30<br /> // offset = Std, UTC = 01:30 (maps to 02:30 DST)\n     * Input: 02:00  Output: 02:00<br /> // offset = DST, UTC = 01:00\n     * Input: 02:30  Output: 02:30<br /> // offset = DST, UTC = 01:30\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time. This means returning the DST offset.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate).\n        // This will return the standard offset if instantLocal is inside the overlap period.\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        if (offsetLocal != offsetAdjusted) {\n            // Transition detected. Check if it's a gap or overlap.\n            // For gaps, the code needs to return the offset suitable for calculating an instant AFTER the gap.\n            // offsetLocal is the offset before the gap (standard), offsetAdjusted is the offset after (daylight).\n            // instantAdjusted (instantLocal - offsetLocal) is an estimated UTC instant.\n            // If instantLocal is 01:30 in a 01:00 -> 02:00 gap, offsetLocal=Std(0), instantAdjusted=01:30UTC.\n            // offsetAdjusted=getOffset(01:30UTC)=Dst(+1).\n            // We want the resulting time to be 02:30 DST. UTC = instantLocal - offset = 01:30 - offset.\n            // To get UTC=01:30, we need offset=0 (offsetLocal).\n            // So for gaps (offsetLocal < offsetAdjusted), return offsetLocal.\n            \n            // For overlaps, the code needs to return the offset corresponding to the earlier instant (daylight/summer time).\n            // If offsetLocal=Dst(+1), instantAdjusted=instantLocal-DstOffset. This UTC is before the transition.\n            // offsetAdjusted=getOffset(instantAdjusted)=Dst(+1). This doesn't trigger offsetLocal != offsetAdjusted.\n            // If offsetLocal=Std(0), instantAdjusted=instantLocal-StdOffset. This UTC is after the transition.\n            // offsetAdjusted=getOffset(instantAdjusted)=Std(0). This doesn't trigger offsetLocal != offsetAdjusted.\n            // This path (offsetLocal != offsetAdjusted) seems unlikely for typical gap/overlap scenarios\n            // based on how getOffset(instant) likely behaves for instants within the transition period.\n            // However, if it does happen:\n            if (offsetLocal < offsetAdjusted) { // Gap\n                 return offsetLocal; // Use standard offset (pushes time forward past gap)\n            } else { // Overlap (offsetLocal > offsetAdjusted)\n                 return offsetLocal; // Use the first offset (likely DST)\n            }\n\n        } else { // offsetLocal == offsetAdjusted\n            // No transition detected based on the initial estimate.\n            // Could be stable time, or within an overlap where the initial guess was consistent.\n            // Example: Overlap 02:00 DST -> 01:00 Std. Local time 01:30 is ambiguous.\n            // Assume getOffset(instantLocal=01:30) returns Std offset (0). offsetLocal=0.\n            // instantAdjusted = 01:30 - 0 = 01:30 UTC. offsetAdjusted=getOffset(01:30 UTC)=0.\n            // offsetLocal == offsetAdjusted.\n            // We must detect that 01:30 local is ambiguous and return the DST offset (+1).\n            // Check the offset just before the calculated UTC instant.\n            long instantBefore = instantAdjusted - 1;\n            int offsetBefore = getOffset(instantBefore);\n            // If offsetBefore is greater than offsetAdjusted, it means the offset dropped\n            // right at instantAdjusted, indicating the end of an overlap.\n            if (offsetBefore > offsetAdjusted) {\n                // instantLocal is in the overlap. Return the earlier offset (DST).\n                return offsetBefore;\n            } else {\n                // Either stable time (offsetBefore == offsetAdjusted) or start of DST (offsetBefore < offsetAdjusted).\n                // In both cases, the calculated offsetAdjusted is correct for the non-ambiguous or forward mapping case.\n                return offsetAdjusted;\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}