{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for.\n     *                      This is generally the local millis according to standard offset,\n     *                      or the local millis derived from fields, which may be ambiguous.\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset guess using the local instant assuming it's roughly UTC\n        final int offsetLocal = getOffset(instantLocal);\n        \n        // adjust the local instant by the first offset guess and get the offset for that\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        if (offsetLocal != offsetAdjusted) {\n            // Transition zone detected. Choose offset based on gap/overlap rules.\n            // If offsetLocal > offsetAdjusted, we are likely in a gap transition (spring forward).\n            // 'instantAdjusted' is chronologically before the transition, 'offsetAdjusted' is the offset BEFORE the gap.\n            // 'offsetLocal' is the offset AFTER the gap (estimated based on instantLocal).\n            // Rule for gaps: return offset AFTER the gap.\n            if (offsetLocal > offsetAdjusted) {\n                return offsetLocal;\n            }\n            // If offsetLocal < offsetAdjusted, we are likely in an overlap transition (fall back).\n            // 'instantAdjusted' is chronologically before the transition, 'offsetAdjusted' is the offset BEFORE the overlap.\n            // 'offsetLocal' is the offset AFTER the overlap (estimated based on instantLocal).\n            // Rule for overlaps: return offset BEFORE the overlap (the earlier, usually daylight time).\n            else {\n                // offsetLocal < offsetAdjusted\n                return offsetAdjusted;\n            }\n        } else {\n            // offsetLocal == offsetAdjusted. This is the normal case, but it could also\n            // occur during an overlap if the initial guess (instantLocal) and the adjusted\n            // instant (instantAdjusted) both fall into the period *after* the transition.\n            final int offset = offsetAdjusted; // The calculated offset\n            final long instantUTC = instantAdjusted; // The calculated UTC instant\n\n            // Check for an overlap scenario where we need to return the earlier offset.\n            // Find the previous transition before the calculated UTC instant.\n            long prevTransUTC = previousTransition(instantUTC);\n            \n            // Is there a previous transition?\n            if (prevTransUTC < instantUTC) {\n                int offsetBefore = getOffset(prevTransUTC - 1); // Offset right before the transition\n                int offsetAfter = getOffset(prevTransUTC); // Offset right after the transition (should == offset)\n\n                // Was it a fall-back transition (offset decreased, creating an overlap)?\n                if (offsetBefore > offsetAfter) {\n                    // Calculate the duration of the overlap in milliseconds.\n                    long overlapDuration = offsetBefore - offsetAfter;\n                    // Calculate how far instantUTC is *after* the transition point.\n                    long timeSinceTransition = instantUTC - prevTransUTC;\n                    \n                    // Does instantUTC fall within the UTC range that maps to the ambiguous local times?\n                    // This range starts at prevTransUTC and lasts for overlapDuration.\n                    if (timeSinceTransition < overlapDuration) {\n                        // Yes, instantUTC corresponds to the *later* local time during the overlap.\n                        // The rule requires returning the offset for the *earlier* local time.\n                        return offsetBefore;\n                    }\n                }\n            }\n            // If it's not an overlap, or instantUTC is outside the ambiguous range,\n            // or there's no previous transition, return the calculated offset.\n            return offset;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}