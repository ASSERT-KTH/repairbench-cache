{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        // Note: getOffset expects UTC millis, but here we are passing local millis.\n        // This estimate is just used to narrow down the potential UTC instant.\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // Check if we are transitioning from standard to daylight time (spring forward / gap)\n            // by checking if the offset difference is negative (offsetAdjusted > offsetLocal).\n            // This occurs if the initial guess (offsetLocal) was the standard offset,\n            // but the adjusted instant (instantAdjusted) falls in daylight time.\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // Find the next transition after the adjusted instant (which is potentially the first UTC estimate).\n                long nextLocal = nextTransition(instantAdjusted);\n                // Find the next transition after the alternative potential UTC instant (local - new offset).\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                \n                // If the next transition differs depending on which candidate UTC instant we use,\n                // it strongly suggests that the local instant falls within the DST gap.\n                if (nextLocal != nextAdjusted) {\n                    // In the gap, the rule is to return an offset that shifts the time forward.\n                    // Returning offsetLocal (the standard offset before the transition) achieves this.\n                    // Example: Gap 1:00-1:59. Input 1:30. offsetLocal=0, offsetAdjusted=+1h.\n                    // utc = 1:30 - offsetLocal = 1:30 UTC.\n                    // DateTime(utc) = 1:30 UTC + getOffset(1:30 UTC) = 1:30 UTC + (+1h) = 2:30 local. Matches example.\n                    return offsetLocal;\n                }\n                // If next transitions are the same, it might be an edge case, proceed to default return.\n            }\n            // If (offsetLocal - offsetAdjusted) >= 0, it might be a fall-back transition or an edge case.\n            // The overlap logic below handles the main fall-back scenario. Defaulting to offsetAdjusted\n            // might be correct for other edge cases where offsets differ.\n            \n        } else if (offsetLocal == offsetAdjusted) {\n            // Offsets match. This could be normal time, or an overlap where the initial guess and adjusted instant\n            // happen to fall into the same offset period (either both standard or both daylight).\n            // We need to check specifically for the overlap condition.\n            long prev = previousTransition(instantAdjusted);\n            // Ensure there was a previous transition.\n            if (prev < instantAdjusted) {\n                // Get the offset that was active *just before* the previous transition.\n                int offsetPrev = getOffset(prev - 1);\n                // Calculate the change in offset at that transition.\n                int diff = offsetAdjusted - offsetPrev;\n                // If the offset decreased (e.g., from +1h DST to 0h Standard), diff will be negative.\n                // This indicates a fall-back transition where an overlap occurs.\n                if (diff < 0) {\n                    // Check if the adjusted instant falls within the overlap period.\n                    // The duration of the overlap is the magnitude of the offset change (-diff, or offsetPrev - offsetAdjusted).\n                    // If the time elapsed since the transition (instantAdjusted - prev) is less than or equal to the overlap duration,\n                    // then instantAdjusted corresponds to a local time within the overlap.\n                    if (instantAdjusted - prev <= (long)(offsetPrev - offsetAdjusted)) {\n                        // We are in the overlap ambiguity zone.\n                        // The rule is to return the offset corresponding to the earlier instant,\n                        // which is the offset active *before* the transition (offsetPrev, typically the daylight offset).\n                        return offsetPrev;\n                    }\n                }\n            }\n        }\n        // Default case: Return the offset calculated from the adjusted instant.\n        // This handles normal cases (no transition nearby), and cases near transitions\n        // that weren't specifically handled by the gap or overlap logic above.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}