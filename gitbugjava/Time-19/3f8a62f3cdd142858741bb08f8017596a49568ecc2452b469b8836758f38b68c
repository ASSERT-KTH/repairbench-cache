{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        // Note: Using local instant here is approximation, may be inaccurate at transitions\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted); // Offset for first estimated UTC instant\n\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // If offsetLocal > offsetAdjusted, we are transitioning from DST to Standard (fall back / overlap)\n            // Example: offsetLocal=+1h, offsetAdjusted=0h.\n            if (offsetLocal > offsetAdjusted) {\n                 // For overlaps, favour DST offset (the larger offset, corresponding to the earlier UTC instant).\n                 return offsetLocal; // Return the DST offset directly.\n            } else {\n                 // Gap (offsetLocal < offsetAdjusted). Standard to DST transition.\n                 // Example: offsetLocal=0h, offsetAdjusted=+1h.\n                 // Check the edge case where the local instant is the transition time.\n                 // Calculate the next transition time based on both possible offsets.\n                 // If they differ, return the offset before the transition (offsetLocal).\n                 long nextLocal = nextTransition(instantAdjusted);\n                 // Use the second estimate for the other next transition check\n                 long instantAdjusted2 = instantLocal - offsetAdjusted;\n                 long nextAdjusted2 = nextTransition(instantAdjusted2);\n                 if (nextLocal != nextAdjusted2) {\n                     // This case implies instantLocal is likely the exact transition time.\n                     // The original code returned offsetLocal (offset before gap).\n                     // To favour times after the gap, we should arguably return offsetAdjusted.\n                     // However, sticking to minimal change based on original logic's likely intent for this exact instant.\n                     return offsetLocal;\n                 }\n                 // Otherwise, for gaps, favour the offset after the gap (DST). Fall through.\n            }\n        } else { // offsetLocal == offsetAdjusted\n            // This block handles cases where the transition was not detected by the\n            // difference check. This can happen if the initial guess offsetLocal\n            // was already the 'correct' offset for the estimated instantAdjusted.\n            // However, instantLocal could still be ambiguous (overlap).\n            // We need to check if instantAdjusted corresponds to the earlier time (DST)\n            // during an overlap. This uses logic inspired by Joda-Time commit fixing issue #19.\n\n            // Find the previous transition before the estimated UTC instant.\n             long prevTransition = previousTransition(instantAdjusted);\n             if (prevTransition < instantAdjusted) {\n                 // Calculate the DST savings. This requires getStandardOffset, assuming it's available.\n                 // Check the standard offset AT the adjusted instant, not the transition instant.\n                 int standardOffset = getStandardOffset(instantAdjusted);\n                 int dstSavings = offsetAdjusted - standardOffset;\n\n                 // Check if the current offset actually includes DST savings.\n                 if (dstSavings > 0) {\n                     // If we are in DST, check if the adjusted instant is close to the PREVIOUS transition.\n                     // If instantAdjusted is within the DST savings amount *after* the previous transition,\n                     // it implies this is the *first* occurrence of the local time (the DST one).\n                     // This handles the ambiguity during overlap by selecting the earlier instant.\n                     if (instantAdjusted - prevTransition <= dstSavings) {\n                         // instantAdjusted is confirmed as the earlier DST instance.\n                         // Return the current offset (which is the DST offset).\n                         return offsetAdjusted;\n                     }\n                 }\n             }\n             // If no DST savings, or if instantAdjusted is long after the previous transition,\n             // then offsetAdjusted is the correct offset (either standard time, or non-ambiguous DST).\n        }\n\n        // Return the calculated offset (offsetAdjusted). This is the offset after a gap (DST),\n        // or the standard offset if not in overlap/gap, or the DST offset if overlap check passed.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}