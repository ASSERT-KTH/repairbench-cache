{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        if (offsetLocal != offsetAdjusted) {\n            // Transition detected.\n            // If offsetLocal > offsetAdjusted, we are in a gap (e.g., 0 -> +1).\n            // Return the offset *after* the gap, which is offsetLocal.\n            // This handles the rule: \"method will return an offset suitable for\n            // calculating an instant after any DST gap\".\n            if (offsetLocal > offsetAdjusted) {\n                return offsetLocal;\n            } else {\n                // offsetLocal < offsetAdjusted. This condition is possible if the initial guess\n                // offsetLocal falls in the later period (e.g. standard time), but the adjusted instant\n                // instantAdjusted falls in the earlier period (e.g. daylight time).\n                // Example: Transition is +1 -> 0. offsetLocal=0, offsetAdjusted=+1.\n                // The rule is \"always favour daylight (summer) time\".\n                // In this case, offsetAdjusted represents the daylight time offset.\n                 return offsetAdjusted;\n            }\n        } else { // offsetLocal == offsetAdjusted\n            // This is the common case, far from transitions.\n            // It also covers the case where we are in an overlap period (e.g. +1 -> 0),\n            // and both estimates happen to yield the standard offset (0).\n            // We must detect this specific overlap case and return the DST offset (+1) instead.\n\n            // Check for overlap: find the transition occurring *before* the estimated UTC instant.\n            long prevTrans = previousTransition(instantAdjusted);\n            if (prevTrans < instantAdjusted) {\n                // Get the offset that was active *before* that transition.\n                int offsetBeforePrev = getOffset(prevTrans - 1);\n                // If the offset before the transition is different from our current estimate (offsetAdjusted)...\n                if (offsetBeforePrev != offsetAdjusted) {\n                    // ...it implies that 'instantAdjusted' is after a transition.\n                    // Now, check if the local time 'instantLocal' could *also* be achieved\n                    // using this alternative offset (offsetBeforePrev).\n                    long utcUsingOffsetBeforePrev = instantLocal - offsetBeforePrev;\n                    // Does this alternative UTC instant actually have the offset 'offsetBeforePrev'?\n                    // Perform this check only if the calculated UTC instant is different\n                    // from the one calculated using offsetAdjusted, to avoid infinite loops.\n                    if (getOffset(utcUsingOffsetBeforePrev) == offsetBeforePrev && utcUsingOffsetBeforePrev != instantAdjusted) {\n                        // Yes, it does. This confirms we are in an overlap.\n                        // 'instantLocal' can be interpreted using offsetAdjusted (standard) or offsetBeforePrev (daylight).\n                        // Rule: \"always favour daylight (summer) time\", which corresponds to the earlier instant.\n                        // The earlier UTC instant is 'utcUsingOffsetBeforePrev'.\n                        // Return the corresponding offset 'offsetBeforePrev'.\n                        return offsetBeforePrev;\n                    }\n                }\n            }\n            // If no overlap is detected, or if we are not near a transition where offsets differ,\n            // the initial consistent estimate 'offsetAdjusted' is correct.\n            return offsetAdjusted;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}