{
    "generation": "    static URL encodeUrl(URL u) {\n\t    u = punyUrl(u); // Make sure host is punycode if required.\n        try {\n            // Utilize URI constructor to properly encode components like path and query.\n            // URL.getPath(), getQuery(), etc. return decoded components.\n            // For example, a path like \"/foo bar\" will be returned by u.getPath() as \"/foo bar\".\n            // A query like \"q=a b\" will be returned by u.getQuery() as \"q=a b\".\n            // The URI constructor then percent-encodes these components.\n            URI uri = new URI(u.getProtocol(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());\n            \n            // URI.toASCIIString() will ensure all parts are ASCII (e.g. host via Punycode, though punyUrl should have done this)\n            // and correctly percent-encoded.\n            // Then, convert this well-formed URI string back to a URL.\n            return new URL(uri.toASCIIString());\n        } catch (URISyntaxException | MalformedURLException e) {\n            // Fallback: return the URL as processed by punyUrl, or original if punyUrl failed.\n            // This might happen if:\n            // 1. punyUrl returned a URL with issues (e.g., non-ASCII host if punyUrl itself failed)\n            //    that cause new URI(...) to fail.\n            // 2. The components from URL (even if individually valid) form an invalid URI combination\n            //    that URI constructor rejects. (Less likely for standard HTTP URLs).\n            // 3. The string from uri.toASCIIString() is somehow not parseable by new URL(),\n            //    though this should be very rare if URI is valid.\n            return u;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}