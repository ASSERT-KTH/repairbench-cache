{
    "generation": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n\n    // It's good practice to override equals and hashCode for comparison,\n    // especially when dealing with objects that conceptually represent values.\n    // However, for typical LeetCode problems, TreeNode comparison usually defaults to reference equality (==)\n    // unless explicitly defined. The fix below works regardless.\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        TreeNode treeNode = (TreeNode) o;\n        return val == treeNode.val;\n    }\n\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(val);\n    }\n}\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Base case: If root is null, or if p or q is the current root node (by reference),\n        // then the current root is the LCA.\n        // This handles cases where p or q are descendants of each other, or if one of them is the root itself.\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n\n        // If both p and q values are less than the current root's value,\n        // then the LCA must be in the left subtree.\n        // This condition replaces `(root.val - p.val) * (root.val - q.val) > 0` for the 'left' side.\n        if (root.val > p.val && root.val > q.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        // If both p and q values are greater than the current root's value,\n        // then the LCA must be in the right subtree.\n        // This condition replaces the `else` part of the original nested `if` for the 'right' side.\n        else if (root.val < p.val && root.val < q.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        // Otherwise (p and q are on opposite sides of the root, or one of them equals the root's value),\n        // the current root is the LCA.\n        // This covers the case where the original code would `return root;` at the end.\n        else {\n            return root;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}