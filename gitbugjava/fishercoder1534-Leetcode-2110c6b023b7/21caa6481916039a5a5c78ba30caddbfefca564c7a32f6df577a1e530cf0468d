{
    "generation": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n    }\n}\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Handle base cases:\n        // 1. If the current node is null, it cannot be an ancestor.\n        // 2. If p or q is the current root node (by reference equality), then root is the LCA.\n        //    This also handles the case where p or q's value matches root's value,\n        //    and effectively means if one of the nodes is found, it's the LCA if the other\n        //    node is in its subtree (which is always true for BST LCA definition).\n        if (root == null || p == root || q == root) {\n            return root;\n        }\n\n        // Determine if p and q are both in the left subtree or both in the right subtree.\n        // We use value comparison to navigate in a BST.\n        // If both p.val and q.val are less than root.val,\n        // then the LCA must be in the left subtree.\n        if (p.val < root.val && q.val < root.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        // If both p.val and q.val are greater than root.val,\n        // then the LCA must be in the right subtree.\n        else if (p.val > root.val && q.val > root.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        // Otherwise, p and q are on different sides of the root,\n        // or one of them is equal to root.val.\n        // In a BST, this means the current root is the lowest common ancestor.\n        else {\n            return root;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}