{
    "generation": "        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n            if (root == null || p == root || q == root) {\n                return root;\n            }\n            \n            // Calculate differences as long to prevent overflow in subsequent multiplication.\n            // (root.val - p.val) can also overflow int if root.val is Integer.MAX_VALUE\n            // and p.val is Integer.MIN_VALUE, so casting root.val to long first is important.\n            long diff_p = (long)root.val - p.val;\n            long diff_q = (long)root.val - q.val;\n\n            // If diff_p and diff_q have the same sign, their product will be positive.\n            // This means p and q are on the same side relative to root.\n            if (diff_p * diff_q > 0) {\n                // If diff_p > 0, it means root.val > p.val.\n                // Since p and q are on the same side, root.val > q.val must also hold.\n                // Therefore, both p and q are in the left subtree.\n                if (diff_p > 0) { \n                    return lowestCommonAncestor(root.left, p, q);\n                }\n                // Else (diff_p < 0), it means root.val < p.val.\n                // Both p and q are in the right subtree.\n                else { // diff_p < 0\n                    return lowestCommonAncestor(root.right, p, q);\n                }\n            }\n            // If the product diff_p * diff_q is <= 0, it means:\n            // 1. p and q are on different sides of root (one diff positive, one negative).\n            // 2. root.val == p.val (so diff_p is 0).\n            // 3. root.val == q.val (so diff_q is 0).\n            // In all these cases, the current root is the LCA.\n            // (The case where p or q is the root node by reference is handled by the initial check).\n            return root;\n        }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}