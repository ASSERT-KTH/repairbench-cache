{
    "generation": "        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n            if (root == null || p == root || q == root) {\n                return root;\n            }\n            // Cast one of the terms to long before multiplication to ensure the product is computed as long.\n            // This prevents integer overflow if the product (root.val - p.val) * (root.val - q.val)\n            // exceeds the int range, which can happen even if the individual differences fit in int.\n            if ((long)(root.val - p.val) * (root.val - q.val) > 0) {\n                // If (root.val - p.val) > 0, it means root.val > p.val.\n                // Since the product was positive, (root.val - p.val) and (root.val - q.val)\n                // must have the same sign. So, if root.val > p.val, then root.val must also be > q.val.\n                // This means both p and q are in the left subtree.\n                if (root.val - p.val > 0) {\n                    return lowestCommonAncestor(root.left, p, q);\n                }\n                // Otherwise (root.val - p.val < 0), root.val < p.val.\n                // By the same logic, root.val must also be < q.val.\n                // This means both p and q are in the right subtree.\n                return lowestCommonAncestor(root.right, p, q);\n            }\n            // If the product is <= 0, it means root.val is between p.val and q.val (inclusive),\n            // or root.val is equal to p.val or q.val. In these cases, root is the LCA.\n            return root;\n        }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}