{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    // We are only interested in expressions that are statements or part of\n    // a comma sequence that is itself a statement.\n    boolean isResultUsed = true; // Assume used by default.\n    if (parent.isExprResult() || parent.isBlock()) {\n      // Standard statement context. Result is unused unless NodeUtil says otherwise.\n      isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    } else if (parent.isComma()) {\n      // For comma operator, only the result of the last expression is used.\n      if (n != parent.getLastChild()) {\n         // Not the last child, result is never used in the comma expression itself.\n         isResultUsed = false;\n      } else {\n         // Last child. The result is used *by the comma expression*.\n         // Check if the comma expression's result is used by its parent context.\n         isResultUsed = NodeUtil.isExpressionResultUsed(parent);\n      }\n    } else if (parent.isFor() && parent.getChildCount() == 4) {\n       // Check FOR(init; cond; incr) structure.\n       Node condition = parent.getSecondChild();\n       Node increment = parent.getChildAtIndex(2);\n       if (n == condition) {\n         // Result of condition is used by FOR.\n         isResultUsed = true;\n       } else if (n == parent.getFirstChild() || n == increment) {\n         // Result of initializer or increment is not used by FOR.\n         isResultUsed = false;\n       } else {\n         // Must be the body node (or something unexpected). Assume result is used or handled elsewhere.\n         return;\n       }\n    } else {\n        // Expression is in some other context (assignment rhs, array literal, etc.)\n        // NodeUtil.isExpressionResultUsed should determine if the value is used.\n        // If used, we don't warn. If unused, it's likely not a \"statement\" context\n        // where this warning is typically desired (e.g., `[1, 2]`).\n        if (NodeUtil.isExpressionResultUsed(n)) {\n            return;\n        } else {\n            // Result is unused, but not in a standard statement context. Avoid warning.\n            return;\n        }\n    }\n\n    // If the result is used, don't report a warning.\n    if (isResultUsed) {\n        return;\n    }\n\n    // If we reach here, the expression's result is not used in its context.\n    // Now, check if the expression itself lacks side effects or is purely computational.\n\n    boolean lacksSideEffects = !NodeUtil.mayHaveSideEffects(n, t.getCompiler());\n    boolean isComputationalOperator = false;\n    // Check if the node type represents an operator whose primary purpose\n    // isn't side effects, even if operands might have them (e.g., ==, +, !, typeof).\n    // These are operators where discarding the result is suspicious.\n    switch (n.getType()) {\n        // Unary operators\n        case Token.POS: case Token.NEG: case Token.BITNOT: case Token.NOT:\n        case Token.TYPEOF: case Token.VOID:\n        // Comparison operators\n        case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE:\n        case Token.LT: case Token.GT: case Token.LE: case Token.GE:\n        case Token.INSTANCEOF: case Token.IN:\n        // Binary arithmetic/bitwise operators\n        case Token.ADD: case Token.SUB: case Token.MUL: case Token.DIV: case Token.MOD:\n        case Token.LSH: case Token.RSH: case Token.URSH:\n        case Token.BITOR: case Token.BITXOR: case Token.BITAND:\n        // Property accessors are typically side-effect free but compute a value.\n        case Token.GETPROP: case Token.GETELEM:\n            isComputationalOperator = true;\n            break;\n    }\n\n    // Warn if the expression provably lacks side effects OR is a computational operator\n    // whose result is discarded.\n    if (lacksSideEffects || isComputationalOperator) {\n      String msg = \"This code lacks side effects and its result is not used.\"; // Default\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isComputationalOperator && !n.isGetProp() && !n.isGetElem()\n                 && !n.isQualifiedName() && !n.isName()) {\n         // Specific message for operators like ==, +, typeof, etc.\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      } else if (n.isQualifiedName() || n.isName() || n.isGetProp() || n.isGetElem()) {\n         // Specific message for unused names/properties like `a.b;` or `myVar;`\n         msg = \"This name/property stands alone and has no apparent side effects.\";\n      }\n      // Else: Keep the default message for other cases like `5;`\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Keep original problemNodes logic for potential follow-up passes.\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}