{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n\n        // Check for '&#'\n        // Ensures there are at least 3 chars: &, #, potential digit/x\n        // The condition index < seqEnd - 2 ensures that index + 1 and index + 2 are valid indices.\n        if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int currentIdx = index + 2;\n            boolean isHex = false;\n\n            // Check if we are already at the end right after '#'\n            // This handles the case \"Test &#\" correctly.\n            // Note: currentIdx is seqEnd if input is exactly \"&#\" which is handled by index < seqEnd - 2 above.\n            // This check is important if the input is like \"&# \"\n            if (currentIdx == seqEnd) {\n                 return 0; // Incomplete sequence \"&#\"\n            }\n\n            // Check for 'x' or 'X' to indicate hex\n            char firstChar = input.charAt(currentIdx);\n            if (firstChar == 'x' || firstChar == 'X') {\n                currentIdx++;\n                isHex = true;\n                // Check there's still something after 'x'/'X'\n                // This handles the cases \"Test &#x\" and \"Test &#X\" correctly.\n                if (currentIdx == seqEnd) {\n                    return 0; // Incomplete sequence \"&#x\" or \"&#X\"\n                }\n            }\n\n            int digitStart = currentIdx;\n\n            // Find the end of the digits by iterating while characters are valid digits for the base\n            while (currentIdx < seqEnd) {\n                char c = input.charAt(currentIdx);\n                if (isHex) {\n                    // Check for valid hex digit [0-9a-fA-F]\n                    if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))) {\n                        break; // Character is not a valid hex digit\n                    }\n                } else {\n                    // Check for valid decimal digit [0-9]\n                    if (!(c >= '0' && c <= '9')) {\n                        break; // Character is not a valid decimal digit\n                    }\n                }\n                currentIdx++;\n            }\n\n            // Check if any digits were actually found after &# or &#x\n            if (currentIdx == digitStart) {\n                return 0; // No digits found (e.g., \"&#;\", \"&#x;\", \"&# not a number\")\n            }\n\n            int entityValue;\n            try {\n                // Parse the numeric value from the identified digit sequence\n                String number = input.subSequence(digitStart, currentIdx).toString();\n                if (isHex) {\n                    entityValue = Integer.parseInt(number, 16);\n                } else {\n                    entityValue = Integer.parseInt(number, 10);\n                }\n            } catch (NumberFormatException nfe) {\n                // This should be logically unreachable due to the prior digit checks,\n                // but catch it defensively. Treat as an invalid sequence.\n                return 0;\n            }\n\n            // Output the character(s). Handles Supplementary Characters correctly.\n            if (entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                // Write Basic Multilingual Plane characters.\n                // Note: The original code wrote any value, including potentially invalid ones.\n                // This fix maintains that behavior for compatibility.\n                out.write(entityValue);\n            }\n\n            // Calculate the total number of characters consumed from the input.\n            // currentIdx currently points just after the last digit.\n            int consumedLength = currentIdx - index;\n\n            // Check for an optional semicolon ';' immediately after the digits.\n            // If present, it's part of the entity and should be consumed.\n            if (currentIdx < seqEnd && input.charAt(currentIdx) == ';') {\n                 consumedLength++; // Increment consumed length to include the semicolon\n            }\n\n            // Return the number of input characters that formed the numeric entity.\n            return consumedLength;\n\n        }\n        // Return 0 if the input sequence starting at 'index' does not begin with \"&#\"\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}