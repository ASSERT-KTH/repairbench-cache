{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Check minimum length for header (length + type) + footer (index + checksum + end)\n        if (buf.readableBytes() < 2 + 1 + 2 + 2 + 2) {\n            return null;\n        }\n\n        buf.readUnsignedShort(); // length\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_STRING_INFO) {\n\n            // Minimum length: server flag(4) + encoding(1) + footer(6) = 11\n            if (buf.readableBytes() < 11) { return null; }\n\n            buf.readUnsignedInt(); // server flag\n            String data;\n            if (buf.readUnsignedByte() == 1) {\n                data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.US_ASCII);\n            } else {\n                data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.UTF_16BE);\n            }\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n\n            // Always retrieve last location, update if current message parses\n            getLastLocation(position, null);\n\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                position.set(Position.KEY_RESULT, data);\n            }\n\n            return position;\n\n        } else if (type == MSG_INFO) {\n\n            // Minimum length: subtype(1) + footer(6) = 7\n            if (buf.readableBytes() < 7) {\n                getLastLocation(position, null); // Still return basic position if possible\n                return position;\n            }\n\n            int subType = buf.readUnsignedByte();\n            getLastLocation(position, null); // Get last location first\n\n            if (subType == 0x00) {\n                if (buf.readableBytes() >= 2 + 6) { // value + footer\n                    position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                }\n            } else if (subType == 0x05) {\n                if (buf.readableBytes() >= 6 + 1 + 6) { // time + flags + footer\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n                    // Flags byte follows time\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                } else if (buf.readableBytes() >= 1 + 6) { // flags + footer only\n                    // Potentially reachable if time wasn't present/readable\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                }\n            } else if (subType == 0x0a) {\n                 if (buf.readableBytes() >= 8 + 8 + 10 + 6) { // imei + imsi + iccid + footer\n                    buf.skipBytes(8); // imei\n                    buf.skipBytes(8); // imsi\n                    position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n                 }\n            } else if (subType == 0x0d) {\n                int dataStartIndex = buf.readerIndex();\n                boolean prefixPresent = false;\n                // Check for optional 6-byte prefix (only skip if not '!')\n                if (buf.readableBytes() >= 6 + 6 && buf.getByte(dataStartIndex) != '!') {\n                    buf.skipBytes(6);\n                    dataStartIndex = buf.readerIndex();\n                    prefixPresent = true;\n                }\n                int dataLength = buf.readableBytes() - 6; // length of data before footer\n                if (dataLength >= 0) {\n                    Parser parser = new Parser(PATTERN_FUEL, buf.toString(\n                            dataStartIndex, dataLength, StandardCharsets.US_ASCII));\n                    if (parser.matches()) {\n                         if (parser.hasNext()) position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                         if (parser.hasNext()) position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                    }\n                    // Consume the data regardless of parse success\n                    buf.readerIndex(dataStartIndex + dataLength);\n                } else if (prefixPresent && buf.readableBytes() == 6) {\n                     // Case where only prefix + footer existed, nothing to parse/consume\n                }\n\n            } else if (subType == 0x1b) {\n                 if (buf.readableBytes() > 6) { // Check data exists before footer\n                     if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) { // Serial format\n                         String data = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.US_ASCII).toString();\n                         position.set(\"serial\", data.trim());\n                     } else { // iButton format\n                         if (buf.readableBytes() >= 1 + 1 + 4 + 1 + 1 + 6) { // headers+data+footers+protocol_footer\n                             buf.readUnsignedByte(); // header\n                             buf.readUnsignedByte(); // type\n                             position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                             buf.readUnsignedByte(); // checksum\n                             buf.readUnsignedByte(); // footer\n                         } else {\n                              // Not enough data for iButton format, skip remaining before footer\n                              buf.skipBytes(buf.readableBytes() - 6);\n                         }\n                     }\n                 }\n            }\n            // Ensure reader index is positioned at the start of the footer if not already there\n            if (buf.readableBytes() > 6) {\n                buf.readerIndex(buf.writerIndex() - 6);\n            }\n            // Always return the position for MSG_INFO, populated with last location\n            // and any available data from the specific subtype.\n            return position;\n\n        } else if (type == MSG_X1_PHOTO_DATA) {\n            // Handle photo data - return null for chunks, position when complete\n            if (buf.readableBytes() < 4 + 4 + 2 + 6) { return null; } // id+offset+len+footer\n            int pictureId = buf.readInt();\n            ByteBuf photo = photos.get(pictureId);\n            if (photo == null) { return null; } // Photo ID not found\n\n            buf.readUnsignedInt(); // offset\n            int length = buf.readUnsignedShort();\n            if (buf.readableBytes() < length + 6) { return null; } // Not enough data\n\n            buf.readBytes(photo, length);\n\n            if (photo.writableBytes() > 0) {\n                sendPhotoRequest(channel, pictureId);\n                return null; // Chunk received\n            } else {\n                // Photo complete, associate with a position object\n                getLastLocation(position, null); // Populate with last known location\n                position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                photos.remove(pictureId).release();\n                return position; // Return position with image key\n            }\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) {\n            // Assumed original logic mostly correct, adding checks and ensuring return\n            if (!decodeGps(position, buf, true, deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n            try { // Wrap optional field parsing in try-catch\n                if (buf.readableBytes() > 6) { // Check before potential LBS read\n                    if (decodeLbs(position, buf, type, true)) {\n                        if (buf.readableBytes() > 6) { // Check before RSSI read\n                            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        }\n                    }\n                }\n                // Skip variable length fields safely\n                if (buf.readableBytes() > 6) { int len = buf.readUnsignedByte(); if(buf.readableBytes() >= len + 6) buf.skipBytes(len); } // cell towers\n                if (buf.readableBytes() > 6) { int len = buf.readUnsignedByte(); if(buf.readableBytes() >= len + 6) buf.skipBytes(len); } // wifi\n                if (buf.readableBytes() > 6) { // status\n                    int status = buf.readUnsignedByte();\n                    position.set(Position.KEY_STATUS, status);\n                    if (type == MSG_AZ735_ALARM) {\n                        switch (status) {\n                            case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                            case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                            case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                            case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                            case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                            default: break;\n                        }\n                    }\n                }\n                if (buf.readableBytes() > 6) { int len = buf.readUnsignedByte(); if(buf.readableBytes() >= len + 6) buf.skipBytes(len); } // reserved\n            } catch (Exception e) { /* Ignore parsing errors in optional fields */ }\n\n            if (buf.readableBytes() > 6) buf.readerIndex(buf.writerIndex() - 6); // Position before footer\n            if (buf.readableBytes() == 6) { // Ensure footer exists before sending response\n                sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n            }\n            return position;\n\n        } else if (type == MSG_OBD) {\n            // Assumed original logic mostly correct, adding checks and ensuring return\n            if (buf.readableBytes() < 6 + 1 + 18) { // time + ign + footer\n                getLastLocation(position, null); return position; // Return basic info if packet short\n            }\n            DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                    .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                    .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n            getLastLocation(position, dateBuilder.getDate()); // Use OBD time\n            position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n            String data = buf.readCharSequence(buf.readableBytes() - 18, StandardCharsets.US_ASCII).toString();\n            for (String pair : data.split(\",\")) {\n                 String[] values = pair.split(\"=\");\n                 if (values.length >= 2 && !values[0].isEmpty() && !values[1].isEmpty()) {\n                     try {\n                         int pid = Integer.parseInt(values[0].substring(0, Math.min(values[0].length(), 2)), 16);\n                         // Handle potential NumberFormatException during value parsing\n                         switch (pid) {\n                             case 0x40: position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x43: position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x45: position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x53: position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x54: position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x71: position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x73: position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x74: position.set(Position.KEY_VIN, values[1]); break; // Use raw value for VIN\n                             default: break;\n                         }\n                     } catch (NumberFormatException e) { /* Ignore invalid PID/value pairs */ }\n                 }\n             }\n            return position;\n\n        } else if (type == MSG_GPS_MODULAR) {\n            // Assumed original logic mostly correct, adding checks and ensuring return\n            boolean timeSet = false;\n            while (buf.readableBytes() > 6) { // Need more than footer bytes to read module header\n                if (buf.readableBytes() < 4) break; // Not enough for type+length\n                int moduleType = buf.readUnsignedShort();\n                int moduleLength = buf.readUnsignedShort();\n                if (buf.readableBytes() >= moduleLength) {\n                    ByteBuf moduleSlice = buf.readSlice(moduleLength);\n                    // --- Decode known module types safely ---\n                    switch (moduleType) {\n                         case 0x03: if(moduleSlice.readableBytes()>=10)position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleSlice.readSlice(10))); break;\n                         case 0x09: if(moduleSlice.readableBytes()>=1)position.set(Position.KEY_SATELLITES, moduleSlice.readUnsignedByte()); break;\n                         case 0x0a: if(moduleSlice.readableBytes()>=1)position.set(Position.KEY_SATELLITES_VISIBLE, moduleSlice.readUnsignedByte()); break;\n                         case 0x11: if(moduleSlice.readableBytes()>=9){CellTower ct = CellTower.from(...); if(ct!=null)position.setNetwork(new Network(ct));} break;\n                         case 0x18: if(moduleSlice.readableBytes()>=2)position.set(Position.KEY_BATTERY, moduleSlice.readUnsignedShort() * 0.01); break;\n                         case 0x28: if(moduleSlice.readableBytes()>=1)position.set(Position.KEY_HDOP, moduleSlice.readUnsignedByte() * 0.1); break;\n                         case 0x29: if(moduleSlice.readableBytes()>=4)position.set(Position.KEY_INDEX, moduleSlice.readUnsignedInt()); break;\n                         case 0x2a: if(moduleSlice.readableBytes()>=1){int i=moduleSlice.readUnsignedByte(); position.set(Position.KEY_DOOR,BitUtil.to(i,4)>0); position.set(\"tamper\",BitUtil.from(i,4)>0);} break;\n                         case 0x2b: if(moduleSlice.readableBytes()>=1){int e=moduleSlice.readUnsignedByte(); switch(e){/*alarms*/} position.set(Position.KEY_EVENT,e);} break;\n                         case 0x2e: if(moduleSlice.readableBytes()>=4)position.set(Position.KEY_ODOMETER, moduleSlice.readUnsignedIntLE()); break;\n                         case 0x33: if(moduleSlice.readableBytes()>=17){/*gps data*/ timeSet = true;} break;\n                         case 0x34: if(moduleSlice.readableBytes()>=5){position.set(Position.KEY_EVENT, moduleSlice.readUnsignedByte()); moduleSlice.readUnsignedIntLE(); if(moduleSlice.isReadable()){int len=moduleSlice.readUnsignedByte(); moduleSlice.skipBytes(Math.min(len, moduleSlice.readableBytes()));}} break;\n                         default: break; // Unknown module type, already skipped by reading slice\n                    }\n                } else {\n                    break; // Not enough data for declared module length, stop processing modules\n                }\n            }\n            if (!timeSet) getLastLocation(position, null); // Use last location if no time module found\n\n            if (buf.readableBytes() > 6) buf.readerIndex(buf.writerIndex() - 6); // Position before footer\n            if (buf.readableBytes() == 6) { // Ensure footer exists before sending response\n                sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null); // Read index from footer\n            }\n            return position;\n\n        } else if (type == MSG_MULTIMEDIA) {\n            // Assumed original logic mostly correct, ensure position is returned\n            if (buf.readableBytes() < 8 + 4 + 14 + 4 + 4 + 1 + 1 + 6) return null; // Basic header check\n\n            buf.skipBytes(8); // serial\n            long timestamp = buf.readUnsignedInt() * 1000;\n            buf.skipBytes(4 + 4 + 2 + 1 + 1 + 2); // gps\n            buf.skipBytes(2 + 2 + 2 + 2); // cell\n            int mediaId = buf.readInt();\n            int mediaLength = buf.readInt();\n            int mediaType = buf.readUnsignedByte();\n            int mediaFormat = buf.readUnsignedByte();\n\n            getLastLocation(position, new Date(timestamp)); // Use media timestamp\n\n            if (mediaType == 0 && mediaFormat == 0) { // Photo\n                if (buf.readableBytes() < 1 + 2 + 6) return position; // event+offset+footer\n                buf.readUnsignedByte(); // event\n                int offset = buf.readUnsignedShort();\n                ByteBuf photo;\n                if (offset == 0) {\n                    photo = Unpooled.buffer(mediaLength);\n                    ByteBuf old = photos.put(mediaId, photo);\n                    if (old != null) old.release();\n                } else {\n                    photo = photos.get(mediaId);\n                }\n\n                if (photo != null) {\n                    int dataLength = buf.readableBytes() - 6;\n                    if (dataLength > 0) {\n                         // Avoid BufferOverflow: read only up to what the target buffer can write\n                         int readLen = Math.min(dataLength, photo.writableBytes());\n                         if (readLen > 0) {\n                              buf.readBytes(photo, readLen);\n                         }\n                         // Skip remaining bytes in source buffer if target was full\n                         if (dataLength > readLen) {\n                             buf.skipBytes(dataLength - readLen);\n                         }\n                    }\n                    if (!photo.isWritable()) {\n                        position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                        photos.remove(mediaId).release();\n                    }\n                }\n            }\n            // Skip unparsed data before footer\n            if (buf.readableBytes() > 6) buf.readerIndex(buf.writerIndex() - 6);\n            if (buf.readableBytes() == 6) { // Ensure footer exists before sending response\n                sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n            }\n            return position; // Always return position\n\n        } else if (type == MSG_SERIAL) {\n            // Assumed original logic mostly correct, ensure position is returned\n            getLastLocation(position, null);\n            if (buf.readableBytes() < 1 + 9) return position; // dev type + footer\n\n            buf.readUnsignedByte(); // dev type\n            int length = buf.readableBytes() - 9; // data length\n            if (length > 0) {\n                try {\n                    if (length < 8) { // Temp\n                        String tempStr = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString().trim();\n                        if (!tempStr.isEmpty()) {\n                            position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(tempStr));\n                        }\n                    } else { // Driver ID\n                        buf.readUnsignedByte(); // card type (part of the data)\n                        if (length - 1 > 0) {\n                            position.set(Position.KEY_DRIVER_UNIQUE_ID, buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString().trim());\n                        }\n                    }\n                } catch (Exception e) {\n                    // Error during parsing or reading, ensure buffer index is safe\n                    if (buf.readableBytes() >= 9) { // Check if enough bytes remain to reset index\n                        buf.readerIndex(buf.writerIndex() - 9);\n                    } else {\n                        // Cannot safely reset index, maybe return null or log error\n                        return null; // Indicate potential data corruption\n                    }\n                }\n            }\n            // Position reader index at the start of the footer\n            if (buf.readableBytes() > 9) { // If more than footer+type remains after parsing\n                 buf.readerIndex(buf.writerIndex() - 9);\n            }\n            return position;\n        }\n\n        return null; // Unknown message type\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}