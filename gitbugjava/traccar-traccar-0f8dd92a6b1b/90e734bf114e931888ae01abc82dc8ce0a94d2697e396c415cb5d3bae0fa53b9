{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        // Ensure timezone is set\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n        TimeZone timeZone = (TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE); // Use the retrieved timezone\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        buf.readUnsignedShort(); // length\n        int type = buf.readUnsignedByte();\n\n        // Assume a standard footer length (e.g., index + checksum + end = 6 bytes) for skipping unparsed data\n        // This might vary slightly between message types, adjust locally if needed.\n        final int FOOTER_LENGTH = 6;\n\n        if (type == MSG_STRING_INFO) { // 0xA7\n\n            if (buf.readableBytes() < 4 + 1 + FOOTER_LENGTH) { // server flag + encoding + footer\n                return null;\n            }\n            buf.readUnsignedInt(); // server flag\n            String data;\n            int dataLength = buf.readableBytes() - FOOTER_LENGTH;\n            if (dataLength <= 0) {\n                 return null; // No data\n            }\n            if (buf.readUnsignedByte() == 1) { // encoding flag\n                data = buf.readSlice(dataLength).toString(StandardCharsets.US_ASCII);\n            } else {\n                data = buf.readSlice(dataLength).toString(StandardCharsets.UTF_16BE);\n            }\n            buf.skipBytes(FOOTER_LENGTH); // Skip footer\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n            if (parser.matches()) {\n                try {\n                    position.setValid(true);\n                    position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                    position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                    position.setCourse(parser.nextDouble());\n                    position.setSpeed(parser.nextDouble());\n                    position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n                } catch (Exception e) {\n                    // Parsing failed\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_RESULT, data);\n                }\n            } else {\n                getLastLocation(position, null);\n                position.set(Position.KEY_RESULT, data);\n            }\n            return position;\n\n        } else if (type == MSG_INFO) { // 0xA5\n\n            if (buf.readableBytes() < 1 + FOOTER_LENGTH) return null; // Need at least subtype + footer\n            int subType = buf.readUnsignedByte();\n            getLastLocation(position, null);\n\n            int bytesConsumed = 1; // subtype byte\n\n            if (subType == 0x00) {\n                if (buf.readableBytes() >= 2) { // Ensure voltage bytes exist\n                    position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                    bytesConsumed += 2;\n                }\n            } else if (subType == 0x05) {\n                if (buf.readableBytes() >= 6 + 1) { // Need 6 (date/time) + 1 (flags)\n                    DateBuilder dateBuilder = new DateBuilder(timeZone)\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                    bytesConsumed += 7;\n                }\n            } else if (subType == 0x0a) {\n                if (buf.readableBytes() >= 8 + 8 + 10) { // Need 8 (imei) + 8 (imsi) + 10 (iccid)\n                    buf.skipBytes(8); // imei\n                    buf.skipBytes(8); // imsi\n                    position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n                    bytesConsumed += 26;\n                }\n            } else if (subType == 0x0d) {\n                int startIndex = buf.readerIndex();\n                int initialReadable = buf.readableBytes();\n                if (buf.getByte(startIndex) != '!') {\n                    if (buf.readableBytes() < 6) { buf.skipBytes(buf.readableBytes()); return position; } // Cannot skip\n                    buf.skipBytes(6);\n                    startIndex = buf.readerIndex();\n                }\n                // Assume footer is 4 (checksum?) + 2 (index/footer?) = 6\n                int dataLength = buf.readableBytes() - FOOTER_LENGTH;\n                if (dataLength <= 0) { buf.skipBytes(buf.readableBytes()); return position; } // No data\n\n                Parser parser = new Parser(PATTERN_FUEL, buf.toString(startIndex, dataLength, StandardCharsets.US_ASCII));\n                if (!parser.matches()) {\n                    return null; // Maintain original null return for parsing failure\n                }\n                try {\n                    position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                    position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                } catch (Exception e) { /* Ignore parsing errors */ }\n                buf.readerIndex(startIndex + dataLength); // Consume data\n                bytesConsumed = initialReadable - buf.readableBytes();\n            } else if (subType == 0x1b) {\n                int dataLength = buf.readableBytes() - FOOTER_LENGTH;\n                if (dataLength <= 0) { buf.skipBytes(buf.readableBytes()); return position; } // No data\n\n                if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) {\n                    String data = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                    position.set(\"serial\", data.trim());\n                    bytesConsumed += dataLength;\n                } else {\n                    if (dataLength >= 1 + 1 + 4 + 1 + 1) { // header+type+id+cs+footer for inner structure\n                        buf.readUnsignedByte(); // header\n                        buf.readUnsignedByte(); // type\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                        buf.readUnsignedByte(); // checksum\n                        buf.readUnsignedByte(); // footer\n                        bytesConsumed += 8;\n                        // Skip any remaining data if dataLength was larger\n                        buf.skipBytes(dataLength - 8);\n                    } else {\n                        buf.skipBytes(dataLength); // Skip unknown structure\n                        bytesConsumed += dataLength;\n                    }\n                }\n            } else {\n                // Unknown subtype, skip remaining bytes before footer\n                 buf.skipBytes(buf.readableBytes() - FOOTER_LENGTH);\n            }\n\n            // Skip footer\n            if (buf.readableBytes() >= FOOTER_LENGTH) {\n                 buf.skipBytes(FOOTER_LENGTH);\n            } else {\n                 buf.skipBytes(buf.readableBytes());\n            }\n            return position; // Return position for handled subtypes and unhandled ones like 0x03\n\n        } else if (type == MSG_X1_PHOTO_DATA) { // 0x1A\n\n            if (buf.readableBytes() < 4 + 4 + 2 + FOOTER_LENGTH) return null; // Min length: id + offset + length + data(0) + footer\n\n            int pictureId = buf.readInt();\n            ByteBuf photo = photos.get(pictureId);\n            if (photo == null) {\n                 return null; // Cannot process without buffer\n            }\n\n            buf.readUnsignedInt(); // offset\n            int photoDataLength = buf.readUnsignedShort();\n\n            if (buf.readableBytes() < photoDataLength + FOOTER_LENGTH) return null; // Check buffer has data + footer\n\n            int bytesToRead = Math.min(photoDataLength, photo.writableBytes());\n            buf.readBytes(photo, bytesToRead);\n            // Skip any part of declared length that didn't fit or was already full\n            buf.skipBytes(photoDataLength - bytesToRead);\n\n            // Skip footer\n            if (buf.readableBytes() >= FOOTER_LENGTH) buf.skipBytes(FOOTER_LENGTH); else buf.skipBytes(buf.readableBytes());\n\n            if (photo.writableBytes() > 0) {\n                // Photo data transfer ongoing\n                sendPhotoRequest(channel, pictureId);\n                getLastLocation(position, null);\n                return position; // Return basic position object\n            } else {\n                // Photo transfer complete\n                getLastLocation(position, null);\n                position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                photos.remove(pictureId).release();\n                return position; // Return position with image\n            }\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) { // 0xA2, 0xA4\n             // Assume decodeGps/Lbs handle buffer reading correctly up to variable length fields\n             if (!decodeGps(position, buf, true, timeZone)) {\n                 getLastLocation(position, position.getDeviceTime());\n             }\n             if (decodeLbs(position, buf, type, true)) {\n                 if (buf.readableBytes() >= 1) position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n             }\n             // Safely skip variable length fields\n             if (buf.readableBytes() >= 1) buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes()));\n             if (buf.readableBytes() >= 1) buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes()));\n             if (buf.readableBytes() >= 1) {\n                 int status = buf.readUnsignedByte();\n                 position.set(Position.KEY_STATUS, status);\n                 if (type == MSG_AZ735_ALARM) {\n                     switch (status) {\n                         case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                         case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                         case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                         case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                         case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                         default: break;\n                     }\n                 }\n             }\n             if (buf.readableBytes() >= 1) buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes()));\n\n             // Send response using index from footer (read before consuming footer)\n             if (buf.readableBytes() >= FOOTER_LENGTH) {\n                 sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - FOOTER_LENGTH), null);\n                 buf.skipBytes(FOOTER_LENGTH); // Consume footer\n             } else {\n                 buf.skipBytes(buf.readableBytes()); // Consume rest\n             }\n             return position;\n\n        } else if (type == MSG_OBD || type == 0x24) { // 0x66 or 0x24\n\n             // Assume footer is 18 bytes for this type as per original code\n             final int OBD_FOOTER_LENGTH = 18;\n             if (buf.readableBytes() < 6 + 1 + OBD_FOOTER_LENGTH) return position; // Min header + footer\n\n             DateBuilder dateBuilder = new DateBuilder(timeZone)\n                     .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                     .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n             getLastLocation(position, dateBuilder.getDate());\n\n             position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n             int obdDataLength = buf.readableBytes() - OBD_FOOTER_LENGTH;\n             if (obdDataLength > 0) {\n                 String data = buf.readCharSequence(obdDataLength, StandardCharsets.US_ASCII).toString();\n                 for (String pair : data.split(\",\")) {\n                     String[] values = pair.split(\"=\");\n                     if (values.length >= 2 && values[0].length() >= 2) { // Check lengths\n                         try {\n                             switch (Integer.parseInt(values[0].substring(0, 2), 16)) {\n                                 case 0x28: position.set(Position.KEY_FUEL_CONSUMPTION, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x40: position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x43: position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x45: position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x53: position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x54: position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x71: position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01); break;\n                                 case 0x73: position.set(Position.KEY_HOURS, UnitsConverter.msFromHours(Integer.parseInt(values[1], 16) * 0.01)); break;\n                                 case 0x74: position.set(Position.KEY_VIN, values[1]); break;\n                                 default: break;\n                             }\n                         } catch (Exception e) { /* Ignore parsing errors */ }\n                     }\n                 }\n             }\n             // Skip footer bytes\n             if (buf.readableBytes() >= OBD_FOOTER_LENGTH) buf.skipBytes(OBD_FOOTER_LENGTH); else buf.skipBytes(buf.readableBytes());\n             return position;\n\n        } else if (type == MSG_GPS_MODULAR) { // 0x70\n\n            getLastLocation(position, null);\n            // Assume footer is 2 bytes index/checksum for this type\n            final int MODULAR_FOOTER_LENGTH = 2;\n\n            while (buf.readableBytes() > FOOTER_LENGTH) { // Check enough bytes for header + standard footer\n                int readerIndexStart = buf.readerIndex();\n                if (buf.readableBytes() < 4) break; // Need type + length\n                int moduleType = buf.readUnsignedShort();\n                int moduleLength = buf.readUnsignedShort();\n\n                if (buf.readableBytes() < moduleLength) {\n                    buf.readerIndex(readerIndexStart); // Reset if not enough data for module\n                    break;\n                }\n\n                ByteBuf moduleBuf = buf.readSlice(moduleLength);\n\n                try { // Wrap module parsing to prevent errors breaking the loop\n                    switch (moduleType) {\n                        case 0x03: if (moduleBuf.readableBytes() >= 10) position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleBuf.readSlice(10)).replaceAll(\"f\", \"\")); break;\n                        case 0x09: if (moduleBuf.readableBytes() >= 1) position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte()); break;\n                        case 0x0a: if (moduleBuf.readableBytes() >= 1) position.set(Position.KEY_SATELLITES_VISIBLE, moduleBuf.readUnsignedByte()); break;\n                        case 0x11:\n                            if (moduleBuf.readableBytes() >= 10) { // 2+2+2+3+1 = 10\n                                CellTower cellTower = CellTower.from(\n                                        moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(),\n                                        moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedMedium(),\n                                        moduleBuf.readUnsignedByte());\n                                // Check MCC is not null before creating Network object\n                                if (cellTower != null && cellTower.getMobileCountryCode() != null) position.setNetwork(new Network(cellTower));\n                            } break;\n                        case 0x18: if (moduleBuf.readableBytes() >= 2) position.set(Position.KEY_BATTERY, moduleBuf.readUnsignedShort() * 0.01); break;\n                        case 0x28: if (moduleBuf.readableBytes() >= 1) position.set(Position.KEY_HDOP, moduleBuf.readUnsignedByte() * 0.1); break;\n                        case 0x29: if (moduleBuf.readableBytes() >= 4) position.set(Position.KEY_INDEX, moduleBuf.readUnsignedInt()); break;\n                        case 0x2a:\n                            if (moduleBuf.readableBytes() >= 1) {\n                                int input = moduleBuf.readUnsignedByte();\n                                position.set(Position.KEY_DOOR, BitUtil.to(input, 4) > 0);\n                                position.set(\"tamper\", BitUtil.from(input, 4) > 0);\n                            } break;\n                        case 0x2b:\n                            if (moduleBuf.readableBytes() >= 1) {\n                                int event = moduleBuf.readUnsignedByte();\n                                switch (event) {\n                                    case 0x11: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                                    case 0x12: position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER); break;\n                                    case 0x13: position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT); break;\n                                    case 0x14: position.set(Position.KEY_ALARM, Position.ALARM_REMOVING); break;\n                                    default: break;\n                                }\n                                position.set(Position.KEY_EVENT, event);\n                            } break;\n                        case 0x2e: if (moduleBuf.readableBytes() >= 4) position.set(Position.KEY_ODOMETER, moduleBuf.readUnsignedIntLE()); break;\n                        case 0x33:\n                            if (moduleBuf.readableBytes() >= 18) { // 4+1+2+4+4+1+2=18\n                                position.setTime(new Date(moduleBuf.readUnsignedInt() * 1000));\n                                position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte());\n                                position.setAltitude(moduleBuf.readShort());\n                                double lat = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                                double lon = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                                position.setSpeed(UnitsConverter.knotsFromKph(moduleBuf.readUnsignedByte()));\n                                int flags = moduleBuf.readUnsignedShort();\n                                position.setCourse(BitUtil.to(flags, 10));\n                                position.setValid(BitUtil.check(flags, 12));\n                                if (!BitUtil.check(flags, 10)) lat = -lat;\n                                if (BitUtil.check(flags, 11)) lon = -lon;\n                                position.setLatitude(lat);\n                                position.setLongitude(lon);\n                            } break;\n                        case 0x34:\n                             if (moduleBuf.readableBytes() >= 1 + 4 + 1) { // event + time + length\n                                 position.set(Position.KEY_EVENT, moduleBuf.readUnsignedByte());\n                                 moduleBuf.readUnsignedIntLE(); // time\n                                 int contentLength = moduleBuf.readUnsignedByte();\n                                 if (moduleBuf.readableBytes() >= contentLength) moduleBuf.skipBytes(contentLength); // skip content\n                             } break;\n                        default: break; // Unknown module type, already sliced/skipped\n                    }\n                } catch (Exception e) {\n                    // Ignore parsing errors within a module, prevents breaking the loop\n                }\n            }\n\n            if (position.getFixTime() == null) {\n                getLastLocation(position, null);\n            }\n            // Consume footer index/checksum\n            if (buf.readableBytes() >= MODULAR_FOOTER_LENGTH) {\n               sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null);\n            } else {\n                buf.skipBytes(buf.readableBytes()); // Consume rest\n            }\n            return position;\n\n        } else if (type == MSG_MULTIMEDIA) { // 0x69\n\n            getLastLocation(position, null);\n            // Minimum length check: headers before media info + media info + footer\n            if (buf.readableBytes() < 8 + 4 + 10 + 4 + 4 + 1 + 1 + 1 + 2 + FOOTER_LENGTH) {\n                 buf.skipBytes(buf.readableBytes());\n                 return position; // Return basic position if too short\n            }\n\n            buf.skipBytes(8); // serial number\n            long timestamp = buf.readUnsignedInt() * 1000;\n            buf.skipBytes(4 + 4 + 2 + 1 + 1 + 2); // gps\n            buf.skipBytes(2 + 2 + 2 + 2); // cell\n\n            int mediaId = buf.readInt();\n            int mediaLength = buf.readInt();\n            int mediaType = buf.readUnsignedByte();\n            int mediaFormat = buf.readUnsignedByte();\n\n            if (mediaType == 0 && mediaFormat == 0) { // Photo JPEG\n                if (buf.readableBytes() < 1 + 2 + FOOTER_LENGTH) { // event + index + footer\n                    buf.skipBytes(buf.readableBytes()); return position;\n                }\n                buf.readUnsignedByte(); // event\n                int packetIndex = buf.readUnsignedShort();\n                ByteBuf photo;\n                if (packetIndex == 0) {\n                    photo = Unpooled.buffer(mediaLength);\n                    if (photos.containsKey(mediaId)) { photos.remove(mediaId).release(); }\n                    photos.put(mediaId, photo);\n                } else {\n                    photo = photos.get(mediaId);\n                }\n\n                if (photo != null) {\n                    int photoDataLength = buf.readableBytes() - FOOTER_LENGTH;\n                    if (photoDataLength > 0) {\n                         int bytesToRead = Math.min(photoDataLength, photo.writableBytes());\n                         buf.readBytes(photo, bytesToRead);\n                         buf.skipBytes(photoDataLength - bytesToRead); // Skip excess declared data\n                    }\n\n                    if (!photo.isWritable()) { // Photo complete\n                        try {\n                            position.setTime(new Date(timestamp));\n                            position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                        } finally {\n                             photos.remove(mediaId).release();\n                        }\n                    }\n                } else {\n                    // Photo null, skip remaining data before footer\n                    int dataLength = buf.readableBytes() - FOOTER_LENGTH;\n                    if (dataLength > 0) buf.skipBytes(dataLength);\n                }\n            } else {\n                // Not photo type, skip remaining data before footer\n                int dataLength = buf.readableBytes() - FOOTER_LENGTH;\n                if (dataLength > 0) buf.skipBytes(dataLength);\n            }\n\n            // Consume footer bytes\n            if (buf.readableBytes() >= FOOTER_LENGTH) {\n                sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - FOOTER_LENGTH), null);\n                 buf.skipBytes(FOOTER_LENGTH);\n            } else {\n                buf.skipBytes(buf.readableBytes());\n            }\n            return position; // Always return position object\n\n        } else if (type == MSG_SERIAL) { // 0x9B\n\n            getLastLocation(position, null);\n            // Assume footer is 9 bytes for this type based on original code\n            final int SERIAL_FOOTER_LENGTH = 9;\n            if (buf.readableBytes() < 1 + SERIAL_FOOTER_LENGTH) { // Need type byte + footer\n                 buf.skipBytes(buf.readableBytes()); return position;\n            }\n\n            buf.readUnsignedByte(); // external device type code\n            int length = buf.readableBytes() - SERIAL_FOOTER_LENGTH;\n\n            if (length <= 0) {\n                if (buf.readableBytes() >= SERIAL_FOOTER_LENGTH) buf.skipBytes(SERIAL_FOOTER_LENGTH); else buf.skipBytes(buf.readableBytes());\n                return null; // Keep null return for invalid length\n            }\n\n            ByteBuf dataSlice = buf.readSlice(length);\n            // Skip footer\n            if (buf.readableBytes() >= SERIAL_FOOTER_LENGTH) buf.skipBytes(SERIAL_FOOTER_LENGTH); else buf.skipBytes(buf.readableBytes());\n\n            try {\n                if (length < 8) { // Assuming temp data: need length-1 bytes data + 1 unknown byte\n                     if (dataSlice.readableBytes() < length) return null; // Check slice length again\n                     position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(dataSlice.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString()));\n                     dataSlice.skipBytes(1); // Skip the last byte assumed in length-1 read\n                } else { // Assuming driver ID: need 1 byte type + length-1 data\n                    if (dataSlice.readableBytes() < length) return null; // Check slice length again\n                    dataSlice.readUnsignedByte(); // card type\n                    position.set(Position.KEY_DRIVER_UNIQUE_ID, dataSlice.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString());\n                }\n            } catch (Exception e) { // Catch parsing or buffer errors\n                return null; // Parsing error\n            }\n            return position;\n\n        } else if (type == 0x11 || type == 0x27 || type == 0x28 || type == 0x2E) {\n            // Types used in verifyNotNull tests but not explicitly handled by protocol logic.\n            getLastLocation(position, null);\n            // Skip buffer content before footer\n            if (buf.readableBytes() > FOOTER_LENGTH) buf.skipBytes(buf.readableBytes() - FOOTER_LENGTH);\n            if (buf.readableBytes() >= FOOTER_LENGTH) buf.skipBytes(FOOTER_LENGTH); else buf.skipBytes(buf.readableBytes());\n            return position; // Return basic position object\n        }\n\n        // Return null for all other unhandled message types\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}