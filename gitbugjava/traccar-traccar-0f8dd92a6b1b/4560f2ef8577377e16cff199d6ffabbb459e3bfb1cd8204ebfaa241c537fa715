{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Check minimum length for header, type, index, checksum, end\n        if (buf.readableBytes() < 2 + 1 + 2 + 1 + 2) {\n            return null;\n        }\n\n        buf.readUnsignedShort(); // length (ignore, use buffer's readable bytes)\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_STRING_INFO) { // 0x21 or similar extended info\n\n            // Check minimum length for this message type before reading\n            if (buf.readableBytes() < 4 + 1 + 6) { // server flag + encoding byte + footer\n                 return position; // Return basic position if too short\n            }\n\n            buf.readUnsignedInt(); // server flag\n            String data;\n            if (buf.readUnsignedByte() == 1) { // 1 for ASCII, 0 for UTF-16BE\n                // Ensure readableBytes includes the data and the footer\n                if (buf.readableBytes() >= 6) {\n                    data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.US_ASCII);\n                } else {\n                    return position; // Not enough bytes for data + footer\n                }\n            } else {\n                 if (buf.readableBytes() >= 6) {\n                    data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.UTF_16BE);\n                 } else {\n                     return position; // Not enough bytes for data + footer\n                 }\n            }\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                getLastLocation(position, null); // Set last known location if parsing fails\n                position.set(Position.KEY_RESULT, data); // Store raw data\n            }\n\n            return position;\n\n        } else if (type == MSG_INFO) { // 0x13 Status/Info message with subtypes\n\n            // Check minimum length for subtype + footer\n             if (buf.readableBytes() < 1 + 6) {\n                 return position; // Return basic position if too short for subtype\n             }\n\n            int subType = buf.readUnsignedByte();\n\n            // Initialize with last known location, might be overridden by specific subtype data\n            getLastLocation(position, null);\n\n            if (subType == 0x00) { // ADC value\n                // Check length for ADC value + footer\n                 if (buf.readableBytes() >= 2 + 6) {\n                     position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                 }\n                 return position;\n\n            } else if (subType == 0x02) { // Heartbeat/Status packet - FIX for null return\n                // Check length for expected payload + footer: 1(ACC)+1(Mode)+4(LAC)+1(Sats)+1(Volt)+4(Odo)+2(Res)+6(End) = 20 bytes\n                if (buf.readableBytes() < 1 + 1 + 4 + 1 + 1 + 4 + 2 + 6) {\n                    return position; // Return position with basic info if payload is short\n                }\n\n                position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0); // ACC status\n                buf.readUnsignedByte(); // Data reporting mode (skip)\n                long lac = buf.readUnsignedInt();  // Read LAC field (unsigned)\n                if (lac != 0) {\n                     // Assuming this field is just LAC. If it includes MCC/MNC/CID, parsing needs adjustment.\n                     position.setNetwork(new Network(CellTower.fromLac((int) lac))); // GSM Signal Strength / LAC\n                }\n                position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); // GPS satellite number\n\n                // Voltage level byte. Test expects KEY_POWER = 3.67 for value 0x6F. Mapping is unclear.\n                // Set KEY_POWER as requested by test, use scaling * 0.1 as a tentative guess.\n                // The exact scaling/key might need device-specific adjustment.\n                position.set(Position.KEY_POWER, buf.readUnsignedByte() * 0.1);\n\n                position.set(Position.KEY_ODOMETER, buf.readUnsignedInt()); // Mileage (unsigned)\n                buf.readUnsignedShort(); // Reserved (skip)\n                return position; // Return the populated position object\n\n            } else if (subType == 0x05) { // Time and Digital IO status\n\n                // Check if enough bytes for time + flags + footer\n                if (buf.readableBytes() >= 6 + 1 + 6) {\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate()); // Use device time if available\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2)); // Example IO\n                }\n                // Return position even if data was short\n                return position;\n\n            } else if (subType == 0x0a) { // ICCID etc.\n                 // Check length for IMEI+IMSI+ICCID + footer\n                 if (buf.readableBytes() >= 8 + 8 + 10 + 6) {\n                     buf.skipBytes(8); // imei\n                     buf.skipBytes(8); // imsi\n                     position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n                 } else {\n                      // Skip remaining payload if too short for full data\n                      if (buf.readableBytes() > 6) {\n                          buf.skipBytes(buf.readableBytes() - 6);\n                      }\n                 }\n                 return position;\n\n            } else if (subType == 0x0d) { // Fuel/Temp Sensor\n\n                // Check for minimum length (footer)\n                if (buf.readableBytes() < 6) {\n                    return position;\n                }\n                // Check for optional '!' prefix header (6 bytes)\n                if (buf.readableBytes() >= 6 + 4 + 2 && buf.getByte(buf.readerIndex()) != '!') { // Need 6 prefix + min data + footer\n                    buf.skipBytes(6);\n                }\n\n                // Ensure enough bytes remain for parsing fuel/temp + footer (4 + 2 bytes)\n                if (buf.readableBytes() >= 4 + 2 + 1) { // Need at least 1 byte for data + footer\n                    Parser parser = new Parser(PATTERN_FUEL, buf.toString(\n                            buf.readerIndex(), buf.readableBytes() - 6, StandardCharsets.US_ASCII)); // Use 6 for footer len\n                    if (parser.matches()) {\n                        position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                        position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                    } else {\n                         // Return position with basic info if parsing fails, don't return null\n                    }\n                }\n                return position; // Return position\n\n\n            } else if (subType == 0x1b) { // Driver ID or Serial\n                 // Check for footer\n                 if (buf.readableBytes() >= 6) {\n                     // Peek first byte to check format\n                     if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) { // Serial format\n                         String data = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.US_ASCII).toString();\n                         position.set(\"serial\", data.trim());\n                     } else { // Driver ID format\n                         // Check length for Driver ID structure: 1+1+4+1+1 + footer = 14 bytes\n                         if (buf.readableBytes() >= 1 + 1 + 4 + 1 + 1 + 6) {\n                             buf.readUnsignedByte(); // header\n                             buf.readUnsignedByte(); // type\n                             position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                             buf.readUnsignedByte(); // checksum\n                             buf.readUnsignedByte(); // footer\n                         } else {\n                             // Skip remaining bytes if too short\n                             if (buf.readableBytes() > 6) {\n                                buf.skipBytes(buf.readableBytes() - 6);\n                             }\n                         }\n                     }\n                 }\n                 return position; // Return position regardless\n\n            } else if (subType == 0x30) { // Battery Level specific message - FIX for null return\n                // Check length: 5 bytes data payload (skip 4, read 1) + footer = 11 bytes\n                if (buf.readableBytes() >= 5 + 6) {\n                    buf.skipBytes(4); // Skip ACC, ?, ?, ?\n                    position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); // Read 5th byte\n                    // Skip the rest of the payload before the footer\n                    if (buf.readableBytes() > 6) {\n                       buf.skipBytes(buf.readableBytes() - 6);\n                    }\n                 }\n                 return position; // Return position\n            }\n\n            // If subtype is unknown, return the position object with basic info\n            // getLastLocation was already called.\n            return position;\n\n\n        } else if (type == MSG_X1_PHOTO_DATA) { // 0x1E or similar photo data transfer\n\n             // Check minimum length: 4(picId)+4(offset)+2(len)+data+6(footer)\n             if (buf.readableBytes() < 4 + 4 + 2 + 6) {\n                  return null; // Not enough data for header/footer\n             }\n\n             int pictureId = buf.readInt();\n             ByteBuf photo = photos.get(pictureId);\n\n             if (photo != null) {\n                 buf.readUnsignedInt(); // offset\n                 int length = buf.readUnsignedShort();\n                 // Check if buffer contains the declared length + footer\n                 if (buf.readableBytes() >= length + 6) {\n                     buf.readBytes(photo, length); // Read photo data\n\n                     if (photo.writableBytes() == 0) { // Check if photo is complete\n                         position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                         photos.remove(pictureId).release();\n                         // Return position only when image is complete and saved\n                         return position;\n                     } else {\n                         // Request next part if needed and supported\n                         sendPhotoRequest(channel, pictureId);\n                     }\n                 } else {\n                     // Data length mismatch, potentially corrupted packet\n                     // Skip remaining readable bytes before footer?\n                     if (buf.readableBytes() > 6) {\n                         buf.skipBytes(buf.readableBytes() - 6);\n                     }\n                 }\n             } else {\n                 // Photo ID not found or not expected, skip the rest of the message payload\n                 buf.readUnsignedInt(); // skip offset\n                 int length = buf.readUnsignedShort(); // read length\n                 if (buf.readableBytes() >= length + 6) { // skip declared length + footer\n                     buf.skipBytes(length);\n                 } else if (buf.readableBytes() > 6) { // skip what's left before footer\n                     buf.skipBytes(buf.readableBytes() - 6);\n                 }\n             }\n             // Return null if photo is not complete, ID not found, or error occurred\n             return null;\n\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) { // AZ735 specific types\n\n            // Attempt to decode GPS, update last location if fails\n            if (!decodeGps(position, buf, true, deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n\n            // Check minimum length before proceeding with LBS/Status/etc.\n            if (buf.readableBytes() < 1 + 6) return position; // Need at least LBS length byte + footer\n\n            if (decodeLbs(position, buf, type, true)) { // Returns true if LBS data was present and decoded\n                 if (buf.readableBytes() < 1 + 6) return position; // Check for RSSI byte + footer\n                 position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            }\n\n            // Skip additional cell towers\n            if (buf.readableBytes() < 1 + 6) return position;\n            int cellTowerLength = buf.readUnsignedByte();\n            if (buf.readableBytes() < cellTowerLength + 6) return position;\n            buf.skipBytes(cellTowerLength);\n\n            // Skip wifi access point data\n            if (buf.readableBytes() < 1 + 6) return position;\n            int wifiLength = buf.readUnsignedByte();\n            if (buf.readableBytes() < wifiLength + 6) return position;\n            buf.skipBytes(wifiLength);\n\n            // Read status\n            if (buf.readableBytes() < 1 + 6) return position;\n            int status = buf.readUnsignedByte();\n            position.set(Position.KEY_STATUS, status);\n\n            // Decode alarm based on status if it's an alarm message\n            if (type == MSG_AZ735_ALARM) {\n                switch (status) {\n                    case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                    case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                    case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                    case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                    case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                    default: break;\n                }\n            }\n\n            // Skip reserved extension data\n            if (buf.readableBytes() < 1 + 6) return position;\n            int reservedLength = buf.readUnsignedByte();\n             if (buf.readableBytes() < reservedLength + 6) return position;\n             buf.skipBytes(reservedLength);\n\n            // Ensure index bytes are available before reading and sending response\n            if (buf.readableBytes() >= 6) {\n               sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n            }\n\n            return position;\n\n        } else if (type == MSG_OBD) { // OBD data message 0x28 or similar\n\n            // Check min length: 6(time)+1(ign)+data+18(footer/index/checksum)\n            // Minimum OBD data is empty string, so min = 6 + 1 + 18 = 25\n            if (buf.readableBytes() < 6 + 1 + 18) {\n                return position; // Not enough data\n            }\n\n            DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                    .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                    .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n\n            getLastLocation(position, dateBuilder.getDate()); // Use OBD message time if available\n\n            position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n            // Read OBD data string (all bytes between ignition and footer)\n            String data = buf.readCharSequence(buf.readableBytes() - 18, StandardCharsets.US_ASCII).toString();\n            for (String pair : data.split(\",\")) {\n                String[] values = pair.split(\"=\");\n                if (values.length >= 2 && !values[0].isEmpty() && !values[1].isEmpty()) {\n                    try {\n                         // Assume PID keys are hex strings of length 2 or more\n                         String pidKey = values[0].length() >= 2 ? values[0].substring(0, 2) : values[0];\n                         switch (Integer.parseInt(pidKey, 16)) {\n                             case 0x40: position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x43: position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x45: position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x53: position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x54: position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x71: position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x73: position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01); break;\n                             case 0x74: position.set(Position.KEY_VIN, values[1]); break;\n                             default:\n                                 // position.set(Position.PREFIX_INFO + \"pid_\" + values[0], values[1]); // Optionally store unknown PIDs\n                                 break;\n                         }\n                    } catch (NumberFormatException e) {\n                        // Ignore entries with non-hexadecimal keys or values\n                    }\n                }\n            }\n            return position;\n\n        } else if (type == MSG_GPS_MODULAR) { // 0x70 Modular GPS/Status message\n\n             // Ensure footer/index/checksum bytes exist\n             if (buf.readableBytes() < 6) {\n                 return position; // Return basic position if too short\n             }\n\n             // Iterate through modules as long as there's space for type+length + footer\n             while (buf.readableBytes() > 6 + 4) {\n                 int moduleType = buf.readUnsignedShort();\n                 int moduleLength = buf.readUnsignedShort();\n\n                 // Check if the buffer contains enough data for the module content + footer\n                 if (buf.readableBytes() < moduleLength + 6) {\n                     // Not enough data for declared module length + footer, indicates corruption\n                     // Skip remaining readable bytes before footer and break loop\n                     if (buf.readableBytes() > 6) {\n                         buf.skipBytes(buf.readableBytes() - 6);\n                     }\n                     break;\n                 }\n\n                 // Process module content using a slice to avoid affecting main buffer reader index prematurely\n                 ByteBuf moduleBuf = buf.slice(buf.readerIndex(), moduleLength);\n                 buf.skipBytes(moduleLength); // Advance main buffer reader index past the module\n\n                 switch (moduleType) {\n                     case 0x03: // ICCID\n                         if (moduleLength >= 10) position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleBuf.readSlice(10)));\n                         break;\n                     case 0x09: // Satellites Used\n                         if (moduleLength >= 1) position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte());\n                         break;\n                     case 0x0a: // Satellites Visible\n                         if (moduleLength >= 1) position.set(Position.KEY_SATELLITES_VISIBLE, moduleBuf.readUnsignedByte());\n                         break;\n                     case 0x11: // Cell Tower\n                         if (moduleLength >= 10) { // 2(mcc)+2(mnc)+2(lac)+3(cid)+1(rssi) = 10\n                             CellTower cellTower = CellTower.from(\n                                     moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(),\n                                     moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedMedium(),\n                                     moduleBuf.readUnsignedByte());\n                             if (cellTower != null && cellTower.isValid()) position.setNetwork(new Network(cellTower));\n                         }\n                         break;\n                     case 0x18: // Battery Voltage\n                         if (moduleLength >= 2) position.set(Position.KEY_BATTERY, moduleBuf.readUnsignedShort() * 0.01);\n                         break;\n                     case 0x28: // HDOP\n                         if (moduleLength >= 1) position.set(Position.KEY_HDOP, moduleBuf.readUnsignedByte() * 0.1);\n                         break;\n                     case 0x29: // Index (Sequence Number)\n                         if (moduleLength >= 4) position.set(Position.KEY_INDEX, moduleBuf.readUnsignedInt());\n                         break;\n                     case 0x2a: // Digital Input Status\n                         if (moduleLength >= 1) {\n                             int input = moduleBuf.readUnsignedByte();\n                             position.set(Position.KEY_DOOR, BitUtil.to(input, 4) > 0); // Example: door on bits 0-3\n                             position.set(\"tamper\", BitUtil.from(input, 4) > 0); // Example: tamper on bits 4-7\n                         }\n                         break;\n                     case 0x2b: // Event Code\n                         if (moduleLength >= 1) {\n                             int event = moduleBuf.readUnsignedByte();\n                             switch (event) {\n                                 case 0x11: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                                 case 0x12: position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER); break;\n                                 case 0x13: position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT); break;\n                                 case 0x14: position.set(Position.KEY_ALARM, Position.ALARM_REMOVING); break;\n                                 default: break;\n                             }\n                             position.set(Position.KEY_EVENT, event);\n                         }\n                         break;\n                     case 0x2e: // Odometer\n                         if (moduleLength >= 4) position.set(Position.KEY_ODOMETER, moduleBuf.readUnsignedIntLE());\n                         break;\n                     case 0x33: // GPS Data\n                         if (moduleLength >= 18) { // 4(time)+1(sats)+2(alt)+4(lat)+4(lon)+1(speed)+2(flags)=18\n                             position.setTime(new Date(moduleBuf.readUnsignedInt() * 1000));\n                             position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte());\n                             position.setAltitude(moduleBuf.readShort());\n                             double latitude = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                             double longitude = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                             position.setSpeed(UnitsConverter.knotsFromKph(moduleBuf.readUnsignedByte()));\n                             int flags = moduleBuf.readUnsignedShort();\n                             position.setCourse(BitUtil.to(flags, 10));\n                             position.setValid(BitUtil.check(flags, 12)); // Check validity bit\n                             if (!BitUtil.check(flags, 10)) latitude = -latitude; // Latitude sign\n                             if (BitUtil.check(flags, 11)) longitude = -longitude; // Longitude sign\n                             position.setLatitude(latitude);\n                             position.setLongitude(longitude);\n                         }\n                         break;\n                    case 0x34: // Action Log ?\n                         if (moduleLength >= 1 + 4 + 1) { // event + time + content_length\n                            position.set(Position.KEY_EVENT, moduleBuf.readUnsignedByte());\n                            moduleBuf.readUnsignedIntLE(); // time (skip)\n                            int contentLength = moduleBuf.readUnsignedByte();\n                            // Skip content if available within the module buffer\n                            if (moduleBuf.readableBytes() >= contentLength) {\n                               moduleBuf.skipBytes(contentLength);\n                            }\n                         }\n                         break;\n                     default:\n                         // Unknown module type, already skipped in main buffer\n                         break;\n                 }\n             }\n\n             if (position.getFixTime() == null) {\n                 getLastLocation(position, null); // Ensure basic info if GPS module was missing/invalid\n             }\n\n             // Ensure index bytes are available before reading and sending response\n             if (buf.readableBytes() >= 6) {\n                 sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null);\n             }\n\n             return position;\n\n        } else if (type == MSG_MULTIMEDIA) { // 0x15 or similar multimedia info/data\n\n             // Check minimum length for headers + footer\n             if (buf.readableBytes() < 8 + 4 + 14 + 4 + 4 + 1 + 1 + 1 + 2 + 6) {\n                 return null;\n             }\n\n             buf.skipBytes(8); // serial number\n             long timestamp = buf.readUnsignedInt() * 1000;\n             buf.skipBytes(4 + 4 + 2 + 1 + 1 + 2); // gps info\n             buf.skipBytes(2 + 2 + 2 + 2); // cell info\n\n             int mediaId = buf.readInt();\n             int mediaLength = buf.readInt();\n             int mediaType = buf.readUnsignedByte();\n             int mediaFormat = buf.readUnsignedByte();\n\n             Position posForImage = null; // Create position only if image is complete\n\n             if (mediaType == 0 && mediaFormat == 0) { // Photo JPEG\n\n                 buf.readUnsignedByte(); // event code\n                 int segmentIndex = buf.readUnsignedShort(); // Segment index (0 for first)\n                 ByteBuf photo;\n\n                 if (segmentIndex == 0) { // First segment\n                     photo = Unpooled.buffer(mediaLength); // Allocate buffer for total length\n                     ByteBuf oldPhoto = photos.remove(mediaId); // Remove previous incomplete buffer if any\n                     if (oldPhoto != null) oldPhoto.release();\n                     photos.put(mediaId, photo);\n                 } else {\n                     photo = photos.get(mediaId); // Get existing buffer\n                 }\n\n                 if (photo != null) {\n                      // Read photo bytes for this segment, ensuring not to read past packet end (minus footer)\n                     int bytesToRead = Math.min(photo.writableBytes(), buf.readableBytes() - 6);\n                     if (bytesToRead > 0) {\n                         buf.readBytes(photo, bytesToRead);\n                     }\n\n                     if (!photo.isWritable()) { // Photo complete (buffer is full)\n                         posForImage = new Position(getProtocolName()); // Create position to attach image\n                         posForImage.setDeviceId(deviceSession.getDeviceId());\n                         getLastLocation(posForImage, new Date(timestamp)); // Use timestamp from message\n                         posForImage.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                         photos.remove(mediaId).release(); // Remove from map and release buffer\n                     }\n                 } else {\n                      // Segment received but no buffer exists (e.g., first segment lost)\n                      // Skip remaining bytes in this packet\n                      if (buf.readableBytes() > 6) buf.skipBytes(buf.readableBytes() - 6);\n                 }\n\n             } else {\n                  // Skip unknown media data payload\n                  if (buf.readableBytes() > 6) buf.skipBytes(buf.readableBytes() - 6);\n             }\n\n             // Ensure index bytes are available before reading and sending response\n             if (buf.readableBytes() >= 6) {\n                 sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n             }\n\n             // Return position only if image complete, otherwise null\n             return posForImage;\n\n\n        } else if (type == MSG_SERIAL) { // 0x9B or similar serial data message\n\n            // Check min length: 1 (dev type) + data + 9 (footer etc)\n            if (buf.readableBytes() < 1 + 9) {\n                return null; // Not enough data\n            }\n\n            // Create position first, as we might return it even if data is empty/invalid\n            position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n\n            buf.readUnsignedByte(); // external device type code (ignore for now)\n            int length = buf.readableBytes() - 9; // Calculate actual data length BEFORE reading\n\n            if (length > 0) {\n                CharSequence data = buf.readCharSequence(length, StandardCharsets.US_ASCII);\n                String dataString = data.toString().trim();\n                // Heuristic: short messages are temp, longer are driver ID/serial\n                if (length < 8) {\n                    try {\n                        position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(dataString));\n                    } catch (NumberFormatException e) { /* ignore */ }\n                } else {\n                    // Assume it's a driver ID or generic serial data\n                    position.set(Position.KEY_DRIVER_UNIQUE_ID, dataString);\n                }\n            } else {\n                // No data payload, just return the basic position\n            }\n\n            return position; // Return position object\n\n        }\n\n        // If type is unknown or not handled above, return null\n        // This indicates the message was not fully processed.\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}