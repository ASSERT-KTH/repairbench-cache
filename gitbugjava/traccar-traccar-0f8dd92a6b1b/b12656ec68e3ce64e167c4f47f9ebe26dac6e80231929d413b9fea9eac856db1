{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        // NOTE: This position might be discarded and replaced in MSG_SERIAL case\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Type is the first byte in the buffer passed to this method as length was read by caller\n        // Check if buffer is readable before attempting to read type\n        if (!buf.isReadable()) {\n            return null; // No data in buffer\n        }\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_STRING_INFO) { // 0x21\n\n            // Need 4 bytes server flag + 1 byte encoding flag + 6 bytes assumed footer = 11 bytes\n            if (buf.readableBytes() < 4 + 1 + 6) {\n                return null; // Not enough data\n            }\n            buf.readUnsignedInt(); // server flag\n            String data;\n            int readable = buf.readableBytes();\n            // Assuming 6 bytes footer (CRC+INDEX+END)\n            int dataLength = readable >= 6 ? readable - 6 : 0; // Calculate length before reading encoding flag\n            int encoding = buf.readUnsignedByte(); // encoding flag\n            dataLength -= 1; // Adjust for encoding flag read\n\n            if (dataLength > 0) {\n                if (encoding == 1) {\n                    data = buf.readSlice(dataLength).toString(StandardCharsets.US_ASCII);\n                } else {\n                    data = buf.readSlice(dataLength).toString(StandardCharsets.UTF_16BE);\n                }\n            } else {\n                data = \"\"; // No actual data payload\n            }\n\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                getLastLocation(position, null);\n                position.set(Position.KEY_RESULT, data);\n            }\n            return position;\n\n        } else if (type == MSG_INFO) { // 0x19\n\n            if (!buf.isReadable()) {\n                 // Cannot read subtype, initialize position and return\n                 getLastLocation(position, null);\n                 return position;\n            }\n            int subType = buf.readUnsignedByte();\n            getLastLocation(position, null); // Get last location regardless of subtype success\n\n            if (subType == 0x00) { // ADC\n                // Need 2 bytes ADC + 6 bytes footer = 8 bytes\n                if (buf.readableBytes() >= 2 + 6) {\n                    position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                }\n                // Return position even if data missing/short\n                return position;\n\n            } else if (subType == 0x05) { // Time + Flags\n                // Try to read time (6 bytes) + flags (1 byte)\n                // Need time(6) + flags(1) + footer(6) = 13 bytes\n                if (buf.readableBytes() >= 6 + 1 + 6) {\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                } else if (buf.readableBytes() >= 1 + 6) { // Check if only flags can be read\n                     int flags = buf.readUnsignedByte();\n                     position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                     position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                }\n                // Return position even if data missing/short\n                return position;\n\n            } else if (subType == 0x0a) { // ICCID\n                // Need 8(imei)+8(imsi)+10(iccid) + 6(footer) = 32\n                if (buf.readableBytes() >= 8 + 8 + 10 + 6) {\n                    buf.skipBytes(8); // imei\n                    buf.skipBytes(8); // imsi\n                    position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n                }\n                // Return position even if data missing/short\n                return position;\n\n            } else if (subType == 0x0d) { // Fuel (Pattern)\n                // Assuming 6 bytes footer\n                if (buf.readableBytes() >= 6) { // Minimum required is footer\n                    // Check for optional 6 bytes skip if first byte is not '!'\n                    if (buf.getByte(buf.readerIndex()) != '!') {\n                        if (buf.readableBytes() >= 6 + 6) { // Check if skippable bytes + footer exist\n                            buf.skipBytes(6);\n                        } else {\n                            // Not enough data to skip and parse, return position as is\n                            return position;\n                        }\n                    }\n\n                    int readable = buf.readableBytes();\n                    int dataLength = readable - 6; // Length of potential pattern data\n                    if (dataLength > 0) {\n                        Parser parser = new Parser(PATTERN_FUEL, buf.toString(buf.readerIndex(), dataLength, StandardCharsets.US_ASCII));\n                        if (parser.matches()) {\n                            position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                            position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                            buf.skipBytes(dataLength); // Consume parsed bytes\n                        }\n                        // If parser doesn't match, do nothing, attributes won't be set\n                    }\n                }\n                // Return position even if parse fails or data missing/short\n                return position;\n\n            } else if (subType == 0x1b) { // Serial / Driver ID\n                // Assuming 6 bytes footer\n                if (buf.readableBytes() > 6) {\n                    int readable = buf.readableBytes();\n                    int dataLength = readable - 6; // Length before footer\n                    if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) {\n                        String data = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                        position.set(\"serial\", data.trim());\n                    } else {\n                        // Structure: 1(hdr)+1(type)+4(id)+1(chk)+1(ftr) = 8 bytes payload\n                        if (dataLength >= 8) {\n                            buf.readUnsignedByte(); // header\n                            buf.readUnsignedByte(); // type\n                            position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                            buf.readUnsignedByte(); // checksum\n                            buf.readUnsignedByte(); // footer byte?\n                        }\n                    }\n                }\n                // Return position even if data missing/short\n                return position;\n            }\n\n            // Fix: Handle unknown subtypes by returning the position with last known location.\n            return position;\n\n        } else if (type == MSG_X1_PHOTO_DATA) { // 0xA6\n\n             // Need 4(picId) + 4(offset) + 2(len) = 10 bytes minimum before chunk data + footer(6) = 16\n             if (buf.readableBytes() < 4 + 4 + 2 + 6) {\n                 return null;\n             }\n            int pictureId = buf.readInt();\n            ByteBuf photo = photos.get(pictureId);\n            /*int offset =*/ buf.readInt(); // Offset not used currently\n            int photoChunkLength = buf.readUnsignedShort();\n\n            if (photo != null) {\n                 if (buf.readableBytes() >= photoChunkLength + 6) { // Check for chunk + footer\n                     int bytesToRead = Math.min(photoChunkLength, photo.writableBytes());\n                     buf.readBytes(photo, bytesToRead);\n                     // Skip any extra bytes declared in chunk length but not fitting in buffer or already read\n                     int remainingDeclared = photoChunkLength - bytesToRead;\n                     if (remainingDeclared > 0) {\n                         buf.skipBytes(remainingDeclared);\n                     }\n\n                    if (photo.writableBytes() > 0) {\n                        sendPhotoRequest(channel, pictureId);\n                        return null; // Partial photo\n                    } else {\n                        position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                        photos.remove(pictureId).release();\n                        return position; // Completed photo\n                    }\n                 } else {\n                      photos.remove(pictureId).release(); // Clean up incomplete\n                      return null; // Not enough data\n                 }\n            } else {\n                 // Photo object not found (maybe first chunk missing?), skip data if possible\n                 if (buf.readableBytes() >= photoChunkLength + 6) { // Check for chunk + footer\n                    buf.skipBytes(photoChunkLength);\n                 }\n                 return null; // Cannot process photo\n            }\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) { // 0xA2, 0xA4\n\n            // Assuming decodeGps/decodeLbs and subsequent reads have internal checks or expect sufficient data\n            if (!decodeGps(position, buf, true, deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n\n            if (decodeLbs(position, buf, type, true)) {\n                 if (buf.isReadable()) {\n                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                 }\n            }\n\n            // Read variable length skips safely\n            if (buf.isReadable()) {\n                 int skip = buf.readUnsignedByte();\n                 skip = Math.min(skip, buf.readableBytes()); // Ensure skip doesn't exceed available bytes\n                 buf.skipBytes(skip);\n            }\n             if (buf.isReadable()) {\n                 int skip = buf.readUnsignedByte();\n                 skip = Math.min(skip, buf.readableBytes());\n                 buf.skipBytes(skip);\n            }\n\n             if (buf.isReadable()) {\n                int status = buf.readUnsignedByte();\n                position.set(Position.KEY_STATUS, status);\n                if (type == MSG_AZ735_ALARM) {\n                    switch (status) {\n                        case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                        case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                        case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                        case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                        case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                        default: break;\n                    }\n                }\n             }\n\n             if (buf.isReadable()) {\n                 int skip = buf.readUnsignedByte();\n                 skip = Math.min(skip, buf.readableBytes());\n                 buf.skipBytes(skip);\n            }\n\n            // Assume 6 bytes footer containing index for response\n            int readerIndexBeforeFooter = buf.writerIndex() - 6; // Assuming writerIndex marks end of payload+footer\n            if (readerIndexBeforeFooter >= buf.readerIndex() && buf.readableBytes() >= 6) {\n                // Read index relative to end of buffer (assuming index is last 2 bytes of 6 byte footer)\n                sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 2), null);\n            }\n            return position;\n\n        } else if (type == MSG_OBD) { // 0x24\n\n            // Need 6(time) + 1(ignition) minimum before data + 18(fixed/footer) = 25\n             if (buf.readableBytes() >= 6 + 1 + 18) {\n                DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                        .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                        .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                getLastLocation(position, dateBuilder.getDate());\n                position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n                int dataLength = buf.readableBytes() - 18; // Assuming 18 bytes footer/other fields after data\n                if (dataLength > 0) {\n                    String data = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                    for (String pair : data.split(\",\")) {\n                        String[] values = pair.split(\"=\");\n                        if (values.length >= 2 && !values[0].isEmpty() && !values[1].isEmpty()) { // Basic validation\n                            try {\n                                switch (Integer.parseInt(values[0].substring(0, 2), 16)) {\n                                    case 40: position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 43: position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 45: position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 53: position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 54: position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 71: position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 73: position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01); break;\n                                    case 74: position.set(Position.KEY_VIN, values[1]); break;\n                                    default: break;\n                                }\n                            } catch (NumberFormatException | IndexOutOfBoundsException e) { /* ignore parse errors */ }\n                        }\n                    }\n                }\n             }\n            // Return position even if data missing/short or parse errors occur\n            return position;\n\n        } else if (type == MSG_GPS_MODULAR) { // 0x70\n\n            // Assuming 6 bytes footer\n            while (buf.readableBytes() > 6) {\n                if (buf.readableBytes() < 4 + 6) { break; } // Need module header(4) + footer(6)\n                int moduleType = buf.readUnsignedShort();\n                int moduleLength = buf.readUnsignedShort();\n\n                // Check if declared length is valid and data available\n                if (moduleLength < 0 || buf.readableBytes() < moduleLength + 6) {\n                     buf.readerIndex(buf.writerIndex() - 6); // Go to footer start and break loop\n                     break;\n                }\n\n                ByteBuf moduleBuf = buf.readSlice(moduleLength); // Process slice safely\n                // Switch with bounds checks for reads within moduleBuf\n                switch (moduleType) {\n                    case 0x03: if (moduleBuf.readableBytes() >= 10) { position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleBuf.readSlice(10)).replaceAll(\"f\", \"\")); } break;\n                    case 0x09: if (moduleBuf.isReadable()) { position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte()); } break;\n                    case 0x0a: if (moduleBuf.isReadable()) { position.set(Position.KEY_SATELLITES_VISIBLE, moduleBuf.readUnsignedByte()); } break;\n                    case 0x11: if (moduleBuf.readableBytes() >= 10) { CellTower cellTower = CellTower.from(moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedMedium(), moduleBuf.readUnsignedByte()); if (cellTower != null && cellTower.getCellId() > 0) { position.setNetwork(new Network(cellTower)); } } break;\n                    case 0x18: if (moduleBuf.readableBytes() >= 2) { position.set(Position.KEY_BATTERY, moduleBuf.readUnsignedShort() * 0.01); } break;\n                    case 0x28: if (moduleBuf.isReadable()) { position.set(Position.KEY_HDOP, moduleBuf.readUnsignedByte() * 0.1); } break;\n                    case 0x29: if (moduleBuf.readableBytes() >= 4) { position.set(Position.KEY_INDEX, moduleBuf.readUnsignedInt()); } break;\n                    case 0x2a: if (moduleBuf.isReadable()) { int input = moduleBuf.readUnsignedByte(); position.set(Position.KEY_DOOR, BitUtil.to(input, 4) > 0); position.set(\"tamper\", BitUtil.from(input, 4) > 0); } break;\n                    case 0x2b: if (moduleBuf.isReadable()) { int event = moduleBuf.readUnsignedByte(); /* ... alarm logic ... */ position.set(Position.KEY_EVENT, event); } break;\n                    case 0x2e: if (moduleBuf.readableBytes() >= 4) { position.set(Position.KEY_ODOMETER, moduleBuf.readUnsignedIntLE()); } break;\n                    case 0x33: if (moduleBuf.readableBytes() >= 18) { /* ... GPS fields ... */ position.setTime(new Date(moduleBuf.readUnsignedInt() * 1000)); position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte()); position.setAltitude(moduleBuf.readShort()); double lat = moduleBuf.readUnsignedInt() / 60.0 / 30000.0; double lon = moduleBuf.readUnsignedInt() / 60.0 / 30000.0; position.setSpeed(UnitsConverter.knotsFromKph(moduleBuf.readUnsignedByte())); int flags = moduleBuf.readUnsignedShort(); position.setCourse(BitUtil.to(flags, 10)); position.setValid(BitUtil.check(flags, 12)); if (!BitUtil.check(flags, 10)) { lat = -lat; } if (BitUtil.check(flags, 11)) { lon = -lon; } position.setLatitude(lat); position.setLongitude(lon); } break;\n                    case 0x34: if (moduleBuf.readableBytes() >= 1 + 4 + 1) { position.set(Position.KEY_EVENT, moduleBuf.readUnsignedByte()); moduleBuf.readUnsignedIntLE(); int len = moduleBuf.readUnsignedByte(); if (moduleBuf.readableBytes() >= len) { moduleBuf.skipBytes(len); } } break;\n                    default: break; // Unknown module type, already skipped by readSlice\n                }\n            }\n\n            if (position.getFixTime() == null) {\n                getLastLocation(position, null);\n            }\n\n            // Assume footer has index (used for response)\n            if (buf.readableBytes() >= 2) { // Check if index bytes remain\n                 sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null);\n            }\n            return position;\n\n        } else if (type == MSG_MULTIMEDIA) { // 0x2A (Check constant value)\n\n            // Check minimum size: 8+4+12(gps)+8(cell)+4(id)+4(len)+1(type)+1(format) + 1(event)+2(index) + 6(footer) = 51\n             if (buf.readableBytes() < 8 + 4 + 12 + 8 + 4 + 4 + 1 + 1 + 1 + 2 + 6) {\n                 return null;\n             }\n            buf.skipBytes(8); // serial\n            long timestamp = buf.readUnsignedInt() * 1000;\n            buf.skipBytes(12); // gps\n            buf.skipBytes(8); // cell\n            int mediaId = buf.readInt();\n            int mediaLength = buf.readInt();\n            int mediaType = buf.readUnsignedByte();\n            int mediaFormat = buf.readUnsignedByte();\n\n            // Process only photo type currently\n            if (mediaType == 0 && mediaFormat == 0) {\n                buf.readUnsignedByte(); // event\n                int index = buf.readUnsignedShort(); // photo index\n                ByteBuf photo;\n                 if (index == 0) { // First chunk\n                    photo = Unpooled.buffer(mediaLength);\n                    if (photos.containsKey(mediaId)) { photos.remove(mediaId).release(); } // Remove old if restarting\n                    photos.put(mediaId, photo);\n                 } else {\n                    photo = photos.get(mediaId);\n                 }\n\n                if (photo != null) {\n                    int photoChunkLength = buf.readableBytes() - 6; // Data before footer\n                     if (photoChunkLength >= 0) {\n                        int bytesToRead = Math.min(photoChunkLength, photo.writableBytes());\n                        buf.readBytes(photo, bytesToRead);\n                        if (photoChunkLength > bytesToRead) { buf.skipBytes(photoChunkLength - bytesToRead); } // Skip excess if any\n\n                        // Send response regardless of completion? Original code did.\n                        if (buf.writerIndex() >= 6) { sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); }\n\n                         if (!photo.isWritable()) { // Completed\n                            getLastLocation(position, new Date(timestamp));\n                            position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                            photos.remove(mediaId).release();\n                            return position; // Return position with image\n                         } else {\n                             return null; // Return null for partial image\n                         }\n                    } else { // photoChunkLength < 0 means only footer left?\n                         if (buf.writerIndex() >= 6) { sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); }\n                         return null; // Not enough data\n                    }\n                } else { // photo buffer missing (e.g., index > 0 but no prior chunk)\n                     int skipLen = buf.readableBytes() - 6; if (skipLen > 0) buf.skipBytes(skipLen);\n                     if (buf.writerIndex() >= 6) { sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); }\n                     return null;\n                }\n            } else { // Other media types not handled\n                 int skipLen = buf.readableBytes() - 6; if (skipLen > 0) buf.skipBytes(skipLen);\n                 if (buf.writerIndex() >= 6) { sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); }\n                 return null;\n            }\n\n        } else if (type == MSG_SERIAL) { // 0x69\n\n            // Use local position for serial data\n            Position serialPosition = new Position(getProtocolName());\n            serialPosition.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(serialPosition, null);\n\n            // Need ext type(1) + footer/structure(9) = 10 bytes minimum\n            if (buf.readableBytes() < 1 + 9) {\n                 return serialPosition; // Return basic position if not enough data\n            }\n\n            buf.readUnsignedByte(); // external device type code\n            int length = buf.readableBytes() - 9; // Length of actual serial data payload\n\n            if (length <= 0) {\n                return serialPosition; // No serial data, return basic position\n            }\n\n            // Ensure buffer contains length + footer before proceeding\n            if (buf.readableBytes() < length + 9) {\n                return serialPosition; // Not enough bytes for declared payload + footer\n            }\n\n            try {\n                if (length < 8) { // Assume Temperature\n                    // Need (length - 1) bytes temp + 1 byte separator\n                    if (length - 1 >= 0) {\n                        serialPosition.set(Position.PREFIX_TEMP + 1, Double.parseDouble(buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString()));\n                        buf.skipBytes(1); // Skip separator\n                    } else { // Only separator? Skip it.\n                         buf.skipBytes(length);\n                    }\n                } else { // Assume Driver ID\n                    // Need 1 byte card type + (length - 1) bytes ID + 1 byte separator\n                    if (length - 1 > 0 && buf.readableBytes() >= 1 + (length - 1) + 1 + 9 - length) { // Ensure remaining structure exists\n                        buf.readUnsignedByte(); // card type\n                        serialPosition.set( Position.KEY_DRIVER_UNIQUE_ID, buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString());\n                        buf.skipBytes(1); // Skip separator\n                    } else { // Not enough bytes or invalid length? Skip payload.\n                         buf.skipBytes(length);\n                    }\n                }\n            } catch (Exception e) { // Catch parsing/buffer errors\n                 // Log error? Skip remaining declared payload if possible\n                 int readerStart = buf.readerIndex() - (buf.readableBytes() < 9 ? 0 : buf.readableBytes() - 9 - length); // approx start of payload\n                 int bytesToSkip = readerStart + length - buf.readerIndex();\n                 if (bytesToSkip > 0 && bytesToSkip <= buf.readableBytes()) {\n                     buf.skipBytes(bytesToSkip);\n                 }\n                 // Return basic position after error\n                 return serialPosition;\n            }\n            // Return populated position if successful\n            return serialPosition;\n        }\n\n        return null; // Type not handled\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}