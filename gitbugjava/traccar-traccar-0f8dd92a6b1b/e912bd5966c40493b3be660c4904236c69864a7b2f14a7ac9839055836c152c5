{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        buf.readUnsignedShort(); // length\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_STRING_INFO) {\n\n            buf.readUnsignedInt(); // server flag\n            String data;\n            // Ensure slice length is non-negative and fits in readableBytes\n            int dataLength = buf.readableBytes() - 6; // 2 index, 2 checksum, 2 footer 0x0D 0x0A\n            if (dataLength < 0) {\n                return null; // Invalid packet length\n            }\n            if (buf.readUnsignedByte() == 1) {\n                data = buf.readSlice(dataLength).toString(StandardCharsets.US_ASCII);\n            } else {\n                data = buf.readSlice(dataLength).toString(StandardCharsets.UTF_16BE);\n            }\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                getLastLocation(position, null);\n                position.set(Position.KEY_RESULT, data);\n            }\n\n            return position;\n\n        } else if (type == MSG_INFO) {\n\n            int subType = buf.readUnsignedByte();\n\n            getLastLocation(position, null); // Get last location regardless of subtype\n\n            if (subType == 0x00) { // ADC\n                if (buf.readableBytes() >= 2 + 6) { // Check for value(2) + footer(6)\n                    position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                } // else: not enough data, but return position anyway\n                return position;\n\n            } else if (subType == 0x05) { // Time and Flags\n                if (buf.readableBytes() >= 6 + 1 + 6) { // Check for time(6) + flags(1) + footer(6)\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                } // else: not enough data\n                return position; // Return position even if time/flags part was short/missing\n\n            } else if (subType == 0x0a) { // ICCID\n                if (buf.readableBytes() >= 8 + 8 + 10 + 6) { // Check for imei(8)+imsi(8)+iccid(10)+footer(6)\n                     buf.skipBytes(8); // imei\n                     buf.skipBytes(8); // imsi\n                     position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n                } // else: not enough data\n                return position;\n\n            } else if (subType == 0x0d) { // Fuel/Temp Sensor\n                if (buf.readableBytes() >= 6) { // Need at least footer bytes\n                    int readerIndexBeforeParse = buf.readerIndex();\n                    int dataLength = buf.readableBytes() - 6; // length before footer\n                    int footerIndex = readerIndexBeforeParse + dataLength;\n\n                    try {\n                        if (dataLength > 0) {\n                            int parseStartIndex = readerIndexBeforeParse;\n                            int parseLength = dataLength;\n                            if (buf.getByte(parseStartIndex) != '!') { // Check for leading '!'\n                                if (parseLength >= 6) { // Can we skip the 6 bytes?\n                                    parseStartIndex += 6;\n                                    parseLength -= 6;\n                                } else {\n                                    parseLength = 0; // Not enough data to skip or parse\n                                }\n                            }\n\n                            if (parseLength > 0) { // Check again after potential skip\n                                Parser parser = new Parser(PATTERN_FUEL, buf.toString(\n                                        parseStartIndex, parseLength, StandardCharsets.US_ASCII));\n                                if (parser.matches()) {\n                                    position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                                    position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                                } // else: parser failed, keep position without fuel/temp\n                            }\n                        }\n                    } finally {\n                        // Ensure reader index is positioned before the footer regardless of parsing result\n                        buf.readerIndex(footerIndex);\n                    }\n                }\n                return position; // Return position even if parsing failed or data was missing\n\n            } else if (subType == 0x1b) { // Serial/RFID\n                 if (buf.readableBytes() >= 6) { // Need at least footer bytes\n                     int readerIndexBeforeParse = buf.readerIndex();\n                     int dataLength = buf.readableBytes() - 6;\n                     int footerIndex = readerIndexBeforeParse + dataLength;\n                     try {\n                         if (dataLength > 0) {\n                             if (Character.isLetter(buf.getUnsignedByte(readerIndexBeforeParse))) { // Serial String?\n                                 String data = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                                 position.set(\"serial\", data.trim());\n                             } else { // RFID structure?\n                                 // Check size for header(1)+type(1)+rfid(4)+checksum(1)+footer(1) = 8 bytes minimum payload\n                                 if (dataLength >= 1 + 1 + 4 + 1 + 1) {\n                                     buf.readUnsignedByte(); // header\n                                     buf.readUnsignedByte(); // type\n                                     position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                                     buf.readUnsignedByte(); // checksum\n                                     buf.readUnsignedByte(); // footer\n                                 } else {\n                                     buf.skipBytes(dataLength); // Skip unknown/short data\n                                 }\n                             }\n                         } // else: No data before footer\n                     } catch (Exception e) {\n                         // Error during parsing, reset index and skip data\n                         buf.readerIndex(readerIndexBeforeParse);\n                         buf.skipBytes(dataLength);\n                     } finally {\n                         // Ensure reader index is positioned before the footer\n                         buf.readerIndex(footerIndex);\n                     }\n                 }\n                return position; // Return position regardless of parsing result\n\n            }\n\n            // Return position even if subtype is unknown\n            return position;\n\n        } else if (type == MSG_X1_PHOTO_DATA) {\n\n            if (buf.readableBytes() < 4 + 4 + 2 + 6) { return null; } // Check min length: id(4)+offset(4)+size(2)+footer(6)\n\n            int pictureId = buf.readInt();\n            ByteBuf photo = photos.get(pictureId);\n\n            if (photo == null) {\n                // No buffer exists for this ID. Maybe log this?\n                return null; // Cannot process, return null\n            }\n\n            buf.readUnsignedInt(); // offset\n            int chunkSize = buf.readUnsignedShort();\n\n            if (buf.readableBytes() < chunkSize + 6) { return null; } // Check if buffer has declared chunk size + footer\n\n            try {\n                // Read chunk, prevent IndexOutOfBounds if chunkSize > photo.writableBytes()\n                buf.readBytes(photo, Math.min(chunkSize, photo.writableBytes()));\n            } catch (IndexOutOfBoundsException e) {\n                photos.remove(pictureId).release(); // Buffer overflowed or other issue? Clean up.\n                return null; // Error reading chunk\n            }\n\n            // Advance buffer reader index past the chunk data even if Math.min reduced the read size\n            buf.readerIndex(buf.readerIndex() + chunkSize - Math.min(chunkSize, photo.writableBytes()));\n\n            if (photo.writableBytes() <= 0) { // Check if buffer is full\n                try {\n                    position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                } finally {\n                     photos.remove(pictureId).release(); // Remove map entry even if write fails\n                }\n            } else {\n                sendPhotoRequest(channel, pictureId); // Request next chunk\n            }\n            // Always return position, with KEY_IMAGE set if complete, otherwise without.\n            return position;\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) {\n\n            // Assuming decodeGps and decodeLbs handle buffer reads safely\n            if (!decodeGps(position, buf, true, (TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n\n            if (decodeLbs(position, buf, type, true)) {\n                 if (buf.isReadable()) { position.set(Position.KEY_RSSI, buf.readUnsignedByte()); }\n            }\n\n            // Safely skip variable length fields\n            if (buf.isReadable()) { buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes())); } // additional cell towers\n            if (buf.isReadable()) { buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes())); } // wifi access point\n\n            if (buf.isReadable()) { // Check before reading status\n                int status = buf.readUnsignedByte();\n                position.set(Position.KEY_STATUS, status);\n                if (type == MSG_AZ735_ALARM) {\n                    switch (status) {\n                        case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                        case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                        case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                        case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                        case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                        default: break;\n                    }\n                }\n            }\n\n            if (buf.isReadable()) { buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes())); } // reserved extension\n\n            sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); // Assuming footer is present\n            return position;\n\n        } else if (type == MSG_OBD) {\n\n            // Assuming footer size is 18 bytes based on original calculation\n            // Check min length: time(6)+ign(1)+footer(18) = 25\n            if (buf.readableBytes() < 25) { return null; }\n\n            DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                    .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                    .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n            getLastLocation(position, dateBuilder.getDate());\n\n            position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n            int dataLength = buf.readableBytes() - 18; // Data part before footer\n            if (dataLength > 0) {\n                String data = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                for (String pair : data.split(\",\")) {\n                    String[] values = pair.split(\"=\");\n                    if (values.length >= 2) {\n                        try {\n                            // Handle PID and Value parsing (assuming hex, except for VIN)\n                            String pidStr = values[0].substring(0, 2);\n                            if (\"74\".equals(pidStr)) { // VIN is ASCII\n                                position.set(Position.KEY_VIN, values[1]);\n                            } else { // Other PIDs assumed hex value\n                                int pid = Integer.parseInt(pidStr, 16);\n                                int value = Integer.parseInt(values[1], 16);\n                                switch (pid) {\n                                    case 40: position.set(Position.KEY_ODOMETER, value * 0.01); break;\n                                    case 43: position.set(Position.KEY_FUEL_LEVEL, value * 0.01); break;\n                                    case 45: position.set(Position.KEY_COOLANT_TEMP, value * 0.01); break;\n                                    case 53: position.set(Position.KEY_OBD_SPEED, value * 0.01); break;\n                                    case 54: position.set(Position.KEY_RPM, value * 0.01); break;\n                                    case 71: position.set(Position.KEY_FUEL_USED, value * 0.01); break;\n                                    case 73: position.set(Position.KEY_HOURS, value * 0.01); break;\n                                    default: break;\n                                }\n                            }\n                        } catch (NumberFormatException | IndexOutOfBoundsException e) { /* ignore parsing errors */ }\n                    }\n                }\n            } else if (dataLength < 0) {\n                // This should not happen if initial check passed\n                 return null;\n            }\n            // Skip footer bytes if necessary (already read dataLength bytes)\n            buf.readerIndex(buf.readerIndex() + Math.max(0, dataLength)); // Ensure index is after data\n            if (buf.readableBytes() >= 18) {\n                buf.skipBytes(18);\n            } else {\n                buf.skipBytes(buf.readableBytes()); // Skip remaining if less than 18\n            }\n\n            return position;\n\n        } else if (type == MSG_GPS_MODULAR) {\n\n            // Footer size is 6 bytes (index + checksum + end)\n            while (buf.readableBytes() > 6 + 4) { // Need module header(4) + packet footer(6)\n                int moduleStartReaderIndex = buf.readerIndex();\n                int moduleType = buf.readUnsignedShort();\n                int moduleLength = buf.readUnsignedShort();\n\n                if (buf.readableBytes() < moduleLength + 6) { break; } // Not enough data for module + footer\n\n                ByteBuf moduleBuf = buf.slice(buf.readerIndex(), moduleLength); // Slice for safe reading\n\n                try {\n                    switch (moduleType) {\n                        // Cases need length checks on moduleBuf before reading\n                        case 0x03: // ICCID\n                             if (moduleLength == 10 && moduleBuf.readableBytes() >= 10) {\n                                  position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleBuf.readSlice(10)));\n                             } break;\n                         case 0x09: // Satellites used\n                             if (moduleLength == 1 && moduleBuf.isReadable()) {\n                                 position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte());\n                             } break;\n                         case 0x0a: // Satellites visible\n                             if (moduleLength == 1 && moduleBuf.isReadable()) {\n                                 position.set(Position.KEY_SATELLITES_VISIBLE, moduleBuf.readUnsignedByte());\n                             } break;\n                         case 0x11: // Network Info\n                              if (moduleLength == 9 && moduleBuf.readableBytes() >= 9) {\n                                 CellTower cellTower = CellTower.from(\n                                         moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(),\n                                         moduleBuf.readUnsignedMedium(), moduleBuf.readUnsignedByte());\n                                 if (cellTower.getCellId() > 0 && cellTower.getCellId() != 0xFFFFFF) {\n                                     position.setNetwork(new Network(cellTower));\n                                 }\n                              } break;\n                         case 0x18: // Battery Voltage\n                             if (moduleLength == 2 && moduleBuf.readableBytes() >= 2) {\n                                 position.set(Position.KEY_BATTERY, moduleBuf.readUnsignedShort() * 0.01);\n                             } break;\n                         case 0x28: // HDOP\n                             if (moduleLength == 1 && moduleBuf.isReadable()) {\n                                 position.set(Position.KEY_HDOP, moduleBuf.readUnsignedByte() * 0.1);\n                             } break;\n                         case 0x29: // Sequence Number\n                             if (moduleLength == 4 && moduleBuf.readableBytes() >= 4) {\n                                 position.set(Position.KEY_INDEX, moduleBuf.readUnsignedInt());\n                             } break;\n                         case 0x2a: // Digital Input Status\n                             if (moduleLength == 1 && moduleBuf.isReadable()) {\n                                 int input = moduleBuf.readUnsignedByte();\n                                 position.set(Position.KEY_DOOR, BitUtil.to(input, 4) > 0);\n                                 position.set(\"tamper\", BitUtil.from(input, 4) > 0);\n                             } break;\n                         case 0x2b: // Alarm Type\n                              if (moduleLength == 1 && moduleBuf.isReadable()) {\n                                 int event = moduleBuf.readUnsignedByte();\n                                  switch (event) {\n                                      case 0x11: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                                      case 0x12: position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER); break;\n                                      case 0x13: position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT); break;\n                                      case 0x14: position.set(Position.KEY_ALARM, Position.ALARM_REMOVING); break;\n                                      default: break;\n                                  }\n                                 position.set(Position.KEY_EVENT, event);\n                              } break;\n                         case 0x2e: // Mileage Statistics\n                             if (moduleLength == 4 && moduleBuf.readableBytes() >= 4) {\n                                 position.set(Position.KEY_ODOMETER, moduleBuf.readUnsignedIntLE());\n                             } break;\n                         case 0x33: // GPS Info\n                             if (moduleLength == 18 && moduleBuf.readableBytes() >= 18) {\n                                  position.setTime(new Date(moduleBuf.readUnsignedInt() * 1000));\n                                  position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte());\n                                  position.setAltitude(moduleBuf.readShort());\n                                  double latitude = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                                  double longitude = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                                  position.setSpeed(UnitsConverter.knotsFromKph(moduleBuf.readUnsignedByte()));\n                                  int flags = moduleBuf.readUnsignedShort();\n                                  position.setCourse(BitUtil.to(flags, 10));\n                                  position.setValid(BitUtil.check(flags, 12));\n                                  if (!BitUtil.check(flags, 10)) { latitude = -latitude; }\n                                  if (BitUtil.check(flags, 11)) { longitude = -longitude; }\n                                  position.setLatitude(latitude);\n                                  position.setLongitude(longitude);\n                             } break;\n                         case 0x34: // LBS Extension Info\n                              if (moduleLength >= 1 + 4 + 1 && moduleBuf.readableBytes() >= 1 + 4 + 1) {\n                                  position.set(Position.KEY_EVENT, moduleBuf.readUnsignedByte());\n                                  moduleBuf.readUnsignedIntLE(); // time\n                                  int contentLength = moduleBuf.readUnsignedByte();\n                                  if (moduleBuf.readableBytes() >= contentLength) {\n                                      moduleBuf.skipBytes(contentLength); // skip content\n                                  }\n                              } break;\n                         default:\n                             break; // Unknown module type\n                    }\n                } catch (Exception e) {\n                    // Error parsing module, log?\n                } finally {\n                     // Advance main buffer reader index past this module\n                     buf.readerIndex(moduleStartReaderIndex + 4 + moduleLength);\n                }\n\n            } // End of module processing loop\n\n            if (position.getFixTime() == null) {\n                getLastLocation(position, null);\n            }\n\n            if (buf.readableBytes() >= 2 + 6) { // Check index(2) + footer(6)\n                 sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null);\n            }\n\n            return position;\n\n        } else if (type == MSG_MULTIMEDIA) {\n\n            // Footer size is 6 bytes (index, checksum, end)\n            // Min length: 8(serial)+4(ts)+11(gps)+8(cell)+4(id)+4(len)+1(type)+1(fmt)+6(footer) = 47\n            if (buf.readableBytes() < 47) { return null; }\n\n            buf.skipBytes(8); // serial number\n            long timestamp = buf.readUnsignedInt() * 1000;\n            getLastLocation(position, new Date(timestamp)); // Set time/location context\n\n            buf.skipBytes(4 + 4 + 2 + 1 + 1 + 2); // gps info\n            buf.skipBytes(2 + 2 + 2 + 2); // cell info\n\n            int mediaId = buf.readInt();\n            int mediaLength = buf.readInt();\n            int mediaType = buf.readUnsignedByte();\n            int mediaFormat = buf.readUnsignedByte();\n\n            if (mediaType == 0 && mediaFormat == 0) { // Photo type\n                 // Min bytes needed for photo info: event(1) + index(2) + footer(6) = 9\n                 if (buf.readableBytes() < 9) { return position; } // Not enough data for photo info/chunk\n\n                buf.readUnsignedByte(); // event\n                int packetIndex = buf.readUnsignedShort();\n\n                ByteBuf photo;\n                if (packetIndex == 0) { // First chunk\n                    photo = Unpooled.buffer(mediaLength);\n                    ByteBuf oldPhoto = photos.put(mediaId, photo);\n                    if (oldPhoto != null) { oldPhoto.release(); } // Clean up old/orphaned buffer\n                } else {\n                    photo = photos.get(mediaId); // Get existing buffer\n                }\n\n                if (photo != null) {\n                    int readableChunk = buf.readableBytes() - 6; // Data available before footer\n                    if (readableChunk > 0) {\n                         try {\n                             // Read chunk data, ensuring we don't overflow the photo buffer\n                             buf.readBytes(photo, Math.min(readableChunk, photo.writableBytes()));\n                         } catch (IndexOutOfBoundsException e) {\n                             photos.remove(mediaId).release(); // Cleanup on error\n                             return position; // Return position without image\n                         }\n                    }\n                    // Check if photo is complete (buffer is full)\n                    if (!photo.isWritable()) {\n                         try {\n                            position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                         } finally {\n                            photos.remove(mediaId).release(); // Always remove from map after processing/attempting write\n                         }\n                    }\n                } // else: photo == null (e.g., index > 0 but no existing buffer) - ignore chunk?\n            } // End of photo processing\n\n             if (buf.readableBytes() >= 6) { // Check for footer before reading response index\n                  sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n             }\n\n            return position; // Return position (maybe with image, maybe just metadata)\n\n        } else if (type == MSG_SERIAL) {\n\n            // Use existing position object created at the start\n\n            // Footer size is 9 bytes (line break? + checksum + index + checksum + footer?)\n            // Min length: type code(1) + footer(9) = 10\n            if (buf.readableBytes() < 1 + 9) { return null; }\n\n            buf.readUnsignedByte(); // external device type code\n            int initialReadableBytes = buf.readableBytes(); // Bytes remaining after type code\n            if (initialReadableBytes < 9) { return null; } // Need at least footer bytes\n\n            int length = initialReadableBytes - 9; // length of payload\n            int readerIndexBeforePayload = buf.readerIndex();\n\n            if (length > 0) {\n                try {\n                    if (length < 8) { // TEMP format assumed (payload = temp string + 1 unknown byte?) -> read length-1 ?\n                        // Ensure length-1 is valid before reading\n                        if (length - 1 < 0) throw new IndexOutOfBoundsException(\"Invalid length for TEMP\");\n                        position.set(Position.PREFIX_TEMP + 1,\n                                Double.parseDouble(buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString()));\n                    } else { // RFID format assumed (payload = card type(1) + id string) -> read length-1 ?\n                         // Ensure length-1 is valid before reading\n                         if (length - 1 < 0) throw new IndexOutOfBoundsException(\"Invalid length for RFID\");\n                         buf.readUnsignedByte(); // card type\n                         position.set(Position.KEY_DRIVER_UNIQUE_ID,\n                                 buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString());\n                    }\n                } catch (Exception e) { // Catch parsing errors (NumberFormat, IndexOutOfBounds)\n                     // Reset reader index to before payload read attempt\n                     buf.readerIndex(readerIndexBeforePayload);\n                     // Skip the entire payload section\n                     buf.skipBytes(length);\n                }\n            } // else: length is 0, no payload to read\n\n            // Ensure reader index is after the payload (or where it would have ended)\n            buf.readerIndex(readerIndexBeforePayload + length);\n\n            // Skip footer bytes\n            if (buf.readableBytes() >= 9) {\n                buf.skipBytes(9);\n            } else {\n                // If we got here, length calculation might be wrong or buffer truncated\n                buf.skipBytes(buf.readableBytes()); // Skip whatever is left\n            }\n\n            if (position.getFixTime() == null) {\n                 getLastLocation(position, null); // Set location if no time was decoded\n            }\n            return position;\n\n        }\n\n        return null; // Return null for unhandled message types\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}