{
    "generation": "private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n    if (deviceSession == null) {\n        return null;\n    }\n\n    if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n        deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n    }\n\n    Position position = new Position(getProtocolName());\n    position.setDeviceId(deviceSession.getDeviceId());\n\n    buf.skipBytes(2); // skip length (we don't parse it here, it's handled externally)\n\n    int type = buf.readUnsignedByte();\n\n    if (type == MSG_STRING_INFO) {\n        buf.readUnsignedInt(); // server flags\n        String data;\n        if (buf.readUnsignedByte() == 1) {\n            data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.US_ASCII);\n        } else {\n            data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.UTF_16BE);\n        }\n\n        Parser parser = new Parser(PATTERN_LOCATION, data);\n        if (parser.matches()) {\n            position.setValid(true);\n            position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n            position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n            position.setCourse(parser.nextDouble());\n            position.setSpeed(parser.nextDouble());\n            position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n        } else {\n            getLastLocation(position, null);\n            position.setTime(new Date());\n            position.set(Position.KEY_RESULT, data);\n        }\n\n        return position;\n    } else if (type == MSG_INFO) {\n        int subType = buf.readUnsignedByte();\n        getLastLocation(position, null);\n\n        if (subType == 0x00) {\n            position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n            return position;\n        } else if (subType == 0x05) {\n            if (buf.readableBytes() >= 6 + 1 + 6) {\n                DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                        .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                        .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                position.setDeviceTime(dateBuilder.getDate());\n            }\n\n            int flags = buf.readUnsignedByte();\n            position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n            position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n            return position;\n        } else if (subType == 0x0a) {\n            buf.skipBytes(8); // imei\n            buf.skipBytes(8); // imsi\n            position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n            return position;\n        } else if (subType == 0x0d) {\n            if (buf.getByte(buf.readerIndex()) != '!')\n                buf.skipBytes(6);\n\n            Parser parser = new Parser(PATTERN_FUEL, buf.toString(\n                    buf.readerIndex(), buf.readableBytes() - 4 - 2, StandardCharsets.US_ASCII));\n            if (!parser.matches()) {\n                position.set(Position.KEY_FUEL_LEVEL, 0.0);\n            } else {\n                position.set(Position.PREFIX_TEMP + 1, parser.nextDoubleUnwrapped());\n                position.set(Position.KEY_FUEL_LEVEL, parser.nextDoubleUnwrapped());\n            }\n            return position;\n        } else if (subType == 0x1b) {\n            if (buf.readableBytes() >= 1 && Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) {\n                String data = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.US_ASCII).toString().trim();\n                position.set(\"serial\", data);\n            } else if (buf.readableBytes() >= 7) {\n                buf.readUnsignedByte(); // header\n                buf.readUnsignedByte(); // type\n                String driverId = ByteBufUtil.hexDump(buf.readSlice(4));\n                position.set(Position.KEY_DRIVER_UNIQUE_ID, driverId);\n                buf.skipBytes(2); // skip checksum and footer\n            }\n            return position;\n        }\n    } else if (type == MSG_GPS_MODULAR || type == 0x11) {\n        // Attempt to decode irrespective of module types\n        boolean hasPositionData = false;\n        while (buf.readableBytes() > 4) {\n            int moduleType = buf.readUnsignedShort();\n            int moduleLength = buf.readUnsignedShort();\n\n            if (buf.readableBytes() < moduleLength)\n                break; // can't read full module \u2014 exit early\n\n            switch (moduleType) {\n                case 0x03:\n                    position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)));\n                    break;\n                case 0x09:\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    break;\n                case 0x0a:\n                    position.set(Position.KEY_SATELLITES_VISIBLE, buf.readUnsignedByte());\n                    break;\n                case 0x11:\n                    CellTower cellTower = CellTower.from(\n                            buf.readUnsignedShort(),\n                            buf.readUnsignedShort(),\n                            buf.readUnsignedShort(),\n                            buf.readUnsignedMedium(),\n                            buf.readUnsignedByte());\n                    if (cellTower.getCellId() > 0) {\n                        position.setNetwork(new Network(cellTower));\n                    }\n                    break;\n                case 0x33:\n                    position.setTime(new Date(buf.readUnsignedInt() * 1000));\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    position.setAltitude(buf.readShortLE());\n\n                    long latData = buf.readUnsignedIntLE();\n                    long lonData = buf.readUnsignedIntLE();\n                    double latitude = latData / 60.0 / 30000.0;\n                    double longitude = lonData / 60.0 / 30000.0;\n\n                    // Apply sign if necessary\n                    int flags = buf.readUnsignedShort();\n                    position.setValid(BitUtil.check(flags, 12));\n                    if (BitUtil.check(flags, 0)) latitude = -latitude;\n                    if (BitUtil.check(flags, 1)) longitude = -longitude;\n\n                    position.setLatitude(latitude);\n                    position.setLongitude(longitude);\n                    position.setCourse(BitUtil.check(flags, 10) ? 1 : 0);\n                    hasPositionData = true;\n                    break;\n                default:\n                    buf.skipBytes(moduleLength);\n                    break;\n            }\n        }\n\n        if (!hasPositionData) {\n            getLastLocation(position, position.getDeviceTime());\n        }\n\n        sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null);\n        return position;\n\n    } else if (type == MSG_OBD) {\n        DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n        getLastLocation(position, dateBuilder.getDate());\n        position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n        String data = buf.readCharSequence(buf.readableBytes() - 18, StandardCharsets.US_ASCII).toString();\n        for (String pair : data.split(\",\")) {\n            String[] values = pair.split(\"=\");\n            if (values.length >= 2) {\n                int key = Integer.parseInt(values[0].substring(0, 2), 16);\n                switch (key) {\n                    case 40:\n                        position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01);\n                        break;\n                    case 43:\n                        position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        return position;\n    }\n\n    // Support fallback for unrecognized message types (but deviceSession is valid)\n    position.setTime(new Date());\n    getLastLocation(position, position.getTime());\n    return position;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}