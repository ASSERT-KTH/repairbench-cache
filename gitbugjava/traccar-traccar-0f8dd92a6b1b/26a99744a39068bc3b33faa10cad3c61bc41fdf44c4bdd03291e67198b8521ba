{
    "generation": "private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n    if (deviceSession == null) {\n        return null;\n    }\n\n    if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n        deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n    }\n\n    Position position = new Position(getProtocolName());\n    position.setDeviceId(deviceSession.getDeviceId());\n\n    buf.readUnsignedShort(); // length\n    int type = buf.readUnsignedByte();\n\n    if (type == MSG_STRING_INFO) {\n        // ... \u539f\u59cb\u4ee3\u7801\uff0c\u786e\u4fdd\u6700\u540e return position\uff1b\n    } else if (type == MSG_INFO) {\n        int subType = buf.readUnsignedByte();\n        getLastLocation(position, null);\n\n        if (subType == 0x00) {\n            position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01); // ADC \u5b57\u6bb5\n            return position;\n        } else if (subType == 0x05) {\n            // \u5904\u7406\u65e5\u671f\u65f6\u95f4\u7b49\n            if (buf.readableBytes() >= 6 + 1 + 6) {\n                DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                        .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                        .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                position.setDeviceTime(dateBuilder.getDate());\n            }\n            int flags = buf.readUnsignedByte();\n            // \u8bbe\u7f6e\u95e8\u548cIO\u72b6\u6001\n            position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n            position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n            return position;\n        } else if (subType == 0x0a) {\n            // \u5904\u7406ICCID\n            buf.skipBytes(8); buf.skipBytes(8);\n            position.set(\n                    Position.KEY_ICCID,\n                    ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\")\n            );\n            return position;\n        } else if (subType == 0x1b) {\n            // \u5904\u7406\u578b\u53f7\u548c\u9a71\u52a8\u4fe1\u606f\n            if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) {\n                String data = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.US_ASCII).toString();\n                position.set(\"serial\", data.trim());\n            } else {\n                buf.readUnsignedByte(); buf.readUnsignedByte();\n                position.set(\n                        Position.KEY_DRIVER_UNIQUE_ID,\n                        ByteBufUtil.hexDump(buf.readSlice(4))\n                );\n                buf.readUnsignedByte(); buf.readUnsignedByte();\n            }\n            return position;\n        }\n        // \u65b0\u589e\u7684\u8fd4\u56de\u8bed\u53e5\n        return position; // \u6dfb\u52a0\u6b64\u8fd4\u56de\uff0c\u5373\u4f7f subType \u4e0d\u5728\u4e0a\u8ff0\u60c5\u51b5\u4ecd\u7136\u8fd4\u56de\u975e\u7a7a\u7684 Position \u5bf9\u8c61\n    } else if ( /* \u5176\u4ed6 type \u5206\u652f */ ) {\n        // \u4ee3\u7801\u539f\u6709\u5206\u652f\u903b\u8f91\n    }\n\n    return null; // \u6700\u7ec8\u672a\u547d\u4e2d\u7684 type \u8fd4\u56denull\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}