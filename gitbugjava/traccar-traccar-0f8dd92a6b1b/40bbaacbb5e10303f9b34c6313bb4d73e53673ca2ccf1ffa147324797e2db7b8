{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Original buffer slice includes length field(s), type, payload, index, checksum.\n        // Determine if the frame format was 7878 (1 byte length) or 7979 (2 bytes length)\n        // by checking the total buffer size against the length field value inside the buffer.\n        int length;\n        int type;\n        int headerLength; // Number of bytes for length field + type field\n\n        // Check for 7878 format: slice_size = length_value + 2 (length byte itself, type, payload, index, crc)\n        if (buf.readableBytes() > 0 && buf.readableBytes() == buf.getUnsignedByte(buf.readerIndex()) + 2) {\n            length = buf.readUnsignedByte(); // Read 1-byte length field value\n            type = buf.readUnsignedByte();   // Read type\n            headerLength = 1 + 1; // length byte + type byte\n        // Check for 7979 format: slice_size = length_value + 4 (length short, type, payload, index, crc)\n        } else if (buf.readableBytes() > 1 && buf.readableBytes() == buf.getUnsignedShort(buf.readerIndex()) + 4) {\n            length = buf.readUnsignedShort(); // Read 2-byte length field value\n            type = buf.readUnsignedByte();    // Read type\n            headerLength = 2 + 1; // length short + type byte\n        } else {\n            // Unknown frame format or corrupted buffer\n             return null;\n        }\n\n        // Calculate payload length (data between type and index)\n        // Total length field value = type(1) + payload(?) + index(2) + crc(2) = payloadLength + 5\n        // So, payloadLength = length - 5\n        int payloadLength = length - 5;\n        if (payloadLength < 0) {\n             return null; // Invalid length\n        }\n\n        // Create a slice for the payload only to avoid reading past it into index/crc\n        // The reader index is currently after the type byte.\n        ByteBuf payloadBuf = buf.readSlice(payloadLength);\n\n\n        if (type == MSG_STRING_INFO) { // 0x21 or 0x94 (Used by 7979 frames)\n\n            if (payloadBuf.readableBytes() < 5) return null; // Need server flag (4) + encoding (1)\n            payloadBuf.readUnsignedInt(); // server flag\n            String data;\n            int encoding = payloadBuf.readUnsignedByte();\n            // Remaining bytes in payloadBuf are the data string\n            if (encoding == 1) {\n                data = payloadBuf.toString(StandardCharsets.US_ASCII);\n            } else {\n                data = payloadBuf.toString(StandardCharsets.UTF_16BE);\n            }\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                getLastLocation(position, null);\n                position.set(Position.KEY_RESULT, data);\n            }\n\n            return position;\n\n        } else if (type == MSG_INFO) { // 0x13\n\n            if (payloadBuf.readableBytes() < 1) return null; // Need at least subType\n            int subType = payloadBuf.readUnsignedByte();\n\n            getLastLocation(position, null);\n\n            if (subType == 0x00) {\n                if (payloadBuf.readableBytes() < 2) return position; // Not enough data, return partial\n                position.set(Position.PREFIX_ADC + 1, payloadBuf.readUnsignedShort() * 0.01);\n                return position;\n\n            } else if (subType == 0x05) {\n                if (payloadBuf.readableBytes() >= 7) { // Needs 6 (time) + 1 (flags) = 7 bytes\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte())\n                            .setTime(payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n\n                    int flags = payloadBuf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                }\n                return position; // Return position even if time/flags couldn't be read\n\n            } else if (subType == 0x0a) {\n                if (payloadBuf.readableBytes() < 26) return position; // Needs 8 (imei) + 8 (imsi) + 10 (iccid) = 26 bytes\n                payloadBuf.skipBytes(8); // imei\n                payloadBuf.skipBytes(8); // imsi\n                position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(payloadBuf.readSlice(10)).replaceAll(\"f\", \"\"));\n                return position;\n\n            } else if (subType == 0x0d) {\n                int fuelDataLength = payloadBuf.readableBytes();\n                if (fuelDataLength > 0 && payloadBuf.getByte(payloadBuf.readerIndex()) != '!') {\n                    if (fuelDataLength < 6) return position; // Not enough data to skip\n                    payloadBuf.skipBytes(6);\n                    fuelDataLength -= 6;\n                }\n\n                if (fuelDataLength <= 0) return position;\n\n                String fuelData = payloadBuf.readCharSequence(fuelDataLength, StandardCharsets.US_ASCII).toString();\n                Parser parser = new Parser(PATTERN_FUEL, fuelData);\n                if (parser.matches()) {\n                    position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                    position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                }\n                return position;\n\n            } else if (subType == 0x1b) {\n                if (payloadBuf.readableBytes() <= 0) return position;\n\n                if (Character.isLetter(payloadBuf.getUnsignedByte(payloadBuf.readerIndex()))) {\n                    String data = payloadBuf.toString(StandardCharsets.US_ASCII).trim();\n                    position.set(\"serial\", data);\n                } else {\n                    if (payloadBuf.readableBytes() < 8) return position; // Needs 1 + 1 + 4 + 1 + 1 = 8 bytes\n                    payloadBuf.readUnsignedByte(); // header\n                    payloadBuf.readUnsignedByte(); // type\n                    position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(payloadBuf.readSlice(4)));\n                    payloadBuf.readUnsignedByte(); // checksum\n                    payloadBuf.readUnsignedByte(); // footer\n                }\n                return position;\n\n            } else {\n                 return position; // Unknown subtype, return partial position\n            }\n\n        } else if (type == MSG_X1_PHOTO_DATA) { // 0x96\n            // Needs pictureId (4), offset (4), dataLength (2) = 10 bytes minimum header\n            if (payloadBuf.readableBytes() < 10) return null;\n\n            int pictureId = payloadBuf.readInt();\n            ByteBuf photo = photos.get(pictureId);\n            if (photo == null) {\n                return null; // Ignore data if we don't have the photo buffer initialized\n            }\n\n            payloadBuf.readUnsignedInt(); // offset (not used)\n            int dataLength = payloadBuf.readUnsignedShort(); // Declared length of data in this packet\n            int bytesToRead = Math.min(dataLength, payloadBuf.readableBytes()); // Actual data bytes available in payload\n            bytesToRead = Math.min(bytesToRead, photo.writableBytes()); // Don't write past buffer capacity\n\n            if (bytesToRead > 0) {\n                 payloadBuf.readBytes(photo, bytesToRead);\n            }\n\n            if (photo.writableBytes() > 0) {\n                sendPhotoRequest(channel, pictureId); // Request next chunk\n                 return null; // No position update until photo is complete\n            } else {\n                // Photo complete\n                getLastLocation(position, null); // Populate with last known data\n                position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                photos.remove(pictureId).release();\n                return position;\n            }\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) { // 0xA4, 0xA5\n             // Original logic relies on sequential reads; using payloadBuf ensures boundaries\n             if (!decodeGps(position, payloadBuf, true, deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                 getLastLocation(position, position.getDeviceTime());\n             }\n\n             // Check remaining bytes before reading more\n             if (payloadBuf.readableBytes() > 0 && decodeLbs(position, payloadBuf, type, true)) {\n                  if (payloadBuf.readableBytes() > 0) {\n                    position.set(Position.KEY_RSSI, payloadBuf.readUnsignedByte());\n                  }\n             }\n\n             if (payloadBuf.readableBytes() > 0) { // Skip additional cell towers length byte + data\n                 int skip = payloadBuf.readUnsignedByte();\n                 payloadBuf.skipBytes(Math.min(skip, payloadBuf.readableBytes()));\n             }\n             if (payloadBuf.readableBytes() > 0) { // Skip wifi access point length byte + data\n                 int skip = payloadBuf.readUnsignedByte();\n                 payloadBuf.skipBytes(Math.min(skip, payloadBuf.readableBytes()));\n             }\n\n             if (payloadBuf.readableBytes() > 0) {\n                 int status = payloadBuf.readUnsignedByte();\n                 position.set(Position.KEY_STATUS, status);\n\n                 if (type == MSG_AZ735_ALARM) {\n                     switch (status) {\n                         case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                         case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                         case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                         case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                         case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                         default: break;\n                     }\n                 }\n             }\n\n             if (payloadBuf.readableBytes() > 0) { // Skip reserved extension length byte + data\n                 int skip = payloadBuf.readUnsignedByte();\n                 payloadBuf.skipBytes(Math.min(skip, payloadBuf.readableBytes()));\n             }\n\n             // Send response using index from the original buffer (before payloadBuf was sliced)\n             // Index starts 4 bytes before the end of the original slice.\n             short index = buf.getShort(buf.writerIndex() - 4);\n             sendResponse(channel, true, type, index, null);\n\n             return position;\n\n        } else if (type == MSG_OBD) { // 0x24\n            // Needs Date/Time (6) + Ignition (1) = 7 bytes minimum\n            if (payloadBuf.readableBytes() < 7) {\n                return null; // Not enough data for basic info\n            }\n\n            DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                    .setDate(payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte())\n                    .setTime(payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte(), payloadBuf.readUnsignedByte());\n\n            getLastLocation(position, dateBuilder.getDate());\n\n            position.set(Position.KEY_IGNITION, payloadBuf.readUnsignedByte() > 0);\n\n            // Remaining payload is the OBD string\n            String data = payloadBuf.toString(StandardCharsets.US_ASCII);\n\n            for (String pair : data.split(\",\")) {\n                String[] values = pair.split(\"=\");\n                if (values.length >= 2 && values[0].length() >= 2) {\n                    try {\n                        switch (Integer.parseInt(values[0].substring(0, 2), 16)) {\n                            case 0x40: position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x43: position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x45: position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x53: position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x54: position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x71: position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x73: position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01); break;\n                            case 0x74: position.set(Position.KEY_VIN, values[1]); break;\n                            default: break;\n                        }\n                    } catch (NumberFormatException e) {\n                        // Ignore PID if value is not a valid hex number or key format issue\n                    }\n                }\n            }\n            return position; // Return the position object\n\n        } else if (type == MSG_GPS_MODULAR) { // 0x70\n             while (payloadBuf.readableBytes() >= 4) { // Need 4 bytes for module header\n                 int moduleType = payloadBuf.readUnsignedShort();\n                 int moduleLength = payloadBuf.readUnsignedShort();\n\n                 if (payloadBuf.readableBytes() < moduleLength) {\n                      break; // Not enough data for module content, stop processing modules\n                 }\n                 ByteBuf moduleBuf = payloadBuf.readSlice(moduleLength); // Slice module content\n\n                 switch (moduleType) {\n                     case 0x03: if (moduleBuf.readableBytes() >= 10) position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleBuf.readSlice(10))); break;\n                     case 0x09: if (moduleBuf.readableBytes() >= 1) position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte()); break;\n                     case 0x0a: if (moduleBuf.readableBytes() >= 1) position.set(Position.KEY_SATELLITES_VISIBLE, moduleBuf.readUnsignedByte()); break;\n                     case 0x11: // Cell Tower\n                          if (moduleBuf.readableBytes() >= 9) { // 2+2+2+3+1 = 10? No, 2+2+2+3(medium)+1 = 10 bytes needed. Docs say 9? Let's assume 10.\n                              if (moduleBuf.readableBytes() >= 10) {\n                                  CellTower cellTower = CellTower.from(\n                                      moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(), moduleBuf.readUnsignedShort(),\n                                      moduleBuf.readUnsignedMedium(), moduleBuf.readUnsignedByte());\n                                  if (cellTower.getCellId() > 0) position.setNetwork(new Network(cellTower));\n                              }\n                          } break;\n                     case 0x18: if (moduleBuf.readableBytes() >= 2) position.set(Position.KEY_BATTERY, moduleBuf.readUnsignedShort() * 0.01); break;\n                     case 0x28: if (moduleBuf.readableBytes() >= 1) position.set(Position.KEY_HDOP, moduleBuf.readUnsignedByte() * 0.1); break;\n                     case 0x29: if (moduleBuf.readableBytes() >= 4) position.set(Position.KEY_INDEX, moduleBuf.readUnsignedInt()); break;\n                     case 0x2a: // Input status\n                          if (moduleBuf.readableBytes() >= 1) {\n                              int input = moduleBuf.readUnsignedByte();\n                              position.set(Position.KEY_DOOR, BitUtil.to(input, 4) > 0);\n                              position.set(\"tamper\", BitUtil.from(input, 4) > 0);\n                          } break;\n                     case 0x2b: // Event\n                          if (moduleBuf.readableBytes() >= 1) {\n                              int event = moduleBuf.readUnsignedByte();\n                              switch (event) {\n                                  case 0x11: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                                  case 0x12: position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER); break;\n                                  case 0x13: position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT); break;\n                                  case 0x14: position.set(Position.KEY_ALARM, Position.ALARM_REMOVING); break;\n                                  default: break;\n                              }\n                              position.set(Position.KEY_EVENT, event);\n                          } break;\n                     case 0x2e: if (moduleBuf.readableBytes() >= 4) position.set(Position.KEY_ODOMETER, moduleBuf.readUnsignedIntLE()); break;\n                     case 0x33: // GPS Data\n                         if (moduleBuf.readableBytes() >= 22) { // 4+1+2+4+4+1+2=22 bytes\n                             position.setTime(new Date(moduleBuf.readUnsignedInt() * 1000));\n                             position.set(Position.KEY_SATELLITES, moduleBuf.readUnsignedByte());\n                             position.setAltitude(moduleBuf.readShort());\n                             double latitude = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                             double longitude = moduleBuf.readUnsignedInt() / 60.0 / 30000.0;\n                             position.setSpeed(UnitsConverter.knotsFromKph(moduleBuf.readUnsignedByte()));\n                             int flags = moduleBuf.readUnsignedShort();\n                             position.setCourse(BitUtil.to(flags, 10));\n                             position.setValid(BitUtil.check(flags, 12));\n                             if (!BitUtil.check(flags, 10)) latitude = -latitude;\n                             if (BitUtil.check(flags, 11)) longitude = -longitude;\n                             position.setLatitude(latitude);\n                             position.setLongitude(longitude);\n                         } break;\n                    case 0x34: // Event with content\n                        if (moduleBuf.readableBytes() >= 6) { // 1(event)+4(time)+1(len)\n                            position.set(Position.KEY_EVENT, moduleBuf.readUnsignedByte());\n                            moduleBuf.readUnsignedIntLE(); // time\n                            int contentLength = moduleBuf.readUnsignedByte();\n                            if (moduleBuf.readableBytes() >= contentLength) {\n                                moduleBuf.skipBytes(contentLength); // skip content\n                            }\n                        } break;\n                     default:\n                         // Already sliced, effectively skipped\n                         break;\n                 }\n             }\n\n             if (position.getFixTime() == null) {\n                 getLastLocation(position, null);\n             }\n\n             short index = buf.getShort(buf.writerIndex() - 4);\n             sendResponse(channel, false, MSG_GPS_MODULAR, index, null);\n\n             return position;\n\n        } else if (type == MSG_MULTIMEDIA) { // 0x15\n             // Header: serial(8)+ts(4)+gps(12)+cell(8)+mediaId(4)+mediaLen(4)+type(1)+format(1) = 44\n             // Data: event(1)+packetIdx(2)+data = 3+\n             if (payloadBuf.readableBytes() < 44 + 3) return null;\n\n             payloadBuf.skipBytes(8); // serial\n             long timestamp = payloadBuf.readUnsignedInt() * 1000;\n             payloadBuf.skipBytes(12); // gps\n             payloadBuf.skipBytes(8); // cell\n\n             int mediaId = payloadBuf.readInt();\n             int mediaLength = payloadBuf.readInt();\n             int mediaType = payloadBuf.readUnsignedByte();\n             int mediaFormat = payloadBuf.readUnsignedByte();\n\n             Position positionUpdate = null; // Only return position if photo completes\n\n             if (mediaType == 0 && mediaFormat == 0) { // Photo JPEG\n                 payloadBuf.readUnsignedByte(); // event\n                 int packetIndex = payloadBuf.readUnsignedShort();\n\n                 ByteBuf photo;\n                 if (packetIndex == 0) {\n                     photo = Unpooled.buffer(mediaLength);\n                     if (photos.containsKey(mediaId)) { photos.remove(mediaId).release(); }\n                     photos.put(mediaId, photo);\n                 } else {\n                     photo = photos.get(mediaId);\n                 }\n\n                 if (photo != null) {\n                     int bytesToRead = Math.min(payloadBuf.readableBytes(), photo.writableBytes());\n                     if (bytesToRead > 0) {\n                         payloadBuf.readBytes(photo, bytesToRead);\n                     }\n                     if (!photo.isWritable()) { // Check if complete\n                         getLastLocation(position, new Date(timestamp)); // Use the original position object\n                         position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                         photos.remove(mediaId).release();\n                         positionUpdate = position; // Mark that position should be returned\n                     }\n                 }\n             }\n\n             short index = buf.getShort(buf.writerIndex() - 4);\n             sendResponse(channel, true, type, index, null);\n             return positionUpdate; // Return position only if photo completed\n\n        } else if (type == MSG_SERIAL) { // 0x9B\n            if (payloadBuf.readableBytes() < 1) return position; // Need device code\n\n            getLastLocation(position, null);\n            payloadBuf.readUnsignedByte(); // external device type code\n\n            // Based on test case \"797900149b03023539303042343843454238410300139ba40d0a\"\n            // Payload: 03 02 353930304234384345423841 03\n            // Expected ID: \"5900B48CEB\" (ASCII of 35...42)\n            // Format seems: [DevCode] [CardType] [ASCII ID (12 bytes?)] [Unknown byte(s)]\n            if (payloadBuf.readableBytes() >= 1 + 12) { // Need card type + 12 bytes ID minimum\n                 payloadBuf.readUnsignedByte(); // card type\n                 position.set(\n                         Position.KEY_DRIVER_UNIQUE_ID,\n                         payloadBuf.readCharSequence(12, StandardCharsets.US_ASCII).toString());\n            } else if (payloadBuf.readableBytes() > 0) { // Fallback for possible temperature reading?\n                // Original code checked if length < 8 for temperature. Let's use that.\n                int dataLength = payloadBuf.readableBytes(); // Data after device code\n                 if (dataLength < 8) {\n                     String tempData = payloadBuf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                     try {\n                         position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(tempData));\n                     } catch (NumberFormatException e) { /* ignore */ }\n                 }\n             }\n            return position;\n        }\n\n        return null; // Return null if type is not handled\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}