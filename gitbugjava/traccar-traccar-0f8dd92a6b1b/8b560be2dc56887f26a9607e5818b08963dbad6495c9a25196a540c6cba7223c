{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        buf.readUnsignedShort(); // length\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_STRING_INFO) { // 0x15\n\n            buf.readUnsignedInt(); // server flag\n            String data;\n            // Check remaining length before reading encoding type and data\n            if (buf.readableBytes() >= 1 + 6) { // encoding byte + end bytes\n                if (buf.readUnsignedByte() == 1) {\n                    data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.US_ASCII);\n                } else {\n                    data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.UTF_16BE);\n                }\n            } else {\n                return null; // Not enough data\n            }\n\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                getLastLocation(position, null);\n                position.set(Position.KEY_RESULT, data);\n            }\n            // No response needed for string info?\n\n            return position;\n\n        } else if (type == MSG_INFO) { // 0x13\n\n            int subType = buf.readUnsignedByte();\n\n            getLastLocation(position, null);\n\n            if (subType == 0x00) {\n                if (buf.readableBytes() >= 2 + 6) {\n                    position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                    return position;\n                }\n            } else if (subType == 0x05) {\n                // Date(6) + Flags(1) + End(6) = 13\n                if (buf.readableBytes() >= 6 + 1 + 6) {\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2)); // ACC?\n                    return position;\n                }\n            } else if (subType == 0x0a) {\n                // IMEI(8) + IMSI(8) + ICCID(10) + End(6) = 32\n                if (buf.readableBytes() >= 8 + 8 + 10 + 6) {\n                    buf.skipBytes(8); // imei\n                    buf.skipBytes(8); // imsi\n                    position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"f\", \"\"));\n                    return position;\n                }\n            } else if (subType == 0x0d) {\n                // Format: Optional Header(6) + !AIOIL,.... + End(6)\n                if (buf.readableBytes() > 6) { // Check if there's any data before the end bytes\n                    int startIndex = buf.readerIndex();\n                    if (buf.getByte(startIndex) != '!') {\n                        if (buf.readableBytes() >= 6 + 6) { // Header + End bytes\n                            buf.skipBytes(6);\n                            startIndex += 6;\n                        } else {\n                            return null; // Not enough data for header + content + end\n                        }\n                    }\n                    // Data Length = Total Readable - Start Offset - End Bytes (index, checksum, footer = 6)\n                    int dataLength = buf.readableBytes() - (buf.readerIndex() - startIndex) - 6;\n                    if (dataLength > 0) {\n                        Parser parser = new Parser(PATTERN_FUEL, buf.toString(buf.readerIndex(), dataLength, StandardCharsets.US_ASCII));\n                        if (!parser.matches()) {\n                            return null; // Parsing failed\n                        }\n                        position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                        position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                        buf.skipBytes(dataLength); // Consume parsed data\n                        return position;\n                    }\n                }\n            } else if (subType == 0x1b) {\n                // Check if enough bytes for end marker\n                if (buf.readableBytes() >= 6) {\n                    if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) {\n                        // Serial String\n                        String data = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.US_ASCII).toString();\n                        position.set(\"serial\", data.trim());\n                    } else {\n                        // Driver ID: Header(1) + Type(1) + ID(4) + Checksum(1) + Footer(1) = 8 bytes minimum before end\n                         if (buf.readableBytes() >= 1 + 1 + 4 + 1 + 1 + 6) {\n                            buf.readUnsignedByte(); // header\n                            buf.readUnsignedByte(); // type\n                            position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                            buf.readUnsignedByte(); // checksum\n                            buf.readUnsignedByte(); // footer\n                        } else {\n                             return null; // Not enough data for Driver ID format\n                        }\n                    }\n                    return position;\n                }\n            }\n            // If subtype not handled or not enough data, fall through to return null\n\n        } else if (type == MSG_X1_PHOTO_DATA) { // 0xE2\n\n            int pictureId = buf.readInt();\n            ByteBuf photo = photos.get(pictureId);\n\n            // Check photo exists before proceeding\n            if (photo == null) {\n                 return null; // No photo buffer initialized for this ID\n            }\n\n            buf.readUnsignedInt(); // offset\n            int photoDataLength = buf.readUnsignedShort();\n\n            if (buf.readableBytes() >= photoDataLength + 6) { // Check enough data for photo chunk and end bytes\n                int readable = Math.min(photoDataLength, photo.writableBytes());\n                if (readable > 0) {\n                     buf.readBytes(photo, readable);\n                }\n                // Skip any remaining bytes from this chunk if buffer is full or length mismatch\n                if (photoDataLength > readable) {\n                    buf.skipBytes(photoDataLength - readable);\n                }\n\n                if (photo.writableBytes() > 0) {\n                    sendPhotoRequest(channel, pictureId);\n                    return null; // More data needed, return null (no position update yet)\n                } else {\n                    getLastLocation(position, null); // Associate photo with last known location/time\n                    position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                    photos.remove(pictureId).release();\n                    // No response needed for data message? Protocol might expect ack separately.\n                    return position; // Return position with image key\n                }\n            }\n             // Not enough data in buffer, maybe next packet will have it. Return null for now.\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) { // 0xA2, 0xA4\n\n            if (!decodeGps(position, buf, true, (TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n\n            if (decodeLbs(position, buf, type, true)) {\n                // Check if RSSI byte exists before reading\n                if (buf.readableBytes() >= 1) {\n                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                }\n            }\n\n            // Skip additional cell towers / wifi APs safely\n            if (buf.readableBytes() >= 1) {\n                buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes()));\n            }\n             if (buf.readableBytes() >= 1) {\n                buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes()));\n            }\n\n            if (buf.readableBytes() >= 1) {\n                 int status = buf.readUnsignedByte();\n                 position.set(Position.KEY_STATUS, status);\n\n                 if (type == MSG_AZ735_ALARM) {\n                     switch (status) {\n                         case 0xA0:\n                             position.set(Position.KEY_ARMED, true);\n                             break;\n                         case 0xA1:\n                             position.set(Position.KEY_ARMED, false);\n                             break;\n                         case 0xA2:\n                         case 0xA3:\n                             position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY);\n                             break;\n                         case 0xA4:\n                             position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                             break;\n                         case 0xA5:\n                             position.set(Position.KEY_ALARM, Position.ALARM_DOOR);\n                             break;\n                         default:\n                             break;\n                     }\n                 }\n             }\n\n            // Skip reserved extension safely\n            if (buf.readableBytes() >= 1 + 6) { // Need length byte + end bytes\n                 buf.skipBytes(Math.min(buf.readUnsignedByte(), buf.readableBytes() - 6));\n            }\n\n            // Check for index before reading\n            if (buf.readableBytes() >= 2) {\n                 sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n            }\n\n            return position;\n\n        } else if (type == MSG_OBD) { // 0x34\n\n            // Date(6) + Ignition(1) + ... + End(18) - Variable length\n            if (buf.readableBytes() >= 6 + 1 + 18) {\n                DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                        .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                        .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n\n                getLastLocation(position, dateBuilder.getDate());\n\n                position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n                // Data length = total readable - already read (7) - end bytes (18)\n                int dataLength = buf.readableBytes() - 18;\n                if (dataLength > 0) {\n                    String data = buf.readCharSequence(dataLength, StandardCharsets.US_ASCII).toString();\n                    for (String pair : data.split(\",\")) {\n                        String[] values = pair.split(\"=\");\n                        if (values.length >= 2) {\n                            try {\n                                // Replicate logic from MSG_OBD (0x34) handler\n                                switch (Integer.parseInt(values[0].substring(0, 2), 16)) {\n                                    case 0x40:\n                                        position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x43:\n                                        position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x45:\n                                        position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x53:\n                                        position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x54:\n                                        position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x71:\n                                        position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x73:\n                                        position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01);\n                                        break;\n                                    case 0x74:\n                                        position.set(Position.KEY_VIN, values[1]);\n                                        break;\n                                    default:\n                                        break;\n                                }\n                            } catch (NumberFormatException | IndexOutOfBoundsException e) {\n                                // Ignore invalid OBD pairs\n                            }\n                        }\n                    }\n                }\n                // No response defined for OBD message? Skip final bytes.\n                buf.skipBytes(18);\n                return position;\n            }\n\n        } else if (type == MSG_GPS_MODULAR) { // 0x70\n\n            while (buf.readableBytes() > 6) { // Need 2 for type, 2 for length + minimum 1 data byte + end(6)? No, end bytes are after loop. Just need module header.\n                if (buf.readableBytes() < 4) { // Check enough bytes for module type and length\n                    break;\n                }\n                int moduleType = buf.readUnsignedShort();\n                int moduleLength = buf.readUnsignedShort();\n\n                if (buf.readableBytes() < moduleLength) {\n                    break; // Not enough data for declared module length\n                }\n\n                ByteBuf moduleSlice = buf.readSlice(moduleLength);\n\n                switch (moduleType) {\n                    case 0x03: // ICCID\n                        if (moduleLength >= 10) {\n                             // Avoid replacing 'f' as it might be part of valid ICCID\n                            position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(moduleSlice.readSlice(10)));\n                        }\n                        break;\n                    case 0x09: // Satellites used\n                        if (moduleLength >= 1) {\n                            position.set(Position.KEY_SATELLITES, moduleSlice.readUnsignedByte());\n                        }\n                        break;\n                    case 0x0a: // Satellites visible\n                        if (moduleLength >= 1) {\n                            position.set(Position.KEY_SATELLITES_VISIBLE, moduleSlice.readUnsignedByte());\n                        }\n                        break;\n                    case 0x11: // LBS\n                        if (moduleLength >= 9) { // MCC(2) MNC(2) LAC(2) CID(3) RSSI(1) = 10 bytes? Check CellTower.from params\n                                                 // MCC(ushort), MNC(ushort), LAC(ushort), CID(uint medium), RSSI(ubyte) -> 2+2+2+3+1 = 10 bytes\n                             if (moduleLength >= 10) {\n                                 CellTower cellTower = CellTower.from(\n                                         moduleSlice.readUnsignedShort(),   // mcc\n                                         moduleSlice.readUnsignedShort(),   // mnc -> This might be wrong, standard MNC is often 1 byte BCD or 3 digits. Check usage. Assuming ushort for now.\n                                         moduleSlice.readUnsignedShort(),   // lac\n                                         moduleSlice.readUnsignedMedium(), // cid\n                                         moduleSlice.readUnsignedByte());  // rssi\n                                 if (cellTower.getCellId() > 0 && cellTower.getMobileCountryCode() != 0) {\n                                     position.setNetwork(new Network(cellTower));\n                                 }\n                             }\n                        }\n                        break;\n                    case 0x18: // Battery Voltage\n                        if (moduleLength >= 2) {\n                            position.set(Position.KEY_BATTERY, moduleSlice.readUnsignedShort() * 0.01);\n                        }\n                        break;\n                    case 0x28: // HDOP\n                        if (moduleLength >= 1) {\n                            position.set(Position.KEY_HDOP, moduleSlice.readUnsignedByte() * 0.1);\n                        }\n                        break;\n                    case 0x29: // Index / Serial\n                        if (moduleLength >= 4) {\n                            position.set(Position.KEY_INDEX, moduleSlice.readUnsignedInt());\n                        }\n                        break;\n                    case 0x2a: // Digital Input Status\n                        if (moduleLength >= 1) {\n                            int input = moduleSlice.readUnsignedByte();\n                            // Example interpretation - adjust based on device spec\n                            position.set(Position.KEY_DOOR, BitUtil.check(input, 0)); // Bit 0 for Door\n                            position.set(Position.KEY_IGNITION, BitUtil.check(input, 1)); // Bit 1 for Ignition\n                            position.set(\"tamper\", BitUtil.check(input, 4)); // Bit 4 for Tamper\n                        }\n                        break;\n                    case 0x2b: // Event Code\n                        if (moduleLength >= 1) {\n                            int event = moduleSlice.readUnsignedByte();\n                            switch (event) {\n                                case 0x11:\n                                    position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY);\n                                    break;\n                                case 0x12:\n                                    position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER);\n                                    break;\n                                case 0x13:\n                                    position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT);\n                                    break;\n                                case 0x14:\n                                    position.set(Position.KEY_ALARM, Position.ALARM_REMOVING);\n                                    break;\n                                default:\n                                    break;\n                            }\n                            position.set(Position.KEY_EVENT, event);\n                        }\n                        break;\n                    case 0x2e: // Odometer\n                        if (moduleLength >= 4) {\n                            position.set(Position.KEY_ODOMETER, moduleSlice.readUnsignedIntLE());\n                        }\n                        break;\n                    case 0x33: // GPS Data\n                        if (moduleLength >= 18) {\n                            position.setTime(new Date(moduleSlice.readUnsignedInt() * 1000));\n                            position.set(Position.KEY_SATELLITES, moduleSlice.readUnsignedByte());\n                            position.setAltitude(moduleSlice.readShort());\n\n                            double latitude = moduleSlice.readUnsignedInt() / 60.0 / 30000.0;\n                            double longitude = moduleSlice.readUnsignedInt() / 60.0 / 30000.0;\n                            position.setSpeed(UnitsConverter.knotsFromKph(moduleSlice.readUnsignedByte()));\n\n                            int flags = moduleSlice.readUnsignedShort();\n                            position.setCourse(BitUtil.to(flags, 10));\n                            position.setValid(BitUtil.check(flags, 12));\n\n                            if (!BitUtil.check(flags, 10)) {\n                                latitude = -latitude;\n                            }\n                            if (BitUtil.check(flags, 11)) { // Protocol spec says bit 11 = 1 means East, 0 means West. East is positive.\n                                longitude = -longitude;\n                            }\n\n                            position.setLatitude(latitude);\n                            position.setLongitude(longitude);\n                        }\n                        break;\n                    case 0x34: // Event Report with Content\n                        if (moduleLength >= 5) { // Event(1) + Time(4) = 5 minimum before content length byte\n                            position.set(Position.KEY_EVENT, moduleSlice.readUnsignedByte());\n                            long eventTimeSeconds = moduleSlice.readUnsignedIntLE();\n                            // Check if content length byte exists\n                            if (moduleSlice.readableBytes() >= 1) {\n                                int contentLength = moduleSlice.readUnsignedByte();\n                                if (moduleSlice.readableBytes() >= contentLength) {\n                                    // Process or skip content\n                                    moduleSlice.skipBytes(contentLength);\n                                }\n                            }\n                        }\n                        break;\n                    default:\n                        break; // Ignore unknown modules (already skipped by readSlice)\n                }\n                 // Ensure the entire module slice was consumed if parsing logic didn't\n                 moduleSlice.skipBytes(moduleSlice.readableBytes());\n            }\n\n            if (position.getFixTime() == null) {\n                getLastLocation(position, null);\n            }\n\n            // Check for index/serial number before reading it\n            if (buf.readableBytes() >= 2) {\n                sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null);\n            }\n\n            return position;\n\n        } else if (type == MSG_MULTIMEDIA) { // 0x20\n\n            // Serial(8) + Timestamp(4) + GPS(12) + Cell(8) + MediaID(4) + MediaLength(4) + Type(1) + Format(1) = 42 bytes minimum before event/index\n            if (buf.readableBytes() < 42 + 1 + 2 + 6) { // Need headers + event(1) + index(2) + end(6)\n                 return null;\n            }\n            buf.skipBytes(8); // serial number\n            long timestamp = buf.readUnsignedInt() * 1000;\n            buf.skipBytes(12); // gps\n            buf.skipBytes(8); // cell\n\n            int mediaId = buf.readInt();\n            int mediaLength = buf.readInt();\n            int mediaType = buf.readUnsignedByte();\n            int mediaFormat = buf.readUnsignedByte();\n\n            Position positionForMedia = null; // Create position only if photo is complete\n\n            if (mediaType == 0 && mediaFormat == 0) { // Photo JPEG\n                buf.readUnsignedByte(); // event triggering photo\n                int packetIndex = buf.readUnsignedShort();\n                ByteBuf photo = photos.get(mediaId);\n\n                if (packetIndex == 0 && photo != null) {\n                    photos.remove(mediaId).release();\n                    photo = null;\n                }\n                if (photo == null && packetIndex == 0) {\n                    photo = Unpooled.buffer(mediaLength);\n                    photos.put(mediaId, photo);\n                }\n\n                if (photo != null) {\n                    if (buf.readableBytes() >= 6) { // Check enough bytes for data chunk + end(6)\n                        int photoChunkLength = buf.readableBytes() - 6;\n                        if (photoChunkLength > 0) {\n                            int readable = Math.min(photoChunkLength, photo.writableBytes());\n                            buf.readBytes(photo, readable);\n                            buf.skipBytes(photoChunkLength - readable); // Skip extra if any\n                        }\n\n                        if (!photo.isWritable()) {\n                            positionForMedia = new Position(getProtocolName());\n                            positionForMedia.setDeviceId(deviceSession.getDeviceId());\n                            getLastLocation(positionForMedia, new Date(timestamp));\n                            positionForMedia.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                            photos.remove(mediaId).release();\n                        }\n                    }\n                }\n            }\n\n            // Always send response? Check protocol spec. Assuming yes.\n            // Check for index before reading\n             if (buf.readableBytes() >= 2) {\n                 sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n             } else {\n                 // Cannot read index for response\n             }\n\n            return positionForMedia; // Return position only if photo is complete\n\n        } else if (type == MSG_SERIAL) { // 0x9B\n\n            getLastLocation(position, null);\n\n            // DevType(1) + Data(...) + LineBreak(1?) + End(6)\n            if (buf.readableBytes() < 1 + 6) {\n                return null; // Not enough data\n            }\n            buf.readUnsignedByte(); // external device type code\n            int dataLength = buf.readableBytes() - 6;\n\n            if (dataLength <= 0) {\n                 return null; // No data\n            }\n\n            // Assuming short messages are temperature, longer ones are RFID/iButton\n            if (dataLength < 8) { // Temperature? e.g., \"23.5\\n\"\n                // Read up to (but not including) the last byte if it might be newline\n                int readLen = dataLength > 1 ? dataLength - 1 : dataLength;\n                String tempStr = buf.readCharSequence(readLen, StandardCharsets.US_ASCII).toString().trim();\n                try {\n                    position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(tempStr));\n                } catch (NumberFormatException e) { /* ignore */ }\n                buf.skipBytes(dataLength - readLen); // Skip the last byte (newline?)\n            } else { // RFID/iButton? e.g., Type(1) + \"IDDDDDDD\\n\"\n                 if (dataLength >= 2) { // Need Type + ID + possible newline\n                     buf.readUnsignedByte(); // card type\n                     int readLen = dataLength - 2 > 0 ? dataLength - 2 : 0; // Length excluding type and possible newline\n                     if (readLen > 0) {\n                         String driverId = buf.readCharSequence(readLen, StandardCharsets.US_ASCII).toString().trim();\n                         position.set(Position.KEY_DRIVER_UNIQUE_ID, driverId);\n                     }\n                     buf.skipBytes(dataLength - 1 - readLen); // Skip potential newline\n                 } else {\n                     buf.skipBytes(dataLength); // Skip data if too short for ID format\n                 }\n            }\n\n            return position;\n\n        // ADDED HANDLERS for types seen in tests with 7979 header\n        } else if (type == 0x21) { // Server Message / Response text\n\n            getLastLocation(position, null);\n            // Serial(4) + Lang(1) + Message(...) + End(6)\n            if (buf.readableBytes() >= 4 + 1 + 6) {\n                buf.skipBytes(4); // Skip serial number\n                buf.skipBytes(1); // Skip language code\n                String message = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.UTF_16BE).toString();\n                position.set(Position.KEY_RESULT, message.trim());\n                sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n                return position;\n            }\n\n        } else if (type == 0x8C) { // OBD data string\n\n            getLastLocation(position, null);\n            // Serial/Flag(4) + Data(...) + End(6)\n            if (buf.readableBytes() >= 4 + 6) {\n                buf.readUnsignedInt(); // Serial number / server flag\n                String data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.US_ASCII);\n\n                for (String pair : data.split(\",\")) {\n                    String[] values = pair.split(\"=\");\n                    if (values.length >= 2) {\n                        try {\n                            switch (Integer.parseInt(values[0].substring(0, 2), 16)) {\n                                case 0x40:\n                                    position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x43:\n                                    position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x45:\n                                    position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x53:\n                                    position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x54:\n                                    position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x71:\n                                    position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x73:\n                                    position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01);\n                                    break;\n                                case 0x74:\n                                    position.set(Position.KEY_VIN, values[1]);\n                                    break;\n                                default:\n                                    break;\n                            }\n                        } catch (NumberFormatException | IndexOutOfBoundsException e) { /* ignore */ }\n                    }\n                }\n                sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n                return position;\n            }\n\n        } else if (type == MSG_ALARM) { // 0x94, Extended Alarm (LBS/WIFI based)\n\n            // Attempt to decode LBS/WIFI location data first\n            decodeLbs(position, buf, type, true); // hasLength=true for LBS in Alarm messages\n            if (position.getLatitude() == 0 && position.getLongitude() == 0) {\n                 decodeWifi(position, buf); // Try WIFI if LBS failed or not present\n            }\n\n            // Decode Status, Alarm, Language if present before end bytes\n            if (buf.readableBytes() >= 1 + 1 + 1 + 6) { // Status(1)+Alarm(1)+Lang(1)+End(6)\n                 int status = buf.readUnsignedByte();\n                 decodeStatus(position, status);\n                 position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));\n                 buf.readUnsignedByte(); // language\n            } else {\n                 // Not enough data for status/alarm, rely on LBS/WIFI time if available\n                 getLastLocation(position, position.getFixTime());\n            }\n\n            if (position.getFixTime() == null) {\n                 getLastLocation(position, null); // Fallback if no time found\n            }\n\n            // Check for index before sending response\n            if (buf.readableBytes() >= 2) {\n                 sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n            }\n            return position;\n        }\n\n        // If type is not handled by any block above, return null\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}