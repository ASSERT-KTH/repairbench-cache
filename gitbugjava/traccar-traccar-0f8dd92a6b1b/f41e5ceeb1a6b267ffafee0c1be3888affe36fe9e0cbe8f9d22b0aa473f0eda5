{
    "generation": "    private Object decodeExtended(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n            deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // FIX: Removed incorrect reading of 2 bytes. The extended format frame\n        // is handled by the main decode method, and decodeExtended receives the\n        // buffer starting from the actual message type.\n        // buf.readUnsignedShort(); // length\n\n        int type = buf.readUnsignedByte();\n\n        if (type == MSG_STRING_INFO) {\n\n            buf.readUnsignedInt(); // server flag\n            String data;\n            if (buf.readUnsignedByte() == 1) {\n                data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.US_ASCII);\n            } else {\n                data = buf.readSlice(buf.readableBytes() - 6).toString(StandardCharsets.UTF_16BE);\n            }\n\n            Parser parser = new Parser(PATTERN_LOCATION, data);\n\n            if (parser.matches()) {\n                position.setValid(true);\n                position.setLatitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setLongitude(parser.nextCoordinate(Parser.CoordinateFormat.HEM_DEG));\n                position.setCourse(parser.nextDouble());\n                position.setSpeed(parser.nextDouble());\n                position.setTime(parser.nextDateTime(Parser.DateTimeFormat.YMD_HMS));\n            } else {\n                getLastLocation(position, null);\n                position.set(Position.KEY_RESULT, data);\n            }\n\n            return position;\n\n        } else if (type == MSG_INFO) { // Note: Standard GT06 MSG_INFO is 0x13, this might handle a variant using 0x0A\n\n            int subType = buf.readUnsignedByte();\n\n            getLastLocation(position, null);\n\n            if (subType == 0x00) {\n\n                position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort() * 0.01);\n                return position;\n\n            } else if (subType == 0x05) {\n\n                if (buf.readableBytes() >= 6 + 1 + 6) { // Assuming original check is correct for this specific subtype structure + suffix\n                    DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                            .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                            .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                    position.setDeviceTime(dateBuilder.getDate());\n\n                    int flags = buf.readUnsignedByte();\n                    position.set(Position.KEY_DOOR, BitUtil.check(flags, 0));\n                    position.set(Position.PREFIX_IO + 1, BitUtil.check(flags, 2));\n                } else {\n                    // If not enough bytes, just skip decoding this part but still return the position\n                    // Or should we advance the buffer pointer past expected suffix? Current logic doesn't.\n                }\n                return position; // Return position even if decoding failed due to length\n\n            } else if (subType == 0x0a || subType == 0x03) { // FIX: Added handler for subType 0x03 which also carries ICCID\n\n                // Check buffer length before reading. Need 8 + 8 + 10 bytes minimum payload.\n                // Suffix length (index+checksum) is typically 4 or 6 bytes. Check required.\n                // Assuming the buffer passed has sufficient length based on frame length check done earlier.\n                if (buf.readableBytes() >= 8 + 8 + 10) { // Basic check for payload data\n                    buf.skipBytes(8); // imei\n                    buf.skipBytes(8); // imsi\n                    position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10)).replaceAll(\"(?i)f\", \"\")); // Use case-insensitive replace\n                } else {\n                     // Log warning or ignore if buffer too short\n                }\n                return position; // Return position even if ICCID couldn't be read\n\n            } else if (subType == 0x0d) {\n\n                if (buf.isReadable() && buf.getByte(buf.readerIndex()) != '!') {\n                    if (buf.readableBytes() >= 6) { // Check before skipping\n                       buf.skipBytes(6);\n                    } else {\n                        return position; // Not enough bytes to skip\n                    }\n                }\n\n                // Original calculation assumes a suffix of 4 (index+checksum) + 2 other bytes?\n                int lengthToParse = buf.readableBytes() - 4 - 2;\n                if (lengthToParse > 0) {\n                    Parser parser = new Parser(PATTERN_FUEL, buf.toString(\n                            buf.readerIndex(), lengthToParse, StandardCharsets.US_ASCII));\n                    if (parser.matches()) {\n                        position.set(Position.PREFIX_TEMP + 1, parser.nextDouble(0));\n                        position.set(Position.KEY_FUEL_LEVEL, parser.nextDouble(0));\n                    }\n                    // The original code returned position here without consuming buffer for parsed data or suffix.\n                    // This might be okay if the parser only peeks, but usually, buffer should be advanced.\n                    // Sticking to original return behavior.\n                    return position;\n                } else {\n                     return position; // Not enough data for parsing\n                }\n\n            } else if (subType == 0x1b) {\n\n                // Need careful length check depending on which sub-format is present + suffix\n                if (buf.readableBytes() > 6) { // Rough check based on original readableBytes - 6 calculation\n                    if (Character.isLetter(buf.getUnsignedByte(buf.readerIndex()))) {\n                        String data = buf.readCharSequence(buf.readableBytes() - 6, StandardCharsets.US_ASCII).toString();\n                        position.set(\"serial\", data.trim());\n                    } else {\n                         if (buf.readableBytes() >= 1 + 1 + 4 + 1 + 1 + 6) { // Check for second structure + assumed 6 byte suffix\n                             buf.readUnsignedByte(); // header\n                             buf.readUnsignedByte(); // type\n                             position.set(Position.KEY_DRIVER_UNIQUE_ID, ByteBufUtil.hexDump(buf.readSlice(4)));\n                             buf.readUnsignedByte(); // checksum\n                             buf.readUnsignedByte(); // footer\n                         }\n                    }\n                }\n                return position; // Return position regardless of which part was decoded\n\n            } else {\n                // Unknown subtype for this message type, return position with basic info\n                return position;\n            }\n\n        } else if (type == MSG_X1_PHOTO_DATA) {\n\n            if (buf.readableBytes() < 4 + 4 + 2) { // Check for header fields before reading\n                 getLastLocation(position, null);\n                 return position;\n            }\n\n            int pictureId = buf.readInt();\n            ByteBuf photo = photos.get(pictureId); // Assuming 'photos' map exists and is managed\n\n            buf.readUnsignedInt(); // offset\n            int dataLength = buf.readUnsignedShort();\n\n            // Assuming suffix is 6 bytes for this message type based on other reads like sendResponse\n            if (photo != null && buf.readableBytes() >= dataLength + 6) {\n                buf.readBytes(photo, dataLength);\n\n                if (photo.writableBytes() <= 0) { // Check if photo is complete\n                    position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                    photos.remove(pictureId).release();\n                    // Original code didn't explicitly return position here, but it makes sense to return it with the image.\n                    getLastLocation(position, null); // Add location context if possible\n                    return position;\n                }\n                // If photo is not complete, we don't return yet, just received a chunk.\n                // Need a mechanism to know when the *last* chunk is received if not based on writableBytes.\n            } else if (photo != null && buf.readableBytes() < dataLength + 6) {\n                 // Not enough data in buffer for expected chunk + suffix, potentially discard incomplete photo?\n                 photos.remove(pictureId).release();\n            }\n            // Fall through if photo is incomplete or processing failed.\n            // Should return null or a basic position? Let's return basic position.\n            getLastLocation(position, null);\n            return position;\n\n        } else if (type == MSG_AZ735_GPS || type == MSG_AZ735_ALARM) {\n\n            // Assume decodeGps/decodeLbs handle their own internal lengths and buffer checks\n            if (!decodeGps(position, buf, true, deviceSession.get(DeviceSession.KEY_TIMEZONE))) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n\n            // Check before reading LBS data\n            // The decodeLbs function itself should perform checks\n            if (decodeLbs(position, buf, type, true)) {\n                 if (buf.readableBytes() >= 1 + 6) { // Check for RSSI + assumed 6 byte suffix\n                    position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                 } else { return position; }\n            }\n\n            // Variable length skips need checks before reading length and before skipping\n            if (buf.readableBytes() < 1 + 6) return position;\n            int additionalCellLen = buf.readUnsignedByte();\n            if (buf.readableBytes() < additionalCellLen + 6) return position;\n            buf.skipBytes(additionalCellLen); // additional cell towers\n\n            if (buf.readableBytes() < 1 + 6) return position;\n            int wifiLen = buf.readUnsignedByte();\n            if (buf.readableBytes() < wifiLen + 6) return position;\n            buf.skipBytes(wifiLen); // wifi access point\n\n            if (buf.readableBytes() < 1 + 6) return position;\n            int status = buf.readUnsignedByte();\n            position.set(Position.KEY_STATUS, status);\n\n            if (type == MSG_AZ735_ALARM) {\n                switch (status) {\n                    case 0xA0: position.set(Position.KEY_ARMED, true); break;\n                    case 0xA1: position.set(Position.KEY_ARMED, false); break;\n                    case 0xA2: case 0xA3: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                    case 0xA4: position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                    case 0xA5: position.set(Position.KEY_ALARM, Position.ALARM_DOOR); break;\n                    default: break;\n                }\n            }\n\n            if (buf.readableBytes() < 1 + 6) return position;\n            int reservedLen = buf.readUnsignedByte();\n            if (buf.readableBytes() < reservedLen + 6) return position;\n            buf.skipBytes(reservedLen); // reserved extension\n\n            // sendResponse is likely handled elsewhere or after decode returns\n            // sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null);\n\n            return position;\n\n        } else if (type == MSG_OBD) {\n\n             // Assuming suffix is 18 bytes as per original calculation? Seems large. Let's assume 6 bytes.\n             if (buf.readableBytes() < 6 + 1 + 6) return position; // time + ignition + suffix\n\n            DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                    .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                    .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n\n            getLastLocation(position, dateBuilder.getDate());\n\n            position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n\n            int dataLen = buf.readableBytes() - 6; // Assuming 6 byte suffix\n            if (dataLen > 0) {\n                String data = buf.readCharSequence(dataLen, StandardCharsets.US_ASCII).toString();\n                for (String pair : data.split(\",\")) {\n                    String[] values = pair.split(\"=\");\n                    if (values.length >= 2) {\n                        try {\n                             String pidHex = values[0].length() >= 2 ? values[0].substring(0, 2) : \"\";\n                            switch (Integer.parseInt(pidHex, 16)) {\n                                case 40: position.set(Position.KEY_ODOMETER, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 43: position.set(Position.KEY_FUEL_LEVEL, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 45: position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 53: position.set(Position.KEY_OBD_SPEED, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 54: position.set(Position.KEY_RPM, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 71: position.set(Position.KEY_FUEL_USED, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 73: position.set(Position.KEY_HOURS, Integer.parseInt(values[1], 16) * 0.01); break;\n                                case 74: position.set(Position.KEY_VIN, values[1]); break;\n                                default: break;\n                            }\n                        } catch (NumberFormatException e) { /* ignore */ }\n                    }\n                }\n            }\n\n            return position;\n\n        } else if (type == MSG_GPS_MODULAR) {\n\n            // Assuming 6 bytes suffix (index+checksum) based on sendResponse usage below\n            while (buf.readableBytes() > 6) {\n                 if (buf.readableBytes() < 4 + 6) break; // module header + suffix\n\n                int moduleType = buf.readUnsignedShort();\n                int moduleLength = buf.readUnsignedShort();\n\n                if (buf.readableBytes() < moduleLength + 6) break; // Check module data + suffix\n\n                int startIndex = buf.readerIndex(); // Save index to skip if needed\n\n                switch (moduleType) {\n                    case 0x03: if (moduleLength == 10) position.set(Position.KEY_ICCID, ByteBufUtil.hexDump(buf.readSlice(10))); break;\n                    case 0x09: if (moduleLength == 1) position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); break;\n                    case 0x0a: if (moduleLength == 1) position.set(Position.KEY_SATELLITES_VISIBLE, buf.readUnsignedByte()); break;\n                    case 0x11:\n                        if (moduleLength == 10) {\n                            CellTower cellTower = CellTower.from(buf.readUnsignedShort(), buf.readUnsignedShort(), buf.readUnsignedShort(), buf.readUnsignedMedium(), buf.readUnsignedByte());\n                            if (cellTower != null && cellTower.getCellId() > 0 && cellTower.getMobileCountryCode() != null) position.setNetwork(new Network(cellTower));\n                        }\n                        break;\n                    case 0x18: if (moduleLength == 2) position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01); break;\n                    case 0x28: if (moduleLength == 1) position.set(Position.KEY_HDOP, buf.readUnsignedByte() * 0.1); break;\n                    case 0x29: if (moduleLength == 4) position.set(Position.KEY_INDEX, buf.readUnsignedInt()); break;\n                    case 0x2a:\n                        if (moduleLength == 1) {\n                            int input = buf.readUnsignedByte();\n                            position.set(Position.KEY_DOOR, BitUtil.to(input, 4) > 0);\n                            position.set(\"tamper\", BitUtil.from(input, 4) > 0);\n                        }\n                        break;\n                    case 0x2b:\n                        if (moduleLength == 1) {\n                            int event = buf.readUnsignedByte();\n                            switch (event) {\n                                case 0x11: position.set(Position.KEY_ALARM, Position.ALARM_LOW_BATTERY); break;\n                                case 0x12: position.set(Position.KEY_ALARM, Position.ALARM_LOW_POWER); break;\n                                case 0x13: position.set(Position.KEY_ALARM, Position.ALARM_POWER_CUT); break;\n                                case 0x14: position.set(Position.KEY_ALARM, Position.ALARM_REMOVING); break;\n                                default: break;\n                            }\n                            position.set(Position.KEY_EVENT, event);\n                        }\n                        break;\n                    case 0x2e: if (moduleLength == 4) position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE()); break;\n                    case 0x33:\n                         if (moduleLength == 18) {\n                             position.setTime(new Date(buf.readUnsignedInt() * 1000));\n                             position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                             position.setAltitude(buf.readShort());\n                             double latitude = buf.readUnsignedInt() / 60.0 / 30000.0;\n                             double longitude = buf.readUnsignedInt() / 60.0 / 30000.0;\n                             position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                             int flags = buf.readUnsignedShort();\n                             position.setCourse(BitUtil.to(flags, 10));\n                             position.setValid(BitUtil.check(flags, 12));\n                             if (!BitUtil.check(flags, 10)) latitude = -latitude;\n                             if (BitUtil.check(flags, 11)) longitude = -longitude;\n                             position.setLatitude(latitude);\n                             position.setLongitude(longitude);\n                         }\n                         break;\n                    case 0x34:\n                         if (moduleLength >= 1 + 4 + 1) {\n                             int event = buf.readUnsignedByte();\n                             long time = buf.readUnsignedIntLE(); // unused?\n                             int contentLength = buf.readUnsignedByte();\n                             if (moduleLength == 1 + 4 + 1 + contentLength && buf.readableBytes() >= contentLength + 6) {\n                                 position.set(Position.KEY_EVENT, event);\n                                 // Read or skip content? Original skipped.\n                                 buf.skipBytes(contentLength);\n                             } else {\n                                 buf.readerIndex(startIndex); // Reset index if length mismatch\n                             }\n                         }\n                         break;\n                     default: break; // Unknown module type handled below by skipping\n                 }\n\n                // Skip remaining bytes in module if not fully read or unknown type\n                if (buf.readerIndex() < startIndex + moduleLength) {\n                    buf.readerIndex(startIndex + moduleLength);\n                }\n            }\n\n            if (position.getFixTime() == null) {\n                getLastLocation(position, null);\n            }\n\n            // sendResponse(channel, false, MSG_GPS_MODULAR, buf.readUnsignedShort(), null); // Handle separately\n\n            return position;\n\n        } else if (type == MSG_MULTIMEDIA) {\n\n             // Assuming 6 byte suffix\n             if (buf.readableBytes() < 8 + 4 + 15 + 4 + 4 + 1 + 1 + 6) return position;\n\n            buf.skipBytes(8); // serial number\n            long timestamp = buf.readUnsignedInt() * 1000;\n            buf.skipBytes(4 + 4 + 2 + 1 + 1 + 2); // gps\n            buf.skipBytes(2 + 2 + 2 + 2); // cell\n\n            int mediaId = buf.readInt();\n            int mediaLength = buf.readInt();\n            int mediaType = buf.readUnsignedByte();\n            int mediaFormat = buf.readUnsignedByte();\n\n            if (mediaType == 0 && mediaFormat == 0) { // JPEG Photo\n\n                 if (buf.readableBytes() < 1 + 2 + 6) return position; // event + offset + suffix\n\n                buf.readUnsignedByte(); // event\n\n                ByteBuf photo;\n                int offset = buf.readUnsignedShort();\n                if (offset == 0) {\n                    photo = Unpooled.buffer(mediaLength);\n                    if (photos.containsKey(mediaId)) photos.remove(mediaId).release();\n                    photos.put(mediaId, photo);\n                } else {\n                    photo = photos.get(mediaId);\n                }\n\n                if (photo != null) {\n                    int dataLen = buf.readableBytes() - 6; // Data before suffix\n                    if (dataLen > 0) {\n                        buf.readBytes(photo, Math.min(dataLen, photo.writableBytes())); // Read only what fits or is available\n                    }\n                    if (!photo.isWritable()) { // Check if complete\n                        position = new Position(getProtocolName()); // Create new position for image message\n                        position.setDeviceId(deviceSession.getDeviceId());\n                        getLastLocation(position, new Date(timestamp));\n                        position.set(Position.KEY_IMAGE, writeMediaFile(deviceSession.getUniqueId(), photo, \"jpg\"));\n                        photos.remove(mediaId).release();\n                        // sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); // Send response on completion\n                        return position;\n                    }\n                }\n            }\n\n            // sendResponse(channel, true, type, buf.getShort(buf.writerIndex() - 6), null); // Send response always?\n\n            // Return basic position if not a photo or photo incomplete\n            getLastLocation(position, new Date(timestamp));\n            return position;\n\n        } else if (type == MSG_SERIAL) {\n\n            position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n\n            // Assuming 9 byte suffix based on original calculation\n            if (buf.readableBytes() < 1 + 9) return position;\n\n            buf.readUnsignedByte(); // external device type code\n            int length = buf.readableBytes() - 9;\n\n            if (length <= 0) {\n                return position;\n            }\n\n            try {\n                if (length < 8) { // Assume Temperature\n                     if (length - 1 >= 0) { // Check before reading char sequence\n                        position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString()));\n                     }\n                } else { // Assume iButton/RFID\n                    if (length - 1 >= 0) { // Check before reading char sequence\n                        buf.readUnsignedByte(); // card type\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, buf.readCharSequence(length - 1, StandardCharsets.US_ASCII).toString());\n                    }\n                }\n            } catch (RuntimeException e) { /* ignore parsing errors */ }\n\n            return position;\n\n        }\n\n        // If type was not handled by any block, return null\n        // Or return the basic position object? Tests expect null sometimes.\n        // Let's stick to returning null if type is unknown.\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}