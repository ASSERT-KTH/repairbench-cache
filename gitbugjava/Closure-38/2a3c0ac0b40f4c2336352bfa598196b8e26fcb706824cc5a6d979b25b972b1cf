{
    "generation": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    // Add a space after '-' if the number is negative or negative zero.\n    // This prevents misparsing of sequences like \"x - -0.0\" or \"x - -4\".\n    if ((x < 0 || negativeZero) && prev == '-') {\n      add(\" \");\n    }\n\n    // Use the long representation if it's integer and not negative zero.\n    // Negative zero must be represented as -0.0.\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      // Use exponential notation for large integers. Avoid calculations if\n      // the number is definitely too small for exponential notation.\n      // Note: Math.abs(Long.MIN_VALUE) == Long.MIN_VALUE, which is negative.\n      // So use >= 100 rather than Math.abs(value) >= 100\n      if (value <= -100 || value >= 100) {\n          // Check if we should use exponential notation, e.g. 1E10.\n          // Note: we cannot use Math.log10 since it will lose precision.\n          // Make sure that we do not use exponent notation if the value is\n          // precisely representable as a long, otherwise things like\n          // 100000000000000000000 will be represented as 1E20, which can\n          // lose precision and result in things like 1E20 + 1 != 1E20.\n          while (mantissa % 10 == 0 && mantissa != 0) {\n            // This check is needed because long division can have rounding errors for large values.\n            // For example, 9007199254740992 / 10 * Math.pow(10, 1) should be 9007199254740992 but\n            // double precision math can make it 9007199254740990.\n            // We only use the exponential notation if the calculation is precise.\n            if (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n                mantissa /= 10;\n                exp++;\n            } else {\n                break;\n            }\n          }\n      }\n\n      // Use exponential notation if the exponent is large enough.\n      // Guarantees that we cannot generate non-representable long values.\n      // Example: 1E18 is representable as a long, but 1E19 is not.\n      // The exponent must be <= 18.\n      // We also make sure that we are not introducing precision problems\n      // by requiring that the exponent is at least 3.\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      // Otherwise, rely on the JDK's conversion algorithm.\n      add(String.valueOf(x));\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}