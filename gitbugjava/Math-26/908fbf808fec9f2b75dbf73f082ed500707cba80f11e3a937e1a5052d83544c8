{
    "generation": "import org.apache.commons.math3.util.FastMath;\nimport java.math.BigInteger; // Import BigInteger\n\n// Fraction class and other methods are assumed to be present\n\n    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge or overflowed.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        // Use Integer.MAX_VALUE as the overflow limit since numerator/denominator are int\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n\n        // Handle potential overflow of the integer part early\n        // Use FastMath.abs(a0) because a0 can be negative. Check against Integer limits.\n        if (FastMath.abs(a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // Check for (almost) integer arguments, which should not go to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            // The check above ensures a0 fits within Integer bounds if it passes\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0; // Convergent numerator\n        long q2 = 1; // Convergent denominator, initialized to 1\n\n        int n = 0;\n        boolean stop = false;\n        double convergent = Double.NaN; // Stores the double value of p2/q2\n\n        do {\n            ++n;\n            // Calculate the next term in the continued fraction\n            double r1 = 1.0 / (r0 - a0);\n            // Check for potential division by zero or infinite result\n            if (Double.isInfinite(r1)) {\n                 // This typically happens when r0 is very close to a0 (the integer part).\n                 // The initial check `FastMath.abs(a0 - value) < epsilon` should handle cases\n                 // where the value is truly close to an integer within the allowed epsilon.\n                 // If reached here, it might be due to floating-point precision limits suggesting\n                 // the previous convergent p1/q1 is the best representation.\n                 stop = true;\n                 // Set p2/q2 to the last valid state (p1/q1) to ensure the final logic uses it.\n                 p2 = p1;\n                 q2 = q1;\n                 // The loop will terminate, and the final assignment logic will handle selection.\n                 break;\n            }\n\n            long a1 = (long)FastMath.floor(r1);\n\n            // Check for theoretical inconsistency: a1 should be non-negative.\n            // In standard continued fractions for positive numbers, a_i >= 1 for i >= 1.\n            // For negative numbers or due to FP issues, a1 might be 0 or negative.\n            // A negative a1 indicates a breakdown in the algorithm's expected behavior.\n            if (a1 < 0L) {\n                 // Throw an exception as the process is not converging correctly.\n                 throw new FractionConversionException(\"Continued fraction convergents failed to converge (negative quotient).\", value, p1, q1);\n            }\n\n            // Safely calculate the next convergent numerator p2 = a1 * p1 + p0\n            // and denominator q2 = a1 * q1 + q0 using BigInteger. This avoids potential\n            // long overflow during the multiplication (a1 * p1 or a1 * q1) and allows\n            // accurate checking against Integer.MAX_VALUE / Integer.MIN_VALUE limits.\n            BigInteger bigA1 = BigInteger.valueOf(a1);\n            BigInteger bigP0 = BigInteger.valueOf(p0);\n            BigInteger bigP1 = BigInteger.valueOf(p1);\n            BigInteger bigQ0 = BigInteger.valueOf(q0);\n            BigInteger bigQ1 = BigInteger.valueOf(q1);\n\n            // Calculate potential p2 and q2 using BigInteger\n            BigInteger bigP2 = bigA1.multiply(bigP1).add(bigP0);\n            BigInteger bigQ2 = bigA1.multiply(bigQ1).add(bigQ0);\n\n            // Check if the calculated numerator or denominator exceeds the limits of an Integer.\n            // Denominator (q2) must be positive and <= Integer.MAX_VALUE.\n            // Numerator (p2) must be within [Integer.MIN_VALUE, Integer.MAX_VALUE].\n            if (bigP2.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0 ||\n                bigP2.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) < 0 ||\n                bigQ2.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0) {\n\n                // If overflow is detected, throw FractionConversionException.\n                // Report the potentially overflowing values (p2, q2) in the exception.\n                // Clip the reported values to the Long range as the exception constructor expects longs.\n                long reportP2 = bigP2.max(BigInteger.valueOf(Long.MIN_VALUE))\n                                     .min(BigInteger.valueOf(Long.MAX_VALUE))\n                                     .longValue();\n                // Ensure reported q2 is positive and clipped to Long range.\n                long reportQ2 = bigQ2.max(BigInteger.ZERO) // Should be positive anyway\n                                     .min(BigInteger.valueOf(Long.MAX_VALUE))\n                                     .longValue();\n\n                throw new FractionConversionException(value, reportP2, reportQ2);\n            }\n\n            // If the checks pass, the calculated values fit within Integer limits.\n            // Convert them back to long for use in the algorithm.\n            p2 = bigP2.longValue();\n            q2 = bigQ2.longValue();\n\n            // Sanity check: denominator should always be positive.\n            if (q2 <= 0) {\n                 // This should not happen if the algorithm proceeds correctly.\n                 throw new FractionConversionException(\"Continued fraction algorithm failed (non-positive denominator).\", value, p2, q2);\n            }\n\n            // Calculate the double value of the current convergent p2/q2 for error checking.\n            convergent = (double)p2 / (double)q2;\n\n            // Check the stopping conditions based on the original logic:\n            // - Max iterations reached? (n < maxIterations)\n            // - Error within epsilon? (FastMath.abs(convergent - value) > epsilon)\n            // - Denominator within limit? (q2 < maxDenominator)\n            // If all these conditions for *continuing* are true, proceed. Otherwise, stop.\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                // Conditions met to continue the loop: update variables for the next iteration.\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1; // a0 is reused to store the next integer part a_i\n                r0 = r1; // r0 is reused to store the next remainder r_i\n            } else {\n                // One of the stopping conditions is met, terminate the loop.\n                stop = true;\n            }\n        } while (!stop);\n\n        // After the loop terminates:\n\n        // Check if termination was due to reaching the maximum number of iterations.\n        if (n >= maxIterations) {\n            // If maxIterations was reached, it implies that the convergence criteria\n            // (epsilon accuracy or max denominator) were not met within the iteration limit.\n            // Throw an exception indicating failure to converge sufficiently quickly.\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        // Determine the final fraction to represent the value.\n        // The loop terminates if:\n        // 1. Epsilon is met: |p2/q2 - value| <= epsilon\n        // 2. Denominator limit is reached: q2 >= maxDenominator\n        // 3. Max iterations is reached (handled above).\n        // 4. Floating point issue (handled by break).\n        //\n        // Use the previous convergent (p1/q1) if the current denominator (q2)\n        // exceeds the maximum allowed denominator. Otherwise, use the last\n        // computed convergent (p2/q2).\n        if (q2 < maxDenominator) {\n             // If q2 is within the limit, use the last calculated convergent p2/q2.\n             // This case covers convergence by epsilon or hitting FP limits before maxDenominator.\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            // If q2 reached or exceeded maxDenominator, the loop stopped.\n            // Use the previous convergent p1/q1, as its denominator q1 was < maxDenominator.\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}