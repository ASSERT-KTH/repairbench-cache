{
    "generation": "    /*\n     * (non-Javadoc)\n     *\n     * @see java.io.InputStream#read(byte[], int, int)\n     */\n    @Override\n    public int read(final byte[] dest, final int offs, final int len)\n        throws IOException {\n        if (offs < 0) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n        }\n        if (len < 0) {\n            throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n        }\n        if (offs + len > dest.length) {\n            throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n                                                + len + \") > dest.length(\" + dest.length + \").\");\n        }\n        // According to the InputStream contract, reading 0 bytes should return 0.\n        if (len == 0) {\n            return 0;\n        }\n        if (this.in == null) {\n            throw new IOException(\"stream closed\");\n        }\n\n        final int hi = offs + len;\n        int destOffs = offs;\n        int b = read0(); // Read the first byte\n        if (b < 0) {\n            // If the first read attempt returns EOF (-1), return -1.\n            return -1;\n        }\n\n        // If the first byte was read successfully, store it.\n        dest[destOffs++] = (byte) b;\n        count(1);\n\n        // Continue reading bytes until the buffer is full (destOffs == hi)\n        // or the end of the stream is reached (read0() returns < 0).\n        while (destOffs < hi) {\n            b = read0();\n            if (b < 0) {\n                break; // EOF reached\n            }\n            dest[destOffs++] = (byte) b;\n            count(1);\n        }\n\n        // Return the total number of bytes read in this call.\n        return destOffs - offs;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}