{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * <p>This method allows fields that are not NUL terminated but are exhausted\n     * by the octal digits. For example \"77777777777\" is accepted, although ideally\n     * it should have been terminated by NUL or space.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the buffer contains invalid characters or does not conform to the expected format.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     pos = offset; // Current position\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        // Check for all NULs first (per documentation)\n        // Allows for parsing missing fields.\n        boolean allNUL = true;\n        // Check from offset to end-1 (inclusive) as end points *after* the last char\n        for (int i = pos; i < end; i++) {\n             // Check bounds for safety, although end should be correct based on length\n             if (i >= buffer.length) {\n                  throw new IllegalArgumentException(\"Trying to parse past buffer boundary at offset \" + i);\n             }\n            if (buffer[i] != 0) {\n                allNUL = false;\n                break;\n            }\n        }\n        if (allNUL) {\n            return 0L;\n        }\n\n        // Check for leading NUL (per documentation/workaround for some implementations)\n        // This needs to be checked after the all-NUL case.\n        if (buffer[pos] == 0) {\n             return 0L;\n        }\n\n        // Skip leading spaces\n        while (pos < end && buffer[pos] == ' ') {\n            pos++;\n        }\n\n        // At this point, 'pos' is the index of the first non-space character,\n        // or 'end' if the buffer only contained spaces (or was empty after offset).\n\n        // Parse octal digits until a non-octal character (space, NUL, or invalid) or end is reached.\n        while (pos < end) {\n            final byte currentByte = buffer[pos];\n\n            // Check for NUL or space terminator characters. These end the octal number.\n            if (currentByte == 0 || currentByte == ' ') {\n                break; // Found a standard terminator\n            }\n\n            // CheckStyle:MagicNumber OFF\n            // Ensure it's a valid octal digit ('0' - '7')\n            if (currentByte < '0' || currentByte > '7') {\n                // If it's not a digit and not a permitted terminator (space/NUL), it's invalid.\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, pos, currentByte));\n            }\n            // CheckStyle:MagicNumber ON\n\n            // Accumulate the octal value.\n            result = (result << 3) + (currentByte - '0'); // Convert ASCII digit to numeric value\n            pos++;\n        }\n\n        // After the loop, 'pos' points to the first terminator (space/NUL) found,\n        // or it points to 'end' if the octal digits filled the buffer up to the length limit.\n\n        // Validate the remainder of the buffer (from 'pos' to 'end')\n        // According to POSIX standard, the tail should only contain NUL or space.\n        while (pos < end) {\n             final byte currentByte = buffer[pos];\n             // Allow only NUL ('\\0') and space (' ') in the tail portion.\n             if (currentByte != 0 && currentByte != ' ') {\n                 throw new IllegalArgumentException(\n                         exceptionMessage(buffer, offset, length, pos, currentByte));\n             }\n             pos++;\n        }\n\n        return result;\n    }\n\n    // Helper method assumed to exist elsewhere in the class.\n    private static String exceptionMessage(byte[] buffer, int offset, int length, int currentOffset, byte currentByte) {\n        String content = \"Invalid byte content (cannot decode)\";\n        try {\n            // Attempt to decode the relevant part of the buffer for the error message\n            // Use a known safe encoding like US-ASCII for TAR headers\n            String raw = new String(buffer, offset, Math.min(length, buffer.length - offset), \"US-ASCII\");\n            // Replace NUL characters with a visible representation for clarity\n            content = raw.replace((char)0, '\\u2400'); // Unicode Symbol for NUL\n        } catch (Exception e) {\n            // Ignore if decoding fails, use fallback message\n        }\n        return \"Invalid byte \" + currentByte + \" at offset \" + (currentOffset - offset) + \" in '\" + content + \"' len=\" + length;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}