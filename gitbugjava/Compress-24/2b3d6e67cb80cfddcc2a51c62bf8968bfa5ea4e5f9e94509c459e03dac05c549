{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer is potentially terminated by a NUL or space byte,\n     * possibly followed by another NUL or space byte. These terminators\n     * are ignored.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * <p>This method allows extensions of the POSIX standard definition\n     * of numbers in tar archives which may be created by other tools.\n     * Specifically, this method allows fields that are not terminated\n     * by NUL or space, such as the size field in GNU tar archives, as long\n     * as the field contents are otherwise valid octal digits.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the length is less than 2, or if any\n     *         non-octal digit character is encountered after skipping leading spaces\n     *         and ignoring trailing NUL/space terminators.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        // Handle cases of leading NUL (potentially signifying empty field).\n        // This also handles an all-NUL buffer.\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim trailing NULs and spaces.\n        // This loop allows for fields ending in digits (GNU tar).\n        // It stops trimming when a non-terminator character is found,\n        // or when start == end.\n        // Use a temporary variable to avoid modifying 'end' used in the exception message context\n        int effectiveEnd = end;\n        while (start < effectiveEnd) {\n            final byte currentByte = buffer[effectiveEnd - 1];\n            if (currentByte == 0 || currentByte == ' ') {\n                effectiveEnd--;\n            } else {\n                // Found a non-terminator (digit or invalid character).\n                // Stop trimming; the next loop will validate it.\n                break;\n            }\n        }\n\n        // If, after skipping leading spaces and trimming trailing NUL/space,\n        // nothing is left (e.g., \"  \\0\"), the loop below won't run and we'll return 0.\n        // This is the correct behavior.\n\n        for ( ;start < effectiveEnd; start++) {\n            final byte currentByte = buffer[start];\n\n            // CheckStyle:MagicNumber OFF\n            // Ensure the current byte is an octal digit.\n            if (currentByte < '0' || currentByte > '7'){\n                 // Assuming exceptionMessage helper exists and uses original length/offset\n                 // Pass original 'end' or 'length' if needed by exceptionMessage\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n\n            // Shift current result left by 3 bits (multiply by 8)\n            // and add the value of the current digit.\n            result = (result << 3) + (currentByte - '0');\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n\n    // Helper method assumed to exist based on original code's usage.\n    // Its implementation might need adjustment depending on the actual codebase.\n    private static String exceptionMessage(byte[] buffer, int offset, int length, int idx, byte currentByte) {\n        String s;\n        try {\n            // Decode using UTF-8, which is compatible with ASCII and handles Unicode better\n            // if the buffer somehow contained non-ASCII bytes (though unlikely for octal).\n            s = new String(buffer, offset, length, java.nio.charset.StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            // Fallback to platform default if UTF-8 fails (e.g., invalid sequence)\n             s = new String(buffer, offset, length); // Note: platform default might not be ASCII\n        }\n        // Calculate index relative to the start of the segment being parsed (offset)\n        int relativeOffset = idx - offset;\n        return \"Invalid byte \" + currentByte + \" ('\" + (char)currentByte + \"') at offset \" + relativeOffset +\n                \" in '\" + s + \"' len=\" + length;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}