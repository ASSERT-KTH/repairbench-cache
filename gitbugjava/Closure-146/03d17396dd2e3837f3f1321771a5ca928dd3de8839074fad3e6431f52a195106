{
    "generation": "  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      // Note: JSType defines a 'registry' field.\n      // If 'that' is a union, delegate to its implementation and swap the results.\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        // If 'this' and 'that' are definitely equal for any values they represent\n        // (e.g., number == number, undefined == undefined), then the condition 'this != that'\n        // represents a contradiction. The only types that satisfy this\n        // contradiction are the bottom type (NO_TYPE).\n        // The caller (SemanticReverseAbstractInterpreter) expects NO_TYPE here\n        // to signify that this code path is unreachable.\n        JSType noType = registry.getNativeType(JSTypeNative.NO_TYPE);\n        return new TypePair(noType, noType);\n\n      case FALSE:\n        // If 'this' and 'that' are definitely not equal (e.g., string == number),\n        // then the condition 'this != that' is always true (assuming non-null/undefined).\n        // This inequality provides no new information beyond the initial types.\n        // Returning the original types signifies no restriction.\n        return new TypePair(this, that);\n\n      case UNKNOWN:\n        // If 'this' and 'that' might be equal or might not be equal\n        // (e.g., (number|string) == number), then the condition 'this != that'\n        // rules out the possibility that they are equal and have the same value\n        // (considering JS coercion rules for !=).\n        // The current implementation returns the original types, signifying\n        // that this base method does not infer further restrictions in the UNKNOWN case.\n        // More specific subtypes (like UnionType) or the caller might handle\n        // refinement for UNKNOWN.\n        return new TypePair(this, that);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}