{
    "generation": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            // Node name tests only apply to elements\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI(); // Expected namespace URI from the XPath expression context\n            boolean wildcard = nodeNameTest.isWildcard(); // True if the test's local name is \"*\"\n            String testPrefix = testName.getPrefix(); // The prefix used in the XPath expression for this test\n\n            // Case 1: Test is \"*\" (wildcard local name, null prefix) - matches any element\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            // Case 2: Test involves specific local name or namespace wildcard\n            // Check if the test's local name is a wildcard (\"prefix:*\") OR if the test's local name matches the node's local name.\n            if (wildcard // True if test is \"prefix:*\"\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) // Compare local names if test is \"prefix:name\" or \"name\"\n            {\n                // If local names match, or if the test is \"prefix:*\", then check the namespace URIs.\n                String nodeNS = DOMNodePointer.getNamespaceURI(node); // Get the actual namespace URI of the DOM node\n                // Compare the expected namespace URI (resolved from the XPath context) with the actual namespace URI of the node.\n                // Assumes equalStrings handles null/empty strings appropriately according to namespace rules.\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            // Local name did not match (and test was not \"prefix:*\")\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    // JXPath's interpretation of 'node()' test seems to be element or document.\n                    // Standard XPath 'node()' matches Element, Text, Comment, PI on applicable axes.\n                    // Keep original logic.\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    // XPath 'text()' test matches Text and CDATA nodes.\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    // XPath 'comment()' test matches Comment nodes.\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    // XPath 'processing-instruction()' test matches PI nodes.\n                    // This specific test only checks the type, not the target name.\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            // Unrecognized node type constant in the NodeTypeTest\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            // XPath 'processing-instruction('target')' test.\n            // Check if node is a PI.\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                // Check if the PI target names match.\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI); // Original uses String.equals\n            }\n            // Node is not a PI.\n            return false;\n        }\n        // Unhandled test type, or node failed specific checks for handled types.\n        return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}