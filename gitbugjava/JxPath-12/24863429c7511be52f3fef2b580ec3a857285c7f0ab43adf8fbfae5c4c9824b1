{
    "generation": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String testLocalName = testName.getName();\n            String testPrefix = testName.getPrefix();\n            // nodeNameTest.isWildcard() means the local name part is \"*\"\n            boolean wildcardName = nodeNameTest.isWildcard();\n            // This is the namespace URI associated with the test prefix (or null) resolved by JXPath\n            String testNamespaceURI = nodeNameTest.getNamespaceURI();\n\n            String nodeLocalName = DOMNodePointer.getLocalName(node);\n\n            // 1. Check local name match\n            // If the test's local name is not a wildcard, it must match the node's local name.\n            if (!wildcardName && !testLocalName.equals(nodeLocalName)) {\n                return false;\n            }\n\n            // Local name matches (or is wildcard). Now check namespace.\n\n            // 2. Check namespace constraints based on the test type\n\n            // Test '*:name' (wildcard prefix, specific name): Namespace doesn't matter.\n            // JXPath Compiler represents this with prefix==\"*\" and namespaceURI==null.\n            if (testPrefix != null && testPrefix.equals(\"*\")) {\n                // Local name was already checked above. Namespace is wildcarded.\n                return true;\n            }\n\n            // Test '*' (wildcard name, null prefix): Namespace doesn't matter.\n            if (wildcardName && testPrefix == null) {\n                // Name part is wildcard, prefix is null. Matches elements in any/no namespace.\n                return true;\n            }\n\n            // Test 'prefix:name', 'name' (default ns or no ns), 'prefix:*'\n            // For these tests, the namespace URIs must match.\n            // Note: For 'prefix:*', wildcardName is true, but testPrefix is not null and not \"*\".\n            //       For 'name', testPrefix is null, wildcardName is false.\n            //       For 'prefix:name', testPrefix is not null/ \"*\", wildcardName is false.\n            // The logic correctly falls through to compare namespaces for all these cases.\n            String nodeNamespaceURI = DOMNodePointer.getNamespaceURI(node);\n            // Use the helper that handles nulls correctly.\n            return equalStrings(testNamespaceURI, nodeNamespaceURI);\n\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    // Although XPath 'node()' matches any node type, the original code\n                    // specifically checked for Element or Document. Retaining original behavior.\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    // This test checks for any PI node. Specific target matching\n                    // is handled by ProcessingInstructionTest.\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false; // Should not be reached with valid NodeTypeTest types\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                // Comparison must be exact match.\n                return testPI.equals(nodePI);\n            }\n            // Node is not a Processing Instruction, so it cannot match this test.\n            return false;\n        }\n        // Test type not recognized or node doesn't match test constraints.\n        return false;\n    }\n\n    // Assume this helper function exists and correctly compares strings, handling nulls.\n    // It's defined in DOMNodePointer in the original codebase.\n    // private static boolean equalStrings(String s1, String s2) { ... }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}