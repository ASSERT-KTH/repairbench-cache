{
    "generation": "import org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.CDATASection;\nimport org.w3c.dom.Comment;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.ProcessingInstruction;\nimport org.w3c.dom.Text;\n\n// Note: Imports added for context, they might differ slightly in the original file.\n// Also assuming 'equalStrings' is accessible, e.g., as a static method in the same class or a utility class.\n\npublic static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        // A NodeNameTest tests for elements by name\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String testLocalName = testName.getName();\n        String testPrefix = testName.getPrefix();\n        // testNamespaceURI is the namespace URI the prefix is bound to in the XPath expression context,\n        // or null if the test is for an unprefixed name.\n        String testNamespaceURI = nodeNameTest.getNamespaceURI();\n        boolean isWildcardTest = nodeNameTest.isWildcard(); // True if the local name part of the test is '*'\n\n        // Handle the '*' test (matches any element)\n        if (isWildcardTest && testPrefix == null) {\n            return true;\n        }\n\n        // Determine the node's local name. Use node.getLocalName() if available (DOM Level 2+).\n        // Fall back to parsing node.getNodeName() for potentially older DOM levels or nodes\n        // created with createElement (which might set nodeName to \"prefix:localName\" but\n        // leave localName as null).\n        String nodeLocalName = node.getLocalName();\n        if (nodeLocalName == null) {\n            String nodeName = node.getNodeName();\n            // Use lastIndexOf, similar to DOMNodePointer.getPrefix logic\n            int idx = nodeName.lastIndexOf(':');\n            if (idx >= 0) {\n                nodeLocalName = nodeName.substring(idx + 1);\n            } else {\n                nodeLocalName = nodeName;\n            }\n        }\n\n        // Check if the local names match\n        boolean localNamesMatch = testLocalName.equals(nodeLocalName);\n\n        // The node matches if:\n        // 1. The test is 'prefix:*' (isWildcardTest is true) AND the namespaces match.\n        // 2. The local names match AND the namespaces match.\n        if (isWildcardTest || localNamesMatch) {\n            // Compare the namespace URI expected by the test with the node's actual namespace URI.\n            // node.getNamespaceURI() returns null if the node is not in a namespace.\n            String nodeNamespaceURI = node.getNamespaceURI();\n            // Use the existing equalStrings method for comparison (assuming it's accessible)\n            return equalStrings(testNamespaceURI, nodeNamespaceURI);\n        }\n\n        // Local names didn't match, and it wasn't a 'prefix:*' test\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                // XPath 'node()' test typically matches any node.\n                // The original code only matched Element and Document nodes.\n                // Retaining original behavior unless specification requires otherwise.\n                // Consider returning true for any node type if this represents 'node()'.\n                 return nodeType == Node.ELEMENT_NODE\n                         || nodeType == Node.DOCUMENT_NODE;\n//                return true; // If NODE_TYPE_NODE represents the XPath node() test\n            case Compiler.NODE_TYPE_TEXT :\n                return nodeType == Node.TEXT_NODE\n                    || nodeType == Node.CDATA_SECTION_NODE;\n            case Compiler.NODE_TYPE_COMMENT :\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI :\n                // Matches PI nodes, ignoring the target.\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false; // Should not happen with valid NodeTypeTest constants\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        // Matches PI nodes with a specific target.\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            // Use equals for comparison as in original code. Assumes target is non-null.\n            return testPI.equals(nodePI);\n        }\n    }\n    // Unknown or unhandled NodeTest type\n    return false;\n}\n\n// Assume this helper method exists elsewhere and performs a null-safe string comparison.\n// private static boolean equalStrings(String s1, String s2) { ... }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}