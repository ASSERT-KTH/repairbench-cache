{
    "generation": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            // Resolved namespace URI for the test (e.g., from prefix, or default)\n            String testNamespaceURI = nodeNameTest.getNamespaceURI();\n            // True if the test's local name is wildcard '*'\n            boolean isWildcardName = nodeNameTest.isWildcard();\n            // The prefix used in the test QName (e.g., \"B\" in \"B:ElementB\", null in \"ElementB\")\n            String testPrefix = testName.getPrefix();\n            // The local name specified in the test (e.g., \"ElementB\", \"*\")\n            String testLocalName = testName.getName();\n\n            // Case 1: Test is *:* (wildcard name, null prefix in QName)\n            // This matches any element node.\n            if (isWildcardName && testPrefix == null) {\n                return true;\n            }\n\n            // Get node's properties using the helper functions which handle DOM variations\n            String nodeLocalName = DOMNodePointer.getLocalName(node);\n            String nodeNamespaceURI = DOMNodePointer.getNamespaceURI(node);\n\n            // Case 2: Test is prefix:* (wildcard name, specific prefix)\n            // This matches elements with the specified namespace URI, regardless of local name.\n            if (isWildcardName) {\n                // testPrefix is non-null here (covered by Case 1 otherwise).\n                // Compare the node's namespace URI with the test's expected namespace URI.\n                return equalStrings(testNamespaceURI, nodeNamespaceURI);\n            }\n\n            // Case 3: Test is for a specific local name (prefix:name or name)\n            // Note: This logic also covers *:name if JXPath represents it with testPrefix==null\n            // and testNamespaceURI==null, but the namespace check might be incorrect for *:name.\n            // However, for prefix:name and name tests, the logic is correct.\n            if (!isWildcardName) {\n                // Check if the node's local name matches the test's local name.\n                // XPath element/attribute names are case-sensitive.\n                if (testLocalName.equals(nodeLocalName)) {\n                    // Local names match. Now compare namespace URIs.\n                    // testNamespaceURI contains the expected URI (specific, default, or null).\n                    // nodeNamespaceURI is the actual URI of the node.\n                    return equalStrings(testNamespaceURI, nodeNamespaceURI);\n                }\n                // else: Local names do not match.\n            }\n\n            // Node did not match the test criteria (e.g., local name mismatch)\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    // Matches Element and Document nodes based on original logic\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            // Unknown/unhandled node type in the test\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                // Check if the PI target names match (case-sensitive).\n                return testPI.equals(nodePI);\n            }\n            // Node is not a processing instruction\n            return false;\n        }\n        // Test type is not recognized or handled\n        return false;\n    }\n\n    /**\n     * Helper function to compare two strings for equality, handling nulls correctly.\n     * @param s1 First string\n     * @param s2 Second string\n     * @return true if strings are equal (both null is considered equal)\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null) {\n            return s2 == null;\n        }\n        return s1.equals(s2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}