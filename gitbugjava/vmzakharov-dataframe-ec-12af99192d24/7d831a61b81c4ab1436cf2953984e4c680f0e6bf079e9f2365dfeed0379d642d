{
    "generation": "    @Override\n    public String asStringLiteral()\n    {\n        // this.value is the raw string content.\n        // For example, if the original DSL was 'foo\"bar', this.value would be the string foo\"bar.\n\n        boolean containsDoubleQuote = this.value.contains(\"\\\"\");\n        boolean containsSingleQuote = this.value.contains(\"'\");\n\n        if (containsDoubleQuote && !containsSingleQuote)\n        {\n            // The string contains double quotes, but no single quotes.\n            // It's best to wrap it with single quotes to avoid escaping the internal double quotes.\n            // e.g., if value is foo\"bar, output should be 'foo\"bar'.\n            return \"'\" + this.value + \"'\";\n        }\n        else\n        {\n            // In all other cases, default to using double quotes for wrapping.\n            // These cases are:\n            // 1. String contains single quotes, but no double quotes (e.g., \"foo'bar\").\n            //    Output: \"foo'bar\" (no escaping needed for the double quotes).\n            // 2. String contains neither single nor double quotes (e.g., \"foobar\").\n            //    Output: \"foobar\" (no escaping needed).\n            // 3. String contains both single and double quotes (e.g., \"foo\\\"bar'baz\").\n            //    Output: \"foo\\\"bar'baz\" (internal double quotes must be escaped).\n            // 4. String is empty.\n            //    Output: \"\" (no escaping needed).\n\n            // Escape any double quotes within the string value by prepending a backslash.\n            // e.g. \" -> \\\"\n            // String.replace() correctly handles replacing all occurrences.\n            String escapedValue = this.value.replace(\"\\\"\", \"\\\\\\\"\");\n            return \"\\\"\" + escapedValue + \"\\\"\";\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}