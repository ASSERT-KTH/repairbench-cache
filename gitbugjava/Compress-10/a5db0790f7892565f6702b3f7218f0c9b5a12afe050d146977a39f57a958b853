{
    "generation": "import java.io.IOException;\nimport java.util.Map;\n\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipConstants;\nimport org.apache.commons.compress.archivers.zip.ZipShort;\nimport org.apache.commons.compress.archivers.zip.ZipUtil;\n\n// Imports only added for context, assuming they exist in the original file.\n// Actual fix only involves the function body.\n\n    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        // Using entries.keySet() preserves the insertion order from the central directory.\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset; // Start of LFH\n\n            // Seek to the position of filename length and extra field length in LFH\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH); // offset 26\n\n            // Read filename length (2 bytes)\n            byte[] shortBuf = new byte[SHORT];\n            archive.readFully(shortBuf);\n            int fileNameLen = ZipShort.getValue(shortBuf);\n\n            // Read extra field length (2 bytes)\n            archive.readFully(shortBuf);\n            int extraFieldLen = ZipShort.getValue(shortBuf);\n\n            // Calculate the offset to the actual data.\n            // dataOffset = start of LFH + size of fixed LFH fields (30 bytes)\n            //              + filename length + extra field length\n            offsetEntry.dataOffset = offset + ZipConstants.LFH_FIXED_SIZE // 30 bytes\n                                      + fileNameLen + extraFieldLen;\n\n\n            // Don't overwrite central directory extra data with local file header extra data.\n            // The central directory data might contain information (e.g., Unicode Path Extra Field)\n            // that is missing in the local file header. Preserving the central directory\n            // extra data is generally safer and resolves issues like the one reported in\n            // COMPRESS-176 / the failing test case where WinZip puts Unicode path data\n            // only in the central directory.\n            //\n            // byte[] localExtraData = new byte[extraFieldLen]; // No longer read\n            // archive.readFully(localExtraData); // No longer read\n            // ze.setExtra(localExtraData); // REMOVED THIS LINE\n\n            // If the entry's name might be non-UTF8 (based on Central Directory's flag),\n            // attempt to decode it using name/comment bytes potentially stored in\n            // the Central Directory's extra fields. This now uses the original extra\n            // data read from the central directory.\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // This uses ze.getExtra() which contains the Central Directory extra data.\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    // If name changed, update the nameMap.\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            // No need to skip LFH filename/extra field data explicitly,\n            // as we are calculating the data offset based on lengths and seeking later.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}