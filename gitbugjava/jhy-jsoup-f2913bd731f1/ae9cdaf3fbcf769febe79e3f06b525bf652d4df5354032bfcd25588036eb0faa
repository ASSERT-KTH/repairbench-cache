{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // normaliseWhite: true if prettyPrint is on AND parent is not whitespace-preserving (e.g., <pre>)\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        // trimLikeBlock: true if parent is a block-level element or formats as a block (e.g., <p>, <div>)\n        final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n        boolean trimLeading = false, trimTrailing = false;\n\n        if (normaliseWhite) {\n            final Node prev = previousSibling();\n            final Node next = nextSibling();\n            final boolean isBlank = isBlank(); // true if this TextNode contains only whitespace\n\n            // Rule 1: Trim leading whitespace if it's the first child of a block-like parent\n            // or if it's a direct child of the Document node itself.\n            if ((trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document) {\n                trimLeading = true;\n            }\n            // Rule 2: Trim leading whitespace if this text node is blank and immediately follows a block-level element.\n            // This covers cases like `</p>\\n<span>` where the `\\n` should be removed because it's after a block.\n            else if (isBlank && prev instanceof Element && ((Element) prev).tag().formatAsBlock()) {\n                trimLeading = true;\n            }\n\n            // Rule 3: Trim trailing whitespace if it's the last child of a block-like parent.\n            if (trimLikeBlock && nextSibling() == null) {\n                trimTrailing = true;\n            }\n            // Rule 4: Trim trailing whitespace if this text node is blank and immediately precedes a block-level element.\n            // This covers cases like `<div>\\n<p>` where the `\\n` should be removed because it's before a block.\n            else if (isBlank && next instanceof Element && ((Element) next).tag().formatAsBlock()) {\n                trimTrailing = true;\n            }\n\n            // Original logic for skipping blank text nodes if the next element should indent or is also blank.\n            // If this blank node is followed by a node that causes indentation (e.g., a block element), or another blank node\n            // (e.g., from re-parenting multiple whitespace text nodes), this one should be completely skipped.\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n                || (next instanceof TextNode && (((TextNode) next).isBlank()));\n            if (couldSkip && isBlank) {\n                return; // Entirely skip this blank text node's output.\n            }\n\n            // Indent logic: for non-blank text nodes at the beginning of a block, or in outline mode, or after a <br>.\n            // This adds a newline and indentation *before* the text node's content is written.\n            if (\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // special case wrap on inline <br> - doesn't make sense as a block tag\n            )\n                indent(accum, depth, out);\n        }\n\n        // Escape and write the text content, applying normalisation and trimming rules.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}