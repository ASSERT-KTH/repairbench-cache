{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // parent shouldn't be null, but check just in case + avoids null check warnings\n        final boolean normaliseWhite = prettyPrint && parent != null && !Element.preserveWhitespace(parent);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        // Indentation is applied directly if needed, no need for a separate flag tracking\n\n        if (normaliseWhite) {\n            final Node prev = previousSibling();\n            final Node next = nextSibling();\n            final boolean isBlank = isBlank();\n            final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n\n            // 1. Check if blank node should be skipped entirely. Skip if the node is blank, and the next node will handle spacing (or is another blank node).\n            boolean nextWillIndent = (next instanceof Element && ((Element) next).shouldIndent(out));\n            boolean nextIsBlank = (next instanceof TextNode && ((TextNode) next).isBlank()); // From re-parenting or similar\n            if (isBlank && (nextWillIndent || nextIsBlank)) {\n                return; // Skip this node entirely, the sibling will handle the whitespace insertion/indentation.\n            }\n\n            // 2. Calculate trimming flags based on context for potentially trimming partial whitespace or the whole node if blank.\n            trimLeading = (trimLikeBlock && siblingIndex == 0) // Is first child of a block-like parent\n                          || parentNode instanceof Document // Is first child of document\n                          || (prev instanceof Element && ((Element) prev).tag().isBlock()); // Follows a block element\n\n            trimTrailing = (trimLikeBlock && next == null) // Is last child of a block-like parent\n                           || (next instanceof Element && ((Element) next).tag().isBlock()); // Precedes a block element\n\n            // 3. Check if indentation needed for non-blank nodes (TextNode itself only handles specific indent cases).\n            if (!isBlank) {\n                 // indent if:\n                 // - in outline mode and siblings exist\n                 // - follows an inline <br> (which doesn't make sense as a block tag)\n                 if (\n                     (out.outline() && siblingNodes().size() > 0) ||\n                     (prev instanceof Element && ((Element) prev).tag().normalName().equals(\"br\"))\n                 ) {\n                     indent(accum, depth, out); // Apply indent directly\n                 }\n            }\n        }\n        // else: normaliseWhite is false, flags remain false, no special logic applies.\n\n        // 4. Call escape with the core value and calculated flags.\n        // Entities.escape() handles the actual whitespace normalization (collapsing to single space)\n        // and trimming based on the flags (removes the space if flags indicate trimming is needed).\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}