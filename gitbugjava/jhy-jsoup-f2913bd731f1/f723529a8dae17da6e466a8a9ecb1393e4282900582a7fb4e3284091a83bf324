{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // Get parent, assuming it's an Element for pretty print logic; null otherwise (e.g. Document)\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // Check if we should normalize whitespace (prettyPrint enabled and parent doesn't preserve whitespace)\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode); // preserveWhitespace checks parent nullity\n\n        if (normaliseWhite) {\n            // Check if this text node contains only whitespace\n            boolean isBlank = isBlank();\n            Node prev = previousSibling(); // Fetch prev sibling once\n\n            // Skipping logic for blank (whitespace-only) nodes:\n            if (isBlank) {\n                Node next = nextSibling(); // Fetch next sibling only if needed for skip check\n                boolean prevIsBlockOrBr = false;\n                if (prev instanceof Element) {\n                    Element prevElem = (Element) prev;\n                    // Check if previous element is a block, formats as block, or is a <br>\n                    prevIsBlockOrBr = prevElem.tag().isBlock() || prevElem.tag().formatAsBlock() || prevElem.normalName().equals(\"br\");\n                }\n                boolean nextWillIndent = (next instanceof Element && ((Element) next).shouldIndent(out));\n                boolean nextIsBlankText = (next instanceof TextNode && ((TextNode) next).isBlank());\n\n                // Skip this blank node if the previous node is block/<br>,\n                // or if the next node will automatically handle the indent/whitespace gap,\n                // or if the next node is also blank text (let the next node handle it).\n                if (prevIsBlockOrBr || nextWillIndent || nextIsBlankText) {\n                    return; // Don't output this blank text node.\n                }\n                // Otherwise, it's a blank node that needs to be preserved (e.g., between two inline elements).\n                // Fall through to Entities.escape below, which will normalize it to a single space.\n            }\n\n            // Indentation logic (applies only if the node was not skipped above):\n            // Indent primarily before non-blank text nodes based on context.\n            boolean indentBefore = false;\n            if (!isBlank) { // Only consider indenting if the node is NOT blank\n                if (parent != null) { // Need parent element context for indent rules\n                    // Indent if:\n                    // 1. First node in a block parent (prev == null implicitly checks siblingIndex == 0)\n                    // 2. In outline mode (and not the first node, checked by prev != null)\n                    // 3. Previous sibling was a <br> element\n                    // These conditions are simplified from original but functionally equivalent for non-blank nodes.\n                    if (\n                        (prev == null && parent.tag().formatAsBlock()) ||\n                        (prev != null && out.outline()) ||\n                        (prev instanceof Element && ((Element) prev).normalName().equals(\"br\"))\n                       ) {\n                        indentBefore = true;\n                    }\n                }\n            }\n\n            if (indentBefore) {\n                indent(accum, depth, out);\n            }\n\n            // Output the text node's content using Entities.escape:\n            // Trim flags determine if leading/trailing space (post-normalization) should be removed.\n            final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n            // Trim leading space if first in a block-like parent OR parent is the Document root\n            boolean trimLeading = (trimLikeBlock && prev == null) || parentNode instanceof Document;\n            // Trim trailing space if last in a block-like parent\n            boolean trimTrailing = trimLikeBlock && nextSibling() == null; // Need to fetch nextSibling again for this check\n\n            // coreValue() gives the text content. normaliseWhite flag tells escape to collapse whitespace.\n            // false = inAttribute=false\n            Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n\n        } else {\n            // Whitespace normalization is off; just escape the raw text value. No indent/trimming needed.\n            Entities.escape(accum, coreValue(), out, false, false, false, false);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}