{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // preserveWhitespace is a per-tag setting (e.g. for <pre>) and unrelated to prettyPrint.\n        // If the parent (e.g. <pre>) preserves whitespace, then don't normalize this text node.\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        Node prev = previousSibling(); // Cache prev sibling, used multiple times\n\n        if (normaliseWhite) {\n            final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n\n            // Determine if leading/trailing space in this text node should be trimmed.\n            // Trim leading if: at start of a block-like parent, or if a child of Document.\n            if ((trimLikeBlock && siblingIndex == 0) || (parentNode instanceof Document)) {\n                trimLeading = true;\n            }\n            // Trim trailing if: at end of a block-like parent.\n            if (trimLikeBlock && nextSibling() == null) {\n                trimTrailing = true;\n            }\n\n            // Adjust trimLeading if this text node follows a \"true\" block element.\n            // Rationale: if prev element was a true block, it would typically end with a newline.\n            // So this text node is effectively at the start of a new line. If it's all whitespace (like \"\\n\"),\n            // it normalizes to \" \", which should then be trimmed if trimLeading is true.\n            if (prev instanceof Element) {\n                Element prevElement = (Element) prev;\n                if (prevElement.tag().isBlock() && !prevElement.tag().isInline()) { // is a \"true\" block (e.g. <p>, not <br>)\n                    trimLeading = true; // This ORs with the earlier trimLeading setting.\n                }\n            }\n\n            // If this text is just whitespace, and the next node will cause an indent, then skip this text.\n            Node next = nextSibling();\n            final boolean isBlank = isBlank(); // Cache isBlank as it's used multiple times\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next is element and will indent\n                || (next instanceof TextNode && ((TextNode) next).isBlank()); // OR next is blank textnode\n            if (couldSkip && isBlank)\n                return; // Don't output this text node\n\n            // Conditions under which this text node should be indented (if it's not blank).\n            boolean indent = false;\n            if (!isBlank) { // Only consider indenting if this text node is not blank.\n                // Condition 1: First non-blank child of a block-formatting parent or Document.\n                if (siblingIndex == 0 && parent != null && (parent.tag().formatAsBlock() || parentNode instanceof Document)) {\n                    indent = true;\n                }\n                // Condition 2: Outline mode. TextNodes also indent in outline mode.\n                // (siblingNodes().size() > 0 is always true if this node exists and has a parent)\n                else if (out.outline() && siblingNodes().size() > 0) {\n                    indent = true;\n                }\n                // Condition 3: After a <br> tag, if this text node is not blank.\n                else if (prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) {\n                    indent = true;\n                }\n            }\n\n            if (indent) {\n                indent(accum, depth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}