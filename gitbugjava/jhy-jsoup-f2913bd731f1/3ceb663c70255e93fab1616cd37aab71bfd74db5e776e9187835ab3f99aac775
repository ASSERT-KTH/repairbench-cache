{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // parent an element?\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // is whitespace normalisation happening?\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        // is this text node in what behaves like a block tag?\n        final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n        \n        boolean trimLeading = false, trimTrailing = false;\n\n        if (normaliseWhite) {\n            // Fetch siblings and calculate isBlank once, as they are used multiple times.\n            Node next = nextSibling();\n            Node prev = previousSibling();\n            final boolean isBlank = isBlank();\n\n            // First, determine if this node should be skipped entirely.\n            if (isBlank) {\n                // if this text is just whitespace, and the next node will cause an indent, or is itself blank, skip this text\n                boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                    || (next instanceof TextNode && ((TextNode) next).isBlank())); // next is blank text, allows sequential blank text nodes to be skipped\n                if (couldSkip) return;\n            }\n\n            // Now, determine if this node should be indented.\n            // Only indent non-blank text nodes. Blank text nodes do not receive an indent.\n            if (!isBlank) {\n                // Conditions for indenting this text node:\n                if (\n                    // First child of a pretty-printed block parent (that formats as block, like <br>)\n                    (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock()) ||\n                    // Outline mode creates indents\n                    (out.outline() && siblingNodes().size() > 0) ||\n                    // After a <br> tag\n                    (prev instanceof Element && ((Element) prev).normalName().equals(\"br\"))\n                ) {\n                    indent(accum, depth, out);\n                }\n            }\n\n            // And determine if this node's whitespace should be trimmed (once the text is normalized).\n            // Init trim state based on this node being the first or last of a block-like parent.\n            trimLeading = (trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document;\n            trimTrailing = trimLikeBlock && next == null; // Use 'next' sibling fetched earlier\n\n            // ** The core fix for the reported bug **\n            // If this TextNode is blank, and immediately follows a block element,\n            // then this text (which will be normalized to a single space) should be completely trimmed.\n            // This handles cases like <p>foo</p>\\n<span>bar</span> -> <p>foo</p><span>bar</span>\n            // or <p>foo</p>\\n<p>bar</p> -> <p>foo</p><p>bar</p>\n            if (isBlank && prev instanceof Element) {\n                Element prevElem = (Element) prev;\n                if (prevElem.tag().isBlock() || prevElem.tag().formatAsBlock()) {\n                    trimLeading = true; // This ensures the blank text node renders as empty string.\n                }\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}