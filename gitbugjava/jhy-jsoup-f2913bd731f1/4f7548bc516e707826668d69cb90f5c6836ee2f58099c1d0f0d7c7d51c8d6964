{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n        final boolean trimLikeBlock = parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock());\n        boolean trimLeading = false, trimTrailing = false;\n\n        if (normaliseWhite) {\n            trimLeading = (trimLikeBlock && siblingIndex == 0) || parentNode instanceof Document;\n            trimTrailing = trimLikeBlock && nextSibling() == null;\n\n            // if this text is just whitespace, and the next node will cause an indent, or other specific conditions, skip this text:\n            boolean isBlank = isBlank(); // Store current node's blank status\n            if (isBlank) {\n                Node next = nextSibling();\n                boolean shouldSkip = false;\n\n                // Condition 1: Next sibling is an element that will cause an indent.\n                if (next instanceof Element && ((Element) next).shouldIndent(out)) {\n                    shouldSkip = true;\n                }\n                // Condition 2: Next sibling is also a blank TextNode.\n                else if (next instanceof TextNode && ((TextNode) next).isBlank()) {\n                    shouldSkip = true;\n                }\n                // Condition 3: (New) Next sibling is an inline element, previous was a block, and parent is a block context.\n                // This handles cases like <p>text</p> \\n <span>text</span> -> <p>text</p><span>text</span>\n                else if (next instanceof Element && ((Element) next).tag().isInline()) {\n                    // 'parent' is this TextNode's parent Element (or null if parentNode is Document).\n                    // normaliseWhite being true implies !Element.preserveWhitespace(parentNode).\n                    if (parent != null && (parent.tag().isBlock() || parent.tag().formatAsBlock())) { // Parent provides block context\n                        Node prev = previousSibling();\n                        if (prev instanceof Element && ((Element) prev).tag().isBlock()) { // Previous sibling is a block element\n                            shouldSkip = true;\n                        }\n                    }\n                }\n                \n                if (shouldSkip) return; // If any skip condition is met, do not output this TextNode.\n            }\n\n            // Indent logic (if not skipped and not blank, or other conditions)\n            Node prev = previousSibling(); // 'prev' for indent logic\n            if (\n                (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank) || // !isBlank refers to current node's status\n                (out.outline() && siblingNodes().size() > 0 && !isBlank) ||\n                (siblingIndex > 0 && prev instanceof Element && ((Element) prev).normalName().equals(\"br\")) // Handles <br> followed by text\n            )\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}