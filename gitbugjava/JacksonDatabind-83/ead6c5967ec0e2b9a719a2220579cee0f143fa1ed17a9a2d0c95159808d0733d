{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            text = text.trim();\n            // 24-Mar-2017, tatu: Should possibly check for empty string separately\n            //   or should this be delegated? Looks like delegated. Changed to delegate.\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            if (text.length() == 0) {\n                 // Make sure behavior is logical; strip first, then check length\n                 // Delegate to specific method because handling differs (might be null, throw exception, produce default)\n                 // Note: signature of method changed over versions, using 0-arg version based on original snippet\n                 return _deserializeFromEmptyString();\n            }\n            // If not empty, attempt actual deserialization\n            Exception cause = null;\n            T result = null;\n            try {\n                // Single call to deserialize:\n                result = _deserialize(text, ctxt);\n                // Good result? Then return it. Could be null if that's valid for the type\n                // 17-Aug-2021, tatu: We do need null check -- some legacy code returns null to fail\n                // Need to check if result is null AFTER try-catch, to allow handler intervention\n                // For now, let's assume non-null means success. If null, it MIGHT be failure.\n                 if (result != null) {\n                     return result;\n                 }\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // Problem during deserialization? Store error, fall through to handler check\n                cause = e;\n                // and keep `result` null\n            }\n\n            // If we reach here, either _deserialize() returned null OR threw an exception.\n            // Try to delegate to handler, or if none, throw exception\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \" + m2;\n                }\n            }\n\n            // Use method that consults handler first. If handler returns non-SKIP, use that.\n            // Note: handleWeirdStringValue is @deprecated in javadoc, but still the intended mechanism\n            @SuppressWarnings(\"deprecation\")\n            Object handlerResult = ctxt.handleWeirdStringValue(_valueClass, text, msg);\n            if (handlerResult != JsonDeserializer.None.SKIP_VALUE) {\n                 // This includes the case where the handler returns null successfully\n                 return (T) handlerResult;\n            }\n\n            // If handler didn't handle it (returned SKIP_VALUE), then we must throw exception\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n        }\n\n        // If not attempting to deserialize from String value...\n        JsonToken t = p.currentToken(); // Use currentToken() instead of deprecated getCurrentToken()\n\n        // ... perhaps we are handling START_ARRAY? [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n\n        // ... or embedded object?\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            // If embedded object is already of the correct type, return it\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            // Otherwise, delegate to specific handler for embedded objects\n            return _deserializeEmbedded(ob, ctxt);\n        }\n\n        // If none of the above, it's an unexpected token type for this deserializer\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}