{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            // [databind#601]: no leading/trailing whitespace allowed\n            text = text.trim();\n            if (text.length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                // Call the non-context version for compatibility with older overrides\n                return _deserializeFromEmptyString();\n            }\n            // Otherwise, could be valid representation to try to parse?\n            try {\n                // 08-Jun-2017, tatu: As per [databind#1677], need to call only once:\n                T result = _deserialize(text, ctxt);\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                return result;\n            // Catch specific exceptions that suggest problems with input String content\n            // (and not general processing problems like IO issues):\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // [databind#1629] Allow problem handlers to intercept disallowed content:\n                String msg = \"not a valid textual representation\";\n                String causeMsg = e.getMessage();\n                if (causeMsg != null) {\n                    msg = msg + \", problem: \" + causeMsg;\n                }\n                // note: will throw exception if handlers cannot handle\n                Object result = ctxt.handleWeirdStringValue(_valueClass, text, msg);\n                // If it didn't throw, must have been handled\n                // [databind#2269]: Allow returning null if handler indicates.\n                if (result == DeserializationContext.MARKER_FOR_EMPTY) {\n                    return null;\n                }\n                // Otherwise, need to cast\n                return (T) result;\n            }\n            // Other kinds of exceptions will propagate as-is, which is fine\n        }\n\n        // [databind#381]: Need to support Array -> Scalar coercion\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_ARRAY) {\n            // Let's delegate array handling properly\n            return _deserializeFromArray(p, ctxt);\n        }\n\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            // 30-Sep-2019, tatu: maybe need this for some reason? (was missing)\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        // [databind#1798]: How about incoming null? Need to handle properly\n        if (t == JsonToken.VALUE_NULL) {\n             // Usually default handling returns `getNullValue(ctxt)` is what is needed here\n             return getNullValue(ctxt);\n        }\n        // Otherwise, unexpected token type; let context handle\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}