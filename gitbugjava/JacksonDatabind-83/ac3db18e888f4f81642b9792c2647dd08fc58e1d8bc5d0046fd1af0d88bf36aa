{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            text = text.trim(); // Trim upfront\n            if (text.length() == 0) { // Check length after trim\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString(); // Delegate check to specific method\n            }\n\n            // If not empty, try to deserialize\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value. -> Call once, return value.\n                T result = _deserialize(text, ctxt);\n                return result;\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // These are expected exceptions for invalid format strings, let's allow handlers to intervene\n                cause = e;\n                // fall through to handler invocation\n            }\n            // OOME or other Errors are not caught; other IOExceptions are not caught\n            // here as _deserialize() isn't supposed to fail with those?\n            // (note: sub-classes may override and add other exceptions)\n\n            // If we reach here, deserialization from string failed.\n            String msg = \"not a valid textual representation\"; // Base message\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n\n            // [databind#1629]: Allow DeserializationProblemHandler to handle\n            // 13-Oct-2020, tatu: Important: MUST call method in DeserializationContext\n            //   AND NOT just `handleWeirdStringValue` on `ObjectMapper` / `MapperFeature`\n            //   because context has information about handler state (avoid infinite loops)\n            Object handled = ctxt.handleWeirdStringValue(_valueClass, text, msg);\n            if (handled != DeserializationContext.UNKNOWN_VALUE) {\n                // Can be null if handler returns null\n                return (T) handled;\n            }\n            // If not handled, THEN throw the exception\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // Old comment: nothing to do here, yet? We'll fail anyway\n        }\n\n        // If not-string value\n        JsonToken t = p.currentToken(); // Need to check as `getValueAsString()` may have advanced parser\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        // Otherwise, unexpected token\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}