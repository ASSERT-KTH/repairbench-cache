{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            text = text.trim();\n            if (text.length() == 0) {\n                // 24-Apr-2020, tatu: Use helper method which may throw exception etc\n                return _deserializeFromEmptyString(ctxt);\n            }\n            // If not empty, try to deserialize\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value. Nulls are valid values.\n            Exception cause = null;\n            try {\n                T result = _deserialize(text, ctxt);\n                // It worked! Whether null or not, return result:\n                return result;\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // Can catch other exceptions too, if _deserialize() throws more types\n                cause = e;\n                // Fall through to handler invocation...\n            }\n            // Note: may want to catch other exceptions, like `JsonMappingException`\n            // Need to figure out how to handle recursive calls; for now keep simple\n\n            // We hit an exception; see if ProblemHandler can provide value instead\n            String baseMsg = \"not a valid textual representation\";\n            // Keep message structure similar to original code\n            String causeMsg = (cause == null) ? null : cause.getMessage();\n            String failureDesc = baseMsg;\n            if (causeMsg != null) {\n                failureDesc = baseMsg + \", problem: \" + causeMsg;\n            }\n\n            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n            // 17-Jan-2018, tatu: Need to delegate problem handling to context\n            // Ask ProblemHandler if it can resolve the situation\n            Object S = ctxt.handleWeirdStringValue(_valueClass, text, failureDesc);\n\n            if (S != DeserializationContext.MISSING_VALUE) {\n                 // Handler provided a value (which might be null)\n                 return (T) S;\n            }\n            \n            // If handler didn't produce a value, THEN construct and throw exception\n            // Also: must pass original `cause` unless handler replaced it\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, failureDesc);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n        }\n\n        // If not attempting to deserialize from String value:\n        JsonToken t = p.currentToken(); // Use currentToken instead of getCurrentToken\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            // 24-Apr-2020, tatu: Use new method\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            // 24-Apr-2020, tatu: Use new method\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        // 24-Apr-2020, tatu: Use new method\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}