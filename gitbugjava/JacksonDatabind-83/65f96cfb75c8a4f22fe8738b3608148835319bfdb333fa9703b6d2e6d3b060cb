{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            text = text.trim();\n            if (text.isEmpty()) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                // 24-Sep-2019, tatu: empty needs different handling than blank...\n                return _deserializeFromEmptyString(ctxt);\n            }\n            // 17-Dec-2018, tatu: Certain JDK types like `UUID` require special care wrt exceptions...\n            // Let's delegate grueso modo handling to context now?\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                // 08-Jun-2017, tatu: Call `_deserialize()` only once now\n                T result = _deserialize(text, ctxt);\n                if (result != null) {\n                    return result;\n                }\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // 21-Jun-2020, tatu: Need to store actual cause for Problem Handler\n                //   processing BUT also need to avoid NPE later on, if `null` really\n                //   is the value... Does not seem like something can check easily,\n                //   so let's just handle what we can\n                cause = e;\n                // and fall through to handling by context which may involve ProblemHandler\n                // or just throw the exception wrapping the cause\n            }\n            // 19-May-2017, tatu: ... this is unfortunate, but has to do for now\n            // 21-Jun-2020, tatu: Let's use standard facilities; handling should be fine,\n            //   except for the slight possibility that `null` is valid value. The check\n            //   above SHOULD take care of that.... meaning we only get here on exception?\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            // Use method that checks for ProblemHandler, returns value/throws exception\n            Object result = ctxt.handleWeirdStringValue(_valueClass, text, msg);\n            // If it did return value, need to cast (might be null)\n            // 18-Nov-2020, tatu: As per [databind#2958], should NOT coerce to null\n            //    but value needs to be compatible... Although actually for \"weird\"\n            //    values, seems ok to trust handler? Let's assume ok for now.\n            // 21-Nov-2020, tatu: ... or possibly check `value != null`? For now assume\n            //    handlers know what they are doing.\n            return (T) result;\n        }\n\n        // Need to support Array (of Strings?) for borderline coercion cases?\n        // Re-scheduled for 2.3; was\u8ba1\u5212to be done for 2.2\n        JsonToken t = p.currentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            // 25-Nov-2015, tatu: Maybe need to call `_deserializeEmbedded`?\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        // 24-Sep-2019, tatu: Let's beef up message for unexpected token too\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}