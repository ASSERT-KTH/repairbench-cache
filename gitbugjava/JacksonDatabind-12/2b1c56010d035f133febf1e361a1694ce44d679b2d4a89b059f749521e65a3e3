{
    "generation": "    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         * We'll broaden this to cover any property that has TypeDeserializer\n         * (for polymorphic handling).\n         */\n        if (_valueTypeDeserializer != null) {\n            return false;\n        }\n        if (_ignorableProperties != null) {\n            return false;\n        }\n        // Also, let's traverse properties, see if any require TypeDeserializer.\n        if (_beanProperties != null) {\n            final Iterator<SettableBeanProperty> it = _beanProperties.iterator();\n            while (it.hasNext()) {\n                // 04-Feb-2017, tatu: As per [databind#1521], existence of TypeDeserializer\n                //   for properties may prevent cachability as well\n                 if (it.next().getValueTypeDeserializer() != null) {\n                     return false;\n                 }\n            }\n        }\n        return true;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}