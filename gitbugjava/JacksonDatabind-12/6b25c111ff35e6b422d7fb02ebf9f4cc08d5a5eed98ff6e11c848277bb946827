{
    "generation": "    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         * We can check this simply by seeing if related fields are null\n         * after construction, but before resolve() has been called.\n         */\n        // also: value instantiator is non-cachable? why?\n        // 22-Dec-2017, tatu: Turns out ValueInstantiator is needed too...\n        //   Probably because it'd be weird to attach it to an otherwise\n        //  \"standard\" deserializer? Or maybe knows something about props?\n        //   ...\n        // Let's NOT include ValueInstantiator check for now, minimal fix:\n        return (_valueDeserializer == null)\n                && (_keyDeserializer == null)\n                && (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null);\n    }\n",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}