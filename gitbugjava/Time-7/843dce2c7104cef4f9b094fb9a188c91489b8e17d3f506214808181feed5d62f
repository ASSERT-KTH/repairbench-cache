{
    "generation": "    /**\n     * Parses a datetime from the given text, at the given position, saving the\n     * result into the fields of the given ReadWritableInstant. If the parse\n     * succeeds, the return value is the new text position. Note that the parse\n     * may succeed without fully reading the text and in this case those fields\n     * that were read will be set.\n     * <p>\n     * Only those fields present in the string will be changed in the specified\n     * instant. All other fields will remain unaltered. Thus if the string only\n     * contains a year and a month, then the day and time will be retained from\n     * the input instant. If this is not the behaviour you want, then reset the\n     * fields before calling this method, or use {@link #parseDateTime(String)}\n     * or {@link #parseMutableDateTime(String)}.\n     * <p>\n     * If it fails, the return value is negative, but the instant may still be\n     * modified. To determine the position where the parse failed, apply the\n     * one's complement operator (~) on the return value.\n     * <p>\n     * This parse method ignores the {@link #getDefaultYear() default year} and\n     * parses using the year from the supplied instant based on the chronology\n     * and time-zone of the supplied instant.\n     * <p>\n     * The parse will use the chronology of the instant.\n     *\n     * @param instant  an instant that will be modified, not null\n     * @param text  the text to parse\n     * @param position  position to start parsing from\n     * @return new position, negative value means parse failed -\n     *  apply complement operator (~) to get position of failure\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the instant is null\n     * @throws IllegalArgumentException if any field is out of range\n     */\n    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        // Select the chronology to use for parsing, potentially applying overrides from the formatter.\n        Chronology effectiveChronology = selectChronology(chrono);\n        // Determine default year using the effective chronology and the original instant's millis.\n        // This ensures the year used for defaults aligns with the chronology used for computation.\n        int defaultYear = effectiveChronology.year().get(instantMillis);\n\n        // Initialize the bucket with the original UTC millis and the effective chronology.\n        // Pass the determined default year. This avoids potential issues with local millis calculation\n        // which seemed to cause problems with leap year validation in computeMillis.\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantMillis, effectiveChronology, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        \n        // Compute the new millis by merging parsed fields onto the initial instant state.\n        // The bucket uses the effectiveChronology for the computation.\n        // 'false' for resetFields ensures unspecified fields (like time) are retained from the original instant.\n        // Pass the text for context in potential error messages from computeMillis.\n        instant.setMillis(bucket.computeMillis(false, text));\n\n        // Determine the final chronology for the result instant.\n        // It should be based on the effectiveChronology, but potentially updated\n        // with a zone/offset parsed from the text.\n        // Note: iOffsetParsed is a formatter field indicating if the parser grammar included offset parsing.\n        Chronology resultChrono;\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            // An offset was successfully parsed.\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            // Use the base chronology but with the parsed fixed offset zone.\n            resultChrono = effectiveChronology.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            // A time zone identifier was successfully parsed.\n            // Use the base chronology but with the parsed zone.\n            resultChrono = effectiveChronology.withZone(bucket.getZone());\n        } else {\n            // No zone or offset was parsed. Use the effectiveChronology determined earlier.\n            // This carries the zone from the original instant or the formatter's override zone.\n            resultChrono = effectiveChronology;\n        }\n        // Set the potentially updated chronology on the instant.\n        // This typically preserves the UTC millisecond value set previously.\n        instant.setChronology(resultChrono);\n        \n        // Finally, apply the formatter's overall zone override (iZone) if it was specified.\n        // This adjusts the fields to match the iZone while preserving the UTC instant.\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        \n        return newPos;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}