{
    "generation": "import java.text.NumberFormat; // Assuming these imports are available\nimport java.text.ParsePosition;\nimport org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.util.MathUtils; // Required for MathUtils.sign\n\n// Assume the context of a class like ProperFractionFormat extending FractionFormat\n// and necessary methods like getWholeFormat, getNumeratorFormat, getDenominatorFormat,\n// parseAndIgnoreWhitespace, parseNextCharacter, and super.parse are defined elsewhere.\n\n    /**\n     * Parses a string to produce a {@link Fraction} object.  This method\n     * expects the string to be formatted as a proper fraction.\n     * <p>\n     * Minus signs are only allowed in the whole number part - i.e.,\n     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n     * will result in a <code>ParseException</code>.\n     * \n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Fraction} object.\n     */\n    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction using base class method first\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n        \n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole number part\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // Invalid whole number. Reset index to start of parsing attempt.\n            // The error index is likely set by NumberFormat.parse failure.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace between whole and numerator\n        parseAndIgnoreWhitespace(source, pos);\n        \n        // Store index before attempting to parse the numerator\n        int numeratorStartIndex = pos.getIndex();\n        \n        // parse numerator\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // Invalid numerator. Reset index to start of parsing attempt.\n            // The error index is likely set by NumberFormat.parse failure.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n        // Validate numerator: must be non-negative for proper fraction format\n        // Use doubleValue for comparison to handle potential non-integer results,\n        // although typically Integer is expected from getNumeratorFormat.\n        if (num.doubleValue() < 0.0) {\n            // Negative numerator is not allowed in proper fraction format as per Javadoc.\n            pos.setIndex(initialIndex); // Reset index to start of this parse attempt\n            pos.setErrorIndex(numeratorStartIndex); // Mark error at the start of the invalid numerator\n            return null;\n        }\n\n        // parse '/' separator\n        int slashStartIndex = pos.getIndex(); // Position where '/' is expected or found\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 : // End of string reached before finding '/'\n            // This indicates a format like \"W N\" which is not a valid proper fraction \"W N / D\".\n            // Proper format requires all three parts.\n            pos.setIndex(initialIndex); // Reset index to start\n            pos.setErrorIndex(slashStartIndex); // Mark error where '/' was expected\n            return null;\n        case '/' :\n            // Found '/', continue parsing denominator\n            break;\n        default : // Found an unexpected character instead of '/'\n            pos.setIndex(initialIndex); // Reset index to start\n            pos.setErrorIndex(slashStartIndex); // Mark error at the unexpected character\n            return null;\n        }\n\n        // parse whitespace between '/' and denominator\n        parseAndIgnoreWhitespace(source, pos);\n\n        // Store index before attempting to parse the denominator\n        int denominatorStartIndex = pos.getIndex();\n\n        // parse denominator\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            // Invalid denominator. Reset index to start of parsing attempt.\n            // The error index is likely set by NumberFormat.parse failure.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        \n        // Validate denominator: must be positive for proper fraction format\n        // Use doubleValue for comparison consistency.\n        if (den.doubleValue() < 0.0) {\n            // Negative denominator is not allowed in proper fraction format as per Javadoc.\n            pos.setIndex(initialIndex); // Reset index to start\n            pos.setErrorIndex(denominatorStartIndex); // Mark error at the start of the invalid denominator\n            return null;\n        }\n\n        // Additional validation: Denominator cannot be zero.\n        if (den.doubleValue() == 0.0) {\n            // Zero denominator is mathematically invalid for fractions.\n            pos.setIndex(initialIndex); // Reset index to start\n            pos.setErrorIndex(denominatorStartIndex); // Mark error at the start of the zero denominator\n            return null;\n        }\n\n        // Extract integer values from parsed Numbers\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        \n        // Calculate the numerator of the resulting improper fraction.\n        // The formula is: sign(w) * (|w| * d + n)\n        // This correctly combines the whole and fractional parts, preserving the sign from the whole part.\n        // MathUtils.sign(w) returns 1 for w>0, -1 for w<0, and 0 for w=0.\n        // The Fraction constructor will handle reduction and potential arithmetic overflows (throwing ArithmeticException).\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}