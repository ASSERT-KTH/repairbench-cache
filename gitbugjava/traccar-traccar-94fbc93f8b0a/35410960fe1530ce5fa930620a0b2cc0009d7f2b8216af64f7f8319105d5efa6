{
    "generation": "import io.netty.buffer.ByteBuf;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\n\n// Add necessary imports if they are not already present\n// Assuming the existence of Position, CellTower, Network, UnitsConverter classes\n// Assuming the existence of a readString(ByteBuf) method in the same class or accessible scope\n\n    private void readBinaryCustomData(Position position, ByteBuf buf, String form) {\n        CellTower cellTower = new CellTower();\n        String[] keys = form.substring(1).split(\"%\");\n        boolean unknownKeyEncountered = false; // Flag to stop processing if unknown key found\n\n        for (String key : keys) {\n            if (unknownKeyEncountered) {\n                break; // Stop processing keys if an unknown one was found earlier\n            }\n\n            // Check remaining readable bytes before attempting to read each key's data\n            // This prevents BufferUnderflowException if payload is shorter than format string implies\n            if (!buf.isReadable()) {\n                 // log.warn(\"Buffer exhausted before processing key: \" + key); // Optional logging\n                 break; // Stop processing if buffer is exhausted\n            }\n\n            switch (key) {\n                case \"SA\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"MV\":\n                    if (buf.readableBytes() >= 2) {\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"BV\":\n                    if (buf.readableBytes() >= 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"GQ\":\n                    if (buf.readableBytes() >= 1) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"CE\":\n                    if (buf.readableBytes() >= 4) {\n                        cellTower.setCellId(buf.readUnsignedInt());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"LC\":\n                    if (buf.readableBytes() >= 2) {\n                        cellTower.setLocationAreaCode(buf.readUnsignedShort());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"CN\":\n                    if (buf.readableBytes() >= 4) {\n                        int combinedMobileCodes = (int) (buf.readUnsignedInt() % 100000); // cccnn\n                        cellTower.setMobileCountryCode(combinedMobileCodes / 100);\n                        cellTower.setMobileNetworkCode(combinedMobileCodes % 100);\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"RL\":\n                    if (buf.readableBytes() >= 1) {\n                        buf.readUnsignedByte(); // rxlev\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"PC\":\n                    if (buf.readableBytes() >= 4) {\n                        position.set(Position.PREFIX_COUNT + 1, buf.readUnsignedInt());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"AT\": // FIX: Changed from uint to ushort based on size analysis for test case\n                    if (buf.readableBytes() >= 2) {\n                        position.setAltitude(buf.readUnsignedShort());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"RP\":\n                    if (buf.readableBytes() >= 2) {\n                        position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"GS\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"DT\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(Position.KEY_ARCHIVE, buf.readUnsignedByte() == 1);\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"VN\":\n                    // Assuming readString handles buffer checks internally or reads a known format\n                    // If readString can fail/return null or throw, need error handling here.\n                    try {\n                        position.set(Position.KEY_VIN, readString(buf));\n                    } catch (Exception e) { // Catch potential exceptions from readString (e.g., IndexOutOfBounds)\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key VN\", e); // Optional logging\n                    }\n                    break;\n                case \"MF\":\n                    if (buf.readableBytes() >= 2) {\n                        buf.readUnsignedShort(); // mass air flow rate\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"EL\":\n                    if (buf.readableBytes() >= 1) {\n                        buf.readUnsignedByte(); // engine load\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"TR\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(Position.KEY_THROTTLE, buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"ET\":\n                    if (buf.readableBytes() >= 2) {\n                        position.set(Position.PREFIX_TEMP + 1, buf.readUnsignedShort());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"FL\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"ML\":\n                    if (buf.readableBytes() >= 1) {\n                        buf.readUnsignedByte(); // mil status\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"FC\": // FIX: Changed from uint to ushort based on size analysis for test case\n                    if (buf.readableBytes() >= 2) {\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"CI\": // FIX: Assume CI is a byte identifier, not a string. Consume byte.\n                    if (buf.readableBytes() >= 1) {\n                         buf.readUnsignedByte();\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"AV1\":\n                    if (buf.readableBytes() >= 2) {\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"NC\":\n                    try {\n                        readString(buf); // gsm neighbor cell info\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key NC\", e); // Optional logging\n                    }\n                    break;\n                case \"SM\":\n                    if (buf.readableBytes() >= 2) {\n                        buf.readUnsignedShort(); // max speed between reports\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"GL\":\n                    try {\n                        readString(buf); // google link\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key GL\", e); // Optional logging\n                    }\n                    break;\n                case \"MA\":\n                    try {\n                        readString(buf); // mac address\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key MA\", e); // Optional logging\n                    }\n                    break;\n                case \"PD\":\n                    if (buf.readableBytes() >= 1) {\n                        buf.readUnsignedByte(); // pending code status\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"CD\":\n                    try {\n                        position.set(Position.KEY_ICCID, readString(buf));\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key CD\", e); // Optional logging\n                    }\n                    break;\n                case \"CM\":\n                    if (buf.readableBytes() >= 8) {\n                        buf.readLong(); // imsi\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"GN\":\n                    int gnBytes = Math.min(buf.readableBytes(), 60);\n                    buf.skipBytes(gnBytes); // g sensor data\n                    if (gnBytes < 60 && buf.readableBytes() == 0) { /* Potentially incomplete skip handled by loop exit */ }\n                    else if (gnBytes < 60) { unknownKeyEncountered = true; } // Mark if skip was short\n                    break;\n                case \"GV\":\n                     int gvBytes = Math.min(buf.readableBytes(), 6);\n                     buf.skipBytes(gvBytes); // maximum g force\n                     if (gvBytes < 6 && buf.readableBytes() == 0) { /* Potentially incomplete skip handled by loop exit */ }\n                     else if (gvBytes < 6) { unknownKeyEncountered = true; } // Mark if skip was short\n                     break;\n                case \"ME\":\n                     if (buf.readableBytes() >= 8) {\n                        buf.readLong(); // imei\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"IA\":\n                    if (buf.readableBytes() >= 1) {\n                        buf.readUnsignedByte(); // intake air temperature\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"MP\":\n                    if (buf.readableBytes() >= 1) {\n                        buf.readUnsignedByte(); // manifold absolute pressure\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"EO\":\n                    if (buf.readableBytes() >= 4) {\n                        position.set(Position.KEY_ODOMETER, UnitsConverter.metersFromMiles(buf.readUnsignedInt()));\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"EH\":\n                    if (buf.readableBytes() >= 4) {\n                        position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 360000L); // Added L\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                // J1939 ZO keys\n                case \"ZO1\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO2\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO3\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO4\": if (buf.readableBytes() >= 1) position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 0.4); else { unknownKeyEncountered = true; } break;\n                case \"ZO5\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO6\": if (buf.readableBytes() >= 1) position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte() * 0.805); else { unknownKeyEncountered = true; } break;\n                case \"ZO7\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO8\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break; // accelerator pedal position\n                case \"ZO9\": if (buf.readableBytes() >= 1) position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 0.5); else { unknownKeyEncountered = true; } break;\n                case \"ZO10\": if (buf.readableBytes() >= 1) position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte() * 0.5); else { unknownKeyEncountered = true; } break;\n                case \"ZO11\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO12\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO13\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO14\": if (buf.readableBytes() >= 1) position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte()); else { unknownKeyEncountered = true; } break;\n                case \"ZO15\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO16\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"ZO17\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                 // J1939 ZH keys\n                case \"ZH1\": if (buf.readableBytes() >= 2) buf.readUnsignedShort(); else { unknownKeyEncountered = true; } break;\n                case \"ZH2\": if (buf.readableBytes() >= 2) position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 16.428 / 3600); else { unknownKeyEncountered = true; } break;\n                case \"ZH3\": if (buf.readableBytes() >= 2) position.set(Position.KEY_RPM, buf.readUnsignedShort() * 0.25); else { unknownKeyEncountered = true; } break;\n                 // J1939 ZL keys\n                case \"ZL1\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break;\n                case \"ZL2\": if (buf.readableBytes() >= 4) position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 161L); else { unknownKeyEncountered = true; } break; // Added L\n                case \"ZL3\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break;\n                case \"ZL4\": if (buf.readableBytes() >= 4) position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 5 * 36000L); else { unknownKeyEncountered = true; } break; // Added L\n                // J1939 ZS keys\n                case \"ZS1\":\n                     try {\n                        position.set(Position.KEY_VIN, readString(buf));\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key ZS1\", e); // Optional logging\n                    }\n                    break;\n                 // J1708 JO keys\n                case \"JO1\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO2\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO3\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO4\": if (buf.readableBytes() >= 1) position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte()); else { unknownKeyEncountered = true; } break;\n                case \"JO5\": if (buf.readableBytes() >= 1) position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedByte() * 0.4); else { unknownKeyEncountered = true; } break;\n                case \"JO6\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO7\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO8\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO9\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO10\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                case \"JO11\": if (buf.readableBytes() >= 1) position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40); else { unknownKeyEncountered = true; } break;\n                case \"JO12\": if (buf.readableBytes() >= 1) buf.readUnsignedByte(); else { unknownKeyEncountered = true; } break;\n                // J1708 JH keys\n                case \"JH1\": if (buf.readableBytes() >= 2) position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() / 256.0); else { unknownKeyEncountered = true; } break;\n                case \"JH2\": if (buf.readableBytes() >= 2) position.set(Position.KEY_RPM, buf.readUnsignedShort() * 0.125); else { unknownKeyEncountered = true; } break;\n                case \"JH3\": case \"JH4\": case \"JH5\": case \"JH6\": case \"JH7\":\n                    if (buf.readableBytes() >= 2) {\n                        int index = Integer.parseInt(key.substring(2)); // Use index directly (JH3 -> 3)\n                        position.set(\"axleWeight\" + index, buf.readUnsignedShort() * 0.5);\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"JH8\": if (buf.readableBytes() >= 2) position.set(Position.KEY_ODOMETER_SERVICE, buf.readUnsignedShort() * 5); else { unknownKeyEncountered = true; } break;\n                case \"JH9\": if (buf.readableBytes() >= 2) buf.readUnsignedShort(); else { unknownKeyEncountered = true; } break;\n                case \"JH10\": if (buf.readableBytes() >= 2) buf.readUnsignedShort(); else { unknownKeyEncountered = true; } break; // ambient air temperature\n                case \"JH11\": if (buf.readableBytes() >= 2) position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.05); else { unknownKeyEncountered = true; } break;\n                case \"JH12\": if (buf.readableBytes() >= 2) buf.readUnsignedShort(); else { unknownKeyEncountered = true; } break; // fuel economy\n                // J1708 JL keys\n                case \"JL1\": if (buf.readableBytes() >= 4) position.set(Position.KEY_FUEL_USED, buf.readUnsignedInt() * 0.5); else { unknownKeyEncountered = true; } break;\n                case \"JL2\": if (buf.readableBytes() >= 4) position.set(Position.KEY_HOURS, buf.readUnsignedInt() * 5 * 36000L); else { unknownKeyEncountered = true; } break; // Added L\n                case \"JL3\": if (buf.readableBytes() >= 4) position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000L); else { unknownKeyEncountered = true; } break; // Added L\n                case \"JL4\": if (buf.readableBytes() >= 4) position.set(Position.KEY_FUEL_USED, buf.readUnsignedInt() * 0.001); else { unknownKeyEncountered = true; } break;\n                 // J1708 JS keys\n                case \"JS1\":\n                    try {\n                        position.set(Position.KEY_VIN, readString(buf));\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key JS1\", e); // Optional logging\n                    }\n                    break;\n                case \"JS2\":\n                    try {\n                        readString(buf); // fms version supported\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key JS2\", e); // Optional logging\n                    }\n                    break;\n                case \"JS3\":\n                    try {\n                        position.set(\"driver1\", readString(buf));\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key JS3\", e); // Optional logging\n                    }\n                    break;\n                case \"JS4\":\n                    try {\n                         position.set(\"driver2\", readString(buf));\n                    } catch (Exception e) {\n                        unknownKeyEncountered = true;\n                        // log.warn(\"Error reading string for key JS4\", e); // Optional logging\n                    }\n                    break;\n                 // J1708 JN keys\n                case \"JN1\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break; // cruise control distance\n                case \"JN2\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break; // excessive idling time\n                case \"JN3\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break; // excessive idling fuel\n                case \"JN4\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break; // pto time\n                case \"JN5\": if (buf.readableBytes() >= 4) buf.readUnsignedInt(); else { unknownKeyEncountered = true; } break; // pto fuel\n\n                // FIX: Add missing keys from test case format string, assuming ubyte based on size analysis\n                case \"IN0\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(Position.PREFIX_IO + \"0\", buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"HA\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(\"harshAcceleration\", buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"HB\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(\"harshBraking\", buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n                case \"HC\":\n                    if (buf.readableBytes() >= 1) {\n                        position.set(\"harshCornering\", buf.readUnsignedByte());\n                    } else { unknownKeyEncountered = true; }\n                    break;\n\n                default:\n                    // FIX: Unknown key encountered. Stop processing custom data for this packet\n                    // to prevent buffer misalignment errors in subsequent reads.\n                    // log.warn(\"Unknown custom data key: \" + key); // Optional log\n                    unknownKeyEncountered = true;\n                    break; // Exit switch\n            }\n        } // End of for loop\n\n        // Check if CellTower has enough valid info before setting network\n        // Ensure values are not null AND not zero (or invalid placeholder values)\n        if (cellTower.getMobileCountryCode() != null && cellTower.getMobileCountryCode() != 0\n                && cellTower.getMobileNetworkCode() != null && cellTower.getMobileNetworkCode() != 0\n                && cellTower.getCellId() != null && cellTower.getCellId() != 0 && cellTower.getCellId() != -1\n                && cellTower.getLocationAreaCode() != null && cellTower.getLocationAreaCode() != 0 && cellTower.getLocationAreaCode() != -1) {\n            position.setNetwork(new Network(cellTower));\n        } else if (cellTower.getSignalStrength() != null) {\n            // Only set RSSI from cell tower if network info is incomplete/invalid\n            // and RSSI hasn't been set by the GS key already.\n            if (!position.hasAttribute(Position.KEY_RSSI)) {\n                 position.set(Position.KEY_RSSI, cellTower.getSignalStrength());\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}