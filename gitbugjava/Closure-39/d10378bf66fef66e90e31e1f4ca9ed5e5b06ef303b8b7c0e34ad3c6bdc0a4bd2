{
    "generation": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      // TODO(nicksantos): Add recursion detection for ReferenceTypes. Programs\n      // like this:\n      // var x = {}; x.y = x; x.toString();\n      // will currently infinite loop.\n      // This likely requires passing a set of visited JSType objects.\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Temporarily disable pretty printing for recursive calls within this\n      // object's properties. This is the original mechanism for recursion detection.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType();\n           // Collect all properties from the prototype chain first.\n           // The limit is applied during printing, not collection.\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      boolean first = true;\n      for (String property : propertyNames) {\n          // Check truncation limit *before* processing the property,\n          // only if not for annotations.\n          if (!forAnnotations && i >= MAX_PRETTY_PRINTED_PROPERTIES) {\n              // Append \"...\" only if we have already added properties.\n              if (!first) {\n                 sb.append(\", ...\");\n              }\n              break;\n          }\n\n          if (!first) {\n            sb.append(\", \");\n          } else {\n            first = false;\n          }\n\n          sb.append(property);\n          sb.append(\": \");\n          JSType propertyType = getPropertyType(property);\n          if (propertyType == null) {\n               // Should not happen, but safeguard.\n               sb.append(\"null\");\n          } else {\n               // Use toStringHelper and pass the 'forAnnotations' flag to handle\n               // recursion representation (\"{...}\" vs \"?\") and nested formatting correctly.\n               sb.append(propertyType.toStringHelper(forAnnotations));\n          }\n          i++;\n      }\n\n      sb.append(\"}\");\n\n      // Restore the flag.\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      // prettyPrint was false, indicating recursion detected by the original mechanism.\n      // Return \"{...}\" for normal toString, \"?\" for annotation string.\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}