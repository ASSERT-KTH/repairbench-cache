{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final int maxEval = getMaximalOrder(); // Renamed for clarity inside the method scope\n        final double[] x = new double[maxEval + 1];\n        final double[] y = new double[maxEval + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else if (y[0] * y[2] < 0) {\n                 // The sign change occurs between the endpoints, x[1] is not helpful initially\n                 // We keep all 3 points for interpolation, but the bracket is [x0, x2]\n                 // Since y[0] and y[1] have the same sign, and y[1] and y[2] have the same sign\n                 // but y[0] and y[2] have different signs.\n                 // Set the sign change index accordingly.\n                 // If y[0] has opposite sign to y[1]/y[2], signChangeIndex = 1? No, bracket is [x0, x2].\n                 // Need to define xA, xB carefully later based on this.\n                 // Let's start with [x[0], x[2]] as the tightest bracket.\n                 // But the points array needs to be consistent with signChangeIndex for later logic.\n                 // Reorder points? Let's stick to the original logic which seems implicitly tested.\n                 // The original code threw NoBracketingException here. Let's reconsider.\n                 // If y[0]*y[1] >= 0 and y[1]*y[2] >= 0, and we are here, it implies\n                 // y[0], y[1], y[2] all have the same sign (unless one is 0, handled above).\n                 // So y[0]*y[2] cannot be < 0. The original exception seems correct.\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            } else {\n                 // All y[0], y[1], y[2] have the same sign.\n                 throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end   = nbPoints;\n            boolean interpolationFailedTotally = false; // Flag for fallback to bisection\n\n            do {\n                // select points for interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n\n                // guess a value for current target, using inverse polynomial interpolation\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n                // Loop if interpolation failed (nextX is NaN) and we have more than 1 point left\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // Fall back to bisection if interpolation failed completely\n                nextX = xA + 0.5 * (xB - xA);\n                interpolationFailedTotally = true;\n                // Keep start/end from the failed attempts, needed below? No, not needed if we use the flag.\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            // Point Management: Update the set of points (x, y) for next interpolation\n\n            // Condition 1: If interpolation succeeded but used a reduced point set [start, end),\n            // discard the points outside this range. Do not do this if we fell back to bisection.\n            if (!interpolationFailedTotally && (nbPoints > 2) && (end - start != nbPoints)) {\n                // We were forced to ignore some points to keep bracketing/ensure convergence.\n                // Drop the unused points from the main arrays.\n                nbPoints = end - start; // Adjust the number of points\n                System.arraycopy(x, start, x, 0, nbPoints); // Copy the used x points to the beginning\n                System.arraycopy(y, start, y, 0, nbPoints); // Copy the used y points to the beginning\n                signChangeIndex -= start; // Adjust the sign change index relative to the new start\n            } else if (nbPoints == x.length) {\n                 // Condition 2: If the array is full (max number of points reached),\n                 // we must drop one point before inserting the new one.\n                 // This happens even if bisection was used.\n                nbPoints--; // Reduce the count conceptually\n\n                // Decide which point to drop: keep the tightest bracketing interval as centered as possible.\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // signChangeIndex is closer to the end: drop the lowest point (at index 0)\n                    System.arraycopy(x, 1, x, 0, nbPoints); // Shift x[1..] down to x[0..nbPoints-1]\n                    System.arraycopy(y, 1, y, 0, nbPoints); // Shift y[1..] down to y[0..nbPoints-1]\n                    --signChangeIndex; // Adjust index because elements shifted down\n                } else {\n                    // signChangeIndex is closer to the start: drop the highest point (at index nbPoints, previously x.length-1)\n                    // No array copy needed here; the insertion below will overwrite the highest element implicitly\n                    // because the copy length `nbPoints - signChangeIndex` will stop before the last slot.\n                }\n            }\n\n            // Insert the new point (nextX, nextY) into the arrays x and y.\n            // By construction, nextX lies within the current tightest bracket (xA, xB).\n            // Insert it at the current signChangeIndex, shifting existing points GTE signChangeIndex up.\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            // Increment the number of points\n            ++nbPoints;\n\n            // Update the bracketing interval [xA, xB] and related variables\n            if (nextY * yA <= 0) {\n                // The sign change occurs between xA (index signChangeIndex-1) and nextX (index signChangeIndex).\n                // The new bracket is [xA, nextX].\n                xB = nextX; // Update right endpoint\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA; // xA was not updated, increment its aging counter\n                agingB = 0; // Reset aging counter for xB\n                // signChangeIndex remains correct (it's the index of the new xB)\n            } else {\n                // The sign change occurs between nextX (index signChangeIndex) and xB (now at index signChangeIndex+1).\n                // The new bracket is [nextX, xB].\n                xA = nextX; // Update left endpoint\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0; // Reset aging counter for xA\n                ++agingB; // xB was not updated, increment its aging counter\n                // Update the sign change index, as it's now between index signChangeIndex and signChangeIndex+1\n                signChangeIndex++;\n            }\n        } // end search loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}