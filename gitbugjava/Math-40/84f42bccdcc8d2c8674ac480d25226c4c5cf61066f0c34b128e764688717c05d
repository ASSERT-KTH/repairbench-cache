{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n\n        final int maximalOrder = getMaximalOrder(); // Local copy for clarity\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex; // Index k such that root is in [x_{k-1}, x_k]\n\n        // Detect bracketing\n        if (y[0] * y[1] < 0) {\n            // Initial bracket [x0, x1]\n            nbPoints        = 2;\n            signChangeIndex = 1; // Root in [x[0], x[1]]\n        } else {\n            // Check [x1, x2]\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n            if (y[1] * y[2] < 0) {\n                // Use all three points, root in [x1, x2]\n                nbPoints        = 3;\n                signChangeIndex = 2; // Root in [x[1], x[2]]\n                // Initial points x[0], x[1], x[2] are min, start, max; already sorted.\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n        }\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                final AllowedSolution allowed = getAllowedSolutions(); // Local copy\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket (xB), try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket (xA), try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // make a few attempts to guess a root, using inverse polynomial interpolation\n            double nextX;\n            int start = 0; // Start index of points to use for interpolation\n            int end   = nbPoints; // End index (exclusive)\n            boolean usedBisection = false; // Flag to track if bisection was used\n\n            do {\n                // If the interpolation interval becomes too small, exit to bisection\n                if (end - start <= 1) {\n                    nextX = Double.NaN; // Signal to use bisection\n                    break;\n                }\n\n                // guess a value for current target, using inverse polynomial interpolation\n                // Pass the original x, y arrays along with the current range [start, end)\n                nextX = guessX(targetY, x, y, start, end);\n\n                if (!((nextX > xA) && (nextX < xB))) {\n                    // Guessed root is not strictly inside the tightest bracketing interval or is NaN.\n                    // Reduce the interpolation interval [start, end).\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // More points before the root estimate, drop the lowest point.\n                        ++start;\n                    } else {\n                        // More points after the root estimate, drop the highest point.\n                        --end;\n                    }\n                    // Signal to retry interpolation with the reduced interval.\n                    nextX = Double.NaN;\n                }\n                // Loop continues if nextX is NaN and the interval size is still > 1.\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n\n            if (Double.isNaN(nextX)) {\n                // Interpolation failed (either didn't produce a value in (xA, xB) or interval became too small).\n                // Fall back to bisection.\n                nextX = xA + 0.5 * (xB - xA);\n                usedBisection = true;\n                // Reset 'start' and 'end' to the full range available before the failed attempt,\n                // as the bisection step doesn't rely on a reduced interpolation range.\n                // This prevents the point management logic below from incorrectly using potentially\n                // shrunk 'start'/'end' values from the failed interpolation attempts.\n                start = 0;\n                end = nbPoints;\n            }\n\n            // evaluate the function at the guessed root (either from interpolation or bisection)\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            // Point management: Update the set of points (x, y) and nbPoints.\n\n            // 1. Shrink arrays if interpolation succeeded with a reduced interval [start, end)\n            //    This means points outside [start, end) were not used and potentially harmful.\n            //    Check usedBisection flag to ensure this only runs when interpolation was successful.\n            if (!usedBisection && (nbPoints > 2) && (end - start != nbPoints)) {\n                // Interpolation succeeded using points in x[start...end-1].\n                // Drop points outside this range permanently.\n                int newNbPoints = end - start;\n                System.arraycopy(x, start, x, 0, newNbPoints);\n                System.arraycopy(y, start, y, 0, newNbPoints);\n                // Adjust signChangeIndex relative to the new array start.\n                // The original signChangeIndex must be mapped to the new coordinate system.\n                signChangeIndex -= start;\n                nbPoints = newNbPoints;\n            }\n            // 2. Drop a point if the array is full before inserting the new point.\n            // Check using x.length which is maximalOrder + 1, the total capacity.\n            else if (nbPoints == x.length) {\n                 nbPoints--; // Decrement count, insertion will increment later.\n                 // Choose which point to drop to keep the sign change index centered.\n                 if (signChangeIndex >= (x.length + 1) / 2) {\n                     // Sign change index is in the upper half, drop the lowest point (index 0).\n                     System.arraycopy(x, 1, x, 0, nbPoints); // nbPoints = x.length - 1 here\n                     System.arraycopy(y, 1, y, 0, nbPoints);\n                     // Adjust signChangeIndex as it's now relative to the shifted array.\n                     signChangeIndex--;\n                 } // else: Drop highest point (index nbPoints = x.length - 1). No copy needed.\n            }\n            // Now nbPoints < x.length, so there is space for insertion.\n\n            // 3. Insert the new point (nextX, nextY) maintaining sorted order of x.\n            int insIndex = 0;\n            // Find insertion point: first index i such that x[i] >= nextX\n            // Check against nbPoints which is the current number of valid points.\n            while (insIndex < nbPoints && nextX > x[insIndex]) {\n                insIndex++;\n            }\n            // Make space for the new point at insIndex.\n            System.arraycopy(x, insIndex, x, insIndex + 1, nbPoints - insIndex);\n            x[insIndex] = nextX;\n            System.arraycopy(y, insIndex, y, insIndex + 1, nbPoints - insIndex);\n            y[insIndex] = nextY;\n            nbPoints++; // Increment point count after insertion.\n\n            // 4. Update the bracketing interval [xA, xB], aging counters, and signChangeIndex.\n            if (nextY * yA <= 0) {\n                // Sign change is between xA and nextX (or nextY == 0). New bracket [xA, nextX].\n                xB    = nextX; // Update xB to the new point\n                yB    = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;     // xA wasn't updated, increment its age\n                agingB = 0;   // xB was updated, reset its age\n            } else {\n                // Sign change must be between nextX and xB (since yA*yB < 0 initially, and yA*nextY > 0).\n                // New bracket [nextX, xB].\n                xA    = nextX; // Update xA to the new point\n                yA    = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;   // xA was updated, reset its age\n                ++agingB;     // xB wasn't updated, increment its age\n            }\n\n            // After updating xA, xB, find the index of the new xB in the updated array x.\n            // This index is the new signChangeIndex (index k where root is in [x_{k-1}, x_k]).\n            signChangeIndex = -1;\n            for (int i = 0; i < nbPoints; i++) {\n                // Use direct comparison; xB is guaranteed to be one of the points in x (either old xB or nextX)\n                if (x[i] == xB) {\n                    signChangeIndex = i;\n                    break;\n                }\n            }\n            if (signChangeIndex == -1){\n                 // This path should theoretically not be reached if xB is properly assigned.\n                 throw new MathInternalError(\"INTERNAL ERROR: Cannot locate bracketing interval endpoint\");\n            }\n\n        } // End of search loop (while true)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}