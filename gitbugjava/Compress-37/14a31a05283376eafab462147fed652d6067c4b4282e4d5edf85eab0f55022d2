{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    // PAX header lines are expected to be UTF-8 encoded.\n    // Assuming globalPaxHeaders is available in the actual class context.\n    // final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Using a new map for standalone function context:\n    final Map<String, String> headers = new HashMap<>(); // In the actual class, initialize with globalPaxHeaders\n\n    // Format is \"length keyword=value\\n\";\n    while(true){ // Process header records\n        int ch;\n        int len = 0;\n        int read = 0; // Bytes read for the current record\n        boolean foundDigit = false; // Flag to track if we've started reading digits for len\n\n        // Parse length field: \"NNN \"\n        while((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') { // End of length field\n                if (foundDigit) { // We successfully read a length\n                    break; // Go to keyword parsing\n                } else {\n                    // Encountered a space before any digits. Invalid format.\n                    throw new IOException(\"Invalid PAX header format: space before digit in length field.\");\n                }\n            }\n            // Handle blank lines (\\n) or unexpected newlines before length digits\n            if (ch == '\\n') {\n                if (!foundDigit) {\n                    // Treat this as the end of the current \"record\" (which is just a newline)\n                    // Skip this blank line and continue to the next record.\n                    // Reset state for the next iteration of the outer loop.\n                    len = 0;\n                    break; // Break inner length loop, the outer loop will check state and continue\n                } else {\n                    // Newline found after digits but before space. Invalid format.\n                    throw new IOException(\"Invalid PAX header format: newline found in length field.\");\n                }\n            }\n            if (ch >= '0' && ch <= '9') {\n                foundDigit = true;\n                final int digit = ch - '0';\n                // Check for potential integer overflow before multiplication/addition\n                // len * 10 + digit > Integer.MAX_VALUE --> len > (Integer.MAX_VALUE - digit) / 10\n                if (len > (Integer.MAX_VALUE - digit) / 10) {\n                     throw new IOException(\"Paxheader length overflow.\");\n                }\n                len = len * 10 + digit;\n            } else {\n                // Non-digit, non-space, non-newline found in length field. Invalid.\n                 if (!foundDigit) {\n                     // First char is invalid\n                     throw new IOException(\"Invalid PAX header format: non-digit found where length expected. Character: \" + (char)ch);\n                 } else {\n                     // Invalid char after digits but before space\n                     throw new IOException(\"Invalid PAX header format: non-digit found in length field after digits. Character: \" + (char)ch);\n                 }\n            }\n        } // End of length parsing loop\n\n        // Check EOF condition\n        if (ch == -1){ // EOF encountered\n            // If we didn't find any digits and read zero bytes, it's a clean EOF.\n            // If we read just a newline (\\n broke the loop) and then hit EOF, also clean.\n            if (!foundDigit && (read == 0 || ch == '\\n')) {\n                break; // Exit outer loop normally\n            }\n            // Otherwise, EOF was unexpected (e.g., mid-length field).\n            throw new IOException(\"Invalid PAX header format: EOF detected prematurely.\");\n        }\n\n        // If we broke the inner loop because ch was '\\n' and !foundDigit (blank line case)\n        if (!foundDigit && ch == '\\n') {\n            // We consumed the newline of a blank line, just continue to the next header record.\n            continue; // Continue outer loop\n        }\n\n        // If we are here, we should have read a valid length (len > 0) and the trailing space.\n        // 'len' includes the length field itself, space, keyword, '=', value, and '\\n'.\n        // 'read' currently holds the number of bytes read for the length field + 1 (for the space).\n\n        // Get keyword up to '='\n        final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n        while((ch = i.read()) != -1) {\n            read++; // Count bytes read for keyword and '='\n            if (ch == '='){ // end of keyword\n                final String keyword = coll.toString(CharsetNames.UTF_8);\n\n                // Calculate remaining bytes for value + '\\n'\n                // Total length is 'len'. We've read 'read' bytes (length + space + keyword + '=').\n                final int valueBytes = len - read;\n\n                // Check for validity: len must accommodate read bytes + at least one byte for '\\n'\n                if (valueBytes <= 0) {\n                    throw new IOException(\"Invalid PAX header. Length \" + len\n                                          + \" <= bytes read for header data \" + read);\n                }\n\n                // Read the value bytes (value + '\\n')\n                final byte[] valueBuffer = new byte[valueBytes];\n                final int got = IOUtils.readFully(i, valueBuffer);\n                if (got != valueBytes) {\n                    // This indicates the stream ended before the declared length was fully read.\n                    throw new IOException(\"Failed to read PAX header value. Expected \"\n                                          + valueBytes\n                                          + \" bytes, read \"\n                                          + got);\n                }\n\n                // Check for the mandatory trailing newline\n                if (valueBuffer[valueBytes - 1] != '\\n') {\n                    throw new IOException(\"Invalid PAX header. Record doesn't end with a newline.\");\n                }\n\n                // Process value based on length\n                if (valueBytes == 1) { // only NL, means keyword removal\n                    headers.remove(keyword);\n                } else {\n                    // Value is buffer content excluding the trailing NL\n                    // Length of value string is valueBytes - 1\n                    final String value = new String(valueBuffer, 0,\n                                              valueBytes - 1, CharsetNames.UTF_8);\n                    headers.put(keyword, value);\n                }\n                break; // Processed this header record successfully, break keyword loop\n            }\n            // Accumulate keyword bytes\n            coll.write((byte) ch);\n        } // End of keyword parsing loop\n\n        if (ch == -1) { // EOF reached while reading keyword or value part\n             // This means the record indicated by 'len' was truncated.\n             throw new IOException(\"Invalid PAX header. EOF detected prematurely in record.\");\n        }\n        // If keyword loop finished normally (found '='), continue outer loop for next record\n    } // End outer loop (while true)\n\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}