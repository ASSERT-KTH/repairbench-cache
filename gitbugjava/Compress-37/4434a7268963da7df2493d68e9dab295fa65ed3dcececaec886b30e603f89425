{
    "generation": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\"; Length is the decimal value of the total size of the record, including the length field itself.\n        while (true) {\n            int ch;\n            long lenL = 0;\n            int lenDigits = 0;\n\n            // 1. Read Length Field: skip leading blank lines, read digits until space.\n            while ((ch = i.read()) != -1) {\n                // Skip leading blank lines (only if we haven't read any digits yet)\n                if (lenDigits == 0 && ch == '\\n') {\n                    continue;\n                }\n                if (ch == ' ') { // End of length field\n                    // Ensure we read some digits before the space\n                    if (lenDigits == 0) {\n                        throw new IOException(\"PAX header record starts with space.\");\n                    }\n                    break; // Found space after digits\n                }\n                if (ch < '0' || ch > '9') {\n                    throw new IOException(\"Unexpected character reading PAX header length: '\" + (char) ch + \"'\");\n                }\n                // Check for potential overflow before multiplication\n                final int digit = ch - '0';\n                // Check for potential overflow: lenL * 10 + digit > Long.MAX_VALUE\n                if (lenL > (Long.MAX_VALUE - digit) / 10) {\n                     throw new IOException(\"Paxheader length overflow detected.\");\n                }\n                lenL = lenL * 10 + digit;\n                lenDigits++;\n            }\n\n            if (ch == -1) { // EOF encountered\n                if (lenDigits == 0) { // Normal EOF after reading all headers (or empty stream/only newlines)\n                    // No more headers found.\n                    return headers;\n                }\n                // EOF after digits but before space\n                throw new IOException(\"Unexpected EOF reading PAX header length/space.\");\n            }\n            // Current char 'ch' is space ' '.\n\n            // Check if length fits in int (needed for array allocation and IOUtils.readFully)\n            if (lenL > Integer.MAX_VALUE) {\n                throw new IOException(\"PAX header length \" + lenL + \" exceeds maximum allowed size\");\n            }\n            final int recordLen = (int) lenL;\n            // Bytes read for length field + space\n            final int lenAndSpaceBytes = lenDigits + 1;\n\n            // 2. Read Keyword field until '='\n            final ByteArrayOutputStream keywordBytes = new ByteArrayOutputStream();\n            int bytesReadInKeyword = 0;\n            while ((ch = i.read()) != -1) {\n                bytesReadInKeyword++;\n                if (ch == '=') { // End of keyword\n                    break;\n                }\n                keywordBytes.write((byte) ch);\n            }\n\n            if (ch == -1) { // EOF while reading keyword\n                throw new IOException(\"Unexpected EOF reading PAX header keyword.\");\n            }\n            // Current char 'ch' is equals '='.\n\n            final String keyword = keywordBytes.toString(CharsetNames.UTF_8);\n            if (keyword.isEmpty()) {\n                throw new IOException(\"PAX header record has empty keyword.\");\n            }\n\n            // 3. Read Value field (including trailing newline)\n            // Total bytes read for the fixed part of the header (length, space, keyword, '=')\n            final int headerPrefixLen = lenAndSpaceBytes + bytesReadInKeyword;\n            // Calculate the expected length of the value + newline part\n            final int expectedValueAndNLLen = recordLen - headerPrefixLen;\n\n            if (expectedValueAndNLLen < 0) {\n                // This indicates declared recordLen is smaller than the actual prefix read\n                throw new IOException(\"Corrupted PAX header: length \" + recordLen\n                                      + \" is smaller than header prefix length \" + headerPrefixLen);\n            }\n\n            // Read the value bytes (value + newline)\n            final byte[] valueAndNL = new byte[expectedValueAndNLLen];\n            final int got = IOUtils.readFully(i, valueAndNL);\n            if (got != expectedValueAndNLLen) {\n                throw new IOException(\"Failed to read PAX header value. Expected \"\n                                      + expectedValueAndNLLen + \" bytes, read \" + got);\n            }\n\n            // The value part must end with a newline. PAX spec implies expectedValueAndNLLen must be >= 1.\n            if (expectedValueAndNLLen == 0) {\n                 // This state should not be possible if recordLen >= headerPrefixLen and the format requires a final newline.\n                 // Example \"8 path=\\n\": recordLen=8, headerPrefixLen=7 (\"8 path=\"). expectedValueAndNLLen=1.\n                 throw new IOException(\"Corrupted PAX header: value length is zero, but header must end in newline\");\n            }\n            if (valueAndNL[expectedValueAndNLLen - 1] != '\\n') {\n                 throw new IOException(\"PAX header record does not end in newline.\");\n            }\n\n            // Process record: remove entry if value consists only of NL, otherwise put entry\n            if (expectedValueAndNLLen == 1) { // Only the newline was present after '='\n                // This corresponds to the PAX command to delete the entry\n                headers.remove(keyword);\n            } else {\n                // Value is the buffer excluding the final newline\n                final String value = new String(valueAndNL, 0, expectedValueAndNLLen - 1, CharsetNames.UTF_8);\n                headers.put(keyword, value);\n            }\n            // Loop for the next header record\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}