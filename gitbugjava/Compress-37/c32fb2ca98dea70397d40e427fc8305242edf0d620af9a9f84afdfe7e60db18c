{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.apache.commons.compress.utils.CharsetNames; // Assuming CharsetNames might still be used elsewhere or by globalPaxHeaders\n\n// Assuming the method is part of a class where globalPaxHeaders is accessible.\n// Example: private Map<String, String> globalPaxHeaders = new HashMap<>();\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    // POSIX specification: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        // Initialize with global headers; subsequent headers override or remove entries.\n        // N.B. A HashMap permits null keys and values, but the PAX standard implies non-null keys and values.\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\"; Length is the total length of the record including length field and NL.\n\n        while (true) { // Outer loop processes one record at a time\n            int ch;\n            int recordLen = 0;\n            int lenFieldLen = 0; // Length of the length field string itself (e.g. \"15\" is 2)\n\n            // 1. Skip leading whitespace before a record starts\n            // This handles blank lines between records.\n            while ((ch = i.read()) != -1) {\n                if (ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t') {\n                    continue; // Skip whitespace\n                }\n                // Found non-whitespace. Break to process it as the start of the length field.\n                break;\n            }\n\n            // Check if EOF reached after skipping whitespace\n            if (ch == -1) {\n                break; // Normal end of stream, no more records\n            }\n\n            // 2. Read the length field (digits)\n            // ch currently holds the first non-whitespace char. It MUST be a digit.\n            final StringBuilder lenBuffer = new StringBuilder();\n            while (ch != -1 && ch != ' ') {\n                if (ch < '0' || ch > '9') {\n                    // If the first char wasn't digit OR subsequent char not digit/space\n                    if (lenBuffer.length() == 0) { // First non-whitespace char was not a digit\n                        // Assume this signifies the end of the PAX headers block, as headers must start with digits.\n                        // We cannot push back 'ch', but the caller (TarArchiveInputStream) likely handles\n                        // transitions between header types based on block content. Returning here is okay.\n                        return headers;\n                    } else { // Found non-digit after some digits, but before the space: Corruption\n                        throw new IOException(\"Corrupted PAX header: non-digit '\" + (char)ch + \"' found in length field.\");\n                    }\n                }\n                lenBuffer.append((char)ch);\n                // A more robust check could use BigInteger or long, but standard tar implementations might have limits.\n                // We rely on Integer.parseInt check later for overflow.\n                ch = i.read(); // Read next char\n            }\n\n            // Check termination condition of length reading loop\n            if (ch == -1) { // EOF occurred before the space was found\n                // If lenBuffer is empty, it means EOF was hit immediately after skipping whitespace.\n                if (lenBuffer.length() == 0) {\n                    break; // Normal EOF\n                }\n                throw new IOException(\"Corrupted PAX header: EOF encountered while reading length field digits.\");\n            }\n            // Now ch must be ' ' (space)\n\n            lenFieldLen = lenBuffer.length();\n            if (lenFieldLen == 0) {\n                 // This case handles where only a space was found after skipping whitespace.\n                 throw new IOException(\"Corrupted PAX header: read empty length field.\");\n            }\n\n            try {\n                recordLen = Integer.parseInt(lenBuffer.toString());\n            } catch (final NumberFormatException nfe) {\n                 // Handle potential overflow if length string exceeds Integer.MAX_VALUE\n                 throw new IOException(\"Corrupted PAX header: invalid length number format or overflow '\" + lenBuffer + \"'.\", nfe);\n            }\n\n            if (recordLen < 0) { // Negative length is invalid\n                throw new IOException(\"Corrupted PAX header: negative length \" + recordLen);\n            }\n\n            // Calculate the length of the prefix (\"LENGTH<space>\") that was read.\n            final int recordPrefixLen = lenFieldLen + 1; // bytes for digits + 1 byte for space\n\n            // 3. Read the record body (keyword=value\\n)\n            // Total length specified is 'recordLen'. Prefix read is 'recordPrefixLen'.\n            // The remaining length for the body is:\n            final int remainingLen = recordLen - recordPrefixLen;\n\n            // Must have at least 1 byte for NL. Realistic minimum is \"=\\n\" (2 bytes).\n            // A length field requires at least 3 bytes (\"0 \\n\"), so recordLen >= 3.\n            // Therefore, recordLen >= recordPrefixLen implies remainingLen >= 0.\n            // We need remainingLen >= 1 for the newline.\n            if (remainingLen < 1) {\n                 throw new IOException(\"Corrupted PAX header: Declared length \" + recordLen + \" is smaller than prefix length \"\n                                       + recordPrefixLen + \". Requires space for at least newline.\");\n            }\n\n            // Read the exact number of bytes for the body\n            final byte[] recordBody = new byte[remainingLen];\n            final int got = IOUtils.readFully(i, recordBody);\n            if (got != remainingLen) {\n                 // This typically means the input stream ended unexpectedly or the declared 'recordLen' was incorrect.\n                 throw new IOException(\"Failed to read PAX record body. Expected \" + remainingLen + \" bytes, but received \" + got + \".\");\n            }\n\n            // 4. Parse and validate the record body (keyword=value\\n)\n            // Ensure the record ends with a newline character.\n            if (recordBody[remainingLen - 1] != '\\n') {\n                throw new IOException(\"Corrupted PAX header: record does not end in newline.\");\n            }\n\n            // Find the position of the '=' separator within the body (excluding the final NL).\n            int eqPos = -1;\n            for (int j = 0; j < remainingLen - 1; j++) {\n                if (recordBody[j] == '=') {\n                    eqPos = j;\n                    break;\n                }\n            }\n\n            // Check if '=' was found.\n            if (eqPos == -1) {\n                throw new IOException(\"Corrupted PAX header: missing '=' character.\");\n            }\n\n            // Extract keyword (bytes before '=') using UTF-8 encoding.\n            final String keyword = new String(recordBody, 0, eqPos, StandardCharsets.UTF_8);\n\n            // Calculate value length (bytes after '=' and before the final '\\n').\n            final int valueStartPos = eqPos + 1;\n            // length = (last_index - first_index + 1)\n            // last_index = remainingLen - 2 (byte before newline)\n            // length = (remainingLen - 2) - valueStartPos + 1 = remainingLen - valueStartPos - 1\n            final int valueLen = remainingLen - 1 - valueStartPos;\n\n            // Check calculated valueLen, should not be negative if eqPos is valid.\n             if (valueLen < 0) {\n                 throw new IOException(\"Internal error calculating PAX header value length: \" + valueLen);\n             }\n\n            // Per POSIX spec, an empty value means the keyword should be removed.\n            if (valueLen == 0) {\n                headers.remove(keyword);\n            } else {\n                // Extract value using UTF-8 encoding.\n                final String value = new String(recordBody, valueStartPos, valueLen, StandardCharsets.UTF_8);\n                headers.put(keyword, value);\n            }\n            // Record processed successfully, continue loop for the next record.\n        } // End while(true)\n\n        // EOF reached after skipping whitespace, indicating a clean end to PAX headers.\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}