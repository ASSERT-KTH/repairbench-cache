{
    "generation": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.IOUtils;\n// Assuming globalPaxHeaders is accessible in the actual class context, e.g., a field:\n// private final Map<String, String> globalPaxHeaders;\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    // POSIX Standard: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        // Use the global Pax headers as a base\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while (true) {\n            int ch;\n            int len = 0;\n            int len_read = 0; // Bytes read for the length field itself + space\n\n            // Read first char to determine state\n            ch = i.read();\n            if (ch == -1) { // Normal EOF at the start of a record\n                break;\n            }\n            len_read++;\n\n            // Skip lines that do not start with a digit (POSIX requirement)\n            // This handles blank lines or other non-conforming lines gracefully.\n            if (ch < '0' || ch > '9') {\n                // Consume until newline or EOF\n                while ((ch = i.read()) != -1 && ch != '\\n') {\n                    // Skip character\n                }\n                if (ch == -1) { // EOF found while skipping non-digit line\n                    break; // Treat as end of headers\n                }\n                // Found newline, continue to the next potential record\n                continue;\n            }\n\n            // It's a digit, parse the length field\n            len = ch - '0';\n            while ((ch = i.read()) != -1) {\n                len_read++;\n                if (ch == ' ') { // End of length field\n                    break; // Break from length parsing loop\n                }\n                if (ch < '0' || ch > '9') {\n                    // If we see a non-digit before space, the length field is malformed.\n                     throw new IOException(\"Malformed PAX header: invalid character '\" + (char)ch\n                                           + \"' in length field at position \" + len_read);\n                }\n\n                // Check for potential integer overflow before calculation\n                // Use long to prevent intermediate overflow during check\n                long nextLen = (long)len * 10 + (ch - '0');\n                if (nextLen > Integer.MAX_VALUE) {\n                     throw new IOException(\"Malformed PAX header: length field overflows integer.\");\n                }\n                len = (int)nextLen;\n            }\n\n            // Check why the length parsing loop exited\n            if (ch == -1) { // EOF encountered before space after starting to read length\n                 throw new IOException(\"Malformed PAX header: EOF encountered reading length field.\");\n            }\n            // Now ch == ' '\n\n            // We have read the length field and the space (len_read bytes).\n            // The total length of the record (including length field, space, keyword, =, value, \\n) is 'len'.\n            // The remaining bytes to read for this record are 'len - len_read'.\n            final int remaining_bytes = len - len_read;\n\n            // Basic validation checks on length\n            if (remaining_bytes < 0) {\n                 throw new IOException(\"Malformed PAX header: Length \" + len\n                                       + \" is smaller than length field itself (\" + len_read + \" bytes).\");\n            }\n            // The smallest possible valid record content after length+space is \"k=\\n\", which is 3 bytes.\n            if (remaining_bytes < 3) {\n                 throw new IOException(\"Malformed PAX header: Record length \" + len\n                                       + \" is too small (\" + remaining_bytes + \" data bytes).\"\n                                       + \" Must contain at least keyword, '=', and '\\\\n'.\");\n            }\n\n\n            // Read the rest of the record data (\"keyword=value\\n\") into a buffer\n            final byte[] record_data = new byte[remaining_bytes];\n            final int got = IOUtils.readFully(i, record_data);\n            if (got != remaining_bytes) {\n                // This indicates truncation (EOF) or stream error\n                throw new IOException(\"Failed to read full Paxheader record data. Expected \"\n                                      + remaining_bytes + \" bytes, but only got \" + got);\n            }\n\n            // Validate the structure of the record data\n            // 1. Must end with a newline character\n            if (record_data[remaining_bytes - 1] != '\\n') {\n                throw new IOException(\"Malformed PAX header: record does not end with newline.\");\n            }\n\n            // 2. Must contain an '=' character somewhere before the final newline\n            int eq_pos = -1;\n            for (int k = 0; k < remaining_bytes - 1; k++) { // Loop up to the byte before the newline\n                if (record_data[k] == '=') {\n                    eq_pos = k;\n                    break;\n                }\n            }\n\n            // Check if '=' was found and if the keyword part is non-empty\n            if (eq_pos < 0) { // '=' not found\n                throw new IOException(\"Malformed PAX header: record missing mandatory '=' character.\");\n            }\n            if (eq_pos == 0) { // Keyword is empty if '=' is the first character\n                throw new IOException(\"Malformed PAX header: record has empty keyword.\");\n            }\n\n            // Extract keyword (bytes from start up to eq_pos)\n            final String keyword = new String(record_data, 0, eq_pos, StandardCharsets.UTF_8);\n\n            // Extract value (bytes from after eq_pos up to the byte before the final newline)\n            final int value_len = remaining_bytes - 1 - (eq_pos + 1); // total data bytes - 1 (for \\n) - (eq_pos + 1) (for keyword and '=')\n            final String value = new String(record_data, eq_pos + 1, value_len, StandardCharsets.UTF_8);\n\n            // Store or remove the header based on the value (POSIX standard: empty value means remove)\n            if (value_len == 0) {\n                headers.remove(keyword);\n            } else {\n                headers.put(keyword, value);\n            }\n            // Successfully processed one record, loop to read the next\n        }\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}