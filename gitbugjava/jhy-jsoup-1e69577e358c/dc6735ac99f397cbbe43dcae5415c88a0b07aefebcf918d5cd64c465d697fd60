{
    "generation": "    URL build() {\n        try {\n            // Manually assemble the URL string using raw components where possible,\n            // to preserve original encoding (like %2B in path), handle IDN hosts,\n            // and then parse with URI for validation and final ASCII string generation.\n\n            // 1. Prepare components\n            String protocol = u.getProtocol();\n            String host = u.getHost();\n            // Apply Punycode to the decoded host provided by u.getHost()\n            String asciiHost = (host != null) ? IDN.toASCII(host) : null;\n            int port = u.getPort();\n            // Use raw components to preserve original encoding as much as possible\n            String rawPath = u.getRawPath();\n            String rawQuery = u.getRawQuery(); // Keep original query raw unless overridden by 'q'\n            String fragment = u.getRef(); // URL.getRef() returns decoded fragment\n            // Use raw user info (available Java 7+) to preserve encoding\n            String rawUserInfo = u.getRawUserInfo();\n\n            // 2. Assemble the URL string\n            StringBuilder urlSb = StringUtil.borrowBuilder();\n            urlSb.append(protocol);\n            urlSb.append(\"://\");\n            if (rawUserInfo != null) {\n                 urlSb.append(rawUserInfo).append('@'); // Append raw user info\n            }\n            // Append host, handling null case (e.g., mailto:)\n            if (asciiHost != null) {\n                urlSb.append(asciiHost);\n            }\n            if (port != -1) {\n                 urlSb.append(':').append(port);\n            }\n\n            // Append Path - ensure '/' separator if needed for authority based URLs\n            // Check if authority is present and path is null or empty\n            boolean hasAuthority = rawUserInfo != null || asciiHost != null;\n            if (rawPath != null && !rawPath.isEmpty()) {\n                // Check if path needs a leading '/' if authority is present but path doesn't start with '/'\n                // (Should generally be handled by URL class structure, but double-check)\n                if (hasAuthority && !rawPath.startsWith(\"/\")) {\n                    urlSb.append('/');\n                }\n                urlSb.append(rawPath);\n            } else if (hasAuthority && (q != null || rawQuery != null || fragment != null)) {\n                 // Add \"/\" between authority and query/fragment if path is empty (common for http/s, ftp)\n                 // Check specific protocols? Or assume common ones need it.\n                 if (\"http\".equals(protocol) || \"https\".equals(protocol) || \"ftp\".equals(protocol)) {\n                     urlSb.append('/');\n                 }\n            }\n\n            // Append Query - use new query 'q' if set, otherwise use original raw query\n            boolean queryAppended = false;\n            if (q != null) { // New query data from .data() methods\n                String queryString = StringUtil.releaseBuilder(q); // Assuming q is the StringBuilder for query params\n                q = null; // Mark as consumed\n                if (queryString != null && !queryString.isEmpty()) {\n                    urlSb.append('?');\n                    // Encode the query string built by application code (e.g. from .data methods)\n                    appendToAscii(queryString, true, urlSb); // spaceAsPlus = true\n                    queryAppended = true;\n                }\n            }\n            // If no new query was appended, use the original raw query from the URL\n            if (!queryAppended && rawQuery != null) {\n                 urlSb.append('?').append(rawQuery);\n            }\n\n            // Append Fragment - encode the original fragment (URL.getRef() provides decoded)\n            if (fragment != null) {\n                urlSb.append('#');\n                appendToAscii(fragment, false, urlSb); // spaceAsPlus = false\n            }\n\n            String assembledUrl = StringUtil.releaseBuilder(urlSb);\n\n            // 3. Parse the assembled string with URI to validate and get final ASCII string.\n            // This step implicitly handles some normalization and ensures the syntax is correct.\n            // It does NOT normalize path segments like \".\" or \"..\". This matches original behavior.\n            URI parsedUri = new URI(assembledUrl);\n\n            // 4. Get the final URL string in ASCII form (correctly handling IDN, percent-encoding)\n            String normUrl = parsedUri.toASCIIString();\n\n            // 5. Create the final URL object\n            // Note: We reassign 'u' field here, as in the original code.\n            u = new URL(normUrl);\n            return u;\n\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException should not happen if appendToAscii uses UTF-8\n            assert Validate.assertFail(e.toString());\n            return u; // Return original URL on failure\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}