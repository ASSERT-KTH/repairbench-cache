{
    "generation": "    URL build() {\n        try {\n            // Create a base URI with scheme, user-info, host, and port.\n            // Path, query, and fragment are initially null.\n            URI baseUri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(), // This is decoded; URI constructor will re-encode it.\n                IDN.toASCII(decodePart(u.getHost())), // Process host with decodePart and IDN.toASCII.\n                u.getPort(),\n                null, // Path component will be applied via resolve.\n                null, // Query component will be added later.\n                null  // Fragment component will be added later.\n            );\n\n            // Get the raw path from the original URL's URI representation.\n            // This preserves existing percent-encodings (e.g., %2B)\n            // and ensures non-ASCII characters are percent-encoded.\n            String pathComponent = u.toURI().getRawPath();\n            \n            // Ensure that http(s) URLs have at least a \"/\" path if original was empty/null.\n            // Other schemes (e.g. mailto:) might have an empty path.\n            if (pathComponent == null || pathComponent.isEmpty()) {\n                if (u.getProtocol().startsWith(\"http\")) { // Covers http and https\n                    pathComponent = \"/\";\n                } else {\n                    pathComponent = \"\"; // Empty path for other schemes like mailto\n                }\n            }\n\n            // Resolve the raw path component against the base URI.\n            // URI.resolve(String) correctly handles pre-encoded path segments\n            // and normalizes (e.g., \".\" and \"..\").\n            URI resolvedUri = baseUri.resolve(pathComponent);\n            String normUrl = resolvedUri.toASCIIString();\n\n            // Append query and fragment if they exist, similar to original logic.\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    // Assuming 'q' is a StringBuilder containing the query key-value pairs.\n                    // And appendToAscii handles encoding them correctly.\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    // u.getRef() returns a decoded fragment. appendToAscii re-encodes it.\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            \n            // Assign the newly built URL string back to u (if this method is part of a builder that reuses 'u').\n            // Or simply return the new URL. The original code does both.\n            u = new URL(normUrl);\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // Fallback logic from the original code.\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}