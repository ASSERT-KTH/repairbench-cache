{
    "generation": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path\n            // and to preserve existing valid percent-encodings in path\n            \n            // Obtain the raw path from u.toURI().getRawPath().\n            // u.toURI() works by calling new URI(u.toString()).\n            // u.toString() (aka u.toExternalForm()) generally produces a spec-compliant URI string.\n            // new URI(String) parses this string. If the path segment in u.toString()\n            // was /%2B32, then getRawPath() will return /%2B32.\n            // If it was /foo\u20acbar, getRawPath() will return /foo%E2%82%ACbar (encoded non-ASCII).\n            // This rawPath is what we need for the new URI constructor's path argument.\n            // If u is opaque (e.g. mailto:foo) or has no path (e.g. http://host),\n            // u.toURI().getRawPath() correctly returns null or \"\" respectively.\n            String rawPath = u.toURI().getRawPath();\n            \n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                rawPath, // use the raw path from u.toURI()\n                null, null // query and fragment appended later so as not to be re-encoded by URI constructor rules for those parts\n            );\n\n            String normUrl = uri.toASCIIString();\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            u =  new URL(normUrl);\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}