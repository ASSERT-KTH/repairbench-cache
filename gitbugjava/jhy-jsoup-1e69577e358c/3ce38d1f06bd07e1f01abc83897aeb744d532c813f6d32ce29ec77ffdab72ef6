{
    "generation": "    URL build() {\n        try {\n            // Build the base URI (scheme, user info, host, port) using the URI class.\n            // The path, query, and fragment components are handled separately to:\n            // 1. Preserve existing percent-encodings in the original URL's path.\n            //    The URI constructor's path argument expects a decoded path, which would then re-encode,\n            //    potentially changing valid existing encodings (e.g., %2B to +).\n            // 2. Allow dynamic appending of new query parameters ('q') and original fragment.\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code conversion for host\n                u.getPort(),\n                null, // Path component is handled separately to preserve existing encodings\n                null, null // Query and fragment are appended later\n            );\n\n            // Start building the full URL string from the base URI.\n            StringBuilder sb = StringUtil.borrowBuilder().append(uri.toASCIIString());\n\n            // Append the original path from the URL directly.\n            // This ensures that any existing percent-encodings (like %2B) are preserved.\n            String path = u.getPath();\n            if (path != null && !path.isEmpty()) {\n                // u.getPath() typically starts with '/' for absolute paths, e.g. /foo\n                // If it's an opaque URI, path might not start with '/' (e.g. mailto:user@host)\n                // However, for HTTP/HTTPS, it typically starts with '/'.\n                // If the base URI doesn't end with a slash, and path doesn't start with one, add one for correctness.\n                // URI.toASCIIString() for scheme://host:port won't have trailing slash.\n                // So append if path exists.\n                if (path.charAt(0) != '/' && !sb.toString().endsWith(\"/\")) { // Defensive: ensure a separator if needed\n                    sb.append('/');\n                }\n                sb.append(path);\n            }\n\n            // Append the new query string 'q' if it exists.\n            // Note: This logic implies 'q' replaces any original query from 'u.getQuery()'.\n            if (q != null) {\n                sb.append('?');\n                appendToAscii(StringUtil.releaseBuilder(q), true, sb); // 'true' for query encoding\n            }\n\n            // Append the original fragment from the URL if it exists.\n            if (u.getRef() != null) {\n                sb.append('#');\n                appendToAscii(u.getRef(), false, sb); // 'false' for fragment encoding\n            }\n\n            String normUrl = StringUtil.releaseBuilder(sb);\n            u = new URL(normUrl); // Create the final URL object from the built string.\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}