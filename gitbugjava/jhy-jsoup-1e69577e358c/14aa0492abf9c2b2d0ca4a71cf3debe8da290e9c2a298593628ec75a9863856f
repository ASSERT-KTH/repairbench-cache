{
    "generation": "    URL build() {\n        try {\n            // 1. Convert URL to URI once to access raw components and handle IDN normalization.\n            // URI handles percent-encoding correctly and preserves original encoding in raw components like path, query, fragment.\n            // It also automatically handles IDN conversion for the host.\n            final URI uri = u.toURI();\n\n            // 2. Start building the final URL string using StringBuilder\n            final StringBuilder sb = StringUtil.borrowBuilder();\n            sb.append(uri.getScheme()).append(\"://\");\n            if (uri.getRawUserInfo() != null)\n                sb.append(uri.getRawUserInfo()).append('@');\n\n            // Host is already appropriately handled (IDN converted to ASCII) by uri.getHost()\n            sb.append(uri.getHost());\n\n            if (uri.getPort() != -1)\n                sb.append(':').append(uri.getPort());\n\n            // Use the raw path to preserve original percent-encoding (e.g., %2B remains %2B, not decoded to +)\n            sb.append(uri.getRawPath());\n\n            // 3. Handle query part: combine original query (if any) and new parameters (if any)\n            final String originalRawQuery = uri.getRawQuery();\n            // 'q' is a StringBuilder field possibly holding pre-encoded key=value pairs for *new* parameters\n            // These are typically added via req.data() or req.query(), which use URLEncoder (+ for space)\n            final String newQuery = (q != null) ? StringUtil.releaseBuilder(q) : null;\n            q = null; // q is now released (or was null), reset field\n\n            if (originalRawQuery != null) {\n                // Append original query part (preserving its encoding)\n                sb.append('?').append(originalRawQuery);\n                if (newQuery != null) {\n                    // Append new query parameters after the original ones, using '&' separator\n                    sb.append('&').append(newQuery);\n                }\n            } else if (newQuery != null) {\n                // Append new query parameters as the only query part, using '?' separator\n                sb.append('?').append(newQuery);\n            }\n\n            // 4. Handle fragment part: use the raw fragment to preserve original encoding\n            final String rawFragment = uri.getRawFragment();\n            if (rawFragment != null) {\n                sb.append('#').append(rawFragment);\n            }\n\n            // 5. Create the final URL object from the constructed string\n            final String normUrl = StringUtil.releaseBuilder(sb);\n            u = new URL(normUrl); // URL constructor parses the potentially complex final string\n            return u;\n\n        } catch (URISyntaxException | MalformedURLException e) {\n            // URISyntaxException: Can happen if the original URL 'u' is malformed wrt URI spec (e.g. invalid characters like '|' not properly escaped).\n            // MalformedURLException: Can happen if the final constructed normUrl string is somehow invalid for the URL constructor.\n\n            // Ensure 'q' StringBuilder is released if it was somehow held due to exception path.\n            if (q != null) {\n                try { StringUtil.releaseBuilder(q); } catch (IllegalArgumentException ignored) {}\n                q = null; // reset field\n            }\n\n            // Log the failure for debugging / testing via assertion.\n            // In production (assertions disabled), return the original URL as a fallback.\n            assert Validate.assertFail(\"Could not build normalized URL: \" + e);\n            return u; // Return the original URL\n        }\n        // Note: Removed UnsupportedEncodingException from catch block as it's not directly thrown by URI/URL methods used,\n        // and appendToAscii (which could throw it) is no longer used here. URLEncoder used elsewhere wraps it.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}