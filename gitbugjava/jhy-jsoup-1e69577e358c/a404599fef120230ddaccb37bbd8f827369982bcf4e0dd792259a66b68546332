{
    "generation": "    URL build() {\n        try {\n            // Determine the path component for the URI.\n            // u.getFile() is used because it preserves percent-encodings like %2B,\n            // unlike u.getPath() which decodes them (e.g., %2B becomes +).\n            // The URI constructor, when given a path like \"/%2B32\", will keep it as is.\n            // If given a path like \"/caf\u00e9\", it will encode non-ASCII characters (e.g., to \"/caf%C3%A9\").\n            // This behavior correctly handles both preserving intentional encodings and encoding unencoded characters.\n            String pathForUri;\n            String file = u.getFile(); // file is in format /path[?query]\n\n            if (file == null || file.isEmpty()) {\n                // Handles cases like \"http://example.com\" where u.getFile() is \"\".\n                // For HTTP/S, an empty file implies an empty path.\n                // u.getPath() would also be \"\" in such cases for an HTTP URL.\n                pathForUri = \"\";\n            } else {\n                int queryIndex = file.indexOf('?');\n                if (queryIndex != -1) {\n                    // Strip the query part to get just the path\n                    pathForUri = file.substring(0, queryIndex);\n                } else {\n                    pathForUri = file;\n                }\n            }\n\n            // use the URI class to encode non-ascii in path\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                pathForUri, // Use the path derived from u.getFile()\n                null, null // query and fragment appended later so as not to encode them by URI constructor\n            );\n\n            String normUrl = uri.toASCIIString();\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    // q is already URL-encoded (application/x-www-form-urlencoded)\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    // u.getRef() returns a decoded fragment; appendToAscii will re-encode it.\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            u =  new URL(normUrl); // Update the request's 'u' field\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8 (or if decodePart from host is removed)\n            assert Validate.assertFail(e.toString());\n            return u; // On error, return the original URL 'u'\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}