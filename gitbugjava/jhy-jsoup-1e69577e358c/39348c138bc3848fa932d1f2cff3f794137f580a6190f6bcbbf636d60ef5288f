{
    "generation": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path, and preserve original path encoding\n            String host = null;\n            if (u.getHost() != null) {\n                // Apply IDN to the host part. u.getHost() should return the decoded host name.\n                host = IDN.toASCII(u.getHost()); // Puny-code host\n            }\n\n            // Construct URI using the raw path to preserve original percent-encoding like %2B\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                host, // Already Puny-coded if necessary\n                u.getPort(),\n                u.getRawPath(), // Use the raw path from the original URL object\n                null, // query and fragment appended later so as not to double-encode\n                null\n            );\n\n            String normUrl = uri.toASCIIString(); // Get the base URL string (scheme, authority, path)\n\n            // Append query and fragment based on 'q' builder and original fragment reference\n            // This logic might drop the original query/fragment if q and ref are null.\n            if (q != null || u.getRef() != null) { // Check if new query or original fragment exists\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    // Append the query string built from the 'q' StringBuilder\n                    sb.append('?');\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    // Append the fragment, re-encoding the decoded version from u.getRef()\n                    // This matches original logic. Might alter original fragment encoding in some cases.\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n\n            // Create the final URL object using the final normalized URL string\n            URL finalURL = new URL(normUrl);\n            // The original code reassigned 'u = finalURL'. Returning the new URL is cleaner.\n            // If 'u' must be updated as a side effect, the original assignment should be kept.\n            // Assuming returning the new URL is the primary goal:\n            return finalURL;\n\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen with IDN.toASCII or if appendToAscii uses UTF-8\n            assert Validate.assertFail(e.toString());\n            return u; // Return the original, unmodified URL object 'u' on failure\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}