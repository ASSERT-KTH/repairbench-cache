{
    "generation": "import java.io.UnsupportedEncodingException;\nimport java.net.IDN;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\n// Assuming StringUtil, Validate, appendToAscii, q, u are available in the context.\n// q is likely a StringBuilder, u is the original URL object.\n\n    URL build() {\n        try {\n            // 1. Normalize host\n            // URL.getHost() is specified to return decoded host (punycode decoded, unicode)\n            String host = u.getHost();\n            String asciiHost = host; // default to original host\n            if (host != null) {\n                boolean needsEncoding = false;\n                for (int i = 0; i < host.length(); i++) {\n                    // Check for non-ASCII characters\n                    if (host.charAt(i) > 127) {\n                        needsEncoding = true;\n                        break;\n                    }\n                }\n                if (needsEncoding) {\n                    try {\n                        // Convert non-ASCII host to punycode according to IDN standard\n                        asciiHost = IDN.toASCII(host);\n                    } catch (IllegalArgumentException e) {\n                        // Host is invalid (e.g. too long, invalid chars as per IDN), return original URL.\n                        // MalformedURLException might be thrown later by new URL() if host is syntactically invalid.\n                        assert Validate.assertFail(\"Failed to normalize host \" + host + \": \" + e);\n                        // Return original URL 'u' as the build failed due to invalid host for IDN processing.\n                        return u;\n                    }\n                }\n            }\n\n            // 2. Get Raw Path from URL object to preserve original path encoding\n            // URL.getFile() returns the raw path and query component (e.g., \"/path%20here?query=1\")\n            String file = u.getFile();\n            String rawPath;\n            // Split file into path and query based on the '?' delimiter\n            int queryInFile = file.indexOf('?');\n            if (queryInFile != -1) {\n                rawPath = file.substring(0, queryInFile);\n                // The query part extracted from 'file' is ignored here.\n                // If 'q' is provided, it replaces the original query. If 'q' is null, the original query is dropped.\n            } else {\n                rawPath = file; // No query part, file is just the raw path\n            }\n            // Handle edge case: if URL was constructed like \"http://example.com/\"\n            // getFile() might be \"/\" but getPath() would be \"/\".\n            // If URL was \"http://example.com\", getFile() is \"\" and getPath() is \"\".\n            // Ensure path is \"/\" if the original URL's path component indicates it should be root.\n            if (rawPath.isEmpty() && \"/\".equals(u.getPath())) {\n                 rawPath = \"/\"; // Ensure root path \"/\" is preserved if it was the intended path\n            }\n\n            // 3. Manually build the final URL string component by component\n            StringBuilder finalUrl = StringUtil.borrowBuilder();\n            finalUrl.append(u.getProtocol()).append(\"://\");\n            if (u.getUserInfo() != null) {\n                // Append user info. Assumes u.getUserInfo() returns the correct string representation.\n                // Note: RFC 3986 requires userinfo to be percent-encoded. If u.getUserInfo() isn't, this might be incorrect.\n                finalUrl.append(u.getUserInfo()).append('@');\n            }\n            finalUrl.append(asciiHost); // Use normalized host (punycode if needed)\n            if (u.getPort() != -1) {\n                finalUrl.append(':').append(u.getPort());\n            }\n\n            // Append the raw path extracted earlier, preserving its original encoding (e.g., %2B)\n            finalUrl.append(rawPath);\n\n            // 4. Append query ('q' overrides original) and fragment (original preserved)\n            // This logic replicates the behavior of the original code block.\n            if (q != null || u.getRef() != null) {\n                if (q != null) {\n                    // Append the new query string provided in 'q'.\n                    finalUrl.append('?');\n                    // appendToAscii encodes the query string; assumes 'q' is a StringBuilder managed by StringUtil\n                    appendToAscii(StringUtil.releaseBuilder(q), true, finalUrl);\n                }\n                // Note: if q == null, the original query (from u.getFile()) is dropped.\n\n                if (u.getRef() != null) {\n                    // Append the original fragment identifier.\n                    finalUrl.append('#');\n                    // appendToAscii encodes the fragment; assumes u.getRef() is a String\n                    appendToAscii(u.getRef(), false, finalUrl);\n                }\n            }\n\n            // Convert the final built string to a URL object.\n            String normUrl = StringUtil.releaseBuilder(finalUrl);\n            return new URL(normUrl);\n\n        } catch (MalformedURLException | UnsupportedEncodingException e) {\n             // MalformedURLException from new URL(normUrl) if the reconstructed string is invalid.\n             // UnsupportedEncodingException from appendToAscii (should not happen with standard UTF-8).\n             assert Validate.assertFail(\"Failed to build URL: \" + e);\n             // In case of failure, return the original, unmodified URL object.\n             return u;\n        }\n        // Note: Removed URISyntaxException catch block as java.net.URI is no longer the primary mechanism.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}