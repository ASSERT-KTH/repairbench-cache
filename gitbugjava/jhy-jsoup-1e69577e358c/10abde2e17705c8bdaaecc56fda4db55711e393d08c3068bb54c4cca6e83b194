{
    "generation": "    URL build() {\n        URL originalUrlOnError = u; // Keep a reference to the original URL for the catch block\n        try {\n            // Use getRaw variants where possible to preserve original encoding, esp. path\n            String protocol = u.getProtocol();\n            String userInfo = u.getRawUserInfo();\n            String host = u.getHost(); // getHost is decoded, needed for IDN.toASCII\n            int port = u.getPort();\n            String path = u.getRawPath(); // getRawPath preserves encoding like %2B\n            String fragment = u.getRef(); // getRef is decoded, consistent with appendToAscii logic below\n\n            // Normalize host using IDN\n            String asciiHost = null;\n            if (host != null) {\n                // Preserve [] host notation for IPv6, as required by URI. Passing []'d host to IDN.toASCII is OK\n                asciiHost = IDN.toASCII(host);\n            }\n\n            // Assemble the base URL string (scheme, authority, path) manually.\n            // This avoids the URI multi-arg constructor which expects decoded path and can modify existing valid escapes.\n            StringBuilder baseUriStr = StringUtil.borrowBuilder();\n            if (protocol != null) {\n                 baseUriStr.append(protocol).append(\":\");\n            }\n            boolean hasAuthority = (userInfo != null || asciiHost != null || port != -1); // Authority consists of userInfo, host, port\n            if (hasAuthority) {\n                baseUriStr.append(\"//\");\n                if (userInfo != null && !userInfo.isEmpty()) {\n                    // Append raw user info - avoid re-encoding potentially valid escapes\n                    baseUriStr.append(userInfo).append('@');\n                }\n                if (asciiHost != null) {\n                    // host is normalized ASCII via IDN\n                    baseUriStr.append(asciiHost);\n                }\n                if (port != -1) {\n                    baseUriStr.append(':').append(port);\n                }\n            }\n\n            // Append path - use raw path to preserve encoding\n            if (path != null && !path.isEmpty()) {\n                 // Ensure path starts with / if authority is present and path is not already absolute\n                 if (hasAuthority && !path.startsWith(\"/\")) {\n                     baseUriStr.append('/');\n                 }\n                baseUriStr.append(path);\n            } else if (hasAuthority) {\n                 // If authority is present but path is null or empty, the path component should be \"/\"\n                 baseUriStr.append('/');\n            } else if (path == null || path.isEmpty()) {\n                // If no authority and path is empty/null, ensure path is represented if needed (e.g., file: requires path)\n                // However, for http/https, this state (no authority, empty path) is unusual.\n                // Let URI parsing handle implications. If path is truly null/empty, don't append anything here.\n            }\n\n\n            // Create a URI from the manually assembled string. This parses the string components, including the raw path.\n            // This constructor preserves valid percent-escapes in the path.\n            URI uri = new URI(StringUtil.releaseBuilder(baseUriStr)); // baseUriStr is released here\n\n            // Use toASCIIString() - this should correctly represent the URI components in ASCII,\n            // preserving the original path encoding handled by the URI(string) constructor.\n            String normUrl = uri.toASCIIString();\n\n            // Check if we need to append query and/or fragment\n            boolean needsQuery = q != null && q.length() > 0;\n            boolean needsFragment = fragment != null;\n\n            String queryString = null;\n            if (needsQuery) {\n                 // Release q's builder *here* to get the full query string. q might be null if no data() called.\n                 // This assumes q contains the *decoded* query string to be appended and encoded.\n                 queryString = StringUtil.releaseBuilder(q);\n            }\n\n\n            if (needsQuery || needsFragment) {\n                // If query or fragment needs appending, borrow a new builder\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (needsQuery) {\n                    sb.append('?');\n                    // appendToAscii encodes the decoded query string for ASCII output\n                    appendToAscii(queryString, true, sb);\n                }\n                if (needsFragment) {\n                    sb.append('#');\n                    // appendToAscii encodes the decoded fragment string for ASCII output\n                    appendToAscii(fragment, false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb); // release sb here\n            }\n\n            // Create the final URL from the normalized string\n            URL finalUrl = new URL(normUrl);\n            // Only assign to u on success? Original code assigned u = new URL(...) then returned u.\n            // Let's return the new URL directly. The caller will handle the assignment if needed.\n            return finalUrl; // Return the newly built URL\n\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException | IllegalArgumentException e) {\n            // Added IllegalArgumentException for URI constructor/parsing errors\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException should not happen as appendToAscii uses UTF8\n            assert Validate.assertFail(e.toString() + \"       Could not normalize URL '\" + originalUrlOnError.toString() + \"'\"); // Add URL to assert message\n            return originalUrlOnError; // Return original URL on failure\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}