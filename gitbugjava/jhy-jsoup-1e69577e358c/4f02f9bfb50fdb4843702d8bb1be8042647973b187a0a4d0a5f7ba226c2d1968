{
    "generation": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path. The URI class will correctly handle existing % encoding.\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code host\n                u.getPort(),\n                u.getPath(), // Pass the path directly, don't decode first\n                null, null // query and fragment appended later so as not to encode using URI constructor\n            );\n\n            String normUrl = uri.toASCIIString(); // Get the properly encoded URI string ( \u0c2a\u0c25 part)\n            \n            // Append query and fragment, encoding them manually\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    // appendToAscii needs to handle encoding of the query string parts correctly\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    // appendToAscii needs to handle encoding of the fragment correctly\n                    // u.getRef() returns the decoded fragment, so it needs encoding\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            \n            // Create the final URL object from the normalized string\n            // Note: Reassigning 'u' here shadows the input 'u' but matches original logic.\n            URL finalUrl = new URL(normUrl); \n            return finalUrl; // Return the newly constructed URL\n            \n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u; // Return the original, unmodified URL on error\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}