{
    "generation": "    URL build() {\n        try {\n            // use the URI class to encode non-ascii in path, but preserve existing % encoding\n            URI uri = new URI(\n                u.getProtocol(),\n                u.getUserInfo(),\n                IDN.toASCII(decodePart(u.getHost())), // puny-code\n                u.getPort(),\n                preserveEncodedParts(u.getPath()),\n                null, null // query and fragment appended later so as not to encode\n            );\n\n            String normUrl = uri.toASCIIString();\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n            u =  new URL(normUrl);\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n\n    private String preserveEncodedParts(String path) {\n        if (path == null) return null;\n        StringBuilder sb = new StringBuilder();\n        int start = 0;\n        while (start < path.length()) {\n            int percentIndex = path.indexOf('%', start);\n            if (percentIndex == -1) {\n                sb.append(path.substring(start));\n                break;\n            }\n            if (percentIndex + 2 >= path.length()) {\n                // Not enough characters for a valid % encoding, treat as literal\n                sb.append(path.substring(start));\n                break;\n            }\n            try {\n                // Check if the % encoding is valid\n                String encoded = path.substring(percentIndex, percentIndex + 3);\n                int codePoint = Integer.parseInt(encoded.substring(1), 16);\n                sb.append(path, start, percentIndex);\n                sb.append(encoded);\n                start = percentIndex + 3;\n            } catch (NumberFormatException e) {\n                // Invalid % encoding, treat as literal\n                sb.append(path.substring(start, percentIndex + 1));\n                start = percentIndex + 1;\n            }\n        }\n        return sb.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}