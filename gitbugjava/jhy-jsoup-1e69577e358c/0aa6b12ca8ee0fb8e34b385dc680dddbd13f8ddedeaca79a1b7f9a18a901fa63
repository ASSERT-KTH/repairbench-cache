{
    "generation": "    URL build() {\n        try {\n            // Strategy: Manually reconstruct the URL string, applying IDN to the host,\n            // and using the raw path from the URI representation to preserve original path encoding.\n            // This avoids the URI multi-argument constructor's re-encoding behavior which can\n            // change valid percent escapes like %2B into different characters like +.\n\n            // Use URI to parse the original URL and access components reliably.\n            // u.toURI() preserves original encoding, especially in the path.\n            URI uri = u.toURI();\n\n            String scheme = uri.getScheme();\n            String userInfo = uri.getRawUserInfo();\n            String host = uri.getHost(); // Decoded host, suitable for IDN.toASCII\n            // Use port from original URL u, as uri.getPort() returns -1 for default ports,\n            // but u.getPort() might contain an explicitly specified default port.\n            int port = u.getPort();\n            String path = uri.getRawPath(); // Raw path with original encoding preserved\n\n            // URI raw path can be null for opaque URIs, or empty. Ensure it's handled.\n            if (path == null) path = \"\";\n\n            // Apply IDN encoding (Punycode) to the host, null safe\n            String asciiHost = null;\n            if (host != null) {\n                 // IDN.toASCII handles conversion of internationalized domain names.\n                 // It should pass through IP addresses and regular hostnames unchanged.\n                 asciiHost = IDN.toASCII(host);\n            }\n\n            // Build the authority part string for reconstruction\n            String authorityString = null;\n            // Check if authority exists at all in the original URI (could be \"\" e.g. file:///)\n            if (uri.getRawAuthority() != null) {\n                StringBuilder authoritySb = StringUtil.borrowBuilder();\n                 if (userInfo != null) {\n                     authoritySb.append(userInfo).append('@');\n                 }\n                 if (asciiHost != null) {\n                     // Handle IPv6 literal address format - enclose in brackets if needed\n                     // URI correctly handles IPv6 bracketization in getHost/getAuthority,\n                     // but IDN.toASCII might return a bare IPv6 literal. Check and bracketize.\n                    if (asciiHost.indexOf(':') >= 0 && !asciiHost.startsWith(\"[\") && !asciiHost.endsWith(\"]\")) {\n                        authoritySb.append('[').append(asciiHost).append(']');\n                    } else {\n                        authoritySb.append(asciiHost);\n                    }\n                 }\n                 // Append port only if specified explicitly in the original URL 'u' (port != -1)\n                 if (port != -1) {\n                     authoritySb.append(':').append(port);\n                 }\n                 authorityString = StringUtil.releaseBuilder(authoritySb);\n\n                 // Handle edge case: if authority components are all null/empty (e.g., file:///),\n                 // the reconstructed authorityString might be empty. If the original raw authority\n                 // was non-null (like \"\"), preserve it as an empty string to ensure \"//\" is added.\n                 if (authorityString.isEmpty() && uri.getRawAuthority() != null) {\n                     // This keeps authorityString as \"\" if the raw authority was present but empty.\n                 } else if (authorityString.isEmpty() && uri.getRawAuthority() == null) {\n                     // If raw authority was null and reconstruction is empty, set authorityString back to null.\n                     authorityString = null;\n                 }\n            }\n\n\n            // Reconstruct the URL string up to the path\n            StringBuilder urlSb = StringUtil.borrowBuilder();\n            urlSb.append(scheme).append(':');\n            if (authorityString != null) { // If authority exists (including \"\" for file:///)\n                urlSb.append(\"//\").append(authorityString);\n            }\n            // Append the raw path, ensuring it starts with / if authority is present and path isn't empty/absolute\n             if (authorityString != null && path.length() > 0 && path.charAt(0) != '/') {\n                 urlSb.append('/'); // Ensure path starts with slash if authority present\n             }\n            urlSb.append(path); // Append the raw path\n\n            String base = StringUtil.releaseBuilder(urlSb); // Base URL string (scheme, authority, path)\n\n            // Now, append query and fragment based on original logic\n            String normUrl;\n            // Check if we need to append query (from 'q' or original) or fragment (from 'u.getRef()' or original)\n            boolean hasQuery = (q != null || uri.getRawQuery() != null);\n            boolean hasFragment = (u.getRef() != null || uri.getRawFragment() != null);\n\n            if (hasQuery || hasFragment) {\n                 StringBuilder sb = StringUtil.borrowBuilder().append(base);\n                 if (q != null) { // Prioritize external query builder 'q'\n                     sb.append('?');\n                     // appendToAscii handles encoding the query string built in 'q'\n                     appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                 } else if (uri.getRawQuery() != null) {\n                     // Preserve the original raw query string if no external 'q' is provided\n                     sb.append('?').append(uri.getRawQuery());\n                 }\n\n                 if (u.getRef() != null) { // Prioritize external ref from 'u' (assumed decoded)\n                     sb.append('#');\n                     // appendToAscii encodes the (presumably decoded) fragment from u.getRef()\n                     appendToAscii(u.getRef(), false, sb);\n                 } else if (uri.getRawFragment() != null) {\n                     // Preserve the original raw fragment string if no ref from 'u'\n                     sb.append('#').append(uri.getRawFragment());\n                 }\n                 normUrl = StringUtil.releaseBuilder(sb);\n            } else {\n                 // Neither query nor fragment needs appending or modification\n                 normUrl = base;\n            }\n\n            // Construct the final URL object from the normalized string.\n            // The original code updated the 'u' field: u = new URL(normUrl);\n            // Assuming this side-effect is intended.\n            u = new URL(normUrl);\n            return u;\n\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would likely never happen. URISyntaxException unlikely with this approach.\n            assert Validate.assertFail(e.toString());\n            return u; // Return original URL on failure\n        } catch (IllegalArgumentException e) {\n            // IDN.toASCII can throw IllegalArgumentException for invalid hostnames\n             assert Validate.assertFail(e.toString());\n             return u; // Return original URL on failure\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}