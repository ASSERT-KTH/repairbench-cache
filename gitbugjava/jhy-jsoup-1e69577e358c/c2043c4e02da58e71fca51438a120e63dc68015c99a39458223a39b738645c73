{
    "generation": "    URL build() {\n        try {\n            // Normalize host (Punycode) and assemble the URL, preserving path encoding.\n            // The java.net.URI component constructor expects decoded path and re-encodes,\n            // which can alter existing valid percent-encodings (e.g., %2B becomes +).\n            // To preserve existing path encoding, we build the URL string by appending the raw path.\n\n            String protocol = u.getProtocol();\n            String userInfo = u.getUserInfo();\n            // Host is decoded for IDN.toASCII, then re-encoded by URI (as Punycode)\n            String host = IDN.toASCII(decodePart(u.getHost()));\n            int port = u.getPort();\n\n            // Build the URI for scheme, authority only (host, user info, port).\n            // Path, query, fragment will be appended manually to preserve existing encoding.\n            URI uriAuthority = new URI(\n                protocol,\n                userInfo,\n                host,\n                port,\n                null, null, null // No path, query, fragment\n            );\n\n            StringBuilder sb = StringUtil.borrowBuilder();\n            sb.append(uriAuthority.toASCIIString());\n\n            // Append the path from the original URL.\n            // URL.getPath() returns the path including percent-escaped characters (e.g., %2B, %C3%A9).\n            // This preserves existing encodings and handles non-ASCII characters correctly.\n            String path = u.getPath();\n            if (path != null && !path.isEmpty()) {\n                // The path returned by URL.getPath() already includes the leading `/` if absolute, or is empty.\n                // So, no need to add an extra `/` here.\n                sb.append(path);\n            }\n\n            // Append query and fragment parts (already handled by Jsoup's appendToAscii, which re-encodes decoded strings)\n            if (u.getQuery() != null) {\n                sb.append('?');\n                appendToAscii(u.getQuery(), true, sb); // u.getQuery() returns decoded query string\n            }\n            if (u.getRef() != null) {\n                sb.append('#');\n                appendToAscii(u.getRef(), false, sb); // u.getRef() returns decoded fragment string\n            }\n\n            String normUrl = StringUtil.releaseBuilder(sb);\n            u = new URL(normUrl); // Re-create URL from the normalized string\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // we assert here so that any incomplete normalization issues can be caught in devel. but in practise,\n            // the remote end will be able to handle it, so in prod we just pass the original URL.\n            // The UnsupportedEncodingException would never happen as always UTF8\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}