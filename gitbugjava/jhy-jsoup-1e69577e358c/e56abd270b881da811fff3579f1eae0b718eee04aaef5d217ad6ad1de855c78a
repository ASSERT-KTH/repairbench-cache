{
    "generation": "    URL build() {\n        try {\n            // Parse the external form of the URL to access raw components and determine opacity\n            URI originalUri = new URI(u.toExternalForm());\n\n            String normUrl;\n\n            if (originalUri.isOpaque()) {\n                // For opaque URIs, the \"path\" is the scheme-specific part (SSP).\n                // Host, port, userInfo are typically null or undefined for opaque URIs.\n                // u.getPath() returns the SSP for opaque URLs.\n                URI opaqueUri = new URI(\n                    u.getProtocol(),\n                    decodePart(u.getPath()), // The SSP, decoded by our custom decodePart\n                    null // Fragment is handled later\n                );\n                normUrl = opaqueUri.toASCIIString();\n            } else { // Hierarchical URI\n                // Process host: apply decodePart then IDN.toASCII for Punycode.\n                String host = u.getHost(); // host from the input URL object\n                if (host != null) {\n                    // decodePart is expected to handle any (unusual) percent-encodings in the host string\n                    // before passing to IDN.toASCII. For typical hostnames, it should be a no-op.\n                    host = IDN.toASCII(decodePart(host));\n                }\n\n                // Construct a temporary URI for the base part (scheme, userinfo, host, port).\n                // The path is set to \"/\" to ensure the resulting string ends with a slash,\n                // facilitating easy concatenation with the rawPath later.\n                URI tempBaseUri = new URI(\n                    u.getProtocol(),\n                    u.getUserInfo(),\n                    host, // Processed host\n                    u.getPort(),\n                    \"/\", // Placeholder path\n                    null, null // Query and fragment are handled later\n                );\n                String basePartString = tempBaseUri.toASCIIString(); // E.g., \"https://example.com/\"\n\n                // Get the raw path from the original URI to preserve its specific percent-encodings.\n                String rawPath = originalUri.getRawPath(); // E.g., \"/%2B32\" or \"/path with space\" (will be %20 encoded)\n\n                if (rawPath == null || rawPath.isEmpty()) {\n                    // If the original URL had no path (e.g., \"http://example.com\"),\n                    // rawPath will be empty. basePartString (e.g. \"http://example.com/\") is already correct.\n                    normUrl = basePartString;\n                } else {\n                    // Concatenate the scheme/authority part with the raw path.\n                    // basePartString ends with \"/\", rawPath usually starts with \"/\".\n                    // Remove trailing \"/\" from basePartString before appending rawPath.\n                    // e.g., \"https://example.com/\" (len-1) -> \"https://example.com\"\n                    // then + \"/%2B32\" -> \"https://example.com/%2B32\"\n                    normUrl = basePartString.substring(0, basePartString.length() - 1) + rawPath;\n                }\n            }\n\n            // Append query string and fragment, similar to the original code.\n            // `q` refers to `this.queryBuf` (a StringBuilder field in HttpConnection.Request)\n            if (q != null || u.getRef() != null) {\n                StringBuilder sb = StringUtil.borrowBuilder().append(normUrl);\n                if (q != null) {\n                    sb.append('?');\n                    // StringUtil.releaseBuilder(q) gets the string from q, then clears and caches q.\n                    appendToAscii(StringUtil.releaseBuilder(q), true, sb);\n                    q = null; // Mark queryBuf as consumed/reset.\n                }\n                if (u.getRef() != null) {\n                    sb.append('#');\n                    appendToAscii(u.getRef(), false, sb);\n                }\n                normUrl = StringUtil.releaseBuilder(sb);\n            }\n\n            u = new URL(normUrl); // Update the request's URL object\n            return u;\n        } catch (MalformedURLException | URISyntaxException | UnsupportedEncodingException e) {\n            // Fallback to original URL on error, asserting in dev.\n            // UnsupportedEncodingException is not expected as UTF-8 is always used.\n            assert Validate.assertFail(e.toString());\n            return u;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}