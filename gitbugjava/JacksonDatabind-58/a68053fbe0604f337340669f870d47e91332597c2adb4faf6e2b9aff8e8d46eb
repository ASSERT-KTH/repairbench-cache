{
    "generation": "    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        if (ctxt.canOverrideAccessModifiers()) {\n            // 14-Jan-2016, tatu: Let's implement explicit check for Throwable.cause, see\n            //    [databind#1089] for details.\n            // 28-Jul-2017, tatu: As per [databind#1706], need to check for AnnotatedField,\n            //    not just AnnotatedMethod\n            Class<?> rawSettingType = beanDesc.getBeanClass();\n            if (mutator == null) {\n                 // 14-Mar-2017, tatu: Ideally should not happen... but maybe if certain mix-ins added?\n                ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                        \"No non-constructor mutator available\");\n                 // ... but should we throw exception or just ignore? Seems like latter is better\n                 return null; // or throw exception?\n            }\n\n            // 18-Nov-2017, tatu: Wait. Let's check `propDef.getName()` instead of `mutator.getName()`;\n            //   latter may differ.\n            // 01-Mar-2021, tatu: And actually let's use declaring class of field/method, not `beanDesc`\n            if (propDef.getName().equals(\"cause\") && mutator instanceof AnnotatedField) {\n                if (Throwable.class == mutator.getDeclaringClass()) {\n                    // cannot and should not try to force access to Throwable.cause\n                } else {\n                    // otherwise fine to try forcing access\n                    mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n            } else {\n                // otherwise fine to try forcing access\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        // 28-Jul-2017, tatu: As per [databind#1706], need to check for AnnotatedField, not just Method\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            // Must be a field. Note check above for null mutator\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}