{
    "generation": "    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n\n        // As.WRAPPER_OBJECT structure is { typeName : value }\n        // Usually caller should have positioned parser at START_OBJECT.\n        // But potentially, ObjectId handling might have consumed START_OBJECT\n        // and first field (\"@id\"), leaving parser at the FIELD_NAME which\n        // indicates the type. So let's handle either START_OBJECT or FIELD_NAME.\n        JsonToken t = p.getCurrentToken();\n        if (t == JsonToken.START_OBJECT) {\n            // If START_OBJECT, advance to FIELD_NAME\n            t = p.nextToken();\n        } else if (t != JsonToken.FIELD_NAME) {\n            // If it's not START_OBJECT or FIELD_NAME, structure is wrong\n             throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n        // Note: current token MUST be FIELD_NAME state at this point\n        if (t != JsonToken.FIELD_NAME) {\n             throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n        }\n\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        \n        // And then the value itself; should be START_OBJECT\n        if (p.nextToken() != JsonToken.START_OBJECT) {\n             throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                     String.format(\"expected START_OBJECT after type id (%s) forSUB type of %s\", typeId, baseTypeName()));\n        }\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible) {\n            // Similar to how As.PROPERTY Injectable values work,\n            // let's merge type id as the first property\n            // 11-Jun-2015, tatu: As per [databind#796] need to create non-closing parser\n             TokenBuffer tb = new TokenBuffer(p, ctxt);\n             tb.writeStartObject(); // recreate START_OBJECT\n             tb.writeFieldName(_typePropertyName);\n             tb.writeString(typeId);\n\n            // Ok, then we need to merge this field sequence with the value token sequence.\n            // NOTE: need to point buffer parser to the first token too\n            // 20-Nov-2017, tatu: We seem to be missing START_OBJECT validation still...\n             //JsonParser bufferParser = tb.asParser(p); // old code\n             // Need context of 'p' for buffer parser?\n             JsonParser bufferParser = tb.asParser();\n             bufferParser.nextToken(); // skip START_OBJECT from buffer\n\n             p = JsonParserSequence.createFlattened(false, bufferParser, p);\n            // and need to point p to START_OBJECT as well\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n\n        // And then need the closing END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}