{
    "generation": "    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization. Assumes parser is positioned at the FIELD_NAME\n     * that contains type id.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // NOTE: assuming caller got us to the FIELD_NAME with type id\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n\n        // Current token should be FIELD_NAME (based on caller contract)\n        if (p.currentToken() != JsonToken.FIELD_NAME) {\n             // This should not happen based on caller guarantees, but let's add a check just in case\n             throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n        }\n\n        final String typeId = p.currentName();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        // And then advance to the value token:\n        p.nextToken();\n\n        Object value;\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible) {\n            // If type id is visible, value must be START_OBJECT for buffering to work\n            if (p.currentToken() != JsonToken.START_OBJECT) {\n                throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                        String.format(\"Object value expected for property '%s' (visible type id)\", typeId));\n            }\n            // Need to recreate the parser to merge type id with actual data\n            // 29-Sep-2015, tatu: This seems potentially problematic; but basically\n            //   it means we can't yet use `JsonParserSequence` as we need to possibly\n            //   access the original parser...\n            // Easiest way is to use TokenBuffer; serialize this token, then\n            // copy the rest.\n            TokenBuffer tb = new TokenBuffer(p, ctxt);\n            tb.writeStartObject(); // recreate START_OBJECT\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n\n            // Keep track of original parser to check END_OBJECT later\n            JsonParser originalParser = p;\n            // Copy structure like \"id\" : \"computer-1\", \"location\" : \"Bangkok\" }\n            // Needs to be done AFTER we have read the START_OBJECT for value, so:\n            tb.copyCurrentStructure(p); // Consumes p, leaves it AFTER value's }\n\n            p = tb.asParser(); // Switch parser to token buffer\n            // Need to move to the first token of the merged structure\n            p.nextToken(); // START_OBJECT\n\n            // Now deserialize from the buffer\n            value = deser.deserialize(p, ctxt);\n\n            // Check that the wrapper object is closed using the original parser state\n            // (which should be positioned after the value object's END_OBJECT)\n            JsonToken closing = originalParser.nextToken();\n            if (closing != JsonToken.END_OBJECT) {\n                 // Use original parser for context, but expected token is END_OBJECT\n                 throw ctxt.wrongTokenException(originalParser, JsonToken.END_OBJECT,\n                          \"expected closing END_OBJECT after type information and deserialized value (got \"+closing+\")\");\n            }\n            // originalParser is now at the wrapper's END_OBJECT.\n        } else { // type id not visible\n            // Value token should still be START_OBJECT\n             if (p.currentToken() != JsonToken.START_OBJECT) {\n                 throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                          String.format(\"Object value expected for property '%s'\", typeId));\n             }\n            // Deserialize directly from the original parser 'p'\n            value = deser.deserialize(p, ctxt); // Should consume value object, leave p AT value's }\n\n            // And then need the closing END_OBJECT\n            // Need to advance parser past value's END_OBJECT to find wrapper's END_OBJECT\n            JsonToken closing = p.nextToken();\n            if (closing != JsonToken.END_OBJECT) {\n                throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT, // p is now at the incorrect token\n                        \"expected closing END_OBJECT after type information and deserialized value (got \"+closing+\")\");\n            }\n            // Parser 'p' is now positioned at the wrapper's END_OBJECT\n        }\n        return value;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}