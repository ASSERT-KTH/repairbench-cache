{
    "generation": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     *\n     * @param u an integer\n     * @param v an integer\n     * @return the greatest common divisor, never zero (unless u=v=0)\n     * @throws ArithmeticException if the gcd calculation results in an overflow\n     *                             (typically when the result would be {@code 2^31})\n     * @since 1.1 (Modified based on Commons Math 2.0 logic for bug fix MATH-201)\n     */\n    public static int gcd(int u, int v) {\n        // Handle 0 inputs and Integer.MIN_VALUE corners\n        // Note: gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) = 2^31, which overflows int.\n        // gcd(Integer.MIN_VALUE, 0) = 2^31, which overflows int.\n        // gcd(Integer.MIN_VALUE, x) where x is representable as -x in int.\n        if (u == 0 || v == 0) {\n            if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u) + Math.abs(v);\n        }\n\n        // Keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow).\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) = 2^31\n            // gcd(Integer.MIN_VALUE, 0) handled above.\n            // gcd(Integer.MIN_VALUE, x) if x!=0 and x is MIN_VALUE/2^k will reach here.\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n\n        // B2. Initialize: u or v is odd at this point.\n        // Use the initialization from Commons Math 2.0 fix (MATH-201)\n        // If u is odd, t = v; otherwise t = u.\n        int t = ((u & 1) == 1) ? v : u;\n\n        // B3/B4: Initial cast out twos from t. From here on, t is always odd.\n        while ((t & 1) == 0) { // while t is even..\n            t /= 2; // cast out twos\n        }\n\n        // B5/B6/B3/B4 loop (from Commons Math 2.0 fix)\n        do {\n            /* assert u<0 && v<0; */\n            // B5 [reset max(u,v)]\n            // Now t is odd. Assign it back to u or v.\n            // Also, note that (-t) must be representable as a positive int\n            // unless t is Integer.MIN_VALUE; however, t starts as u or v,\n            // and then becomes (v-u)/2 after reduction. Since u and v are\n            // not MIN_VALUE here (checked earlier), t cannot be MIN_VALUE.\n            if (t > 0) { // corresponds to |v| > |u|\n                u = -t; // u is now negative odd.\n            } else {     // corresponds to |u| >= |v|\n                v = t;  // v is now negative odd.\n            }\n\n            // B6/B3. At this point both u and v should be odd.\n            // t = (|u| - |v|) / 2; using v-u or u-v gives same abs value.\n            // The difference v-u is now guaranteed to be even.\n            t = (v - u) / 2;\n\n            // B3/B4: Cast out twos from the new t.\n            while ((t & 1) == 0) {\n                t /= 2;\n            }\n        } while (t != 0); // B6: Repeat until t is 0.\n\n        // gcd is -u*2^k where u is the negative number representing the odd part of the gcd.\n        // The result must be returned as a positive integer.\n        // Since -u is the odd part, -u cannot be Integer.MIN_VALUE.\n        // The final result is -u * 2^k. Check for overflow.\n        if (k > 0 && -u == (1 << (31-k))) { // Check if -u * 2^k would be 2^31\n             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        return -u * (1 << k); // gcd is |u|*2^k\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}