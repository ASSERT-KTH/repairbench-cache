{
    "generation": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.NodeUtil;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.Warnings;\n// Assuming T is JSType or can be cast from JSType\n// Assuming relevant member variables (compiler, propertiesToErrorFor, typeSystem etc.) exist\n// Assuming Property class and getProperty method exist\n// Assuming TypeSystem<T> typeSystem and processProperty method exist\n\n    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Child node is STRING_KEY, GETTER_DEF, SETTER_DEF, or MEMBER_FUNCTION_DEF\n        // Use NodeUtil to get the key name robustly. Handles quoted/unquoted keys, getters, setters.\n        String name = NodeUtil.getObjectLitKeyName(child);\n        if (name == null) {\n          // This indicates an unexpected structure or a key type we don't handle.\n          // MEMBER_FUNCTION_DEF nodes are handled by handleFunction if needed by the pass. Skip here.\n          if (!child.isMemberFunctionDef()) {\n             // TODO(user): Consider logging or reporting an error for unexpected child types.\n          }\n          continue;\n        }\n\n        Property prop = getProperty(name);\n\n        // Determine the type of the object that this literal initializes or represents.\n        // This is the type on which the properties should be recorded for disambiguation.\n        JSType ownerType = null;\n        Node parent = n.getParent();\n        if (parent != null) {\n           // Case 1: Assignment, e.g., obj.prop = { key: value } or Class.prototype = { key: value }\n           // Check if the object literal 'n' is the RHS of an ASSIGN node.\n           if (parent.isAssign() && n == parent.getLastChild()) {\n             Node lhs = parent.getFirstChild();\n             // The type of the LHS is the context type we need.\n             ownerType = lhs.getJSType();\n           // Case 2: Variable declaration, e.g., var x = { key: value }\n           // Check if the object literal 'n' is the initializer for a NAME node in a VAR declaration.\n           } else if (parent.isName() && n == parent.getLastChild()) {\n             Node gramps = parent.getParent();\n             if (gramps != null && gramps.isVar()) {\n                // The type of the variable (NAME node) is the context type.\n                ownerType = parent.getJSType();\n             }\n           // Case 3: Property value in another object literal, e.g., var obj = { outer: { inner: value } }\n           // Check if the object literal 'n' is the value associated with a STRING_KEY.\n           } else if (parent.isStringKey() && n == parent.getLastChild()) {\n              // The relevant type is often the type inferred for the object literal 'n' itself,\n              // which might reflect the structure { outer: { inner: ... } }.\n              ownerType = n.getJSType();\n           // Case 4: Return statement: return { ... }\n           } else if (parent.isReturn() && n == parent.getFirstChild()) {\n               // Use the type inferred for the object literal 'n'. This might be influenced\n               // by the function's declared or inferred return type.\n               ownerType = n.getJSType();\n           // Case 5: Function argument: foo({ ... }), or new Foo({ ... })\n           // Check if 'n' is an argument to a CALL or NEW node (and not the function itself).\n           } else if ((parent.isCall() || parent.isNew()) && n != parent.getFirstChild()) {\n               // Use the type inferred for the object literal 'n'. Type inference might\n               // propagate parameter type information to the argument node.\n               ownerType = n.getJSType();\n           }\n           // Other potential contexts (e.g., array literals, default parameter values) could be added if necessary.\n        }\n\n        // If we couldn't determine the owner type from common expression contexts,\n        // fall back to the JSType attached to the OBJECTLIT node itself by type inference.\n        if (ownerType == null) {\n            ownerType = n.getJSType();\n        }\n\n        // DisambiguateProperties uses JSType as T.\n        // We need to provide the JSType to processProperty.\n        JSType typeForProp = ownerType;\n\n        // Skip processing if the determined type is null, unknown, or too general ({*}).\n        // Associating properties with such types provides no useful information for disambiguation\n        // and could lead to incorrect results.\n        if (typeForProp == null || typeForProp.isAllType() || typeForProp.isUnknownType()) {\n           continue;\n        }\n\n        // Process the property occurrence using the determined owner type.\n        // processProperty updates the property's type information and returns the resolved type.\n        // We need to cast JSType to T, assuming T is JSType or a compatible supertype.\n        @SuppressWarnings(\"unchecked\")\n        T resolvedType = processProperty(t, prop, (T) typeForProp, null);\n\n        // Schedule the property key node (child) for potential renaming based on the gathered type info.\n        // scheduleRenaming returns false if this occurrence creates a type conflict (invalidation).\n        if (!prop.scheduleRenaming(child, resolvedType)) {\n          // Renaming failed, likely due to type invalidation. Report error if configured to do so.\n          if (propertiesToErrorFor.containsKey(name)) {\n            // Report the invalidation error using the standard warning format.\n            String ownerTypeName = typeForProp.toString();\n            // prop.getType() should return the first/representative type recorded for this property. Use \"?>\" if null.\n            String firstTypeName = (prop.getType() == null ? \"<?>\" : prop.getType().toString());\n\n            compiler.report(JSError.make(\n                t.getSourceName(),\n                child, // Location of the error (the property key node, e.g., 'a' in {'a':0})\n                propertiesToErrorFor.get(name), // Specific error message template from the map\n                Warnings.INVALIDATION, // Standard warning category for this type of conflict\n                name, // {0} Property name (e.g., \"a\")\n                ownerTypeName, // {1} Conflicting type name (the type where it's being redefined/used incompatibly)\n                firstTypeName // {2} Original type name (the type where it was first defined/used)\n                ));\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}