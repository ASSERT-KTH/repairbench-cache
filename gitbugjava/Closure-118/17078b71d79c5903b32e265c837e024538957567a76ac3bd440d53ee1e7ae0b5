{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Child node types can be:\n        // STRING_KEY: Represents a standard property `{ key: value }` or `{ 'key': value }`.\n        // GETTER_DEF: Represents a getter `get key() { ... }`.\n        // SETTER_DEF: Represents a setter `set key(v) { ... }`.\n        // MEMBER_FUNCTION_DEF: Represents a method shorthand `key() { ... }`.\n        // COMPUTED_PROPERTY: Represents `{ [expr]: value }`.\n\n        // Computed properties cannot be renamed.\n        if (child.isComputedProp()) {\n          continue;\n        }\n\n        // Get the property name. This works for STRING_KEY, GETTER_DEF, SETTER_DEF, MEMBER_FUNCTION_DEF.\n        String name = child.getString();\n        // It might be null for computed properties if not handled above, or unexpected nodes.\n        if (name == null) {\n             continue;\n        }\n\n        T type = typeSystem.getType(getScope(), n, name);\n        Property prop = getProperty(name);\n        boolean schedule = true;\n\n        // Quoted keys in object literals indicate programmer intent not to rename or\n        // compatibility with external code. Do not schedule these for renaming.\n        // Check if the node represents a string key and if it's quoted.\n        // Node.isStringKey() checks if the node type is Token.STRING_KEY.\n        // Node.isQuotedString() checks the QUOTED_PROP marker on the node.\n        if (child.isStringKey() && child.isQuotedString()) {\n            schedule = false;\n        }\n        // GETTER_DEF, SETTER_DEF, MEMBER_FUNCTION_DEF, and unquoted STRING_KEY should be scheduled.\n\n        // Process the property to update type information regardless of scheduling.\n        boolean changed = processProperty(t, prop, type, null);\n\n        if (schedule) {\n          // Schedule renaming only if it's an eligible property definition.\n          if (!prop.scheduleRenaming(child, changed)) {\n            // Report error if scheduling failed for a property we intended to rename.\n            if (propertiesToErrorFor.containsKey(name)) {\n              compiler.report(JSError.make(\n                  t.getSourceName(), child, propertiesToErrorFor.get(name),\n                  Warnings.INVALIDATION, name,\n                  (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n            }\n          }\n        }\n        // If schedule is false (e.g., quoted key), we intentionally don't schedule\n        // renaming and thus don't report an error here if scheduling \"fails\".\n        // Invalidation might still occur due to other accesses, handled elsewhere.\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}