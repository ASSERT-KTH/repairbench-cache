{
    "generation": "    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header (must be at least 512 bytes long)\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-335\">COMPRESS-335</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(final byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        boolean checksumFound = false; // Have we started parsing octal digits?\n        boolean checksumStop = false;  // Should we stop parsing octal digits?\n        int digitsParsed = 0;          // Count of parsed octal digits\n\n        // CHKSUMLEN is 8\n        // CHKSUM_OFFSET is 148\n        final int checksumFieldEnd = CHKSUM_OFFSET + CHKSUMLEN;\n\n        for (int i = 0; i < header.length; i++) {\n            final byte currentByte = header[i];\n            byte byteForSumming = currentByte; // Byte value to use for sum calculation\n\n            if (CHKSUM_OFFSET <= i && i < checksumFieldEnd) {\n                // --- Handle checksum field bytes for parsing storedSum ---\n                if (!checksumStop && digitsParsed < 6) { // Only parse if not stopped and less than 6 digits found\n                    if (currentByte == ' ' && !checksumFound) {\n                        // Skip leading spaces\n                    } else if (currentByte == 0 || currentByte == ' ') {\n                        // Null or space terminates the checksum field parsing\n                        checksumStop = true;\n                    } else if (currentByte >= '0' && currentByte <= '7') {\n                        // Found an octal digit\n                        checksumFound = true;\n                        storedSum = storedSum * 8 + (currentByte - '0');\n                        digitsParsed++;\n                        if (digitsParsed == 6) { // Stop parsing once 6 digits are found\n                            checksumStop = true;\n                        }\n                    } else {\n                        // Found a non-octal, non-space, non-NUL character after starting. Stop parsing.\n                        checksumStop = true;\n                    }\n                }\n                // --- Summing: ALWAYS treat checksum field bytes as spaces (' ') ---\n                byteForSumming = ' ';\n            }\n\n            // Add the byte value (original or space replacement) to sums\n            unsignedSum += 0xff & byteForSumming;\n            signedSum += byteForSumming;\n        }\n\n        // Check if the calculated sum (unsigned or signed) matches the stored sum\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}