{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                @Override\n                public int compare(EventState es0, EventState es1) {\n                    // comparing event occurrence time\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            // Check all events to see if they occur during the step\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            // Process events occurring during the step\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove(); // Remove the current event from the set for processing\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                // CLONE the state BEFORE triggering events/handlers,\n                // as they may modify the state passed to them\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // Advance all event states to the event time.\n                // This is necessary to ensure that the g-function values are evaluated\n                // at the precise event time, required before checking stop() or reset().\n                // It's also crucial for consistent state updates across all handlers.\n                // Use the state obtained AFTER the previous step processing and BEFORE any reset/stop.\n                for (EventState state : eventsStates) {\n                    // Update the state's internal checkpoints G-values, time etc.\n                    state.stepAccepted(eventT, eventY); // Uses the state 'eventY' at time eventT\n                }\n\n                // Check if the current event requests stopping\n                isLastStep = currentEvent.stop();\n\n                // Call step handlers for the portion of the step up to the event\n                // Pass the isLastStep flag reflecting the decision from the current event.\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // The event requested to stop integration.\n                    // Update the main state vector y to the state at event time.\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    // The function returns eventT, signaling the integration loop to stop.\n                    return eventT;\n                }\n\n\n                // Check if the current event requests resetting state.\n                // Note: The reset() method might modify the eventY array directly.\n                boolean needReset = currentEvent.reset(eventT, eventY); // eventY may be modified by reset()\n                if (needReset) {\n                    // The event handler has triggered a state change requiring derivatives recomputation.\n                    // Update the main state vector y with the post-reset state.\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    // Recompute derivatives with the new state.\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true; // Signal the integrator to restart the step from eventT.\n                    // The function returns eventT, signaling the integration loop to handle the reset.\n                    return eventT;\n                }\n\n                // Event did not stop or reset the state.\n                // The integration continues from the event time.\n                previousT = eventT; // The next segment starts from the event time.\n                interpolator.setSoftPreviousTime(eventT); // Adjust interpolator boundaries for the next segment.\n                interpolator.setSoftCurrentTime(currentT); // The step end time remains the same.\n\n                // Re-evaluate ALL events for the remaining interval [eventT, currentT].\n                // This is crucial because:\n                // 1. An event handler might have changed the state indirectly, affecting other events.\n                // 2. An event might be recurring and trigger again in the remaining interval.\n                // 3. Numerical precision might require re-evaluation.\n                // Clear the previous findings.\n                occuringEvents.clear();\n                // Check all registered events again.\n                for (final EventState state : eventsStates) {\n                    // state.stepAccepted(eventT, eventY) was already called, updating internal state (g0, t0).\n                    // Now check if it triggers in the new interval [eventT, currentT]\n                    if (state.evaluateStep(interpolator)) { // This uses the updated g0, t0 and interpolator interval [eventT, currentT]\n                        occuringEvents.add(state);\n                    }\n                }\n                // The loop continues with the (potentially empty) set of events for the remaining interval.\n            } // End of event processing loop\n\n            // No more events detected in the interval [previousT, currentT].\n            // previousT is the time of the start of the step, or the time of the last event handled.\n\n            // Process the final segment of the step: [previousT, currentT].\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState(); // State at the end of the step.\n\n            // Update the internal state of all event detectors to the end of the step time.\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY); // Use state at currentT\n                // Do NOT check stop() here. Stop is only determined at the exact event time.\n            }\n            // Check if the end of the integration range has been reached.\n            isLastStep = Precision.equals(currentT, tEnd, 1);\n\n\n            // Call step handlers for the final segment of the step.\n            // Ensure the interpolator is restricted to the final interval [previousT, currentT].\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(currentT);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            // Update the main state vector y with the final state at currentT.\n            // This is essential for the case where the step completes without events stopping/resetting.\n            System.arraycopy(currentY, 0, y, 0, y.length);\n\n            // Return the time at the end of the completed step.\n            return currentT;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}