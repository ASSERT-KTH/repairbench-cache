{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    // comparing NaN values is bad, default to returning 0\n                    // which will throw an exception in the TreeSet\n                    if(Double.isNaN(es0.getEventTime()) || Double.isNaN(es1.getEventTime())) {\n                       return 0;\n                    }\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            // Initialize the set of occuring events for the current step interval\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            boolean stepFinished = false;\n            while (!stepFinished) {\n\n                if (occuringEvents.isEmpty()) {\n                    // No more events detected in the remaining interval [previousT, currentT]\n                    stepFinished = true;\n\n                } else {\n                    // handle the chronologically first event\n                    final Iterator<EventState> iterator = occuringEvents.iterator();\n                    final EventState currentEvent = iterator.next();\n                    // Note: We do not remove the event from the set now.\n                    // If the event does not stop or reset the integration, we will need to\n                    // re-evaluate all events for the remaining time interval, including this one.\n\n                    // restrict the interpolator to the first part of the step, up to the event\n                    final double eventT = currentEvent.getEventTime();\n                    interpolator.setSoftPreviousTime(previousT);\n                    interpolator.setSoftCurrentTime(eventT);\n\n                    // get state at event time\n                    interpolator.setInterpolatedTime(eventT);\n                    // we need to clone the state because it may be modified by the event handler\n                    final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                    // advance all event states to the event time\n                    for (EventState state : eventsStates) {\n                        state.stepAccepted(eventT, eventY);\n                    }\n\n                    // handle the consequences of the event occurrence\n                    isLastStep = currentEvent.stop();\n\n                    // handle the step, notifying step handlers\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, isLastStep);\n                    }\n\n                    if (isLastStep) {\n                        // the event asked to stop integration\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        // The step and integration end here\n                        return eventT;\n                    }\n\n                    boolean needReset = currentEvent.reset(eventT, eventY);\n                    if (needReset) {\n                        // some event handler has triggered changes that\n                        // invalidate the derivatives, we need to recompute them\n                        System.arraycopy(eventY, 0, y, 0, y.length);\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                        // The step ends here, and the integrator will start a new step from eventT\n                        return eventT;\n                    }\n\n                    // Event handler has continued integration, prepare handling of the remaining part of the step\n                    previousT = eventT;\n                    interpolator.setSoftPreviousTime(eventT);\n                    interpolator.setSoftCurrentTime(currentT);\n\n                    // Re-evaluate all events for the remaining interval [eventT, currentT]\n                    // The previous check might have been impacted by the state change at eventT\n                    // or by the time advancement. We need a fresh evaluation.\n                    occuringEvents.clear();\n                    for (final EventState state : eventsStates) {\n                        // Evaluate the G function over the new interval [eventT, currentT]\n                        if (state.evaluateStep(interpolator)) {\n                            // the event occurs during the remaining part of the step\n                            occuringEvents.add(state);\n                        }\n                    }\n                    // Continue loop with the updated set of occurring events\n                }\n            }\n\n            // The step has been processed successfully up to currentT (no stop or reset event occurred)\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState(); // State at the end of the step\n            // Ensure all events states have their internal states updated to currentT\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                // Check if any event triggers a stop condition exactly at the end of the step\n                // NOTE: This behavior might depend on the event handler's logic for stop()\n                isLastStep = isLastStep || state.stop();\n            }\n            // The step is also the last one if it reaches the final integration time\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the full step or the remaining part, notifying step handlers\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}