{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   * 2) If the function body has side effects, arguments must not be expressions\n   *    that are sensitive to side effects.\n   *    For instance, this will not be inlined:\n   * <pre>\n   *    function foo(a){ modifyX(); return a; }\n   *    x = foo(getX()); // getX() might be affected by modifyX()\n   * </pre>\n   * <pre>\n   *    function foo(a){ x.prop = 2; return a; }\n   *    y = foo(x.prop); // x.prop evaluation depends on when side effect happens\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n    // An empty function can always be inlined.\n    // Avoid checking hasChildren() if block is not a block (e.g. concise arrow body)\n    if (block.isBlock() && !block.hasChildren()) {\n      return CanInlineResult.YES;\n    }\n\n    // Function body must be a block node. We don't handle arrow function\n    // concise bodies for this type of inlining.\n    if (!block.isBlock()) {\n        return CanInlineResult.NO;\n    }\n\n    // Determine if the function body has side effects. This is important\n    // for checking interactions with argument evaluation order.\n    boolean FNScopeBlockHasSideEffects = NodeUtil.mayHaveSideEffects(block, compiler);\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Adjust for 'this' argument in '.call'\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          // We can't inline if 'this' is not passed using .call.\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext(); // Skip 'this' argument.\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n\n    // Iterate through arguments and parameters simultaneously.\n    while (cArg != null || fnParam != null) {\n\n      // Store parameter information if a parameter exists for the current position.\n      String paramName = null;\n      int refCount = 0; // Default reference count (0 indicates parameter unused or non-existent)\n      if (fnParam != null) {\n          paramName = fnParam.getString();\n          // Determine the number of times the parameter is referenced in the function body.\n          refCount = NodeUtil.getNameReferenceCount(block, paramName);\n      }\n\n      // Check argument properties if an argument exists for the current position.\n      if (cArg != null) {\n          boolean argMayEffectMutableState = NodeUtil.mayEffectMutableState(cArg, compiler);\n          boolean argMayHaveSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);\n          // Check if the evaluation of the argument itself could be affected by side effects.\n          boolean argCanBeSideEffected = NodeUtil.canBeSideEffected(cArg);\n\n          // Check 1: Disallow if a mutable argument (like object/array) is passed to\n          // a parameter that is referenced more than once. Inlining might create\n          // unexpected shared references or modify the object multiple times.\n          // Example: function f(a) { a.x=1; return a.y; }; f(obj); // Aliasing `obj`\n          if (paramName != null && argMayEffectMutableState && refCount > 1) {\n              return CanInlineResult.NO;\n          }\n\n          // Check 2: Disallow if an argument has side effects (like i++, function call) AND\n          // its corresponding parameter is used zero times (side effect lost) or multiple\n          // times (side effect incorrectly repeated). It's only safe if used exactly once.\n          // Note: refCount is 0 if paramName is null (meaning it's an extra argument).\n          // Example: function f(a) { return 1; }; f(i++); => NO (refCount=0 -> side effect lost)\n          // Example: function f() { }; f(i++); => NO (refCount=0 -> side effect lost)\n          // Example: function f(a) { return a; }; f(i++); => OK (refCount=1)\n          // Example: function f(a) { return a+a; }; f(i++); => NO (refCount=2 -> side effect occurs twice)\n          if (argMayHaveSideEffects && refCount != 1) {\n               return CanInlineResult.NO;\n          }\n\n          // Check 3: Disallow if the function body has side effects AND the evaluation of\n          // an argument could potentially be altered by those side effects. Inlining\n          // would change the order of evaluation relative to the side effects.\n          // Example: function f(a) { x=1; return a; }; f(x); // Inline may read x before assignment\n          // Example: function f(a) { modify(); return a; }; f( T.x ); // modify() might change T.x\n          if (FNScopeBlockHasSideEffects && argCanBeSideEffected) {\n               return CanInlineResult.NO;\n          }\n      }\n\n      // Move to the next argument and parameter.\n      if (cArg != null) {\n          cArg = cArg.getNext();\n      }\n      if (fnParam != null) {\n          fnParam = fnParam.getNext();\n      }\n    }\n\n    // If none of the checks failed, inlining is considered safe.\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}