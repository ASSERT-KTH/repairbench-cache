{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   * 2) If the function has side-effects, arguments that are not simple\n   * locals or literals (e.g. \"obj.prop\" or \"arr[0]\") cannot be inlined if\n   * the corresponding parameter is used, because the side-effect might change\n   * the value of the argument between the time it is evaluated and the time\n   * it is used.\n   * <pre>\n   *     function foo(a) { x=1; return a; }\n   *     y = foo(obj.prop); // Inlining would change behavior if x=1 modifies obj.prop\n   * </pre>\n   * 3) Function uses 'arguments' or is var_args (unsafe).\n   * 4) Function uses 'this' and is called via '.call' (currently unsupported).\n   * 5) Extra arguments passed to the function have side-effects (would be dropped).\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n    // An empty function can be inlined. Null should not happen for FUNCTION.\n    if (block == null || !block.isBlock()) {\n       return CanInlineResult.NO;\n    }\n\n    // Function body characteristics needed for checks below\n    boolean functionHasSideEffects = NodeUtil.mayHaveSideEffects(block, compiler);\n    // TODO(johnlenz): Support 'arguments'. This check is overly broad.\n    // Note: isVarArgsFunction implies usesArguments.\n    if (NodeUtil.usesArguments(fnNode)) {\n       return CanInlineResult.NO;\n    }\n\n    // CALL NODE: [ NAME/GETPROP, ARG1, ARG2, ... ] or [ CALL, THIS, ARG1, ..] etc.\n    Node cArg = callNode.getFirstChild().getNext(); // First argument\n\n    // Adjust cArg based on call type (.call)\n    if (!callNode.getFirstChild().isName()) { // Handle GETPROP, CALL etc.\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        Node thisArg = cArg; // The first arg to .call is 'this'\n\n        // Check if 'this' argument itself has side-effects that must be preserved.\n        // We must do this even if 'this' isn't used by the function body,\n        // as the evaluation of the argument happens in the original code.\n        if (thisArg != null && NodeUtil.mayHaveSideEffects(thisArg, compiler)) {\n           return CanInlineResult.NO; // Don't drop side effect of 'this' arg evaluation\n        }\n\n        // Check if the function actually uses 'this'\n        if (NodeUtil.referencesThis(block)) {\n             // `func.call(thisValue, ...)` requires replacing 'this'.\n             // TODO(johnlenz): Support replacing 'this' with a value.\n             return CanInlineResult.NO;\n        }\n\n        // Skip the 'this' argument for parameter matching if it exists\n        if (thisArg != null) {\n             cArg = thisArg.getNext();\n        }\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode),\n            \"Unexpected apply call: %s\", callNode.toStringTree());\n        // Other indirect calls are assumed to be filtered by earlier checks\n        // like isDirectCallNodeReplacementPossible.\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n    // Check each argument and parameter pair.\n    while (cArg != null || fnParam != null) {\n      // Default refCount to 0 if fnParam is null (no parameter for arg).\n      int refCount = 0;\n      if (fnParam != null) {\n          // Calculate refCount once per parameter.\n          // This is potentially expensive, but necessary for correctness checks.\n          refCount = NodeUtil.getNameReferenceCount(block, fnParam.getString());\n      }\n\n      if (cArg != null) { // If argument exists\n        boolean argHasSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);\n        // An argument value is unstable if it depends on nonlocal state\n        // that might be changed by side effects within the function body.\n        boolean argValueChanges = !NodeUtil.evaluatesToLocalValue(cArg, compiler);\n\n        if (fnParam != null) { // Argument corresponds to a parameter\n            // Check 1: Argument side effects are duplicated if param used > 1 time.\n            if (argHasSideEffects && refCount > 1) {\n                return CanInlineResult.NO;\n            }\n\n            // Check 2 (from original code): Argument may modify state and is used\n            // multiple times. This check is subsumed by Check 1 because\n            // mayEffectMutableState() implies mayHaveSideEffects().\n            // if (NodeUtil.mayEffectMutableState(cArg, compiler) && refCount > 1) {\n            //   return CanInlineResult.NO;\n            // }\n\n            // Check 3: Function side effects might change arg value before use.\n            // This is only relevant if the parameter is actually used (refCount > 0).\n            if (refCount > 0 && functionHasSideEffects && argValueChanges) {\n                 // TODO(b/11717375): This check is too broad. We should be able\n                 // to inline if the side effect doesn't impact the parameter value.\n                 // e.g. \"function f(a){global=1; return a;} f(x.y);\". Current check\n                 // prevents this, but it might be safe if \"global=1\" doesn't change \"x.y\".\n                 // A more precise check requires more complex analysis.\n                return CanInlineResult.NO;\n            }\n\n        } else { // Extra argument (no corresponding parameter)\n            // Check 4: Don't drop side effects of extra arguments.\n            // The evaluation must happen. Inlining the function body directly would lose this.\n            if (argHasSideEffects) {\n                return CanInlineResult.NO;\n            }\n        }\n        cArg = cArg.getNext();\n      }\n\n      if (fnParam != null) {\n        // Move to the next parameter.\n        fnParam = fnParam.getNext();\n      }\n    }\n\n    // All checks passed\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}