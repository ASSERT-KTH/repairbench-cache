{
    "generation": "    /**\n     * Initializes the name to index mapping.\n     * <p>\n     * This method is called only if the format specifies a header, either explicitly via\n     * {@link CSVFormat#withHeader(String...)} or implicitly via {@link CSVFormat#withHeader()}.\n     * </p>\n     *\n     * @return The initialized mapping from header name to column index. Returns an empty map if\n     *         the header is read from the file and the file is empty. Will never return {@code null}.\n     * @throws IOException if there is a problem reading the header or skipping the first record.\n     * @throws IllegalArgumentException if the header contains duplicates (and duplicates are not ignored based on format settings).\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        // Use LinkedHashMap to maintain header order\n        final Map<String, Integer> hdrMap = new LinkedHashMap<String, Integer>();\n        final String[] formatHeader = this.format.getHeader(); // Header specified explicitly in format\n        String[] headerRecord = null;\n\n        if (formatHeader != null) {\n            // Header names are provided by the format object.\n            // Note: According to original logic, an empty array formatHeader means read from file.\n            if (formatHeader.length == 0) {\n                // Read header from the first record if format header is empty.\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                // Header names were explicitly given. Use them.\n                // Optionally skip the first record if requested.\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n        } else {\n            // Header names are read from the first record of the input stream.\n            // This case is invoked by format.withHeader() without arguments.\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n            // If nextRecord is null (e.g., empty file), headerRecord remains null.\n        }\n\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                // Check for null header BEFORE calling trim()\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n\n                // Skip empty headers if the format specifies they should be ignored.\n                if (emptyHeader && this.format.getIgnoreEmptyHeaders()) {\n                    continue; // Skip this header - do not add to map or check for duplicates\n                }\n\n                // Check for duplicates after potentially ignoring empty headers.\n                // If the header is already present in the map, it's a duplicate among the headers\n                // that are actually being recorded (non-empty or empty-but-not-ignored).\n                if (hdrMap.containsKey(header)) {\n                    // Build detailed error message if duplicates are not allowed or if this specific duplicate isn't allowed\n                    // The original duplicate check logic was:\n                    // containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))\n                    // This simplifies to: containsHeader && (!emptyHeader || !this.format.getIgnoreEmptyHeaders())\n                    // This check is implicitly handled now because we `continue` above for ignored empty headers.\n                    // Any header reaching this point that is already in the map is a violation.\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n\n                // Add the header mapping.\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n        // Return the map (never null). If the header couldn't be read (e.g., empty file), the map will be empty.\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}