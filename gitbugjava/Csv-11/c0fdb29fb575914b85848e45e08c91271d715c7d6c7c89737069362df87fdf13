{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        // Use the getter methods for format settings to ensure consistency\n        final String[] formatHeader = this.format.getHeader();\n        final boolean isFormatHeaderDefined = formatHeader != null;\n        final boolean isFirstRecordHeader = this.format.isFirstRecordAsHeader();\n\n        // If no header is explicitly defined AND the first record is not configured as the header,\n        // then no header processing is needed. Return null.\n        if (!isFormatHeaderDefined && !isFirstRecordHeader) {\n            return null;\n        }\n\n        // Header processing is required. Initialize the map.\n        // Use LinkedHashMap to preserve the order of headers.\n        final Map<String, Integer> hdrMap = new LinkedHashMap<>();\n        String[] headerRecord = null;\n\n        if (isFormatHeaderDefined) {\n            // Header is explicitly defined in the format settings.\n            headerRecord = formatHeader;\n            // Check if the format specifies skipping the header record (the first line in the data).\n            // This is relevant only when the header is EXPLICITLY provided, allowing us\n            // to skip a header line that might also be present in the input data source.\n            if (this.format.getSkipHeaderRecord()) {\n                // Consume the first record from the input stream and discard it.\n                this.nextRecord();\n            }\n        } else {\n            // Header should be read from the first record of the input stream.\n            // Read the first record. This record IS the header.\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n            // Note: format.getSkipHeaderRecord() is effectively ignored in this case,\n            // as the first record *must* be read to serve as the header.\n            // The CSVFormat Javadoc confirms this behavior.\n        }\n\n        // Build the name-to-index mappings from the determined header record array.\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                // Check if the header string is null or effectively empty.\n                // Null can occur if format.withNullString() is used on an empty field.\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n\n                // Check for duplicate headers based on the format settings.\n                // The original logic's condition translates to:\n                // Throw if (it's a duplicate) AND (it's NOT (an empty header AND we are ignoring empty headers)).\n                final boolean containsHeader = header == null ? hdrMap.containsKey(null) : hdrMap.containsKey(header);\n                if (containsHeader && !(emptyHeader && this.format.getIgnoreEmptyHeaders())) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n\n                // Add the header to the map unless it's an empty header that should be ignored.\n                // This logic ensures that we add:\n                // 1. All non-empty headers.\n                // 2. Empty/null headers IF the format is NOT set to ignore empty headers.\n                if (!emptyHeader || !this.format.getIgnoreEmptyHeaders()) {\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n                // Implicitly, if it IS an empty header AND we ARE ignoring empty headers,\n                // we simply skip adding it to the map. This also handles the case where\n                // a duplicate empty header was encountered but the exception was suppressed\n                // because ignoreEmptyHeaders was true; it's still not added to the map.\n            }\n        }\n\n        // Return the initialized map (which might be empty if the header record was null or empty).\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}