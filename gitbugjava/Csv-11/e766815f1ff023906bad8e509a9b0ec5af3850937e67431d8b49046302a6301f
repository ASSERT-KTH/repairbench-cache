{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    // Check for null header before calling trim() or checking map contains\n                    final boolean headerIsNull = header == null;\n                    final boolean emptyHeader = headerIsNull || header.trim().isEmpty();\n                    final boolean ignoreHeader = emptyHeader && this.format.getIgnoreEmptyHeaders();\n\n                    // Check for duplicates, potentially ignoring empty headers\n                    // Note: containsKey(null) is valid for LinkedHashMap\n                    final boolean containsHeader = hdrMap.containsKey(header);\n\n                    // A duplicate is an error if:\n                    // 1. We already have this header: containsHeader is true\n                    // 2. AND EITHER\n                    //    a) It's not an empty header: !emptyHeader\n                    //    b) OR it IS an empty header, but we are NOT ignoring empty headers: (emptyHeader && !this.format.getIgnoreEmptyHeaders())\n                    // Simplified logic check from original code: containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))\n                    // Let's refine the condition slightly for clarity and ensure it handles the null case properly treated as empty.\n                    // Error if duplicate exists AND it's not an empty header that we are supposed to ignore.\n                    if (containsHeader && !ignoreHeader) {\n                         // If it's a non-ignored empty header, check if duplicates of empty are allowed\n                         if (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders())) {\n                             throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                     \"\\\" in \" + Arrays.toString(headerRecord));\n                         }\n                    }\n\n                    // Add mapping if the header should not be ignored\n                    if (!ignoreHeader) {\n                         hdrMap.put(header, Integer.valueOf(i));\n                    }\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}