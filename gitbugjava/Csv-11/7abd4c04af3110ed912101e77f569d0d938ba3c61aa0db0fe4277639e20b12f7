{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                // Use a separate map to track occurrences of headers for duplicate detection.\n                // Keys are canonicalized (lowercase if ignoring case). Values are the index.\n                final Map<String, Integer> canonicalHeaderMap = new HashMap<>(headerRecord.length);\n                final boolean ignoreCase = this.format.getIgnoreHeaderCase();\n                final boolean ignoreEmpty = this.format.getIgnoreEmptyHeaders();\n\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i]; // Could be null if reading from record\n\n                    // Check 1: Handle null or empty header based on ignoreEmpty flag\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (emptyHeader && ignoreEmpty) {\n                        continue; // Skip if null/empty and ignoring empty headers\n                    }\n\n                    // Check 2: Determine canonical name for duplicate checking\n                    final String canonicalHeader;\n                    if (header == null) {\n                        // Use null as the canonical name for a null header.\n                        // If ignoreEmpty is false, null is a valid header name.\n                        canonicalHeader = null;\n                    } else {\n                        // For non-null headers, canonical name is lowercase if ignoring case.\n                        canonicalHeader = ignoreCase ? header.toLowerCase() : header;\n                    }\n\n                    // Check 3: Check for duplicates using the canonical name\n                    if (canonicalHeaderMap.containsKey(canonicalHeader)) {\n                        // A duplicate canonical name exists.\n                        // This is an error unless it's a duplicate empty/null header AND ignoreEmpty is true,\n                        // but we already skipped those cases earlier.\n                        // So, any duplicate found here is an error according to the format settings.\n                        throw new IllegalArgumentException(\n                                \"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" +\n                                        Arrays.toString(headerRecord));\n                    } else {\n                        // No duplicate canonical name found yet. Record it.\n                        canonicalHeaderMap.put(canonicalHeader, Integer.valueOf(i));\n                        // Add the original header (with original case, could be null/empty if not ignoring) to the main map.\n                        hdrMap.put(header, Integer.valueOf(i));\n                    }\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}