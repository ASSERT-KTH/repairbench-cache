{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header or the header record could not be read.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null; // Initialize map in the branches where a header is expected\n        final String[] formatHeader = this.format.getHeader(); // Header specified in format\n\n        String[] headerRecord = null;\n        if (formatHeader != null) {\n            // Header defined explicitly in the format.\n            hdrMap = new LinkedHashMap<String, Integer>();\n            if (this.format.getSkipHeaderRecord()) {\n                // Skip the first record from the input stream if specified by the format.\n                // This is useful when the header is defined externally but still present in the data.\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        } else {\n            // Header is not defined in format, check if we should read it from the first record.\n            if (this.format.getSkipHeaderRecord()) {\n                // skipHeaderRecord is true, so read the header from the first line of the file.\n                final CSVRecord firstRecord = this.nextRecord();\n                if (firstRecord != null) {\n                    headerRecord = firstRecord.values();\n                    // Initialize map only if we successfully read a header record\n                    hdrMap = new LinkedHashMap<String, Integer>();\n                }\n                // If firstRecord is null (e.g., empty file), headerRecord remains null,\n                // and hdrMap remains null, indicating no header was found.\n            }\n            // else: !format.getSkipHeaderRecord() means no header expected from the file,\n            //       so hdrMap remains null.\n        }\n\n        // build the name to index mappings if a header record was obtained and map initialized\n        if (hdrMap != null && headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                // Handle null headers potentially returned by CSVRecord.values()\n                if (header == null) {\n                   // Original code would throw NPE here. Silently skipping null header names.\n                   // Consider adding a format option to handle null headers differently if needed.\n                   continue;\n                }\n\n                final boolean containsHeader = hdrMap.containsKey(header);\n                // Use trim() only if needed to avoid creating unnecessary strings for non-empty headers.\n                final boolean emptyHeader = header.isEmpty() || header.trim().isEmpty();\n\n                // Throw exception if it's a duplicate header,\n                // unless it's an empty header and ignoreEmptyHeaders is true.\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n        return hdrMap; // Return null if no header was processed/found\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}