{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader(); // Explicit header array from format\n\n        // Check if a header is defined, either explicitly or implicitly (by requesting skipHeaderRecord).\n        // format.getSkipHeaderRecord() is the primary flag indicating a header row is expected/skipped.\n        if (this.format.getSkipHeaderRecord()) {\n            String[] headerRecord = null; // The actual header strings to use\n\n            // Determine the source of the header record.\n            if (formatHeader != null) {\n                // An explicit header array was provided in the format.\n                // We must consume the corresponding header line from the input stream\n                // if skipHeaderRecord is true (which it should be if header is specified).\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord(); // Skip the actual header line in the input\n                }\n                headerRecord = formatHeader; // Use the header from the format object\n            } else {\n                // No explicit header array - read header from the first record of the input.\n                // This happens when format.withHeader() is called without specific header strings.\n                final CSVRecord firstRecord = this.nextRecord(); // Read the first record to use as header\n                if (firstRecord != null) {\n                    headerRecord = firstRecord.values();\n                }\n                // Note: If firstRecord is null (empty file), headerRecord remains null.\n            }\n\n            // Build the header map if we have determined a header record.\n            // headerRecord can be null if the input stream was empty and header wasn't specified otherwise.\n            if (headerRecord != null) {\n                // Use LinkedHashMap to preserve order and support null keys (if needed and allowed by format).\n                hdrMap = new LinkedHashMap<>();\n                final boolean ignoringEmpty = this.format.getIgnoreEmptyHeaders();\n\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i]; // May be null if format specifies a null string conversion\n\n                    // Check if header is effectively empty and should be ignored based on format settings.\n                    // Null strings are generally handled by the parser based on format settings (e.g., withNullString),\n                    // resulting in null elements in headerRecord. Treat null as empty for ignoring purposes.\n                    final boolean effectivelyEmpty = (header == null || header.trim().isEmpty());\n\n                    if (ignoringEmpty && effectivelyEmpty) {\n                        continue; // Skip this header as requested by format settings.\n                    }\n\n                    // Check for duplicates among non-ignored headers.\n                    // Behavior for duplicates might depend on format settings (e.g., allowDuplicateHeaderNames).\n                    // Assuming default behavior based on original code: duplicates are not allowed (unless empty & ignored).\n                    // Since ignored headers are skipped above, any duplicate found here constitutes an error.\n                    if (hdrMap.containsKey(header)) {\n                         // TODO: Consider adding a format option to allow duplicate headers\n                         throw new IllegalArgumentException(\n                                 \"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" +\n                                 Arrays.toString(headerRecord));\n                    }\n\n                    // Add the valid header mapping.\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        // If format.getSkipHeaderRecord() was false, or if reading the header failed (e.g., empty file),\n        // hdrMap remains null, correctly indicating no header map is available.\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}