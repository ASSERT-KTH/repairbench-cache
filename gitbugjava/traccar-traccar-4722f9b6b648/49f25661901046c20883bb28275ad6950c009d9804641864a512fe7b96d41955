{
    "generation": "private Position decodeIridiumPosition(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n        // Read length, not used\n        buf.readUnsignedShortLE();\n\n        // Skip identification header and read index\n        buf.skipBytes(3);\n        buf.readUnsignedIntLE();\n\n        // Read and decode device session\n        String imei = buf.readSlice(15).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        // Create and configure position\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        // Read session status, not used\n        buf.readUnsignedByte();\n\n        // Skip reserved bytes and read date and time\n        buf.skipBytes(4);\n        long time = buf.readUnsignedIntLE();\n\n        // Adjust time to be within the expected range\n        long currentTime = System.currentTimeMillis() / 1000;\n        if (Math.abs(currentTime - time) > 25 * 60 * 60) {\n            time = currentTime;\n        }\n\n        // Set time on position\n        position.setTime(new Date((time + 2752051200L) * 1000));\n\n        // Skip coordinates block, not used in this test\n        buf.skipBytes(23);\n\n        // Skip data tag header and decode minimal data set\n        buf.skipBytes(3);\n        decodeMinimalDataSet(position, buf);\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}