{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            // Creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Handle with PropertyValueBuffer. If buffer fills up, build and process remaining tokens.\n                // 14-Mar-2016, tatu: Note: We cannot pass value to ExternalTypeHandler; it will be\n                // handled separately... Also, we do NOT want to call `assignParameter()` here,\n                // since that would require creator property value to be passed. Instead, let's\n                // just buffer it for later handling.\n                // related to [databind#928], but different problem?\n\n                // 13-Jun-2020, tatu: Actually, the problem here is that External Type Id handling\n                //    requires DIFFERENT handling. Cannot just buffer creator property values using\n                //    standard buffer, need to use buffer AND THEN pass info to External Handler.\n                //    Let's try speculative fix similar to one for [databind#1341], which is to\n                //    Do The Right Thing, pass external property.\n\n                // Handle with PropertyValueBuffer first, see if we can create instance\n                if (!buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    // if not possible, could still be handled by external type handler IF..\n                    // for now, let's assume it's always buffered property?\n                    // 13-Jun-2020, tatu: As per above, this isn't quite right..\n                    //    need to let `ExternalTypeHandler` process it too.\n                    // To fix [databind#928], let's try to call `handlePropertyValue` nonetheless\n                    // We'll change buffer `assignParameter` returns `true` logic below too\n                    if (ext.handlePropertyValue(p, ctxt, propName, buffer)) { // changed 3rd arg\n                       ; // handled by ext type handler\n                    }\n                    continue;\n                }\n                \n                // If we get this far, buffer IS filled, time to build the instance?\n                t = p.nextToken(); // Need to advance past prop value\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    // 24-Aug-2017, tatu: As per comments in #1790, need to be careful\n                    //   with possibly nested exceptions\n                    return wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                // Buffer remaining properties encountered so far into tokens\n                while (t == JsonToken.FIELD_NAME) {\n                    // NOTE: MUST buffer FIELD_NAME first...\n                    tokens.writeFieldName(p.getCurrentName());\n                    p.nextToken();\n                    tokens.copyCurrentStructure(p);\n                    t = p.nextToken();\n                }\n                tokens.writeEndObject();\n                // Sanity check for polymorphism (might be less relevant with external type id)\n                if (bean.getClass() != _beanType.getRawClass()) {\n                     // 13-Jun-2020, tatu: As per [databind#928], this should be fine?\n                     // Let ext.complete handle it, don't throw here. Seems safe enough.\n                     // 29-Jun-2020, tatu: Actually, requires passing TokenBuffer, combining,\n                     //     handling END_OBJECT... complex. Fail for now\n                     return ctxt.reportBadDefinition(_beanType, String.format(\n                            \"Cannot create polymorphic instances with external type ids (%s -> %s)\",\n                            _beanType.getRawClass().getName(), bean.getClass().getName()));\n                }\n                // Pass buffered tokens to external type handler to process the rest\n                // 13-Jun-2020, tatu: Also note that `ext.complete()` takes `p`, NOT TokenBuffer parser...\n                //    may be another problem. But fundamentally problem is that we cannot create\n                //    bean instance before seeing type id -- so need to change ordering.\n                //    Let's assume for now that `p` is fine.\n                return ext.complete(p, ctxt, bean);\n\n                // If buffer not filled, continue loop\n//                continue; // NOTE: this was missing, added now (2.11.2)\n            } else { // Not creator property\n\n                // Object Id property?\n                if (buffer.readIdProperty(propName)) {\n                    continue;\n                }\n\n                // External Type Handler property? Let it handle...\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) { // Pass null for buffer/bean\n                    continue;\n                }\n\n                // Regular property? needs buffering\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                    continue;\n                }\n\n                // Ignorable property?\n                if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                    handleIgnoredProperty(p, ctxt, handledType(), propName);\n                    continue;\n                }\n                \n                // \"any property\"?\n                if (_anySetter != null) {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                    continue; \n                }\n                \n                // Unknown: let's buffer...\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            }\n        }\n\n        // Hit END_OBJECT, but bean not built inside loop. Build it now.\n        try {\n             // We may have all creator parameters collected, and external type id\n             // Need to complete external type handling, create bean\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            return wrapInstantiationProblem(e, ctxt);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}