{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = null; // created lazily\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // We must deal with the case involving creator property...\n                // Check if external type handler can handle this?\n                // 15-Jan-2020, tatu: As per [databind#2608], need to pass buffer, NOT null\n                // Pass buffer so that `ExternalTypeHandler` has chance to buffer value,\n                // although not sure if it can associate it with creator property value\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    // Nothing to do, property handled by handler\n                    ;\n                } else {\n                    // If not handled by `ext`, buffer using PropertyValueBuffer\n                    // NB: This may fail if `assignParameter` needs to buffer and there is\n                    // no setter fallback. Indicates external type handling interaction issue.\n                    buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp));\n                    // 13-Feb-2024, tatu: MUST NOT try to build bean early as parameters may\n                    //    rely on type information not yet received. Original code had this\n                    //    flaw.\n                }\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // external type id (or property that depends on it)? This handles the type marker\n            // Pass `null` as there is no bean yet\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n\n            // Unknown property, ignorable property, or \"any property\"\n            // Need to buffer for later processing\n            if (tokens == null) {\n                tokens = new TokenBuffer(p, ctxt);\n            }\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n            \n            /* // Removed original separate handling to unify via TokenBuffer\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            if (_anySetter != null) {\n                try {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                }\n                continue;\n            }\n            // Unknown: pass to handler method\n            handleUnknownProperty(p, ctxt, _valueClass, propName);\n            */\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        Object bean;\n        try {\n            // Use the \"standard\" completion mechanism that requires creator/buffer\n            bean = ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            // As per method signature, need to return Object; wrapInstantiationProblem likely throws\n            // but for compile-time, return value needed. Exception wrapping seems appropriate.\n            return wrapInstantiationProblem(e, ctxt);\n        }\n\n        // If we did buffer anything, replay now\n        if (tokens != null) {\n             // If we got END_OBJECT this may be problematic...\n             // But if we exit loop, we are AT End-Object or after it.\n             // Let's assume stream is at or after END-OBJECT.\n\n            tokens.writeEndObject(); // Finish buffering\n            JsonParser bufferedParser = tokens.asParser(p); // Use main parser for context\n            bufferedParser.nextToken(); // Move past virtual START_OBJECT\n\n             // Need to deserialize stored properties onto bean instance\n             while (bufferedParser.getCurrentToken() != JsonToken.END_OBJECT) {\n                 String propName = bufferedParser.getCurrentName();\n                 bufferedParser.nextToken(); // value\n                 SettableBeanProperty prop = _beanProperties.find(propName);\n                 if (prop != null) {\n                     try {\n                         prop.deserializeAndSet(bufferedParser, ctxt, bean);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, bean, propName, ctxt);\n                     }\n                 } else if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                     handleIgnoredProperty(bufferedParser, ctxt, bean, propName);\n                 } else if (_anySetter != null) {\n                     try {\n                         _anySetter.deserializeAndSet(bufferedParser, ctxt, bean, propName);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, bean, propName, ctxt);\n                     }\n                 } else {\n                     // Unknown property stored in tokens\n                     handleUnknownProperty(bufferedParser, ctxt, bean, propName);\n                 }\n                 bufferedParser.nextToken();\n             }\n             bufferedParser.close(); // Close the token buffer parser\n        }\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}