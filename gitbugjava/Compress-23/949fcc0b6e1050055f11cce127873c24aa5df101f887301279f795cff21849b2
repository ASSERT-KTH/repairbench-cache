{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            // LZMA properties consist of 1 byte for lc/lp/pb and 4 bytes for dictionary size (32-bit unsigned little-endian).\n            if (coder.properties == null || coder.properties.length < 5) {\n                throw new IOException(\"LZMA Coder properties are truncated.\");\n            }\n\n            byte propsByte = coder.properties[0];\n            long dictSize = 0;\n            // Reconstruct the 32-bit unsigned little-endian dictionary size.\n            // The original code had a bug related to sign extension when reading bytes.\n            for (int i = 0; i < 4; i++) {\n                // Treat byte as unsigned using & 0xFF before casting to long and shifting.\n                // This prevents sign extension issues, especially with coder.properties[1].\n                dictSize |= ((long)(coder.properties[i + 1] & 0xFF)) << (8 * i);\n            }\n\n            // The theoretical maximum dictionary size is 4GiB - 1 (0xFFFFFFFFL).\n            // However, the org.tukaani.xz.LZMAInputStream constructor takes an int for dictionary size.\n            // Furthermore, it imposes its own limit, slightly less than Integer.MAX_VALUE.\n            // See org.tukaani.xz.LZMA2Options.DICT_SIZE_MAX.\n            // We must ensure the dictionary size fits within the positive range of int.\n            // Values larger than Integer.MAX_VALUE would become negative or wrap around when cast to int,\n            // causing the constructor check `dictSize < 0` to fail.\n            if (dictSize > Integer.MAX_VALUE) {\n                 // Throw an IOException indicating the size is too large to be represented as a positive int,\n                 // which is a prerequisite for the underlying LZMAInputStream implementation.\n                 throw new IOException(\"Dictionary size \" + dictSize + \" bytes is too large for this implementation (max supported: \" + Integer.MAX_VALUE + \")\");\n            }\n\n            // Now, dictSize is known to be between 0 and Integer.MAX_VALUE.\n            // Cast to int safely. The LZMAInputStream constructor will perform\n            // the final check against its specific implementation limit (LZMA2Options.DICT_SIZE_MAX).\n            int dictionarySizeInt = (int) dictSize;\n\n            return new LZMAInputStream(in, -1, propsByte, dictionarySizeInt);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}