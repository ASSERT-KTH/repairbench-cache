{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            // Validate properties length\n            if (coder.properties == null || coder.properties.length < 5) {\n                 throw new IOException(\"LZMA Coder properties are too short.\");\n            }\n\n            byte propsByte = coder.properties[0];\n            \n            // Dictionary size is a 32-bit unsigned integer, stored little-endian.\n            // We must read it carefully into a long to handle values > Integer.MAX_VALUE.\n            // Bytes must be treated as unsigned by masking with 0xFF.\n            long dictSize = coder.properties[1] & 0xFFL; // Read byte 1 (LSB) as unsigned long\n            dictSize |= (coder.properties[2] & 0xFFL) << 8;  // Read byte 2\n            dictSize |= (coder.properties[3] & 0xFFL) << 16; // Read byte 3\n            dictSize |= (coder.properties[4] & 0xFFL) << 24; // Read byte 4 (MSB)\n\n            // The org.tukaani.xz.LZMAInputStream constructor (via LZMAAloneDecoder) \n            // has an implementation limit of 1.5 GiB for the dictionary size.\n            // This limit is (1 << 30) + (1 << 29) = 1610612736L.\n            // See org.tukaani.xz.LZMAAloneDecoder constructor source code.\n            final long xzLibraryLimit = 1610612736L; \n            if (dictSize > xzLibraryLimit) {\n                throw new IOException(\"Dictionary size \" + dictSize \n                                     + \" exceeds the maximum supported size \" + xzLibraryLimit);\n            }\n\n            // The LZMAInputStream constructor takes an int for dictionary size.\n            // Since we've validated dictSize against xzLibraryLimit, which is \n            // less than Integer.MAX_VALUE, the cast to int is safe.\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}