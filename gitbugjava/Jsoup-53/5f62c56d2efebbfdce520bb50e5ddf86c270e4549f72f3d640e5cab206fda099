{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        final char ESC = '\\\\'; // Escape character\n\n        do {\n            if (isEmpty()) break; // Exit if queue is empty\n            Character c = consume(); // Consume next character\n            boolean escaped = (last == ESC); // Check if the previous character was an escape\n\n            if (!escaped) { // If the current character is not escaped\n                if (inSingleQuote) { // If currently inside single quotes\n                    if (c == '\\'') // Check for closing single quote\n                        inSingleQuote = false;\n                    // Inside single quotes, open/close characters are ignored for depth calculation\n                } else if (inDoubleQuote) { // If currently inside double quotes\n                    if (c == '\"') // Check for closing double quote\n                        inDoubleQuote = false;\n                    // Inside double quotes, open/close characters are ignored for depth calculation\n                } else { // Not inside any quotes\n                    if (c == '\\'') {\n                        inSingleQuote = true; // Enter single quotes\n                    } else if (c == '\"') {\n                        inDoubleQuote = true; // Enter double quotes\n                    } else if (c.equals(open)) { // Check for opener character\n                        depth++;\n                        if (start == -1) // Mark start position *after* the opener\n                            start = pos;\n                    } else if (c.equals(close)) { // Check for closer character\n                        depth--;\n                    }\n                }\n            }\n            // If the character was escaped, we ignore it for quote state changes and depth calculation.\n\n            // Update the end position:\n            // If we are inside the balanced structure (depth > 0) and it's not the first character processed after the opener,\n            // update 'end' to the position *after* the current character 'c'.\n            // This ensures 'end' points to the character *after* the last character within the balanced section.\n            if (depth > 0 && last != 0) { // 'last != 0' ensures we don't set end based on the opener itself.\n                                          // An alternative clearer check might be 'start != -1'.\n                end = pos;\n            }\n            last = c; // Update the last character for the next iteration's escape check\n\n            // The loop continues as long as depth > 0.\n            // It terminates *after* processing the character that makes depth == 0.\n        } while (depth > 0);\n\n        // Return the substring from 'start' (exclusive of opener) to 'end' (exclusive of closer)\n        // If 'end' was never updated (e.g., empty balanced section like '()', or unterminated), return \"\"\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}