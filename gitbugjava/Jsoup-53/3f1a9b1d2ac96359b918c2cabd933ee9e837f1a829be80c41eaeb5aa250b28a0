{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1; // Position after the first char consumed (the opening bracket)\n        int end = -1;   // Position after the last char consumed *before* the closing bracket\n        int depth = 0;\n        char last = 0; // Tracks the last character consumed\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        final char ESC = '\\\\'; // Assuming ESC = '\\\\' is defined in the class\n\n        do {\n            if (isEmpty()) break; // Stop if queue is empty\n            Character c = consume(); // Consume the next character, increments pos\n\n            // Handle escapes: if the previous character was an escape, this character is skipped for balancing/quoting logic\n            if (last == 0 || last != ESC) {\n                // Handle quotes: only change quote state if not escaped\n                if (c.equals('\\'') && !inDoubleQuote) {\n                    inSingleQuote = !inSingleQuote;\n                } else if (c.equals('\"') && !inSingleQuote) {\n                    inDoubleQuote = !inDoubleQuote;\n                }\n                // Handle open/close: only change depth if not escaped and not inside quotes\n                else if (!inSingleQuote && !inDoubleQuote) {\n                    if (c.equals(open)) {\n                        depth++;\n                        if (start == -1) // If this is the first 'open' found\n                            start = pos; // Set start to position *after* this 'open' char is consumed\n                    } else if (c.equals(close)) {\n                        depth--;\n                        // Note: depth could become < 0 here if 'close' appears before 'open'\n                    }\n                }\n            }\n\n            // Update 'end' position using original logic:\n            // If depth > 0 (meaning we are inside the balanced structure)\n            // and we have consumed at least one character (last != 0 - avoids updating end right after consuming 'open')\n            // then update 'end' to the position *after* the character just consumed ('c').\n            // This correctly marks the position after the last character *before* the final closing bracket.\n            if (depth > 0 && last != 0) {\n                end = pos; // end points *after* the character 'c'\n            }\n\n            last = c; // Update last character seen *after* all checks involving 'last'\n\n            // The loop condition `depth > 0` ensures we continue only while inside the balanced structure.\n            // It terminates when depth becomes 0 (after consuming the closing bracket) or < 0 (unbalanced).\n        } while (depth > 0);\n\n        // If 'end' was updated (meaning we found content between the brackets), return the substring.\n        // 'start' is the position after the opening bracket.\n        // 'end' is the position after the last character before the closing bracket.\n        // queue.substring(start, end) extracts the content between the brackets.\n        // For \"()\", start=1, end=-1, returns \"\".\n        // For \"(a)\", start=1, end=2, returns \"a\".\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}