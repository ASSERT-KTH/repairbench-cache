{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1; // start index of balanced string content (after open char)\n        int end = -1; // end index of balanced string content (before close char)\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false;\n        char quoteChar = 0;\n        final char ESC = '\\\\'; // Escape character\n\n        while (!isEmpty()) {\n            int currentPos = pos; // Position before consuming char c\n            char c = consume(); // Read char and advance position\n\n            boolean isEscaped = last == ESC;\n\n            if (!isEscaped) { // Only process special chars if not escaped\n                if (!inQuote) { // If not currently within quotes\n                    if (c == '\\'' || c == '\"') { // Start of quote\n                        inQuote = true;\n                        quoteChar = c;\n                    } else if (c == open) { // Opening char\n                        depth++;\n                        if (start == -1) // Record start index if it's the first opener we encounter\n                            start = pos; // pos is *after* the consumed opening char\n                    } else if (c == close) { // Closing char\n                        depth--;\n                    }\n                } else { // If currently within quotes\n                    if (c == quoteChar) { // End of quote\n                        inQuote = false;\n                    }\n                    // Inside quotes, characters like open/close don't affect depth\n                }\n            }\n\n            // Check for exit condition *after* processing the character and updating depth.\n            // We need to have found the start bracket (start != -1) and depth must have returned to 0 (or less, safety).\n            if (start != -1 && depth <= 0) {\n                 // This state should only be reached when the closing character `c` is consumed,\n                 // is not escaped, not inside a quote, and matches the `close` parameter.\n                 // The depth calculation already handles the conditions for decrementing.\n                 // So, if depth drops to 0 or below after finding the start, we've found the matching close.\n                end = currentPos; // The balanced content ends *before* the closing char c (which was at currentPos)\n                break; // Found the balanced match\n            }\n\n            last = c; // Update last char for escape checking next iteration\n        }\n\n        // If loop finished because queue is empty but depth is still > 0, it's unbalanced. End remains -1.\n        // If start was never found, start is -1, end is -1.\n        // Return substring only if end was validly found (which implies start was also found).\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}