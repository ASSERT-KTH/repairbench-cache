{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1; // Start index of the balanced portion (position *after* open char)\n        int end = -1;   // End index of the balanced portion (position *after* char before close char)\n        int depth = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        boolean escaping = false;\n\n        // Assuming ESC is defined in the class, e.g., private static final char ESC = '\\\\';\n        // If ESC is not defined, needs to be added or obtained from context.\n        final char ESC = '\\\\'; // Hardcoding for this fix, assuming standard Java escape\n\n        do {\n            if (isEmpty()) break; // Stop if queue is empty\n\n            char c = consume(); // Consume the next character and advance position\n\n            if (escaping) {\n                // Previous char was escape, this char is escaped. Reset flag.\n                // Treat escaped char literally (don't check for quotes or balance).\n                escaping = false;\n            } else {\n                if (c == ESC) {\n                    escaping = true; // Mark next char as escaped. Don't process this ESC char further.\n                } else {\n                    // Not an escape char, and not currently escaped: process normally.\n                    if (c == '\\'' && !inDoubleQuote) {\n                        inSingleQuote = !inSingleQuote; // Toggle single quote state\n                    } else if (c == '\"' && !inSingleQuote) {\n                        inDoubleQuote = !inDoubleQuote; // Toggle double quote state\n                    }\n\n                    // Check for balancing characters only if not inside quotes.\n                    if (!inSingleQuote && !inDoubleQuote) {\n                        if (c == open) {\n                            depth++;\n                            if (start == -1) // Record start position *after* the first non-quoted/escaped opening char\n                                start = pos; // 'pos' is now after the consumed 'c'\n                        } else if (c == close) {\n                            depth--;\n                            // Depth decreases *after* consuming the closing char.\n                        }\n                    }\n                }\n            }\n\n            // Update the end position if we are inside the balanced structure.\n            // 'start >= 0' ensures the opener was found.\n            // 'depth > 0' ensures we are still inside the balanced structure *after* processing 'c'.\n            // If 'c' was the final closing char that made depth 0, this condition will be false,\n            // so 'end' correctly points to the position *after* the character *before* the final closing char.\n            if (depth > 0 && start >= 0) {\n                 end = pos; // Update end to the current position (after consuming 'c')\n            }\n            // Note: If the loop terminates because the queue is empty while depth > 0,\n            // 'end' will hold the position after the last consumed character.\n\n        } while (depth > 0); // Loop while strictly inside the balanced structure (depth > 0)\n\n        // Return the substring between start and end.\n        // If end was never updated (e.g., input \"()\" or just \"(\"), end remains -1.\n        // The condition 'end >= 0' handles these cases correctly.\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}