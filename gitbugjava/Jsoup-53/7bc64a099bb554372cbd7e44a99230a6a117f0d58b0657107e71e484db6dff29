{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1; // Position of the first opening char found\n        int end = -1; // Position of the matching closing char\n        int depth = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        boolean escaped = false;\n        final char ESC = '\\\\'; // Assuming this constant is available or should be defined here/class level\n\n        while (!isEmpty()) {\n            int currentPos = pos; // Position *before* consuming char c\n            Character c = consume();\n\n            if (escaped) {\n                // Previous char was escape, treat current char literally\n                escaped = false;\n            } else {\n                // Handle escape char for *next* character\n                if (c == ESC) {\n                    escaped = true;\n                }\n                // Handle quotes - only toggle if not escaped\n                else if (c == '\\'' && !inDoubleQuote) {\n                    inSingleQuote = !inSingleQuote;\n                } else if (c == '\"' && !inSingleQuote) {\n                    inDoubleQuote = !inDoubleQuote;\n                }\n                // Handle open/close only if not escaped and not inside quotes\n                else if (!inSingleQuote && !inDoubleQuote) {\n                    if (c.equals(open)) {\n                        depth++;\n                        if (start == -1) // Record position of the first opening char\n                            start = currentPos;\n                    } else if (c.equals(close)) {\n                        depth--;\n                    }\n                }\n            }\n\n            // Check for match completion *after* processing the char and updating depth\n            // Requires that we have found the start char first\n            if (start != -1 && depth == 0) {\n                end = currentPos; // Position of the closing char (the char just consumed)\n                break; // Found the matching close\n            }\n\n            // Check for premature close (unbalanced situation like \")(\" )\n            if (depth < 0) {\n                 // Indicates an error state, like finding 'close' before 'open'.\n                 // Stop processing. start will be -1, resulting in empty string return.\n                break;\n            }\n        }\n\n        // If a balanced match was found (start was set, and loop broke with depth == 0 at end position)\n        if (start != -1 && end != -1) {\n             // Return the content *between* open and close chars\n             // queue.substring(from, to) -> from is inclusive, to is exclusive\n             // start is the index of 'open', end is the index of 'close'\n             // We want the string from index start + 1 up to (but not including) end.\n            return queue.substring(start + 1, end);\n        } else {\n            // No balanced match found (either open never seen, or queue ended prematurely with depth > 0, or premature close with depth < 0)\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}