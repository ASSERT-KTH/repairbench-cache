{
    "generation": "    /**\n     * Helper method called when there is the explicit \"is-creator\", but no mode declaration.\n     *\n     * @since 2.9.2\n     */\n    protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n        if (1 != candidate.paramCount()) {\n            // Ok: for delegates, we want one and exactly one parameter without\n            // injection AND without name\n            int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n            if (oneNotInjected >= 0) {\n                // getting close; but most not have name\n                if (candidate.paramName(oneNotInjected) == null) {\n                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n\n        // Common case: single argument constructor/factory method\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0); // Check explicit name first\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // If no explicit name/injection, check if implicit name corresponds to a real property\n\n            // 25-May-2018, tatu: [databind#2051]: Use name from BeanPropertyDefinition\n            // (Buggy code used candidate.findImplicitParamName(0) here)\n            paramName = paramDef.getFullName(); // Get logical name from property def\n\n            // Consider it property-based if we found a logical name AND it could be serialized (getter/field exists)\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n\n        // If determined to be property-based:\n        if (useProps) {\n            // We must use the name as defined by the property definition\n            // (which takes into account NamingStrategy, explicit name via @JsonProperty)\n            // -- Naming strategy applies to logical name,JsonProperty overrides.\n            // However, CreatorProperty itself needs the logical name? No, external.\n            // Let's try using the name as determined earlier (explicit, or implicit from def)\n            // but apply Naming Strategy if NO explicit name was given.\n\n            // UPDATE for [databind#2051] fix and related test:\n            // It seems that for constructor parameters, the naming strategy SHOULD\n            // be applied even if there is an explicit @JsonProperty annotation.\n            // This differs from regular properties.\n            PropertyName nameToUse = paramName; // Start with logical name (explicit or implicit)\n            PropertyNamingStrategy strategy = ctxt.getConfig().getPropertyNamingStrategy();\n            if (strategy != null) {\n                 String simpleName = paramName.getSimpleName();\n                 // Always apply strategy if present for constructor parameter\n                 nameToUse = strategy.nameForConstructorParameter(ctxt.getConfig(), param, simpleName);\n            }\n\n            // Construct and register property using the calculated external name.\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, nameToUse, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n\n        // If not property-based, handle as delegating/value creator\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}