{
    "generation": "import java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.annotation.Nullable; // Or org.jetbrains.annotations.Nullable if using Jetbrains annotations\nimport org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\n\n// todo - this is getting gnarly. needs a rewrite. // Comment kept from original\nstatic Document parseByteData(ByteBuffer byteData, @Nullable String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc;\n    final String defaultCharset = StandardCharsets.UTF_8.name();\n    String finalCharset = null;\n\n    // Mark the start for potential resets\n    byteData.mark();\n\n    // 1. Check for BOM (Byte Order Mark)\n    boolean bomFound = false;\n    String bomCharset = null;\n    if (byteData.remaining() >= 3 &&\n        byteData.get(0) == (byte) 0xEF && byteData.get(1) == (byte) 0xBB && byteData.get(2) == (byte) 0xBF) {\n        bomCharset = StandardCharsets.UTF_8.name();\n        byteData.position(3); // Skip BOM bytes\n        bomFound = true;\n    }\n    // Add checks for other BOMs (UTF-16LE, UTF-16BE) if needed here\n    else {\n        byteData.reset(); // No BOM found or handled, reset to original mark\n    }\n    // Mark the start of the actual data (after BOM if applicable) for the final read\n    byteData.mark();\n\n\n    // 2. Determine final charset based on precedence: specified > BOM > meta > default\n    if (charsetName != null) { // Specified charset takes precedence\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        finalCharset = charsetName;\n        // byteData position is already correctly set (initial mark or after BOM)\n    } else if (bomFound) { // BOM detected and no specific charset specified\n        finalCharset = bomCharset; // Use charset implied by BOM (e.g., UTF-8)\n    } else { // No specified charset, no BOM: detect from meta tags or use default\n        try {\n            // Use a defensive copy/slice for tentative decoding with default charset\n            // slice() creates a view sharing content but with independent pos/limit/mark\n            ByteBuffer bufferForMetaRead = byteData.slice();\n            String tentativeDocData = Charset.forName(defaultCharset).decode(bufferForMetaRead).toString();\n\n            // Parse tentatively to find meta tags.\n            // Note: A full parse is used here to read the meta tag. This is more robust than regex.\n            Document tempDoc = parser.parseInput(tentativeDocData, baseUri);\n\n            // Look for <meta charset=...> or <meta http-equiv=content-type ...>\n            // Prefer <meta charset=charset> as per HTML5 spec\n            Element metaCharset = tempDoc.selectFirst(\"meta[charset]\");\n            if (metaCharset != null) {\n                String foundCharset = metaCharset.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() > 0) {\n                   finalCharset = foundCharset;\n                }\n            } else {\n                 // Fallback to http-equiv\n                 Element metaHttpEquiv = tempDoc.selectFirst(\"meta[http-equiv=content-type]\");\n                 if (metaHttpEquiv != null) {\n                     String foundCharset = getCharsetFromContentType(metaHttpEquiv.attr(\"content\"));\n                      if (foundCharset != null && foundCharset.length() > 0) {\n                          finalCharset = foundCharset;\n                      }\n                 }\n            }\n\n            // Validate the found charset (if any)\n            if (finalCharset != null) {\n                 finalCharset = finalCharset.trim().replaceAll(\"['\\\"]\", \"\"); // Clean attribute value\n                 try {\n                     if (!Charset.isSupported(finalCharset)) {\n                         // Found charset in meta, but it's not supported. Fallback needed.\n                         finalCharset = null;\n                     }\n                     // else: charset is supported, keep it.\n                 } catch (IllegalCharsetNameException e) {\n                     // Found charset in meta, but the name is illegal. Fallback needed.\n                     finalCharset = null;\n                 }\n            }\n\n        } catch (Exception e) {\n            // Exception during tentative read/parse (e.g., buffer error, parse error).\n            // Ignore and fallback to default charset later. Consider logging 'e'.\n        }\n\n        // If meta detection didn't yield a supported charset, use the default\n        if (finalCharset == null) {\n            finalCharset = defaultCharset;\n        }\n    }\n\n    // 3. Reset buffer to start point (after BOM if applicable) for final decode\n    byteData.reset(); // Reset to the mark set after BOM check/skip\n\n    // 4. Final Decode\n    // Ensure we have a final charset name by this point\n    if (finalCharset == null) { // Should not happen with the logic above, but as a safeguard\n         finalCharset = defaultCharset;\n    }\n\n    try {\n        docData = Charset.forName(finalCharset).decode(byteData).toString();\n    } catch (Exception e) {\n        // If the determined charset failed (e.g., invalid specified charset), throw an exception.\n        // Consider wrapping in a Jsoup-specific exception (e.g., CharsetException) or handle per project strategy.\n        throw new RuntimeException(\"Failed to decode using charset '\" + finalCharset + \"'\", e);\n    }\n\n    // 5. Final Parse\n    doc = parser.parseInput(docData, baseUri);\n\n    // 6. Set Output Charset in Document settings\n    // Use the charset that was actually used for decoding.\n    doc.outputSettings().charset(finalCharset);\n\n    return doc;\n}\n\n// Helper function to extract charset from Content-Type header value\n// Assumes this function is available or placed within the same class.\nprivate static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\");\n@Nullable\nprivate static String getCharsetFromContentType(@Nullable String contentType) {\n    if (contentType == null) return null;\n    Matcher m = charsetPattern.matcher(contentType);\n    if (m.find()) {\n        String charset = m.group(1).trim();\n        // Charset.isSupported() should be used to validate before use.\n        // Return the found string, validation happens in the caller.\n        if (charset.length() > 0) {\n            return charset;\n        }\n    }\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}