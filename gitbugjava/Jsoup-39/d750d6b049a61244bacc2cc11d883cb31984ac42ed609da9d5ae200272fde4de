{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        // Use a temporary variable to track the charset as it's detected or specified\n        String detectedCharset = charsetName;\n\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            // Initial decode attempt with default charset\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri); // Initial parse to look for meta tags\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            detectedCharset = defaultCharset; // Assume default if no meta found\n\n            if (meta != null) { // if found, potentially override charset\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    // Note: Original logic might miss charset if http-equiv is present but doesn't specify charset, and meta[charset] exists.\n                    // Keeping original logic structure for minimal fix.\n                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                        try {\n                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                foundCharset = meta.attr(\"charset\");\n                            }\n                        } catch (IllegalCharsetNameException e) {\n                            // ignore invalid charset\n                            foundCharset = null;\n                        }\n                    }\n                } else if (meta.hasAttr(\"charset\")) { // <meta charset=...>\n                     try {\n                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n                             foundCharset = meta.attr(\"charset\");\n                         }\n                     } catch (IllegalCharsetNameException e) {\n                         // ignore invalid charset\n                         foundCharset = null;\n                     }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    detectedCharset = foundCharset; // Update detected charset\n                    byteData.rewind(); // Rewind buffer for re-decoding\n                    docData = Charset.forName(detectedCharset).decode(byteData).toString(); // Re-decode with found charset\n                    doc = null; // Set doc to null to trigger re-parse below\n                }\n                // If no charset found in meta, or it's the default, keep the initial parse (doc != null)\n            }\n            // If no meta tag found, keep the initial parse (doc != null) and default charset\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            detectedCharset = charsetName; // Use the specified charset\n            // doc is still null, needs parsing\n        }\n\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        // Check if the string data starts with the BOM character (\\uFEFF)\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind(); // Rewind the original byte buffer\n            // Re-decode forced as UTF-8 (defaultCharset)\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1); // Remove the BOM character from the string\n            detectedCharset = defaultCharset; // BOM implies UTF-8, override any previous detection/specification\n            doc = null; // *** FIX: Force re-parse with BOM removed and correct charset ***\n        }\n\n        if (doc == null) {\n            // If doc is null, it needs parsing (or re-parsing).\n            // This happens if charset was specified, or meta charset required re-decode, or BOM was found.\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the output charset on the final document based on the determined charset\n        doc.outputSettings().charset(detectedCharset);\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}