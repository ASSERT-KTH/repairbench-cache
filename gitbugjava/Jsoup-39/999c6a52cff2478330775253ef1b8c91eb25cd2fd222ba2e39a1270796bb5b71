{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString(); // Initial decode using default charset\n            doc = parser.parseInput(docData, baseUri); // Initial parse\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String foundCharset = null; // Declare foundCharset outside the meta block to track it later\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) { // Check charset attr if http-equiv failed or wasn't present\n                     try {\n                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                         }\n                     } catch (IllegalCharsetNameException e) {\n                            foundCharset = null; // Treat invalid charset name as null\n                     }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode if different charset found\n                    // Rerun same check from else branch, but use found charset\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset; // Update the authoritative charsetName\n                    byteData.rewind(); // Rewind buffer for re-decoding\n                    docData = Charset.forName(foundCharset).decode(byteData).toString(); // Re-decode with found charset\n                    doc = null; // Set doc to null to trigger re-parse later\n                }\n            }\n            // If we fall through here, doc might still be the initially parsed doc (using defaultCharset)\n            // docData might still be the initially decoded data (with BOM if present)\n            // charsetName might still be null (if no meta tag found or meta tag had defaultCharset)\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            // doc is still null here\n        }\n\n        // UTF-8 BOM indicator check. This comes AFTER potential meta charset detection or explicit charset setting.\n        // It overrides other findings if a BOM is present.\n        // Uses the correct defaultCharset defined in DataUtil.\n        if (docData.length() > 0 && docData.charAt(0) == 65279) { // Check for BOM (U+FEFF)\n            byteData.rewind(); // Rewind buffer\n            docData = Charset.forName(defaultCharset).decode(byteData).toString(); // Re-decode ALWAYS using defaultCharset (UTF-8) if BOM present\n            docData = docData.substring(1); // Remove BOM from string\n            charsetName = defaultCharset; // Set charset to defaultCharset, overriding any previous value\n            doc = null; // Set doc to null to force re-parse with BOM removed and defaultCharset (UTF-8)\n        }\n\n        if (doc == null) { // This will be true if: 1) charsetName was specified, 2) meta tag forced re-decode, 3) BOM forced re-decode\n            doc = parser.parseInput(docData, baseUri); // Parse the potentially re-decoded and BOM-stripped docData\n            // Determine the charset to set on the document. Prioritize the final 'charsetName' value.\n            // If charsetName is null here, it means we started with null, didn't find a meta tag, and didn't find a BOM, so use defaultCharset.\n            doc.outputSettings().charset(charsetName != null ? charsetName : defaultCharset);\n        } else {\n            // This case is reached ONLY if charsetName was initially null, no relevant meta tag was found, AND no BOM was detected.\n            // The doc was parsed using the defaultCharset. Set the charset accordingly.\n             doc.outputSettings().charset(defaultCharset);\n        }\n\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}