{
    "generation": "    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf);\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        // This block seems specific and potentially problematic (byte count 18 vs 20)\n        if (buf.readableBytes() == 20) {\n            // Assuming this structure is correct for specific messages\n            buf.skipBytes(4); // remaining battery and mileage?\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1); // Voltage\n            buf.readUnsignedInt(); // area id\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            buf.skipBytes(3); // reserved\n            // Note: Consumes 18 bytes, leaves 2 unread if readableBytes == 20 initially\n            return position;\n        }\n\n        while (buf.readableBytes() > 2) { // Need at least type and length\n\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n            int endIndex = buf.readerIndex() + length;\n\n            // Ensure buffer has enough bytes for the declared length before processing\n            if (endIndex > buf.writerIndex()) {\n                 // Log error or break if length exceeds buffer bounds\n                 // Log.warn(\"Invalid TLV length: subtype=\" + subtype + \", length=\" + length);\n                 break; // Avoid BufferOverflowException\n            }\n\n            String stringValue;\n            switch (subtype) {\n                case 0x01: // Odometer\n                    if (length == 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    } else {\n                        buf.skipBytes(length); // Skip if length is wrong\n                    }\n                    break;\n                case 0x02: // Fuel Level\n                    if (length == 2) {\n                        position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1);\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x2b: // Fuel Consumption\n                    if (length == 4) {\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x30: // RSSI\n                    if (length == 1) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x31: // Satellites\n                    if (length == 1) {\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x33: // Lock Status String\n                    if (length > 15) { // Check min length for expected format \"*M00...{7 chars}...\"\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        if (stringValue.startsWith(\"*M00\") && stringValue.length() >= 15) {\n                            try {\n                                String lockStatus = stringValue.substring(8, 15); // 7 chars\n                                position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                            } catch (IndexOutOfBoundsException | NumberFormatException e) {\n                                // Malformed string, ignore or log\n                                // Ensure buffer index advances correctly\n                                buf.readerIndex(endIndex);\n                            }\n                        } else {\n                            // String doesn't match expected format, ensure index advances\n                            buf.readerIndex(endIndex);\n                        }\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0x60: // Event\n                     if (length >= 2) {\n                         position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                         // Skip remaining bytes, if any\n                         buf.skipBytes(length - 2);\n                     } else {\n                         buf.skipBytes(length);\n                     }\n                    break;\n                case 0x69: // Battery Voltage\n                    if (length == 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0x80: // Extension - Original logic complex/unclear, skip based on length\n                     buf.skipBytes(length);\n                    break;\n                case 0x91: // OBD Data Block 1\n                     // Min expected length is 24 based on fields read\n                     if (length >= 24) {\n                         position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1); // 2\n                         position.set(Position.KEY_RPM, buf.readUnsignedShort()); // 2\n                         position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte()); // 1\n                         position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255); // 1\n                         position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255); // 1\n                         position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40); // 1\n                         buf.skipBytes(2); // skip unknown short\n                         position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01); // 2\n                         buf.skipBytes(2); // skip unknown short\n                         buf.skipBytes(4); // skip unknown int\n                         buf.skipBytes(2); // skip unknown short\n                         position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01); // 2\n                         // Total read = 24 bytes. Skip any remaining bytes if length > 24\n                         buf.skipBytes(length - 24);\n                     } else {\n                         buf.skipBytes(length); // Skip if length insufficient\n                     }\n                    break;\n                case 0x94: // VIN\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                case 0xA7: // ADC\n                    if (length == 4) {\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                        position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xAC: // Odometer (alternate)\n                    if (length == 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xBC: // Driver Name\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(\"driver\", stringValue.trim());\n                    }\n                    break;\n                case 0xBD: // Driver ID\n                     if (length > 0) {\n                         stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                         position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                     }\n                    break;\n                case 0xD0: // User Status / Alarm\n                    if (length == 4) {\n                        long userStatus = buf.readUnsignedInt();\n                        if (BitUtil.check(userStatus, 3)) {\n                            position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                        }\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xD3: // Power (Voltage)\n                    if (length == 2) {\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xD4: // Battery Level %\n                case 0xE1: // Battery Level %\n                    if (length == 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xD5: // Lock Info / Battery Voltage\n                    if (length == 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 1) { // Multiple locks format\n                         try {\n                            int count = buf.readUnsignedByte();\n                            // Check if length is sufficient: 1 (count) + count * 13 bytes/lock\n                            if (1 + count * 13 <= length && count > 0) {\n                                for (int i = 1; i <= count; i++) {\n                                    // Check readable bytes before each read group\n                                    if (buf.readableBytes() < 13) {\n                                        throw new IndexOutOfBoundsException(\"Insufficient data for lock \" + i);\n                                    }\n                                    position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                    position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                    position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                                    int status = buf.readUnsignedShort();\n                                    position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                                }\n                                // Skip any remaining padding bytes\n                                buf.readerIndex(endIndex);\n                            } else {\n                                buf.skipBytes(length); // Skip if length mismatch or count is 0\n                            }\n                         } catch (IndexOutOfBoundsException e) {\n                             // Log error? Ensure index advances\n                             buf.readerIndex(endIndex);\n                         }\n                    } else { // length == 0 or 1 (invalid for multi-lock)\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xDA: // Device Status\n                    if (length >= 3) {\n                        buf.skipBytes(2); // string cut count\n                        int deviceStatus = buf.readUnsignedByte();\n                        position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                        position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                        position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                        buf.skipBytes(length - 3); // Skip remaining\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xE6: // Wireless Sensors\n                    // Each sensor block is 1 (index) + 6 (mac) + 8 (temp) + 8 (humidity) = 23 bytes\n                    if (length > 0 && length % 23 == 0) {\n                        while (buf.readerIndex() < endIndex) {\n                             if (buf.readableBytes() < 23) break; // Check before reading block\n                            int sensorIndex = buf.readUnsignedByte();\n                            buf.skipBytes(6); // mac\n                            position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(buf));\n                            position.set(\"humidity\" + sensorIndex, decodeCustomDouble(buf));\n                        }\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xEB: // Network Info or Extended Data\n                    handleEbExtension(position, buf, length, endIndex);\n                    break;\n                case 0xED: // Card Number\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_CARD, stringValue.trim());\n                    }\n                    break;\n                case 0xEE: // Misc Status (Bike Lock?)\n                    if (length == 7) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xF3: // Extended OBD Data\n                    handleF3Extension(position, buf, endIndex);\n                    break;\n                case 0xFE: // Battery Level % or Extended Alarms\n                    handleFeExtension(position, buf, length, endIndex); // Use helper for clarity\n                    break;\n                default: // Unknown subtype\n                    buf.skipBytes(length); // Skip the value part\n                    break;\n            }\n\n            // Ensure reader index is correctly positioned at the end of the TLV\n            // This handles cases where the switch case skipped bytes or didn't consume the full length.\n            // Also handles unknown subtypes where we skipped the value.\n            if (buf.readerIndex() > endIndex) {\n                 // Log.warn(\"Reader index (\" + buf.readerIndex() + \") passed endIndex (\" + endIndex + \") for subtype \" + subtype);\n                 // Resetting might hide parsing bugs, but prevents reading into next TLV incorrectly\n                 buf.readerIndex(endIndex);\n            } else {\n                 // If reader index is before endIndex (e.g. case skipped due to invalid inner length), advance it.\n                 buf.readerIndex(endIndex);\n            }\n\n        }\n\n        return position;\n    }\n\n    // Helper method for case 0xEB (Refactored for clarity and safety)\n    private void handleEbExtension(Position position, ByteBuf buf, int length, int endIndex) {\n        // Check length before reading anything inside\n        if (length < 1) {\n             // buf.skipBytes(length); // length is 0, no skip needed\n             return;\n        }\n        try {\n            // Conditional logic based on first two bytes peeked\n            // Check length > 1 before peeking\n            if (length > 1 && buf.getUnsignedShort(buf.readerIndex()) > 200) {\n                // Network Info Format 1\n                if (length >= 3) { // Need MCC (2) and MNC (1)\n                    Network network = new Network();\n                    int mcc = buf.readUnsignedShort();\n                    int mnc = buf.readUnsignedByte();\n                    // Check if remaining length matches cell tower structure size: N * 5 bytes\n                    int remainingLength = length - 3;\n                    if (remainingLength > 0 && remainingLength % 5 == 0) {\n                        while (buf.readerIndex() < endIndex) {\n                             if (buf.readableBytes() < 5) break; // Check remaining bytes for a full cell tower info\n                            network.addCellTower(CellTower.from(\n                                    mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(),\n                                    buf.readUnsignedByte()));\n                        }\n                        position.setNetwork(network);\n                    }\n                    // Ensure reader index is advanced to endIndex even if format was unexpected\n                    buf.readerIndex(endIndex);\n                } else {\n                    buf.skipBytes(length); // Skip if length too short for MCC/MNC\n                }\n            } else {\n                // Extended Data Format (inner TLVs)\n                while (buf.readerIndex() < endIndex) {\n                    if (buf.readableBytes() < 4) break; // Need inner length(2) and type(2)\n                    int extendedLength = buf.readUnsignedShort();\n                    int extendedType = buf.readUnsignedShort();\n                    int valueBytes = extendedLength - 2; // Bytes for value part\n                    int valueEndIndex = buf.readerIndex() + valueBytes;\n\n                    if (valueBytes < 0 || valueEndIndex > endIndex) {\n                         buf.readerIndex(endIndex); // Skip to end if inner length invalid\n                         break;\n                    }\n                    if (buf.readableBytes() < valueBytes) {\n                         buf.readerIndex(endIndex); // Skip to end if not enough bytes for value\n                         break;\n                    }\n\n                    switch (extendedType) {\n                        case 0x0001: // fuel1\n                            if (valueBytes == 3) { // 2(val)+1(unused)\n                                position.set(\"fuel1\", buf.readUnsignedShort() * 0.1);\n                                buf.readUnsignedByte(); // unused\n                            } else { buf.skipBytes(valueBytes); }\n                            break;\n                        case 0x0023: // fuel2\n                            if (valueBytes == 6) {\n                                try {\n                                    position.set(\"fuel2\", Double.parseDouble(\n                                        buf.readCharSequence(6, StandardCharsets.US_ASCII).toString()));\n                                } catch (NumberFormatException e) { buf.skipBytes(valueBytes); /* ignore parse error */ }\n                            } else { buf.skipBytes(valueBytes); }\n                            break;\n                        case 0x00CE: // power\n                            if (valueBytes == 2) {\n                                position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);\n                            } else { buf.skipBytes(valueBytes); }\n                            break;\n                        case 0x00D8: // network format 2\n                            if (valueBytes == 9) { // 2(mcc)+1(mnc)+2(lac)+4(cid)\n                                Network network = new Network();\n                                network.addCellTower(CellTower.from(\n                                        buf.readUnsignedShort(), buf.readUnsignedByte(),\n                                        buf.readUnsignedShort(), buf.readUnsignedInt()));\n                                position.setNetwork(network);\n                            } else { buf.skipBytes(valueBytes); }\n                            break;\n                        case 0xE1: // battery level % (inner)\n                            if (valueBytes == 1) {\n                                position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            } else { buf.skipBytes(valueBytes); }\n                            break;\n                        default:\n                            buf.skipBytes(valueBytes);\n                            break;\n                    }\n                    // Ensure index is correct after processing inner TLV's value\n                    buf.readerIndex(valueEndIndex);\n                }\n            }\n        } catch (Exception e) { // Catch potential exceptions during parsing (e.g., reading bytes)\n            // Log error?\n            // Log.warn(\"Error parsing EB extension: \" + e.getMessage());\n            buf.readerIndex(endIndex); // Ensure we move to the end of the outer TLV\n        }\n    }\n\n    // Helper method for case 0xF3 (Refactored for clarity and safety)\n    private void handleF3Extension(Position position, ByteBuf buf, int endIndex) {\n        try {\n             while (buf.readerIndex() < endIndex) {\n                 if (buf.readableBytes() < 3) break; // Need type(2) + length(1)\n                 int extendedType = buf.readUnsignedShort();\n                 int extendedLength = buf.readUnsignedByte(); // Length of value part\n                 int valueEndIndex = buf.readerIndex() + extendedLength;\n\n                 if (extendedLength < 0 || valueEndIndex > endIndex) { // length is unsignedByte, >=0 check redundant\n                      buf.readerIndex(endIndex); // Skip to end if inner length invalid\n                      break;\n                 }\n                 if (buf.readableBytes() < extendedLength) {\n                      buf.readerIndex(endIndex); // Skip to end if not enough bytes for value\n                      break;\n                 }\n\n                 // Simplified handling using if/else and skipBytes\n                 if (extendedType == 0x0002 && extendedLength == 2) position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() * 0.1);\n                 else if (extendedType == 0x0003 && extendedLength == 2) position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                 else if (extendedType == 0x0004 && extendedLength == 2) position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                 else if (extendedType == 0x0005 && extendedLength == 4) position.set(Position.KEY_OBD_ODOMETER, buf.readUnsignedInt() * 100);\n                 else if (extendedType == 0x0007 && extendedLength == 2) position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.1);\n                 else if (extendedType == 0x0008 && extendedLength == 2) position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedShort() * 0.1);\n                 else if (extendedType == 0x0009 && extendedLength == 2) position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShort() - 40);\n                 else if (extendedType == 0x000B && extendedLength == 2) position.set(\"intakePressure\", buf.readUnsignedShort());\n                 else if (extendedType == 0x000C && extendedLength == 2) position.set(\"intakeTemp\", buf.readUnsignedShort() - 40);\n                 else if (extendedType == 0x000D && extendedLength == 2) position.set(\"intakeFlow\", buf.readUnsignedShort());\n                 else if (extendedType == 0x000E && extendedLength == 2) position.set(Position.KEY_THROTTLE, buf.readUnsignedShort() * 100 / 255);\n                 else if (extendedType == 0x0050 && extendedLength == 17) position.set(Position.KEY_VIN, buf.readSlice(17).toString(StandardCharsets.US_ASCII));\n                 else if (extendedType == 0x0100 && extendedLength == 2) position.set(Position.KEY_ODOMETER_TRIP, buf.readUnsignedShort() * 0.1);\n                 else if (extendedType == 0x0102 && extendedLength == 2) position.set(\"tripFuel\", buf.readUnsignedShort() * 0.1);\n                 else if (extendedType == 0x0112 && extendedLength == 2) position.set(\"hardAccelerationCount\", buf.readUnsignedShort());\n                 else if (extendedType == 0x0113 && extendedLength == 2) position.set(\"hardDecelerationCount\", buf.readUnsignedShort());\n                 else if (extendedType == 0x0114 && extendedLength == 2) position.set(\"hardCorneringCount\", buf.readUnsignedShort());\n                 else buf.skipBytes(extendedLength); // Skip data if type/length doesn't match known patterns\n\n                 buf.readerIndex(valueEndIndex); // Ensure index is moved past value data correctly\n             }\n         } catch (Exception e) { // Catch potential read errors\n             // Log.warn(\"Error parsing F3 extension: \" + e.getMessage());\n             buf.readerIndex(endIndex); // Ensure index advances on error\n         }\n    }\n\n    // Helper method for case 0xFE (Refactored with fix and safety checks)\n    private void handleFeExtension(Position position, ByteBuf buf, int length, int endIndex) {\n         try {\n             if (length == 1) {\n                 position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n             } else if (length > 1) {\n                 int mark = buf.readUnsignedByte();\n                 // Calculate end index for the *value* part of the FE TLV\n                 int feValueEndIndex = buf.readerIndex() + length - 1;\n\n                 if (mark == 0x7C) {\n                     // Process inner TLVs for alarms\n                     while (buf.readerIndex() < feValueEndIndex) {\n                         if (buf.readableBytes() < 2) break; // Need inner type(1) + length(1)\n                         int extendedType = buf.readUnsignedByte();\n                         int extendedLength = buf.readUnsignedByte();\n                         int innerValueEndIndex = buf.readerIndex() + extendedLength;\n\n                         if (extendedLength < 0 || innerValueEndIndex > feValueEndIndex) {\n                             buf.readerIndex(feValueEndIndex); // Skip to end of FE value section\n                             break; // Inner TLV exceeds outer boundary or invalid length\n                         }\n                         if (buf.readableBytes() < extendedLength) {\n                             buf.readerIndex(feValueEndIndex); // Skip to end of FE value section\n                             break; // Not enough bytes for inner value\n                         }\n\n                         switch (extendedType) {\n                             case 0x01: // Alarms\n                                 if (extendedLength == 4) {\n                                     long alarms = buf.readUnsignedInt();\n                                     if (BitUtil.check(alarms, 0)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION); }\n                                     if (BitUtil.check(alarms, 1)) { position.set(Position.KEY_ALARM, Position.ALARM_BRAKING); }\n                                     if (BitUtil.check(alarms, 2)) { position.set(Position.KEY_ALARM, Position.ALARM_CORNERING); }\n                                     if (BitUtil.check(alarms, 3)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT); }\n                                     if (BitUtil.check(alarms, 4)) { position.set(Position.KEY_ALARM, Position.ALARM_TAMPERING); }\n                                 } else {\n                                     buf.skipBytes(extendedLength);\n                                 }\n                                 break;\n                             default:\n                                 buf.skipBytes(extendedLength);\n                                 break;\n                         }\n                         // Ensure reader index is advanced past inner value, even if skipped\n                         buf.readerIndex(innerValueEndIndex);\n                     }\n                     // Ensure reader index is at the end of the FE value section after processing inner TLVs\n                     buf.readerIndex(feValueEndIndex);\n                 } else {\n                     // Mark is not 0x7C. Assume the byte *after* mark is battery level.\n                     // We already read 'mark' (1 byte). Length is > 1.\n                     position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                     // The outer loop's readerIndex adjustment (buf.readerIndex(endIndex))\n                     // will handle skipping any remaining bytes if length > 2.\n                 }\n             }\n             // If length is 0, do nothing. Outer loop handles index.\n         } catch (Exception e) { // Catch potential read errors\n             // Log.warn(\"Error parsing FE extension: \" + e.getMessage());\n             buf.readerIndex(endIndex); // Ensure index advances on error\n         }\n    }\n\n    // Assume decodeCustomDouble exists elsewhere and is correct\n    private double decodeCustomDouble(ByteBuf buf) {\n        // Placeholder implementation, replace with actual logic if needed\n        if (buf.readableBytes() >= 8) {\n            return buf.readDouble();\n        }\n        return 0.0;\n    }\n\n    // Assume decodeAlarm exists elsewhere and is correct\n    private String decodeAlarm(long code) {\n        // Placeholder implementation, replace with actual logic if needed\n        if (code == 0x00030002) return \"someAlarm\"; // Example\n        return null;\n    }\n\n    // Assume decodeCoordinates exists elsewhere and is correct\n    private void decodeCoordinates(Position position, ByteBuf buf) {\n        // Placeholder implementation, replace with actual logic if needed\n        if (buf.readableBytes() >= 8) {\n            position.setLatitude(buf.readInt() * 0.000001);\n            position.setLongitude(buf.readInt() * 0.000001);\n            position.setValid(true); // Assume valid if coordinates are read\n        }\n    }\n\n    // Assume readDate exists elsewhere and is correct\n    private java.util.Date readDate(ByteBuf buf, java.util.TimeZone tz) {\n        // Placeholder implementation, replace with actual logic if needed\n        if (buf.readableBytes() >= 6) {\n            int year = buf.readUnsignedByte();\n            int month = buf.readUnsignedByte();\n            int day = buf.readUnsignedByte();\n            int hour = buf.readUnsignedByte();\n            int minute = buf.readUnsignedByte();\n            int second = buf.readUnsignedByte();\n            java.util.Calendar calendar = java.util.Calendar.getInstance(tz != null ? tz : java.util.TimeZone.getTimeZone(\"UTC\"));\n            calendar.clear();\n            calendar.set(year + 2000, month - 1, day, hour, minute, second);\n            return calendar.getTime();\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}