{
    "generation": "    /**\n     * Creates a period from the given millisecond duration with the standard period type\n     * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n     * <p>\n     * The calculation uses the hour, minute, second and millisecond fields.\n     *\n     * @param duration  the duration, in milliseconds\n     */\n    protected BasePeriod(long duration) {\n        // bug [3264409] - calculation should be done using time-only period type\n        // Calculate period values using PeriodType.time() using UTC chronology\n        // This ensures that the duration is broken down into time fields only (h, m, s, ms).\n        PeriodType timeType = PeriodType.time();\n        // Use UTC chronology for duration calculations as it's context-agnostic.\n        Chronology chrono = org.joda.time.chrono.ISOChronology.getInstanceUTC();\n        // Use the chronology to get the field values for the duration according to the time-only type.\n        // The chrono.get method populates an array with values corresponding to the fields in the provided period object's type.\n        // We create a dummy MutablePeriod just to pass the timeType to chrono.get.\n        int[] values = chrono.get(new org.joda.time.MutablePeriod(timeType), duration);\n\n        // Construct the BasePeriod using the constructor that takes all fields.\n        // We explicitly set years, months, weeks, days to zero,\n        // use the calculated hours, minutes, seconds, millis,\n        // and specify the standard PeriodType for the final object.\n        // The indices in the 'values' array correspond to the fields in PeriodType.time():\n        // 0: hours, 1: minutes, 2: seconds, 3: millis\n        // We assume the 8-argument + PeriodType constructor exists and is accessible.\n        this(0, 0, 0, 0, values[0], values[1], values[2], values[3], PeriodType.standard());\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}