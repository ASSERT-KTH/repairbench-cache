{
    "generation": "import com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeUtil;\n\n// NOTE: This code assumes the existence and correct behavior of NodeUtil methods\n// like getBestJSDocInfo, isExprAssign, isPrototypeProperty, and Node#isObjectLitKey\n// (or equivalent checks for STRING_KEY, GETTER_DEF, SETTER_DEF).\n\n/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse functions where 'this'\n * is bound to a specific object (e.g., constructors, prototype methods,\n * methods in @lends objects, or methods with @this annotations).\n */\n@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  // We are only interested in pruning the traversal of functions.\n  if (n.getType() == Token.FUNCTION) {\n\n    // 1. Don't traverse functions that are constructors, interfaces,\n    //    or have annotations indicating 'this' is fixed (@this, @override).\n    //    We use getBestJSDocInfo to find JSDoc potentially attached to parent nodes.\n    JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // 2. Don't traverse functions assigned directly to a prototype property.\n    //    e.g., Foo.prototype.bar = function() { ... };\n    //    or Foo.prototype = function() { ... };\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = parent.getLastChild();\n      // Check if the function node 'n' is the RHS of the assignment\n      if (n == rhs && NodeUtil.isExprAssign(parent)) { // Ensure it's a simple assignment LHS = RHS\n        // Check if the LHS is modifying a prototype\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n            return false;\n        }\n      }\n    }\n\n    // 3. Don't traverse functions inside an object literal annotated with @lends.\n    //    e.g., /** @lends {Foo.prototype} */ ({ m: function() { ... } })\n    //    The function node 'n' would be the child of a STRING_KEY, GETTER_DEF, or SETTER_DEF node 'parent'.\n    //    The parent of 'parent' would be the OBJECTLIT node.\n    if (parent != null) {\n      Node objectLit = null;\n      // Check if the parent is an object literal key/definition node\n      // Use isObjectLitKey() or check specific token types\n       if (parent.isObjectLitKey() || // Covers STRING_KEY, GETTER_DEF, SETTER_DEF if method exists\n           parent.getType() == Token.STRING_KEY || // Explicit check otherwise\n           parent.getType() == Token.GETTER_DEF ||\n           parent.getType() == Token.SETTER_DEF) {\n         objectLit = parent.getParent();\n       }\n\n      if (objectLit != null && objectLit.getType() == Token.OBJECTLIT) {\n          // Find the JSDoc associated with the object literal, potentially\n          // coming from a parent node (e.g., a CALL or ASSIGN).\n          JSDocInfo objectLitJsDoc = NodeUtil.getBestJSDocInfo(objectLit);\n          if (objectLitJsDoc != null && objectLitJsDoc.getLendsName() != null) {\n              // This object literal's properties are lent, treat 'this' as non-global.\n              return false;\n          }\n      }\n    }\n\n    // 4. Don't traverse functions nested inside other functions.\n    //    The 'this' keyword in nested functions depends on the call site,\n    //    and isn't the primary target of CheckGlobalThis which focuses on\n    //    potentially global contexts.\n    if (parent != null && parent.getType() == Token.FUNCTION) {\n       return false;\n    }\n\n    // NOTE: The original code had a check based on parent types (BLOCK, SCRIPT, NAME, ASSIGN, STRING, NUMBER)\n    // to allow traversal only in specific contexts. This has been removed in favor of\n    // explicitly skipping known non-global contexts above. The default is now to traverse,\n    // allowing checks in IIFEs, global functions, simple method assignments, etc.\n\n    // NOTE: The original code had logic for nested assignments (assignLhsChild). This was removed\n    // as it doesn't seem relevant for deciding whether to traverse a function body for 'this' checks.\n  }\n\n  // Default behavior: traverse the node and its children.\n  // This allows visiting other node types and function bodies not explicitly excluded above.\n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}