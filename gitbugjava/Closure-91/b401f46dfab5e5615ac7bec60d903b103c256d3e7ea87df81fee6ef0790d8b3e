{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    // Don't traverse into object literals marked with @lends. Functions inside\n    // will have 'this' bound to the lent type, not the global object.\n    if (n.getType() == Token.OBJECTLIT) {\n      JSDocInfo jsDoc = n.getJSDocInfo();\n      if (jsDoc != null && jsDoc.getLendsName() != null) {\n        return false;\n      }\n    }\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation, or are interfaces. 'this' is bound correctly.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they are defined in a context where 'this'\n      // might be meaningfully bound (e.g., function declaration, assignment to variable\n      // or property, object literal method, class method). Functions defined\n      // elsewhere (e.g., as immediate arguments to functions) are more likely\n      // to have 'this' bound incorrectly or unexpectedly.\n      if (parent != null) {\n          int pType = parent.getType();\n          if (!(pType == Token.BLOCK ||         // function f() {}\n                pType == Token.SCRIPT ||        // function f() {} (global scope)\n                pType == Token.NAME ||          // var f = function() ...\n                pType == Token.ASSIGN ||        // x = function() ... or x.y = function() ...\n                pType == Token.STRING_KEY ||    // { 'k': function() ... }\n                pType == Token.GETTER_DEF ||    // { get k() ... }\n                pType == Token.SETTER_DEF ||    // { set k() ... }\n                pType == Token.MEMBER_FUNCTION_DEF)) { // class C { m() ... }\n             return false;\n          }\n      }\n      // Allow traversal for functions at the root (parent == null) implicitly.\n    }\n\n    // Handle assignments, especially assignments to prototype properties.\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of an assignment.\n        // Track the LHS for potential use in the visit method (e.g. `a = this`).\n        // (assignLhsChild is assumed to be a member variable of the class)\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else { // n == rhs\n        // Don't traverse the RHS if it's being assigned to a prototype property.\n        // Functions/objects defined here are methods/properties and 'this' refers\n        // to the instance, so no need to check for global 'this'.\n        // e.g. Foo.prototype.bar = function() { ... }\n        // e.g. Foo.prototype.baz = { qux: function() { ... } }\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}