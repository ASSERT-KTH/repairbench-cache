{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    // Rule 1: Don't traverse functions with specific JSDoc annotations\n    // that imply 'this' is not global (@constructor, @interface, @this, @override).\n    if (n.isFunction()) {\n      // Use the specific helper from the original code context, assuming it gets JSDoc directly on n\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Rule 2: Don't traverse functions inside object literals annotated with @lends.\n      // This indicates the methods should be treated as prototype methods.\n      if (parent != null) {\n        Node grandparent = parent.getParent();\n        boolean isFunctionValueInObjectLit = false;\n\n        // Check if n is the function node within an Object Literal structure\n        if (grandparent != null && grandparent.isObjectLit()) {\n           // Cases like: { method() { [n] } } or { get x() { [n] } } or { set x(v) { [n] } }\n           // Here n=FUNCTION, parent=MEMBER_FUNCTION_DEF/GETTER_DEF/SETTER_DEF, grandparent=OBJECTLIT\n           if ((parent.isMemberFunctionDef() || parent.isGetterDef() || parent.isSetterDef()) &&\n               parent.getLastChild() == n) { // Ensure n is the function body\n             isFunctionValueInObjectLit = true;\n           }\n           // Cases like: { 'key': [n] }, { 123: [n] }\n           // Here n=FUNCTION, parent=STRING_KEY/NUMBER, grandparent=OBJECTLIT\n           else if ((parent.isStringKey() || parent.isNumber()) &&\n                     parent.hasChildren() && parent.getFirstChild() == n) { // Ensure n is the value\n             isFunctionValueInObjectLit = true;\n           }\n           // Computed properties { [expr]: function() {} } could also have @lends,\n           // Parent would be COMPUTED_PROP. Add if needed.\n           // else if (parent.isComputedProp() && parent.getLastChild() == n) {\n           // isFunctionValueInObjectLit = true;\n           // }\n        }\n\n        if (isFunctionValueInObjectLit) {\n            // Check the JSDoc on the OBJECTLIT node (grandparent) for @lends\n            JSDocInfo objectLitJsDoc = grandparent.getJSDocInfo();\n            if (objectLitJsDoc != null && objectLitJsDoc.getLendsName() != null) {\n               // Found @lends on the containing object literal, don't traverse function n.\n               return false;\n            }\n        }\n      }\n    } // End of n.isFunction() block for rules 1 & 2\n\n    // Rule 3: Don't traverse the RHS function node if it's being assigned directly\n    // to a prototype property (e.g., Foo.prototype.bar = function() { ... }).\n    // This needs to check if 'n' itself is the function node being assigned.\n    if (parent != null && parent.isAssign() && n == parent.getLastChild() && n.isFunction()) {\n        // n is the function node on the RHS of an assignment.\n        Node lhs = parent.getFirstChild();\n\n        // Check if lhs is Foo.prototype or Foo.prototype.bar\n        if (lhs.isGetProp()) { // e.g., a.b or a.b.c\n            Node lastChild = lhs.getLastChild();\n            // Check for Foo.prototype = function() { ... };\n            if (lastChild.isString() && lastChild.getString().equals(\"prototype\")) {\n                return false;\n            }\n\n            Node maybePrototype = lhs.getFirstChild(); // e.g., a.b from a.b.c\n            // Check for Foo.prototype.bar = function() { ... }; where maybePrototype is Foo.prototype\n            if (maybePrototype.isGetProp()) {\n                 Node prototypeChild = maybePrototype.getLastChild(); // e.g., 'prototype' from Foo.prototype\n                 if (prototypeChild.isString() && prototypeChild.getString().equals(\"prototype\")) {\n                    return false;\n                 }\n            }\n        }\n    }\n\n    // Removed the original parent type check (BLOCK, SCRIPT, NAME, ASSIGN etc.) as it seemed unreliable\n    // and prevented correct handling of cases like @lends. The specific checks above are more targeted.\n\n    // Retain the assignLhsChild logic if it's used elsewhere in the surrounding class,\n    // but it doesn't influence the traversal decision here.\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        if (n == lhs) {\n          // We are traversing the LHS of an assignment.\n          if (assignLhsChild == null) { // Condition from original code\n            assignLhsChild = lhs;\n          }\n        }\n    }\n\n    // Default: Traverse the node. Allows the pass to find 'this' usages unless\n    // specifically excluded by the rules above (JSDoc, @lends, prototype assignment).\n    return true;\n  }\n\n  // Assume getFunctionJsDocInfo is defined in the surrounding class and correctly\n  // retrieves JSDoc information specifically associated with the function Node n.\n  abstract JSDocInfo getFunctionJsDocInfo(Node n);\n\n  // Assume assignLhsChild is a field in the surrounding class.\n  private Node assignLhsChild = null;",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}