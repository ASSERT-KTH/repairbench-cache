{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse function contexts where\n   * {@code this} is known to be bound to an object or where the context\n   * strongly suggests it's not global.\n   */\n  @Override // Assuming this overrides a TraversalCallback method\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have @this/@override,\n      // or are inside an object literal with @lends.\n\n      // Check 1: JSDoc on the function itself indicating 'this' type.\n      // Use the existing helper method from the original snippet.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false; // 'this' has a known non-global meaning.\n      }\n\n      // Check 2: @lends annotation on a parent object literal.\n      Node objectLit = null;\n      if (parent != null && parent.isStringKey() && parent.getParent() != null && parent.getParent().isObjectLit()) {\n          // Covers: /** @lends ... */ ({ key: function() { ... } })\n          objectLit = parent.getParent();\n      } else if (parent != null && parent.isMemberFunctionDef() && parent.getParent() != null && parent.getParent().isObjectLit()) {\n          // Covers: /** @lends ... */ ({ method() { ... } }) (ES6 syntax)\n          objectLit = parent.getParent();\n      }\n\n      if (objectLit != null) {\n          // Use NodeUtil.getBestJSDocInfo which handles JSDoc possibly attached\n          // to a parent node (like VAR or ASSIGN).\n          JSDocInfo objectLitJsDoc = NodeUtil.getBestJSDocInfo(objectLit);\n          if (objectLitJsDoc != null && objectLitJsDoc.getLendsName() != null) {\n              // Function is intended as a method on the type specified by @lends.\n              return false; // 'this' refers to an instance of the specified type.\n          }\n      }\n\n\n      // Check 3: Original check based on parent type (pruning strategy).\n      // Don't traverse functions unless they are in common declaration/assignment\n      // patterns where 'this' might be global or where @this annotation is applicable.\n      if (parent != null) {\n          int pType = parent.getType();\n          // Update the list of context types based on original code and potential node types.\n          // STRING_KEY for { 'key': function()... }\n          // MEMBER_FUNCTION_DEF for { method()... }\n          boolean isPotentialGlobalThisContext =\n              pType == Token.BLOCK ||        // function func()...\n              pType == Token.SCRIPT ||       // function func()... (at top level)\n              pType == Token.NAME ||         // var func = function()...\n              pType == Token.ASSIGN ||       // obj.prop = function()...\n              pType == Token.STRING_KEY ||   // { key: function()... } (covers original STRING/NUMBER)\n              pType == Token.MEMBER_FUNCTION_DEF; // { method()... }\n\n          if (!isPotentialGlobalThisContext) {\n              // If function is in other contexts (e.g., IIFE, callback), assume 'this'\n              // is non-global based on the original logic's pruning.\n              return false;\n          }\n      }\n      // Implicit else: If parent is null (root function) or context is potential global this, continue traversal checks.\n\n    } // End of Function Node Checks\n\n    // Check 4: Original check for assignments involving prototypes (outside the FUNCTION block).\n    // This handles cases like `Foo.prototype.bar = function() {}` or `Foo.prototype = {...}`.\n    // If 'n' is the RHS of such an assignment, don't traverse it.\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      // This logic relies on 'assignLhsChild' potentially being a member variable of the class.\n      // Keep the original logic for handling the LHS of assignments.\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        // Assuming 'assignLhsChild' is a field in the CheckGlobalThis class:\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else if (n == rhs) { // Check if 'n' is the RHS node being traversed\n        // If the assignment target (LHS) is a prototype property or the prototype itself,\n        // then assume 'this' inside the RHS (n) refers to an instance, so don't traverse.\n        // Use NodeUtil.isPrototypeProperty for a robust check.\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n            return false;\n        }\n      }\n    } // End of Assignment Node Checks\n\n    // If none of the above checks returned false, traverse the node.\n    return true;\n  }\n\n  // NOTE: This fixed code assumes the existence of:\n  // 1. A member variable `assignLhsChild` in the surrounding class.\n  // 2. A helper method `getFunctionJsDocInfo(Node n)` in the surrounding class.\n  // 3. Standard Google Closure Compiler classes like Node, NodeTraversal, JSDocInfo, Token, NodeUtil.",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}