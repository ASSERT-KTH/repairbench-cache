{
    "generation": "    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf);\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        if (buf.readableBytes() == 20) {\n\n            buf.skipBytes(4); // remaining battery and mileage\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n            buf.readUnsignedInt(); // area id\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            buf.skipBytes(3); // reserved\n\n            return position;\n\n        }\n\n        while (buf.readableBytes() > 2) { // Need at least subtype (1) and length (1)\n\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n            int endIndex = buf.readerIndex() + length;\n\n            // Basic bounds check: ensure endIndex is not before readerIndex and within buffer limits\n            // Also check if buffer actually has 'length' bytes readable starting now.\n            if (endIndex < buf.readerIndex() || endIndex > buf.writerIndex() || buf.readableBytes() < length) {\n                break; // Invalid length/endIndex or not enough data, stop processing TLVs\n            }\n\n            String stringValue;\n            switch (subtype) {\n                case 0x01: // Odometer\n                    if (length == 4) {\n                       position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    }\n                    break;\n                case 0x02: // Fuel Level\n                    if (length == 2) {\n                       position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1);\n                    }\n                    break;\n                case 0x2b: // Fuel Consumption\n                     if (length == 4) {\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt());\n                    }\n                    break;\n                case 0x30: // RSSI\n                    if (length == 1) {\n                       position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0x31: // Satellites\n                     if (length == 1) {\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0x33: // Lock Status String\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        // Check string format before parsing\n                        if (stringValue.startsWith(\"*M00\") && stringValue.length() >= 15) {\n                            String lockStatus = stringValue.substring(8, 15); // Length 7\n                            if (lockStatus.length() >= 5) {\n                                try {\n                                   position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                                } catch (NumberFormatException e) {\n                                    // Ignore if battery part is not a number\n                                }\n                            }\n                        }\n                    }\n                    break;\n                case 0x56: // Battery Level and Reserved\n                    if (length == 2) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 10);\n                        buf.readUnsignedByte(); // reserved\n                    }\n                    break;\n                case 0x60: // Event\n                    if (length >= 2) {\n                        position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                        // Skip remaining bytes if length > 2, handled by readerIndex(endIndex) below\n                    }\n                    break;\n                case 0x69: // Battery Voltage\n                    if (length == 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    }\n                    break;\n                case 0x80: // Extension data\n                    // Assuming decodeExtension consumes buffer data up to endIndex\n                    decodeExtension(position, buf, endIndex);\n                    break; // Added missing break\n                case 0x91: // OBD data block\n                    // Check if length matches expected size for all fields\n                    if (length >= 21) { // Sum of bytes read/skipped\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n                        position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                        position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte());\n                        position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255);\n                        position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255);\n                        position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40);\n                        buf.readUnsignedShort(); // skip 2\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01);\n                        buf.readUnsignedShort(); // skip 2\n                        buf.readUnsignedInt();   // skip 4\n                        buf.readUnsignedShort(); // skip 2\n                        position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01);\n                    }\n                    break;\n                case 0x94: // VIN\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                case 0xA7: // ADC\n                     if (length == 4) {\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                        position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                    }\n                    break;\n                case 0xAC: // Odometer (alternative)\n                    if (length == 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                    }\n                    break;\n                case 0xBC: // Driver Name/ID String\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(\"driver\", stringValue.trim());\n                    }\n                    break;\n                case 0xBD: // Driver Unique ID String\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                    }\n                    break;\n                case 0xD0: // User Status / Vibration Alarm\n                    if (length == 4) {\n                        long userStatus = buf.readUnsignedInt();\n                        if (BitUtil.check(userStatus, 3)) {\n                            position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                        }\n                    }\n                    break;\n                case 0xD3: // Power Voltage\n                     if (length == 2) {\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    }\n                    break;\n                case 0xD4: // Battery Level\n                case 0xE1: // Battery Level (alternative) -> Fallthrough\n                     if (length == 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0xD5: // Battery Voltage or Lock Info\n                    if (length == 2) { // Battery Voltage format\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 0) { // Lock Info format (at least 1 byte for count)\n                        int count = buf.readUnsignedByte();\n                        int expectedMinLength = 1 + count * 13; // 1 for count, 13 per lock (5+5+1+2)\n                        // Check if declared length matches expected and buffer has enough for locks\n                        if (length >= expectedMinLength && buf.readableBytes() >= expectedMinLength - 1) {\n                            for (int i = 1; i <= count; i++) {\n                                position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                                int status = buf.readUnsignedShort();\n                                position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                            }\n                        }\n                    }\n                    break;\n                case 0xDA: // Device Status (string cut, motion, cover)\n                    if (length >= 3) { // Need 2 for count + 1 for status\n                        buf.readUnsignedShort(); // string cut count (unused)\n                        int deviceStatus = buf.readUnsignedByte();\n                        position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                        position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                        position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                    }\n                    break;\n                case 0xE6: // External Sensor Data (Temp/Humidity)\n                    // Loop respects endIndex which is validated at the start\n                    while (buf.readerIndex() < endIndex) {\n                        // Check bytes needed per sensor: index(1)+mac(6)+temp(8)+humidity(8) = 23\n                        if (buf.readableBytes() < 23) {\n                           break;\n                        }\n                        int sensorIndex = buf.readUnsignedByte();\n                        buf.skipBytes(6); // mac\n                        position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(buf));\n                        position.set(\"humidity\" + sensorIndex, decodeCustomDouble(buf));\n                    }\n                    break;\n                case 0xEB: // Network Info or Extended Attributes\n                    // Ensure processing respects endIndex validated at start\n                    if (length >= 2) { // Need at least 2 bytes to check format type\n                       if (buf.getUnsignedShort(buf.readerIndex()) > 200) { // Network info format\n                            if (buf.readableBytes() >= 3) { // Need mcc(2), mnc(1)\n                                Network network = new Network();\n                                int mcc = buf.readUnsignedShort();\n                                int mnc = buf.readUnsignedByte();\n                                while (buf.readerIndex() < endIndex) {\n                                    // Check bytes needed per cell: lac(2), cid(2/4?), rssi(1)\n                                    // Assuming 2 bytes for CID based on original code usage\n                                    if (buf.readableBytes() < 5) break;\n                                    network.addCellTower(CellTower.from(\n                                            mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(),\n                                            buf.readUnsignedByte()));\n                                }\n                                if (network.getCellTowers() != null && !network.getCellTowers().isEmpty()) {\n                                    position.setNetwork(network);\n                                }\n                            }\n                        } else { // Extended attributes format (Inner TLV: Len(2), Type(2), Value)\n                            while (buf.readerIndex() < endIndex) {\n                                if (buf.readableBytes() < 4) break; // Need inner length(2) and type(2)\n                                int extendedLength = buf.readUnsignedShort(); // Length includes type field\n                                int extendedType = buf.readUnsignedShort();\n                                int extendedValueIndex = buf.readerIndex();\n                                // Value length = extendedLength - 2 (type), must be >= 0\n                                int valueLength = extendedLength >= 2 ? extendedLength - 2 : 0;\n                                int extendedEndIndex = extendedValueIndex + valueLength;\n\n                                // Validate inner endIndex against outer endIndex and current index\n                                if (extendedEndIndex > endIndex || extendedEndIndex < extendedValueIndex) {\n                                    break; // Invalid inner length/end index\n                                }\n                                if (buf.readableBytes() < valueLength) {\n                                    break; // Not enough data for inner value\n                                }\n\n                                switch (extendedType) {\n                                    case 0x0001: if(valueLength>=3) {position.set(\"fuel1\", buf.readUnsignedShort() * 0.1); buf.readUnsignedByte();} break;\n                                    case 0x0023: if(valueLength>=6) {position.set(\"fuel2\", Double.parseDouble(buf.readCharSequence(6, StandardCharsets.US_ASCII).toString()));} break;\n                                    case 0x00CE: if(valueLength>=2) {position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);} break;\n                                    case 0x00D8: // Inner Network Cell Tower\n                                        if (valueLength >= 7) { // mcc(2)+mnc(1)+lac(2)+cid(4)=9? Original uses 7 bytes read. Rechecking...\n                                            // CellTower.from(mcc, mnc, lac, cid) used in main part takes 4 args.\n                                            // CellTower.from(mcc, mnc, lac, cid, rs) takes 5.\n                                            // Here it reads mcc(2)+mnc(1)+lac(2)+cid(4)=9 bytes. Let's assume CID is 4 bytes here.\n                                             if (valueLength >= 9) {\n                                                Network network = new Network();\n                                                network.addCellTower(CellTower.from(\n                                                        buf.readUnsignedShort(), buf.readUnsignedByte(), // mcc, mnc\n                                                        buf.readUnsignedShort(), buf.readUnsignedInt())); // lac, cid\n                                                position.setNetwork(network);\n                                             }\n                                        }\n                                        break;\n                                    case 0xE1:   if(valueLength>=1) {position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());} break;\n                                    default: break; // Value skipped by readerIndex adjustment below\n                                }\n                                buf.readerIndex(extendedEndIndex); // Ensure correct position after inner item\n                            }\n                        }\n                    }\n                    break;\n                case 0xED: // Card Number String\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_CARD, stringValue.trim());\n                    }\n                    break;\n                case 0xEE: // Combined Status (RSSI, Power, Battery, Sats)\n                    if (length == 6) { // rssi(1)+power(2)+battery(2)+sat(1)\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0xF3: // OBD Extended Data (Inner TLV: Type(2), Len(1), Value)\n                     // Ensure processing respects outer endIndex validated at start\n                    while (buf.readerIndex() < endIndex) {\n                        if (buf.readableBytes() < 3) break; // Need inner type(2) + length(1)\n                        int extendedType = buf.readUnsignedShort();\n                        int extendedLength = buf.readUnsignedByte(); // This is value length\n                        int extendedValueIndex = buf.readerIndex();\n                        int extendedEndIndex = extendedValueIndex + extendedLength;\n\n                        // Validate inner endIndex against outer endIndex and current index\n                        if (extendedEndIndex > endIndex || extendedEndIndex < extendedValueIndex) {\n                            break; // Invalid inner length/end index\n                        }\n                        if (buf.readableBytes() < extendedLength) {\n                            break; // Not enough data for inner value\n                        }\n\n                        switch (extendedType) {\n                            // Add length checks matching data read\n                            case 0x0002: if(extendedLength>=2) {position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() * 0.1);} break;\n                            case 0x0003: if(extendedLength>=2) {position.set(Position.KEY_RPM, buf.readUnsignedShort());} break;\n                            case 0x0004: if(extendedLength>=2) {position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);} break;\n                            case 0x0005: if(extendedLength>=4) {position.set(Position.KEY_OBD_ODOMETER, buf.readUnsignedInt() * 100);} break;\n                            case 0x0007: if(extendedLength>=2) {position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.1);} break;\n                            case 0x0008: if(extendedLength>=2) {position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedShort() * 0.1);} break;\n                            case 0x0009: if(extendedLength>=2) {position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShort() - 40);} break;\n                            case 0x000B: if(extendedLength>=2) {position.set(\"intakePressure\", buf.readUnsignedShort());} break;\n                            case 0x000C: if(extendedLength>=2) {position.set(\"intakeTemp\", buf.readUnsignedShort() - 40);} break;\n                            case 0x000D: if(extendedLength>=2) {position.set(\"intakeFlow\", buf.readUnsignedShort());} break;\n                            // Original used readUnsignedShort for Throttle, but scaling suggests byte? Using original for now. Check protocol doc.\n                            case 0x000E: if(extendedLength>=2) {position.set(Position.KEY_THROTTLE, buf.readUnsignedShort() * 100 / 255);} break;\n                            case 0x0050: if(extendedLength>=17) {position.set(Position.KEY_VIN, buf.readSlice(17).toString(StandardCharsets.US_ASCII));} break;\n                            case 0x0100: if(extendedLength>=2) {position.set(Position.KEY_ODOMETER_TRIP, buf.readUnsignedShort() * 0.1);} break;\n                            case 0x0102: if(extendedLength>=2) {position.set(\"tripFuel\", buf.readUnsignedShort() * 0.1);} break;\n                            case 0x0112: if(extendedLength>=2) {position.set(\"hardAccelerationCount\", buf.readUnsignedShort());} break;\n                            case 0x0113: if(extendedLength>=2) {position.set(\"hardDecelerationCount\", buf.readUnsignedShort());} break;\n                            case 0x0114: if(extendedLength>=2) {position.set(\"hardCorneringCount\", buf.readUnsignedShort());} break;\n                            default: break; // Value skipped by readerIndex adjustment below\n                        }\n                        buf.readerIndex(extendedEndIndex); // Ensure correct position after inner item\n                    }\n                    break;\n                case 0xFE: // Battery/Power or Complex Alarm/Status (Inner TLV: Type(1), Len(1), Value)\n                    if (length == 1) { // Battery Level format\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else if (length == 2) { // Power Voltage format\n                         position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    } else if (length > 2) { // Complex format, starts with mark byte\n                        int mark = buf.readUnsignedByte(); // Read first byte of value field\n                        if (mark == 0x7C) { // Indicates inner TLV structure follows\n                            // Loop respects outer endIndex\n                            while (buf.readerIndex() < endIndex) {\n                                if (buf.readableBytes() < 2) break; // Need inner type(1) and length(1)\n                                int extendedType = buf.readUnsignedByte();\n                                int extendedLength = buf.readUnsignedByte(); // Value length\n                                int extendedValueIndex = buf.readerIndex();\n                                int extendedEndIndex = extendedValueIndex + extendedLength;\n\n                                // Validate inner endIndex against outer endIndex and current index\n                                if (extendedEndIndex > endIndex || extendedEndIndex < extendedValueIndex) {\n                                    break; // Invalid inner length/end index\n                                }\n                                if (buf.readableBytes() < extendedLength) {\n                                    break; // Not enough data for inner value\n                                }\n\n                                switch (extendedType) {\n                                    case 0x01: // Alarm flags\n                                        if (extendedLength >= 4) { // Check length for uint alarm flags\n                                            long alarms = buf.readUnsignedInt();\n                                            if (BitUtil.check(alarms, 0)) position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION);\n                                            if (BitUtil.check(alarms, 1)) position.set(Position.KEY_ALARM, Position.ALARM_BRAKING);\n                                            if (BitUtil.check(alarms, 2)) position.set(Position.KEY_ALARM, Position.ALARM_CORNERING);\n                                            if (BitUtil.check(alarms, 3)) position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT);\n                                            if (BitUtil.check(alarms, 4)) position.set(Position.KEY_ALARM, Position.ALARM_TAMPERING);\n                                        }\n                                        break;\n                                    default: break; // Value skipped by readerIndex adjustment below\n                                }\n                                 buf.readerIndex(extendedEndIndex); // Ensure correct position after inner item\n                            }\n                        }\n                        // If mark != 0x7C, the remaining length-1 bytes are skipped by the outer logic below\n                        // Original code had a possibly erroneous battery read here, which is removed.\n                    }\n                    break;\n                default:\n                    // Unknown subtype, data will be skipped by readerIndex adjustment below\n                    break;\n            }\n\n            // Set reader index to the end of the TLV item's value field.\n            // This skips any unread bytes within the current item's declared length,\n            // handles the default case (unknown subtype), and ensures the loop progresses correctly.\n            // Bounds were checked before the switch, so endIndex should be valid.\n            buf.readerIndex(endIndex);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}