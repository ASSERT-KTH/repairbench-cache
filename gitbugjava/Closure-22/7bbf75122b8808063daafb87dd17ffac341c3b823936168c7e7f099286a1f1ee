{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n\n    // Handle COMMAs operands differently.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      // Prevent report warning on calls to eval. We are unable to evaluate\n      // the safety of the arguments String value.\n      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n          return;\n        }\n      }\n\n      // The result of the non-last child of a comma is ignored. Check if it\n      // has side effects.\n      if (n != parent.getLastChild()) {\n        if (!NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n          // Exceptions: Check for JSDoc on names which implies the no-op\n          // statement is there intentionally.\n          if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n             // Suppress warning.\n          } else if (n.isExprResult()) {\n            // This indicates an error in the AST structure.\n            // Ignore EXPR_RESULT node itself.\n          } else {\n            boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n            String msg = \"This code lacks side-effects. Is there a bug?\";\n            if (n.isString()) {\n              msg = \"Is there a missing '+' on the previous line?\";\n            } else if (isSimpleOp) {\n              msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n                  \"' operator is not being used.\";\n            }\n            // Use the DiagnosticGroup defined in CheckSideEffects\n            t.getCompiler().report(\n                t.makeError(n, level, USELESS_CODE_ERROR, msg));\n            // Record the node for potential removal.\n            // Use the same condition as in the original code's final block.\n            if (!NodeUtil.isStatement(n)) {\n              problemNodes.add(n);\n            }\n          }\n        }\n        // We have handled the non-last child of the comma. Stop processing.\n        return;\n      } else {\n        // For the last child of the comma, its value may be used.\n        // Check the context of the comma expression. If the value is used,\n        // don't report a warning.\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          // If the comma expression is not part of a EXPR_RESULT or BLOCK,\n          // its value is likely used. Example: return (a(), b);\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n            return; // Result is used, suppress warning.\n          else\n            // Found EXPR_RESULT or BLOCK. Result might be unused.\n            // Stop searching and fall through to the final check.\n            break;\n        }\n        // Fall through to the final check if the result might be unused.\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      // If the parent is not an EXPR_RESULT or BLOCK, the expression's\n      // result is likely used.\n      // An exception: The initializer and increment parts of a FOR loop.\n      // These are not used expressions *in the sense that their result matters*,\n      // but they are allowed locations for expressions with side effects.\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&\n           (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n          // Allow expressions in FOR initializer and increment.\n          // The final check below will verify if they lack side effects.\n          // Fall through.\n      } else {\n        // The expression's result is used in other contexts (assignments, conditions, etc.).\n        return;\n      }\n    }\n\n    // If we reach here, 'n' is typically a child of EXPR_RESULT or BLOCK,\n    // or it's the initializer/increment of a FOR loop,\n    // or it's the last child of a COMMA whose result is potentially unused.\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      } else if (n.isExprResult()) {\n        // This node type is already handled by visiting its children.\n        // An EXPR_RESULT node indicates a statement-level expression;\n        // its child is the actual expression node we'd want to check.\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}