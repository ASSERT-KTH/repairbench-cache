{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty()) {\n      return;\n    }\n\n    // Don't warn about COMMA nodes themselves. We check their children.\n    // The result of a comma node has its use checked when we visit the parent\n    // node.\n    if (n.isComma()) {\n      return;\n    }\n\n\n    if (parent == null) {\n      return;\n    }\n\n    // Handle special cases for COMMA children\n    if (parent.isComma()) {\n      Node gramps = parent.getParent();\n      // Always consider the first part of a \"var C = A, B;\" to be used.\n      // TODO(johnlenz): Is this true? What is the definition of \"used\"?\n      //                 Perhaps this is just suppressing a warning.\n      if (gramps.isVar() && parent == gramps.getFirstChild()) {\n         if (n == parent.getFirstChild()) {\n             return;\n         }\n      }\n\n      // eval(foo, bar) is special case. Don't warn about the foo.\n      if (gramps.isCall() && parent == gramps.getFirstChild() && n == parent.getFirstChild()) {\n        Node fun = gramps.getFirstChild();\n        if (fun.isName() && \"eval\".equals(fun.getString())) {\n          return;\n        }\n      }\n\n      // The result of the last expression in a comma operator is used.\n      // The results of the previous expressions are discarded.\n      if (n == parent.getLastChild()) {\n          // Don't check the last child; its result is used by the COMMA op.\n          // Whether the COMMA op result is used is checked elsewhere.\n         return;\n      }\n      // Fall through to the main check for non-last children of COMMA.\n    }\n    // NOTE: The original code had an \"else if\" here that skipped the check\n    // if the parent was not EXPR_RESULT or BLOCK (e.g., parent was IF).\n    // This was incorrect, as it prevented checks like \"if(x) y == z;\".\n    // Removing that condition allows the main check below to run more broadly.\n\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.isExprResult() || parent.isBlock()) {\n      // Allow Normally, EXPR_RESULT and BLOCK nodes are handled by our\n      // child traversal. The exception is labels labels pointing Blocks or\n      // EXPR_RESULT nodes. Keep these labels.\n      // TODO(johnlenz): Handle these cases in the peephole passes. Either\n      // by removing the labels or the nodes.\n      if (parent.isBlock()\n          && parent.getParent() != null\n          && parent.getParent().isLabel()) {\n         return;\n      }\n    } else if (parent.isFor() && parent.getChildCount() == 4 && n != parent.getFirstChild().getNext()) {\n        // Only check the condition of a FOR loop. The init and increment\n        // parts are checked by mayHaveSideEffects.\n        return;\n    } else if (!NodeUtil.isStatementParent(parent)){\n        // Otherwise, if the parent is not a statement node, then the side\n        // effects aren't used. This is likely some construct like:\n        // if (foo) { bar(); }\n        // In this case, the results of foo are used, but the results of bar()\n        // are not.\n        return;\n    }\n\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        // This no-op statement was there so that JSDoc information could\n        // be attached to the name. This check should not complain about it.\n        return;\n      } else if (n.isExprResult()) {\n        // Before we evaluate the child, we need to make sure\n        // that the child is not a constructor call. This happens\n        // when the compiler does work like this:\n        //   var x = new Foo(); Foo.apply(x);\n        // ->\n        //   var x = new Foo(); x.apply();  // Not possible in valid JS.\n        // ->\n        //   var x = new Foo(); // Remove useless call.\n        // TODO(johnlenz): Introduce a NoOp node type.\n\n        // We don't want to flag EXPR_RESULT nodes directly. We want to\n        // flag their children.\n        return;\n      }\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      // We only remove things from the AST if they are not statements.\n      // Removing statements like IFs, LABELs, etc is handled by other\n      // optimization passes.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}