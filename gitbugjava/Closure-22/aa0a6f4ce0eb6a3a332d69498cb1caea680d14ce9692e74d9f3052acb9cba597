{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // Allow these.\n    if (n.isEmpty()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Check for useless code:\n    // An expression statement or sub-expression whose result is not used\n    // and that has no side effects according to NodeUtil analysis.\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n\n    // Expressions that don't have side effects include simple operators\n    // (like +, -, ==), literals, and names/qualified names unless they are\n    // on the left side of an assignment or part of a delete/inc/dec operation.\n    // NodeUtil.mayHaveSideEffects covers most of this. Simple operators are\n    // particularly common cases of useless code.\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    boolean hasNoSideEffects = !NodeUtil.mayHaveSideEffects(n, t.getCompiler());\n\n    // If the result isn't used and the expression has no side effects (or is a simple op),\n    // it's potentially useless code.\n    if (!isResultUsed && (isSimpleOp || hasNoSideEffects)) {\n\n      // Allow certain types of constructs known to be harmless, such as type annotations.\n\n      // Allow unused expressions if they have JsDoc. These are often used\n      // for type annotations or casting. Example: /** @type {string} */ someVar;\n      if (n.getJSDocInfo() != null) {\n        return;\n      }\n      // Also allow expression statements whose sole purpose is JsDoc: /** @type {foo} */ (expr);\n      // Here, the EXPR_RESULT node holds the JsDoc.\n      if (parent.isExprResult() && parent.getJSDocInfo() != null) {\n        return;\n      }\n\n      // Report the warning.\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        // Special message for strings since they are sometimes unintentional fragments\n        // left over from combining lines.\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        // More specific message for simple operators.\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      // Report the error/warning to the compiler.\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Original code added nodes to problemNodes here for potential removal by other passes.\n      // This logic is omitted as problemNodes is not defined in the scope of this function fix.\n      // if (!NodeUtil.isStatement(n)) {\n      //   problemNodes.add(n);\n      // }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}