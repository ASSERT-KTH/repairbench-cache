{
    "generation": "    public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n    {\n        // There are certain nasty classes that could cause problems, mostly\n        // via default typing -- catch them here.\n        final Class<?> raw = type.getRawClass();\n        // Class.getName() is unlikely to return null, but let's be defensive\n        // Also, raw can be null for some odd types (like marker types), see [databind#2811]\n        if (raw == null) {\n             return; // Or should we throw? For now, return seems safer\n        }\n\n        String full = raw.getName();\n\n        main_check:\n        do {\n            if (_cfgIllegalClassNames.contains(full)) {\n                break;\n            }\n\n            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n            //    for some Spring framework types\n            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n            if (full.startsWith(PREFIX_STRING)) {\n                // 11-Nov-2019, tatu: Check may be too broad, causing issues like [databind#2534].\n                //    Let's add finer-grained checks... first, interface check:\n                // Check added in 2.10.1: Block all interfaces / abstract types by default\n                 if (raw.isInterface() || raw.isAbstract()) {\n                    break main_check; // default break: security risk otherwise\n                 }\n                \n                // If not interface/abstract, maybe specific problematic classes?\n                // Need to check base classes AND potentially interfaces, but base classes first\n                // 08-Oct-2019, tatu: As per [databind#2470], this check may need to be done\n                //    more generally, perhaps configurable? For now, just add one more default\n                 // Fixed loop condition for [databind#1872]: added 'cls != null' to prevent NPE when raw is an interface\n                 // (even if check above was not done)\n                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {\n                    String name = cls.getSimpleName();\n                    // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                    if (\"AbstractPointcutAdvisor\".equals(name)\n                            // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                            || \"AbstractApplicationContext\".equals(name)) {\n                        break main_check;\n                    }\n                }\n            }\n            // Ok, fine, looks like a legit type for now\n            return;\n        } while (false);\n\n        // If we get this far, not acceptable\n        throw JsonMappingException.from(ctxt,\n                String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}