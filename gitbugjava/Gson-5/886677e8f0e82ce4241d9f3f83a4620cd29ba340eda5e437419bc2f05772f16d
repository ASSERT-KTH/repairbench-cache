{
    "generation": "import java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\n\n// Assume helper methods parseInt, checkOffset, indexOfNonDigit are available and correct.\n// Assume TIMEZONE_UTC is defined as TimeZone.getTimeZone(\"UTC\").\n// The following class structure is just for encapsulating the method.\nclass DateUtil {\n    private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");\n\n    // Assume these helper methods exist and are implemented correctly elsewhere\n    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n         return Integer.parseInt(value.substring(beginIndex, endIndex));\n    }\n    private static boolean checkOffset(String value, int offset, char expected) {\n        return (offset < value.length()) && (value.charAt(offset) == expected);\n    }\n    private static int indexOfNonDigit(String string, int offset) {\n        for (int i = offset; i < string.length(); i++) {\n            if (!Character.isDigit(string.charAt(i))) {\n                return i;\n            }\n        }\n        return string.length();\n    }\n\n\n    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     *\n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            if (date.length() < offset + 4) throw new StringIndexOutOfBoundsException(\"Expected 'yyyy' at index \" + offset);\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            if (date.length() < offset + 2) throw new StringIndexOutOfBoundsException(\"Expected 'MM' at index \" + offset);\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            if (date.length() < offset + 2) throw new StringIndexOutOfBoundsException(\"Expected 'dd' at index \" + offset);\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n\n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n                // Note: Uses default timezone. Consider UTC if standard requires.\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n                offset += 1; // Consume 'T'\n\n                // Expect hh\n                if (date.length() < offset + 2) throw new StringIndexOutOfBoundsException(\"Expected 'hh' after 'T' at index \" + offset);\n                hour = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1; // Consume optional ':' separator\n                }\n\n                // Expect mm\n                if (date.length() < offset + 2) throw new StringIndexOutOfBoundsException(\"Expected 'mm' after 'hh' at index \" + offset);\n                minutes = parseInt(date, offset, offset += 2);\n\n                // Optional :ss[.sss]\n                // Check if the next character exists and is a colon before proceeding.\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1; // Consume ':'\n                    // Check if there's room for 'ss'\n                    // Need to ensure we don't parse timezone Z or +/- as seconds\n                    if (date.length() >= offset + 2 && Character.isDigit(date.charAt(offset))) {\n                        seconds = parseInt(date, offset, offset += 2);\n                        if (seconds > 59 && seconds < 63) seconds = 59; // Handle leap seconds by truncating\n\n                        // Optional .sss\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1; // Consume '.'\n                            int startMillisOffset = offset;\n                            int endMillisOffset = indexOfNonDigit(date, offset);\n                            if (endMillisOffset == startMillisOffset) { // No digits found\n                                throw new NumberFormatException(\"Missing fractional second digits after '.'\");\n                            }\n\n                            // Limit parsing to 3 digits for milliseconds\n                            int parseEndOffset = Math.min(endMillisOffset, startMillisOffset + 3);\n\n                            int fraction = parseInt(date, startMillisOffset, parseEndOffset);\n\n                            // Scale to milliseconds based on the number of digits parsed\n                            switch (parseEndOffset - startMillisOffset) {\n                                case 1: milliseconds = fraction * 100; break;\n                                case 2: milliseconds = fraction * 10; break;\n                                default: milliseconds = fraction; // 3 digits were parsed\n                            }\n                            offset = endMillisOffset; // Update offset to after all fractional digits\n                        }\n                    }\n                    // If not digits after ':', it could be timezone indicator Z, +, - (handled below)\n                }\n            } // End of time parsing if(hasT)\n\n            // extract timezone Z, +hh:mm, +hhmm, +hh\n            if (date.length() <= offset) {\n                // If 'T' was present, timezone is required.\n                // Original code threw: throw new IllegalArgumentException(\"No time zone indicator\");\n                 throw new IllegalArgumentException(\"Missing time zone indicator\");\n             }\n\n            TimeZone timezone;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffsetStr = date.substring(offset); // Grab the potential offset string\n\n                String parsedOffsetStr; // The actual +/-hh:mm or +/-hhmm or +/-hh part\n                int offsetLen; // Length of the parsed offset string\n\n                // Determine format and length, with digit checks\n                if (timezoneOffsetStr.length() >= 6 && timezoneOffsetStr.charAt(3) == ':' &&\n                    Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2)) &&\n                    Character.isDigit(timezoneOffsetStr.charAt(4)) && Character.isDigit(timezoneOffsetStr.charAt(5))) { // Format \u00b1hh:mm\n                    parsedOffsetStr = timezoneOffsetStr.substring(0, 6);\n                    offsetLen = 6;\n                } else if (timezoneOffsetStr.length() >= 5 &&\n                           Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2)) &&\n                           Character.isDigit(timezoneOffsetStr.charAt(3)) && Character.isDigit(timezoneOffsetStr.charAt(4))) { // Format \u00b1hhmm\n                    parsedOffsetStr = timezoneOffsetStr.substring(0, 5);\n                    offsetLen = 5;\n                } else if (timezoneOffsetStr.length() >= 3 &&\n                           Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2))) { // Format \u00b1hh\n                    parsedOffsetStr = timezoneOffsetStr.substring(0, 3);\n                    offsetLen = 3;\n                } else {\n                    throw new IllegalArgumentException(\"Invalid time zone offset format: \" + timezoneOffsetStr);\n                }\n\n                // Check for zero offset variations\n                boolean isZero = \"+0000\".equals(parsedOffsetStr) || \"+00:00\".equals(parsedOffsetStr) || \"+00\".equals(parsedOffsetStr) ||\n                                 \"-0000\".equals(parsedOffsetStr) || \"-00:00\".equals(parsedOffsetStr) || \"-00\".equals(parsedOffsetStr);\n\n                if (isZero) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // Use \"GMT\" prefix for custom time zones with offsets\n                    String timezoneId = \"GMT\" + parsedOffsetStr;\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    // Verify TimeZone.getTimeZone didn't silently fail by returning GMT for a non-zero offset input\n                    // TimeZone.getTimeZone returns \"GMT\" (with 0 offset) for unrecognized IDs like \"GMT+99:00\"\n                    // Check if the ID is exactly \"GMT\" and the raw offset is zero. This indicates failure for non-zero inputs.\n                    if (timezone.getID().equals(\"GMT\") && timezone.getRawOffset() == 0) {\n                         throw new IllegalArgumentException(\"Invalid or unrecognized time zone offset: \" + parsedOffsetStr);\n                    }\n                    // Note: TimeZone.getTimeZone(\"GMT+01\") returns a TimeZone with ID \"GMT+01:00\".\n                    // The check above works because invalid offsets like \"GMT+99\" result in ID \"GMT\" and offset 0.\n                    // Valid offsets like \"GMT+01\" result in a non-\"GMT\" ID (e.g., \"GMT+01:00\") or the correct non-zero raw offset.\n                }\n                offset += offsetLen; // Consume the parsed timezone offset part\n            } else {\n                 // Original code used IndexOutOfBoundsException for invalid char\n                 throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1); // Calendar month is 0-based\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset); // Update position to where parsing stopped\n            return calendar.getTime();\n\n        } catch (IndexOutOfBoundsException e) {\n            fail = e;\n        } catch (NumberFormatException e) {\n            fail = e;\n        } catch (IllegalArgumentException e) {\n            fail = e;\n        } catch (StringIndexOutOfBoundsException e) { // Catch specific bounds exception from parsing checks\n             fail = e;\n        }\n        // Convert any caught exception to ParseException\n        String input = (date == null) ? null : ('\"' + date + '\"');\n        // Ensure fail is not null before getting message\n        String msg = (fail != null) ? fail.getMessage() : \"Unknown error during parsing\";\n        if (msg == null || msg.isEmpty()) {\n            // Provide fallback message including exception class if message is null/empty\n            msg = \"(\" + (fail != null ? fail.getClass().getName() : \"Unknown Exception\") + \")\";\n        }\n        // Set error index to where parsing failed (current value of pos.getIndex())\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        if (fail != null) {\n             ex.initCause(fail);\n        }\n        throw ex;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}