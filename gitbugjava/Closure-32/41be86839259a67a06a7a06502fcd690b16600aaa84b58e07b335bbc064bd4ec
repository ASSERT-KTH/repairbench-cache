{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // If the block starts directly with EOC or EOF, it's empty.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n\n    // Track if we need to ignore a leading star on the next line.\n    // This is true initially if the passed-in token is EOL.\n    boolean ignoreStar = token == JsDocToken.EOL;\n\n    // Skip any initial EOL tokens.\n    while (token == JsDocToken.EOL) {\n        ignoreStar = true; // Mark that we encountered EOL.\n        token = next();\n        // Check again for immediate EOC/EOF after the EOL.\n        if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n          // Block contained only EOLs.\n          return new ExtractionInfo(\"\", token);\n        }\n    }\n\n    // Now 'token' is the first non-EOL token. Record its start position.\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    StringBuilder builder = new StringBuilder();\n    boolean requiresSeparator = false; // Track if a space is needed before the next token.\n    String line; // To hold content from getRemainingJSDocLine.\n\n    do {\n        switch (token) {\n            case STAR:\n                if (ignoreStar) {\n                    // This star is the optional leading '*' on a comment line. Ignore it.\n                    ignoreStar = false; // Handled the potential star for this line.\n                    requiresSeparator = false; // Star itself doesn't require separation.\n                    token = next(); // Consume the star, move to the next token.\n\n                    if (option == WhitespaceOption.PRESERVE) {\n                        // If preserving whitespace, capture the rest of the line verbatim,\n                        // including leading whitespace after the star.\n                        stream.update(); // Ensure stream is positioned at start of content.\n                        line = stream.getRemainingJSDocLine();\n                        builder.append(line);\n                        // Need separator if non-whitespace was appended.\n                        requiresSeparator = line.trim().length() > 0;\n                        // Consume the EOL/next token after this line.\n                        token = next();\n                    }\n                    // If not PRESERVE, the tokenizer handles whitespace, so just continue.\n                    continue; // Process the token found after the star/line.\n\n                } else {\n                    // This star is part of the actual text content.\n                    if (requiresSeparator) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                    requiresSeparator = true; // Star acts as content needing separation.\n                    token = next();\n                    continue;\n                }\n\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    // Append newline. Trim trailing space first unless preserving whitespace.\n                    if (option != WhitespaceOption.PRESERVE) {\n                      // Trim trailing whitespace from builder before adding newline.\n                      while (builder.length() > 0 &&\n                             Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                          builder.setLength(builder.length() - 1);\n                      }\n                    }\n                    builder.append('\\n');\n                }\n                ignoreStar = true; // Expect a potential leading star on the next line.\n                requiresSeparator = false; // Reset separator flag for the new line.\n                token = next();\n                continue;\n\n            // Handle termination conditions.\n            case ANNOTATION:\n                // Annotations terminate the block unless PRESERVE is set.\n                if (option != WhitespaceOption.PRESERVE) {\n                   // Fallthrough to shared termination code below.\n                } else {\n                   // If preserving, treat ANNOTATION as a normal content token.\n                   break; // Break out of switch to handle in default case.\n                }\n                // FALLTHROUGH for non-PRESERVE ANNOTATION\n            case EOC:\n            case EOF:\n                // Terminate extraction process.\n                String multilineText = builder.toString();\n\n                // Trim the final extracted text only if not preserving whitespace.\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                // Note: Depending on exact JSDoc specs, even PRESERVE might need\n                // some final cleanup, but typically it implies literal content.\n\n                // Calculate end position (using the start of the terminating token).\n                stream.update(); // Position stream at start of the current (terminating) token.\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n\n                // Record the extracted text and its source location if non-empty.\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                                          endLineno, endCharno);\n                }\n                // Return the result and the token that caused termination.\n                return new ExtractionInfo(multilineText, token);\n\n            default: // Handle all other regular tokens (and ANNOTATION if PRESERVE).\n                ignoreStar = false; // Any non-EOL token means subsequent STARs are content.\n\n                // Add a space separator if the previous token requires one.\n                if (requiresSeparator) {\n                    builder.append(' ');\n                }\n\n                // Append the string representation of the current token.\n                String tokenStr = toString(token);\n                builder.append(tokenStr);\n\n                // Append the rest of the content on the current line.\n                line = stream.getRemainingJSDocLine();\n\n                // Trim the end of this line unless preserving whitespace.\n                if (option != WhitespaceOption.PRESERVE) {\n                    // Assumes a utility function trimEnd(String) exists and works like String.trim() but only for the end.\n                    // If trimEnd is not available, use a regex or loop. Example:\n                    // line = line.replaceAll(\"\\\\s+$\", \"\");\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n\n                // Determine if a space separator is needed before the *next* token.\n                // Needed if the current token string or the rest of the line added non-whitespace characters.\n                requiresSeparator = (tokenStr.trim().length() > 0 || line.trim().length() > 0);\n\n                // Advance to the next token.\n                token = next();\n        }\n    } while (true); // Continue loop until an explicit return.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}