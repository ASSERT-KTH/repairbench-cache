{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token (first token *after* the annotation name).\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // Handle cases where there's nothing after the annotation name.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    // If the first token is EOL, skip it and start processing from the next line.\n    // The text content effectively starts on the next line.\n    if (token == JsDocToken.EOL) {\n       token = next();\n       // If we reached the end immediately after the EOL, return empty.\n       if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n           return new ExtractionInfo(\"\", token);\n       }\n       // Otherwise, the new 'token' points to the start of the first content line.\n    }\n\n    // Mark the start position of the text block's content.\n    // This should be the position *before* the first actual content character.\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    StringBuilder builder = new StringBuilder();\n    boolean firstContentLine = true;\n\n    // Loop until we hit the end of the comment (EOC), end of file (EOF),\n    // or a new annotation (if not preserving whitespace).\n    // The loop condition primarily checks for EOC/EOF. The annotation check is inside.\n    while (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n         // Check for terminating annotation if not preserving whitespace\n         if (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE) {\n             // Stop reading text block, the annotation marks the start of something new.\n             break;\n         }\n\n         // Read the content of the current line using getRemainingJSDocLine.\n         // This method is assumed to handle the optional leading \" * \" correctly\n         // based on JSDoc conventions (skipping it) and return the raw content\n         // from that point until the end of the line (EOL or EOC).\n         stream.update(); // Ensure stream position is correct before reading line.\n         String line = stream.getRemainingJSDocLine();\n\n         // Process the extracted line based on the whitespace option.\n         if (!firstContentLine) {\n             // Add the newline separator from the previous line before adding the new line's content.\n             builder.append('\\n');\n         }\n\n         if (option == WhitespaceOption.PRESERVE) {\n             // Preserve mode: Keep the line content exactly as read (including leading/trailing spaces).\n             builder.append(line);\n         } else {\n             // Non-preserve modes (TRIM or COLLAPSE):\n             // Trim trailing whitespace from the line. Leading whitespace (after potential '*') is kept.\n             line = trimEnd(line);\n             builder.append(line);\n         }\n\n         firstContentLine = false; // We have processed at least one line of content.\n\n         // Advance the token state past the line we just consumed.\n         // getRemainingJSDocLine reads until EOL or EOC. Calling next() consumes that terminator\n         // and positions the stream for the start of the next line or termination.\n         token = next();\n\n         // If the token immediately after the line content was EOL (the common case),\n         // we need to consume that EOL and get the token for the start of the *next* line\n         // (which could be STAR, content, another EOL, EOC, etc.).\n         // If the token was already EOC/EOF, the loop condition will handle termination.\n         if (token == JsDocToken.EOL) {\n             token = next();\n         }\n         // Now 'token' is set for the check at the start of the next loop iteration.\n    }\n\n    // --- Finalization ---\n    String multilineText = builder.toString();\n\n    // No final trimming of the entire block is done, preserving intended structure like\n    // leading spaces on the first line and blank lines represented by newlines.\n\n    // Mark the text range using the recorded start position and the stream's\n    // position *before* the terminating token (EOC/EOF/ANNOTATION).\n    stream.update(); // Update stream position to be just before the terminating token.\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n\n    // Return the extracted text and the token that terminated the extraction.\n    return new ExtractionInfo(multilineText, token);\n  }\n\n  // Helper function to trim trailing whitespace (assuming Character class is available).\n  private String trimEnd(String s) {\n      int len = s.length();\n      while (len > 0 && Character.isWhitespace(s.charAt(len - 1))) {\n          len--;\n      }\n      return s.substring(0, len);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}