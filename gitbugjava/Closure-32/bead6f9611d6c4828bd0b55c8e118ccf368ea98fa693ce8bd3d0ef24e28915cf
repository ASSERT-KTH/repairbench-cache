{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // If the description starts with EOC or EOF, return empty string.\n    // Allow EOL to start a potentially multiline description (handled below).\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    // stream, jsdocBuilder, next(), toString(), trimEnd() are assumed to be members/methods of the enclosing class.\n    stream.update(); // Update stream position to the start of the passed token\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    StringBuilder builder = new StringBuilder();\n    String line;\n\n    if (option == WhitespaceOption.PRESERVE) {\n        // --- PRESERVE Logic ---\n        // Correctly handles leading/trailing whitespace, newlines, and optional stars\n        // to preserve formatting for @license/@preserve.\n\n        boolean firstElement = true; // Track if we are processing the very first token/line\n\n        // Handle the first token/line content only if it's not EOL.\n        if (token != JsDocToken.EOL) {\n            line = stream.getRemainingJSDocLine();\n            builder.append(line);\n            token = next(); // Consume rest of line content\n            firstElement = false;\n        }\n        // else: first token is EOL, loop below will handle it without adding initial content.\n\n        // Loop through subsequent lines/tokens\n        while (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n            if (token == JsDocToken.EOL) {\n                // Append newline, unless we are skipping the very first EOL (handled by firstElement flag).\n                if (!firstElement) {\n                   builder.append('\\n');\n                }\n                token = next(); // Consume EOL\n                firstElement = false; // No longer the first element\n\n                // Check for optional star at the beginning of the new line\n                if (token == JsDocToken.STAR) {\n                    token = next(); // Consume STAR\n                    // Append the rest of the line (including leading space after star)\n                    line = stream.getRemainingJSDocLine();\n                    builder.append(line);\n                    token = next(); // Consume the line content + EOL\n                } else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n                    // No star, but not EOC/EOF. Append the whole line.\n                    line = stream.getRemainingJSDocLine();\n                    builder.append(line);\n                    token = next(); // Consume rest of line + EOL\n                }\n                // If token became EOC/EOF after consuming line, outer loop condition catches it.\n                // If token became EOL (empty line after star or no star), loop continues.\n            } else {\n                // Unexpected token for PRESERVE mode (e.g., mid-line content after EOL processing).\n                // This implies an issue with tokenization or stream state.\n                // Assume correct tokenization leads to EOC/EOF here or ANNOTATION if allowed.\n                // Since PRESERVE allows annotations, just break and let the caller handle it.\n                 break; // Exit loop, return current builder content and this token.\n            }\n        }\n\n        // Record the text end position. stream is positioned at the terminating token (EOC/EOF/ANNOTATION).\n        stream.update();\n        int endLineno = stream.getLineno();\n        int endCharno = stream.getCharno();\n        String preserveText = builder.toString(); // Don't trim\n\n        if (preserveText.length() > 0) {\n            // Mark text using recorded start/end positions.\n             jsdocBuilder.markText(preserveText, startLineno, startCharno, endLineno, endCharno);\n        }\n        return new ExtractionInfo(preserveText, token);\n\n    } else {\n        // --- NON-PRESERVE Logic ---\n        // Collapses whitespace, trims lines, handles optional stars.\n\n        boolean firstToken = true;\n        boolean ignoreStar = false; // Track if last token processed was EOL\n\n        do {\n            switch (token) {\n                case STAR:\n                    if (!ignoreStar) { // Star is content if not preceded by EOL\n                        // Append space only if needed.\n                        if (!firstToken && builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                           builder.append(' ');\n                        }\n                        builder.append('*');\n                        firstToken = false;\n                    }\n                    // Star after EOL is ignored (whitespace).\n                    ignoreStar = false; // Reset ignoreStar after handling STAR\n                    token = next();\n                    continue;\n\n                case EOL:\n                    if (option == WhitespaceOption.SINGLE_LINE) {\n                         // Terminate on the first EOL for SINGLE_LINE mode.\n                         String singleLineText = builder.toString().trim();\n                         stream.update();\n                         int endLineno = stream.getLineno();\n                         int endCharno = stream.getCharno();\n                         if (singleLineText.length() > 0) {\n                             jsdocBuilder.markText(singleLineText, startLineno, startCharno, endLineno, endCharno);\n                         }\n                         return new ExtractionInfo(singleLineText, token);\n                    }\n\n                    // For multi-line non-preserve, EOL potentially signifies a space break.\n                    ignoreStar = true; // The next STAR should be ignored.\n                    // Space is added before the *next* content token, not here.\n                    firstToken = false; // No longer the first token\n                    token = next();\n                    continue;\n\n                 case ANNOTATION: // Terminates non-preserve blocks\n                 case EOC:\n                 case EOF:\n                     String extractedText = builder.toString().trim();\n                     stream.update();\n                     int endLineno = stream.getLineno();\n                     int endCharno = stream.getCharno();\n                     if (extractedText.length() > 0) {\n                        jsdocBuilder.markText(extractedText, startLineno, startCharno,\n                            endLineno, endCharno);\n                     }\n                     return new ExtractionInfo(extractedText, token);\n\n                 default: // Regular content tokens (STRING, NAME, etc.)\n                    // Append a space separator unless it's the first token,\n                    // or if the builder already ends in a space. The ignoreStar flag signals\n                    // that a space is needed due to a preceding EOL (+ optional STAR).\n                    if (!firstToken) {\n                        if (ignoreStar || (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ')) {\n                            builder.append(' ');\n                        }\n                    }\n\n                    // Append the token's string value.\n                    builder.append(toString(token));\n\n                    // Append the rest of the line, trimming only the end.\n                    line = stream.getRemainingJSDocLine();\n                    // Use trimEnd from Apache Commons Lang or implement locally if not available\n                    line = trimEnd(line); // Preserve leading space relative to token\n                    if (line.length() > 0) {\n                        // Add space only if builder doesn't already end with one.\n                         if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                             builder.append(' ');\n                         }\n                        builder.append(line);\n                    }\n\n                    firstToken = false;\n                    ignoreStar = false; // Reset ignoreStar\n                    token = next(); // Consume token + rest of line\n            }\n        } while (true);\n    }\n  }\n\n  // Helper needed by the fixed code if not already present\n  private String trimEnd(String str) {\n    int end = str.length();\n    while (end > 0 && Character.isWhitespace(str.charAt(end - 1))) {\n      end--;\n    }\n    return str.substring(0, end);\n  }\n\n  // Helper class definition used by the function (assumed existing)\n  private static class ExtractionInfo {\n     final String string;\n     final JsDocToken token;\n     ExtractionInfo(String string, JsDocToken token) {\n       this.string = string;\n       this.token = token;\n     }\n  }\n\n  // Dummy State enum to satisfy the original code structure, though not actively used in the fix logic.\n  private enum State { SEARCHING_ANNOTATION }\n  private State state;\n\n  // Assume these members/methods exist in the enclosing class:\n  // private JsDocTokenStream stream;\n  // private JsDocBuilder jsdocBuilder;\n  // private JsDocToken next() { ... }\n  // private String toString(JsDocToken token) { ... }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}