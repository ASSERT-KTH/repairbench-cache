{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // FIX: Do not bail out if the first token is EOL.\n    // The common case is \"@tag \\n description\". Let the loop handle the EOL.\n    // Original check:\n    // if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n    //     token == JsDocToken.EOF) {\n    //   return new ExtractionInfo(\"\", token);\n    // }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    // Charno after the first token was read. Might be inaccurate for marking.\n    int startCharno = stream.getCharno() + 1;\n\n    StringBuilder builder = new StringBuilder();\n    boolean ignoreStar = false; // Should we ignore a star at the start of the *next* line?\n\n    // Handle initial EOL correctly. If the first token is EOL, consume it,\n    // mark that the next line might have a star, and proceed to the next token.\n    // Don't add a newline for this initial EOL.\n    if (token == JsDocToken.EOL) {\n      ignoreStar = true;\n      token = next();\n    }\n\n    do {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Skip the star, get next token. ignoreStar remains true: the token after\n            // the star is still effectively at the start of the line's content.\n            token = next();\n            continue;\n          } else {\n            // The star is part of the comment. Fall through to default handling.\n            // Fallthrough intended.\n          }\n\n        case EOL:\n          // An EOL ends the current line segment or represents a blank line.\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            // Append \\n, unless builder already ends with \\n? No, PRESERVE needs exact \\n count.\n            // Check builder state to avoid double EOL when first token is EOL.\n            if (builder.length() > 0) {\n                builder.append(\"\\n\");\n            }\n          }\n          ignoreStar = true; // The next line might start with an ignorable star.\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n        case ANNOTATION:\n           // Check for termination conditions.\n           if (token == JsDocToken.EOC || token == JsDocToken.EOF ||\n               (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n\n            String multilineText = builder.toString();\n            // Only trim if not preserving whitespace. Also, trim leading/trailing\n            // whitespace added by the loop, respecting internal newlines.\n            if (option != WhitespaceOption.PRESERVE) {\n                multilineText = multilineText.trim();\n            }\n\n            // Mark the text's location in the source file.\n            // Use the stream's current position as the end point.\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            // Only mark non-empty text blocks.\n            if (multilineText.length() > 0) {\n              // Note: startCharno might be slightly off due to initial token read.\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            // Return the extracted text and the token that ended the extraction.\n            return new ExtractionInfo(multilineText, token);\n          }\n          // If it's an ANNOTATION token but we're in PRESERVE mode, treat it as text.\n          // Fallthrough intended.\n\n        default: // Includes ANNOTATION in PRESERVE mode, and non-ignored STAR\n          // If we are at the start of a new line (ignoreStar is true)\n          // AND preserving whitespace, we need to capture the leading whitespace\n          // that the tokenizer skipped. This is hard with current tools.\n          // Workaround: Assume JsDocTokenStream correctly positions at the start\n          // of the actual token, and getRemainingJSDocLine captures from there.\n          // This will lose leading whitespace on new lines in PRESERVE mode.\n\n          // Append the current token's string representation.\n          String tokenStr = toString(token);\n\n          // Append spacing logic based on mode.\n          if (option == WhitespaceOption.PRESERVE) {\n             // If ignoreStar was true, we are at the start of the line content.\n             // Prepending whitespace here is tricky. Let's append token + rest of line.\n             // We might lose leading space but preserve the rest.\n          } else {\n            // Add a space separator if needed in non-PRESERVE modes.\n            if (builder.length() > 0 && !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                builder.append(' ');\n            }\n          }\n\n          builder.append(tokenStr);\n\n          // Append the rest of the current line.\n          String line = stream.getRemainingJSDocLine(); // Consumes the line and EOL.\n\n          if (option == WhitespaceOption.PRESERVE) {\n            // Preserve remaining whitespace exactly.\n            builder.append(line);\n          } else {\n            // Trim trailing whitespace if not preserving.\n            builder.append(trimEnd(line));\n          }\n\n          // We processed a content token/line. Reset ignoreStar.\n          ignoreStar = false;\n\n          // Advance to the next token (already past the EOL consumed by getRemainingJSDocLine).\n          token = next();\n          continue; // Continue the loop with the new token.\n      }\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}