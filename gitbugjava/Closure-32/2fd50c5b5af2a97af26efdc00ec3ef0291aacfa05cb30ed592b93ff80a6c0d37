{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  // Note: @SuppressWarnings(\"fallthrough\") is kept, as ANNOTATION might fall through\n  // in PRESERVE mode, although the default case handles it explicitly.\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    // Use 0-based charno for start. markText likely handles 0-based vs 1-based internally.\n    int startCharno = stream.getCharno();\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      // Trim entire line for non-preserve mode on first line.\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    // We consumed the first line's content, now get the next token (usually EOL).\n    token = next();\n\n    boolean ignoreStar = false; // True if the previous token was EOL\n\n    do {\n      // Loop invariant: 'token' is the token at the start of the current line segment.\n      // stream is positioned at the start of 'token'.\n\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Line starts with '*', ignore it and capture the rest of the line.\n            token = next(); // Consume STAR, stream is after '*'\n\n            String restOfLine = stream.getRemainingJSDocLine();\n            if (option == WhitespaceOption.PRESERVE) {\n               // Preserve whitespace as is.\n               builder.append(restOfLine);\n            } else {\n               // Non-preserve mode: trim the line start similar to reading token+rest.\n               builder.append(restOfLine.trim());\n            }\n            token = next(); // Consume rest of line (EOL/EOC/EOF)\n            // We handled the line content, so the next token doesn't follow a STAR implicitly.\n            ignoreStar = false;\n          } else {\n            // Star is part of the comment text (not a leading star).\n             if (option != WhitespaceOption.PRESERVE) {\n                 // Add space only if not start of line/builder in non-preserve mode.\n                 if (builder.length() > 0 && !builder.substring(builder.length() - 1).equals(\"\\n\")) {\n                    builder.append(' ');\n                 }\n             }\n             // In PRESERVE mode, append '*' without extra leading space.\n             builder.append('*');\n             token = next(); // Consume STAR token.\n             ignoreStar = false; // Processed a content token.\n          }\n          continue; // Continue to next token.\n\n        case EOL:\n          if (option == WhitespaceOption.SINGLE_LINE) {\n             // Stop processing on first EOL if single line mode.\n             // Finalize and return EOL as the terminating token.\n             String singleLineText = builder.toString();\n             stream.update(); // Position at EOL token\n             int endLineno = stream.getLineno();\n             int endCharno = stream.getCharno();\n             // Apply final trim based on option before marking.\n             if (option != WhitespaceOption.PRESERVE) {\n               singleLineText = singleLineText.trim();\n             }\n             if (singleLineText.length() > 0) {\n                 jsdocBuilder.markText(singleLineText, startLineno, startCharno,\n                                      endLineno, endCharno);\n             }\n             // Return EOL token, as this is where we stopped.\n             return new ExtractionInfo(singleLineText, token);\n          }\n\n          // Multiline mode, append newline.\n          builder.append(\"\\n\");\n          ignoreStar = true; // Expect a star or beginning of text on the next line.\n          token = next(); // Consume EOL, move to next token.\n          continue; // Continue to next token.\n\n        case EOF: // Termination condition\n        case EOC: // Termination condition\n          // Terminate loop, handle finalization below.\n          break; // Exit switch\n\n        case ANNOTATION:\n          if (option != WhitespaceOption.PRESERVE) {\n            // Annotation terminates unless preserving whitespace.\n            break; // Exit switch, terminate loop.\n          }\n          // If preserving, ANNOTATION is treated as text, fallthrough to default.\n\n        default: // Includes ANNOTATION if option == PRESERVE\n          boolean startingNewLine = ignoreStar; // Were we expecting a star (i.e., last token was EOL)?\n          ignoreStar = false; // We are processing content, so reset flag.\n\n          this.state = State.SEARCHING_ANNOTATION; // Set parser state (assuming needed by caller context)\n\n          if (option == WhitespaceOption.PRESERVE) {\n              // Preserve mode: Append the raw text starting from the current token position.\n              if (startingNewLine) {\n                  // We had EOL, but the current token is not STAR.\n                  // Capture the entire line from the current stream position, preserving all leading whitespace.\n                  String restOfLine = stream.getRemainingJSDocLine();\n                  builder.append(restOfLine);\n                  token = next(); // Consume the line content (EOL/EOC/EOF).\n              } else {\n                  // Content is not at the start of a line (or it's the very first line part).\n                  // Append the token's string value and the rest of the line.\n                  // Assumes toString() gives a reasonable representation and getRemaining handles the rest.\n                  builder.append(toString(token));\n                  String restOfLine = stream.getRemainingJSDocLine();\n                  builder.append(restOfLine);\n                  token = next(); // Consume token + rest of line.\n              }\n          } else { // Not PRESERVE\n             // Original non-PRESERVE logic: Add space, append toString(), append trimEnd(rest).\n             if (builder.length() > 0 && !builder.substring(builder.length() - 1).equals(\"\\n\")) {\n                builder.append(' ');\n             }\n             builder.append(toString(token));\n             String restOfLine = stream.getRemainingJSDocLine();\n             // Only trim the end of the remaining part of the line.\n             restOfLine = trimEnd(restOfLine);\n             builder.append(restOfLine);\n             token = next(); // Consume token + rest of line.\n          }\n          continue; // Go to next token processing.\n      } // End switch\n\n      // If we reached here by break, it means loop termination condition met (EOC, EOF, or ANNOTATION).\n      break; // Exit do-while loop.\n\n    } while (true);\n\n    // Finalization (after loop termination by EOC, EOF, or ANNOTATION)\n    String multilineText = builder.toString();\n\n    // Apply final trim if not preserving whitespace.\n    if (option != WhitespaceOption.PRESERVE) {\n      multilineText = multilineText.trim();\n    }\n\n    // End position is the beginning of the terminating token.\n    stream.update(); // Ensure stream position is current.\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    if (multilineText.length() > 0) {\n      jsdocBuilder.markText(multilineText, startLineno, startCharno,\n          endLineno, endCharno);\n    }\n\n    // Return the extracted text and the token that terminated the extraction.\n    return new ExtractionInfo(multilineText, token);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}