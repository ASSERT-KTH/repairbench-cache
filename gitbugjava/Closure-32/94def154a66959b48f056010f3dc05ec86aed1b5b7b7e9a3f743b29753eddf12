{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      // No text found.\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1; // 1-based index of the first char.\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    // Handle trimming on the first line based on the option.\n    if (option == WhitespaceOption.TRIM || option == WhitespaceOption.SINGLE_LINE) {\n      line = line.trim();\n    } // PRESERVE: Keep leading/trailing whitespace.\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    // Consume the remainder of the first line and get the next token.\n    token = next();\n\n    // After the first line, we expect subsequent lines to start with a star,\n    // which should be ignored unless it's actual content.\n    boolean ignoreStar = true;\n\n    do {\n      // Check for terminating tokens.\n      if (token == JsDocToken.EOC || token == JsDocToken.EOF ||\n          (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n\n        String multilineText = builder.toString();\n\n        // Perform final trimming based on the option.\n        if (option == WhitespaceOption.TRIM || option == WhitespaceOption.SINGLE_LINE) {\n          multilineText = multilineText.trim();\n        } // PRESERVE: Keep all captured whitespace.\n\n        // The token location is typically the start of the token.\n        // Update the stream position before getting the end location.\n        stream.update();\n        int endLineno = stream.getLineno();\n        int endCharno = stream.getCharno();\n\n        if (multilineText.length() > 0) {\n          jsdocBuilder.markText(multilineText, startLineno, startCharno,\n              endLineno, endCharno);\n        }\n\n        return new ExtractionInfo(multilineText, token);\n      }\n\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Leading star on a new line. Consume it and get the rest of the line.\n            stream.update(); // Position stream after the STAR token.\n            String restOfLine = stream.getRemainingJSDocLine();\n\n            if (option == WhitespaceOption.PRESERVE) {\n              // Keep all whitespace as is.\n              builder.append(restOfLine);\n            } else { // TRIM or SINGLE_LINE\n              // Skip a single leading space after the star, if present.\n              if (restOfLine.startsWith(\" \")) {\n                restOfLine = restOfLine.substring(1);\n              }\n              // Append based on mode.\n              if (option == WhitespaceOption.SINGLE_LINE) {\n                String trimmedLine = restOfLine.trim();\n                if (!trimmedLine.isEmpty()) {\n                  // Add a space separator if needed. Assumes builder doesn't end in whitespace.\n                  if (builder.length() > 0 &&\n                      !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                    builder.append(' ');\n                  }\n                  builder.append(trimmedLine);\n                }\n              } else { // TRIM\n                // Append the line content (leading space removed), trim trailing space from this piece.\n                builder.append(trimEnd(restOfLine));\n              }\n            }\n            // We've processed the line after the star. Consume the line content.\n            token = next(); // Gets EOL/EOC/EOF normally.\n          } else {\n            // Star is part of the text content.\n            String tokenText = \"*\"; // The star itself.\n            String restOfLine = stream.getRemainingJSDocLine(); // Content after the star.\n\n            if (option == WhitespaceOption.PRESERVE) {\n              builder.append(tokenText);\n              builder.append(restOfLine);\n            } else { // TRIM or SINGLE_LINE\n              String combinedLine = tokenText + restOfLine;\n              if (option == WhitespaceOption.SINGLE_LINE) {\n                String trimmedLine = combinedLine.trim();\n                if (!trimmedLine.isEmpty()) {\n                  // Add space separator if needed.\n                  if (builder.length() > 0 &&\n                      !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                    builder.append(' ');\n                  }\n                  builder.append(trimmedLine);\n                }\n              } else { // TRIM\n                // Add space if previous char wasn't whitespace\n                 if (builder.length() > 0 &&\n                    !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                   builder.append(' ');\n                 }\n                 // Append combined line, trimmed at the end for this piece.\n                 builder.append(trimEnd(combinedLine));\n              }\n            }\n            // Consumed star and rest of line. Get next token.\n            token = next();\n          }\n          // Reset ignoreStar, as we are no longer at the start of a line requiring ignore.\n          ignoreStar = false;\n          continue; // Re-evaluate the new token.\n\n        case EOL:\n          // Add a newline character, unless we are collapsing lines.\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            // Avoid adding double newlines if builder already ends with one.\n             if (builder.length() == 0 || builder.charAt(builder.length() - 1) != '\\n') {\n               builder.append('\\n');\n             } else {\n               // If the builder ends with \\n, only append another if the original had consecutive EOLs.\n               // This requires looking ahead or tracking state, complex. Let's keep simple logic:\n               // only add \\n if the builder doesn't already end with it. This handles single blank lines.\n               // Double blank lines might be collapsed to one. Check if tests require preserving double blanks.\n               // The tests (e.g., testParseLicense) expect double blanks to be preserved.\n               // Let's always append \\n for EOL when not SINGLE_LINE. Final trim handles trailing ones if needed.\n               builder.append('\\n');\n             }\n          }\n          // Prepare for the next line, which might start with a star.\n          ignoreStar = true;\n          token = next(); // Consume EOL, get the next token.\n          continue; // Re-evaluate the new token.\n\n        default: // Handles ANNOTATION (in PRESERVE mode), STRING, identifiers, etc.\n          String tokenText = toString(token); // Get the string value of the token.\n          String restOfLine = stream.getRemainingJSDocLine(); // Get content after the token.\n\n          if (option == WhitespaceOption.PRESERVE) {\n            // Append token and rest of line exactly.\n            builder.append(tokenText);\n            builder.append(restOfLine);\n          } else { // TRIM or SINGLE_LINE\n            String combinedLine = tokenText + restOfLine;\n            if (option == WhitespaceOption.SINGLE_LINE) {\n              String trimmedLine = combinedLine.trim();\n              if (!trimmedLine.isEmpty()) {\n                // Add space separator if needed.\n                if (builder.length() > 0 &&\n                    !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                  builder.append(' ');\n                }\n                builder.append(trimmedLine);\n              }\n            } else { // TRIM\n              // Add space if needed before appending, if the last char wasn't whitespace.\n              if (builder.length() > 0 &&\n                  !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n                builder.append(' ');\n              }\n              // Append combined line, trimmed at the end for this piece.\n              builder.append(trimEnd(combinedLine));\n            }\n          }\n          // We've processed the token and the rest of the line. Get the next token.\n          token = next();\n          // Reset ignoreStar, as we are no longer at the start of a line requiring ignore.\n          ignoreStar = false;\n          continue; // Re-evaluate the new token.\n      }\n    } while (true);\n  }\n\n  /** Helper method to trim trailing whitespace. */\n  private String trimEnd(String s) {\n    int len = s.length();\n    while (len > 0 && Character.isWhitespace(s.charAt(len - 1))) {\n      len--;\n    }\n    return s.substring(0, len);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}