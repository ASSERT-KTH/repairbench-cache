{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    // Record the start position of the textual block.\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno(); // 0-based\n\n    StringBuilder builder = new StringBuilder();\n\n    // Consume the rest of the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option == WhitespaceOption.PRESERVE) {\n      builder.append(line);\n    } else {\n      // Trim trailing space, but not leading space for the first line.\n      // The final trim() happens later for non-preserve options.\n      builder.append(trimEnd(line));\n    }\n    token = next(); // Read the token that terminates the first line (EOL, EOC, EOF)\n\n    // Consume subsequent lines\n    while (token == JsDocToken.EOL) {\n      // Append the newline character.\n      if (option != WhitespaceOption.SINGLE_LINE) {\n        builder.append('\\n');\n      }\n      token = next(); // Read the first token on the new line (STAR, text, EOC, ...)\n\n      if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n          break;\n      }\n      // An annotation terminates the block unless we're preserving whitespace.\n      if (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE) {\n          break;\n      }\n\n      // Handle the beginning of the line based on the whitespace option.\n      if (option == WhitespaceOption.PRESERVE) {\n        // Consume the potential leading star.\n        if (token == JsDocToken.STAR) {\n           token = next();\n           // Consume the space after the star if it exists.\n           if (stream.peek() == ' ') {\n             stream.getChar();\n           }\n        }\n        // Append the rest of the line literally.\n        line = stream.getRemainingJSDocLine();\n        builder.append(line);\n        token = next(); // Consume the EOL at the end of this line.\n      } else { // Not PRESERVE (TRIM or SINGLE_LINE)\n        // Consume the potential leading star, but don't add it to the builder.\n        if (token == JsDocToken.STAR) {\n          token = next();\n        }\n\n        // Add a space between lines if needed (for TRIM mode).\n        if (option == WhitespaceOption.TRIM && builder.length() > 0) {\n            char lastChar = builder.charAt(builder.length() - 1);\n            if (lastChar != '\\n' && lastChar != ' ') {\n                builder.append(' ');\n            }\n        }\n\n        // Consume the rest of the line token by token, trimming trailing whitespace from each part.\n        while (token != JsDocToken.EOL && token != JsDocToken.EOC && token != JsDocToken.EOF) {\n            if (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE) {\n                break; // Stop at annotations when not preserving.\n            }\n\n            // Append token representation\n            builder.append(toString(token));\n            // Append rest of line, trimmed only at the end\n            line = trimEnd(stream.getRemainingJSDocLine());\n            if (!line.isEmpty()) {\n                 // Add space only if needed before appending the rest of the line\n                 if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                    char firstChar = line.charAt(0);\n                    if (firstChar != ' ' && firstChar != '\\t') {\n                        builder.append(' ');\n                    }\n                 }\n                 builder.append(line);\n            }\n            token = next(); // Read the token that terminates this line/segment (EOL, ANNOTATION, etc.).\n\n            // Add space before next token if needed and we're not at the end\n             if (token != JsDocToken.EOL && token != JsDocToken.EOC && token != JsDocToken.EOF &&\n                 !(token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n                 if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                    builder.append(' ');\n                 }\n             }\n        } // End inner while\n\n        // Exit inner loop: token is EOL, EOC, EOF, or ANNOTATION\n        if (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE) {\n            break; // Exit outer loop as well\n        }\n      } // End else (not PRESERVE)\n    } // End while (token == EOL)\n\n    // We have exited the loop. token is the terminating token (EOC, EOF, ANNOTATION).\n    String multilineText = builder.toString();\n\n    // Trim the final result only if not preserving whitespace.\n    if (option != WhitespaceOption.PRESERVE) {\n      multilineText = multilineText.trim();\n    }\n\n    // Determine the end position. stream.update() ensures the lineno/charno are current,\n    // reflecting the position *before* the terminating token was logically processed.\n    stream.update();\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    if (multilineText.length() > 0) {\n      // Mark the text using the start position and the current end position.\n      // Convert startCharno to 1-based for marking.\n      jsdocBuilder.markText(multilineText, startLineno, startCharno + 1,\n          endLineno, endCharno);\n    }\n\n    return new ExtractionInfo(multilineText, token);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}