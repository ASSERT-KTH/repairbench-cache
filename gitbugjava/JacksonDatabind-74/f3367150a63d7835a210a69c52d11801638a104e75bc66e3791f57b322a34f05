{
    "generation": "    // off-lined to keep main method lean and mean...\n    @SuppressWarnings(\"resource\")\n    protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n            TokenBuffer tb) throws IOException\n    {\n        // As per [JACKSON-614], may have default implementation to use\n        JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n        if (deser != null) {\n            // [databind#1533]: Handle empty String as null possibly\n            if (p.hasToken(JsonToken.VALUE_STRING)) {\n                final String text = p.getText();\n                if (text.isEmpty()) {\n                    if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                         // Important: check based on resolved type, not base type; base type is nominal\n                         // and generally abstract, so not useful\n                         // 26-Oct-2021, tatu: But wait! We have default type's deserializer...\n                         //   Let's use that information then?\n\n                         // 03-Nov-2021, tatu: Should not need to construct an actual type but\n                         //    rather check kind of type... Also: related to `CoercionConfigs`\n                         Class<?> rawDefaultType = deser.handledType();\n\n                         // 03-Nov-2021, tatu: Need to consider coercion effects similar to\n                         //    `StdDeserializer._deserializeFromEmptyString()` ... may seem\n                         //    counter-intuitive but rules for coercion from empty String need\n                         //    to be applied same way regardless of where Empty String occurs.\n                         //    Except let's not block Containers, Reference types. String is ambigous\n                         //    but handled by default deser so fine.\n                         //    Basically: only use `null` for POJO/Enum/Scalar-non-String\n                         if (!String.class.isAssignableFrom(rawDefaultType)\n                                 && !java.util.Collection.class.isAssignableFrom(rawDefaultType)\n                                 && !java.util.Map.class.isAssignableFrom(rawDefaultType)\n                                 && !com.fasterxml.jackson.databind.type.ReferenceType.class.isAssignableFrom(rawDefaultType)\n                                 ) {\n                             return null;\n                         }\n                    }\n                }\n            }\n            \n            if (tb != null) {\n                tb.writeEndObject();\n                p = tb.asParser(p);\n                // must move to point to the first token:\n                p.nextToken();\n            }\n            return deser.deserialize(p, ctxt);\n        }\n        \n        // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n        Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n        if (result != null) {\n            return result;\n        }\n        \n        // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n        if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n            return super.deserializeTypedFromAny(p, ctxt);\n        }\n        \n        // 10-Jun-2020, tatu: Should we check for `JsonToken.VALUE_EMBEDDED_OBJECT`?\n        //   Seems like we probably should.\n\n        ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n        return null; // never gets here\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}