{
    "generation": "    private boolean isInlineable(Document.OutputSettings out) {\n        // If outline mode is enabled in output settings, no element is considered inlineable for rendering purposes.\n        if (out.outline()) {\n            return false;\n        }\n\n        // According to the Javadoc: \"this element itself is a block\" -> is inlineable.\n        // This implies that if the element is a block tag, it's considered \"inlineable\" in the sense\n        // that it can be placed in the flow, even if it forces a line break.\n        if (!tag().isInline()) {\n            return true;\n        }\n\n        // At this point, `this` element is an inline tag.\n        // Now, apply the Javadoc's specific rules for inline elements:\n        // \"if it has a block parent, it is ok if there's no previous sibling (it's the first child),\n        // or if it has a previous sibling, that it is also inline\"\n        if (parent() != null && parent().isBlock()) {\n            Node prev = previousSibling();\n            // It's inlineable if:\n            // 1. It's the first child (no previous sibling).\n            // 2. Its previous sibling is a TextNode (which is always inline content).\n            // 3. Its previous sibling is an Element and that element's tag is inline.\n            return prev == null\n                || prev.isTextNode()\n                || (prev instanceof Element && ((Element) prev).tag().isInline());\n        }\n\n        // Javadoc: \"If it has an inline parent, this means it needs to be inline.\"\n        // We are already in the `!tag().isInline()` (false) branch, meaning `this` element *is* inline.\n        // If the parent is inline (or if there's no parent, i.e., it's a root or standalone node),\n        // and this element is inline, then it's considered inlineable.\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}