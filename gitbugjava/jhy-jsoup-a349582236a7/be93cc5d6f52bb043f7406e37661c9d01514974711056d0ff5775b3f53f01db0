{
    "generation": "    private boolean isInlineable(Document.OutputSettings out) {\n        // inline tags that are the first significant children of a block are not inlineable\n        // block tags that contain only inline children are not inlineable\n\n        if (!tag().isInline() || out.outline()) // Quick exits for non-inline tags or outline mode\n            return false;\n\n        Element parent = parent();\n        if (parent == null || !parent.tag().isBlock()) // Parent must be block\n            return false;\n\n        Node ps = previousSibling();\n        if (ps == null) // Must have a previous sibling\n            return false;\n\n        // Skip backwards over blank text nodes to find the effective previous node\n        while (ps instanceof TextNode && ((TextNode) ps).isBlank()) {\n            Node prior = ps.previousSibling();\n            if (prior == null) { // Reached start past whitespace; this element is the first significant child\n                return false;\n            }\n            ps = prior; // continue back\n        }\n\n        // Now check the type of the effective previous sibling `ps`\n        if (ps instanceof Element && ((Element) ps).tag().isBlock()) {\n            // Previous effective node is a block element, so this inline element must start on a new line\n            return false;\n        }\n        // note that Comments, DataNodes, etc are not block\n\n\n        // Otherwise (prev sibling is inline element, non-blank text, comment etc.), it's inlineable\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}