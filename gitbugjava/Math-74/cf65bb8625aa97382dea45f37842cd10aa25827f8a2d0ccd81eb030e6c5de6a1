{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    // Check if the Butcher arrays 'c' are defined. If not, this is likely not a Runge-Kutta method.\n    final boolean isRungeKutta = (this.c != null);\n    // Determine the number of stages based on the 'c' array for RK methods, default to 1 otherwise.\n    final int stages = isRungeKutta ? this.c.length + 1 : 1;\n    // Ensure yDotK has at least 2 stages allocated, as initializeStep might use yDotK[1].\n    final int allocStages = Math.max(2, stages);\n\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    // Allocate internal arrays based on the determined number of stages.\n    final double[][] yDotK = new double[allocStages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    // Note: This logic assumes the 'prototype' interpolator is suitable for the specific\n    // integrator type (RK or otherwise). Non-RK methods requiring dense output might need\n    // specific handling not fully captured by this base class method.\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final AbstractStepInterpolator proto = prototype.copy(); // Copy the prototype interpolator\n      proto.reinitialize(this, yTmp, yDotK, forward); // Reinitialize with current state and arrays\n      interpolator = proto;\n    } else {\n      // Use a dummy interpolator if dense output is not required.\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0); // Store the initial time\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true; // Flag for the first step initialization\n    for (StepHandler handler : stepHandlers) {\n        handler.reset(); // Reset step handlers\n    }\n    // Setup event handling, including checking for reaching the final time t\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false; // Flag indicating if the last step is being taken\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift(); // Prepare interpolator for the next step\n\n      double error = 0;\n      // Inner loop for step acceptance and step size control\n      for (boolean loop = true; loop;) {\n\n        // Compute the derivative at the current state (yDotK[0])\n        // This is always done for the first step or if FSAL optimization is not active.\n        // Multistep methods typically have fsal=false, so this runs every step attempt.\n        if (firstTime || !fsal) {\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          // Perform initialization for the first step\n          final double[] scale; // Determine scaling factors for error control\n          if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n            } else {\n              scale = vecAbsoluteTolerance;\n            }\n          // Call initializeStep, which might be overridden by subclasses (e.g., to run a starter integrator).\n          // yDotK has at least 2 stages, so passing yDotK[1] is safe.\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false; // Mark first step initialization as complete\n        }\n\n        stepSize = hNew; // Set the step size for the current attempt\n\n        // --- Runge-Kutta specific stage computations ---\n        // This block should only execute for RK methods that have defined Butcher arrays.\n        if (isRungeKutta) {\n          // Compute intermediate stages (k=1 to stages-1) required by the RK method\n          for (int k = 1; k < stages; ++k) {\n            for (int j = 0; j < y0.length; ++j) {\n              // Calculate the weighted sum of previous derivatives using 'a' coefficients\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                sum += a[k-1][l] * yDotK[l][j];\n              }\n              // Estimate the state at the intermediate stage\n              yTmp[j] = y[j] + stepSize * sum;\n            }\n            // Compute the derivative at the intermediate stage time and state\n            computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]); // Increments evaluation count\n          }\n\n          // Estimate the final state at the end of the step using 'b' coefficients\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = b[0] * yDotK[0][j];\n            for (int l = 1; l < stages; ++l) {\n              sum += b[l] * yDotK[l][j];\n            }\n            // Store the final estimated state in yTmp\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n        } else {\n            // For non-RK methods (e.g., Multistep), the step computation (predictor-corrector)\n            // is handled by subclass-specific logic, often integrated with error estimation.\n            // We copy the current state 'y' to 'yTmp' as a placeholder. The actual step\n            // calculation should update 'yTmp' before or during the estimateError call.\n             System.arraycopy(y, 0, yTmp, 0, y.length);\n        }\n        // --- End of Runge-Kutta specific logic ---\n\n        // Estimate the local error of the step. This method is abstract and must be\n        // implemented by concrete subclasses (RK, Adams, etc.) to provide their\n        // specific error estimation logic. For non-RK methods, this might also implicitly\n        // finalize the step computation into yTmp.\n        error = estimateError(yDotK, y, yTmp, stepSize);\n\n        // Check if the estimated error is within the tolerance\n        if (error <= 1.0) { // Step accepted (tentatively)\n\n          // Check for discrete events occurring during this step interval\n          interpolator.storeTime(stepStart + stepSize); // Store tentative end time for event check\n          if (manager.evaluateStep(interpolator)) {\n              // An event was detected within the step interval\n              final double dt = manager.getEventTime() - stepStart; // Time from step start to event\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // Event is extremely close to the step start; accept the current step\n                  // to prevent overly small steps.\n                  loop = false; // Exit acceptance loop\n              } else {\n                  // Event occurred within the step. Reject the current step size\n                  // and adjust it to hit the event time exactly.\n                  hNew = dt; // Set step size for the next attempt to hit the event\n                  // Stay in the acceptance loop (loop = true) to re-run with the adjusted step size.\n              }\n          } else {\n            // No event detected, the step is fully accepted.\n            loop = false; // Exit acceptance loop\n          }\n\n        } else { // error > 1.0: Step rejected due to large error\n          // Compute a scaling factor to reduce the step size.\n          final double factor =\n              Math.min(maxGrowth, // Limit step size growth\n                       Math.max(minReduction, safety * Math.pow(error, exp))); // Apply reduction factor based on error\n          // Calculate the new proposed step size, filtered to respect constraints.\n          hNew = filterStep(stepSize * factor, forward, false);\n          // Stay in the acceptance loop (loop = true) to retry the step with the smaller size.\n        }\n\n      } // End of acceptance loop (loop is false)\n\n      // --- Step Acceptance ---\n      // The step (potentially adjusted for events) has been accepted.\n      final double nextStep = stepStart + stepSize; // Time at the end of the accepted step\n      System.arraycopy(yTmp, 0, y, 0, y0.length);   // Update the main state vector 'y' with the result from 'yTmp'\n      manager.stepAccepted(nextStep, y);             // Notify event manager that the step was accepted\n      lastStep = manager.stop();                     // Check if the integration termination condition is met\n\n      // Provide the step data to registered step handlers\n      interpolator.storeTime(nextStep); // Ensure interpolator reflects the final time of the accepted step\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep); // Call handler\n      }\n      stepStart = nextStep; // Advance the current time to the end of the accepted step\n\n      // --- Post-step operations ---\n\n      // FSAL (First Same As Last) optimization for Runge-Kutta methods.\n      // If applicable, save the derivative computation from the last stage (yDotK[stages-1])\n      // to be used as the first stage derivative (yDotK[0]) in the next step.\n      if (isRungeKutta && fsal) {\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      // Handle potential state resets triggered by event handlers after the step.\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // If an event handler modified the state 'y', the derivatives are no longer valid.\n        // Recompute the derivative at the new state.\n        computeDerivatives(stepStart, y, yDotK[0]);\n        // Note: This implicitly invalidates the FSAL optimization if it was used.\n      }\n\n      // --- Step size control for the next step ---\n      if (! lastStep) {\n        // Ensure the current step size is non-zero (can happen with events at step start).\n        stepSize = filterStep(stepSize, forward, true);\n\n        // Compute a factor for the next step size based on the error of the accepted step.\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        // Calculate the proposed step size for the next step.\n        final double scaledH = stepSize * factor;\n        final double nextT = stepStart + scaledH; // Tentative time at the end of the next step\n        // Check if the proposed step would go past the final integration time 't'.\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        // Filter the proposed step size (apply limits, potentially adjust for the final step).\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    } // End of main integration loop (while !lastStep)\n\n    final double stopTime = stepStart; // Final time reached by the integration\n    resetInternalState(); // Clean up internal state variables\n    return stopTime; // Return the final time\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}