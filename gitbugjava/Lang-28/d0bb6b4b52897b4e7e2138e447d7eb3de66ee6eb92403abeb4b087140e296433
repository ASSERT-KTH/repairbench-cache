{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // Check bounds for initial '&#'.\n        if (input.charAt(index) == '&' && index + 1 < input.length() && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            // Check bounds for character after '#'.\n            if (start >= input.length()) {\n                return 0; // Not enough characters for a potential entity.\n            }\n\n            boolean isHex = false;\n            char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++;\n                // Check bounds after 'x'/'X'.\n                if (start >= input.length()) {\n                    return 0; // Not enough characters after 'x'/'X'.\n                }\n                isHex = true;\n            }\n\n            int end = start;\n            // Find the semicolon, checking bounds and validating digits.\n            while (end < input.length() && input.charAt(end) != ';') {\n                // Check if the character is a valid digit for the base\n                char currentChar = input.charAt(end);\n                if (isHex) {\n                    if (!((currentChar >= '0' && currentChar <= '9') || (currentChar >= 'a' && currentChar <= 'f') || (currentChar >= 'A' && currentChar <= 'F'))) {\n                        // Invalid hex digit found before semicolon\n                        return 0;\n                    }\n                } else {\n                    if (!(currentChar >= '0' && currentChar <= '9')) {\n                        // Invalid decimal digit found before semicolon\n                        return 0;\n                    }\n                }\n                end++;\n            }\n\n            // Check if semicolon was found within bounds.\n            if (end == input.length() || input.charAt(end) != ';') {\n                 return 0; // Malformed entity: missing semicolon or ended prematurely.\n            }\n\n            // Check if there were any digits between markers and semicolon.\n            if (start == end) {\n                return 0; // Malformed entity: no digits found.\n            }\n\n            int entityValue;\n            try {\n                CharSequence subSequence = input.subSequence(start, end);\n                if (isHex) {\n                    entityValue = Integer.parseInt(subSequence.toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(subSequence.toString(), 10);\n                }\n            } catch (NumberFormatException nfe) {\n                // Should not happen with the digit checks, but safeguard against overly large numbers.\n                return 0; // Malformed entity: invalid or out-of-range number.\n            }\n\n            try {\n                // Use Character.toChars to handle both BMP and supplementary code points correctly.\n                // This method also throws IllegalArgumentException for invalid code points.\n                char[] chars = Character.toChars(entityValue);\n                out.write(chars);\n            } catch (IllegalArgumentException e) {\n                // The parsed value is not a valid Unicode code point.\n                return 0; // Treat invalid code points as untranslatable.\n            }\n\n            // Calculate consumed length: length = (';' index) + 1 - (start index 'index')\n            return end + 1 - index;\n        }\n        // Input didn't start with '&#...' at the given index.\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}