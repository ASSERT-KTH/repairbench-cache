{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // Check if we have \"&#\"\n        if (input.charAt(index) == '&'\n                && index + 1 < input.length() && input.charAt(index + 1) == '#') {\n\n            int start = index + 2;\n            // Check if we have at least one character after \"&#\"\n            if (start == input.length()) {\n                return 0; // Input ends with \"&#\"\n            }\n\n            boolean isHex = false;\n            char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n                // Check if we have at least one character after \"&#x\" or \"&#X\"\n                if (start == input.length()) {\n                    return 0; // Input ends with \"&#x\" or \"&#X\"\n                }\n            }\n\n            int end = start;\n            // Find the semicolon, checking bounds\n            while (end < input.length() && input.charAt(end) != ';') {\n                end++;\n            }\n\n            // Check if semicolon was found before the end of the input\n            if (end == input.length() || input.charAt(end) != ';') {\n                return 0; // Malformed entity (missing semicolon or ended prematurely)\n            }\n\n            try {\n                CharSequence numericEntity = input.subSequence(start, end);\n                // Check for empty numeric part like \"&#;\" or \"&#x;\"\n                if (numericEntity.length() == 0) {\n                    return 0;\n                }\n\n                int entityValue;\n                if (isHex) {\n                    entityValue = Integer.parseInt(numericEntity.toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(numericEntity.toString(), 10);\n                }\n\n                // Handle supplementary characters (code points > 0xFFFF)\n                // These require two chars in UTF-16\n                if (entityValue > 0xFFFF) {\n                    out.write(Character.toChars(entityValue));\n                } else {\n                    // Handle BMP characters (code points <= 0xFFFF)\n                    // These require one char in UTF-16\n                    out.write((char) entityValue);\n                }\n\n                // Calculate consumed characters: position after ';' minus starting position 'index'\n                // Includes '&', '#', optional 'x'/'X', digits, and ';'\n                return (end + 1) - index;\n\n            } catch (NumberFormatException nfe) {\n                // Catches invalid numeric sequences between #/[xX] and ;\n                return 0; // Indicates no translation occurred\n            }\n        }\n        // Not a numeric entity starting at index\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}