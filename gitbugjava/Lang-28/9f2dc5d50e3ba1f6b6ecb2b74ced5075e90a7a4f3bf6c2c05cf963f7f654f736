{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        final int seqEnd = input.length();\n        // Check for '&#'\n        // Check validity of the index and the next character first\n        if (input.charAt(index) == '&' && index + 1 < seqEnd && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            // Check if there's at least one character after '&#'\n            if (start == seqEnd) {\n                return 0; // Incomplete entity '&#'\n            }\n\n            boolean isHex = false;\n            char firstChar = input.charAt(start);\n            // Check for hex marker 'x' or 'X'\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n                // Check if there's at least one character after '&#x'\n                if (start == seqEnd) {\n                    return 0; // Incomplete entity '&#x'\n                }\n            }\n\n            int end = start;\n            // Find the ending semicolon, ensuring we don't go out of bounds\n            while (end < seqEnd && input.charAt(end) != ';') {\n                end++;\n            }\n\n            // Check if semicolon was found before the end of the sequence\n            // and if there were any digits (i.e., end > start)\n            if (end == seqEnd || end == start) {\n                // Malformed entity: no semicolon found or no digits/hex digits found\n                return 0;\n            }\n\n            int entityValue;\n            try {\n                CharSequence sub = input.subSequence(start, end);\n                if (isHex) {\n                    entityValue = Integer.parseInt(sub.toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(sub.toString(), 10);\n                }\n            } catch (NumberFormatException nfe) {\n                // Malformed entity: the sequence between #/[x] and ; is not a valid number\n                return 0;\n            }\n\n            // Check if the value is a valid Unicode code point\n            // Note: Integer.parseInt can produce negative values for large hex numbers\n            // if they exceed Integer.MAX_VALUE. Character methods handle code points as ints.\n            // We should ideally handle invalid code points, but the original didn't.\n            // Let's proceed assuming valid code points, focusing on the supplementary char issue.\n\n            if (entityValue > 0xFFFF) {\n                // Handle supplementary characters (code points > U+FFFF)\n                // These need to be encoded as a surrogate pair in UTF-16\n                char[] chars = Character.toChars(entityValue);\n                out.write(chars[0]);\n                out.write(chars[1]);\n            } else {\n                // Handle BMP characters (code points <= U+FFFF)\n                // Note: This includes values from 0 to 0xFFFF\n                out.write(entityValue);\n            }\n\n            // Calculate the number of input characters consumed\n            // It's 2 for '&#' + 1 if hex ('x') + number of digits (end - start) + 1 for ';'\n            return 2 + (isHex ? 1 : 0) + (end - start) + 1;\n        }\n        // Not a numeric entity starting at the given index\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}