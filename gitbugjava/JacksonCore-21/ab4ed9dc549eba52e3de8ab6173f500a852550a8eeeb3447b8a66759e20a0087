{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n\n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        // 11-Mar-2021, tatu: [core#677] This check needs to consider `_includePath` as well; specifically,\n        //     if path IS included, we need to retain enclosing Array/Object markers.\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n                // If path is included, need to see START + END; otherwise ok to stop\n                if (_currToken.isStructEnd()) {\n                    if (_headContext.isStartHandled() && !_includePath) { // Added !_includePath check\n                        return (_currToken = null);\n                    }\n                } else if (_currToken.isScalarValue()) {\n                    // If path is not included, and we have already matched a scalar value, we are done.\n                    // Minor complication: if scalar value is result of START_OBJECT/START_ARRAY handling, need to skip\n                    if (!_headContext.isStartHandled()\n                            && (_itemFilter == TokenFilter.INCLUDE_ALL)\n                            && !_includePath // Added !_includePath check\n                    ) {\n                        return (_currToken = null);\n                    }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of\n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    // Note: filterFinishArray/Object() is not called here in the original code\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                            // We must save FIELD_NAME as current token, _nextToken2() will return START_OBJECT\n                             _currToken = delegate.getCurrentToken(); // should be FIELD_NAME\n                        } else {\n                            return (_currToken = t);\n                        }\n                    } else {\n                        return (_currToken = t);\n                    }\n                } else if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                } else { // filter indicates potential match\n                    f = f.includeProperty(name);\n                    if (f == null) { // but property itself is not matching\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        break;\n                    }\n                    // property potentially included, filter `f` to use\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                             return (_currToken = t);\n                        }\n                         // Path not included, but property matches: need context buffering?\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                             t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                             _exposedContext = _headContext;\n                             // We must save FIELD_NAME as current token, _nextToken2() will return START_OBJECT\n                             _currToken = delegate.getCurrentToken(); // should be FIELD_NAME\n                        } else {\n                            // Matched, but path not included, immediate parent not include OR already handled\n                            // -> Just return the FIELD_NAME? Seems unlikely, should perhaps buffer?\n                            // Or, does this case mean \"don't return\"? Original code fell through.\n                            // Let's assume falling through to _nextToken2() is needed if !includePath\n                            // and the token isn't immediately returned.\n                            // But if INCLUDE_ALL, why buffer? Let's reconsider the original flow:\n                            // If includePath=false, includeImmediateParent=false, includeProperty returns INCLUDE_ALL,\n                            // it fell through. This seems wrong, it should probably return the FIELD_NAME.\n                            // Let's stick to minimal change for now: if it wasn't returned above, it falls through.\n                        }\n                    } else if (_includePath) {\n                        // property possibly matching, path included: buffer\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                // If FIELD_NAME wasn't returned, fall through to _nextToken2()\n                if (_currToken == t) { // If _currToken was updated to FIELD_NAME above, don't fall through\n                   // Actually, the only cases returning 't' are when f == INCLUDE_ALL and includePath=true\n                   // or f == INCLUDE_ALL and includePath=false and immediate parent handled.\n                   // The other cases (_includeImmediateParent triggering buffering) set _currToken\n                   // but should fall through.\n                   // The buffering case (_nextTokenWithBuffering) returns if t!=null.\n                   // If we reach here, it means either FIELD_NAME was skipped, or requires buffering via _nextToken2()\n                   // or it matched but path wasn't included in a way that returned immediately.\n                   // Reverting to original logic: break here seems correct if FIELD_NAME wasn't returned.\n                   break;\n                }\n                // If _currToken was NOT set to t, or if _exposedContext was set, fall-through might be needed.\n                // Let's stick to the original structure's fallthrough logic.\n            }\n            break; // This break was in the original code for the FIELD_NAME case\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    // Value included. Need to check for parent buffering like with FIELD_NAME\n                     if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT/ARRAY but also marks it handled\n                        _exposedContext = _headContext;\n                        // Need to save the scalar value as _currToken before returning buffered parent start\n                        _currToken = delegate.getCurrentToken(); // Should be the scalar token\n                        // Fall through to _nextToken2() to return the buffered token first\n                    } else {\n                        // Included, path included OR immediate parent not needed/handled\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        // This is called if:\n        // - Token is skipped (like START_ARRAY/OBJECT, non-matching FIELD_NAME)\n        // - Buffering via _exposedContext occurred (_includeImmediateParent cases)\n        // - START_ARRAY/OBJECT potentially needs buffering (_includePath=true but filter != INCLUDE_ALL)\n        // - Non-matching scalar value\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}