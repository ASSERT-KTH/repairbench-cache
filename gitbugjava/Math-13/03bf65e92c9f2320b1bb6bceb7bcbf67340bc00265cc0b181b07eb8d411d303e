{
    "generation": "import org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.linear.EigenDecomposition;\nimport org.apache.commons.math3.linear.DiagonalMatrix;\nimport org.apache.commons.math3.util.FastMath;\n\n    /**\n     * Computes the square-root of the weight matrix.\n     * <p>\n     * This method is optimized for diagonal matrices, which are common in weighted least squares problems\n     * where each observation has an independent weight. For non-diagonal matrices, it falls back to using\n     * EigenDecomposition, which is computationally more expensive and requires more memory.\n     * </p>\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n        // Check if the matrix is diagonal. This is a common case for weight matrices in WLS.\n        // Calculating the square root of a diagonal matrix is much more efficient than EigenDecomposition.\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final double[] sqrtDiag = new double[dim];\n            for (int i = 0; i < dim; ++i) {\n                // The input matrix m is positive-definite, so diagonal elements are positive.\n                sqrtDiag[i] = FastMath.sqrt(m.getEntry(i, i));\n            }\n            // Create a new diagonal matrix with the square roots of the diagonal elements.\n            // Pass 'false' to avoid unnecessary copying of the internal array.\n            return new DiagonalMatrix(sqrtDiag, false);\n        } else {\n            // Fallback for general symmetric positive-definite matrices.\n            // This might be memory-intensive for very large matrices.\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}