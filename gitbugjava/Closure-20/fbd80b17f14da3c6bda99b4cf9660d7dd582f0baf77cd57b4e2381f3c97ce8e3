{
    "generation": "import com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.common.base.Preconditions;\n\n// ... inside the class PeepholeSubstituteAlternateSyntax ...\n\n  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n\n    // Check if it's a call to the global String function: String(arg)\n    if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n\n      // Check for exactly one argument\n      Node value = callTarget.getNext();\n      // We require exactly one argument, and the argument must be immutable.\n      if (value != null && value.getNext() == null) {\n\n        // Fold String(a) to '' + (a) on immutable literals,\n        // which allows further optimizations.\n        //\n        // We can't do this in the general case, because String(a) has\n        // slightly different semantics than '' + (a). See\n        // http://code.google.com/p/closure-compiler/issues/detail?id=759\n        if (NodeUtil.isImmutableValue(value)) {\n          // Create the ADD node: '' + value\n          Node emptyString = IR.string(\"\").srcref(callTarget);\n          // Detach the value node from the original call structure.\n          Node addition = IR.add(emptyString, value.detach());\n          // Copy source information from the original call node to the new add node.\n          addition.srcrefTreeIfMissing(n);\n\n          // Replace the original CALL node 'n' with the new ADD node 'addition'.\n          n.replaceWith(addition);\n          reportCodeChange();\n          return addition; // Return the new node\n        }\n      }\n    }\n    return n; // Return the original node if no change was made\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}