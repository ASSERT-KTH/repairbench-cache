{
    "generation": "import java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.WildcardType;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.GenericArrayType;\n\n// A minimal surrounding class structure is assumed for context, but only the method is required.\nclass ReflectionUtils { // Example class name\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     * If the first generic type argument is itself parameterized (e.g. List<Set<String>>), it returns the raw type\n     * of that argument (e.g. Set.class). For other complex types like TypeVariables or WildcardTypes, it returns Object.class.\n     *\n     * @param field the field to inspect\n     * @return the Class of the first generic type argument, or Object.class if not determinable or not generic.\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) generic;\n            Type[] actualTypeArguments = pt.getActualTypeArguments();\n\n            if (actualTypeArguments.length > 0) {\n                Type firstTypeArgument = actualTypeArguments[0];\n\n                if (firstTypeArgument instanceof Class) {\n                    // e.g. ArgumentCaptor<Foo> -> Foo.class\n                    return (Class<?>) firstTypeArgument;\n                } else if (firstTypeArgument instanceof ParameterizedType) {\n                    // e.g. ArgumentCaptor<List<Foo>> -> List.class\n                    // Cast is safe because raw type of ParameterizedType is Class\n                    return (Class<?>) ((ParameterizedType) firstTypeArgument).getRawType();\n                }\n                // Handle other cases like TypeVariable<?> or WildcardType<?> ?\n                // Returning Object.class is a safe fallback, similar to non-generic types.\n                // This covers cases like ArgumentCaptor<T> or ArgumentCaptor<? extends Number>\n                // where the actual class isn't directly specified in the field signature.\n                // It might also cover GenericArrayType if needed, though less common as direct arg.\n            }\n        }\n\n        // Return Object.class for non-generic fields, raw types, or unhandled generic types.\n        return Object.class;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}