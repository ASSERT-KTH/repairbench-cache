{
    "generation": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n        }\n        \n        // Ok: here's where context might come in handy!\n        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n         *   unresolved type variables to handle some cases where bounds\n         *   are enough. Let's hope it does not hide real fail cases.\n         */\n        JavaType actualType = context.findType(name);\n        if (actualType != null) {\n            return actualType;\n        }\n\n        /* 16-Apr-2015, tatu: Unexpected problem: recursive types with partial\n         *   bindings (like subtype having only some of bindings). If so, need\n         *   to ensure we will check placeholders... Also: must check for direct\n         *   recursion. Fixed as per [databind#728]\n         */\n        if (context.isTryingToResolve(type)) { // see [databind#728]\n             return _unknownType();\n        }\n        context.startResolution(type);\n\n        try { // Note: must have final block to ensure clearing of resolution state\n            /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n             *   bound: but the problem is that this can occur for generic \"base\"\n             *   method, overridden by sub-class. If so, we will want to ignore\n             *   current type (for method) since it will be masked.\n             */\n            Type[] bounds = type.getBounds();\n    \n            // With type variables we must use bound information.\n            // Theoretically this gets tricky, as there may be multiple\n            // bounds (\"... extends A & B\"); and optimally we might\n            // want to choose the best match. Also, bounds are optional;\n            // but here we are lucky in that implicit \"Object\" is\n            // added as bounds if so.\n            // Either way let's just use the first bound, for now, and\n            // worry about better match later on if there is need.\n            if (bounds.length == 0) { // this should not happen according to spec\n                 return _unknownType();\n            }\n    \n            /* 29-Jan-2010, tatu: One more problem are recursive types\n             *   (T extends Comparable<T>). Need to add \"placeholder\"\n             *   for resolution to catch those.\n             */\n            context._addPlaceholder(name);\n            return _constructType(bounds[0], context);\n        } finally {\n             context.resolveFinally(type);\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}