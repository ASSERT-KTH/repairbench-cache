{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        // The following variables are used in Brent's method algorithm.\n        // See explanation, e.g., in Numerical Recipes, Chapter 10.2\n        double x = mid; // Current point, stores the best point found so far\n        double v = x;   // Previous best point\n        double w = x;   // Point before previous best point / Point with second best value\n        double d = 0;   // Step size in the last iteration\n        double e = 0;   // Step size in the iteration before last\n        double fx = computeObjectiveValue(x); // Objective function value at x\n        if (!isMinim) {\n            fx = -fx; // Negate if maximizing, as Brent's finds minimum\n        }\n        double fv = fx; // Objective function value at v\n        double fw = fx; // Objective function value at w\n\n        UnivariatePointValuePair previous = null;\n        // current keeps track of the point evaluated in the current iteration for the convergence checker\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Note: (x, fx) always tracks the best point found *internally* by the algorithm.\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Midpoint of the current interval [a, b]\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold; // Tolerance based on x\n            final double tol2 = 2 * tol1; // Double tolerance\n\n            // Default stopping criterion: check if the interval width relative to x is small enough\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\n            if (stop) {\n                 // Default termination criterion is met.\n                 // Return the best point found, which is stored in (x, fx).\n                 return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            }\n\n            // If not converged, calculate the next point u to evaluate.\n            double p = 0; // Numerator for parabolic interpolation step\n            double q = 0; // Denominator for parabolic interpolation step\n            double r = 0; // Used temporarily\n            double u = 0; // Point to be evaluated next\n\n            // Try parabolic interpolation if there's enough history (e > tol1)\n            if (FastMath.abs(e) > tol1) {\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p; // Ensure q is positive\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store previous step (from second last iteration)\n                e = d; // Store step from last iteration\n\n                // Check if the parabolic interpolation step is acceptable\n                if (p > q * (a - x) &&      // Is the interpolated point within (a, b)?\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // Is the step size reasonable compared to previous steps?\n\n                    // Parabolic interpolation step is accepted\n                    d = p / q;\n                    u = x + d;\n\n                    // Check if the function must be evaluated too close to the boundaries a or b\n                    if (u - a < tol2 || b - u < tol2) {\n                        // If too close, compute step towards midpoint m, with size tol1\n                        // This prevents u from being extremely close to a boundary,\n                        // which might happen with floating point inaccuracies.\n                        d = (x <= m) ? tol1 : -tol1;\n                        // Note: u is not recalculated here. The adjusted d will be used below.\n                    }\n                } else {\n                    // Parabolic interpolation failed or is rejected, use Golden Section step\n                    e = (x < m) ? (b - x) : (a - x); // Set interval width for golden section\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Not enough history or previous step was too small, use Golden Section step\n                e = (x < m) ? (b - x) : (a - x); // Set interval width for golden section\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Ensure the step size d is at least tol1 in magnitude.\n            // This prevents the algorithm from stalling if d becomes too small.\n            if (FastMath.abs(d) < tol1) {\n                u = x + (d >= 0 ? tol1 : -tol1); // Force a step of size tol1\n            } else {\n                u = x + d; // Use the calculated step d\n            }\n\n            // Evaluate the objective function at the new point u\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu; // Negate if maximizing\n            }\n\n            // Update 'previous' and 'current' state for the convergence checker\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // Check user-defined convergence checker, if provided\n            if (checker != null) {\n                // If the checker indicates convergence after evaluating u, stop.\n                if (checker.converged(iter, previous, current)) {\n                    // Return the best point found overall, stored in (x, fx).\n                    return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n                }\n            }\n\n            // Update the algorithm state (a, b, v, w, x, fx, fv, fw) based on the new point (u, fu)\n            // This maintains the bracketing interval [a, b] and the points x, v, w\n            // such that fx <= fv and fx <= fw.\n            if (fu <= fx) { // Case 1: New point u is better than or equal to the current best x\n                // Update the interval boundaries\n                if (u < x) { // New point u is to the left of x\n                    b = x;   // New interval is [a, x]\n                } else {     // New point u is to the right of x\n                    a = x;   // New interval is [x, b]\n                }\n                // Shift the points: v <- w, w <- x, x <- u\n                v = w; fv = fw;\n                w = x; fw = fx;\n                x = u; fx = fu; // Update the best point x and its value fx\n            } else { // Case 2: New point u is worse than the current best x\n                // Update the interval boundaries\n                if (u < x) { // New point u is to the left of x\n                    a = u;   // New interval is [u, b]\n                } else {     // New point u is to the right of x\n                    b = u;   // New interval is [a, u]\n                }\n                // Update v and w if u is better than them, maintaining fx <= fv, fx <= fw\n                if (fu <= fw || Precision.equals(w, x)) {\n                    // If u is better than w, or w is the same as x (degenerate case)\n                    // Shift v and w: v <- w, w <- u\n                    v = w; fv = fw;\n                    w = u; fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    // If u is not better than w, but is better than v (or v is degenerate)\n                    // Update only v: v <- u\n                    v = u; fv = fu;\n                }\n            }\n\n            ++iter; // Increment iteration counter\n        } // End of while loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}