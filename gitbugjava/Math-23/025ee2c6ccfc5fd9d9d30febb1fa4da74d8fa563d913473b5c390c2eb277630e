{
    "generation": "import org.apache.commons.math3.exception.NotStrictlyPositiveException; // Keep relevant imports if needed by class context\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\nimport org.apache.commons.math3.optimization.ConvergenceChecker;\nimport org.apache.commons.math3.optimization.GoalType;\nimport org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer;\nimport org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Precision;\n\n// Assuming class structure and necessary methods like getRelativeAccuracy(), getAbsoluteAccuracy(), etc. are present.\n\n    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n        // Convergence parameters\n        // Assuming methods getRelativeAccuracy() and getAbsoluteAccuracy() exist and are correctly implemented.\n        final double relativeThreshold = getRelativeAccuracy();\n        final double absoluteThreshold = getAbsoluteAccuracy();\n        // Brent's method constant for golden section\n        final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n\n        // Set up the search interval [a, b], ensuring a <= b\n        double a; // Lower bound of the bracket\n        double b; // Upper bound of the bracket\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        // Initialize Brent's state variables\n        double x = mid; // Current point with the best function value found so far (among x, w, v)\n        double v = x;   // Point with the second best function value\n        double w = x;   // Point with the third best function value (or previous value of v)\n        double d = 0;   // Step taken in the last iteration ('d' in Brent's notation)\n        double e = 0;   // Step taken in the iteration before last ('e' in Brent's notation, used for parabolic fit check)\n\n        // Evaluate the objective function at the initial point 'x' (start value 'mid')\n        final double fxEvaluated = computeObjectiveValue(x);\n\n        // Track the best point found overall throughout the optimization process.\n        // Initialize with the starting point. Uses original function values.\n        UnivariatePointValuePair bestPointSoFar = new UnivariatePointValuePair(x, fxEvaluated);\n\n        // Internal working function values for Brent's core minimization logic.\n        // Negate function values if the goal is maximization, so the algorithm always minimizes internally.\n        double fx = isMinim ? fxEvaluated : -fxEvaluated; // Value at x\n        double fv = fx; // Value at v\n        double fw = fx; // Value at w\n\n        // Variables to hold the points for the convergence checker. Uses original function values.\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = bestPointSoFar; // The initial point is the first 'current' point\n\n        int iter = 0; // Iteration counter\n        while (true) {\n            final double m = 0.5 * (a + b); // Midpoint of the current interval [a, b]\n            // Calculate tolerance based on current point x\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion (Brent's criterion):\n            // Check if the distance between x and the interval midpoint m is small enough\n            // relative to the interval width (b - a).\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\n            if (stop) {\n                // Termination condition met, return the best point found overall.\n                return bestPointSoFar;\n            }\n\n            // --- Begin computing the next trial point 'u' ---\n            // Logic follows Brent's method: try parabolic interpolation, fall back to golden section search.\n            double p = 0; // Numerator for parabolic interpolation step\n            double q = 0; // Denominator for parabolic interpolation step\n            double r = 0; // Temporary variable used in parabola calculation\n\n            // Try parabolic interpolation only if the step before last ('e') was significant enough.\n            if (FastMath.abs(e) > tol1) {\n                // Fit parabola through the three points (x, fx), (w, fw), (v, fv)\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) { // Ensure q is positive (parabola opens upward for minimum)\n                    p = -p;\n                } else { // q should be negative if parabola opens downward\n                    q = -q;\n                }\n\n                r = e; // Store step from iter-2 (used to check step size reduction)\n                e = d; // Store step from iter-1 (will become step before last in next iteration)\n\n                // Check acceptability of the parabolic interpolation step\n                // 1. Is the interpolation point within the interval (a, b)? (p > q*(a-x) and p < q*(b-x))\n                // 2. Is the step size reasonable compared to previous steps? (abs(p) < abs(0.5*q*r))\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step is accepted.\n                    d = p / q; // Calculate step distance\n                    // Note: u will be calculated later using this 'd'\n\n                    // Check if the proposed point u=x+d would be too close to boundaries\n                    // This check influences whether the step 'd' is potentially overridden by +/- tol1 below.\n                     final double u_proposed = x + d;\n                     if (u_proposed - a < tol2 || b - u_proposed < tol2) {\n                         // If u is too close to a boundary, invalidate the parabolic step 'd' calculated above\n                         // by setting d to +/- tol1. This effectively forces a minimal step or golden section later.\n                         // The direction ensures the step is taken towards the middle of the interval.\n                         d = (x < m) ? tol1 : -tol1;\n                     }\n                     // If the parabolic step was rejected (e.g., point outside interval), fall through to golden section.\n                } else {\n                    // Parabolic step is not acceptable, perform a golden section step instead.\n                    // 'e' will store the width of the larger interval section.\n                    e = (x < m) ? (b - x) : (a - x);\n                    d = GOLDEN_SECTION * e;\n                }\n            } else { // Previous step 'e' was too small, use golden section search.\n                // 'e' will store the width of the larger interval section.\n                e = (x < m) ? (b - x) : (a - x);\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Determine the final point 'u' for evaluation.\n            // Ensure the step size |d| is at least 'tol1'.\n            final double u; // The point where the function will be evaluated next.\n            if (FastMath.abs(d) >= tol1) { // If proposed step 'd' (from parabola or golden section) is large enough\n                 u = x + d;\n            } else { // Proposed step 'd' is too small, force a minimum step of size 'tol1'.\n                 // Use the sign of 'd' to determine the direction of the minimum step.\n                 u = x + (d >= 0 ? tol1 : -tol1);\n            }\n            // --- End computing the next trial point 'u' ---\n\n\n            // Evaluate the objective function at the new point 'u'.\n            final double fuEvaluated = computeObjectiveValue(u);\n\n            // Create the pair representing the new point with its original function value.\n            final UnivariatePointValuePair newPoint = new UnivariatePointValuePair(u, fuEvaluated);\n\n            // Update the overall best point found so far if the new point is better.\n            // Comparison uses original function values based on the optimization goal.\n             if (isMinim) {\n                 // Use '<' for comparison. If multiple points have the exact same minimal value,\n                 // this might favor later points, which is generally acceptable.\n                 if (newPoint.getValue() < bestPointSoFar.getValue()) {\n                     bestPointSoFar = newPoint;\n                 }\n             } else { // MAXIMIZE goal\n                 if (newPoint.getValue() > bestPointSoFar.getValue()) {\n                     bestPointSoFar = newPoint;\n                 }\n             }\n\n            // Potentially negate the evaluated function value for internal minimization logic.\n            double fu = isMinim ? fuEvaluated : -fuEvaluated;\n\n            // Update 'previous' and 'current' points for the external convergence checker.\n            // These hold pairs with original function values.\n            previous = current;\n            current = newPoint;\n\n            // Check for convergence using the optional user-defined checker.\n            if (checker != null) {\n                // If the checker indicates convergence, return the overall best point found.\n                if (checker.converged(iter, previous, current)) {\n                    return bestPointSoFar;\n                }\n            }\n\n            // Update Brent's internal state variables (a, b, v, w, x, fv, fw, fx).\n            // This logic determines the next search interval and updates the points used for interpolation.\n            // It uses the potentially negated function values (fu, fx, etc.) for internal comparison (minimization).\n            if (fu <= fx) { // New point 'u' is better than or equal to current best 'x' (in terms of minimization objective)\n                // Update the interval boundaries: the minimum must be between a and x, or x and b.\n                if (u < x) { // If u is to the left of x\n                    b = x;   // The new interval is [a, x]\n                } else {     // If u is to the right of x (or u == x)\n                    a = x;   // The new interval is [x, b]\n                }\n                // Shift the points: v <- w, w <- x, x <- u (update the three points defining the potential parabola)\n                v = w; fv = fw;\n                w = x; fw = fx;\n                x = u; fx = fu; // 'u' becomes the new best point 'x'\n            } else { // New point 'u' is worse than current best 'x' (fu > fx)\n                // Update the interval boundaries: the minimum must be between a and u, or u and b.\n                if (u < x) { // If u is to the left of x\n                    a = u;   // The new interval is [u, b]\n                } else {     // If u is to the right of x\n                    b = u;   // The new interval is [a, u]\n                }\n                // Update the secondary points 'v' and 'w' only if 'u' is better than them.\n                // This maintains the property that fx <= fw <= fv (usually).\n                if (fu <= fw || Precision.equals(w, x)) { // If u is better than w, or w is the same point as x\n                    v = w; fv = fw; // Shift w to v\n                    w = u; fw = fu; // Update w to u\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) { // If u is better than v, or v is the same as x or w\n                    v = u; fv = fu; // Update v to u\n                }\n                // If fu > fx, fu > fw, and fu > fv, then 'u' is worse than all three tracked points x, w, v.\n                // In this case, x, fx, w, fw, v, fv remain unchanged, only the interval [a, b] is updated.\n            }\n\n            ++iter; // Increment iteration counter\n        } // End of while loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}