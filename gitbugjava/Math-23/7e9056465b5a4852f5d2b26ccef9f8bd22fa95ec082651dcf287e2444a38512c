{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid; // Current best point estimate\n        double v = x;   // Second best point\n        double w = x;   // Previous value of w\n        double d = 0;   // Step size in current iteration (delta)\n        double e = 0;   // Step size in iteration before previous (used to check termination/parabola fit)\n        double fx = computeObjectiveValue(x); // Objective function value at x\n        if (!isMinim) {\n            fx = -fx; // Internal optimization is always minimization\n        }\n        double fv = fx; // Objective function value at v\n        double fw = fx; // Objective function value at w\n\n        UnivariatePointValuePair previous = null; // Previous point for checker\n        // Initialize current with the initial point's actual value (not negated)\n        UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0; // Local iteration counter for the checker\n        while (true) {\n            // Increment the framework's iteration counter (for max iterations limit)\n            // Note: This call might need to be adapted based on the specific base class structure.\n            // Assuming it exists based on typical optimizer patterns.\n            incrementIterationCount();\n\n            final double m = 0.5 * (a + b); // Midpoint of the current interval [a, b]\n            // Access threshold fields directly (relativeThreshold, absoluteThreshold are fields)\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold; // Tolerance based on current point x\n            final double tol2 = 2 * tol1; // Double tolerance\n\n            // Check for convergence based on Brent's criterion:\n            // The interval width |x - m| should be within tolerance, accounting for interval size (b - a).\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                // Convergence criterion met. Return the best point found (x, fx).\n                // Adjust the function value back if we were maximizing.\n                return new UnivariatePointValuePair(x, isMinim ? fx : -fx); // FIX: Return the best point found (x, fx)\n            }\n\n            double p = 0; // Numerator for parabolic interpolation step calculation\n            double q = 0; // Denominator for parabolic interpolation step calculation\n            double r = 0; // Temporary variable, reused (stores previous step 'e' during parabola check)\n\n            // Try parabolic interpolation step if the step size 'e' from the step before previous was significant\n            boolean parabola_ok = false; // Flag to indicate if parabolic step was successful\n            if (FastMath.abs(e) > tol1) {\n                // Calculate coefficients for the parabola passing through (x, fx), (w, fw), (v, fv)\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                // Ensure q is positive (parabola opens upwards for minimum finding)\n                if (q > 0) {\n                    p = -p; // Adjust p to maintain sign convention for minimum finding step p/q\n                } else {\n                    q = -q; // Make q positive\n                }\n\n                r = e; // Store the step size 'd' from the previous iteration into 'r' (used for acceptance check)\n                e = d; // Update 'e' to be the step 'd' from the previous iteration (for the next loop's check)\n\n                // Check if the parabolic interpolation step is acceptable\n                // Condition 1 & 2: The interpolated point x + p/q must be within the current interval (a, b)\n                // Condition 3: The step size |p/q| must be smaller than half the step size |r| from the step before previous\n                if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic step is acceptable. Calculate the step size 'd'.\n                    d = p / q;\n                    double u_trial = x + d; // Calculate the tentative point based on parabolic step\n\n                    // Check if the tentative point 'u_trial' is too close to the boundaries 'a' or 'b'.\n                    if (u_trial - a < tol2 || b - u < tol2) { // Original check used `b - u`, likely meant `b - u_trial`\n                        // If too close, adjust the step size 'd' to be the minimal tolerance 'tol1'.\n                        // The direction is determined relative to the midpoint 'm'. If x is left of m, move right (+tol1).\n                        if (x < m) {\n                            d = tol1;\n                        } else { // If x is right of m (or at m), move left (-tol1).\n                            d = -tol1;\n                        }\n                    }\n                    // Parabolic step calculation succeeded (d might have been adjusted for boundary proximity).\n                    parabola_ok = true;\n                }\n            }\n\n            // If parabolic interpolation was not attempted or not acceptable, perform a golden section step.\n            if (!parabola_ok) {\n                // Determine the larger segment of the interval [a, b] relative to x.\n                if (x < m) {\n                    e = b - x; // Golden section search in the right interval [x, b]\n                } else {\n                    e = a - x; // Golden section search in the left interval [a, x]\n                }\n                d = GOLDEN_SECTION * e; // Calculate the golden section step size.\n                // Note: 'e' is updated here naturally based on interval width for the next iteration's check.\n            }\n\n            // Calculate the final evaluation point 'u' for this iteration.\n            // Ensure the step size 'd' (whether from parabola or golden section) has at least magnitude 'tol1'.\n            double u;\n            if (FastMath.abs(d) >= tol1) {\n                u = x + d; // Step is large enough, use it.\n            } else {\n                // Step is too small. Force a step of size 'tol1', preserving the sign (direction) of 'd'.\n                u = x + FastMath.copySign(tol1, d);\n            }\n\n            // Evaluate the objective function at the new point 'u'.\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu; // Apply negation for internal minimization if the goal is maximization.\n            }\n\n            // Update 'previous' and 'current' points for the convergence checker.\n            // These pairs store the actual (non-negated) function values.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // Check for convergence using the optional user-provided checker.\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // Checker indicates convergence. Return the best point found so far (x, fx).\n                    // Adjust the function value back if we were maximizing.\n                    return new UnivariatePointValuePair(x, isMinim ? fx : -fx); // FIX: Return the best point found\n                }\n            }\n\n            // Update the optimization state variables (a, b, x, v, w, fx, fv, fw) based on the new point (u, fu).\n            if (fu <= fx) { // New point 'u' is better than or equal to the current best 'x'.\n                // Update the interval bounds [a, b] to bracket the minimum more tightly.\n                if (u < x) {\n                    b = x; // New best is left of old best, so upper bound becomes old best.\n                } else {\n                    a = x; // New best is right of old best, so lower bound becomes old best.\n                }\n                // Update the points tracking the minimum: x becomes the new best 'u'.\n                // Previous best 'x' becomes the second best 'w'. Previous second best 'w' becomes 'v'.\n                v = w; fv = fw;\n                w = x; fw = fx;\n                x = u; fx = fu;\n            } else { // New point 'u' is worse than the current best 'x'.\n                // Update the interval bounds [a, b] using 'u' to exclude the region where 'u' lies.\n                if (u < x) {\n                    a = u; // 'u' is left of 'x' and worse, so 'u' becomes the new lower bound.\n                } else {\n                    b = u; // 'u' is right of 'x' and worse, so 'u' becomes the new upper bound.\n                }\n                // Update the second best 'w' or third best 'v' if 'u' is better than them.\n                // Check if 'u' is better than the second best 'w' OR if 'w' currently holds the best point 'x'.\n                if (fu <= fw || Precision.equals(w, x)) {\n                    // 'u' replaces 'w' as the second best. Old 'w' becomes 'v'.\n                    v = w; fv = fw;\n                    w = u; fw = fu;\n                }\n                // Check if 'u' is better than the third best 'v' OR if 'v' currently holds 'x' or 'w'.\n                else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    // 'u' replaces 'v' as the third best.\n                    v = u; fv = fu;\n                }\n            }\n\n            // Increment the local iteration counter used by the checker.\n            ++iter;\n        } // End of while loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}