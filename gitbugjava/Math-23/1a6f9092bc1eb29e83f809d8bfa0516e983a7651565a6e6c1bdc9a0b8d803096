{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        final double relativeThreshold = getRelativeAccuracy();\n        final double absoluteThreshold = getAbsoluteAccuracy();\n        // The value GOLDEN_SECTION should be defined elsewhere in the class, typically as (3 - sqrt(5))/2\n        final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid; // Current best point estimate\n        double v = x;   // Previous best point estimate\n        double w = x;   // Point with second lowest value\n        double d = 0;   // Step size in the current iteration (delta x)\n        double e = 0;   // Step size from the previous iteration (used to decide between parabolic and golden section)\n        double fx = computeObjectiveValue(x); // Objective function value at x\n        if (!isMinim) {\n            fx = -fx; // Internally, always minimize by negating the function if maximizing\n        }\n        double fv = fx; // Objective function value at v\n        double fw = fx; // Objective function value at w\n\n        UnivariatePointValuePair previous = null;\n        // current tracks the last evaluated point for the checker interface\n        UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Middle of the current interval [a, b]\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion (Brent's criterion).\n            // Check if the optimization has converged based on interval size relative to x.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                 // Termination condition met. Return the best point found.\n                 // The internal state (x, fx) represents the best point according to Brent's logic.\n                 return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            }\n\n            // If not stopping, calculate the next point u to evaluate.\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u; // Point to be evaluated in this iteration\n\n            if (FastMath.abs(e) > tol1) { // Try parabolic interpolation if previous step 'e' was large enough\n                // Fit parabola through (x,fx), (w,fw), (v,fv)\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) { // q contains denominator difference, ensure it's positive\n                    p = -p; // Adjust numerator sign accordingly\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store previous step size (d from previous iteration)\n                e = d; // Store step size from before previous iteration\n\n                // Check conditions for accepting parabolic interpolation step\n                // Check bounds: is the parabola minimum between a and b? (p/q is the step)\n                // Check step size reduction: is the step smaller than half the previous step?\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step is accepted.\n                    d = p / q; // Calculated step size\n                    u = x + d; // New point u\n\n                    // Check if u is too close to interval boundaries a or b\n                    if (u - a < tol2 || b - u < tol2) {\n                        // If too close, adjust step 'd' to be minimal step towards center 'm'\n                        // This modification prevents evaluating too near the boundaries.\n                        // The step 'd' is adjusted, and the minimum step check later will use it.\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                    // Note: u is not immediately recalculated with the adjusted d here.\n                    // The logic flows to the minimum step check below.\n                } else { // Parabolic interpolation failed or rejected\n                    // Perform a Golden section step.\n                    if (x < m) { // Check if x is in the lower or upper half of [a, b]\n                        e = b - x; // If lower half, the larger segment is (x, b]\n                    } else {\n                        e = a - x; // If upper half, the larger segment is [a, x)\n                    }\n                    d = GOLDEN_SECTION * e; // Calculate step using golden ratio\n                }\n            } else { // Previous step 'e' was too small, force Golden section step\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Ensure progress by taking a minimum step of size tol1 if the calculated step 'd' is too small.\n            if (FastMath.abs(d) >= tol1) {\n                 // Use the calculated step d (from parabola or golden section, possibly adjusted)\n                 u = x + d;\n            } else {\n                 // If calculated step d is too small, force a minimum step size tol1\n                 // Use the sign of d to determine direction.\n                 u = x + (d >= 0 ? tol1 : -tol1);\n            }\n\n            // Evaluate the objective function at the new point u.\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu; // Internal value is always minimized\n            }\n\n            // Prepare for convergence checker using the newly evaluated point (u, fu)\n            // 'previous' holds the 'current' from the last iteration\n            // 'current' holds the result of the current function evaluation\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n\n            // Update the Brent state (a, b, x, v, w, fx, fv, fw) based on the new point (u, fu)\n            // This maintains x as the point with the best function value found so far.\n            if (fu <= fx) { // Found a point as good or better than the current best x\n                if (u < x) { // If u is to the left of x, shrink interval from the right\n                    b = x;\n                } else { // If u is to the right of x, shrink interval from the left\n                    a = x;\n                }\n                // Shift the points: v<-w, w<-x, x<-u\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u; // Update best point x\n                fx = fu; // Update best value fx\n            } else { // New point u is worse than current best x\n                if (u < x) { // If u is to the left of x, shrink interval from the left\n                    a = u;\n                } else { // If u is to the right of x, shrink interval from the right\n                    b = u;\n                }\n                // Check if u is better than the second best w or third best v\n                if (fu <= fw || Precision.equals(w, x)) {\n                    // u becomes the new second best w\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    // u becomes the new third best v\n                    v = u;\n                    fv = fu;\n                }\n            }\n\n            // After state update, (x, fx) represents the best point found so far according to Brent logic.\n            final UnivariatePointValuePair currentBest = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n            // Check convergence with user-defined checker AFTER updating the algorithm state.\n            // The checker interface uses the sequence of evaluated points (previous, current).\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // If checker converges, return the overall best point found (x, fx).\n                    return currentBest;\n                }\n            }\n\n            // Increment iteration count and loop back to check default stop condition.\n            ++iter;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}