{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            // Skip the current entry's data if necessary\n            // Copied from org.apache.commons.io.IOUtils.skip(InputStream, long)\n            long numToSkip = entrySize - entryOffset;\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    // TAR entries shouldn't contain unexpected EOF when skipping\n                    // yet, so throw an exception\n                    throw new IOException(\"Unexpected EOF skipping current tar entry data\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) { // Check EOF after reading the header record\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            // Handle potential parsing errors in the header, such as invalid octal numbers\n            IOException ioe = new IOException(\"Failed to read tar entry header: \" + e.getMessage());\n            ioe.initCause(e); // Preserve the original cause\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // Read the long name from the entry's data section\n            byte[] longNameData = new byte[(int) entrySize];\n            int read = readAll(longNameData, 0, longNameData.length);\n            if (read != entrySize) {\n                 throw new IOException(\"Failed to read entire long name entry data\");\n            }\n            getNextEntry(); // Recursively call getNextEntry to process the actual entry after the long name entry\n            if (currEntry == null) {\n                // Bugzilla: 40334 - Malformed tar file, long name entry not followed by actual entry\n                return null;\n            }\n            // Remove trailing null terminator if present\n            int NUL_offset = longNameData.length;\n            // Some archives seem to pad the name with NULs, find the last non-NUL byte\n            for(int i = longNameData.length -1; i >= 0; i--){\n                if (longNameData[i] != 0) {\n                    break;\n                }\n                NUL_offset = i;\n            }\n            // TODO: Should use the tar header encoding? Default is UTF-8 for GNULongName\n            currEntry.setName(new String(longNameData, 0, NUL_offset));\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to PAX headers or other modifications, update entrySize.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }\n\n    /**\n     * Reads len bytes from the input stream into the buffer buf, starting at\n     * offset off. This method repeats the read until the buffer is filled,\n     * unless the stream ends prematurely.\n     *\n     * @param buf the buffer to read data into.\n     * @param off the offset in the buffer from which to start writing data.\n     * @param len the number of bytes to read.\n     * @return the number of bytes read, which is typically len unless the\n     * stream ends prematurely.\n     * @throws IOException if an I/O error occurs.\n     */\n    private int readAll(byte[] buf, int off, int len) throws IOException {\n        int totalRead = 0;\n        while (totalRead < len) {\n            int numRead = read(buf, off + totalRead, len - totalRead);\n            if (numRead == -1) {\n                if (totalRead == 0) {\n                    return -1; // Return -1 if EOF is encountered immediately\n                }\n                break; // Break if EOF is encountered after reading some data\n            }\n            totalRead += numRead;\n        }\n        return totalRead;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}