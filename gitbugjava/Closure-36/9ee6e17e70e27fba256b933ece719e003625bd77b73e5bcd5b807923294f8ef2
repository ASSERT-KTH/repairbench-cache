{
    "generation": "    /**\n     * @return true if the provided reference and declaration can be safely\n     *         inlined according to our criteria\n     */\n    private boolean canInline(\n        Reference declaration,\n        Reference initialization,\n        Reference reference) {\n      if (!isValidDeclaration(declaration)\n          || !isValidInitialization(initialization)\n          || !isValidReference(reference)) {\n        return false;\n      }\n\n      // If the value is read more than once, skip it.\n      // VAR declarations and EXPR_RESULT don't need the value, but other\n      // ASSIGN expressions parents do.\n      if (declaration != initialization &&\n          !initialization.getGrandparent().isExprResult()) {\n        return false;\n      }\n\n      // Be very conservative and do no cross control structures or\n      // scope boundaries\n      if (declaration.getBasicBlock() != initialization.getBasicBlock()\n          || declaration.getBasicBlock() != reference.getBasicBlock()) {\n        return false;\n      }\n\n      Node value = initialization.getAssignedValue();\n      Preconditions.checkState(value != null);\n      Node refNode = reference.getNode();\n      Node refParent = reference.getParent();\n\n\n      // Check 1: Do not inline into a call node if it changes the 'this' binding.\n      //   var a = b.c;\n      //   a();\n      // should not be inlined to b.c(), because it calls c in the context of b\n      // rather than the context of the window.\n      //   var a = b.c;\n      //   f(a)\n      // is ok.\n      if (value.isGetProp()\n          && refParent.isCall()\n          && refParent.getFirstChild() == refNode) {\n        return false;\n      }\n\n      // Check 2: Don't inline a FUNCTION into certain types of calls,\n      // as it can break analyses like class inheritance or singleton detection.\n      // This applies when the function is used as an argument to these special calls.\n      //   var F = function(){}; goog.inherits(G, F); => Cannot inline F\n      //   var C = function(){}; goog.addSingletonGetter(C); => Cannot inline C\n      if (value.isFunction() && refParent.isCall()) {\n          CodingConvention convention = compiler.getCodingConvention();\n\n          // Bug 2388531: Don't inline functions into class defining calls.\n          SubclassRelationship relationship = convention.getClassesDefinedByCall(refParent);\n          if (relationship != null) {\n              return false;\n          }\n\n          // issue 668: Don't inline functions into singleton getter definition calls.\n          if (convention.isSingletonGetterCall(refParent)) {\n              return false;\n          }\n      }\n\n      // TODO(johnlenz): Add more checks, e.g., for 'this'/'arguments' usage if\n      // we relax the basic block constraint.\n\n      // Check 3: Aggressive/Moderate movement constraints.\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}