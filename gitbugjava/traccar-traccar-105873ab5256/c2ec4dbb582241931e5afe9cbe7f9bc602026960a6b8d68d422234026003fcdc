{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.readUnsignedByte(); // header\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        // If response flag is set, send ACK/NACK\n        if (BitUtil.check(flags, 4)) {\n            // Slice buffer from current index to retain payload for potential response processing\n            sendResponse(channel, remoteAddress, index, type, buf.slice());\n        }\n\n        // Process only DATA or SERVICES messages\n        if (type == MSG_DATA || type == MSG_SERVICES) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n            // Track if the *current* position object has had its DeviceId set via key 0x01\n            boolean currentPositionHasId = false;\n\n            while (buf.isReadable()) {\n                // Read block length and calculate end index BEFORE reading the key\n                // Note: Length seems to be the length of the value part, excluding the key byte itself.\n                // The original code read length then key, then calculated endIndex. Let's stick to that.\n                // Re-reading the original code: it reads length byte, then key byte. endIndex calculation seems off.\n                // Let's assume the original calculation was correct for the protocol:\n                // endIndex = length_byte + current_reader_index (after reading length and key) -- seems wrong.\n                // Maybe it should be:\n                // int length = buf.readUnsignedByte(); int key = buf.readUnsignedByte(); int endIndex = buf.readerIndex() + length;\n                // Let's stick to the original code's reading order for now, assuming it was tested.\n                // However, calculating endIndex *before* reading the key seems safer.\n                int dataLength = buf.readUnsignedByte();\n                int key = buf.readUnsignedByte();\n                int endIndex = buf.readerIndex() + dataLength; // Calculate end index *after* reading key, using the length field\n\n\n                if (keys.contains(key)) {\n                    // Key repeated: finalize the previous position block if it's valid (has ID).\n                    if (currentPositionHasId) {\n                        if (!hasLocation) {\n                            // getLastLocation requires deviceId, which is set if currentPositionHasId is true.\n                            getLastLocation(position, null);\n                        }\n                        positions.add(position);\n                    } // else: discard previous block as it lacked a device ID (key 0x01).\n\n                    // Start new position block\n                    keys.clear();\n                    hasLocation = false;\n                    position = new Position(getProtocolName());\n                    currentPositionHasId = false; // Reset ID flag\n                }\n                keys.add(key);\n\n                // Ensure we don't read past the declared length for this block\n                ByteBuf valueSlice = buf.readSlice(dataLength); // Use a slice to prevent over-reading in cases\n                try {\n                    switch (key) {\n                        case 0x01:\n                            // IMEI / Device ID - necessary to associate the position\n                            String imei = valueSlice.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                            DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                            if (deviceSession == null) {\n                                // Cannot identify the device, abort processing this message.\n                                // Log warning? buf.skipBytes(valueSlice.readableBytes()); break; ?\n                                // Original code returned null for the whole message, maintain this behavior.\n                                return null;\n                            }\n                            position.setDeviceId(deviceSession.getDeviceId());\n                            currentPositionHasId = true; // Mark this position has having an ID\n                            break;\n                        case 0x02:\n                            long alarm = valueSlice.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                            break;\n                        case 0x14:\n                            position.set(Position.KEY_BATTERY_LEVEL, valueSlice.readUnsignedByte());\n                            position.set(Position.KEY_BATTERY, valueSlice.readUnsignedShortLE() * 0.001);\n                            break;\n                        case 0x20:\n                            hasLocation = true;\n                            position.setLatitude(valueSlice.readIntLE() * 0.0000001);\n                            position.setLongitude(valueSlice.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(valueSlice.readUnsignedShortLE()));\n                            position.setCourse(valueSlice.readUnsignedShortLE());\n                            position.setAltitude(valueSlice.readShortLE());\n                            int hdop = valueSlice.readUnsignedShortLE();\n                            position.setValid(hdop > 0); // Assuming hdop > 0 means valid GPS fix\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, valueSlice.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, valueSlice.readUnsignedByte());\n                            break;\n                        case 0x21:\n                            int mcc = valueSlice.readUnsignedShortLE();\n                            int mnc = valueSlice.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            while (valueSlice.isReadable()) { // Read all cell towers in this block\n                                int rssi = valueSlice.readByte();\n                                int lac = valueSlice.readUnsignedShortLE();\n                                int cid = valueSlice.readUnsignedShortLE();\n                                position.getNetwork().addCellTower(CellTower.from(mcc, mnc, lac, cid, rssi));\n                            }\n                            break;\n                        case 0x22:\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            while (valueSlice.isReadable()) { // Read all WiFi APs in this block\n                                int rssi = valueSlice.readByte();\n                                String mac = ByteBufUtil.hexDump(valueSlice.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                        mac.substring(0, mac.length() - 1), rssi));\n                            }\n                            break;\n                        case 0x23:\n                            position.set(\"tagId\", readTagId(valueSlice));\n                            position.setLatitude(valueSlice.readIntLE() * 0.0000001);\n                            position.setLongitude(valueSlice.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                            break;\n                        case 0x24:\n                            position.setTime(new Date(valueSlice.readUnsignedIntLE() * 1000));\n                            long status = valueSlice.readUnsignedIntLE();\n                            position.set(Position.KEY_STATUS, status);\n                            if (BitUtil.check(status, 4)) {\n                                position.set(Position.KEY_CHARGE, true);\n                            }\n                            if (BitUtil.check(status, 7)) {\n                                position.set(Position.KEY_ARCHIVE, true); // Indicates stored historical data\n                            }\n                            position.set(Position.KEY_MOTION, BitUtil.check(status, 9));\n                            position.set(Position.KEY_RSSI, BitUtil.between(status, 19, 24)); // GSM Signal Strength Indicator\n                            position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24)); // Battery level 0-100%\n                            break;\n                        case 0x28:\n                            int beaconFlags = valueSlice.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(valueSlice));\n                            position.set(\"tagRssi\", (int) valueSlice.readByte());\n                            position.set(\"tag1mRssi\", (int) valueSlice.readByte()); // Calibrated RSSI at 1m\n                            if (BitUtil.check(beaconFlags, 7)) { // Location included flag\n                                position.setLatitude(valueSlice.readIntLE() * 0.0000001);\n                                position.setLongitude(valueSlice.readIntLE() * 0.0000001);\n                                position.setValid(true);\n                                hasLocation = true;\n                            }\n                            if (BitUtil.check(beaconFlags, 6)) { // Description included flag\n                                position.set(\"description\", valueSlice.readCharSequence(\n                                        valueSlice.readableBytes(), StandardCharsets.US_ASCII).toString());\n                            }\n                            break;\n                        case 0x2A: // WiFi based location\n                            valueSlice.readUnsignedByte(); // flags\n                            valueSlice.skipBytes(6); // mac address of AP used for location\n                            valueSlice.readUnsignedByte(); // rssi\n                            position.setLatitude(valueSlice.readIntLE() * 0.0000001);\n                            position.setLongitude(valueSlice.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                            break;\n                        case 0x30: // Pedometer\n                            valueSlice.readUnsignedIntLE(); // timestamp\n                            position.set(Position.KEY_STEPS, valueSlice.readUnsignedIntLE());\n                            break;\n                        case 0x31: // Activity monitor\n                            int i = 1;\n                            while (valueSlice.isReadable()) {\n                                position.set(\"activity\" + i + \"Time\", valueSlice.readUnsignedIntLE()); // Duration\n                                position.set(\"activity\" + i, valueSlice.readUnsignedIntLE()); // Type? Count?\n                                i += 1;\n                            }\n                            break;\n                        case 0x37: // Barking detection\n                            valueSlice.readUnsignedIntLE(); // timestamp\n                            long barking = valueSlice.readUnsignedIntLE();\n                            if (BitUtil.check(barking, 31)) {\n                                position.set(\"barkStop\", true); // Barking stop event\n                            }\n                            position.set(\"barkCount\", BitUtil.to(barking, 31)); // Bark count\n                            break;\n                        case 0x40: // Heart rate\n                            valueSlice.readUnsignedIntLE(); // timestamp\n                            int heartRate = valueSlice.readUnsignedByte();\n                            if (heartRate > 1) { // Ignore 0 or 1?\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                            break;\n                        default:\n                            // Unknown key type, already sliced off, do nothing.\n                            break;\n                    }\n                } finally {\n                    // Ensure reader index of main buffer is advanced correctly, even if errors occur in switch\n                    // or if valueSlice wasn't fully read (e.g. unknown key, future data).\n                    buf.readerIndex(endIndex);\n                }\n            } // end while\n\n            // Handle the very last position object accumulated\n            if (currentPositionHasId) { // Only add if the last block had an ID\n                if (!hasLocation) {\n                    // Ensure deviceId is set before calling getLastLocation\n                    getLastLocation(position, null);\n                }\n                positions.add(position);\n            }\n\n            // Return the list of valid positions found, or null if none were valid (lacked ID)\n            return positions.isEmpty() ? null : positions;\n\n        } // end if type == MSG_DATA || type == MSG_SERVICES\n\n        return null; // Message type wasn't relevant\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}