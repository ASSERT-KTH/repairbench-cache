{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        // Ensure buffer has enough data for the header\n        if (buf.readableBytes() < 8) {\n            return null;\n        }\n\n        buf.readUnsignedByte(); // header\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        // sendResponse uses a slice of the *remaining* buffer AFTER the header\n        // The slice shares the underlying buffer but has independent reader/writer indices.\n        // Assuming sendResponse consumes the slice immediately or copies it if needed later.\n        if (BitUtil.check(flags, 4)) {\n            sendResponse(channel, remoteAddress, index, type, buf.slice());\n        }\n\n        if (type == MSG_DATA || type == MSG_SERVICES) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            // Initialize the first position object\n            Position position = new Position(getProtocolName());\n            DeviceSession deviceSession = null;\n\n            while (buf.isReadable()) {\n                // Need at least 2 bytes for block length and key\n                if (buf.readableBytes() < 2) {\n                    break; // Not enough data for block header\n                }\n                int blockLength = buf.readUnsignedByte();\n                // Check if blockLength is valid (at least 1 for the key byte itself)\n                if (blockLength < 1) {\n                    break; // Invalid block length, might indicate corruption\n                }\n                int key = buf.readUnsignedByte();\n                // Calculate end index for the current block's content, relative to current reader index\n                int endIndex = buf.readerIndex() + blockLength - 1; // Subtract 1 because blockLength includes the key byte\n\n                // Check buffer bounds for endIndex BEFORE reading content\n                if (endIndex > buf.writerIndex()) {\n                    break; // Invalid endIndex points beyond buffer limit, stop processing\n                }\n\n                // Check if the key indicates the start of a new logical position report\n                if (keys.contains(key)) {\n                    // Add the previously accumulated position data to the list, if it contains any useful info\n                    if (position.getFixTime() != null || position.getValid() || !position.getAttributes().isEmpty()) {\n                        positions.add(position);\n                    }\n                    // Start a new position object\n                    keys.clear();\n                    position = new Position(getProtocolName());\n                    // DO NOT call getLastLocation here; deviceId is not set yet.\n                }\n                keys.add(key); // Track keys seen for the current position object\n\n                // Check if there are enough bytes for the block content\n                int contentLength = blockLength - 1;\n                if (buf.readableBytes() < contentLength) {\n                    // Not enough data for the declared content length, skip to expected endIndex\n                    buf.readerIndex(endIndex);\n                    continue; // Move to next block header\n                }\n\n                // Process data based on key\n                switch (key) {\n                    case 0x01: // IMEI / Device Session\n                        if (contentLength >= 15) {\n                            String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                            // Only get session if not already identified for this message\n                            if (deviceSession == null) {\n                                deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                                // Don't check for null here; handle it once after the loop.\n                            }\n                            // Skip any extra bytes in the block beyond the 15-byte IMEI\n                            if (contentLength > 15) {\n                                buf.skipBytes(contentLength - 15);\n                            }\n                        } else {\n                            // Skip invalid IMEI block content\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x02: // Alarm\n                        if (contentLength >= 4) {\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                             if (contentLength > 4) { buf.skipBytes(contentLength - 4); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x14: // Battery\n                        if (contentLength >= 3) {\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                             if (contentLength > 3) { buf.skipBytes(contentLength - 3); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x20: // Location\n                        if (contentLength >= 19) {\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                            position.setCourse(buf.readUnsignedShortLE());\n                            position.setAltitude(buf.readShortLE());\n                            int hdop = buf.readUnsignedShortLE();\n                            position.setValid(hdop > 0); // Set validity based on HDOP\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                             if (contentLength > 19) { buf.skipBytes(contentLength - 19); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x21: // Cell Tower\n                        if (contentLength >= 3) { // Need MCC (2) + MNC (1)\n                            int mcc = buf.readUnsignedShortLE();\n                            int mnc = buf.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            // Remaining bytes for cell towers (RSSI(1) + LAC(2) + CID(2) = 5 bytes each)\n                            int remainingContent = endIndex - buf.readerIndex();\n                            while (remainingContent >= 5) {\n                                int rssi = buf.readByte();\n                                position.getNetwork().addCellTower(CellTower.from(\n                                        mcc, mnc, buf.readUnsignedShortLE(), buf.readUnsignedShortLE(), rssi));\n                                remainingContent -= 5;\n                            }\n                            if (remainingContent > 0) { buf.skipBytes(remainingContent); } // Skip leftover bytes\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x22: // WiFi Access Points\n                        // Need RSSI(1) + MAC(6) = 7 bytes per AP\n                        if (position.getNetwork() == null) {\n                            position.setNetwork(new Network());\n                        }\n                        int remainingContentWifi = endIndex - buf.readerIndex();\n                        while (remainingContentWifi >= 7) {\n                            int rssi = buf.readByte();\n                            // Use getBytes for MAC to avoid affecting buf reader index temporarily\n                            byte[] macBytes = new byte[6];\n                            buf.readBytes(macBytes);\n                            String mac = ByteBufUtil.hexDump(macBytes).replaceAll(\"(..)\", \"$1:\");\n                            position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                    mac.substring(0, mac.length() - 1), rssi));\n                            remainingContentWifi -= 7;\n                        }\n                        if (remainingContentWifi > 0) { buf.skipBytes(remainingContentWifi); } // Skip leftover bytes\n                        break;\n                    case 0x23: // Tag Location\n                        if (contentLength >= 14) { // tagId(6) + lat(4) + lon(4) = 14\n                            position.set(\"tagId\", readTagId(buf)); // Assumes readTagId reads 6 bytes correctly\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                             if (contentLength > 14) { buf.skipBytes(contentLength - 14); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x24: // Time and Status\n                        if (contentLength >= 8) { // time(4) + status(4) = 8\n                            position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                            long status = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_CHARGE, BitUtil.check(status, 4));\n                            position.set(Position.KEY_ARCHIVE, BitUtil.check(status, 7)); // Mark if historical\n                            position.set(Position.KEY_MOTION, BitUtil.check(status, 9));\n                            position.set(Position.KEY_RSSI, BitUtil.between(status, 19, 24));\n                            position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                            position.set(Position.KEY_STATUS, status);\n                             if (contentLength > 8) { buf.skipBytes(contentLength - 8); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x28: // Beacon Data\n                        if (contentLength >= 9) { // flags(1) + tagId(6) + rssi(1) + 1mRssi(1) = 9\n                            int beaconFlags = buf.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(buf)); // Assumes readTagId reads 6 bytes\n                            position.set(\"tagRssi\", (int) buf.readByte());\n                            position.set(\"tag1mRssi\", (int) buf.readByte());\n                            if (BitUtil.check(beaconFlags, 7)) {\n                                // Check remaining length for location (lat(4) + lon(4) = 8)\n                                if (endIndex - buf.readerIndex() >= 8) {\n                                    position.setLatitude(buf.readIntLE() * 0.0000001);\n                                    position.setLongitude(buf.readIntLE() * 0.0000001);\n                                    position.setValid(true);\n                                } else {\n                                    // Not enough bytes for location, skip rest of block\n                                    buf.readerIndex(endIndex);\n                                    break; // Break switch, outer loop will advance index\n                                }\n                            }\n                            if (BitUtil.check(beaconFlags, 6)) {\n                                int descriptionLength = endIndex - buf.readerIndex();\n                                if (descriptionLength > 0) {\n                                    position.set(\"description\", buf.readCharSequence(\n                                            descriptionLength, StandardCharsets.US_ASCII).toString());\n                                }\n                            }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x2A: // WiFi Location\n                        if (contentLength >= 16) { // flags(1) + mac(6) + rssi(1) + lat(4) + lon(4) = 16\n                            buf.readUnsignedByte(); // flags\n                            buf.skipBytes(6); // mac\n                            buf.readUnsignedByte(); // rssi\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                             if (contentLength > 16) { buf.skipBytes(contentLength - 16); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x30: // Steps\n                        if (contentLength >= 8) { // timestamp(4) + steps(4) = 8\n                            buf.readUnsignedIntLE(); // timestamp (ignore, use 0x24 time if available)\n                            position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                             if (contentLength > 8) { buf.skipBytes(contentLength - 8); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x31: // Activity\n                        // Read activity pairs (time(4) + activity(4) = 8 bytes)\n                        int i = 1;\n                        int remainingContentAct = endIndex - buf.readerIndex();\n                        while (remainingContentAct >= 8) {\n                            position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                            position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                            i += 1;\n                            remainingContentAct -= 8;\n                        }\n                        if (remainingContentAct > 0) { buf.skipBytes(remainingContentAct); } // Skip leftover bytes\n                        break;\n                    case 0x37: // Barking\n                        if (contentLength >= 8) { // timestamp(4) + barking(4) = 8\n                            buf.readUnsignedIntLE(); // timestamp (ignore)\n                            long barking = buf.readUnsignedIntLE();\n                            position.set(\"barkStop\", BitUtil.check(barking, 31));\n                            position.set(\"barkCount\", BitUtil.to(barking, 31));\n                             if (contentLength > 8) { buf.skipBytes(contentLength - 8); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    case 0x40: // Heart Rate\n                        if (contentLength >= 5) { // timestamp(4) + heartRate(1) = 5\n                            buf.readUnsignedIntLE(); // timestamp (ignore)\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) { // Seems 0 and 1 might be invalid/placeholders\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                             if (contentLength > 5) { buf.skipBytes(contentLength - 5); }\n                        } else {\n                            buf.skipBytes(contentLength);\n                        }\n                        break;\n                    default:\n                        // Unknown key, skip block content\n                        buf.skipBytes(contentLength);\n                        break;\n                }\n                // Ensure reader index is at the end of the block,\n                // handling cases where content was shorter/longer than expected or only partially processed.\n                buf.readerIndex(endIndex);\n            }\n\n            // Add the last processed position object if it has any data\n             if (!keys.isEmpty() && (position.getFixTime() != null || position.getValid() || !position.getAttributes().isEmpty())) {\n                 positions.add(position);\n            }\n\n            // Final checks and processing: Require deviceSession and at least one position\n            if (deviceSession == null) {\n                 return null; // No device identified (IMEI key 0x01 missing or failed lookup)\n            }\n            if (positions.isEmpty()) {\n                return null; // No position data could be decoded\n            }\n\n            // Set deviceId for all positions and attempt to fill missing locations\n            for (Position p : positions) {\n                p.setDeviceId(deviceSession.getDeviceId());\n                if (!p.getValid()) {\n                    // If no valid location fix was decoded directly for this position object\n                    // (e.g., from keys 0x20, 0x23, 0x28, 0x2A), try using the last known location.\n                    getLastLocation(p, p.getFixTime()); // Pass time if available (e.g., from key 0x24)\n                }\n            }\n\n            return positions;\n\n        }\n\n        return null; // type was not MSG_DATA or MSG_SERVICES\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}