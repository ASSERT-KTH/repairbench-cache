{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.channel.Channel;\nimport org.traccar.BaseProtocolDecoder;\nimport org.traccar.DeviceSession;\nimport org.traccar.Network;\nimport org.traccar.Protocol;\nimport org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Position;\nimport org.traccar.model.WifiAccessPoint;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n// Define constants locally for context, assuming they exist in the actual class\n// import static org.traccar.protocol.Minifinder2Protocol.*;\nabstract class Minifinder2ProtocolDecoderStub extends BaseProtocolDecoder {\n    public Minifinder2ProtocolDecoderStub(Protocol protocol) { super(protocol); }\n    protected static final int MSG_DATA = 0x10;\n    protected static final int MSG_SERVICES = 0x12;\n    protected static final int MSG_USER = 0x18; // Assumed based on tests\n    protected static final int MSG_RESPONSE = 0x7F; // Assumed based on tests\n    protected abstract void sendResponse(Channel channel, SocketAddress remoteAddress, int index, int type, ByteBuf slice);\n    protected abstract String decodeAlarm(long alarm);\n    protected abstract String readTagId(ByteBuf buf); // Assume reads 6 bytes\n    // Need overload for getDeviceSession called in MSG_RESPONSE handler\n    protected DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress) {\n        return super.getDeviceSession(channel, remoteAddress);\n    }\n}\n\n\n// Replace Minifinder2ProtocolDecoderStub with the actual class name if needed\npublic class FixedMinifinder2Decoder extends Minifinder2ProtocolDecoderStub {\n\n    // Dummy constructor + methods for the provided snippet context\n    // Replace with actual implementations or remove if inheriting correctly\n    public FixedMinifinder2Decoder(Protocol protocol) { super(protocol); }\n    @Override protected void sendResponse(Channel channel, SocketAddress remoteAddress, int index, int type, ByteBuf slice) {}\n    @Override protected String decodeAlarm(long alarm) { return Position.ALARM_GENERAL; }\n    @Override protected String readTagId(ByteBuf buf) { return ByteBufUtil.hexDump(buf.readSlice(6)); }\n\n    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        if (buf.readableBytes() < 9) { // header(1) + flags(1) + length(2) + checksum(2) + index(2) + type(1)\n             return null; // Not enough data for header\n        }\n\n        buf.readUnsignedByte(); // header (0xAB)\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        if (BitUtil.check(flags, 4)) { // Needs response?\n            // Create a slice *before* consuming buffer for potential response payload\n            ByteBuf responsePayload = buf.slice(buf.readerIndex(), buf.readableBytes());\n            sendResponse(channel, remoteAddress, index, type, responsePayload);\n        }\n\n        // Handle specific non-TLV types first (e.g., command responses)\n        if (type == MSG_RESPONSE) { // 0x7F\n             if (buf.readableBytes() >= 2) { // Expecting length 1, status byte\n                 int length = buf.readUnsignedByte();\n                 // Check if reported length matches remaining bytes and expected format\n                 if (length == 1 && buf.readableBytes() >= 1) {\n                     int status = buf.readUnsignedByte();\n                     Position position = new Position(getProtocolName());\n                     // Try to link response to device via channel\n                     DeviceSession session = getDeviceSession(channel, remoteAddress);\n                     if (session != null) {\n                         position.setDeviceId(session.getDeviceId());\n                         getLastLocation(position, null); // Include base info if possible\n                     }\n                     position.set(Position.KEY_RESULT, String.valueOf(status));\n                     return position; // Return single position with result\n                 }\n             }\n             // If format doesn't match, consume buffer based on header length? Or just return null?\n             // Returning null seems safer if the format is unexpected.\n             return null; // Malformed response or unexpected format\n        }\n\n        // Handle types that use the TLV (Tag-Length-Value) chunk format\n        // Added MSG_USER (0x18) based on test cases requiring parsing for this type\n        if (type == MSG_DATA || type == MSG_SERVICES || type == MSG_USER) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n            DeviceSession deviceSession = null; // Will be identified by 0x01 chunk if present\n\n            while (buf.isReadable()) {\n                if (buf.readableBytes() < 2) {\n                    break; // Not enough for chunk length byte and key byte\n                }\n                // Mark reader index before reading length and key for calculating endIndex robustly\n                buf.markReaderIndex();\n                int chunkLength = buf.readUnsignedByte(); // Includes key byte + data bytes\n                int key = buf.readUnsignedByte();\n                int dataLength = chunkLength - 1; // Length of data following the key\n\n                // Calculate the expected end index of this chunk's data\n                int endIndex = buf.readerIndex() + dataLength;\n\n                // Basic validation\n                if (chunkLength == 0 || dataLength < 0) {\n                    buf.resetReaderIndex(); // Reset to before reading length/key\n                    break; // Invalid chunk length, stop processing message\n                }\n                // Check if buffer contains enough bytes for the declared data length\n                if (buf.readableBytes() < dataLength) {\n                    buf.resetReaderIndex(); // Reset to before reading length/key\n                    break; // Not enough data in buffer for declared chunk length, stop processing\n                }\n\n                // Detect start of a new logical record based on duplicate key\n                if (keys.contains(key)) {\n                    // Add previous position only if it had some data (keys is not empty)\n                    if (!keys.isEmpty()) {\n                        if (!hasLocation) {\n                            // Get last known location if the completed record didn't have one\n                            getLastLocation(position, null);\n                        }\n                        positions.add(position);\n                    }\n                    // Reset for the new record\n                    keys.clear();\n                    hasLocation = false;\n                    position = new Position(getProtocolName());\n                }\n                keys.add(key);\n\n                // Process chunk based on key\n                switch (key) {\n                    case 0x01: // IMEI / Device ID\n                        if (dataLength == 15) {\n                            String imei = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                            deviceSession = getDeviceSession(channel, remoteAddress, imei);\n                            // Store session (or null), crucial: DO NOT return null here\n                        } else {\n                            buf.readerIndex(endIndex); // Skip malformed chunk data\n                        }\n                        break;\n\n                    case 0x02: // Alarm\n                        if (dataLength == 4) {\n                            long alarm = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                            if (BitUtil.check(alarm, 31)) {\n                                position.set(\"bark\", true);\n                            }\n                        } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x14: // Battery\n                        if (dataLength == 3) { // 1 level + 2 voltage\n                            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                            position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                        } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x20: // Location GPS\n                        if (dataLength == 21) { // 4 lat + 4 lon + 2 speed + 2 course + 2 alt + 2 hdop + 4 odo + 1 sats\n                            hasLocation = true;\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                            position.setCourse(buf.readUnsignedShortLE());\n                            position.setAltitude(buf.readShortLE());\n                            int hdop = buf.readUnsignedShortLE();\n                            position.setValid(hdop > 0); // GPS validity based on HDOP\n                            position.set(Position.KEY_HDOP, hdop * 0.1);\n                            position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                            position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                        } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x21: // Cell Tower\n                        // 2 mcc + 1 mnc + N * (1 rssi + 2 lac + 2 cid) Min dataLength = 3\n                        if (dataLength >= 3) {\n                            int mcc = buf.readUnsignedShortLE();\n                            int mnc = buf.readUnsignedByte();\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            // Read cell towers until the end of the chunk data\n                            while (buf.readerIndex() < endIndex && buf.readableBytes() >= 5) {\n                                int rssi = buf.readByte();\n                                int lac = buf.readUnsignedShortLE();\n                                int cid = buf.readUnsignedShortLE();\n                                position.getNetwork().addCellTower(CellTower.from(mcc, mnc, lac, cid, rssi));\n                            }\n                        }\n                        // Ensure reader index is advanced even if data was partial or malformed\n                        buf.readerIndex(endIndex);\n                        break;\n\n                    case 0x22: // WiFi AP\n                        // N * (1 rssi + 6 mac) Min dataLength = 0\n                        if (dataLength >= 0) { // Allow empty data section\n                             if (position.getNetwork() == null) {\n                                 position.setNetwork(new Network());\n                             }\n                             // Read WiFi APs until the end of the chunk data\n                             while (buf.readerIndex() < endIndex && buf.readableBytes() >= 7) {\n                                 int rssi = buf.readByte();\n                                 String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                 position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                         mac.substring(0, mac.length() - 1), rssi));\n                             }\n                        }\n                        buf.readerIndex(endIndex); // Ensure reader index is advanced\n                        break;\n\n                    case 0x23: // Tag Location\n                        if (dataLength == 14) { // 6 tagId + 4 lat + 4 lon\n                            position.set(\"tagId\", readTagId(buf)); // Assumes reads 6 bytes\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true); // Tag location assumed valid\n                            hasLocation = true;\n                        } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x24: // Time and Status\n                        if (dataLength == 8) { // 4 time + 4 status\n                            position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                            long status = buf.readUnsignedIntLE();\n                            position.set(Position.KEY_STATUS, status);\n                            position.set(Position.KEY_CHARGE, BitUtil.check(status, 4));\n                            position.set(Position.KEY_ARCHIVE, BitUtil.check(status, 7));\n                            position.set(Position.KEY_MOTION, BitUtil.check(status, 9));\n                            position.set(Position.KEY_RSSI, BitUtil.between(status, 19, 24));\n                            position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                            // Validity is determined by location source (0x20, 0x23, 0x2A)\n                        } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x28: // Beacon Info\n                        // 1 flags + 6 tagId + 1 rssi + 1 1mRssi (+ 4 lat + 4 lon) (+ N desc) Min dataLength = 9\n                        if (dataLength >= 9) {\n                            int beaconFlags = buf.readUnsignedByte();\n                            position.set(\"tagId\", readTagId(buf)); // Assumes reads 6 bytes\n                            position.set(\"tagRssi\", (int) buf.readByte());\n                            position.set(\"tag1mRssi\", (int) buf.readByte());\n                            if (BitUtil.check(beaconFlags, 7)) { // Location included\n                                // Ensure 8 bytes remain for location within the current chunk's data\n                                if (buf.readerIndex() + 8 <= endIndex && buf.readableBytes() >= 8) {\n                                    position.setLatitude(buf.readIntLE() * 0.0000001);\n                                    position.setLongitude(buf.readIntLE() * 0.0000001);\n                                    position.setValid(true); // Beacon location assumed valid\n                                    hasLocation = true;\n                                } else {\n                                    buf.readerIndex(endIndex); // Skip rest of malformed chunk\n                                    break; // Exit switch case for this chunk\n                                }\n                            }\n                            if (BitUtil.check(beaconFlags, 6)) { // Description included\n                                int remainingData = endIndex - buf.readerIndex();\n                                if (remainingData > 0 && buf.readableBytes() >= remainingData) {\n                                    position.set(\"description\", buf.readCharSequence(\n                                            remainingData, StandardCharsets.US_ASCII).toString());\n                                } // Else: description missing/malformed, index will be set below\n                            }\n                        }\n                        buf.readerIndex(endIndex); // Ensure reader index is advanced\n                        break;\n\n                    case 0x2A: // WiFi Location Result\n                         if (dataLength == 16) { // 1 flags + 6 mac + 1 rssi + 4 lat + 4 lon\n                            buf.readUnsignedByte(); // flags\n                            buf.skipBytes(6); // mac\n                            buf.readUnsignedByte(); // rssi\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true); // WiFi location assumed valid\n                            hasLocation = true;\n                         } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x30: // Steps\n                         if (dataLength == 8) { // 4 timestamp + 4 steps\n                            buf.readUnsignedIntLE(); // timestamp\n                            position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                         } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x31: // Activity\n                        // N * (4 time + 4 activity) Min dataLength = 0\n                         if (dataLength >= 0) {\n                             int i = 1;\n                             // Read activity data until the end of the chunk data\n                             while (buf.readerIndex() < endIndex && buf.readableBytes() >= 8) {\n                                 position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                                 position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                                 i += 1;\n                             }\n                         }\n                         buf.readerIndex(endIndex); // Ensure reader index is advanced\n                        break;\n\n                    case 0x37: // Barking\n                         if (dataLength == 8) { // 4 timestamp + 4 barking\n                            buf.readUnsignedIntLE(); // timestamp\n                            long barking = buf.readUnsignedIntLE();\n                            if (BitUtil.check(barking, 31)) {\n                                position.set(\"barkStop\", true);\n                            }\n                            position.set(\"barkCount\", BitUtil.to(barking, 31));\n                         } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    case 0x40: // Heart Rate\n                         if (dataLength == 5) { // 4 timestamp + 1 heartRate\n                            buf.readUnsignedIntLE(); // timestamp\n                            int heartRate = buf.readUnsignedByte();\n                            if (heartRate > 1) { // Filter potentially invalid values\n                                position.set(Position.KEY_HEART_RATE, heartRate);\n                            }\n                         } else { buf.readerIndex(endIndex); } // Skip malformed\n                        break;\n\n                    default:\n                        // Unknown key, skip the chunk data\n                        buf.skipBytes(dataLength);\n                        break;\n                }\n                // Verify index is at the end of chunk data; if not, force it to prevent infinite loops\n                if (buf.readerIndex() != endIndex) {\n                     buf.readerIndex(endIndex);\n                }\n\n            } // end while loop processing chunks\n\n            // Add the last position object being built, but only if it received some data\n            if (!keys.isEmpty()) {\n                if (!hasLocation) {\n                    // If the final record had data but no location, get last known location\n                    getLastLocation(position, null);\n                }\n                positions.add(position);\n            }\n\n            // If no positions were successfully decoded (e.g., all chunks were malformed or buffer empty after header), return null\n            if (positions.isEmpty()) {\n                return null;\n            }\n\n            // Assign device ID to all decoded positions if a device session was identified\n            if (deviceSession != null) {\n                final long deviceId = deviceSession.getDeviceId();\n                for (Position p : positions) {\n                    p.setDeviceId(deviceId);\n                }\n            }\n            // Return the list of positions. It might be non-empty but lack deviceId if 0x01 chunk wasn't present.\n            return positions;\n\n        } // end if type requires TLV processing\n\n        // If type was not MSG_RESPONSE and not DATA/SERVICES/USER\n        return null;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}