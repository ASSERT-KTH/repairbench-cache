{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.channel.Channel;\nimport io.netty.handler.codec.CorruptedFrameException;\nimport org.traccar.BaseProtocolDecoder;\nimport org.traccar.session.DeviceSession;\nimport org.traccar.Protocol;\nimport org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\nimport org.traccar.model.WifiAccessPoint;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n// Define necessary constants if they are not inherited or available globally\n// private static final int MSG_DATA = 0x10;\n// private static final int MSG_SERVICES = 0x18;\n\n// Assume the class extends BaseProtocolDecoder and necessary methods like\n// getProtocolName(), getLastLocation(), getDeviceSession(), sendResponse(),\n// decodeAlarm(), readTagId() are available.\n\n    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        // Ensure minimum header length before reading\n        if (buf.readableBytes() < 8) {\n            return null;\n        }\n\n        buf.readUnsignedByte(); // header (e.g., 0xAB)\n        int flags = buf.readUnsignedByte();\n        buf.readUnsignedShortLE(); // length\n        buf.readUnsignedShortLE(); // checksum\n        int index = buf.readUnsignedShortLE();\n        int type = buf.readUnsignedByte();\n\n        // Handle ACK response if requested by flag\n        if (BitUtil.check(flags, 4)) {\n            // Slice the remaining buffer content for the response if needed, without consuming it\n            sendResponse(channel, remoteAddress, index, type, buf.slice(buf.readerIndex(), buf.readableBytes()));\n        }\n\n        // Process only DATA or SERVICES message types\n        if (type == MSG_DATA || type == MSG_SERVICES) {\n\n            List<Position> positions = new LinkedList<>();\n            Set<Integer> keys = new HashSet<>();\n            boolean hasLocation = false;\n            Position position = new Position(getProtocolName());\n\n            DeviceSession deviceSession = null; // Populated if key 0x01 (IMEI) is found\n\n            while (buf.isReadable()) {\n                // Each data block starts with length (1 byte) and key (1 byte)\n                if (buf.readableBytes() < 2) {\n                    break; // Not enough data for length and key\n                }\n                int dataLength = buf.readUnsignedByte();\n                int endIndex = dataLength + buf.readerIndex();\n\n                // Validate data block length against buffer bounds\n                if (endIndex > buf.writerIndex()) {\n                    // Log potentially corrupt message or throw exception\n                     throw new CorruptedFrameException(\"Invalid data block length: \" + dataLength);\n                    // break; // Alternative: stop processing this message\n                }\n\n                int key = buf.readUnsignedByte();\n\n                // If a key repeats, it signifies the start of a new position report\n                if (keys.contains(key)) {\n                    if (!hasLocation) {\n                        // Attempt to fill missing location from last known position\n                        getLastLocation(position, position.getTime()); // Pass time if available\n                    }\n                    positions.add(position); // Add the completed position object\n                    keys.clear();            // Reset state for the new position\n                    hasLocation = false;\n                    position = new Position(getProtocolName()); // Create a new position object\n                }\n                keys.add(key); // Track keys seen for the current position\n\n                // Process data based on the key\n                // Use a try-finally block to ensure reader index is advanced correctly\n                try {\n                    switch (key) {\n                        case 0x01: // IMEI / Device ID\n                            // Check if buffer contains enough data for IMEI (15 bytes)\n                            if (buf.readerIndex() + 15 <= endIndex) {\n                                deviceSession = getDeviceSession(\n                                        channel, remoteAddress, buf.readCharSequence(15, StandardCharsets.US_ASCII).toString());\n                                // If device session cannot be identified, stop processing.\n                                if (deviceSession == null) {\n                                    return null;\n                                }\n                            } else {\n                                // Not enough data for IMEI, skip to end of block\n                                buf.readerIndex(endIndex);\n                                continue; // Go to next key-value block\n                            }\n                            break;\n                        case 0x02: // Alarm / Bark status\n                            if (buf.readerIndex() + 4 <= endIndex) {\n                                long alarm = buf.readUnsignedIntLE();\n                                position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                                if (BitUtil.check(alarm, 31)) {\n                                    position.set(\"bark\", true);\n                                }\n                            }\n                            break;\n                        case 0x14: // Battery info\n                            if (buf.readerIndex() + 3 <= endIndex) {\n                                position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                                position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                            }\n                            break;\n                        case 0x20: // Location data\n                            if (buf.readerIndex() + 21 <= endIndex) {\n                                hasLocation = true;\n                                position.setLatitude(buf.readIntLE() * 0.0000001);\n                                position.setLongitude(buf.readIntLE() * 0.0000001);\n                                position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                                position.setCourse(buf.readUnsignedShortLE());\n                                position.setAltitude(buf.readShortLE());\n                                int hdop = buf.readUnsignedShortLE();\n                                position.setValid(hdop > 0); // Assuming HDOP > 0 means valid fix\n                                position.set(Position.KEY_HDOP, hdop * 0.1);\n                                position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                                position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                            }\n                            break;\n                        case 0x21: // Cell Tower data\n                            if (buf.readerIndex() + 3 <= endIndex) { // Check for MCC + MNC\n                                int mcc = buf.readUnsignedShortLE();\n                                int mnc = buf.readUnsignedByte();\n                                if (position.getNetwork() == null) {\n                                    position.setNetwork(new Network());\n                                }\n                                // Read cell tower info: RSSI(1) + LAC(2) + CID(2) = 5 bytes each\n                                while (buf.readerIndex() + 5 <= endIndex) {\n                                    int rssi = buf.readByte();\n                                    position.getNetwork().addCellTower(CellTower.from(\n                                            mcc, mnc, buf.readUnsignedShortLE(), buf.readUnsignedShortLE(), rssi));\n                                }\n                            }\n                            break;\n                        case 0x22: // WiFi Access Point data\n                            if (position.getNetwork() == null) {\n                                position.setNetwork(new Network());\n                            }\n                            // Read WiFi AP info: RSSI(1) + MAC(6) = 7 bytes each\n                            while (buf.readerIndex() + 7 <= endIndex) {\n                                int rssi = buf.readByte();\n                                String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                        mac.substring(0, mac.length() - 1), rssi));\n                            }\n                            break;\n                        case 0x23: // Tag Location\n                             // Assuming readTagId reads 6 bytes. Total = tag(6) + lat(4) + lon(4) = 14 bytes\n                            if (buf.readerIndex() + 14 <= endIndex) {\n                                position.set(\"tagId\", readTagId(buf));\n                                position.setLatitude(buf.readIntLE() * 0.0000001);\n                                position.setLongitude(buf.readIntLE() * 0.0000001);\n                                position.setValid(true);\n                                hasLocation = true;\n                            }\n                            break;\n                        case 0x24: // Time and Status\n                            if (buf.readerIndex() + 8 <= endIndex) {\n                                position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                                long status = buf.readUnsignedIntLE();\n                                if (BitUtil.check(status, 4)) {\n                                    position.set(Position.KEY_CHARGE, true);\n                                }\n                                if (BitUtil.check(status, 7)) {\n                                    position.set(Position.KEY_ARCHIVE, true); // Indicates stored message\n                                }\n                                position.set(Position.KEY_MOTION, BitUtil.check(status, 9));\n                                position.set(Position.KEY_RSSI, BitUtil.between(status, 19, 24));\n                                position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                                position.set(Position.KEY_STATUS, status);\n                            }\n                            break;\n                        case 0x28: // Beacon data\n                            // Min length: flag(1) + tagId(6?) + rssi(1) + 1mRssi(1) = 9 bytes\n                            if (buf.readerIndex() + 1 <= endIndex) { // Check for flags byte\n                                int beaconFlags = buf.readUnsignedByte();\n                                // Assuming readTagId reads 6 bytes. Check for tagId + rssi + 1mRssi\n                                if (buf.readerIndex() + 8 <= endIndex) {\n                                    position.set(\"tagId\", readTagId(buf));\n                                    position.set(\"tagRssi\", (int) buf.readByte());\n                                    position.set(\"tag1mRssi\", (int) buf.readByte());\n                                    // Check if location data is present\n                                    if (BitUtil.check(beaconFlags, 7)) {\n                                        if (buf.readerIndex() + 8 <= endIndex) { // lat(4) + lon(4)\n                                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                                            position.setValid(true);\n                                            hasLocation = true;\n                                        }\n                                    }\n                                    // Check if description is present\n                                    if (BitUtil.check(beaconFlags, 6)) {\n                                        if (buf.readerIndex() < endIndex) { // Read remaining bytes as description\n                                            position.set(\"description\", buf.readCharSequence(\n                                                    endIndex - buf.readerIndex(), StandardCharsets.US_ASCII).toString());\n                                        }\n                                    }\n                                }\n                            }\n                            break;\n                        case 0x2A: // WiFi Location Assist\n                            // flags(1) + mac(6) + rssi(1) + lat(4) + lon(4) = 16 bytes\n                             if (buf.readerIndex() + 16 <= endIndex) {\n                                buf.readUnsignedByte(); // flags\n                                buf.skipBytes(6); // mac\n                                buf.readUnsignedByte(); // rssi\n                                position.setLatitude(buf.readIntLE() * 0.0000001);\n                                position.setLongitude(buf.readIntLE() * 0.0000001);\n                                position.setValid(true);\n                                hasLocation = true;\n                             }\n                            break;\n                        case 0x30: // Steps Count\n                            if (buf.readerIndex() + 8 <= endIndex) {\n                                buf.readUnsignedIntLE(); // timestamp (ignore)\n                                position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                            }\n                            break;\n                        case 0x31: // Activity Data\n                            int i = 1;\n                            // Read activity data: time(4) + activity(4) = 8 bytes each\n                            while (buf.readerIndex() + 8 <= endIndex) {\n                                position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                                position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                                i += 1;\n                            }\n                            break;\n                        case 0x37: // Barking Event\n                            if (buf.readerIndex() + 8 <= endIndex) {\n                                buf.readUnsignedIntLE(); // timestamp (ignore)\n                                long barking = buf.readUnsignedIntLE();\n                                if (BitUtil.check(barking, 31)) {\n                                    position.set(\"barkStop\", true);\n                                }\n                                position.set(\"barkCount\", BitUtil.to(barking, 31));\n                            }\n                            break;\n                        case 0x40: // Heart Rate\n                            if (buf.readerIndex() + 5 <= endIndex) {\n                                buf.readUnsignedIntLE(); // timestamp (ignore)\n                                int heartRate = buf.readUnsignedByte();\n                                if (heartRate > 1) { // Ignore potentially invalid values like 0 or 1\n                                    position.set(Position.KEY_HEART_RATE, heartRate);\n                                }\n                            }\n                            break;\n                        default:\n                            // Unknown key: data will be skipped by the finally block below\n                            break;\n                    }\n                } finally {\n                    // Ensure reader index is advanced to the end of the current data block.\n                    // This handles leftover data in loops (e.g., wifi/cell), partial reads due to insufficient bytes,\n                    // and skipping data for unknown keys.\n                    if (buf.readerIndex() < endIndex) {\n                        buf.readerIndex(endIndex);\n                    } else if (buf.readerIndex() > endIndex) {\n                        // This indicates a bug in the switch case logic (read past endIndex)\n                        // Log.warn(\"Reader index (\" + buf.readerIndex() + \") exceeded endIndex (\" + endIndex + \") for key \" + key);\n                         throw new CorruptedFrameException(\"Decoder read past data block boundary for key: \" + key);\n                    }\n                }\n            }\n\n            // Handle the last position object after the loop finishes\n            // Add it if it contains keys OR if no other positions were added yet (covers single-position messages)\n            if (!keys.isEmpty() || positions.isEmpty()) {\n                if (!hasLocation) {\n                   getLastLocation(position, position.getTime()); // Pass time if available\n                }\n                positions.add(position);\n            }\n\n            // If no positions were successfully parsed, return null\n            if (positions.isEmpty()) {\n                return null;\n            }\n\n            // If deviceSession was identified from the message (key 0x01), set the deviceId on all positions.\n            if (deviceSession != null) {\n                for (Position p : positions) {\n                    p.setDeviceId(deviceSession.getDeviceId());\n                }\n            }\n            // FIX: Removed the `else { return null; }` block.\n            // If deviceSession is null (key 0x01 was missing), we still return the parsed positions.\n            // The framework can associate the device ID later based on the channel session.\n\n            return positions; // Return the list of parsed positions\n        }\n\n        return null; // Message type was not MSG_DATA or MSG_SERVICES\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}