{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    @Override\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            // Loop until readLen is non-zero (either > 0 bytes read or -1 for EOF)\n            while (readLen == 0) {\n                if (!base64.hasData()) { // Check if Base64 codec's buffer needs more data\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf); // Read from underlying input stream\n                    // The setInitialBuffer optimization logic was removed as it's complex\n                    // and potentially incorrect within this loop structure.\n\n                    // Pass data read (or EOF indicator c=-1) to the Base64 codec\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                    // If the underlying stream reached EOF (c == -1) and the codec\n                    // has processed it, subsequent calls to base64.readResults\n                    // should eventually return -1 after flushing any remaining data.\n                }\n                // Attempt to fill the user buffer 'b' with data from the Base64 codec\n                readLen = base64.readResults(b, offset, len);\n                // If readLen == 0, the loop condition remains true, and we try again.\n                // This ensures this method does not return 0, fulfilling the requirement\n                // for interop with InputStreamReader and fixing CODEC-101.\n                // The loop terminates when readLen > 0 (bytes read) or readLen == -1 (EOF).\n            }\n            return readLen;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}