{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        // Combine boundary checks for clarity and efficiency\n        } else if (offset < 0 || len < 0 || len > b.length - offset) {\n            // Ensure the provided message is helpful for debugging\n            throw new IndexOutOfBoundsException(\"Trying to read \" + len + \" bytes into a byte array of size \" + b.length + \" at offset \" + offset);\n        } else if (len == 0) {\n            return 0;\n        } else {\n            byte[] buf = null; // Buffer used to read from underlying stream, initialize lazily\n            boolean eof = false; // Tracks if EOF was reached on the underlying stream 'in'\n            int readLen = 0; // Number of bytes read in the last call to base64.readResults\n\n            // Loop until we have read non-zero bytes or confirmed EOF.\n            // This loop implements the fix for CODEC-101, ensuring this method never returns 0\n            // unless len == 0, addressing issues with InputStreamReader and similar classes.\n            while (true) {\n                // Try to read results from the Base64 engine into the user buffer 'b'.\n                // This method may return >0 bytes, 0 bytes (if more input needed or skipping non-base64), or -1 (EOF).\n                readLen = base64.readResults(b, offset, len);\n\n                // If readResults returned non-zero, we return that value.\n                // This handles both successful reads (> 0) and EOF signaled by the codec (-1).\n                if (readLen != 0) {\n                    return readLen;\n                }\n\n                // If we reach here, readLen is 0. This means the Base64 engine couldn't produce\n                // output bytes with its current state. It might need more input data, or it might\n                // have processed input that resulted in no output (e.g., skipped whitespace).\n\n                // Check if we already know the underlying stream has ended.\n                if (eof) {\n                    // 'eof' is true means in.read() previously returned -1.\n                    // Since readResults just returned 0, it confirms that there's no more data\n                    // to be produced by the Base64 engine. Signal true EOF for this stream.\n                    return -1;\n                }\n\n                // readLen == 0 and the underlying stream is not yet known to be EOF.\n                // We need to try to fetch more data from 'in' if the Base64 engine's internal buffer is empty.\n                if (!base64.hasData()) {\n                    // Lazily initialize the buffer for reading from 'in'.\n                    // Size depends on whether we are encoding (smaller buffer) or decoding (larger buffer).\n                    if (buf == null) {\n                       buf = new byte[doEncode ? 4096 : 8192];\n                    }\n                    int c = in.read(buf); // Read from the underlying stream\n\n                    if (c == -1) {\n                        // End of the underlying stream reached.\n                        eof = true; // Mark that EOF has been reached.\n                        if (!doEncode) {\n                            // For decoding, we must explicitly signal EOF to the Base64 engine.\n                            // This allows it to process any final partial blocks or padding.\n                            // We pass -1 as the length to the decode method to signal EOF.\n                            base64.decode(buf, 0, -1);\n                            // The loop will continue. The next call to readResults will attempt\n                            // to fetch any final data produced by the decoder. If it returns 0,\n                            // the 'if (eof)' check above will catch it and return -1.\n                        }\n                        // For encoding, reaching EOF on the input stream is normal. We just mark eof=true.\n                        // The loop continues. The next call to readResults will fetch any remaining\n                        // encoded data buffered in the engine. If readResults returns 0 after this,\n                        // the 'if (eof)' check above will return -1.\n                    } else if (c > 0) {\n                        // Successfully read 'c' bytes from the underlying stream.\n                        // Pass this data to the Base64 engine for processing (encoding or decoding).\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                        // The loop continues. The next call to readResults will attempt\n                        // to fill the user buffer 'b' with the processed data.\n                    }\n                    // If c == 0, the underlying stream read 0 bytes. This is permitted by the\n                    // InputStream contract but unusual. We simply continue the loop,\n                    // which will effectively retry the read from 'in' if !base64.hasData().\n                } else {\n                    // base64.hasData() is true, but readResults returned 0.\n                    // This scenario means the Base64 engine has some data internally, but it wasn't\n                    // enough to produce output bytes (e.g., processed whitespace, needs more data for a\n                    // full quantum, or 'len' was too small). We must continue the loop.\n                    // Eventually, either readResults will return non-zero, or hasData will become false\n                    // (prompting a read from 'in'), or 'in' will hit EOF triggering the eof logic.\n                }\n                // Continue loop to call readResults again.\n            } // End while\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}