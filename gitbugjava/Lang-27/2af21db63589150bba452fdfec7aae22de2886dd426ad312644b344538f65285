{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport org.apache.commons.lang3.StringUtils; // Assuming StringUtils is available\n\n// NOTE: This code assumes the existence and correctness of the following helper methods within the same class:\n// - isDigits(String): Checks if a string contains only Unicode digits. Returns false for null/empty.\n// - isAllZeros(String): Checks if a string contains only '0'. Returns true for null/empty.\n// - createInteger(String): Creates an Integer, potentially throwing NumberFormatException. Handles hex.\n// - createLong(String): Creates a Long, potentially throwing NumberFormatException.\n// - createBigInteger(String): Creates a BigInteger, potentially throwing NumberFormatException.\n// - createFloat(String): Creates a Float, potentially throwing NumberFormatException.\n// - createDouble(String): Creates a Double, potentially throwing NumberFormatException.\n// - createBigDecimal(String): Creates a BigDecimal, potentially throwing NumberFormatException.\n\npublic class NumberUtils { // Renamed class for context, replace with actual class name if different\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * or exponent and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (ignoring case), it\n     * will be interpreted as a hexadecimal integer. Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        if (str.startsWith(\"--\")) {\n            // Leading -- apparently causes issues with BigDecimal parsing, see LANG-411\n            // Returning null for compatibility with the original code's intent, although throwing might be more consistent.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            // Validate hex digits after the prefix\n            int p = (str.startsWith(\"-\") ? 1 : 0) + 2;\n            if (p >= str.length()){\n                 throw new NumberFormatException(str + \" is not a valid number.\"); // e.g., \"0x\" or \"-0X\"\n            }\n            for(int i = p; i < str.length(); i++){\n               final char ch = str.charAt(i);\n               // Check for valid hex characters\n               if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f') && (ch < 'A' || ch > 'F')){\n                    throw new NumberFormatException(str + \" is not a valid number.\"); // Invalid hex char\n               }\n            }\n            // Assuming createInteger correctly handles hex syntax and range (possibly returning BigInteger)\n            try {\n                 return createInteger(str);\n            } catch (final NumberFormatException nfe) {\n                // Rethrow if createInteger fails, indicating an issue it couldn't handle (e.g., range if no BigInteger support)\n                 throw new NumberFormatException(str + \" is not a valid number. \" + nfe.getMessage());\n            }\n        }\n\n        final char lastChar = str.charAt(str.length() - 1);\n        String numeric; // The part of the string excluding the final qualifier character, if any\n\n        final int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e'); // Find first 'e' or 'E'\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        // Check for invalid trailing exponent indicator (e.g., \"123e\")\n        if (expPos > -1 && expPos == str.length() - 1) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        // Handle Type Qualifiers (L, F, D)\n        if (lastChar == 'l' || lastChar == 'L') {\n            // Qualifier must be the last char, and cannot follow an exponent marker directly (e.g., \"1eL\")\n            // It also must not have a decimal point.\n            if (decPos == -1 && expPos == -1) {\n                // Check if the character before 'L' is 'e' or 'E' - this check seems redundant due to expPos == -1\n                //numeric = str.substring(0, str.length() - 1);\n                 numeric = str.substring(0, str.length() - 1);\n                 // Validate content: should be digits only, optional leading sign\n                 if ( (numeric.startsWith(\"-\") || numeric.startsWith(\"+\")) && numeric.length() == 1 ){\n                      throw new NumberFormatException(str + \" is not a valid number.\"); // Only a sign\n                 }\n                 // Use isDigits helper (assumed to exist)\n                 if ( (numeric.startsWith(\"-\") && !isDigits(numeric.substring(1)) ) ||\n                      (numeric.startsWith(\"+\") && !isDigits(numeric.substring(1)) ) ||\n                      (!numeric.startsWith(\"-\") && !numeric.startsWith(\"+\") && !isDigits(numeric)) ) {\n                      throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                try {\n                    // Assumes createLong handles numeric correctly\n                    return createLong(numeric);\n                } catch (final NumberFormatException nfe) {\n                    // Fallback to BigInteger if Long range exceeded\n                    // Assumes createBigInteger handles numeric correctly\n                    return createBigInteger(numeric);\n                }\n            }\n            // Invalid format for Long (e.g., has '.', 'e', or 'E', or invalid sequence like \"1eL\")\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        if (lastChar == 'f' || lastChar == 'F' || lastChar == 'd' || lastChar == 'D') {\n            // Qualifier must be the last char, cannot follow exponent marker directly (e.g., \"1eF\")\n            if (expPos != -1 && expPos == str.length() - 2) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            numeric = str.substring(0, str.length() - 1);\n\n            // Helper check: is the numeric part mathematically zero? (Handles \"0\", \"0.0\", \"0e0\", etc.)\n            final boolean allZeros = isNumericZero(numeric);\n\n            if (lastChar == 'f' || lastChar == 'F') {\n                try {\n                    final Float f = createFloat(numeric);\n                    // Check precision / range. isInfinite or 0.0F when !allZeros indicate issues.\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                    // Otherwise, Float lacks precision or range, fall through to Double/BigDecimal\n                } catch (final NumberFormatException nfe) {\n                    // Format error in 'numeric'? Fall through might hide it.\n                    // Maintain original fall-through behavior.\n                }\n            }\n\n            // Handle 'd'/'D' and fall-through from 'f'/'F'\n            try {\n                final Double d = createDouble(numeric);\n                // Check precision / range. isInfinite or 0.0D when !allZeros indicate issues.\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n                // Otherwise, Double lacks precision or range, fall through to BigDecimal\n            } catch (final NumberFormatException nfe) {\n                // Format error in 'numeric'? Fall through might hide it.\n            }\n\n            // Final fallback for F/f/D/d is BigDecimal\n            try {\n                return createBigDecimal(numeric);\n            } catch (final NumberFormatException e) {\n                // If BigDecimal also fails, the numeric part itself is invalid.\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n        // No valid F/f/D/d/L/l qualifier found. Auto-detect type from 'str'.\n        // Check for invalid trailing letters (already checked for e/E ending and type qualifiers)\n        // Allow trailing '.' (LANG-521)\n        if (Character.isLetter(lastChar)) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        // Auto-detect: Integer types if no '.', no 'e'/'E', and doesn't end with '.'\n        if (decPos == -1 && expPos == -1) {\n             if (lastChar == '.') { // Handle \"123.\" as float type (LANG-521)\n                // Fall through to float type logic below\n             } else {\n                 // Try Integer -> Long -> BigInteger\n                 try {\n                     return createInteger(str);\n                 } catch (final NumberFormatException nfe) { /* ignore */ }\n                 try {\n                     return createLong(str);\n                 } catch (final NumberFormatException nfe) { /* ignore */ }\n                 // Final fallback for integer-like strings\n                 return createBigInteger(str);\n             }\n        }\n\n        // Auto-detect: Float types if has '.', has 'e'/'E', or ends with '.'\n        final boolean allZeros = isNumericZero(str);\n        try {\n            final Float f = createFloat(str);\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                return f;\n            }\n        } catch (final NumberFormatException nfe) { /* ignore */ }\n        try {\n            final Double d = createDouble(str);\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                return d;\n            }\n        } catch (final NumberFormatException nfe) { /* ignore */ }\n\n        // Final fallback for float-like strings\n        return createBigDecimal(str);\n    }\n\n    /**\n     * Helper method to check if the string numerically represents zero.\n     * Handles optional sign, decimal point, and exponent.\n     * Assumes {@code isAllZeros(String)} helper exists.\n     * @param str The string to check.\n     * @return {@code true} if the string numerically represents zero.\n     */\n    private static boolean isNumericZero(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return true; // Consistent with isAllZeros(null/empty)\n        }\n        // Find exponent marker\n        int realExpPos = str.indexOf('e');\n        if (realExpPos == -1) {\n            realExpPos = str.indexOf('E');\n        }\n        // Consider only the significand part (before exponent)\n        String significand = str;\n        if (realExpPos != -1) {\n            significand = str.substring(0, realExpPos);\n        }\n        // Remove leading sign\n        if (significand.startsWith(\"-\") || significand.startsWith(\"+\")) {\n            significand = significand.substring(1);\n        }\n        // Check if all characters in the significand are '0' or '.'\n        for (int i = 0; i < significand.length(); i++) {\n            final char c = significand.charAt(i);\n            if (c != '0' && c != '.') {\n                return false; // Found a non-zero digit\n            }\n        }\n        // At this point, all digits are '0' or '.', need to ensure there's at least one '0' if not empty\n        // An empty significand (e.g. from \"+e1\") should perhaps be invalid number, caught elsewhere.\n        // A significand of just \".\" is invalid number, caught by createXXX methods.\n        // A significand of \"0\", \"0.\", \".0\", \"0.0\" etc. are all numerically zero.\n        // Our loop correctly identifies these cases as returning true.\n        return true;\n    }\n\n    // Dummy implementations of required helpers (replace with actual implementations)\n    private static boolean isDigits(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Assume createXXX methods exist and correctly parse or throw NumberFormatException.\n    // Example stubs:\n    private static Integer createInteger(final String str) throws NumberFormatException { return Integer.decode(str); }\n    private static Long createLong(final String str) throws NumberFormatException { return Long.valueOf(str); }\n    private static BigInteger createBigInteger(final String str) throws NumberFormatException { return new BigInteger(str); }\n    private static Float createFloat(final String str) throws NumberFormatException { return Float.valueOf(str); }\n    private static Double createDouble(final String str) throws NumberFormatException { return Double.valueOf(str); }\n    private static BigDecimal createBigDecimal(final String str) throws NumberFormatException { return new BigDecimal(str); }\n    private static boolean isAllZeros(String str) { return StringUtils.isEmpty(str) || str.matches(\"^[0]+$\"); } // Simplified example\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}