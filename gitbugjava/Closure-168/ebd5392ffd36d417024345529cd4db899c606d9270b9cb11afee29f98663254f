{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Skip global scope\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      // Record non-empty returns for the function\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // Skip analysis for scopes too close to global\n      // (Assumes analysis is about inner functions accessing outer vars)\n      // This pass focuses on locals accessed potentially outside their definition scope.\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned OR READ in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      Scope scope = t.getScope();\n\n      // Case 1: Simple Name (e.g., x)\n      if (n.isName() && !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          // Record assignment if it's a local var and an LValue\n          if (ownerScope.isLocal() && NodeUtil.isLValue(n)) {\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n\n          // Record escape if it's a local var accessed from an inner scope\n          // This should happen for both reads and writes (LValues and RValues)\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n        }\n      }\n      // Case 2: Qualified Name (e.g., a.b)\n      else if (n.isGetProp() && n.isUnscopedQualifiedName()) {\n        Node root = NodeUtil.getRootOfQualifiedName(n);\n        // Only interested if the base of the qualified name is a simple variable name\n        if (root.isName()) {\n          String name = root.getString();\n          Var var = scope.getVar(name);\n          if (var != null) {\n            Scope ownerScope = var.getScope();\n            // Check if the root variable is local and accessed from an inner scope\n            if (scope != ownerScope && ownerScope.isLocal()) {\n              // Record the root variable as escaped (handles reads like 'obj.prop')\n              data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n\n              // If it's an LValue assignment, also record the qualified name (original behavior)\n              if (NodeUtil.isLValue(n)) {\n                 data.get(ownerScope.getRootNode())\n                   .recordEscapedQualifiedName(n.getQualifiedName());\n              }\n            }\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}