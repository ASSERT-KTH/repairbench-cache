{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Only skip global scope.\n      if (t.inGlobalScope()) { // t.getScopeDepth() == 1\n        return;\n      }\n\n      // Process return statements regardless of depth.\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // Analyze local scopes (depth >= 2)\n      Scope scope = t.getScope();\n      Var var = null;\n      Scope ownerScope = null;\n      String varName = null; // Base variable name if qualified\n      boolean isBasedOnLocalVar = false; // Is the node related to a local variable?\n\n      // Determine if n represents a local variable or property access thereof\n      if (n.isName()) {\n        varName = n.getString();\n        var = scope.getVar(varName);\n        if (var != null) {\n          ownerScope = var.getScope();\n          // Ensure we are dealing with a variable declared in a local scope.\n          // We treat global variables as always escaped by default.\n          isBasedOnLocalVar = ownerScope.isLocal();\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName()) {\n        Node root = NodeUtil.getRootOfQualifiedName(n);\n        // Check if the base of the qualified name is a simple name\n        if (root.isName()) {\n          varName = root.getString();\n          var = scope.getVar(varName);\n          if (var != null) {\n            ownerScope = var.getScope();\n            // Ensure the base variable is declared in a local scope.\n            isBasedOnLocalVar = ownerScope.isLocal();\n          }\n        }\n      }\n\n      // If it's related to a variable declared in a local scope\n      if (isBasedOnLocalVar) {\n          Node ownerRoot = ownerScope.getRootNode();\n\n          // Record assignment if it's an LValue NAME node\n          // Be careful of bleeding functions (like function declarations) which create\n          // variables in the *inner* scope, not the scope where the name appears.\n          if (n.isName() && NodeUtil.isLValue(n) &&\n              !NodeUtil.isBleedingFunctionName(n)) {\n            // Record that this specific name was assigned in its owner scope's function.\n             data.get(ownerRoot).recordAssignedName(n.getString());\n          }\n\n          // Record escape if accessed (read or write) in a different scope than declared\n          if (scope != ownerScope) {\n            // This variable is used in a scope different from its declaration scope,\n            // hence it has escaped its declaring scope.\n            if (n.isName()) {\n               // Record the simple name variable as escaped.\n               data.get(ownerRoot).recordEscapedVarName(n.getString());\n            } else { // Must be the GETPROP case checked above\n               // Record the full qualified name as escaped.\n               data.get(ownerRoot).recordEscapedQualifiedName(n.getQualifiedName());\n            }\n          }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}