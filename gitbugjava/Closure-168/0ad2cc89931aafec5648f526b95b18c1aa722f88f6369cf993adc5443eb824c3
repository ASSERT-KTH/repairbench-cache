{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Skip global scope - variables there are treated as escaped by default.\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      // Record non-empty returns for the function being analyzed.\n      Node scopeRoot = t.getScopeRoot();\n      // Ensure we are inside a function scope before recording return info.\n      // Data map is keyed by function root node.\n      if (scopeRoot != null && scopeRoot.isFunction()) {\n          if (n.isReturn() && n.getFirstChild() != null) {\n            // Get or create FunctionData for the current function scope.\n            // Using computeIfAbsent ensures the entry exists.\n            data.computeIfAbsent(scopeRoot, k -> new FunctionData()).recordNonEmptyReturn();\n          }\n      }\n\n      // Original check skipped analysis in top-level function scopes (depth 1 & 2).\n      // This prevented analysis of assignments like 'var self = this' and\n      // detection of escapes originating from these scopes (like 'self' used\n      // in an inner function). Removing the check allows this analysis.\n      // if (t.getScopeDepth() <= 2) {\n      //  return;\n      // }\n\n      if (n.isName()) {\n        // Skip bleeding function names; they declare vars in the inner scope\n        // where the function definition occurs, not where the name appears.\n        if (NodeUtil.isBleedingFunctionName(n)) {\n           return;\n        }\n\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n\n        // Process only if var exists and is function-local (not global or extern).\n        if (var != null && var.getScope().isLocal()) {\n          Scope ownerScope = var.getScope();\n          Node ownerRoot = ownerScope.getRootNode(); // Root node of the function where 'var' is defined\n          // Get or create FunctionData for the function where the var is defined.\n          FunctionData functionData = data.computeIfAbsent(ownerRoot, k -> new FunctionData());\n\n          // Record assignment if the name is being assigned to (LHS).\n          if (NodeUtil.isLValue(n)) {\n            functionData.recordAssignedName(name);\n          }\n\n          // Record escape if the variable is accessed (read or write via NAME)\n          // in a scope different from (and typically nested within) its defining scope.\n          // This correctly flags captured variables like 'self' in the test case.\n          if (scope != ownerScope) {\n            functionData.recordEscapedVarName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n        // Handles assignment to potentially escaped qualified names like 'localVar.prop = ...'.\n        // We only care about cases where the root variable is local.\n        String rootName = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(rootName);\n\n        // Process only if the root var exists and is function-local.\n        if (var != null && var.getScope().isLocal()) {\n          Scope ownerScope = var.getScope();\n          // Record escape only if the assignment occurs in a scope different from\n          // (and typically nested within) the defining scope of the root variable.\n          if (scope != ownerScope) {\n             Node ownerRoot = ownerScope.getRootNode(); // Root node of the function where 'var' (rootName) is defined\n             FunctionData functionData = data.computeIfAbsent(ownerRoot, k -> new FunctionData());\n             functionData.recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}