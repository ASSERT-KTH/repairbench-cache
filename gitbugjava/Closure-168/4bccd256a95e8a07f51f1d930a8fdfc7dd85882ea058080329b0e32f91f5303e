{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Avoid infinite recursion.\n      if (n == data.get(t.getScopeRoot()).root) {\n         return;\n      }\n\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // TODO(johnlenz): Make the scope depth check meaningful or remove it.\n      // It is possible that this check is problematic as the Function node\n      // is FUNCTION, NAME, LP, PARAM_LIST, BLOCK. The scope depth will\n      // be deeper if the function is nested. Removing the check entirely\n      // doesn't seem to change anything.\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are referenced in inner scopes (\"escaped\n        //    vars\"), whether that reference is a read or a write.\n        //\n        // 2) Local variables that are assigned more than once.\n        //    (This is handled by the assignedNames data structure).\n        //\n        // We treat all global variables as escaped by default.\n        return;\n      }\n\n\n      if (n.isName()) {\n        // Be careful of bleeding functions, which create variables\n        // in the inner scope, not the scope where the name appears.\n        if (NodeUtil.isBleedingFunctionName(n)) {\n          return;\n        }\n\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          if (ownerScope.isLocal()) {\n            Node ownerRoot = ownerScope.getRootNode();\n            // Record reads/writes from inner scopes -> escaped\n            if (scope != ownerScope) {\n              data.get(ownerRoot).recordEscapedVarName(name);\n            }\n            // Record writes -> assigned\n            if (NodeUtil.isLValue(n)) {\n              data.get(ownerRoot).recordAssignedName(name);\n            }\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          // Record writes from inner scopes -> escaped\n          // Note: qualified names can only be escaped via writes.\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}