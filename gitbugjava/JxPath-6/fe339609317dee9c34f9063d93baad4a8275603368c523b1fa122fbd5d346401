{
    "generation": "    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        // Determine if left is iterator-like\n        Iterator li = null;\n        boolean lIsIterator = false;\n        // Check for Iterator first, as compute() might return it directly\n        if (l instanceof Iterator) {\n            li = (Iterator) l;\n            lIsIterator = true;\n        } else if (l instanceof Collection) { // Then check for Collection\n            li = ((Collection) l).iterator();\n            lIsIterator = true;\n        }\n        // Note: This logic assumes that if a NodePointer represents a collection,\n        // compute() returns an Iterator over the corresponding nodes/pointers.\n\n        // Determine if right is iterator-like\n        Iterator ri = null;\n        boolean rIsIterator = false;\n        // Check for Iterator first\n        if (r instanceof Iterator) {\n            ri = (Iterator) r;\n            rIsIterator = true;\n        } else if (r instanceof Collection) { // Then check for Collection\n            ri = ((Collection) r).iterator();\n            rIsIterator = true;\n        }\n\n        // Apply XPath comparison logic based on iterator presence\n        if (lIsIterator && !rIsIterator) {\n            // Compare elements of iterator li with scalar r\n            return contains(li, r);\n        }\n        if (!lIsIterator && rIsIterator) {\n            // Compare elements of iterator ri with scalar l\n            return contains(ri, l);\n        }\n        if (lIsIterator && rIsIterator) {\n            // Check for any match between elements of li and ri\n            return findMatch(li, ri);\n        }\n\n        // Fallback: Neither side is directly an iterator or collection.\n        // Delegate to the base equality comparison method, which must handle\n        // potential NodePointers and apply XPath scalar comparison rules (type conversions etc.).\n        return equal(l, r); // Assumes this calls a base equal(Object, Object) method\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}