{
    "generation": "import java.util.Collection;\nimport java.util.Iterator;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\n\n// Assuming the class extends CoreOperationCompare or similar base class\n// with access to contains(Iterator, Object), findMatch(Iterator, Iterator)\n// and a static equal(Object, Object) helper.\n\n    /**\n     * Compares two values according to XPath '=' rules.\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        // Compute the values of the left and right expressions\n        Object l = left.computeValue(context);\n        Object r = right.computeValue(context);\n\n        // Unwrap EvalContext to NodePointer if necessary\n        // This handles cases where an expression yields the context itself (e.g., '.')\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        // Extract the underlying value if l or r is a NodePointer\n        // This is necessary because NodePointers can wrap collections/iterators\n        Object lValue = l;\n        if (l instanceof NodePointer) {\n             // Use getValue() to access the object represented by the pointer\n             lValue = ((NodePointer) l).getValue();\n        }\n\n        Object rValue = r;\n        if (r instanceof NodePointer) {\n            rValue = ((NodePointer) r).getValue();\n        }\n\n        // Check if the underlying values are collections or iterators and get iterators\n        Iterator lIter = null;\n        if (lValue instanceof Collection) {\n            lIter = ((Collection) lValue).iterator();\n        }\n        else if (lValue instanceof Iterator) {\n            // Handle cases where computeValue directly returns an Iterator\n            lIter = (Iterator) lValue;\n        }\n\n        Iterator rIter = null;\n        if (rValue instanceof Collection) {\n            rIter = ((Collection) rValue).iterator();\n        }\n        else if (rValue instanceof Iterator) {\n            rIter = (Iterator) rValue;\n        }\n\n        // Perform comparison based on XPath rules for sequences (represented by iterators)\n        // Rule: iterator = non-iterator -> true if exists item in iterator such that item = non-iterator\n        if (lIter != null && rIter == null) {\n            // Pass the iterator and the potentially wrapped value from the right side.\n            // contains should compare each element from lIter with rValue using the base equality rules.\n            return contains(lIter, rValue);\n        }\n        // Rule: non-iterator = iterator -> true if exists item in iterator such that non-iterator = item\n        if (lIter == null && rIter != null) {\n            // Pass the iterator and the potentially wrapped value from the left side.\n             return contains(rIter, lValue);\n        }\n        // Rule: iterator = iterator -> true if exists item1 in iterator1 and item2 in iterator2 such that item1 = item2\n        if (lIter != null && rIter != null) {\n            return findMatch(lIter, rIter);\n        }\n\n        // Fallback: Neither underlying value (lValue, rValue) is a Collection or Iterator.\n        // Call the static equal helper with the original computed objects (l, r).\n        // These original objects (l, r) could still be NodePointers wrapping primitive values,\n        // or just the primitive values themselves. The static helper is responsible\n        // for handling NodePointer unwrapping ONLY for non-iterable value comparisons.\n        return equal(l, r);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}