{
    "generation": "  @Override\n  public JSType getLeastSupertype(JSType that) {\n    // If 'that' isn't a RecordType, fall back to the general ObjectType/JSType logic.\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n\n    RecordType thatRecord = that.toMaybeRecordType();\n\n    // The least supertype is only guaranteed to be a RecordType if both 'this'\n    // and 'thatRecord' have the exact same set of defined property names.\n    // Note: This assumes structural typing where extra properties don't prevent\n    // LUB from being a record if the common core properties match exactly by name.\n    // However, standard LUB for records often results in a Union unless one is\n    // a subtype of the other OR they have identical property sets.\n    if (this.properties.keySet().equals(thatRecord.properties.keySet())) {\n      RecordTypeBuilder builder = new RecordTypeBuilder(this.registry);\n\n      for (String property : this.properties.keySet()) {\n        // Property must exist in thatRecord due to the keySet equality check.\n        JSType thisPropType = this.getPropertyType(property);\n        JSType thatPropType = thatRecord.getPropertyType(property);\n\n        // Calculate the LUB of the individual property types.\n        JSType lubPropType = thisPropType.getLeastSupertype(thatPropType);\n\n        // Add the property with the computed LUB type to the builder.\n        // Use the property node from 'this' as a representative node.\n        builder.addProperty(property, lubPropType, this.getPropertyNode(property));\n      }\n       // If we successfully processed all properties with identical names,\n       // build and return the resulting record type.\n      return builder.build();\n\n    } else {\n      // If the property sets differ, the least supertype cannot generally be represented\n      // by a single record type that precisely captures both structures (unless one\n      // is a subtype of the other, which should be handled by the caller or superclass).\n      // Fall back to the general LUB mechanism (likely creating a UnionType or handled\n      // by ObjectType's LUB logic).\n      return super.getLeastSupertype(that);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}