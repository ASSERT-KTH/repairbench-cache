{
    "generation": "import org.traccar.helper.Log;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.Position;\nimport org.traccar.model.DeviceSession;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport org.traccar.helper.BitUtil;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\n\nimport java.nio.charset.StandardCharsets;\n// Assuming other necessary imports exist (e.g., TimeZone, readDate, decodeAlarm, decodeCoordinates, decodeExtension, decodeCustomDouble)\n\n    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf); // Assume reads status, lat, lon\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        // Assuming readDate method is available and correctly implemented\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        // This block seems potentially problematic (checks 20 bytes, reads 18) but might be for a specific message variant.\n        // Keep it as is unless proven incorrect by other tests.\n        if (buf.readableBytes() == 20) {\n            buf.skipBytes(4); // remaining battery and mileage\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n            buf.readUnsignedInt(); // area id\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            buf.skipBytes(3); // reserved\n            return position;\n        }\n\n        // Process TLV (Type-Length-Value) data\n        while (buf.readableBytes() > 2) { // Need at least 3 bytes for subtype, length, and some value\n\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n            int endIndex;\n\n            // --- FIX START ---\n            // Special handling for subtype 0x07 due to observed invalid length byte (0x44) in test data,\n            // which caused incorrect skipping of subsequent TLVs.\n            if (subtype == 0x07) {\n                // Assume fixed payload length of 6 bytes based on analysis of the problematic test data structure.\n                // The original 'length' byte (0x44) is ignored for this subtype.\n                int actualLength = 6;\n                if (buf.readableBytes() >= actualLength) {\n                    endIndex = buf.readerIndex() + actualLength;\n                    // Data for 0x07 is currently ignored as its meaning and structure are unclear.\n                    // The goal here is to correctly position the reader for the next TLV item.\n                } else {\n                    // Not enough bytes for the assumed fixed length. Log and stop TLV parsing.\n                    Log.warning(\"Huabao: Invalid data for subtype 0x07: requires \" + actualLength\n                            + \" bytes payload, only \" + buf.readableBytes() + \" available. Stopping TLV parsing.\");\n                    break; // Prevent further processing with potentially corrupt data\n                }\n            } else {\n                // Standard TLV processing: Validate length against remaining bytes.\n                if (buf.readableBytes() < length) {\n                    // Log and stop TLV parsing if the specified length exceeds available bytes.\n                    Log.warning(\"Huabao: Invalid TLV length: \" + length + \" > remaining \" + buf.readableBytes()\n                            + \" for subtype 0x\" + String.format(\"%02X\", subtype) + \". Stopping TLV parsing.\");\n                    break; // Prevent IndexOutOfBoundsException or incorrect reading\n                }\n                endIndex = buf.readerIndex() + length;\n            }\n            // --- FIX END ---\n\n            // Process known subtypes based on the calculated endIndex\n            String stringValue;\n            switch (subtype) {\n                case 0x01:\n                    if (length == 4 && buf.readerIndex() <= endIndex - 4) { // Check length and bounds\n                       position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    }\n                    break;\n                case 0x02:\n                     if (length == 2 && buf.readerIndex() <= endIndex - 2) { // Check length and bounds\n                        position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1);\n                     }\n                    break;\n                case 0x07:\n                    // Handled above (endIndex calculated for skipping). Data is ignored.\n                    break;\n                case 0x2b:\n                     if (length == 4 && buf.readerIndex() <= endIndex - 4) { // Check length and bounds\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt());\n                     }\n                    break;\n                case 0x30:\n                     if (length == 1 && buf.readerIndex() <= endIndex - 1) { // Check length and bounds\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                     }\n                    break;\n                case 0x31:\n                     if (length == 1 && buf.readerIndex() <= endIndex - 1) { // Check length and bounds\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                     }\n                    break;\n                case 0x33:\n                     // Basic check for \"*M00...\" structure length and indices safety needed\n                     if (length >= 15 && buf.readerIndex() <= endIndex - length) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        if (stringValue.startsWith(\"*M00\") && stringValue.length() >= 15) {\n                            try {\n                                String lockStatus = stringValue.substring(8, 15); // 7 characters\n                                position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                            } catch (NumberFormatException | IndexOutOfBoundsException e) {\n                                Log.warning(\"Huabao: Failed to parse battery from subtype 0x33 string: \" + stringValue, e);\n                            }\n                        }\n                     }\n                    break;\n                case 0x80:\n                     // Special logic for 0x80 requires careful handling of endIndex and length\n                     if (length >= 1 && buf.readerIndex() <= endIndex - 1) { // Need at least 1 byte for content\n                         buf.readUnsignedByte(); // content byte\n                         // The original code adjusted endIndex here based on writerIndex, keep this specific logic.\n                         endIndex = buf.writerIndex() - 2; // Recalculate endIndex based on buffer end\n                         if (buf.readerIndex() <= endIndex) { // Check if still readable after index adjustment\n                            decodeExtension(position, buf, endIndex); // decodeExtension needs to respect this endIndex\n                         }\n                     }\n                    break;\n                case 0x91:\n                    if (length == 24 && buf.readerIndex() <= endIndex - 24) { // Check expected length and bounds\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n                        position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                        position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte());\n                        position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255);\n                        position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255);\n                        position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40);\n                        buf.readUnsignedShort(); // skip 2\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01);\n                        buf.readUnsignedShort(); // skip 2\n                        buf.readUnsignedInt(); // skip 4\n                        buf.readUnsignedShort(); // skip 2\n                        position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01); // read 2\n                    }\n                    break;\n                case 0x94: // VIN\n                    if (length > 0 && buf.readerIndex() <= endIndex - length) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                case 0xA7: // ADC\n                     if (length == 4 && buf.readerIndex() <= endIndex - 4) { // Check length and bounds\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                        position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                     }\n                    break;\n                case 0xAC: // Odometer\n                     if (length == 4 && buf.readerIndex() <= endIndex - 4) { // Check length and bounds\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                     }\n                    break;\n                case 0xBC: // Driver Name\n                     if (length > 0 && buf.readerIndex() <= endIndex - length) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(\"driver\", stringValue.trim());\n                     }\n                    break;\n                case 0xBD: // Driver ID\n                     if (length > 0 && buf.readerIndex() <= endIndex - length) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                     }\n                    break;\n                case 0xD0: // User Status / Vibration Alarm\n                     if (length == 4 && buf.readerIndex() <= endIndex - 4) { // Check length and bounds\n                        long userStatus = buf.readUnsignedInt();\n                        if (BitUtil.check(userStatus, 3)) {\n                            position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                        }\n                     }\n                    break;\n                case 0xD3: // Power\n                     if (length == 2 && buf.readerIndex() <= endIndex - 2) { // Check length and bounds\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                     }\n                    break;\n                case 0xD4: // Battery Level (%)\n                     if (length == 1 && buf.readerIndex() <= endIndex - 1) { // Check length and bounds\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                     }\n                    break;\n                case 0xD5: // Lock Status / Battery Voltage\n                    if (length == 2 && buf.readerIndex() <= endIndex - 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 1 && buf.readerIndex() <= endIndex - 1) { // Need at least count byte\n                         int count = buf.readUnsignedByte();\n                         int expectedPayloadLength = count * (5 + 5 + 1 + 2); // id(5)+card(5)+batt(1)+status(2) = 13 bytes per lock\n                         if (length == 1 + expectedPayloadLength && buf.readerIndex() <= endIndex - expectedPayloadLength) { // Check total length and bounds\n                             for (int i = 1; i <= count; i++) {\n                                 position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                 position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                 position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                                 int status = buf.readUnsignedShort();\n                                 position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                             }\n                         } else {\n                              Log.warning(\"Huabao: Mismatched length \" + length + \" or bounds for subtype 0xD5 with count \" + count);\n                         }\n                    }\n                    break;\n                case 0xDA: // String Sensor / Motion / Cover\n                     if (length >= 3 && buf.readerIndex() <= endIndex - 3) { // Need count(2)+status(1)\n                       buf.readUnsignedShort(); // string cut count (ignored)\n                       int deviceStatus = buf.readUnsignedByte();\n                       position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                       position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                       position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                     }\n                    break;\n                case 0xE6: // Temperature/Humidity Sensors\n                    while (buf.readerIndex() < endIndex) {\n                         int requiredSensorBytes = 1 + 6 + 8 + 8; // index(1)+mac(6)+temp(8)+hum(8)\n                         if (buf.readerIndex() > endIndex - requiredSensorBytes) { break; } // Check bounds before reading sensor data\n                        int sensorIndex = buf.readUnsignedByte();\n                        buf.skipBytes(6); // mac\n                        // Assume decodeCustomDouble reads 8 bytes and handles potential exceptions\n                        position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(buf));\n                        position.set(\"humidity\" + sensorIndex, decodeCustomDouble(buf));\n                    }\n                    break;\n                case 0xEB: // Network Info or Extended Data\n                    // Keep original complex logic, ensure inner loops check against endIndex\n                    int startIndexEb = buf.readerIndex();\n                    if (buf.readableBytes() >= 2 && buf.getUnsignedShort(startIndexEb) > 200) { // Network Info\n                        if (buf.readableBytes() >= 3 && buf.readerIndex() <= endIndex - 3) { // Check MCC/MNC size & bounds\n                            Network network = new Network();\n                            int mcc = buf.readUnsignedShort();\n                            int mnc = buf.readUnsignedByte();\n                            while (buf.readerIndex() < endIndex) {\n                                if (buf.readerIndex() > endIndex - 5) { break; } // Check cell tower size & bounds\n                                network.addCellTower(CellTower.from(\n                                        mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(), buf.readUnsignedByte()));\n                            }\n                            if (!network.getCellTowers().isEmpty()) {\n                                position.setNetwork(network);\n                            }\n                        }\n                    } else { // Extended Data\n                        while (buf.readerIndex() < endIndex) {\n                            if (buf.readerIndex() > endIndex - 4) { break; } // Check extended item header size & bounds\n                            int extendedLength = buf.readUnsignedShort(); // Includes type field length (2)\n                            int extendedType = buf.readUnsignedShort();\n                            int dataLength = extendedLength - 2;\n                            if (dataLength < 0 || buf.readerIndex() > endIndex - dataLength) { break; } // Check data size & bounds\n                            int itemEndIndex = buf.readerIndex() + dataLength;\n\n                            switch (extendedType) {\n                                case 0x0001: if (dataLength == 3) { position.set(\"fuel1\", buf.readUnsignedShort() * 0.1); buf.readUnsignedByte(); } break;\n                                case 0x0023: if (dataLength == 6) { try { position.set(\"fuel2\", Double.parseDouble(buf.readCharSequence(6, StandardCharsets.US_ASCII).toString())); } catch (NumberFormatException e) { Log.warning(\"Huabao: Invalid fuel2 format\", e); } } break;\n                                case 0x00CE: if (dataLength == 2) { position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01); } break;\n                                case 0x00D8: if (dataLength == 9) { Network network = new Network(); network.addCellTower(CellTower.from(buf.readUnsignedShort(), buf.readUnsignedByte(), buf.readUnsignedShort(), buf.readUnsignedInt())); position.setNetwork(network); } break;\n                                case 0xE1: if (dataLength == 1) { position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); } break;\n                                default: buf.skipBytes(dataLength); break; // Skip unknown extended type\n                            }\n                            // Ensure reader index is at the end of the item, even if parsing failed or skipped\n                            buf.readerIndex(itemEndIndex);\n                        }\n                    }\n                    break; // End case 0xEB\n                case 0xED: // Card\n                     if (length > 0 && buf.readerIndex() <= endIndex - length) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_CARD, stringValue.trim());\n                     }\n                    break;\n                case 0xEE: // Sensor Data Block\n                     if (length == 6 && buf.readerIndex() <= endIndex - 6) { // Check length and bounds\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                     }\n                    break;\n                case 0xF3: // OBD Extended Data Block\n                    while (buf.readerIndex() < endIndex) {\n                        if (buf.readerIndex() > endIndex - 3) { break; } // Check extended OBD header size & bounds\n                        int extendedType = buf.readUnsignedShort();\n                        int extendedDataLength = buf.readUnsignedByte(); // This length is *only* for the data payload\n                        if (buf.readerIndex() > endIndex - extendedDataLength) { break; } // Check data size & bounds\n                        int itemEndIndex = buf.readerIndex() + extendedDataLength;\n                        // Simplified checks for common cases, assuming extendedDataLength matches required size\n                        switch (extendedType) {\n                            case 0x0002: if (extendedDataLength == 2) { position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0003: if (extendedDataLength == 2) { position.set(Position.KEY_RPM, buf.readUnsignedShort()); } break;\n                            case 0x0004: if (extendedDataLength == 2) { position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001); } break;\n                            case 0x0005: if (extendedDataLength == 4) { position.set(Position.KEY_OBD_ODOMETER, buf.readUnsignedInt() * 100); } break;\n                            case 0x0007: if (extendedDataLength == 2) { position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0008: if (extendedDataLength == 2) { position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0009: if (extendedDataLength == 2) { position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShort() - 40); } break;\n                            case 0x000B: if (extendedDataLength == 2) { position.set(\"intakePressure\", buf.readUnsignedShort()); } break;\n                            case 0x000C: if (extendedDataLength == 2) { position.set(\"intakeTemp\", buf.readUnsignedShort() - 40); } break;\n                            case 0x000D: if (extendedDataLength == 2) { position.set(\"intakeFlow\", buf.readUnsignedShort()); } break;\n                            case 0x000E: if (extendedDataLength == 1) { position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255); } else if (extendedDataLength == 2) { position.set(Position.KEY_THROTTLE, buf.readUnsignedShort() * 100 / 255); } break;\n                            case 0x0050: if (extendedDataLength == 17) { position.set(Position.KEY_VIN, buf.readSlice(17).toString(StandardCharsets.US_ASCII)); } break;\n                            case 0x0100: if (extendedDataLength == 2) { position.set(Position.KEY_ODOMETER_TRIP, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0102: if (extendedDataLength == 2) { position.set(\"tripFuel\", buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0112: if (extendedDataLength == 2) { position.set(\"hardAccelerationCount\", buf.readUnsignedShort()); } break;\n                            case 0x0113: if (extendedDataLength == 2) { position.set(\"hardDecelerationCount\", buf.readUnsignedShort()); } break;\n                            case 0x0114: if (extendedDataLength == 2) { position.set(\"hardCorneringCount\", buf.readUnsignedShort()); } break;\n                            default: buf.skipBytes(extendedDataLength); break; // Skip unknown item\n                        }\n                        buf.readerIndex(itemEndIndex); // Ensure we are at the end of the item\n                    }\n                    break; // End case 0xF3\n                case 0xFE: // Battery Level or Driving Behavior Alarms\n                    if (length == 1 && buf.readerIndex() <= endIndex - 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else if (length > 1 && buf.readerIndex() < endIndex) { // Check bounds\n                        if (buf.getUnsignedByte(buf.readerIndex()) == 0x7C) { // Check for 0x7C marker\n                            buf.readUnsignedByte(); // Consume 0x7C\n                            while (buf.readerIndex() < endIndex) {\n                                if (buf.readerIndex() > endIndex - 2) { break; } // Check behavior item header size & bounds\n                                int extendedType = buf.readUnsignedByte();\n                                int extendedDataLength = buf.readUnsignedByte(); // Length of data payload\n                                if (buf.readerIndex() > endIndex - extendedDataLength) { break; } // Check data size & bounds\n                                int itemEndIndex = buf.readerIndex() + extendedDataLength;\n                                switch (extendedType) {\n                                    case 0x01: // Alarms bitmap\n                                        if (extendedDataLength == 4) {\n                                           long alarms = buf.readUnsignedInt();\n                                           if (BitUtil.check(alarms, 0)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION); }\n                                           if (BitUtil.check(alarms, 1)) { position.set(Position.KEY_ALARM, Position.ALARM_BRAKING); }\n                                           if (BitUtil.check(alarms, 2)) { position.set(Position.KEY_ALARM, Position.ALARM_CORNERING); }\n                                           if (BitUtil.check(alarms, 3)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT); }\n                                           if (BitUtil.check(alarms, 4)) { position.set(Position.KEY_ALARM, Position.ALARM_TAMPERING); }\n                                        }\n                                        break;\n                                    default: buf.skipBytes(extendedDataLength); break; // Skip unknown item\n                                }\n                                buf.readerIndex(itemEndIndex); // Ensure we are at the end of the item\n                            }\n                        } else {\n                             // Fallback: Assume last byte is battery level if no 0x7C marker and data available\n                             if (buf.readerIndex() <= endIndex - 1) {\n                                 buf.readerIndex(endIndex - 1); // Move to last byte\n                                 position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                             }\n                        }\n                    }\n                    break; // End case 0xFE\n                case 0xE1: // Standalone Battery Level (%) - This case seems redundant if 0xD4/0xEB/0xFE handle it? Check if needed.\n                     if (length == 1 && buf.readerIndex() <= endIndex - 1) { // Check length and bounds\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                     }\n                    break;\n                default:\n                    // Unknown subtype. Data will be skipped by the readerIndex(endIndex) call below.\n                    // Log is handled by the validation logic before the switch.\n                    break;\n            }\n\n            // Position reader index to the end of the current TLV item for the next iteration.\n            // This handles cases where the switch didn't read the full 'length' bytes (e.g., unknown subtype, skipped data)\n            // or read exactly 'length' bytes. It also handles the special subtype 0x07 case.\n            // It relies on ByteBuf implementation to handle endIndex potentially exceeding writerIndex\n            // (typically by setting readerIndex to writerIndex).\n            buf.readerIndex(endIndex);\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}