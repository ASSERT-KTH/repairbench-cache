{
    "generation": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        // 13-Dec-2023, bot: Check current token. If it's FIELD_NAME, prepend START_OBJECT\n        // as implied by the #592 fix description.\n        JsonToken t = jp.currentToken();\n\n        // If FIELD_NAME is the first token, assume START_OBJECT precedes it.\n        // (We may already be inside an object, too, doesn't matter)\n        if (t == JsonToken.FIELD_NAME) {\n            // Method is within TokenBuffer itself, which is a JsonGenerator\n            writeStartObject(); \n            // Fall through to copy the FIELD_NAME and the rest of the structure\n        } else if (t == null) {\n            // Or similarly, if parser is pointing to null, advance past START_OBJECT/ARRAY\n            // (although delegation suggests we should already be pointing to a value...)\n            // But let's handle this robustly if possible. May need this for root-level\n            // buffer too.\n            // 17-Jan-2018, tatu: As per [databind#1801], need to handle case where\n            //    current token is null (but for which `nextToken()` would return token)\n             t = jp.nextToken();\n             // Need to check again, possible we got END_OF_INPUT\n             if (t == null) { // end-of-input?\n                 return this; // empty\n             }\n             // otherwise fall-through\n        }\n        // Otherwise, just copy whatever structure we encounter now\n        copyCurrentStructure(jp);\n        return this;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}