{
    "generation": "    private Object decodePosition(\n            Channel channel, SocketAddress remoteAddress, String sentence, String id) {\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        List<Position> positions = new LinkedList<>();\n        Position position = null;\n        DateBuilder dateBuilder = null;\n\n        for (String pair : sentence.split(\",\")) {\n            String[] data = pair.split(\"[=:]\");\n            // Check if split resulted in at least two parts (key and value)\n            if (data.length < 2) {\n                 continue; // Skip malformed pairs\n            }\n            int key;\n            try {\n                // Keys are hexadecimal\n                key = Integer.parseInt(data[0], 16);\n            } catch (NumberFormatException e) {\n                // Skip pairs with invalid non-hexadecimal key\n                continue;\n            }\n            String value = data[1];\n            if (key == 0x0) { // Start of a new position record\n                if (position != null) {\n                    // If there was a previous position object being built, finalize its time and add it\n                    // We assume dateBuilder is not null here because it's set together with position when key is 0x0\n                    position.setTime(dateBuilder.getDate());\n                    positions.add(position);\n                }\n                // Create a new position object for the current record\n                position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                // Initialize a date builder, using current time as the base\n                dateBuilder = new DateBuilder(new Date());\n            } else if (position != null) {\n                // Process other keys only if a position object has been started (key 0x0 was encountered)\n                switch (key) {\n                    case 0x11: // Date in DDMMYY format\n                        value = (\"000000\" + value).substring(value.length()); // Pad if needed\n                        dateBuilder.setDateReverse(\n                                Integer.parseInt(value.substring(0, 2)),\n                                Integer.parseInt(value.substring(2, 4)),\n                                Integer.parseInt(value.substring(4)));\n                        break;\n                    case 0x10: // Time in HHMMSSms format (milliseconds might be single digit)\n                        value = (\"00000000\" + value).substring(value.length()); // Pad if needed\n                        dateBuilder.setTime(\n                                Integer.parseInt(value.substring(0, 2)), // HH\n                                Integer.parseInt(value.substring(2, 4)), // MM\n                                Integer.parseInt(value.substring(4, 6)), // SS\n                                Integer.parseInt(value.substring(6)) * 10); // Milliseconds (adjust if needed)\n                        break;\n                    case 0xA: // Latitude\n                        position.setValid(true);\n                        position.setLatitude(Double.parseDouble(value));\n                        break;\n                    case 0xB: // Longitude\n                        position.setValid(true);\n                        position.setLongitude(Double.parseDouble(value));\n                        break;\n                    case 0xC: // Altitude\n                        position.setAltitude(Double.parseDouble(value));\n                        break;\n                    case 0xD: // Speed (KPH)\n                        position.setSpeed(UnitsConverter.knotsFromKph(Double.parseDouble(value)));\n                        break;\n                    case 0xE: // Course/Heading\n                        position.setCourse(Integer.parseInt(value));\n                        break;\n                    case 0xF: // Satellites\n                        position.set(Position.KEY_SATELLITES, Integer.parseInt(value));\n                        break;\n                    case 0x12: // HDOP\n                        position.set(Position.KEY_HDOP, Integer.parseInt(value));\n                        break;\n                    case 0x20: // Acceleration\n                        position.set(Position.KEY_ACCELERATION, value);\n                        break;\n                    case 0x24: // Battery (Voltage in centivolts?)\n                        position.set(Position.KEY_BATTERY, Integer.parseInt(value) * 0.01);\n                        break;\n                    case 0x81: // RSSI\n                        position.set(Position.KEY_RSSI, Integer.parseInt(value));\n                        break;\n                    case 0x82: // Device Temperature\n                        // Original buggy line:\n                        // position.set(Position.KEY_DEVICE_TEMP, Integer.parseInt(value) * 0.1);\n                        // This failed for input like \"53.000000\" with NumberFormatException.\n                        // Fixed line: Use Double.parseDouble to handle both integer (\"47\") and float (\"53.000000\") inputs.\n                        // Note: This assumes \"47\" means 47.0 degrees, not 4.7 degrees. If 4.7 was intended, the protocol/device sends inconsistent formats.\n                        position.set(Position.KEY_DEVICE_TEMP, Double.parseDouble(value));\n                        break;\n                    case 0x104: // Engine Load\n                        position.set(Position.KEY_ENGINE_LOAD, Integer.parseInt(value));\n                        break;\n                    case 0x105: // Coolant Temperature\n                        position.set(Position.KEY_COOLANT_TEMP, Integer.parseInt(value));\n                        break;\n                    case 0x10c: // RPM\n                        position.set(Position.KEY_RPM, Integer.parseInt(value));\n                        break;\n                    case 0x10d: // OBD Speed (KPH)\n                        position.set(Position.KEY_OBD_SPEED, UnitsConverter.knotsFromKph(Integer.parseInt(value)));\n                        break;\n                    case 0x111: // Throttle Position\n                        position.set(Position.KEY_THROTTLE, Integer.parseInt(value));\n                        break;\n                    default: // Other keys are treated as generic IO values\n                        position.set(Position.PREFIX_IO + key, value);\n                        break;\n                }\n            }\n        }\n\n        // After processing all pairs, finalize the last position object if it exists\n        if (position != null) {\n            if (!position.getValid()) {\n                // If the position data didn't include valid coordinates (e.g., no GPS fix),\n                // try to use the last known location details.\n                // Pass the timestamp associated with this record, if available.\n                Date observed = (dateBuilder != null) ? dateBuilder.getDate() : null;\n                getLastLocation(position, observed);\n            }\n            // Set the final calculated time for this position record.\n            // This requires dateBuilder to have been initialized (key 0x0 must have been present).\n            if (dateBuilder != null) {\n                position.setTime(dateBuilder.getDate());\n            } else {\n                // Fallback: If somehow we have a position but no dateBuilder (e.g., malformed data with no key 0x0),\n                // set time to now if it's not already set (e.g., by getLastLocation).\n                 if (position.getTime() == null) {\n                    position.setTime(new Date());\n                }\n            }\n            positions.add(position);\n        }\n\n        return positions.isEmpty() ? null : positions;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}