{
    "generation": "import com.google.common.base.Predicate;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.common.base.Preconditions;\n\n// NOTE: Assumes isNameAssignedTo(String, Node) is defined elsewhere in the class.\n\n  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    if (node.isName()) {\n      // Replacing name 'v' with 'replacement'.\n      // It's unsafe if 'replacement' contains 'v' itself, as this can lead to\n      // incorrect results when 'v' is reassigned between the definition and use,\n      // or if the replacement happens within an assignment to 'v'.\n      // Example: x = x.a; x = x.a; is problematic because the second 'x.a' would\n      // refer to the x modified by the first assignment if naively substituted.\n      // Example: x = x.a; y = x; is problematic if x changes between the two statements.\n      // Checking if the replacement references the assigned variable captures this risk.\n      final String name = node.getString();\n      // Check if 'name' is used anywhere in 'replacement'. Traverse into all nodes\n      // except function definitions, as replacements across function boundaries\n      // have different safety considerations (handled elsewhere).\n      if (NodeUtil.has(\n          replacement,\n          new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n              // Check if input is a NAME node with the specified name.\n              return input.isName() && input.getString().equals(name);\n            }\n          },\n          new Predicate<Node>() {\n            @Override\n            public boolean apply(Node node) {\n              // Traverse into all nodes except function definitions.\n              return !node.isFunction();\n            }\n          })) {\n        return false; // Unsafe: replacement uses the variable being replaced.\n      }\n      return true; // Safe otherwise (from this function's perspective).\n    }\n\n    // If not a NAME, the original code assumed it must be a GETPROP.\n    Preconditions.checkArgument(node.isGetProp());\n\n    // Replacing 'base.prop...' with 'replacement'.\n    // Find the ultimate base of the property access chain (e.g., 'a' in 'a.b.c').\n    Node base = node.getFirstChild();\n    while (base.isGetProp()) {\n      base = base.getFirstChild();\n    }\n\n    // If the base is a name (e.g., 'a' in a.b.c), check if that name ('a')\n    // is assigned to anywhere within the 'replacement' expression.\n    // If the base object ('a') could be modified by evaluating the replacement,\n    // then substituting the replacement for 'a.b.c' is unsafe.\n    // Example: a.p = b; use(a.p); => use(b); is unsafe if 'b' is 'a = null'.\n    if (base.isName()) {\n        if (isNameAssignedTo(base.getString(), replacement)) {\n             // Unsafe: replacement assigns to the base name of the original GETPROP.\n             return false;\n        }\n    }\n\n    // If the checks pass, the replacement is considered safe regarding variable changes\n    // and base object modifications checked here. Other checks (like general side\n    // effects of replacement) are likely handled elsewhere by the calling pass.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}