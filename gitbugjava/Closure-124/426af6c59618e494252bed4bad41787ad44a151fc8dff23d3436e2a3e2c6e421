{
    "generation": "  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @param node The node containing the name reference (e.g., NAME, GETPROP).\n   * @param replacement The expression that would replace the name.\n   * @return Whether the replacement can be made without the replacement\n   *     expression changing the referenced name's value before the reference.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // If the node where the replacement happens is just a name,\n    // check if the replacement expression modifies that name.\n    if (node.isName()) {\n      // Original code returned true here unconditionally. Fixed.\n      if (NodeUtil.isNameAssignedTo(node.getString(), replacement)) {\n          return false; // Unsafe if replacement modifies the name itself.\n      }\n      return true; // Safe if replacement doesn't modify the name.\n    }\n\n    // If the node is a property access, check the base name.\n    if (node.isGetProp()) {\n      Node base = node.getFirstChild();\n      // Check if the base is a name and the replacement modifies that name.\n      if (base.isName() &&\n          NodeUtil.isNameAssignedTo(base.getString(), replacement)) {\n        return false; // Unsafe if replacement modifies the base object name.\n      }\n      // If base isn't a name, or replacement doesn't modify it, assume safe for GETPROP.\n      // We don't need to recursively check deeper, as `isNameAssignedTo` checks\n      // the entire replacement expression.\n      return true;\n    }\n\n    // Add handling for GETELEM similar to GETPROP\n    if (node.isGetElem()) {\n        Node base = node.getFirstChild();\n        // Check if the base is a name and the replacement modifies that name.\n        if (base.isName() &&\n            NodeUtil.isNameAssignedTo(base.getString(), replacement)) {\n            return false; // Unsafe if replacement modifies the base object name.\n        }\n        return true; // Assume safe for GETELEM otherwise.\n    }\n\n\n    // Default assumption for other node types:\n    // If the usage node isn't a direct name or a property/element access\n    // based on a name, we assume the replacement is safe with respect to\n    // modifying the name being replaced (as there's no clear single name target).\n    // This matches the behavior of the original code which implicitly returned true\n    // or crashed for unexpected node types after the NAME check.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}