{
    "generation": "  /**\n   * Checks names referenced within 'node' to determine if any might have\n   * their meaning changed by assignments related to 'replacement'.\n   * Used to determine if a value ('replacement') can be safely substituted\n   * elsewhere. The common case is checking the RHS of an assignment `lhs = rhs`\n   * by calling `isSafeReplacement(rhs, rhs)`.\n   * @param node The node to recursively check for possibly-aliased names.\n   * @param replacement The context expression, usually the same as 'node'.\n   * @return Whether the replacement seems safe w.r.t. name changes.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // Check recursively for names or qualified names within the node.\n    if (node.isName()) {\n      // Base case: If 'node' is a name, check if that specific name might be\n      // reassigned in a way related to 'replacement'. If it is potentially\n      // reassigned (isNameAssignedTo returns true), the replacement is unsafe.\n      return !isNameAssignedTo(node.getString(), replacement);\n    }\n\n    // For non-Name nodes, recursively check all children.\n    // If any child contains a name that makes the replacement unsafe,\n    // the whole node is considered unsafe.\n    for (Node child = node.getFirstChild(); child != null; child = child.getNext()) {\n      if (!isSafeReplacement(child, replacement)) {\n        return false;\n      }\n    }\n\n    // If the node itself is not a Name and all children are safe,\n    // then this node is considered safe for replacement in this context.\n    // This covers literals, operators, GETPROP/GETELEM objects/indices etc.,\n    // assuming their children have been verified.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}