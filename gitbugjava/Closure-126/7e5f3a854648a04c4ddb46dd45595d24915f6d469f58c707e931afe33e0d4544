{
    "generation": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks/continues within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Handle structures that require recursive minimization first.\n    // Order matters.\n\n    // 'if' statement: minimize exits in the branches.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      // After minimizing branches, the IF itself might be processed by the caller's loop\n      // if it's the last statement.\n      return;\n    }\n\n    // 'try/catch/finally' statement: minimize exits in try and catch blocks.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        // TODO(johnlenz): Handle multiple catch blocks. Minimize all of them.\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      // Don't try to minimize the exits of finally blocks, as this\n      // can cause problems if it changes the completion type of the finally\n      // block. See ECMA 262 Sections 8.9 & 12.14.\n      // An explicit 'return' or 'throw' is necessary in the finally block if it needs\n      // to override a 'return' or 'throw' in the try/catch block.\n      // Minimizing a 'break' or 'continue' in finally is also problematic.\n      if (NodeUtil.hasFinally(n)) {\n        // Node finallyBlock = n.getLastChild();\n        // tryMinimizeExits(finallyBlock, exitType, labelName); // DO NOT RECURSE\n      }\n      // After minimizing blocks, the TRY itself might be processed by the caller's loop.\n      return;\n    }\n\n    // 'label' statement: minimize exits in the label's block.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      // Minimize the label body first.\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      // If the label's block is now empty, remove the label node itself.\n      // This is safe because an empty labeled statement is equivalent to an empty statement.\n      if (labelBlock.isBlock() && !labelBlock.hasChildren()) {\n          Node parent = n.getParent();\n          if (parent != null) {\n             // TODO(johnlenz): Consider cases like `label1: label2: {}` where removing label1\n             // might be problematic if label2 is needed. But usually empty blocks are removed\n             // elsewhere anyway. Removing the label seems generally correct if its body is empty.\n             NodeUtil.removeChild(parent, n);\n             compiler.reportCodeChange();\n          }\n      }\n      // After potentially removing the label, return. Nothing more to do with the label node itself.\n      return;\n    }\n\n    // TODO(johnlenz): Handle SWITCH statements? Minimize breaks at the end of cases?\n\n    // Only process container nodes like BLOCK or SCRIPT further.\n    // Other node types (like RETURN, BREAK) are handled when they are children.\n    if (!n.isBlock() && !n.isScript()) {\n        return;\n    }\n    if (n.getLastChild() == null) {\n      return; // Empty block/script.\n    }\n\n    // Minimize explicit exits at the end of the block `n`.\n    // Traverse backwards from the last child. If the last child is removed,\n    // check the new last child.\n    for (Node c = n.getLastChild(); c != null; /* Update c in loop */) {\n       // Store the node we are about to process.\n       Node originalChild = c;\n\n       // Try to minimize the child first recursively. This might simplify or remove it.\n       // For example, if 'c' is a label containing only a 'return', the recursive\n       // call might remove the 'return' and then the label itself.\n       tryMinimizeExits(originalChild, exitType, labelName);\n\n       // After the recursive call, check if 'originalChild' is still the last child of 'n'.\n       // It might have been removed or replaced.\n       c = n.getLastChild(); // Get the current last child for the check.\n       if (c == originalChild && c != null && c.getParent() == n) {\n          // If the node is still the last child, check if it is now an\n          // exit node that matches the context ('exitType', 'labelName')\n          // and can be removed because it's redundant at the end of block 'n'.\n          // Assumes matchingExitNode is correctly implemented elsewhere to handle\n          // label matching and nulls correctly for RETURN, BREAK, CONTINUE.\n          if (matchingExitNode(c, exitType, labelName)) {\n            NodeUtil.removeChild(n, c);\n            compiler.reportCodeChange();\n            // After removing 'c', the new last child is fetched in the next iteration's\n            // c = n.getLastChild() update.\n            c = n.getLastChild(); // Update c for the next iteration check immediately.\n          } else {\n            // If the last child wasn't a removable exit for this context,\n            // we can't simplify block 'n' further by removing its last element. Stop.\n            break;\n          }\n       } else {\n         // The last child changed during the recursive call (e.g., 'originalChild' was removed).\n         // The loop condition will fetch the new last child (or null).\n         // If c is now null, the loop terminates. Otherwise, continue with the new last child 'c'.\n         if (c == null) {\n            break; // Block became empty.\n         }\n         // Continue loop with the new last child 'c'.\n       }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}