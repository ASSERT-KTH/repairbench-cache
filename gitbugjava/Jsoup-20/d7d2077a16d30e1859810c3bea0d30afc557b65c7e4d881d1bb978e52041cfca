{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate; // Assuming this is available or import appropriately\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n// Assume defaultCharset is a static final String member of this class or accessible\n// Assume getCharsetFromContentType(String) is a static method in this class or accessible\n\n// Fixes the handling of spurious Byte Order Marks (BOM) which could interfere with parsing.\nclass FixedDataUtil { // Wrapper class for context, replace with actual class name if known\n\n    // Assume defaultCharset is defined elsewhere, e.g.:\n    private static final String defaultCharset = \"UTF-8\";\n\n    // Assume getCharsetFromContentType is defined elsewhere, e.g.:\n    private static String getCharsetFromContentType(String contentType) {\n        // Implementation omitted - extracts charset from Content-Type string\n        if (contentType == null) return null;\n        java.util.regex.Matcher m = java.util.regex.Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\").matcher(contentType);\n        if (m.find()) {\n            return m.group(1).trim().toUpperCase();\n        }\n        return null;\n    }\n\n\n    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        // defaultCharset used throughout, ensure it's static final in the class or accessible constant\n\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            byteData.mark(); // Mark position before decoding for potential rewind\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n\n            // Check and strip BOM *before* first parse\n            // UTF-8 BOM is \\uFEFF. Normal Charset decoders should identify and remove it, but we handle it here just in case\n            if (docData.length() > 0 && docData.charAt(0) == 65279) { // 65279 == U+FEFF (BOM)\n                 docData = docData.substring(1);\n                 // Note: If we need to rewind later, the byte buffer might not perfectly align with the BOM-stripped string.\n                 // However, rewinding only happens if a *different* charset is found. In that case, we re-decode\n                 // the original byte buffer with the new charset, and check/strip BOM again. So this is safe.\n            }\n\n            doc = parser.parseInput(docData, baseUri); // First parse based on default charset (BOM stripped)\n            // look for charset meta tag\n            Element meta = doc.selectFirst(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null;\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    foundCharset = meta.attr(\"charset\");\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                    // Sainty check found charset\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\"); // Clean charset name\n                    if (Charset.isSupported(foundCharset)) { // Ensure charset is supported before trying to decode\n                        charsetName = foundCharset;\n                        byteData.reset(); // Rewind to marked position\n                        docData = Charset.forName(foundCharset).decode(byteData).toString();\n                        // Check and strip BOM again after re-decoding with found charset\n                        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n                             docData = docData.substring(1);\n                        }\n                        doc = null; // set doc back to null so intermediate doc is ignored - needs re-parsing\n                    } else {\n                        // Found charset but unsupported. Keep the default charset and the initially parsed doc\n                        charsetName = defaultCharset; // Explicitly set charsetName used\n                    }\n                } else {\n                     // Meta tag found but charset is same as default, or empty/null. Keep default.\n                     charsetName = defaultCharset; // Explicitly set charsetName used\n                }\n            } else {\n                 // Meta tag not found, use the default charset.\n                 charsetName = defaultCharset; // Explicitly set charsetName used\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            // Check and strip BOM if charset was explicitly specified\n            if (docData.length() > 0 && docData.charAt(0) == 65279) { // 65279 == U+FEFF (BOM)\n                 docData = docData.substring(1);\n            }\n        }\n\n        if (doc == null) {\n            // This block executes if:\n            // 1. charsetName was specified initially (and BOM stripped).\n            // 2. charsetName was null, a different charset was found, re-decoded (and BOM stripped).\n            // Important: docData here is the potentially BOM-stripped string from the correct charset decoding.\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the charset used for parsing in the output settings\n        // If charsetName is null at this point, it means we used the default charset for the final parse\n        doc.outputSettings().charset(charsetName != null ? charsetName : defaultCharset);\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}