{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      // goog.provide('goog') is special cased in ProcessClosurePrimitives.\n      // Either firstNode or candidateDefinition must be non-null.\n      // (It's possible that firstNode is null if the namespace is implicitly\n      // provided by a definition rather than a goog.provide).\n      Preconditions.checkState(firstNode != null || candidateDefinition != null,\n          \"Neither firstNode nor candidateDefinition is non-null for namespace %s\", namespace);\n\n\n      if (firstNode == null) {\n        // This namespace must be provided implicitly by a definition,\n        // and this definition is the first node we encounter.\n        // Example:\n        // M1: goog.provide('a');\n        // M2: var a = {}; goog.provide('a.b');\n        // Assume M2 is processed first. We process 'a.b'. Its parent 'a'\n        // has candidateDefinition='var a={};' and firstNode=null.\n        replacementNode = candidateDefinition;\n        // We assume candidateDefinition is already placed correctly or will be handled.\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol ('explicitNode' will be the goog.provide call).\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent(); // Remove the goog.provide call.\n        compiler.reportCodeChange();\n\n        // Default to using the candidateDefinition as the replacement.\n        replacementNode = candidateDefinition;\n\n        // If the candidate is an assignment 'a = ...', try to convert to 'var a = ...'.\n        // This is fragile and doesn't handle all cases (e.g., obj.a = ...).\n        // It also assumes the definition is at the global scope.\n        // See testAssignBeforeProvide and ProcessClosurePrimitives#processProvide.\n        if (NodeUtil.isExprAssign(candidateDefinition)) {\n          Node assignNode = candidateDefinition.getFirstChild(); // ASSIGN\n          Node nameNode = assignNode.getFirstChild(); // LHS of assign\n          if (nameNode.isName()) { // Only convert if LHS is simple name 'a', not 'a.b'\n            Node valueNode = nameNode.getNext(); // RHS of assign\n\n            // Detach children from ASSIGN\n            assignNode.detachChildren();\n\n            // Build the new VAR node\n            nameNode.addChildToFront(valueNode); // NAME becomes NAME(value)\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFromForTree(candidateDefinition); // Copy source info\n\n            // Try to preserve JSDoc (check both EXPR_RESULT and ASSIGN)\n            JSDocInfo JSDoc = candidateDefinition.getJSDocInfo();\n            if (JSDoc == null) {\n               JSDoc = assignNode.getJSDocInfo();\n            }\n            if (JSDoc != null) {\n               nameNode.setJSDocInfo(JSDoc); // Attach JSDoc to the NAME node\n            }\n\n            // Replace the original EXPR_RESULT with the VAR node if possible.\n            Node parent = candidateDefinition.getParent();\n            if (parent != null) {\n               parent.replaceChild(candidateDefinition, varNode);\n               compiler.reportCodeChange();\n               replacementNode = varNode; // Use the new VAR node as the replacement\n            } else {\n               // candidateDefinition wasn't in the tree; this might be problematic.\n               // replacementNode will be the detached VAR node. Its placement\n               // depends on subsequent logic (e.g., module handling).\n               replacementNode = varNode;\n            }\n          }\n        }\n        // If conversion didn't happen, replacementNode remains candidateDefinition.\n        // We assume candidateDefinition is already correctly placed or will be handled.\n\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        // Create a declaration 'var ns = {};' or 'ns.sub = {};'\n        replacementNode = createDeclarationNode();\n\n        // Determine where to insert the new declaration node.\n        if (firstModule == minimumModule) {\n          // The first time we saw this namespace was in the earliest module.\n          // Insert the declaration before that first node.\n          Node insertionPoint = firstNode;\n          Node insertionPointParent = insertionPoint.getParent();\n          Preconditions.checkNotNull(insertionPointParent, \"firstNode for %s must be in the AST.\", namespace);\n          insertionPointParent.addChildBefore(replacementNode, insertionPoint);\n          compiler.reportCodeChange();\n        } else {\n          // This namespace was first seen in a later module, but needs to be\n          // declared in an earlier common ancestor module (minimumModule).\n          int indexOfDot = namespace.indexOf('.');\n          Node insertionScript = compiler.getNodeForCodeInsertion(minimumModule);\n          Preconditions.checkNotNull(insertionScript, \"Cannot get insertion point SCRIPT for module %s\", minimumModule);\n          Preconditions.checkState(insertionScript.isScript(), \"Insertion point %s is not a SCRIPT node\", insertionScript);\n\n          if (indexOfDot == -1) {\n            // Top-level namespace (e.g., 'var apps = {}').\n            // Add it to the end of the common module's script.\n            insertionScript.addChildToBack(replacementNode);\n            compiler.reportCodeChange();\n          } else {\n            // Nested namespace (e.g., 'apps.foo = {}').\n            // Add it *after* its parent namespace declaration in the common module.\n            String parentNamespace = namespace.substring(0, indexOfDot);\n            ProvidedName parentName = providedNames.get(parentNamespace);\n            Preconditions.checkNotNull(parentName, \"No parent ProvidedName entry for '%s' found when processing '%s'\", parentNamespace, namespace);\n\n            // Crucial Assumption: The parent namespace must have been processed *before* the child.\n            Node parentNode = parentName.replacementNode;\n            Preconditions.checkNotNull(parentNode,\n                \"Parent namespace '%s' has not been replaced yet (check processing order).\", parentNamespace);\n\n            Node parentNodeParent = parentNode.getParent();\n            // Check that the parent node is in the tree and attached to the expected script node.\n            Preconditions.checkNotNull(parentNodeParent,\n                \"Parent namespace node '%s' is not attached to the AST.\", parentNamespace);\n            Preconditions.checkState(parentNodeParent == insertionScript,\n                \"Parent namespace node '%s' is not in the expected SCRIPT node for module %s. Found in %s.\",\n                parentNamespace, minimumModule, parentNodeParent);\n\n            // Insert the child declaration right after the parent declaration.\n            parentNodeParent.addChildAfter(replacementNode, parentNode);\n            compiler.reportCodeChange();\n          }\n        }\n\n        // If this namespace had an explicit goog.provide call associated with it\n        // (which wasn't the first node encountered for the namespace), remove it now.\n        if (explicitNode != null && explicitNode != firstNode) {\n          explicitNode.detachFromParent();\n          compiler.reportCodeChange();\n        }\n        // If the first node encountered was the explicit goog.provide call for this\n        // namespace, remove it as well (we've now added the proper declaration).\n        // Check node type to ensure it's the goog.provide call expression.\n        if (explicitNode == firstNode && firstNode.isExprResult()) {\n            Node callNode = firstNode.getFirstChild();\n            if (callNode != null && callNode.isCall() &&\n                callNode.getFirstChild() != null && // Check grandchild exists\n                callNode.getFirstChild().matchesQualifiedName(\"goog.provide\")) {\n               firstNode.detachFromParent();\n               compiler.reportCodeChange();\n            }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}