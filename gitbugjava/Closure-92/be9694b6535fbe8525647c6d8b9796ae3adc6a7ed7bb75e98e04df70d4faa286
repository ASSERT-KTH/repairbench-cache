{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        // Ensure the definition becomes a declaration if it's suitable.\n        if (NodeUtil.isExpressionNode(candidateDefinition)\n            && candidateDefinition.getFirstChild().isAssign()) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          // Check if it's a simple assignment (NAME = VALUE)\n          if (nameNode.isName() && nameNode.getNext() != null) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            // Detach children from ASSIGN\n            assignNode.detachChildren();\n            // Prepare NAME node for VAR\n            nameNode.addChildToFront(valueNode);\n\n            // Create VAR node\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n            if (assignNode.getJSDocInfo() != null) {\n               // Prefer JSDoc info from the original assignment if available\n               nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            }\n\n            // Replace the original expression statement with the VAR node\n            Node parent = candidateDefinition.getParent();\n            if (parent != null) { // Parent might be null if already detached\n              parent.replaceChild(candidateDefinition, varNode);\n              compiler.reportCodeChange();\n              replacementNode = varNode;\n            } else {\n              // If parent is null, candidateDefinition might have been detached\n              // elsewhere. We've created the varNode, make it the replacement.\n              replacementNode = varNode;\n              // It needs to be inserted somewhere, ProcessClosurePrimitives should handle this.\n            }\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode(); // Generates VAR or EXPR_RESULT\n\n        // Determine insertion point in minimumModule.\n        Node insertAfterNode = null;\n\n        // Find the longest ancestor namespace that has been replaced.\n        ProvidedName parentName = null;\n        Node parentReplacementNode = null;\n        String currentNamespace = namespace;\n        int p = currentNamespace.lastIndexOf('.');\n        while (p != -1) {\n          String parentNamespace = currentNamespace.substring(0, p);\n          parentName = providedNames.get(parentNamespace);\n          if (parentName != null && parentName.replacementNode != null) {\n            parentReplacementNode = parentName.replacementNode;\n            // Ensure the parent's replacement is in the minimum module's AST.\n            // We assume ProcessClosurePrimitives places replacementNodes correctly.\n            break; // Found the closest ancestor that has been replaced.\n          }\n          // If not found, try the next level up.\n          p = parentNamespace.lastIndexOf('.');\n        }\n\n        if (parentReplacementNode != null) {\n          // Find the statement containing the parent's replacement node.\n          Node parentStatement = parentReplacementNode;\n          // Walk up the AST until we find the node directly under a BLOCK/SCRIPT.\n          while (parentStatement.getParent() != null &&\n                 !parentStatement.getParent().isScript() &&\n                 !parentStatement.getParent().isBlock()) {\n            parentStatement = parentStatement.getParent();\n          }\n\n          // Ensure we found a valid statement node that has a parent block/script.\n          if (parentStatement.getParent() != null &&\n              (parentStatement.getParent().isScript() || parentStatement.getParent().isBlock())) {\n             insertAfterNode = parentStatement;\n          }\n        }\n\n        // Insert the new node into minimumModule.\n        if (insertAfterNode != null) {\n          // Insert after the parent's statement node.\n          insertAfterNode.getParent().addChildAfter(replacementNode, insertAfterNode);\n        } else {\n          // Parent statement wasn't found or this is a root namespace.\n          // Insert at the beginning/end of the minimum module script.\n          // Using addChildToBack is generally safer for initialization order.\n          compiler.getNodeForCodeInsertion(minimumModule)\n              .addChildToBack(replacementNode);\n        }\n\n        // If there was an explicit definition for this name (e.g., var ns = {}),\n        // remove it now, as it's been superseded by the declaration we just added.\n        if (explicitNode != null) {\n          // Check parent, as it might have already been detached if explicitNode was involved\n          // in the candidateDefinition logic (though this 'else' block implies it wasn't used).\n          if (explicitNode.getParent() != null) {\n              explicitNode.detachFromParent();\n          }\n        }\n        // Report the change after insertion/removal.\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}