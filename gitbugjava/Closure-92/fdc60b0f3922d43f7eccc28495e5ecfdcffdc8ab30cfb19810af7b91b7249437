{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        // If the candidate definition is the same as the explicit node,\n        // then they are the same node, and we don't need to do anything.\n        // This happens often in Closure code. See testDuplicateProvideIssue774.\n        if (candidateDefinition == explicitNode) {\n           replacementNode = candidateDefinition;\n           return;\n        }\n\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        // If candidate definition is an EXPR_RESULT, then it is an assignment.\n        // If the name on the left of the assign has not been declared,\n        // convert the assign to a var declaration.\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.isQualifiedName()) {\n            // Need to convert this assign to a var declaration.\n            Var var = compiler.getScopeCreator().createScope(candidateDefinition, null).getVar(\n                nameNode.getQualifiedName());\n            // Check if the name is already declared OR is not a global name.\n            // If it's not a global name, we can't declare it in the global scope.\n            // If it's already declared, we don't need to redeclare it.\n            // It may be defined in multiple modules, but it will be declared\n            // in the first module that requires it.\n            if (var == null || (!var.isExtern() && var.getScope().isGlobal() && var.getNode() == null\n                && var.getInitialValue() == null)) {\n              // Convert 'a.b = ...' to 'var a = {}; a.b = ...'.\n              // We make sure to do this even if the namespace is provided\n              // elsewhere.\n              Node valueNode = nameNode.getNext();\n              assignNode.removeChild(nameNode);\n              assignNode.removeChild(valueNode);\n              nameNode.addChildToFront(valueNode);\n              Node varNode = new Node(Token.VAR, nameNode);\n              varNode.copyInformationFromForTree(candidateDefinition);\n              candidateDefinition.getParent().replaceChild(\n                  candidateDefinition, varNode);\n              nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n              compiler.reportCodeChange();\n              replacementNode = varNode;\n            }\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          // Insert the declaration before the first node (goog.provide call).\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Top-level namespace, add it to the beginning or end of the module.\n            // Adding to the back is simpler as it avoids ordering issues with\n            // potential existing declarations.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace if possible.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n\n            // Ensure the parent replacement node is available and in the AST.\n            // It might not be if the parent is also being moved to this module\n            // and hasn't been processed yet.\n            if (parentName.replacementNode != null &&\n                parentName.replacementNode.getParent() != null) {\n              // Parent node exists and is in the tree, insert after it.\n              parentName.replacementNode.getParent().addChildAfter(\n                  replacementNode, parentName.replacementNode);\n            } else {\n              // Parent isn't ready yet (likely also being moved).\n              // Fall back to adding the node to the end of the module.\n              // This ensures the node is added, although the relative order\n              // might not be strictly sequential if processing order varies.\n              compiler.getNodeForCodeInsertion(minimumModule)\n                  .addChildToBack(replacementNode);\n            }\n          }\n        }\n\n        // Remove the original goog.provide call if it exists and wasn't\n        // already handled (e.g., wasn't the candidate definition).\n        if (explicitNode != null && explicitNode != candidateDefinition) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}