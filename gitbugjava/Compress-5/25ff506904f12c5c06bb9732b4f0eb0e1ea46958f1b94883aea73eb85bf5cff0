{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        // Defer finished check until we know the entry method\n        if (current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start < 0 || length < 0 || start > buffer.length || buffer.length - start < length) {\n             throw new ArrayIndexOutOfBoundsException();\n        }\n\n        // Handle zero length read early\n        if (length == 0) {\n            // Check finished state even for 0-byte read, return -1 if already finished\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                if (current.getSize() != -1 && readBytesOfEntry >= current.getSize()) {\n                    return -1;\n                }\n            } else { // DEFLATED\n                if (inf.finished()) {\n                    return -1;\n                }\n            }\n            return 0; // Otherwise, reading 0 bytes returns 0\n        }\n\n\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            // Check if STORED entry is finished\n            int csize = (int) current.getSize();\n            if (csize != -1 && readBytesOfEntry >= csize) {\n                return -1;\n            }\n\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                lengthOfLastRead = in.read(buf); // Read next chunk\n                if (lengthOfLastRead == -1) {\n                    // EOF from underlying stream\n                    count(0); // Count 0 bytes for this read attempt\n                    // If EOF before expected size, it's truncated\n                    if (csize != -1 && readBytesOfEntry < csize) {\n                         throw new IOException(\"Truncated ZIP file\");\n                    }\n                    return -1; // Normal EOF for STORED\n                }\n                // Count actual bytes read\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n\n            // Calculate bytes to copy from buffer 'buf'\n            int availableInChunk = lengthOfLastRead - offsetInBuffer;\n            int remainingInEntry = (csize == -1) ? Integer.MAX_VALUE : (csize - readBytesOfEntry);\n            int toRead = Math.min(length, Math.min(availableInChunk, remainingInEntry));\n\n            if (toRead > 0) {\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n            } else {\n                 // This should ideally not happen if the finished check at the start is correct,\n                 // but return -1 to indicate EOF if it does.\n                 return -1;\n            }\n            return toRead;\n\n        } else { // DEFLATED\n            // Check if DEFLATED entry is already finished\n             if (inf.finished()) {\n                 return -1;\n             }\n\n             // Fill buffer if inflater needs input\n             if (inf.needsInput()) {\n                 fill();\n                 // ---- FIX: Check for EOF after fill ----\n                 if (lengthOfLastRead == -1) {\n                     // Inflater needs input, but we reached EOF prematurely.\n                     throw new IOException(\"Truncated ZIP file\");\n                 }\n                 // ---- End FIX ----\n                 if (lengthOfLastRead > 0) {\n                     bytesReadFromStream += lengthOfLastRead;\n                 }\n             }\n\n             // Try to inflate data\n             int read = 0;\n             try {\n                 read = inf.inflate(buffer, start, length);\n             } catch (DataFormatException e) {\n                 // Wrap DataFormatException in ZipException (which is an IOException)\n                 throw new ZipException(e.getMessage() != null ? e.getMessage() : \"Invalid ZLIB data format\");\n             }\n\n             // Update CRC with successfully inflated bytes\n             if (read > 0) {\n                  crc.update(buffer, start, read);\n             }\n\n             // Check again if finished after inflation attempt\n             if (inf.finished()) {\n                  // If finished and we read 0 bytes this time, signal EOF.\n                  // If we read > 0 bytes, return them; the next call will return -1.\n                  if (read == 0) {\n                      return -1;\n                  }\n             }\n\n             // Return the number of bytes read (could be 0 if inflate couldn't produce output yet)\n             return read;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}