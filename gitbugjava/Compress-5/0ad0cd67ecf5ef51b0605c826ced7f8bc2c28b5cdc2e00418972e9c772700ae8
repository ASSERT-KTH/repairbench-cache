{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        // Check for finished inflater or null current entry first\n        // (current becomes null if closeEntry is called or stream ends)\n        if (current == null) {\n            return -1;\n        }\n        // If inflater finished for the current entry, return EOF for this entry\n        // Note: This check is primarily for DEFLATED entries. STORED entries\n        // handle EOF based on size or underlying stream EOF.\n        // Checking inf.finished() here is safe but might be redundant for STORED.\n        if (inf.finished()) {\n             return -1;\n        }\n\n\n        // Parameter validation (check array bounds)\n        if (start < 0 || length < 0 || start > buffer.length || length > buffer.length - start) {\n             throw new ArrayIndexOutOfBoundsException(\"Offset=\"+ start + \", length=\"+ length + \", buffer size=\" + buffer.length);\n        }\n\n        // Handle zero length read efficiently\n        if (length == 0) {\n            return 0;\n        }\n\n        try {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                // --- STORED Entry Logic ---\n                // Size might be unknown (-1), especially if using data descriptor\n                long csize = current.getSize();\n\n                // Check if we have already read the declared size (if known)\n                if (csize >= 0 && readBytesOfEntry >= csize) {\n                    return -1; // End of entry reached\n                }\n\n                // Need to read more from the underlying stream into our internal buffer?\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0; // Reset buffer offset\n                    lengthOfLastRead = in.read(buf); // Read data into internal buffer 'buf'\n\n                    if (lengthOfLastRead == -1) {\n                        // We hit EOF of the underlying stream.\n                        // If size is known (csize >= 0) and we haven't read it all yet, it's truncated.\n                        if (csize >= 0 && readBytesOfEntry < csize) {\n                             throw new IOException(\"Truncated ZIP file\");\n                        }\n                        // If size is unknown OR size is known and fully read, this is normal EOF for the entry.\n                        return -1;\n                    }\n                    // Successfully read some data from the stream\n                    count(lengthOfLastRead); // Update stats\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n\n                // Calculate how much data to copy from our internal buffer ('buf')\n                // to the user's buffer ('buffer').\n                int toRead = Math.min(length, lengthOfLastRead - offsetInBuffer);\n\n                // If entry size is known, ensure we don't read beyond it\n                if (csize >= 0) {\n                    long remainingInEntry = csize - readBytesOfEntry;\n                    // Check if we've already read enough (should be caught earlier, but defense-in-depth)\n                    if (remainingInEntry <= 0) {\n                         return -1;\n                    }\n                    // Limit toRead to not exceed the declared size\n                    if (remainingInEntry < toRead) {\n                        toRead = (int)remainingInEntry; // Safe cast as toRead was smaller or equal\n                    }\n                }\n\n                // If toRead calculated to 0 (e.g. size limit hit exactly), return EOF\n                // This check might be redundant given the checks above, but ensures correctness.\n                if (toRead == 0) {\n                    return -1;\n                }\n\n                // Copy data to user buffer\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n\n                // Update internal state\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead; // Increment bytes read for this entry\n                crc.update(buffer, start, toRead); // Update CRC checksum\n\n                return toRead; // Return number of bytes read in this call\n\n            } else {\n                // --- DEFLATED (or other compressed) Entry Logic ---\n\n                // Does the inflater need more input data?\n                if (inf.needsInput()) {\n                    fill(); // Attempt to read from 'in' and feed the inflater\n                    // 'fill' updates 'lengthOfLastRead'. If it's -1, EOF was hit by 'in.read(buf)'.\n                    if (lengthOfLastRead > 0) {\n                        bytesReadFromStream += lengthOfLastRead;\n                    }\n                     // No special handling needed here if lengthOfLastRead == -1;\n                     // the subsequent inf.inflate() call will handle the EOF condition.\n                }\n\n                // Attempt to decompress data into the user's buffer\n                int read = 0;\n                try {\n                    read = inf.inflate(buffer, start, length);\n                } catch (DataFormatException e) {\n                    throw new ZipException(\"Bad data formatting on entry \" + current.getName() + \": \" + e.getMessage());\n                }\n\n                // Update CRC with the decompressed data\n                crc.update(buffer, start, read);\n\n                // Analyze the result of inf.inflate()\n                if (read == 0) {\n                    if (inf.finished()) {\n                        // Inflater finished normally for this entry. Signal EOF for entry.\n                        return -1;\n                    }\n                    if (inf.needsInput()) {\n                        // Inflater needs more input, but inflate() returned 0 bytes.\n                        // This implies fill() couldn't provide data, likely because\n                        // the underlying stream 'in' reached EOF prematurely.\n                        // This is the truncation condition for DEFLATED entries.\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // Case: read == 0, !inf.finished(), !inf.needsInput() -> unusual state.\n                    // This can happen, e.g., after Z_SYNC_FLUSH. Standard InflaterInputStream\n                    // returns 0 in this case, allowing the caller to retry.\n                }\n                // Return the number of bytes decompressed (read >= 0)\n                return read;\n            }\n        } catch (IOException e) {\n            throw e; // Rethrow IOExceptions (including our \"Truncated ZIP file\" exception)\n        }\n        // No RuntimeException catch needed unless specific handling is desired.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}