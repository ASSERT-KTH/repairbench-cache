{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        // Check if current entry is finished or null\n        // Finish check has to be made here, as handleStoredEntries expects\n        // current.getSize() to be valid.\n        if (current == null || inf.finished()) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer, check parameters\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n\n            if (length == 0) { // Handle 0 length read early\n                 return 0;\n            }\n\n            // Check method and process accordingly\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                // === STORED Logic ===\n                // Use the current entry size as the condition for ending the stream\n                int csize = (int) current.getSize();\n\n                // Check if already read expected size\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n\n                // Need more data from underlying stream?\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    lengthOfLastRead = in.read(buf); // Read next block\n                    if (lengthOfLastRead == -1) {\n                        // EOF hit before expected size reached indicates truncation\n                        // Note: readBytesOfEntry must be less than csize if we are here,\n                        // because the check at the start handles readBytesOfEntry >= csize.\n                       throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // Update counters for bytes read from stream\n                    count(lengthOfLastRead); // Assume this counts raw bytes for other purposes\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n\n                // Calculate how much to copy from 'buf' to 'buffer' in this call\n                int toRead = Math.min(length, lengthOfLastRead - offsetInBuffer);\n\n                // Ensure we don't read beyond the declared entry size\n                long remainingInEntry = csize - readBytesOfEntry;\n                if (remainingInEntry < toRead) {\n                    // Only read up to the declared size\n                    toRead = (int) remainingInEntry; // Cast is safe as csize is int\n                }\n\n                // Copy data to output buffer\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead; // Advance position in internal buffer 'buf'\n                readBytesOfEntry += toRead; // Update count of bytes read for this entry\n                crc.update(buffer, start, toRead); // Update CRC\n                return toRead; // Return bytes read in this call\n\n            } else { // Assuming DEFLATED if not STORED\n                // === DEFLATED Logic ===\n                if (inf.needsInput()) {\n                    fill(); // Tries to read more data into 'buf', sets 'lengthOfLastRead'\n                            // and calls inf.setInput()\n                    if (lengthOfLastRead > 0) {\n                        // Update counter for raw bytes read from underlying stream\n                        bytesReadFromStream += lengthOfLastRead;\n                    }\n                    // If lengthOfLastRead is -1 (EOF), we still proceed to inflate\n                    // as the inflater might have buffered data.\n                }\n\n                int read = 0;\n                try {\n                    // Attempt to inflate data into the output buffer\n                    read = inf.inflate(buffer, start, length);\n                } catch (DataFormatException e) {\n                    // DataFormatException often indicates corrupt/truncated compressed data\n                    throw new IOException(\"Truncated ZIP file\", e);\n                }\n\n                // Check the result of inflate()\n                if (read == 0) {\n                    if (inf.finished()) {\n                        // Normal end of compressed data for this entry.\n                        return -1;\n                    }\n                    // read == 0 but inflater is not finished.\n                    if (inf.needsInput() && lengthOfLastRead == -1) {\n                        // Inflater needs input, but the last call to fill() hit EOF.\n                        // This indicates the compressed stream was truncated.\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // Otherwise (e.g., output buffer full, or fill returned 0), return 0.\n                    // The caller's loop should handle retrying the read.\n                } else {\n                    // read > 0: Successfully inflated some bytes\n                    crc.update(buffer, start, read); // Update CRC with inflated bytes\n                    readBytesOfEntry += read; // Update count of (uncompressed) bytes read for this entry\n                }\n                return read; // Return number of bytes inflated (can be 0 if !finished and !truncated)\n            }\n        }\n        // If parameters are invalid (original condition was false)\n        throw new ArrayIndexOutOfBoundsException();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}