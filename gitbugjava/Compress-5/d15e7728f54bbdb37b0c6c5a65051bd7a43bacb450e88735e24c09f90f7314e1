{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            // If the entry is STORED, then we can exactly check the size.\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                // If the buffer is empty, read a new block of data.\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        // Reached EOF prematurely.\n                        // Throw if the entry is not complete\n                        if (csize > readBytesOfEntry) {\n                             throw new IOException(\"Truncated ZIP file\");\n                        }\n                        // Should be -1, but again, the contract is vague,\n                        // and the original code returned -1 here. Keep it for now\n                        // unless further tests show issues.\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                // Determine how much to read\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                // Ensure we don't read more than the claimed size\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                // Copy data\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                // Update counters\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n\n            // If the entry is DEFLATED...\n            // Fill the inflater buffer if necessary\n            if (inf.needsInput()) {\n                fill();\n                // If the fill ended up reading EOF from the underlying stream,\n                // but the inflater is not finished, then the file is truncated.\n                if (lengthOfLastRead == -1) {\n                    // Only throw if inf hasn't signalled end AND needs input\n                    if (!inf.finished()) {\n                         throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // If inflater finished and fill got EOF, it's a normal ending.\n                    // Fall through to inflate, which should return 0 and signal finished.\n                } else if (lengthOfLastRead > 0) { // Only count if data was actually read\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n\n            // Decompress data\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                // Data format exception implies corrupt data, map to ZipException\n                // which is an IOException.\n                throw new ZipException(e.getMessage() != null ? e.getMessage() : \"Invalid ZLIB data format\");\n            }\n\n            // If inflate returns 0 and is finished, we are at the end of the entry\n            if (read == 0 && inf.finished()) {\n                return -1;\n            }\n\n            // Update CRC and return bytes read\n            if (read > 0) {\n                crc.update(buffer, start, read);\n            }\n            return read;\n        }\n        // Invalid arguments\n        throw new ArrayIndexOutOfBoundsException();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}