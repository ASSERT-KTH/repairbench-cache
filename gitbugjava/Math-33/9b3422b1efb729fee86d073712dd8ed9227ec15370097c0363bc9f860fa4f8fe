{
    "generation": "    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        // Do NOT drop the RHS column (index 0)\n        // columnsToDrop.add(0); // Buggy line removed\n\n        // identify columns corresponding to positive cost non-artificial variables\n        // in the phase 1 objective row\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            // Check Precision.compareTo first as it is tolerant to floating point arithmetic errors.\n            // Drop the column if the entry is greater than zero using Precision.compareTo.\n            // Drop the column if the entry is equal to zero and we are minimizing the objective function.\n            // Note: The second check is not necessary for the example test case but might be needed for other cases.\n            // However, sticking to the original logic of only dropping if > 0 based on Precision seems safer\n            // without more context or failing tests requiring the equals check.\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // identify columns corresponding to non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) { // Variable is non-basic\n            columnsToDrop.add(col);\n          }\n        }\n\n        // Create the new matrix excluding the first row (phase 1 objective) and the identified columns\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) { // Start from row 1 to skip phase 1 objective row\n          int newMatrixCol = 0;\n          for (int j = 0; j < getWidth(); j++) { // Iterate through original columns\n            if (!columnsToDrop.contains(j)) { // Check if the column should be kept\n              matrix[i - 1][newMatrixCol++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        // Remove labels for the dropped columns (iterate backwards to avoid index issues)\n        // Ensure columnsToDrop is sorted or handle removal carefully if it's not inherently sorted.\n        // ArrayList preserves insertion order, which matches the column index order here.\n        // Iterating backwards is the standard way to remove multiple items from a list by index.\n        Collections.sort(columnsToDrop, Collections.reverseOrder()); // Sort descending for safe removal\n        for (int colIndex : columnsToDrop) {\n          columnLabels.remove(colIndex);\n        }\n\n        // Update the tableau and artificial variable count\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0; // Phase 1 is done, no more artificial variables needed conceptually\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}