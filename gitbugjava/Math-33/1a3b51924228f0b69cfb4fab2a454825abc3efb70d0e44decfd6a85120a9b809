{
    "generation": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.util.Precision;\n\n// Imports added for context. Assume necessary member variables like\n// tableau, numArtificialVariables, numObjectiveFunctions, columnLabels, basicRows, maxUlps\n// and methods like getNumObjectiveFunctions, getArtificialVariableOffset, getHeight,\n// getWidth, getBasicRow, getNumArtificialVariables exist within the class.\n\n    /**\n     * Removes the phase 1 objective function, columns corresponding to the\n     * phase 1 objective function value and non-basic artificial variables\n     * from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return; // Already in phase 2 or no artificial variables needed\n        }\n\n        // Identify columns to drop:\n        // We need to drop the column holding the value of the phase 1 objective function 'W'.\n        // Based on the constructor logic (tableau.setEntry(0, 1, -1) when artificials > 0),\n        // column 1 seems to serve this purpose.\n        // We also drop columns corresponding to non-basic artificial variables.\n        Set<Integer> columnsToDropSet = new HashSet<>();\n\n        // Drop column 1 (assumed to be phase 1 objective value 'W')\n        // This column is only relevant during phase 1.\n        if (getWidth() > 1) { // Check if column 1 exists\n            columnsToDropSet.add(1);\n        }\n\n\n        // Drop columns corresponding to non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n            int col = i + getArtificialVariableOffset();\n            // Check if the artificial variable in column 'col' is basic.\n            // getBasicRow(col) returns the row index if basic, null otherwise.\n            if (getBasicRow(col) == null) { // If artificial variable is non-basic\n                columnsToDropSet.add(col);\n            }\n            // Note: Basic artificial variables might remain if they correspond to\n            // redundant constraints. Their columns are kept for now, but the variable\n            // count numArtificialVariables will be set to 0.\n        }\n\n        // Create a sorted list of unique column indices to drop\n        List<Integer> sortedColumnsToDrop = new ArrayList<>(columnsToDropSet);\n        Collections.sort(sortedColumnsToDrop);\n\n        // Create the new tableau matrix:\n        // Height decreases by 1 (removing phase 1 objective row 0).\n        // Width decreases by the number of columns dropped.\n        double[][] matrix = new double[getHeight() - 1][getWidth() - sortedColumnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) { // Iterate through old rows, skipping row 0\n            int newCol = 0;\n            int dropIdx = 0; // Index into sortedColumnsToDrop\n            for (int j = 0; j < getWidth(); j++) { // Iterate through old columns\n                boolean dropCurrentCol = false;\n                // Check if the current old column 'j' should be dropped\n                if (dropIdx < sortedColumnsToDrop.size() && j == sortedColumnsToDrop.get(dropIdx)) {\n                    dropCurrentCol = true;\n                    dropIdx++;\n                }\n\n                if (!dropCurrentCol) {\n                    // Copy the entry to the new matrix. Row index is i-1.\n                    matrix[i - 1][newCol++] = tableau.getEntry(i, j);\n                }\n            }\n        }\n\n        // Update column labels (removing labels for dropped columns)\n        List<String> newLabels = new ArrayList<>();\n        int dropIdx = 0; // Index into sortedColumnsToDrop\n        for (int j = 0; j < columnLabels.size(); j++) { // Iterate through old labels by index\n            boolean dropCurrentLabel = false;\n            // Check if the current old column index 'j' should be dropped\n            if (dropIdx < sortedColumnsToDrop.size() && j == sortedColumnsToDrop.get(dropIdx)) {\n                dropCurrentLabel = true;\n                dropIdx++;\n            }\n            if (!dropCurrentLabel) {\n                newLabels.add(columnLabels.get(j));\n            }\n        }\n        this.columnLabels = newLabels; // Replace the old list\n\n\n        // Update the map of basic variables (basicRows)\n        // Column indices shift left, row indices shift up by 1.\n        Map<Integer, Integer> newBasicRows = new HashMap<>();\n        for (Map.Entry<Integer, Integer> entry : basicRows.entrySet()) {\n            int oldColIndex = entry.getKey();\n            int rowIndex = entry.getValue(); // Row index in the old tableau\n\n            // Check if the column of this basic variable was dropped\n            if (columnsToDropSet.contains(oldColIndex)) {\n                // This basic variable's column was dropped. Remove it from the map.\n                // This should generally not happen for essential variables, but could\n                // occur if a basic artificial variable corresponding to a truly\n                // redundant constraint was somehow targeted for removal (though current\n                // logic only targets non-basic artificials).\n                continue;\n            }\n\n            // Calculate the new column index for this basic variable\n            int numDroppedBefore = 0;\n            for (int droppedCol : sortedColumnsToDrop) {\n                if (droppedCol < oldColIndex) {\n                    numDroppedBefore++;\n                } else {\n                    break; // sortedColumnsToDrop is sorted\n                }\n            }\n            int newColIndex = oldColIndex - numDroppedBefore;\n\n            // Row indices shift up by 1 because row 0 was removed.\n            // The row index must be > 0 as row 0 was the objective row.\n            if (rowIndex > 0) {\n                 newBasicRows.put(newColIndex, rowIndex - 1);\n            }\n             // else: Basic variable was in row 0? Should not happen in feasible phase 1 end. Ignore/log error?\n        }\n        this.basicRows = newBasicRows;\n\n        // Update the tableau state\n        this.tableau = new Array2DRowRealMatrix(matrix, false); // Use the new matrix (false = don't copy)\n        this.numArtificialVariables = 0; // Phase 1 artifacts are removed or accounted for\n        this.numObjectiveFunctions = 1; // Only the original objective remains\n        // Width and Height are implicitly updated by using the new tableau matrix.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}