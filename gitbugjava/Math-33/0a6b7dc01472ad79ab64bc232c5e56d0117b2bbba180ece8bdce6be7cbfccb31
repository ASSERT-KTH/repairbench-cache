{
    "generation": "import java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.util.Precision; // Keep import in case it's needed by helpers, though not directly used in the fixed logic\n\n// The context assumes this method is part of a SimplexTableau class with access\n// to methods like getNumObjectiveFunctions, getArtificialVariableOffset,\n// getNumArtificialVariables, getBasicRow, getHeight, getWidth, and fields\n// like tableau (RealMatrix), columnLabels (List<String>), numArtificialVariables (int), maxUlps (int).\n\n    /**\n     * Removes the phase 1 objective function row (row 0) and columns corresponding to\n     * non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        // If there's only one objective function, it implies Phase 1 was not used or\n        // has already been dropped. Nothing to do.\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        // List to store the indices of columns that should be dropped.\n        List<Integer> columnsToDrop = new ArrayList<>();\n\n        // Identify columns corresponding to non-basic artificial variables.\n        // Artificial variable columns are located starting from getArtificialVariableOffset().\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int colIndex = i + getArtificialVariableOffset();\n          // getBasicRow(colIndex) returns the index of the basic row for this column,\n          // or null if the variable is non-basic.\n          if (getBasicRow(colIndex) == null) {\n            // If the artificial variable is non-basic, mark its column for removal.\n            columnsToDrop.add(colIndex);\n          }\n        }\n\n        // Create the data array for the new tableau matrix.\n        // The new matrix will have one less row (the Phase 1 objective row 0 is removed).\n        // The width will be reduced by the number of dropped columns.\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n\n        // Populate the new matrix by copying relevant entries from the old tableau.\n        for (int i = 1; i < getHeight(); i++) { // Iterate through rows of the original tableau, skipping row 0.\n          int newMatrixColumnIndex = 0;\n          for (int j = 0; j < getWidth(); j++) { // Iterate through columns of the original tableau.\n            // Check if the current original column 'j' is one of the columns to be dropped.\n            // Using contains() is efficient enough for typical numbers of artificial variables.\n            if (!columnsToDrop.contains(j)) {\n              // If the column should be kept, copy the entry to the new matrix.\n              // Original row 'i' maps to new row 'i-1'.\n              // Original column 'j' maps to new column 'newMatrixColumnIndex'.\n              matrix[i - 1][newMatrixColumnIndex++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        // Remove the labels corresponding to the dropped columns from the columnLabels list.\n        // It's crucial to iterate backwards when removing elements by index from a List\n        // to avoid index shifting issues. Sorting columnsToDrop is not necessary here.\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          // Ensure the index is treated as an int for remove(int index) method.\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        // Update the tableau to use the newly created matrix.\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        // Reset the count of artificial variables, as Phase 1 is complete and these\n        // variables (or their tracking) are no longer needed for Phase 2.\n        this.numArtificialVariables = 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}