{
    "generation": "import java.util.Locale;\n\n// The surrounding class structure is omitted as per the request.\n// Assume necessary imports like java.util.Locale are present.\n\n    /**\n     * <p>Converts a String to a Locale.</p>\n     *\n     * <p>This method takes the string format of a locale and creates the\n     * locale object from it.</p>\n     *\n     * <pre>\n     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n     *   LocaleUtils.toLocale(\"en__POSIX\")  = new Locale(\"en\", \"\", \"POSIX\")\n     *   LocaleUtils.toLocale(\"_GB\")        = new Locale(\"\", \"GB\", \"\")\n     *   LocaleUtils.toLocale(\"_GB_POSIX\")  = new Locale(\"\", \"GB\", \"POSIX\")\n     * </pre>\n     *\n     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n     *\n     * <p>This method validates the input strictly.\n     * The language code must be lowercase letters. The language code must be exactly two letters.\n     * The country code must be uppercase letters. The country code must be exactly two letters.\n     * The separator must be an underscore.\n     * The length must be correct. Format examples: {@code ll}, {@code ll_CC}, {@code ll_CC_variant},\n     * {@code ll__variant}, {@code _CC}, {@code _CC_variant}.</p>\n     *\n     * @param str  the locale String to convert, null returns null\n     * @return a Locale, null if null input\n     * @throws IllegalArgumentException if the string is an invalid format\n     */\n    public static Locale toLocale(final String str) {\n        if (str == null) {\n            return null;\n        }\n        final int len = str.length();\n        // Ensure specific length constraints are met later, but prevent IndexOutOfBounds early.\n        if (len == 0) {\n             // An empty string is not a valid locale format.\n             throw new IllegalArgumentException(\"Invalid locale format: \\\"\\\"\");\n        }\n\n        // Handle formats starting with '_' like _CC or _CC_variant (LANG-865)\n        if (str.charAt(0) == '_') {\n            if (len < 3) { // Must be at least _CC (\"_GB\")\n                // This covers \"_\" (len 1) and \"_G\" (len 2) failing cases from the test.\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final char ch1 = str.charAt(1);\n            final char ch2 = str.charAt(2);\n            // Check country code: 2 uppercase letters (as specified by tests _Gb, _gB, _1B, _G1)\n            if (!Character.isLetter(ch1) || !Character.isUpperCase(ch1) ||\n                !Character.isLetter(ch2) || !Character.isUpperCase(ch2)) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 3) { // Format _CC (\"_GB\")\n                return new Locale(\"\", str.substring(1)); // language=\"\", country=\"GB\"\n            }\n            // Check for variant part _CC_variant (\"_GB_POSIX\")\n            // It needs to be at least 5 chars long (\"_CC_v\") and have an underscore at index 3.\n            // Test cases \"_GB_\" (len 4), \"_GBAP\" (len 5, wrong separator) fail here.\n            // Test case \"_G\" (len 2) failed above. Test case \"_GB\" (len 3) is handled above.\n            // Test case \"_GB_P\" (len 5) is handled below. Test case \"_GB_POSIX\" (len 9) is handled below.\n            if (len < 5 || str.charAt(3) != '_') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            // Check variant is not empty - Test case \"_GB_\" (len 5 with valid separator but empty variant) fails here.\n            final String variant = str.substring(4);\n            if (variant.isEmpty()) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            // Format _CC_variant (\"_GB_POSIX\")\n            return new Locale(\"\", str.substring(1, 3), variant); // language=\"\", country=\"GB\", variant=\"POSIX\"\n        }\n\n        // Original logic for ll, ll_CC, ll_CC_variant, plus ll__variant fix\n\n        // Format: ll... (\"en...\")\n        // Language code check requires minimum length 2.\n        if (len < 2) {\n             // This case should not be reachable due to the len == 0 check above\n             // and the fact that strings starting with '_' are handled separately.\n             // Any string reaching here must have len >= 1 and not start with '_'.\n             // If len == 1, it fails the language check below.\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        // Check language: 2 lowercase letters.\n        final char ch0 = str.charAt(0);\n        final char ch1 = str.charAt(1);\n        // The Javadoc says \"lowercase letters\", isLowerCase() should suffice.\n        // It implicitly checks they are letters too for standard alphabets.\n        if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n\n        if (len == 2) { // Format ll (\"en\")\n            return new Locale(str); // language=\"en\", country=\"\", variant=\"\"\n        }\n\n        // Format: ll_... (\"en_...\")\n        // Needs separator and country/variant part. Minimum length 5 (ll_CC or ll__v).\n        if (len < 5) {\n            // This covers \"en_\", \"en_G\" which are invalid.\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        // Check separator after language.\n        if (str.charAt(2) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n\n        final char ch3 = str.charAt(3);\n        // Check for format ll__variant (\"en__POSIX\")\n        if (ch3 == '_') {\n            // Minimum length 6 (\"ll__v\").\n            if(len < 6) { // Handles \"en___\" invalid case\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            final String variant = str.substring(5);\n            // Check variant is not empty (\"en__\").\n            if (variant.isEmpty()) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            // Format ll__variant (\"en__POSIX\")\n            return new Locale(str.substring(0, 2), \"\", variant); // language=\"en\", country=\"\", variant=\"POSIX\"\n        }\n\n        // Format ll_CC... (\"en_GB...\")\n        final char ch4 = str.charAt(4);\n        // Check country code: 2 uppercase letters (similar to _CC check).\n        if (!Character.isLetter(ch3) || !Character.isUpperCase(ch3) ||\n            !Character.isLetter(ch4) || !Character.isUpperCase(ch4)) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n\n        if (len == 5) { // Format ll_CC (\"en_GB\")\n            return new Locale(str.substring(0, 2), str.substring(3, 5)); // language=\"en\", country=\"GB\", variant=\"\"\n        }\n\n        // Format ll_CC_variant (\"en_GB_POSIX\")\n        // Minimum length 7 (\"ll_CC_v\").\n        if (len < 7) { // Handles \"en_GB_\" invalid case\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        // Check separator after country.\n        if (str.charAt(5) != '_') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        final String variant = str.substring(6);\n        // Check variant is not empty (\"en_GB_\").\n        if (variant.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        // Format ll_CC_variant (\"en_GB_POSIX\")\n        return new Locale(str.substring(0, 2), str.substring(3, 5), variant); // language=\"en\", country=\"GB\", variant=\"POSIX\"\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}