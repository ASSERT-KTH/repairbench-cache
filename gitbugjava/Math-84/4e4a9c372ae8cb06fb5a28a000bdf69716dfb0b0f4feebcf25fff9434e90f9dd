{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        incrementIterationsCounter();\n\n        // Save the simplex state BEFORE iteration\n        final RealPointValuePair[] original = new RealPointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, original, 0, simplex.length);\n        final RealPointValuePair originalBest = original[0];\n\n        // Perform reflection step. evaluateNewSimplex potentially modifies 'simplex'.\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        // Save the simplex state AFTER reflection.\n        final RealPointValuePair[] reflectedSimplexState = new RealPointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, reflectedSimplexState, 0, simplex.length);\n        // Get the best point *after* the reflection evaluation potentially modified the simplex\n        final RealPointValuePair reflectedBest = simplex[0];\n\n        // Check if reflection improved compared to the original best.\n        if (comparator.compare(reflectedBest, originalBest) < 0) {\n            // Reflection improved. Try expansion.\n            // Compute expansion based on the original simplex state.\n            // evaluateNewSimplex potentially modifies 'simplex' again.\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            // Get the best point *after* the expansion evaluation potentially modified the simplex\n            final RealPointValuePair expandedBest = simplex[0];\n\n            // Check if expansion provided a better result than reflection.\n            // Compare the best point after expansion ('expandedBest') vs best point after reflection ('reflectedBest').\n            if (comparator.compare(expandedBest, reflectedBest) >= 0) {\n                // Expansion was not better, restore the reflected state.\n                System.arraycopy(reflectedSimplexState, 0, simplex, 0, simplex.length);\n            }\n            // else: Expansion is better, accept it. 'simplex' is already in the expanded state.\n\n            // Return after reflection/expansion phase\n            return;\n        }\n\n        // Reflection did not improve (or stayed the same). Try contraction.\n        // Compute contraction based on the original simplex state.\n        // evaluateNewSimplex potentially modifies 'simplex'.\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        // Get the best point *after* the contraction evaluation potentially modified the simplex\n        final RealPointValuePair contractedBest = simplex[0];\n\n        // Check if contraction improved compared to the original best.\n        if (comparator.compare(contractedBest, originalBest) < 0) {\n            // Contraction improved, accept it. 'simplex' is already in the contracted state.\n            // Return after contraction phase\n            return;\n        }\n\n        // Neither reflection (improving on original best) nor contraction (improving on original best) occurred.\n        // The simplex state is currently the one resulting from the contraction attempt,\n        // which might or might not be different from the state after the reflection attempt,\n        // depending on whether evaluateNewSimplex replaced the worst point during contraction.\n        // In standard Nelder-Mead, a shrink step would happen here if contraction failed to improve.\n        // This implementation lacks an explicit shrink step here. We just return.\n        // The calling optimize loop handles convergence checks.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}