{
    "generation": "    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        if (codec == CODEC_GH3000) {\n\n            int globalMask = 0x0f; // Default mask for GH3000 if not present\n\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            // Check if the full data structure including global mask is present\n            if (buf.readableBytes() > 16) { // Heuristic: Check if there's enough data for mask + location block\n                 globalMask = buf.readUnsignedByte();\n            }\n\n            if (BitUtil.check(globalMask, 0)) { // Location Data\n\n                position.setTime(new Date(time * 1000));\n\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n\n                if (BitUtil.check(locationMask, 5)) { // Cell Tower Info\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n\n                    if (BitUtil.check(locationMask, 6)) { // Signal Strength\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n\n                    if (BitUtil.check(locationMask, 7)) { // Operator\n                        cellTower.setOperator(buf.readUnsignedInt());\n                    }\n\n                    position.setNetwork(new Network(cellTower));\n\n                } else { // If no Cell Tower, check for RSSI and Operator separately\n                    if (BitUtil.check(locationMask, 6)) { // RSSI\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) { // Operator\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt());\n                    }\n                }\n\n            } else {\n                // No location data in this record\n                getLastLocation(position, new Date(time * 1000));\n            }\n\n            // Read 1 byte IO data based on globalMask\n            if (BitUtil.check(globalMask, 1)) {\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 1, codec, model);\n                }\n            }\n\n            // Read 2 byte IO data based on globalMask\n            if (BitUtil.check(globalMask, 2)) {\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 2, codec, model);\n                }\n            }\n\n            // Read 4 byte IO data based on globalMask\n            if (BitUtil.check(globalMask, 3)) {\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 4, codec, model);\n                }\n            }\n            // Note: GH3000 typically doesn't use 8, 16, or X byte IO in the same way as Codec 8/8E/16\n\n        } else {\n            // Logic for Codec 8, 8 Extended, 16\n\n            position.setTime(new Date(buf.readLong()));\n            position.set(\"priority\", buf.readUnsignedByte());\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n            position.setValid(satellites != 0);\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            position.set(Position.KEY_EVENT, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16));\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type (specific to Codec 16, often ignored)\n            }\n\n            readExtByte(buf, codec, CODEC_8_EXT); // total IO data records count (ignored, we read N1, N2 etc.)\n\n            // Read IO Elements based on Teltonika Codec 8 / 8 Ext / 16 structure\n\n            // Read N1 count and items (1 byte value)\n            int cnt1 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt1; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 1, codec, model);\n            }\n\n            // Read N2 count and items (2 bytes value)\n            int cnt2 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt2; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 2, codec, model);\n            }\n\n            // Read N4 count and items (4 bytes value)\n            int cnt4 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt4; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 4, codec, model);\n            }\n\n            // Read N8 count and items (8 bytes value)\n            int cnt8 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt8; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 8, codec, model);\n            }\n\n            // Read NX count and items (Variable length, only for Codec 8 Extended)\n            if (codec == CODEC_8_EXT) {\n                int cntX = buf.readUnsignedShort(); // NX count is always 2 bytes\n                for (int j = 0; j < cntX; j++) {\n                    int id = buf.readUnsignedShort(); // NX ID is always 2 bytes\n                    int length = buf.readUnsignedShort(); // NX length is always 2 bytes\n                    if (length > buf.readableBytes()) {\n                         // Avoid IndexOutOfBoundsException if reported length is wrong\n                         throw new IndexOutOfBoundsException(\n                             \"Declared Data Length (\" + length + \") exceeds available buffer data (\"\n                             + buf.readableBytes() + \") for variable IO ID \" + id);\n                    }\n                    if (id == 256) { // VIN\n                        position.set(Position.KEY_VIN,\n                                buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                    } else if (id == 281) { // DTCs\n                        position.set(Position.KEY_DTCS,\n                                buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                    } else if (id == 385) { // Beacons\n                        ByteBuf data = buf.readSlice(length);\n                        if (data.readableBytes() > 0) {\n                            data.readUnsignedByte(); // data part (always 0?)\n                            int index = 1;\n                            while (data.isReadable()) {\n                                if (data.readableBytes() < 1) break; // Ensure flags byte exists\n                                int flags = data.readUnsignedByte();\n                                if (BitUtil.from(flags, 4) > 0) { // iBeacon\n                                     if (data.readableBytes() < 20) break; // Need 16+2+2 bytes\n                                     position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                                     position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                                     position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                                } else { // Eddystone\n                                     if (data.readableBytes() < 16) break; // Need 10+6 bytes\n                                     position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10)));\n                                     position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));\n                                }\n                                if (data.readableBytes() < 1) break; // Need RSSI byte\n                                position.set(\"beacon\" + index + \"Rssi\", (int) data.readByte());\n                                if (BitUtil.check(flags, 1)) { // Battery present\n                                     if (data.readableBytes() < 2) break;\n                                     position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.01);\n                                }\n                                if (BitUtil.check(flags, 2)) { // Temperature present\n                                     if (data.readableBytes() < 2) break;\n                                     position.set(\"beacon\" + index + \"Temp\", data.readUnsignedShort());\n                                }\n                                index += 1;\n                             }\n                         }\n                    } else { // Generic variable length IO\n                        position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                    }\n                }\n            }\n\n            // Read N16 count and items (Seems specific to 'extended' mode, interpretation might vary)\n            // This was present in the buggy code's else block, structure kept for compatibility attempt.\n            if (extended) {\n                 int cnt16 = readExtByte(buf, codec, CODEC_8_EXT); // N16 count\n                 for (int j = 0; j < cnt16; j++) {\n                     int id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16); // N16 ID\n                     if (buf.readableBytes() >= 16) {\n                         position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(16))); // N16 Value\n                     } else {\n                         // Avoid IndexOutOfBoundsException\n                         throw new IndexOutOfBoundsException(\n                             \"Not enough data for 16-byte IO value for ID \" + id);\n                     }\n                 }\n            }\n        }\n\n        // Common post-processing\n        decodeNetwork(position, model);\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}