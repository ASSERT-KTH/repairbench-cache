{
    "generation": "    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        if (codec == CODEC_GH3000) {\n\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            int globalMask = buf.readUnsignedByte(); // globalMask is specific to CODEC_GH3000\n            if (BitUtil.check(globalMask, 0)) { // Location data is present\n\n                position.setTime(new Date(time * 1000));\n\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n\n                if (BitUtil.check(locationMask, 5)) {\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n\n                    if (BitUtil.check(locationMask, 6)) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n\n                    if (BitUtil.check(locationMask, 7)) {\n                        cellTower.setOperator(buf.readUnsignedInt());\n                    }\n\n                    position.setNetwork(new Network(cellTower));\n\n                } else { // locationMask bit 5 is false\n                    if (BitUtil.check(locationMask, 6)) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt());\n                    }\n                }\n\n            } else { // globalMask bit 0 is false\n\n                getLastLocation(position, new Date(time * 1000));\n\n            }\n\n            // Read 1 byte data for CODEC_GH3000\n            if (BitUtil.check(globalMask, 1)) {\n                int cnt = readExtByte(buf, codec, CODEC_8_EXT); // readExtByte will read 1 byte for non CODEC_8_EXT/CODEC_16\n                for (int j = 0; j < cnt; j++) {\n                    decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 1, codec, model);\n                }\n            }\n\n            // Read 2 byte data for CODEC_GH3000\n            if (BitUtil.check(globalMask, 2)) {\n                int cnt = readExtByte(buf, codec, CODEC_8_EXT);\n                for (int j = 0; j < cnt; j++) {\n                    decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 2, codec, model);\n                }\n            }\n\n            // Read 4 byte data for CODEC_GH3000\n            if (BitUtil.check(globalMask, 3)) {\n                int cnt = readExtByte(buf, codec, CODEC_8_EXT);\n                for (int j = 0; j < cnt; j++) {\n                    decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 4, codec, model);\n                }\n            }\n\n        } else { // For CODEC_8, CODEC_8_EXT, CODEC_16, etc.\n\n            position.setTime(new Date(buf.readLong()));\n\n            position.set(\"priority\", buf.readUnsignedByte());\n\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n\n            position.setValid(satellites != 0);\n\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            position.set(Position.KEY_EVENT, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16));\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type\n            }\n\n            // Total IO data records (propertiesCount) for CODEC_8/8_EXT/16\n            int ioCount = readExtByte(buf, codec, CODEC_8_EXT);\n\n            for (int j = 0; j < ioCount; j++) {\n                int id;\n                int length;\n\n                // For CODEC_8_EXT, X-byte IDs are 2 bytes, others are 1 byte.\n                // getParamLength needs to be part of TeltonikaProtocolDecoder.java, which it is.\n                // It determines length based on ID, and also reads the ID from buffer based on codec.\n                // The issue here is that this decodeLocation function does not have access to getParamLength as a method.\n                // The provided code snippet only has 'this' which is the TeltonikaProtocolDecoder object.\n                // The original code implies readExtByte(id) and then fixed lengths.\n                // The original X-byte block explicitly read `buf.readUnsignedShort()` for ID.\n\n                // Re-introducing Teltonika's typical IO parsing:\n                if (codec == CODEC_8_EXT && buf.readableBytes() >= 2) { // Assume X-byte parameters might appear\n                    // Peek ahead to see if the ID suggests an X-byte parameter that is 2 bytes long\n                    int peekedId = buf.getUnsignedShort(buf.readerIndex());\n                    if (TeltonikaProtocolDecoder.getParamLength(peekedId) == -1) { // If it's an X-byte ID\n                        id = buf.readUnsignedShort(); // Read 2-byte ID\n                        length = buf.readUnsignedShort(); // Read 2-byte length for X-byte value\n\n                        if (id == 256) {\n                            position.set(Position.KEY_VIN,\n                                    buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                        } else if (id == 281) {\n                            position.set(Position.KEY_DTCS,\n                                    buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                        } else if (id == 385) { // iBeacon data\n                            ByteBuf data = buf.readSlice(length);\n                            data.readUnsignedByte(); // data part\n                            int index = 1;\n                            while (data.isReadable()) {\n                                int flags = data.readUnsignedByte();\n                                if (BitUtil.from(flags, 4) > 0) {\n                                    position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                                    position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                                    position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                                } else {\n                                    position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10)));\n                                    position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));\n                                }\n                                position.set(\"beacon\" + index + \"Rssi\", (int) data.readByte());\n                                if (BitUtil.check(flags, 1)) {\n                                    position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.01);\n                                }\n                                if (BitUtil.check(flags, 2)) {\n                                    position.set(\"beacon\" + index + \"Temp\", data.readUnsignedShort());\n                                }\n                                index += 1;\n                            }\n                        } else {\n                            position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                        }\n                    } else { // Not an X-byte ID or not enough bytes to peek 2 bytes for CODEC_8_EXT\n                        // Read ID as 1 byte (typical for other fixed-size parameters in CODEC_8_EXT)\n                        id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16);\n                        length = TeltonikaProtocolDecoder.getParamLength(id); // Get length for 1-byte ID\n                        decodeParameter(position, id, buf, length, codec, model);\n                    }\n                } else { // For codecs other than CODEC_8_EXT or not enough bytes for peek\n                    id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16);\n                    length = TeltonikaProtocolDecoder.getParamLength(id);\n                    if (length == -1) { // Fallback for any other variable length parameter outside CODEC_8_EXT\n                        length = buf.readUnsignedShort();\n                        position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                    } else {\n                        decodeParameter(position, id, buf, length, codec, model);\n                    }\n                }\n            }\n        }\n\n        decodeNetwork(position, model);\n\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}