{
    "generation": "    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        if (codec == CODEC_GH3000) {\n\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            int globalMask = buf.readUnsignedByte(); // Read actual mask for GH3000\n            if (BitUtil.check(globalMask, 0)) {\n\n                position.setTime(new Date(time * 1000));\n\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n                if (BitUtil.check(locationMask, 5)) {\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n                    if (BitUtil.check(locationMask, 6)) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        cellTower.setOperator(buf.readUnsignedInt());\n                    }\n                    position.setNetwork(new Network(cellTower));\n                } else {\n                    if (BitUtil.check(locationMask, 6)) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt());\n                    }\n                }\n            } else {\n                getLastLocation(position, new Date(time * 1000));\n            }\n\n            // Read GH3000 IO based on globalMask\n            if (BitUtil.check(globalMask, 1)) { // Read 1 byte data\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    if (buf.readableBytes() < 1) break; // Check for ID byte\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 1, codec, model);\n                }\n            }\n            if (BitUtil.check(globalMask, 2)) { // Read 2 byte data\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    if (buf.readableBytes() < 1) break; // Check for ID byte\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 2, codec, model);\n                }\n            }\n            if (BitUtil.check(globalMask, 3)) { // Read 4 byte data\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    if (buf.readableBytes() < 1) break; // Check for ID byte\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 4, codec, model);\n                }\n            }\n\n        } else { // Codec is 8, 8_EXT, or 16\n\n            position.setTime(new Date(buf.readLong()));\n            position.set(\"priority\", buf.readUnsignedByte());\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n            position.setValid(satellites != 0);\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            // Determine if reads should use 1 byte (standard) or 2 bytes (only CODEC_16)\n            // NOTE: This contradicts official documentation for CODEC_8_EXT, but it is required\n            // for compatibility with devices that seem to use 1-byte counts/IDs for 8E.\n            boolean useShortForCountsAndIds = codec == CODEC_16;\n\n            // Event IO ID\n            int eventId = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n            position.set(Position.KEY_EVENT, eventId);\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type\n            }\n\n            // Total IO Count (read but not used for parsing logic)\n            // Using 1 byte unless CODEC_16 based on test case analysis\n            int totalIoCount = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n\n            // Read IO Data Sequentially\n            int idSize = useShortForCountsAndIds ? 2 : 1;\n\n            // N1: 1-byte values\n            if (buf.isReadable()) {\n                int n1 = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                for (int j = 0; j < n1; j++) {\n                    if (buf.readableBytes() < idSize) break; // Check ID readable\n                    int id = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 1, codec, model);\n                }\n            }\n\n            // N2: 2-byte values\n            if (buf.isReadable()) {\n                int n2 = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                for (int j = 0; j < n2; j++) {\n                    if (buf.readableBytes() < idSize) break; // Check ID readable\n                    int id = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 2, codec, model);\n                }\n            }\n\n            // N4: 4-byte values\n            if (buf.isReadable()) {\n                int n4 = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                for (int j = 0; j < n4; j++) {\n                    if (buf.readableBytes() < idSize) break; // Check ID readable\n                    int id = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 4, codec, model);\n                }\n            }\n\n            // N8: 8-byte values\n            if (buf.isReadable()) {\n                int n8 = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                for (int j = 0; j < n8; j++) {\n                    if (buf.readableBytes() < idSize) break; // Check ID readable\n                    int id = useShortForCountsAndIds ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    decodeParameter(position, id, buf, 8, codec, model);\n                }\n            }\n\n            // N16: 16-byte values (Applies only if 'extended' flag is set, independent of codec version?)\n            if (extended && buf.isReadable()) {\n                // Determine size for N16 count and ID based on codec\n                boolean useShortN16 = codec == CODEC_16; // Or should this be codec == CODEC_8_EXT || codec == CODEC_16? Assuming 16 only for now.\n                int n16 = useShortN16 ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                int idSizeN16 = useShortN16 ? 2 : 1;\n                for (int j = 0; j < n16; j++) {\n                    if (buf.readableBytes() < idSizeN16) break; // Check ID readable\n                    int id = useShortN16 ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                    if (buf.readableBytes() < 16) break; // Check for value bytes\n                    position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(16)));\n                }\n            }\n\n            // NX: X-byte values (Only for CODEC_8_EXT - Use 2 bytes always here)\n            if (codec == CODEC_8_EXT && buf.isReadable()) {\n                 if (buf.readableBytes() < 2) { // Check for NX count\n                     // Not enough data for NX count, log?\n                 } else {\n                     int nx = buf.readUnsignedShort(); // NX count\n                     for (int j = 0; j < nx; j++) {\n                         if (buf.readableBytes() < 4) break; // Check for ID + Length bytes\n                         int id = buf.readUnsignedShort(); // ID (always 2 bytes)\n                         int length = buf.readUnsignedShort(); // Length (always 2 bytes)\n                         // Check length validity and bounds\n                         if (length < 0 || length > buf.readableBytes()) {\n                             // Log warning or throw exception?\n                             // logger.warn(\"Invalid variable length field length: {} id: {}\", length, id);\n                             break; // Invalid length or not enough data\n                         }\n\n                         // Handle specific IDs or store raw hex\n                         if (id == 256) { // VIN\n                             position.set(Position.KEY_VIN,\n                                     buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                         } else if (id == 281) { // DTC\n                             position.set(Position.KEY_DTCS,\n                                     buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                         } else if (id == 385) { // Beacons\n                             ByteBuf data = buf.readSlice(length);\n                             if (data.readableBytes() > 0) { // Check if data part type exists\n                                 data.readUnsignedByte(); // Read and ignore data part type\n                                 int index = 1;\n                                 while (data.isReadable()) {\n                                     if (data.readableBytes() < 1) break; // Need flags byte\n                                     int flags = data.readUnsignedByte();\n                                     boolean isEddystone = BitUtil.from(flags, 4) > 0;\n\n                                     // Calculate required bytes for the rest of this beacon entry\n                                     int remainingRequired = 1; // Rssi\n                                     if (isEddystone) {\n                                         remainingRequired += 16 + 2 + 2; // UUID, Major, Minor\n                                     } else { // iBeacon\n                                         remainingRequired += 10 + 6; // Namespace, Instance\n                                     }\n                                     if (BitUtil.check(flags, 1)) { remainingRequired += 2; } // Battery\n                                     if (BitUtil.check(flags, 2)) { remainingRequired += 2; } // Temp\n\n                                     // Check if enough bytes remain\n                                     if (data.readableBytes() < remainingRequired) break;\n\n                                     // Read beacon data\n                                     if (isEddystone) {\n                                         position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                                         position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                                         position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                                     } else { // iBeacon\n                                         position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10)));\n                                         position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));\n                                     }\n                                     position.set(\"beacon\" + index + \"Rssi\", (int) data.readByte());\n                                     if (BitUtil.check(flags, 1)) {\n                                         position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.01);\n                                     }\n                                     if (BitUtil.check(flags, 2)) {\n                                         position.set(\"beacon\" + index + \"Temp\", data.readUnsignedShort());\n                                     }\n                                     index += 1;\n                                 }\n                             }\n                         } else { // Generic IO\n                             position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                         }\n                     }\n                 }\n            }\n        } // end codec 8/8E/16 block\n\n        decodeNetwork(position, model); // Common post-processing\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}