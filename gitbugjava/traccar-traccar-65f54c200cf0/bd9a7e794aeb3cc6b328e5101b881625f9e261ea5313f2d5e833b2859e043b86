{
    "generation": "    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        // globalMask is only relevant for GH3000 within its block.\n        // No need for default initialization here if it's not used outside GH3000 block.\n\n        if (codec == CODEC_GH3000) {\n\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            int globalMask = buf.readUnsignedByte(); // Read actual mask for GH3000\n            if (BitUtil.check(globalMask, 0)) { // Check GPS data presence bit\n\n                position.setTime(new Date(time * 1000));\n\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n\n                if (BitUtil.check(locationMask, 5)) {\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n\n                    if (BitUtil.check(locationMask, 6)) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n\n                    if (BitUtil.check(locationMask, 7)) {\n                        cellTower.setOperator(buf.readUnsignedInt());\n                    }\n\n                    position.setNetwork(new Network(cellTower));\n\n                } else {\n                    if (BitUtil.check(locationMask, 6)) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt());\n                    }\n                }\n\n            } else {\n\n                getLastLocation(position, new Date(time * 1000));\n\n            }\n\n            // IO Data for GH3000 (based on its globalMask)\n            // Assuming GH3000 uses 1 byte count/id based on typical embedded protocols.\n\n            // Read 1 byte data\n            if (BitUtil.check(globalMask, 1)) {\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                    // Assuming decodeParameter handles reading based on length=1 and interprets ID as byte\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 1, codec, model);\n                }\n            }\n\n            // Read 2 byte data\n            if (BitUtil.check(globalMask, 2)) {\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                     // Assuming decodeParameter handles reading based on length=2 and interprets ID as byte\n                   decodeParameter(position, buf.readUnsignedByte(), buf, 2, codec, model);\n                }\n            }\n\n            // Read 4 byte data\n            if (BitUtil.check(globalMask, 3)) {\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                     // Assuming decodeParameter handles reading based on length=4 and interprets ID as byte\n                    decodeParameter(position, buf.readUnsignedByte(), buf, 4, codec, model);\n                }\n            }\n            // Note: GH3000 likely does not have 8, 16, X byte IOs in this format.\n\n        } else { // Standard Teltonika Codecs (8, 8 Extended, 16, etc.)\n\n            position.setTime(new Date(buf.readLong()));\n\n            position.set(\"priority\", buf.readUnsignedByte());\n\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n\n            position.setValid(satellites != 0);\n\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            position.set(Position.KEY_EVENT, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16));\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type\n            }\n\n            readExtByte(buf, codec, CODEC_8_EXT); // total IO data records count (N) - discarded as counts below are used\n\n            // --- IO Elements Reading (Moved inside the 'else' block) ---\n            // Read 1 byte data (N1 + N1 * (ID + Value))\n            int cnt1 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt1; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 1, codec, model);\n            }\n\n            // Read 2 byte data (N2 + N2 * (ID + Value))\n            int cnt2 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt2; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 2, codec, model);\n            }\n\n            // Read 4 byte data (N4 + N4 * (ID + Value))\n            int cnt4 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt4; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 4, codec, model);\n            }\n\n            // Read 8 byte data (N8 + N8 * (ID + Value))\n            int cnt8 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt8; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 8, codec, model);\n            }\n\n            // Read 16 byte data (N16 + N16 * (ID + Value))\n            // Assuming 'extended' is a field available in the class scope indicating a variant with 16-byte IOs\n            if (extended) {\n                int cnt16 = readExtByte(buf, codec, CODEC_8_EXT);\n                for (int j = 0; j < cnt16; j++) {\n                    int id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16);\n                    // decodeParameter might not handle length 16, using generic dump as in original code\n                    position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(16)));\n                }\n            }\n\n            // Read X byte data (NX + NX * (ID + Length + Value))\n            if (codec == CODEC_8_EXT) {\n                int cntX = buf.readUnsignedShort();\n                for (int j = 0; j < cntX; j++) {\n                    int id = buf.readUnsignedShort();\n                    int length = buf.readUnsignedShort();\n                    // Keep original X-byte handling logic, including specific IDs\n                    // Ensure buffer has enough readable bytes before reading slices\n                    if (buf.readableBytes() < length) {\n                        // Avoid IndexOutOfBoundsException if length is incorrect\n                        break; // Or log an error\n                    }\n                    if (id == 256) { // VIN\n                        position.set(Position.KEY_VIN,\n                                buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                    } else if (id == 281) { // DTCs\n                        position.set(Position.KEY_DTCS,\n                                buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                    } else if (id == 385) { // Beacons\n                        ByteBuf data = buf.readSlice(length);\n                        // Check readable bytes for safety within this slice too\n                        if (data.readableBytes() > 0) {\n                            data.readUnsignedByte(); // data part\n                            int index = 1;\n                            while (data.readableBytes() >= 17) { // Min readable bytes needed (1 flag + 1 RSSI + 6+10 or 16+2+2)\n                                int flags = data.readUnsignedByte();\n                                position.set(\"beacon\" + index + \"Rssi\", (int) data.readByte()); // Read RSSI first\n                                if (BitUtil.from(flags, 4) > 0) { // Eddystone UUID (16+2+2 = 20 bytes)\n                                    if (data.readableBytes() < 20) break;\n                                    position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                                    position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                                    position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                                } else { // Eddystone UID (10+6 = 16 bytes)\n                                    if (data.readableBytes() < 16) break;\n                                    position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10)));\n                                    position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));\n                                }\n                                if (BitUtil.check(flags, 1)) { // Battery present (2 bytes)\n                                    if (data.readableBytes() < 2) break;\n                                    position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.01);\n                                }\n                                if (BitUtil.check(flags, 2)) { // Temperature present (2 bytes)\n                                     if (data.readableBytes() < 2) break;\n                                   position.set(\"beacon\" + index + \"Temp\", data.readUnsignedShort());\n                                }\n                                index += 1;\n                            }\n                        }\n                    } else if (id == 235) { // 0xEB - Eye Sensor / Tag data\n                         if (length >= 19 && buf.readableBytes() >= length) { // Check length and buffer bounds\n                             // Read the full slice first to avoid partial reads if an error occurs\n                             ByteBuf data = buf.readSlice(length);\n                             position.set(\"tag1Mac\", ByteBufUtil.hexDump(data.readSlice(6)));\n                             data.readUnsignedByte(); // reserved\n                             position.set(\"tag1Temp\", data.readShort() * 0.01);\n                             position.set(\"tag1Battery\", data.readUnsignedShort()); // Read as short, store integer value\n                             position.set(\"tag1Humidity\", data.readUnsignedByte() * 0.5);\n                             data.readUnsignedByte(); // flags\n                             position.set(\"tag1Acc\", ByteBufUtil.hexDump(data.readSlice(6)));\n                             // Slice automatically handles remaining bytes if length > 19\n                        } else {\n                             // Skip the declared length even if invalid/unreadable to try parsing next element\n                             buf.skipBytes(Math.min(length, buf.readableBytes()));\n                        }\n                    } else { // Generic X-byte handling\n                        position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                    }\n                }\n            } // end CODEC_8_EXT X-byte\n\n        } // end standard codecs 'else'\n\n        // Common post-processing step\n        decodeNetwork(position, model);\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}