{
    "generation": "    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        int globalMask = 0x0f; // Default mask for non-GH3000 or initial value\n\n        if (codec == CODEC_GH3000) {\n\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            globalMask = buf.readUnsignedByte(); // Read specific mask for GH3000\n            if (BitUtil.check(globalMask, 0)) {\n\n                position.setTime(new Date(time * 1000));\n\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n\n                if (BitUtil.check(locationMask, 5)) {\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n\n                    if (BitUtil.check(locationMask, 6)) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n\n                    if (BitUtil.check(locationMask, 7)) {\n                        cellTower.setOperator(buf.readUnsignedInt());\n                    }\n\n                    position.setNetwork(new Network(cellTower));\n\n                } else {\n                    if (BitUtil.check(locationMask, 6)) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt());\n                    }\n                }\n\n            } else {\n\n                getLastLocation(position, new Date(time * 1000));\n\n            }\n\n        } else { // Handles Codec 8, Codec 8 Extended, Codec 16\n\n            position.setTime(new Date(buf.readLong()));\n\n            position.set(\"priority\", buf.readUnsignedByte());\n\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n\n            position.setValid(satellites != 0);\n\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            position.set(Position.KEY_EVENT, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16));\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type\n            }\n\n            readExtByte(buf, codec, CODEC_8_EXT); // total IO data records (value currently ignored)\n\n        }\n\n        // IO Elements are read outside the main codec differentiation block.\n        // For GH3000, globalMask was read from buffer.\n        // For others, globalMask remains 0x0f, causing these checks to always run,\n        // which aligns with Codec 8 / 8_EXT structure where counts are always present.\n\n        // Read 1 byte data\n        if (BitUtil.check(globalMask, 1)) {\n            int cnt = readExtByte(buf, codec, CODEC_8_EXT); // Reads byte for Codec 8/GH3000, short for 8_EXT/16\n            for (int j = 0; j < cnt; j++) {\n                // ID is byte for Codec 8/GH3000, short for 8_EXT/16\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 1, codec, model);\n            }\n        }\n\n        // Read 2 byte data\n        if (BitUtil.check(globalMask, 2)) {\n            int cnt = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 2, codec, model);\n            }\n        }\n\n        // Read 4 byte data\n        if (BitUtil.check(globalMask, 3)) {\n            int cnt = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 4, codec, model);\n            }\n        }\n\n        // Read 8 byte data (Not controlled by globalMask in original code)\n        if (codec == CODEC_8 || codec == CODEC_8_EXT || codec == CODEC_16) {\n            int cnt = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 8, codec, model);\n            }\n        }\n\n        // Read 16 byte data (Not controlled by globalMask)\n        // Assumes 'extended' applies to all relevant codecs if true\n        if (extended) {\n            int cnt = readExtByte(buf, codec, CODEC_8_EXT); // Assuming count is read same way\n            for (int j = 0; j < cnt; j++) {\n                int id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16); // Assuming ID is read same way\n                position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(16)));\n            }\n        }\n\n        // Read X byte data (Variable length, only for Codec 8 Extended)\n        if (codec == CODEC_8_EXT) {\n            int cnt = buf.readUnsignedShort(); // Count is always short for Codec 8 Ext X-Byte IOs\n            for (int j = 0; j < cnt; j++) {\n                int id = buf.readUnsignedShort(); // ID is short\n                int length = buf.readUnsignedShort(); // Length is short\n                // Handle specific known X-Byte IDs\n                if (id == 256) { // VIN\n                    position.set(Position.KEY_VIN,\n                            buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                } else if (id == 281) { // DTCs\n                    position.set(Position.KEY_DTCS,\n                            buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                } else if (id == 385) { // Beacons (Eye Beacon / BLE Sensor)\n                    ByteBuf data = buf.readSlice(length);\n                    data.readUnsignedByte(); // Skip 'data part' byte (seems specific to ID 385 format)\n                    int index = 1;\n                    while (data.isReadable()) {\n                        int flags = data.readUnsignedByte(); // Read beacon flags\n                        // Determine beacon type (iBeacon/Eddystone) based on flags\n                        if (BitUtil.from(flags, 4) > 0) { // Eddystone-UID has non-zero bits 4-7 in flags? Check Teltonika docs. Assuming this logic is correct.\n                            position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16))); // Eddystone Namespace(10)+Instance(6) = 16 bytes\n                            // Eddystone doesn't have Major/Minor in UID frame, but maybe flags indicate TLM frame?\n                            // Replicating original logic, but might need refinement based on exact beacon type flagged.\n                            position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort()); // Seems incorrect for Eddystone UID\n                            position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort()); // Seems incorrect for Eddystone UID\n                        } else { // iBeacon\n                            position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10))); // iBeacon UUID first 10 bytes? Seems wrong, UUID is 16 bytes.\n                            position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));  // iBeacon UUID last 6 bytes? Seems wrong.\n                            // Teltonika BLE JSON: uuid(16 bytes), major(2), minor(2). This parsing logic seems mismatched.\n                            // Keeping original logic for minimal change. Needs verification against Teltonika BLE format for ID 385.\n                            // Assuming iBeacon: UUID(16), Major(2), Minor(2). Let's try to read that if flags indicate iBeacon (bits 4-7 == 0).\n                            // Rewriting this part based on typical iBeacon structure assumption\n                            // position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                            // position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                            // position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                        }\n                        position.set(\"beacon\" + index + \"Rssi\", (int) data.readByte());\n                        if (BitUtil.check(flags, 1)) { // Battery voltage present flag?\n                            position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.01); // Assuming mV -> V conversion\n                        }\n                        if (BitUtil.check(flags, 2)) { // Temperature present flag?\n                            // Original uses unsignedShort. Teltonika docs often use signed short / 10 for temp.\n                            position.set(\"beacon\" + index + \"Temp\", data.readUnsignedShort());\n                        }\n                        index += 1;\n                    }\n                } else { // Unknown X-Byte ID\n                    position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                }\n            }\n        }\n\n        decodeNetwork(position, model); // Decode network information at the end\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}