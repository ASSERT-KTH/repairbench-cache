{
    "generation": "    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        int globalMask = 0x0f; // This globalMask is intended for shared IO logic, but its value depends on the codec.\n\n        if (codec == CODEC_GH3000) {\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            globalMask = buf.readUnsignedByte(); // globalMask is explicitly read for CODEC_GH3000\n            if (BitUtil.check(globalMask, 0)) {\n\n                position.setTime(new Date(time * 1000));\n\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n\n                if (BitUtil.check(locationMask, 5)) {\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n\n                    if (BitUtil.check(locationMask, 6)) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n\n                    if (BitUtil.check(locationMask, 7)) {\n                        cellTower.setOperator(buf.readUnsignedInt());\n                    }\n\n                    position.setNetwork(new Network(cellTower));\n\n                } else {\n                    if (BitUtil.check(locationMask, 6)) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt());\n                    }\n                }\n\n            } else {\n                getLastLocation(position, new Date(time * 1000));\n            }\n\n        } else { // This branch handles CODEC_8, CODEC_8_EXT, CODEC_16\n            // For these codecs, the `globalMask` variable remains its initial value (0x0f)\n            // and is not directly related to IO flags in the same way as GH3000.\n            // However, the subsequent IO parsing blocks still use `globalMask` condition,\n            // which will always evaluate to true for bits 1, 2, 3 due to 0x0f.\n            // The counts for these IO types are explicitly provided in the protocol.\n\n            position.setTime(new Date(buf.readLong()));\n\n            position.set(\"priority\", buf.readUnsignedByte());\n\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n\n            position.setValid(satellites != 0);\n\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            // Event ID (1 byte for Teltonika AVL data)\n            position.set(Position.KEY_EVENT, buf.readUnsignedByte()); // FIX: Use buf.readUnsignedByte() for Event ID\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type (specific to CODEC_16)\n            }\n\n            // Total IO data records (1 byte) - This byte indicates the number of following IO data blocks (1-byte, 2-byte, etc.)\n            // It needs to be consumed but its value is not directly used for loop counts in the current structure.\n            buf.readUnsignedByte(); // FIX: Use buf.readUnsignedByte() to consume this byte\n        }\n\n        // --- IO data blocks (common for all codecs based on original code structure) ---\n        // For CODEC_8, CODEC_8_EXT, CODEC_16, the `globalMask` is 0x0f,\n        // so conditions `BitUtil.check(globalMask, 1/2/3)` will always be true.\n        // The critical fix is to correctly read the 'count' (cnt) for each block.\n        // For Teltonika CODEC_8, CODEC_8_EXT, CODEC_16, these counts are 1-byte, except for X-byte count.\n\n        // Read 1 byte data\n        if (BitUtil.check(globalMask, 1)) {\n            int cnt = (codec == CODEC_GH3000) ? readExtByte(buf, codec, CODEC_8_EXT) : buf.readUnsignedByte(); // FIX: Use buf.readUnsignedByte() for counts for CODEC_8/8_EXT/16\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 1, codec, model);\n            }\n        }\n\n        // Read 2 byte data\n        if (BitUtil.check(globalMask, 2)) {\n            int cnt = (codec == CODEC_GH3000) ? readExtByte(buf, codec, CODEC_8_EXT) : buf.readUnsignedByte(); // FIX: Use buf.readUnsignedByte() for counts\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 2, codec, model);\n            }\n        }\n\n        // Read 4 byte data\n        if (BitUtil.check(globalMask, 3)) {\n            int cnt = (codec == CODEC_GH3000) ? readExtByte(buf, codec, CODEC_8_EXT) : buf.readUnsignedByte(); // FIX: Use buf.readUnsignedByte() for counts\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 4, codec, model);\n            }\n        }\n\n        // Read 8 byte data\n        // This condition is true for CODEC_8, CODEC_8_EXT, CODEC_16, and also might apply to GH3000 if globalMask bit is set\n        if (codec == CODEC_8 || codec == CODEC_8_EXT || codec == CODEC_16 || BitUtil.check(globalMask, 4)) { // Assuming globalMask bit 4 covers 8-byte for GH3000\n            int cnt = (codec == CODEC_GH3000) ? readExtByte(buf, codec, CODEC_8_EXT) : buf.readUnsignedByte(); // FIX: Use buf.readUnsignedByte() for counts\n            for (int j = 0; j < cnt; j++) {\n                decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 8, codec, model);\n            }\n        }\n\n        // Read 16 byte data (Traccar custom extension)\n        if (extended) { // This `extended` flag is set by decoder configuration\n            int cnt = readExtByte(buf, codec, CODEC_8_EXT); // This might return UnsignedShort if codec is CODEC_8_EXT\n            for (int j = 0; j < cnt; j++) {\n                int id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16);\n                position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(16)));\n            }\n        }\n\n        // Read X byte data (Specific to CODEC_8_EXT)\n        if (codec == CODEC_8_EXT) {\n            int cnt = buf.readUnsignedShort(); // This count is correctly 2 bytes for X-byte data\n            for (int j = 0; j < cnt; j++) {\n                int id = buf.readUnsignedShort();\n                int length = buf.readUnsignedShort();\n                if (id == 256) {\n                    position.set(Position.KEY_VIN,\n                            buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                } else if (id == 281) {\n                    position.set(Position.KEY_DTCS,\n                            buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                } else if (id == 385) { // Beacon data (Teltonika BLE)\n                    ByteBuf data = buf.readSlice(length);\n                    // The first byte of the value for ID 385 is typically the 'number of records' (N)\n                    // The line `data.readUnsignedByte(); // data part` consumes this N byte.\n                    // The loop `while (data.isReadable())` then processes N records if N was correctly consumed.\n                    data.readUnsignedByte(); // This byte consumes the 'number of records' or 'data part'\n                    int index = 1;\n                    while (data.isReadable()) {\n                        int flags = data.readUnsignedByte(); // This reads the flags for the current beacon\n                        if (BitUtil.from(flags, 4) > 0) { // Check for iBeacon vs Eddystone\n                            position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                            position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                            position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                        } else {\n                            position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10)));\n                            position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));\n                        }\n                        position.set(\"beacon\" + index + \"Rssi\", (int) data.readByte());\n                        if (BitUtil.check(flags, 1)) { // Check if battery data is present (bit 1)\n                            position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.01);\n                        }\n                        if (BitUtil.check(flags, 2)) { // Check if temperature data is present (bit 2)\n                            position.set(\"beacon\" + index + \"Temp\", data.readUnsignedShort());\n                        }\n                        index += 1;\n                    }\n                } else {\n                    position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                }\n            }\n        }\n\n        decodeNetwork(position, model);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}