{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\n\n// Assume TeltonikaProtocolDecoder context for fields and helper methods\n// like CODEC_*, extended, getConfig, getLastLocation, readExtByte, decodeParameter, decodeNetwork\n\n    private void decodeLocation(Position position, ByteBuf buf, int codec, String model) {\n\n        if (codec == CODEC_GH3000) {\n\n            // GH3000 decoding\n            long time = buf.readUnsignedInt() & 0x3fffffff;\n            time += 1167609600; // 2007-01-01 00:00:00\n\n            int globalMask = buf.readUnsignedByte(); // Read the actual mask for GH3000\n            if (BitUtil.check(globalMask, 0)) { // Location data present\n\n                position.setTime(new Date(time * 1000));\n                int locationMask = buf.readUnsignedByte();\n\n                if (BitUtil.check(locationMask, 0)) {\n                    position.setLatitude(buf.readFloat());\n                    position.setLongitude(buf.readFloat());\n                }\n                if (BitUtil.check(locationMask, 1)) {\n                    position.setAltitude(buf.readUnsignedShort());\n                }\n                if (BitUtil.check(locationMask, 2)) {\n                    position.setCourse(buf.readUnsignedByte() * 360.0 / 256);\n                }\n                if (BitUtil.check(locationMask, 3)) {\n                    position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedByte()));\n                }\n                if (BitUtil.check(locationMask, 4)) {\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                }\n                position.setValid(BitUtil.check(locationMask, 0)); // Validity based on location presence\n\n                if (BitUtil.check(locationMask, 5)) { // Network Info\n                    CellTower cellTower = CellTower.fromLacCid(\n                            getConfig(), buf.readUnsignedShort(), buf.readUnsignedShort());\n                    if (BitUtil.check(locationMask, 6)) {\n                        cellTower.setSignalStrength((int) buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        cellTower.setOperator(buf.readUnsignedInt()); // Assuming 4 bytes, needs spec check\n                    }\n                    position.setNetwork(new Network(cellTower));\n                } else { // Only RSSI / Operator ID\n                    if (BitUtil.check(locationMask, 6)) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    if (BitUtil.check(locationMask, 7)) {\n                        position.set(Position.KEY_OPERATOR, buf.readUnsignedInt()); // Assuming 4 bytes, needs spec check\n                    }\n                }\n\n            } else { // No location data\n                getLastLocation(position, new Date(time * 1000));\n                position.setValid(false);\n            }\n\n            // IO parsing for GH3000 using its globalMask\n            // Assuming 1-byte IDs and counts for GH3000 IO. Mask bits need spec confirmation.\n            if (BitUtil.check(globalMask, 1)) { // 1-byte IO\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                     // Check readability: ID(1) + Value(1) = 2\n                     if (buf.readableBytes() >= 2) {\n                         decodeParameter(position, buf.readUnsignedByte(), buf, 1, codec, model);\n                     } else { buf.skipBytes(buf.readableBytes()); break; } // Avoid IndexOutOfBounds\n                }\n            }\n            if (BitUtil.check(globalMask, 2)) { // 2-byte IO\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                     // Check readability: ID(1) + Value(2) = 3\n                     if (buf.readableBytes() >= 3) {\n                         decodeParameter(position, buf.readUnsignedByte(), buf, 2, codec, model);\n                     } else { buf.skipBytes(buf.readableBytes()); break; }\n                }\n            }\n            if (BitUtil.check(globalMask, 3)) { // 4-byte IO\n                int cnt = buf.readUnsignedByte();\n                for (int j = 0; j < cnt; j++) {\n                     // Check readability: ID(1) + Value(4) = 5\n                     if (buf.readableBytes() >= 5) {\n                         decodeParameter(position, buf.readUnsignedByte(), buf, 4, codec, model);\n                     } else { buf.skipBytes(buf.readableBytes()); break; }\n                }\n            }\n            // Assuming mask bit 4 for 8-byte IO - Needs spec confirmation\n            if (BitUtil.check(globalMask, 4)) {\n                 int cnt = buf.readUnsignedByte();\n                 for (int j = 0; j < cnt; j++) {\n                     // Check readability: ID(1) + Value(8) = 9\n                     if (buf.readableBytes() >= 9) {\n                         decodeParameter(position, buf.readUnsignedByte(), buf, 8, codec, model);\n                     } else { buf.skipBytes(buf.readableBytes()); break; }\n                 }\n            }\n\n        } else { // Codec 8, 8E, 16 (AVL Data Packet)\n\n            position.setTime(new Date(buf.readLong()));\n            position.set(\"priority\", buf.readUnsignedByte());\n\n            position.setLongitude(buf.readInt() / 10000000.0);\n            position.setLatitude(buf.readInt() / 10000000.0);\n            position.setAltitude(buf.readShort());\n            position.setCourse(buf.readUnsignedShort());\n\n            int satellites = buf.readUnsignedByte();\n            position.set(Position.KEY_SATELLITES, satellites);\n            position.setValid(satellites >= 3); // Standard validity check (e.g., >= 3 satellites)\n\n            position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort()));\n\n            position.set(Position.KEY_EVENT, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16));\n            if (codec == CODEC_16) {\n                buf.readUnsignedByte(); // generation type\n            }\n\n            readExtByte(buf, codec, CODEC_8_EXT); // Read and discard total IO count (as original code did)\n\n            // Read IO data based on N1, N2, N4, N8, N16, NX counts from the stream\n            int idSize = (codec == CODEC_8_EXT || codec == CODEC_16) ? 2 : 1;\n\n            // Read N1 IOs\n            int count1 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < count1; j++) {\n                 if (buf.readableBytes() >= idSize + 1) { // Check readability for ID + Value\n                     decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 1, codec, model);\n                 } else { buf.skipBytes(buf.readableBytes()); break; }\n            }\n\n            // Read N2 IOs\n            int count2 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < count2; j++) {\n                 if (buf.readableBytes() >= idSize + 2) { // Check readability for ID + Value\n                     decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 2, codec, model);\n                 } else { buf.skipBytes(buf.readableBytes()); break; }\n            }\n\n            // Read N4 IOs\n            int count4 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < count4; j++) {\n                 if (buf.readableBytes() >= idSize + 4) { // Check readability for ID + Value\n                     decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 4, codec, model);\n                 } else { buf.skipBytes(buf.readableBytes()); break; }\n            }\n\n            // Read N8 IOs\n            int count8 = readExtByte(buf, codec, CODEC_8_EXT);\n            for (int j = 0; j < count8; j++) {\n                 if (buf.readableBytes() >= idSize + 8) { // Check readability for ID + Value\n                     decodeParameter(position, readExtByte(buf, codec, CODEC_8_EXT, CODEC_16), buf, 8, codec, model);\n                 } else { buf.skipBytes(buf.readableBytes()); break; }\n            }\n\n            // Read N16 IOs (Gated by 'extended' flag - same placement as original)\n            if (extended) {\n                int count16 = readExtByte(buf, codec, CODEC_8_EXT);\n                for (int j = 0; j < count16; j++) {\n                     if (buf.readableBytes() >= idSize + 16) { // Check readability for ID + Value\n                         int id = readExtByte(buf, codec, CODEC_8_EXT, CODEC_16);\n                         position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(16)));\n                     } else { buf.skipBytes(buf.readableBytes()); break; }\n                }\n            }\n\n            // Read NX IOs (Variable length - specific to CODEC_8_EXT)\n            if (codec == CODEC_8_EXT) {\n                if (buf.readableBytes() >= 2) { // Check readability for count NX\n                    int countX = buf.readUnsignedShort();\n                    for (int j = 0; j < countX; j++) {\n                        // Check readability for ID (2) + Length (2) = 4\n                        if (buf.readableBytes() < 4) { buf.skipBytes(buf.readableBytes()); break; }\n                        int id = buf.readUnsignedShort();\n                        int length = buf.readUnsignedShort();\n                        // Check readability for Value (length)\n                        if (buf.readableBytes() < length) { buf.skipBytes(buf.readableBytes()); break; }\n\n                        // Handle specific NX IDs\n                        if (id == 256) { // VIN\n                            position.set(Position.KEY_VIN, buf.readSlice(length).toString(StandardCharsets.US_ASCII));\n                        } else if (id == 281) { // DTCs\n                            position.set(Position.KEY_DTCS, buf.readSlice(length).toString(StandardCharsets.US_ASCII).replace(',', ' '));\n                        } else if (id == 385) { // Beacons\n                            ByteBuf data = buf.readSlice(length);\n                            // Skip optional 'part' byte at the start if present\n                            if (data.readableBytes() > 0) { data.readUnsignedByte(); }\n                            int index = 1;\n                            while (data.isReadable()) {\n                                // Need at least flags(1) + rssi(1) = 2 bytes\n                                if (data.readableBytes() < 2) { break; }\n                                int flags = data.readUnsignedByte();\n                                int rssi = data.readByte();\n\n                                if (BitUtil.from(flags, 4) > 0) { // Eddystone format\n                                    // Need Namespace(10) + Instance(6) = 16 bytes\n                                    if (data.readableBytes() < 16) { break; }\n                                    position.set(\"beacon\" + index + \"Namespace\", ByteBufUtil.hexDump(data.readSlice(10)));\n                                    position.set(\"beacon\" + index + \"Instance\", ByteBufUtil.hexDump(data.readSlice(6)));\n                                } else { // iBeacon format (corrected)\n                                    // Need UUID(16) + Major(2) + Minor(2) = 20 bytes\n                                    if (data.readableBytes() < 20) { break; }\n                                    position.set(\"beacon\" + index + \"Uuid\", ByteBufUtil.hexDump(data.readSlice(16)));\n                                    position.set(\"beacon\" + index + \"Major\", data.readUnsignedShort());\n                                    position.set(\"beacon\" + index + \"Minor\", data.readUnsignedShort());\n                                }\n                                position.set(\"beacon\" + index + \"Rssi\", rssi);\n\n                                if (BitUtil.check(flags, 1)) { // Battery present\n                                    if (data.readableBytes() < 2) { break; }\n                                    // Scale needs confirmation, assume mV -> V\n                                    position.set(\"beacon\" + index + \"Battery\", data.readUnsignedShort() * 0.001);\n                                }\n                                if (BitUtil.check(flags, 2)) { // Temperature present\n                                    if (data.readableBytes() < 2) { break; }\n                                    // Scale needs confirmation, assume 0.1 degrees C/F\n                                    position.set(\"beacon\" + index + \"Temp\", data.readShort() * 0.1); // Use readShort for temp\n                                }\n                                index += 1;\n                            }\n                        } else { // Generic NX IO\n                            position.set(Position.PREFIX_IO + id, ByteBufUtil.hexDump(buf.readSlice(length)));\n                        }\n                    }\n                } else { buf.skipBytes(buf.readableBytes()); } // Not enough bytes for NX count\n            } // end if codec == CODEC_8_EXT\n        } // End of non-GH3000 block\n\n        decodeNetwork(position, model); // Decode network info at the end\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}