{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Create a mutable copy of the mocks set to allow removal of injected mocks\n        Set<Object> availableMocks = new HashSet<>(mocks);\n        // Process fields in the order defined by the framework (e.g., declaration order)\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            // Ask the filter for the best candidate mock for the current field among the *available* mocks\n            // The filter is responsible for prioritization logic (e.g., exact type, name matching, ancestor types)\n            // It returns an OngoingInjecter that knows which mock (if any) was selected.\n            org.mockito.internal.configuration.MockCandidateFilter.OngoingInjecter ongoingInjecter =\n                    mockCandidateFilter.filterCandidate(availableMocks, field, fieldInstance);\n\n            // Execute the injection if a suitable mock was found by the filter.\n            // Assume thenInject() returns the actual mock object that was injected, or null if no injection occurred.\n            Object injectedMock = ongoingInjecter.thenInject();\n\n            // If a mock was successfully injected into the field, remove it from the set of available mocks\n            // This ensures a mock instance is injected into at most one field.\n            if (injectedMock != null) {\n                availableMocks.remove(injectedMock);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}