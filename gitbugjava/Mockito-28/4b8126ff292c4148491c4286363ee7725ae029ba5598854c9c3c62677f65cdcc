{
    "generation": "import java.lang.reflect.Field;\nimport java.util.HashSet;\nimport java.util.Set;\n// Imports added for clarity; assume necessary types like PotentialInjectee are available.\n\n    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Copy mocks to allow removal of injected mocks during processing\n        Set<Object> availableMocks = new HashSet<>(mocks);\n\n        // First Pass: Iterate through fields and inject mocks only if the type matches EXACTLY.\n        for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            if (availableMocks.isEmpty()) {\n                break; // Optimization: No more mocks to inject.\n            }\n\n            // Find mocks from the available set that have the exact same type as the field.\n            Set<Object> exactMatchingMocks = new HashSet<>();\n            for (Object mock : availableMocks) {\n                // Using equals() for type comparison is generally safer than ==\n                if (field.getType().equals(mock.getClass())) {\n                    exactMatchingMocks.add(mock);\n                }\n            }\n\n            // If any exact type matches were found, attempt injection using only those mocks.\n            if (!exactMatchingMocks.isEmpty()) {\n                // Use the filterCandidate mechanism, but restrict it to the exact matching mocks.\n                // filterCandidate is expected to select the best candidate if multiple apply\n                // and handle checks like field modifiers (static, final) and existing values.\n                PotentialInjectee injection = mockCandidateFilter.filterCandidate(exactMatchingMocks, field, fieldInstance);\n                // thenInject performs the actual field assignment and should return the mock that was injected.\n                Object injectedMock = injection.thenInject();\n\n                if (injectedMock != null) {\n                    // If injection was successful, remove the injected mock from the available pool\n                    // to ensure it's not injected again.\n                    availableMocks.remove(injectedMock);\n                }\n            }\n        }\n\n        // Second Pass: Iterate through fields again. Inject remaining mocks into fields where the\n        // field type is assignable from the mock type (i.e., superclass or interface).\n        // This pass handles cases where no exact match was found or preferred.\n        if (!availableMocks.isEmpty()) { // Only proceed if there are still mocks left to inject.\n            for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n                if (availableMocks.isEmpty()) {\n                    break; // Optimization: No more mocks to inject.\n                }\n\n                // Attempt injection using the *remaining* available mocks.\n                // filterCandidate will check for assignability and other injection criteria.\n                // It should not inject if the field already received a mock in the first pass (assuming filter logic prevents this).\n                PotentialInjectee injection = mockCandidateFilter.filterCandidate(availableMocks, field, fieldInstance);\n                Object injectedMock = injection.thenInject();\n\n                if (injectedMock != null) {\n                    // If injection was successful, remove the injected mock from the available pool.\n                    availableMocks.remove(injectedMock);\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}