{
    "generation": "  /**\n   * Visits a NEW node.\n   *\n   * Example: new Foo();\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    // Get the type of the constructor expression. Could be FunctionType, UnionType, Unknown, etc.\n    JSType constructorType = getJSType(constructor);\n    // We are interested in the type when it's not null or undefined.\n    JSType restrictedType = constructorType.restrictByNotNullOrUndefined();\n\n    // Check if the restricted type could possibly be used with 'new'.\n    // This includes actual constructors, or types that could resolve to one\n    // (like unknown, empty, or unions containing constructors).\n    boolean maybeConstructor = restrictedType.isConstructor()\n        || restrictedType.isEmptyType() || restrictedType.isUnknownType();\n    if (!maybeConstructor && restrictedType.isUnionType()) {\n      // If it's a union, check if any alternative could be a constructor.\n      for (JSType alt : restrictedType.toMaybeUnionType().getAlternates()) {\n        // Check the alternative after restricting it as well.\n        JSType restrictedAlt = alt.restrictByNotNullOrUndefined();\n        if (restrictedAlt.isConstructor() || restrictedAlt.isEmptyType() || restrictedAlt.isUnknownType()) {\n          maybeConstructor = true;\n          break;\n        }\n      }\n    }\n\n    // If it's definitely not something that can be used with 'new', report an error.\n    if (!maybeConstructor) {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n); // Assign unknown type after reporting error\n      return;\n    }\n\n    // If we're here, the type might be usable with 'new'.\n    // Try to resolve it to a specific FunctionType if possible.\n    // This will return null for UNKNOWN, EMPTY, or UNION types.\n    FunctionType fnType = restrictedType.toMaybeFunctionType();\n\n    if (fnType != null) {\n      // Case 1: The type resolved to a single FunctionType.\n      // Check if it's actually a constructor or an interface.\n      if (fnType.isConstructor()) {\n        // It's a proper constructor. Check parameters and assign the instance type.\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else if (fnType.isInterface()) {\n        // It's an interface. Report error, cannot instantiate interfaces.\n        report(t, n, NOT_A_CONSTRUCTOR);\n        ensureTyped(t, n);\n      } else {\n        // It's some other kind of function, not marked as constructor/interface.\n        // Treat as not a constructor.\n        report(t, n, NOT_A_CONSTRUCTOR);\n        ensureTyped(t, n);\n      }\n    } else {\n      // Case 2: The type did not resolve to a single FunctionType.\n      // It must be UNKNOWN, EMPTY, or a UNION (because maybeConstructor was true).\n      FunctionType representativeFnType = null; // For parameter checking\n      // Prepare to build the result type (usually UNKNOWN or a union of instance types).\n      JSType resultType = typeRegistry.getNativeType(JSTypeNative.NO_TYPE); // Start with bottom type\n      boolean hasValidInstanceType = false;\n\n      if (restrictedType.isUnionType()) {\n        // Iterate through the union alternatives to find constructors.\n        for (JSType alt : restrictedType.toMaybeUnionType().getAlternates()) {\n          JSType restrictedAlt = alt.restrictByNotNullOrUndefined();\n          if (restrictedAlt.isConstructor()) {\n            // Found a constructor alternative.\n            FunctionType altFn = restrictedAlt.toMaybeFunctionType();\n            if (altFn != null) {\n              // Use the first constructor found for parameter checking.\n              if (representativeFnType == null) {\n                representativeFnType = altFn;\n              }\n              // Add its instance type to the possible result types.\n              resultType = typeRegistry.createUnionType(resultType, altFn.getInstanceType());\n              hasValidInstanceType = true;\n            }\n          } else if (restrictedAlt.isEmptyType() || restrictedAlt.isUnknownType()) {\n            // If any alternative is unknown/empty, include UNKNOWN in the result type.\n            resultType = typeRegistry.createUnionType(resultType,\n                typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n            hasValidInstanceType = true;\n          }\n          // Ignore alternatives that are definitely not constructors (e.g., number, string).\n          // Interfaces would also be ignored here as !isConstructor().\n        }\n      } else {\n        // Type must be UNKNOWN or EMPTY (since fnType was null but maybeConstructor was true).\n        // The result type is UNKNOWN.\n        resultType = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n        hasValidInstanceType = true;\n      }\n\n      // Perform parameter check if we found a representative constructor signature from a union.\n      if (representativeFnType != null) {\n        visitParameterList(t, n, representativeFnType);\n      }\n\n      // Assign the calculated result type.\n      if (hasValidInstanceType) {\n        // If resultType is still NO_TYPE, it means the union only contained non-constructors\n        // (which should have been caught earlier), so default to UNKNOWN.\n        ensureTyped(t, n, resultType.isBottomType() ?\n            typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE) : resultType);\n      } else {\n        // Fallback: Should not be reached if maybeConstructor was true, but ensures node gets typed.\n        ensureTyped(t, n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}