{
    "generation": "    @Override\n    protected String doFormat(final String code, final LineEnding ending) throws IOException {\n        // Import necessary classes (assuming they are imported at the top level)\n        // import com.helger.css.parser.CSSOMParser;\n        // import com.helger.css.parser.CSSParseException;\n        // import com.helger.css.parser.SACParserCSS3;\n        // import com.helger.css.writer.CSSWriter;\n        // import com.helger.css.writer.CSSWriterSettings;\n        // import com.helger.css.writer.ECSSNewLineMode;\n        // import com.helger.css.decl.CSSStyleSheetImpl;\n        // import org.w3c.css.sac.InputSource;\n        // import java.io.StringReader;\n        // import java.io.IOException;\n\n        final var source = new InputSource(new StringReader(code));\n        // SACParserCSS3 supports CSS 3.0 including media queries etc.\n        final var parser = new CSSOMParser(new SACParserCSS3());\n        // Optional: Add an error handler to potentially capture/log parsing errors differently\n        // parser.setParseExceptionCallback(new ThrowingCSSParseExceptionCallback ());\n\n        final CSSStyleSheetImpl sheet;\n        try {\n            // The parseStyleSheet method in CSSOMParser can return null or throw CSSParseException\n            sheet = (CSSStyleSheetImpl) parser.parseStyleSheet(source, null, null);\n            // If parsing returns null (e.g., for empty input or completely unparseable CSS), treat as no change.\n            if (sheet == null) {\n                 // Log warning? System.err.println(\"CSS parsing returned null stylesheet.\");\n                 return null;\n             }\n        } catch (final Exception e) { // Catch broad Exception as CSSOMParser throws it\n            // Wrap parser exception into IOException as per method signature\n            throw new IOException(\"Failed to parse CSS: \" + e.getMessage(), e);\n        }\n\n        // Create writer settings based on the formatter configuration (indent, etc.)\n        // This constructor copies settings like indent, quote URLs etc. from this.formatter\n        final var writerSettings = new CSSWriterSettings(this.formatter);\n\n        // *** Override the line ending mode based on the 'ending' parameter ***\n        // The original code implicitly used system default line endings via sheet.getCssText()\n        switch (ending) {\n            case LF:\n                writerSettings.setNewLineMode(ECSSNewLineMode.LF);\n                break;\n            case CRLF:\n                writerSettings.setNewLineMode(ECSSNewLineMode.CRLF);\n                break;\n            case CR:\n                writerSettings.setNewLineMode(ECSSNewLineMode.CR);\n                break;\n            // Assuming AUTO, KEEP, SYSTEM are resolved by the framework before calling doFormat\n            default:\n                // Fallback to system default, consistent with CSSWriterSettings default if not overridden.\n                writerSettings.setNewLineMode(ECSSNewLineMode.SYSTEM_DEFAULT);\n                break;\n        }\n\n        // Create the writer and get the formatted text\n        final var writer = new CSSWriter(writerSettings);\n        String formattedCode = writer.getCSSAsString(sheet);\n\n        // Defensive check against null return from getCSSAsString, though unlikely\n        if (formattedCode == null) {\n           formattedCode = \"\";\n        }\n\n        // Patch converted 'tab' back to '\\9' for IE 7,8, and 9 hack. Cssparser switches it to 'tab'.\n        // Apply this *after* formatting, as the formatter might produce the '\\t;'\n        formattedCode = formattedCode.replace(\"\\t;\", \"\\\\9;\");\n\n        // Final comparison: return null if no change from original code\n        if (code.equals(formattedCode)) {\n            return null;\n        }\n\n        return formattedCode;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}