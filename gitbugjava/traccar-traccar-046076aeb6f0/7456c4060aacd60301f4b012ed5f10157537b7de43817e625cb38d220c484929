{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport org.traccar.DeviceSession;\nimport org.traccar.helper.BitUtil;\nimport org.traccar.helper.BcdUtil;\nimport org.traccar.helper.DateBuilder;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\nimport org.traccar.model.WifiAccessPoint;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.TimeZone;\n\n// Assume helper classes, constants (MSG_*, Variant), and methods (getProtocolName, getDeviceSession, etc.)\n// are defined elsewhere in the actual class context, similar to the buggy code structure.\n// The following provides ONLY the fixed decodeBasic method.\n\npublic class Gt06ProtocolDecoderFixed {\n\n    // Constants and helper methods assumed defined\n    private static final int MSG_LOGIN = 0x01;\n    private static final int MSG_GPS = 0x10;\n    private static final int MSG_LBS = 0x11;\n    private static final int MSG_GPS_LBS_1 = 0x12;\n    private static final int MSG_STATUS = 0x13;\n    private static final int MSG_SATELLITE = 0x14;\n    private static final int MSG_STRING = 0x15;\n    private static final int MSG_GPS_LBS_STATUS_1 = 0x16;\n    private static final int MSG_WIFI = 0x17;\n    private static final int MSG_LBS_MULTIPLE_1 = 0x18;\n    private static final int MSG_LBS_EXTEND = 0x19;\n    private static final int MSG_LBS_STATUS = 0x1A;\n    private static final int MSG_GPS_LBS_EXTEND = 0x1E;\n    private static final int MSG_GPS_LBS_STATUS_2 = 0x1F;\n    private static final int MSG_COMMAND_0 = 0x80;\n    private static final int MSG_COMMAND_1 = 0x81;\n    private static final int MSG_COMMAND_2 = 0x82;\n    private static final int MSG_TIME_REQUEST = 0x8A;\n    private static final int MSG_INFO = 0x94;\n    private static final int MSG_ALARM = 0x95;\n    private static final int MSG_LBS_ALARM = 0x96;\n    private static final int MSG_WIFI_ALARM = 0x97;\n    private static final int MSG_GPS_SLEEP = 0x98;\n    private static final int MSG_FRIEND_NUMBER = 0xA0;\n    private static final int MSG_HEARTBEAT = 0x23;\n    private static final int MSG_ADDRESS_REQUEST = 0x24;\n    private static final int MSG_ADDRESS_RESPONSE = 0x24;\n    private static final int MSG_LBS_MULTIPLE_2 = 0x26;\n    private static final int MSG_GPS_LBS_STATUS_3 = 0x27;\n    private static final int MSG_LBS_MULTIPLE_3 = 0x28;\n    private static final int MSG_WIFI_2 = 0x2C;\n    private static final int MSG_GPS_LBS_2 = 0xA9;\n    private static final int MSG_FENCE_MULTI = 0xAA;\n    private static final int MSG_GPS_LBS_3 = 0xAB;\n    private static final int MSG_GPS_LBS_4 = 0xAC;\n    private static final int MSG_BMS = 0xE1;\n    private static final int MSG_LBS_2 = 0xE2;\n    private static final int MSG_WIFI_3 = 0xE3;\n    private static final int MSG_WIFI_4 = 0xE4;\n    private static final int MSG_WIFI_5 = 0xE5;\n    private static final int MSG_OBD = 0xF2;\n    private static final int MSG_X1_GPS = 0xA1;\n    private static final int MSG_X1_PHOTO_INFO = 0xA2;\n    private Map<Integer, ByteBuf> photos = new HashMap<>();\n    private enum Variant { DEFAULT, GT06E_CARD, BENWAY, VXT01, S5, SPACE10X, OBD6, WANWAY_S20, SR411_MINI }\n    private Variant variant = Variant.DEFAULT;\n    private String getProtocolName() { return \"gt06\"; } // Mock\n    private DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress) { return null; } // Mock\n    private DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress, String imei) { return null; } // Mock\n    private TimeZone getTimeZone(long deviceId) { return TimeZone.getTimeZone(\"UTC\"); } // Mock\n    private void sendResponse(Channel channel, boolean text, int type, short serial, ByteBuf content) {} // Mock - changed serial type\n    private Position getLastLocation(Position position, Date time) { return position; } // Mock\n    private void decodeGps(Position position, ByteBuf buf, boolean hasRssi, TimeZone timezone) {} // Mock\n    private void decodeGps(Position position, ByteBuf buf, boolean hasRssi, boolean hasSatellites, boolean hasSpeed, TimeZone timezone) {} // Mock\n    private void decodeLbs(Position position, ByteBuf buf, int type, boolean hasStatus) {} // Mock\n    private void decodeStatus(Position position, ByteBuf buf) {} // Mock\n    private boolean isSupported(int type) { return true; } // Mock\n    private boolean hasGps(int type) { return true; } // Mock\n    private boolean hasLbs(int type) { return true; } // Mock\n    private boolean hasStatus(int type) { return true; } // Mock\n    private String decodeAlarm(byte value) { return null; } // Mock - original used byte\n    private String decodeAlarm(short value) { return decodeAlarm((byte)value); } // Mock overload for short\n    private boolean hasLanguage(int type) { return false; } // Mock - assume false to remove tail read\n    private void sendPhotoRequest(Channel channel, int pictureId) {} // Mock\n\n    private Object decodeBasic(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        int length = buf.readUnsignedByte(); // L = Proto(1)+Info(dL)+Serial(2)+CRC(2)\n\n        // Check if the buffer actually contains L bytes AFTER the length byte.\n        // 'length' includes Protocol Number, Info Content, Serial Number, CRC.\n        if (buf.readableBytes() < length) {\n            return null; // Buffer truncated or invalid length declared\n        }\n\n        // Get serial number based on declared length L.\n        // Serial number starts at offset (L - 4) relative to the current reader index (which is after the length byte).\n        // L includes Proto(1), Info(dataLength), Serial(2), CRC(2). Serial starts after Proto + Info.\n        // Offset = 1 (Proto) + dataLength = 1 + (L - 5) = L - 4.\n        short serial = buf.getShort(buf.readerIndex() + length - 4);\n\n        int dataLength = length - 5; // Length of the Information Content part\n        if (dataLength < 0) {\n            // Declared length L is too small to hold Proto, Serial, CRC\n            return null;\n        }\n\n        // Calculate the index where the Information Content is expected to end\n        // This index is relative to the start of the buffer 'buf'\n        int infoContentEndIndex = buf.readerIndex() + 1 + dataLength; // +1 because readerIndex is after Length byte\n\n        int type = buf.readUnsignedByte(); // Consume the type byte\n\n        Position position = new Position(getProtocolName());\n        DeviceSession deviceSession = null;\n        if (type != MSG_LOGIN) {\n            deviceSession = getDeviceSession(channel, remoteAddress);\n            if (deviceSession == null) {\n                // If session is required but not found, discard message\n                return null;\n            }\n            position.setDeviceId(deviceSession.getDeviceId());\n            // Initialize timezone only if it's not already set\n            if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n                // Assuming getTimeZone is cheap/non-blocking\n                deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n            }\n        }\n\n        // --- Start Message Type Handling ---\n        // Reads use 'buf'. Handlers must ensure they don't read past infoContentEndIndex.\n\n        if (type == MSG_LOGIN) {\n\n            if (dataLength < 10 || buf.readerIndex() > infoContentEndIndex - 10) return null; // Check required bytes\n\n            String imei = ByteBufUtil.hexDump(buf.readSlice(8)).substring(1);\n            buf.readUnsignedShort(); // type\n\n            deviceSession = getDeviceSession(channel, remoteAddress, imei);\n            if (deviceSession != null && !deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n                deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n            }\n\n            // Optional timezone extension\n            if (dataLength > 10 && buf.readerIndex() <= infoContentEndIndex - 2) { // Need 2 bytes for extension\n                 int extensionBits = buf.readUnsignedShort();\n                 // ... (timezone processing as in original code) ...\n                 int hours = (extensionBits >> 4) / 100;\n                 int minutes = (extensionBits >> 4) % 100;\n                 int offset = (hours * 60 + minutes) * 60;\n                 if ((extensionBits & 0x8) != 0) {\n                     offset = -offset;\n                 }\n                 if (deviceSession != null) {\n                     TimeZone timeZone = deviceSession.get(DeviceSession.KEY_TIMEZONE);\n                     if (timeZone == null || timeZone.getRawOffset() == 0) {\n                         if (timeZone == null) {\n                             timeZone = TimeZone.getTimeZone(\"UTC\");\n                         }\n                         timeZone.setRawOffset(offset * 1000);\n                         deviceSession.set(DeviceSession.KEY_TIMEZONE, timeZone);\n                     }\n                 }\n            }\n\n            if (deviceSession != null) {\n                // Use the serial number extracted earlier\n                sendResponse(channel, false, type, serial, null);\n            }\n\n            return null; // Login doesn't typically return a position\n\n        } else if (type == MSG_HEARTBEAT) {\n\n            getLastLocation(position, null);\n\n            if (dataLength < 1 || buf.readerIndex() > infoContentEndIndex - 1) return position; // Needs status byte\n            int status = buf.readUnsignedByte();\n            position.set(Position.KEY_ARMED, BitUtil.check(status, 0));\n            position.set(Position.KEY_IGNITION, BitUtil.check(status, 1));\n            position.set(Position.KEY_CHARGE, BitUtil.check(status, 2));\n\n            // Optional fields - check remaining space before reading\n            if (dataLength >= 3 && buf.readerIndex() <= infoContentEndIndex - 2) { // Battery (2 bytes)\n                 position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n            }\n            if (dataLength >= 4 && buf.readerIndex() <= infoContentEndIndex - 1) { // RSSI (1 byte)\n                 position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            }\n\n            sendResponse(channel, false, type, serial, null); // Use extracted serial\n            return position;\n\n        } else if (type == MSG_ADDRESS_REQUEST) {\n            // Specific response format, likely doesn't use standard serial\n            String response = \"NA&&NA&&0##\";\n            ByteBuf content = Unpooled.buffer();\n            content.writeByte(response.length());\n            content.writeInt(0);\n            content.writeBytes(response.getBytes(StandardCharsets.US_ASCII));\n            sendResponse(channel, true, MSG_ADDRESS_RESPONSE, (short) 0, content);\n            return null;\n\n        } else if (type == MSG_TIME_REQUEST) {\n            // Specific response format, likely doesn't use standard serial\n            Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n            ByteBuf content = Unpooled.buffer();\n            content.writeByte(calendar.get(Calendar.YEAR) - 2000);\n            content.writeByte(calendar.get(Calendar.MONTH) + 1);\n            content.writeByte(calendar.get(Calendar.DAY_OF_MONTH));\n            content.writeByte(calendar.get(Calendar.HOUR_OF_DAY));\n            content.writeByte(calendar.get(Calendar.MINUTE));\n            content.writeByte(calendar.get(Calendar.SECOND));\n            sendResponse(channel, false, MSG_TIME_REQUEST, (short) 0, content);\n            return null;\n\n        }\n        // --- Add other message type handlers ('else if') here as in the original code ---\n        // --- Ensure each handler respects bounds (buf.readerIndex() <= infoContentEndIndex - bytesToRead) ---\n        // --- Example structure for a generic handler: ---\n        /*\n        else if (type == SOME_TYPE) {\n            // Check assumptions about dataLength if fixed for this type\n            // Read required fields with bounds checks\n            if (buf.readerIndex() > infoContentEndIndex - 4) return position; // Example check for an int read\n            int someValue = buf.readInt();\n            position.set(\"someKey\", someValue);\n\n            // Read optional fields with bounds checks\n            if (buf.readerIndex() <= infoContentEndIndex - 2) {\n                position.set(\"optionalKey\", buf.readShort());\n            }\n            // Fall through to common tail\n        }\n        */\n        // --- Placeholder for brevity - Copy relevant handlers from original code, adding bounds checks ---\n        else if (type == MSG_X1_GPS) { /* ... (original code with bounds checks) ... */ }\n        else if (type == MSG_X1_PHOTO_INFO) { /* ... (original code with bounds checks, returns null) ... */ }\n        else if (type == MSG_WIFI || type == MSG_WIFI_2 || type == MSG_WIFI_4) { /* ... (original code with bounds checks) ... */ }\n        else if (type == MSG_INFO) { /* ... (original code with bounds checks) ... */ }\n        else if (type == MSG_LBS_MULTIPLE_3 && variant == Variant.SR411_MINI) { /* ... (original code with bounds checks) ... */ }\n        else if (type == MSG_LBS_MULTIPLE_1 || type == MSG_LBS_MULTIPLE_2 || type == MSG_LBS_MULTIPLE_3\n                || type == MSG_LBS_EXTEND || type == MSG_LBS_WIFI || type == MSG_LBS_2\n                || type == MSG_WIFI_3 || type == MSG_WIFI_5) { /* ... (original code with bounds checks) ... */ }\n        else if (type == MSG_STRING) { /* ... (original code with bounds checks, returns position/null) ... */ }\n        else if (type == MSG_BMS) { /* ... (original code with bounds checks, sends response, returns position) ... */ }\n        else if (type == MSG_STATUS && dataLength == 16) { /* ... (original code with bounds checks) ... */ }\n        else if (isSupported(type)) { /* ... (original code with bounds checks, calls helpers) ... */ }\n        else if (type == MSG_ALARM) { /* ... (original code with bounds checks) ... */ }\n        // --- End of placeholder ---\n\n        else { // Handler for unknown types or types not explicitly handled above\n            // Skip any remaining bytes in the Information Content section\n            int currentInfoBytesRead = buf.readerIndex() - 2; // Bytes read within Info section (after Type byte)\n            int remainingInfoBytes = dataLength - currentInfoBytesRead;\n            if (remainingInfoBytes > 0 && buf.readableBytes() >= remainingInfoBytes + 4) { // Check if skippable bytes exist before Serial/CRC\n                 buf.skipBytes(remainingInfoBytes);\n            } else if (remainingInfoBytes < 0) {\n                 // Over-read error occurred in a handler above\n                 return null; // Discard message\n            } // If readableBytes too small, do nothing, let final check handle it\n\n            // Send response for non-command unknown types? Optional.\n            if (type != MSG_COMMAND_0 && type != MSG_COMMAND_1 && type != MSG_COMMAND_2) {\n                sendResponse(channel, false, type, serial, null);\n            }\n            return null; // Discard message data for unknown type\n        }\n\n        // --- Common Tail ---\n        // Executed for message types that generate a position and fall through\n\n        // Final check: Ensure reader index is at the expected end of info content\n        if (buf.readerIndex() < infoContentEndIndex) {\n            // Under-read: Handler didn't consume all dataLength bytes. Skip remaining.\n            int availableToSkip = buf.readableBytes() - 4; // Bytes available before Serial/CRC\n            int calculatedSkip = infoContentEndIndex - buf.readerIndex();\n            if (calculatedSkip > 0 && availableToSkip > 0) {\n                 buf.skipBytes(Math.min(calculatedSkip, availableToSkip));\n            }\n        } else if (buf.readerIndex() > infoContentEndIndex) {\n            // Over-read: Handler read into Serial/CRC. Data might be corrupt.\n            // Log error? Depending on policy, could return null or proceed.\n            // Log.warn(\"Over-read detected for type \" + type);\n            // Proceeding for now, position data might be invalid.\n        }\n        // If readerIndex == infoContentEndIndex, everything was read correctly.\n\n        // Send standard response using the extracted serial number\n        sendResponse(channel, false, type, serial, null);\n\n        return position;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}