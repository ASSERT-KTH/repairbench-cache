{
    "generation": "    @java.lang.SuppressWarnings(\"RedundantCast\")\n    private Object decodeBasic(Channel channel, SocketAddress remoteAddress, ByteBuf buf) {\n\n        // Read packet length (number of bytes from Type to CRC)\n        int length = buf.readUnsignedByte();\n        // Read packet type (protocol number)\n        int type = buf.readUnsignedByte();\n\n        // Calculate minimum expected tail size (Serial Number + CRC)\n        // Language field might be present before Serial Number for some types\n        int minTailSize = 4 + (hasLanguage(type) ? 2 : 0); // Serial(2)+CRC(2)+Lang?(2)\n\n        Position position = new Position(getProtocolName());\n        DeviceSession deviceSession = null;\n        if (type != MSG_LOGIN) {\n            deviceSession = getDeviceSession(channel, remoteAddress);\n            if (deviceSession == null) {\n                // Wait for login message if session doesn't exist yet\n                return null;\n            }\n            position.setDeviceId(deviceSession.getDeviceId());\n            // Initialize timezone if not present in session\n            if (!deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n                deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n            }\n        }\n\n        if (type == MSG_LOGIN) { // 0x01\n\n            String imei = ByteBufUtil.hexDump(buf.readSlice(8)).substring(1);\n            buf.readUnsignedShort(); // Skip information serial number (2 bytes)\n\n            deviceSession = getDeviceSession(channel, remoteAddress, imei);\n            if (deviceSession != null && !deviceSession.contains(DeviceSession.KEY_TIMEZONE)) {\n                deviceSession.set(DeviceSession.KEY_TIMEZONE, getTimeZone(deviceSession.getDeviceId()));\n            }\n\n            // Check if timezone extension exists. Base login length byte is 15 (0x0F).\n            // With timezone extension (4 bytes), length byte is 19 (0x13).\n            // Need 4 ext bytes + 2 serial + 2 crc = 8 readable minimum.\n            if (length > 15 && buf.readableBytes() >= 4 + 4) {\n                int extensionBits = buf.readUnsignedShort();\n                int hours = (extensionBits >> 4) / 100;\n                int minutes = (extensionBits >> 4) % 100;\n                int offset = (hours * 60 + minutes) * 60;\n                if ((extensionBits & 0x8) != 0) { // Check sign bit\n                    offset = -offset;\n                }\n                if (deviceSession != null) {\n                    TimeZone timeZone = deviceSession.get(DeviceSession.KEY_TIMEZONE);\n                    // Only set offset if the default timezone has no offset (e.g., UTC)\n                    if (timeZone.getRawOffset() == 0) {\n                        timeZone.setRawOffset(offset * 1000);\n                        deviceSession.set(DeviceSession.KEY_TIMEZONE, timeZone);\n                    }\n                }\n                 buf.readUnsignedShort(); // Skip reserved / software version (2 bytes)\n            }\n\n            if (deviceSession != null) {\n                // Send response for login\n                if (length >= 5) { // Ensure length is valid for reading serial\n                    try {\n                        // Use packet length relative index for serial number\n                        sendResponse(channel, false, type, buf.getShort(length - 3), null);\n                    } catch (IndexOutOfBoundsException e) {\n                         LOGGER.warn(\"Failed to get serial number for LOGIN type {} with length {}. Index {} out of bounds for buffer size {}.\",\n                                type, length, length - 3, buf.capacity());\n                    }\n                }\n            }\n\n            return null; // Login doesn't return a position\n\n        } else if (type == MSG_HEARTBEAT) { // Often uses type 0x13, same as MSG_STATUS\n\n            getLastLocation(position, null); // Initialize time if needed\n\n            // Status byte decoding (assuming standard heartbeat format)\n            if (buf.readableBytes() >= 1 + minTailSize) { // Check for status byte + tail\n                int status = buf.readUnsignedByte();\n                position.set(Position.KEY_ARMED, BitUtil.check(status, 0));\n                position.set(Position.KEY_IGNITION, BitUtil.check(status, 1));\n                position.set(Position.KEY_CHARGE, BitUtil.check(status, 2));\n\n                // Optional fields (check remaining bytes before reading)\n                // Voltage level (1 byte), GSM signal (1 byte) are common in heartbeats\n                if (buf.readableBytes() >= 1 + minTailSize) {\n                     position.set(Position.KEY_VOLTAGE, buf.readUnsignedByte() * 0.1);\n                }\n                 if (buf.readableBytes() >= 1 + minTailSize) {\n                     position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                 }\n            } else {\n                LOGGER.warn(\"Buffer too short for Heartbeat status byte. Length: {}, Readable: {}\", length, buf.readableBytes());\n                buf.readerIndex(buf.writerIndex()); // Consume buffer\n                return null; // Malformed\n            }\n\n\n            // Send response for heartbeat\n            if (length >= 5) { // Check length for serial reading\n                 try {\n                    // Use packet length relative index for serial number\n                    sendResponse(channel, false, type, buf.getShort(length - 3), null);\n                 } catch (IndexOutOfBoundsException e) {\n                      LOGGER.warn(\"Failed to get serial number for HEARTBEAT type {} with length {}. Index {} out of bounds for buffer size {}.\",\n                                type, length, length - 3, buf.capacity());\n                 }\n            }\n\n            return position;\n\n        } else if (type == MSG_ADDRESS_REQUEST) { // 0x21\n\n            String responseText = \"NA&&NA&&0##\"; // Standard response format\n            ByteBuf content = Unpooled.buffer();\n            content.writeByte(responseText.length()); // Command length\n            content.writeInt(0); // Server flag\n            content.writeBytes(responseText.getBytes(StandardCharsets.US_ASCII));\n            // Send response type 0x21 with content (serial = 0)\n            sendResponse(channel, true, MSG_ADDRESS_REQUEST, (short) 0, content);\n\n            return null;\n\n        } else if (type == MSG_TIME_REQUEST) { // 0x8A\n\n            Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n            ByteBuf content = Unpooled.buffer(6); // 6 bytes for time\n            content.writeByte(calendar.get(Calendar.YEAR) - 2000);\n            content.writeByte(calendar.get(Calendar.MONTH) + 1);\n            content.writeByte(calendar.get(Calendar.DAY_OF_MONTH));\n            content.writeByte(calendar.get(Calendar.HOUR_OF_DAY));\n            content.writeByte(calendar.get(Calendar.MINUTE));\n            content.writeByte(calendar.get(Calendar.SECOND));\n            // Send response type 0x8A with time content (serial = 0)\n            sendResponse(channel, false, MSG_TIME_REQUEST, (short) 0, content);\n\n            return null;\n\n        } else if (type == MSG_X1_GPS) { // 0x24\n             // Define minimum data size before tail for this type\n             // Data/Alarm(4)+GPS(17)+TermInfo(2)+Odo(4)+Cell(9)+Driver(4)+Batt(2)+Power(2)+PortInfo(4)+InOut(2)+ADC(var)\n             int minDataSize = 4 + 17 + 2 + 4 + 9 + 4 + 2 + 2 + 4 + 2; // Minimum size without ADCs\n\n            if (buf.readableBytes() >= minDataSize + minTailSize) {\n                buf.readUnsignedInt(); // data and alarm info (4 bytes)\n                // Use the correct decodeGps signature\n                decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE)); // Reads ~17 bytes\n                buf.readUnsignedShort(); // terminal info (2 bytes)\n                position.set(Position.KEY_ODOMETER, buf.readUnsignedInt()); // 4 bytes\n                // Cell info (MCC, MNC, LAC, CID) = 2 + 1 + 2 + 4 = 9 bytes\n                position.setNetwork(new Network(CellTower.from(\n                        buf.readUnsignedShort(), buf.readUnsignedByte(),\n                        buf.readUnsignedShort(), buf.readUnsignedInt())));\n                // Driver ID (4 bytes)\n                long driverId = buf.readUnsignedInt();\n                if (driverId > 0) {\n                    position.set(Position.KEY_DRIVER_UNIQUE_ID, String.valueOf(driverId));\n                }\n                // Battery and Power (2 + 2 = 4 bytes)\n                position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);\n                long portInfo = buf.readUnsignedInt(); // 4 bytes (controls ADC reading)\n                // Input/Output status (1 + 1 = 2 bytes)\n                position.set(Position.KEY_INPUT, buf.readUnsignedByte());\n                position.set(Position.KEY_OUTPUT, buf.readUnsignedByte());\n                // ADC values (variable number, 2 bytes each)\n                for (int i = 1; i <= BitUtil.between(portInfo, 20, 24); i++) {\n                    // Check readable bytes before reading ADC + tail\n                    if (buf.readableBytes() >= 2 + minTailSize) {\n                         position.set(Position.PREFIX_ADC + i, buf.readUnsignedShort() * 0.01);\n                    } else {\n                        LOGGER.warn(\"Buffer too short for ADC reading in MSG_X1_GPS. Index: {}\", i);\n                        break; // Stop reading ADCs if buffer ends\n                    }\n                }\n            } else {\n                LOGGER.warn(\"Buffer too short for MSG_X1_GPS base data. Length: {}, Readable: {}\", length, buf.readableBytes());\n                buf.readerIndex(buf.writerIndex()); return null; // Malformed\n            }\n            // Response will be sent by common code later\n\n        } else if (type == MSG_X1_PHOTO_INFO) { // 0x25? Placeholder type\n            // Define minimum data size: Time(6)+Fix(1)+Lat(4)+Lon(4)+CamId(1)+Src(1)+Fmt(1)+PhotoLen(4)+PicId(4) = 26\n            int minDataSize = 26;\n            if (buf.readableBytes() >= minDataSize + minTailSize) {\n                buf.skipBytes(6); // time\n                buf.readUnsignedByte(); // fix status\n                buf.readUnsignedInt(); // latitude\n                buf.readUnsignedInt(); // longitude\n                buf.readUnsignedByte(); // camera id\n                buf.readUnsignedByte(); // photo source\n                buf.readUnsignedByte(); // picture format\n                int photoLength = buf.readInt(); // Photo data length\n                int pictureId = buf.readInt(); // Picture ID\n                // Check if photo data itself is present before tail\n                if (buf.readableBytes() >= photoLength + minTailSize) {\n                    ByteBuf photo = Unpooled.buffer(photoLength); // Store photo data later if needed\n                    // buf.readBytes(photo); // Read photo data if needed\n                    buf.skipBytes(photoLength); // Skip photo data for now\n                    photos.put(pictureId, photo); // Store empty buffer for now\n                    sendPhotoRequest(channel, pictureId);\n                } else {\n                    LOGGER.warn(\"Buffer too short for photo data content in MSG_X1_PHOTO_INFO.\");\n                    // Skip remaining buffer to avoid errors\n                    buf.readerIndex(buf.writerIndex());\n                }\n            } else {\n                 LOGGER.warn(\"Buffer too short for photo header data in MSG_X1_PHOTO_INFO.\");\n                 buf.readerIndex(buf.writerIndex());\n            }\n            return null; // No position data, returns null\n\n        } else if (type == MSG_WIFI || type == MSG_WIFI_2 || type == MSG_WIFI_4) { // 0x28, 0x2C, 0xCC\n            // Min Data: Time(6). Specifics depend on type. Check inside.\n            if (buf.readableBytes() >= 6 + minTailSize) {\n                ByteBuf timeSlice = buf.readSlice(6); // Read time (6 BCD bytes)\n                DateBuilder dateBuilder = new DateBuilder()\n                        .setYear(BcdUtil.readInteger(timeSlice, 2))\n                        .setMonth(BcdUtil.readInteger(timeSlice, 2))\n                        .setDay(BcdUtil.readInteger(timeSlice, 2))\n                        .setHour(BcdUtil.readInteger(timeSlice, 2))\n                        .setMinute(BcdUtil.readInteger(timeSlice, 2))\n                        .setSecond(BcdUtil.readInteger(timeSlice, 2));\n                getLastLocation(position, dateBuilder.getDate());\n                Network network = new Network();\n                int wifiCount = 0;\n                if (type == MSG_WIFI_4) { // 0xCC requires Count(1) + AP data + tail\n                    if (buf.readableBytes() >= 1 + minTailSize) {\n                         wifiCount = buf.readUnsignedByte();\n                    } else { LOGGER.warn(\"Buffer short for Wifi count (Type 0xCC).\"); }\n                } else { // 0x28, 0x2C require Cell Info + Wifi Count + AP data + TA + tail\n                    // Peek at Wifi count byte (original logic: getUnsignedByte(readerIndex + 2)) - seems fragile.\n                    // Assuming fixed structure: Time(6)+CellCount(1)+MCC(2)+MNC(1)+Cells+TA(1)+WifiCount(1)+APs+tail\n                    // Let's read based on this assumed structure with checks.\n                    // Try reading cell info first for 0x28/0x2C\n                     int cellCount = 0;\n                     int mcc = 0, mnc = 0;\n                     if (buf.readableBytes() >= 1 + 2 + 1 + minTailSize) { // CellCount+MCC+MNC+tail\n                         cellCount = buf.readUnsignedByte();\n                         mcc = buf.readUnsignedShort();\n                         mnc = buf.readUnsignedByte();\n                         for (int i = 0; i < cellCount; i++) {\n                             // Need LAC(2) + CID(2) + RSSI(1) = 5 bytes per tower\n                             if (buf.readableBytes() >= 5 + minTailSize) { // Check space for cell + tail\n                                 network.addCellTower(CellTower.from(\n                                         mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(), buf.readUnsignedByte()));\n                             } else { LOGGER.warn(\"Buffer short for Cell Tower {}. Type {}\", i, type); break; }\n                         }\n                     } else { LOGGER.warn(\"Buffer short for Cell header. Type {}\", type); }\n                     // Now read TA(1) and WifiCount(1)\n                     if (buf.readableBytes() >= 1 + 1 + minTailSize) {\n                         buf.readUnsignedByte(); // Skip TA\n                         wifiCount = buf.readUnsignedByte();\n                     } else { LOGGER.warn(\"Buffer short for TA/WifiCount. Type {}\", type); }\n                }\n\n                // Read Wifi APs\n                for (int i = 0; i < wifiCount; i++) {\n                     int bytesNeeded = 6; // MAC address\n                     if (type == MSG_WIFI_4) { bytesNeeded += 2; } // Skip 2 bytes\n                     else { bytesNeeded += 1; } // Signal strength\n                    if (buf.readableBytes() >= bytesNeeded + minTailSize) { // Check space for AP + tail\n                         if (type == MSG_WIFI_4) { buf.skipBytes(2); }\n                         WifiAccessPoint wifiAccessPoint = new WifiAccessPoint();\n                         wifiAccessPoint.setMacAddress(String.format(\"%02x:%02x:%02x:%02x:%02x:%02x\",\n                                 buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte(),\n                                 buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte()));\n                         if (type != MSG_WIFI_4) {\n                             wifiAccessPoint.setSignalStrength((int) buf.readUnsignedByte());\n                         }\n                         network.addWifiAccessPoint(wifiAccessPoint);\n                     } else { LOGGER.warn(\"Buffer short for WiFi AP {}. Type {}\", i, type); break; }\n                }\n                 // Custom response logic for 0x28/0x2C removed - rely on standard response\n\n                position.setNetwork(network);\n            } else {\n                LOGGER.warn(\"Buffer too short for WiFi base data (Time). Type {}\", type);\n                buf.readerIndex(buf.writerIndex()); return null; // Malformed\n            }\n            // Response will be sent by common code later\n\n        } else if (type == MSG_INFO) { // 0x94\n            // Structure assumed: Power(2) + tail\n             getLastLocation(position, null);\n             if (buf.readableBytes() >= 2 + minTailSize) {\n                 position.set(Position.KEY_POWER, buf.readShort() * 0.01);\n             } else {\n                 LOGGER.warn(\"Buffer too short for Power in MSG_INFO.\");\n                 // Don't bail out, partial info might be acceptable\n             }\n            // Response will be sent by common code later\n\n        } else if (type == MSG_LBS_MULTIPLE_3 && variant == Variant.SR411_MINI) { // 0xA3 variant\n             // Structure: GPS + LBS + Ignition(1) + Power(2) + Battery(2) + tail\n             // Estimate GPS(~17) + LBS(~9) + Trailer(5) = 31 bytes minimum data\n             int minDataSize = 31;\n            if (buf.readableBytes() >= minDataSize + minTailSize) {\n                decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));\n                decodeLbs(position, buf, type, false); // LBS data\n                // Read trailer fields\n                position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n                position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);\n                position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n            } else {\n                 LOGGER.warn(\"Buffer too short for MSG_LBS_MULTIPLE_3 (SR411_MINI) data.\");\n                 buf.readerIndex(buf.writerIndex()); return null; // Malformed\n            }\n            // Response will be sent by common code later\n\n        } else if (type == MSG_LBS_MULTIPLE_1 || type == MSG_LBS_MULTIPLE_2 || type == MSG_LBS_MULTIPLE_3 // 0xA1,A2,A3\n                || type == MSG_LBS_EXTEND || type == MSG_LBS_WIFI || type == MSG_LBS_2 // A4, A5, AA\n                || type == MSG_WIFI_3 || type == MSG_WIFI_5) { // AF, B0\n            // Structure: Time(6) + [TA(1)?] + CellHeader(3/4) + Cells(var) + [TA(1)?] + [Wifi(var)?] + tail\n            int minDataSize = 6 + 3; // Time + MCC/MNC minimum\n            if (buf.readableBytes() >= minDataSize + minTailSize) {\n                boolean longFormat = type == MSG_LBS_2 || type == MSG_WIFI_3 || type == MSG_WIFI_5; // AA, AF, B0\n                DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                        .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                        .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                getLastLocation(position, dateBuilder.getDate());\n                if (variant == Variant.WANWAY_S20) { buf.readUnsignedByte(); } // ta\n                int mcc = buf.readUnsignedShort();\n                int mncBytes = BitUtil.check(mcc, 15) ? 2 : 1;\n                int mnc = mncBytes == 2 ? buf.readUnsignedShort() : buf.readUnsignedByte();\n                Network network = new Network();\n                int cellCount = 0;\n                if (buf.readableBytes() >= 1 + minTailSize) { // Check for cell count byte\n                     cellCount = variant == Variant.WANWAY_S20 ? buf.readUnsignedByte() : (type == MSG_WIFI_5 ? 6 : 7);\n                } else { LOGGER.warn(\"Buffer short for cell count byte. Type {}\", type); }\n\n                for (int i = 0; i < cellCount; i++) {\n                     int lacBytes = longFormat ? 4 : 2;\n                     int cidBytes = longFormat ? 8 : 3;\n                     int bytesNeeded = lacBytes + cidBytes + 1; // + RSSI(1)\n                    if (buf.readableBytes() >= bytesNeeded + minTailSize) { // Check space for cell + tail\n                         int lac = longFormat ? buf.readInt() : buf.readUnsignedShort();\n                         int cid = longFormat ? (int) buf.readLong() : buf.readUnsignedMedium();\n                         int rssi = -buf.readUnsignedByte();\n                         if (lac > 0 && cid > 0) {\n                             network.addCellTower(CellTower.from(BitUtil.to(mcc, 15), mnc, lac, cid, rssi));\n                         }\n                     } else { LOGGER.warn(\"Buffer short for LBS Cell {}. Type {}\", i, type); break; }\n                }\n                if (variant != Variant.WANWAY_S20) {\n                     if (buf.readableBytes() >= 1 + minTailSize) { buf.readUnsignedByte(); } // ta\n                     else { LOGGER.warn(\"Buffer short for TA byte. Type {}\", type); }\n                }\n                if (type != MSG_LBS_MULTIPLE_1 && type != MSG_LBS_MULTIPLE_2 && type != MSG_LBS_MULTIPLE_3 && type != MSG_LBS_2) {\n                    if (buf.readableBytes() >= 1 + minTailSize) { // Check for wifi count\n                         int wifiCount = buf.readUnsignedByte();\n                         for (int i = 0; i < wifiCount; i++) {\n                             if (buf.readableBytes() >= 7 + minTailSize) { // MAC(6) + RSSI(1) + tail\n                                 String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                                 network.addWifiAccessPoint(WifiAccessPoint.from(\n                                         mac.substring(0, mac.length() - 1), buf.readUnsignedByte()));\n                             } else { LOGGER.warn(\"Buffer short for LBS WiFi AP {}. Type {}\", i, type); break; }\n                         }\n                     } else { LOGGER.warn(\"Buffer short for WiFi count. Type {}\", type); }\n                }\n                position.setNetwork(network);\n            } else {\n                LOGGER.warn(\"Buffer too short for LBS base data. Type {}\", type);\n                buf.readerIndex(buf.writerIndex()); return null; // Malformed\n            }\n            // Response will be sent by common code later\n\n        } else if (type == MSG_STRING) { // 0x15\n            // Structure: CmdLen(1) + [Flag(4)+String(CmdLen-4)] + tail\n            getLastLocation(position, null);\n             if (buf.readableBytes() >= 1 + minTailSize) { // Check for CmdLen + tail\n                 int commandLength = buf.readUnsignedByte();\n                 if (commandLength > 0) {\n                     int dataBytesNeeded = commandLength; // Flag(4) + String(CmdLen-4) = CmdLen\n                     if (buf.readableBytes() >= dataBytesNeeded + minTailSize) {\n                         buf.readUnsignedInt(); // server flag (reserved, 4 bytes)\n                         int stringDataLength = commandLength - 4;\n                         if (stringDataLength > 0) {\n                             String data = buf.readSlice(stringDataLength).toString(StandardCharsets.US_ASCII);\n                             if (data.startsWith(\"<ICCID:\") && data.length() >= 27) {\n                                 position.set(Position.KEY_ICCID, data.substring(7, 27));\n                             } else {\n                                 position.set(Position.KEY_RESULT, data);\n                             }\n                         } else if (stringDataLength < 0) { LOGGER.warn(\"Invalid commandLength {} in MSG_STRING.\", commandLength); }\n                     } else { LOGGER.warn(\"Buffer short for command data {}. CmdLen={}, Type {}\", commandLength, type); }\n                 } // else: commandLength is 0, nothing to read\n             } else { LOGGER.warn(\"Buffer short for commandLength byte. Type {}\", type); }\n            // Response will be sent by common code later\n\n        } else if (type == MSG_BMS) { // 0xB9\n            // Structure: DevSerial(8)+Timestamp(4)+BMSData(85)+tail\n            int minDataSize = 8 + 4 + 85;\n            if (buf.readableBytes() >= minDataSize + minTailSize) {\n                buf.skipBytes(8); // device serial number\n                getLastLocation(position, new Date(buf.readUnsignedInt() * 1000)); // timestamp\n                position.set(\"relativeCapacity\", buf.readUnsignedByte());\n                position.set(\"remainingCapacity\", buf.readUnsignedShort());\n                position.set(\"absoluteCapacity\", buf.readUnsignedByte());\n                position.set(\"fullCapacity\", buf.readUnsignedShort());\n                position.set(\"batteryHealth\", buf.readUnsignedByte());\n                position.set(\"batteryTemp\", buf.readUnsignedShort() * 0.1 - 273.1);\n                position.set(\"current\", buf.readUnsignedShort());\n                position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001); // Voltage\n                position.set(\"cycleIndex\", buf.readUnsignedShort());\n                for (int i = 1; i <= 14; i++) {\n                    position.set(\"batteryCell\" + i, buf.readUnsignedShort() * 0.001);\n                }\n                position.set(\"currentChargeInterval\", buf.readUnsignedShort());\n                position.set(\"maxChargeInterval\", buf.readUnsignedShort());\n                position.set(\"barcode\", buf.readCharSequence(16, StandardCharsets.US_ASCII).toString().trim());\n                position.set(\"batteryVersion\", buf.readUnsignedShort());\n                position.set(\"manufacturer\", buf.readCharSequence(16, StandardCharsets.US_ASCII).toString().trim());\n                position.set(\"batteryStatus\", buf.readUnsignedInt()); // BMS status\n                position.set(\"controllerStatus\", buf.readUnsignedInt());\n                position.set(\"controllerFault\", buf.readUnsignedInt());\n\n                // Send response for BMS\n                 if (length >= 5) { // Check length for serial reading\n                     try {\n                         // Use packet length relative index for serial number\n                         sendResponse(channel, false, type, buf.getShort(length - 3), null);\n                     } catch (IndexOutOfBoundsException e) {\n                         LOGGER.warn(\"Failed to get serial number for BMS type {} with length {}. Index {} out of bounds for buffer size {}.\",\n                                 type, length, length - 3, buf.capacity());\n                     }\n                 }\n            } else {\n                 LOGGER.warn(\"Buffer too short for BMS data. Readable: {}, Required: ~{}\", buf.readableBytes(), minDataSize + minTailSize);\n                 buf.readerIndex(buf.writerIndex()); // Consume buffer\n            }\n            return position; // Return position even if buffer was short? Or null? Returning position.\n\n        } else if (type == MSG_STATUS && buf.readableBytes() >= 22 + minTailSize) { // 0x13 specific length check\n             // Structure: Info(1)+Sat(2)+Alarm(1)+LangRaw(1)+BattLvl(1)+Mode(1)+Volt(2)+Res(1)+Times(2)+Time(2)+Temp(2) = 18 bytes data? No, 22 bytes total payload.\n            getLastLocation(position, null);\n            buf.readUnsignedByte(); // information content\n            buf.readUnsignedShort(); // satellites (raw format)\n            buf.readUnsignedByte(); // alarm (raw)\n            buf.readUnsignedByte(); // language (raw)\n            position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); // Raw battery level\n            buf.readUnsignedByte(); // working mode\n            buf.readUnsignedShort(); // working voltage (raw)\n            buf.readUnsignedByte(); // reserved\n            buf.readUnsignedShort(); // working times (count?)\n            buf.readUnsignedShort(); // working time (duration?)\n            int value = buf.readUnsignedShort(); // Temperature raw value\n            double temperature = BitUtil.to(value, 15) * 0.1;\n            position.set(Position.PREFIX_TEMP + 1, BitUtil.check(value, 15) ? temperature : -temperature); // Signed temp\n            // Ensure exactly 22 bytes were consumed before tail\n             int bytesToSkip = 22 - (1 + 2 + 1 + 1 + 1 + 1 + 2 + 1 + 2 + 2 + 2); // Should be 0 if structure is correct\n             if (bytesToSkip > 0 && buf.readableBytes() >= bytesToSkip + minTailSize) {\n                 buf.skipBytes(bytesToSkip);\n             } else if (bytesToSkip < 0) { LOGGER.warn(\"Read too many bytes for MSG_STATUS fixed length.\"); }\n             else if (buf.readableBytes() < minTailSize) { LOGGER.warn(\"Buffer short after MSG_STATUS fixed length data.\"); }\n            // Response will be sent by common code later\n\n        } else if (isSupported(type)) { // Generic handling for GPS/LBS/Status types\n\n            if (type == MSG_LBS_STATUS && variant == Variant.SPACE10X) { // 0xAB variant\n                 buf.readerIndex(buf.writerIndex()); return null; // Skip multi-lbs message\n            }\n\n            if (hasGps(type)) {\n                 // GPS data size: Time(6)+Lat(4)+Lon(4)+Speed(1)+Status/Course(2)=17\n                 if (buf.readableBytes() >= 17 + minTailSize) {\n                     decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));\n                 } else { LOGGER.warn(\"Buffer short for GPS data. Type {}\", type); buf.readerIndex(buf.writerIndex()); return null; }\n            } else {\n                getLastLocation(position, null); // Initialize time if no GPS\n            }\n\n            if (hasLbs(type)) {\n                 // LBS size varies greatly, decodeLbs must handle bounds checks internally\n                 decodeLbs(position, buf, type, hasStatus(type) && type != MSG_LBS_ALARM);\n            }\n\n            if (hasStatus(type)) {\n                 // Base Status: TermInfo(1)+Voltage(1)+GSM(1)=3\n                 if (buf.readableBytes() >= 3 + minTailSize) {\n                     decodeStatus(position, buf); // Reads 3 bytes\n                     if (variant == Variant.OBD6) { // OBD6 adds 8 bytes\n                         if (buf.readableBytes() >= 8 + minTailSize) {\n                             int signal = buf.readUnsignedShort();\n                             position.set(Position.KEY_SATELLITES, BitUtil.between(signal, 10, 15) + BitUtil.between(signal, 5, 10));\n                             position.set(Position.KEY_RSSI, BitUtil.to(signal, 5));\n                             position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));\n                             buf.readUnsignedByte(); // language raw\n                             position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                             buf.readUnsignedByte(); // working mode\n                             position.set(Position.KEY_POWER, buf.readUnsignedShort() / 100.0);\n                         } else { LOGGER.warn(\"Buffer short for OBD6 status ext. Type {}\", type); }\n                     } else { // Standard status adds 3 bytes\n                         if (buf.readableBytes() >= 3 + minTailSize) {\n                             position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte() * 100 / 6); // Specific formula\n                             position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                             position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));\n                         } else { LOGGER.warn(\"Buffer short for standard status ext. Type {}\", type); }\n                     }\n                 } else { LOGGER.warn(\"Buffer short for base Status data. Type {}\", type); }\n            }\n\n            // Type-specific extensions after common parts\n            if (type == MSG_GPS_LBS_1) { // 0x12\n                if (variant == Variant.GT06E_CARD) { // Odo(4)+Len(1)+Data(var)+Alarm(1)+Swiped(1)+tail\n                    if (buf.readableBytes() >= 4 + 1 + minTailSize) {\n                         position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                         int dataLen = buf.readUnsignedByte();\n                         if (buf.readableBytes() >= dataLen + 1 + 1 + minTailSize) {\n                             String data = buf.readCharSequence(dataLen, StandardCharsets.US_ASCII).toString();\n                             buf.readUnsignedByte(); // alarm raw\n                             buf.readUnsignedByte(); // swiped status\n                             position.set(\"driverLicense\", data.trim());\n                         } else { LOGGER.warn(\"Buffer short for GT06E CardLicence data.\"); }\n                    } else { LOGGER.warn(\"Buffer short for GT06E Odometer/DataLen.\"); }\n                } else if (variant == Variant.BENWAY) { // Mask(2)+tail\n                    if (buf.readableBytes() >= 2 + minTailSize) {\n                         int mask = buf.readUnsignedShort();\n                         position.set(Position.KEY_IGNITION, BitUtil.check(mask, 8 + 7));\n                         position.set(Position.PREFIX_IN + 2, BitUtil.check(mask, 8 + 6));\n                         if (BitUtil.check(mask, 8 + 4)) { // Temp reading\n                             int value = BitUtil.to(mask, 4); // Assuming 4 bits for temp value? Check spec.\n                             if (BitUtil.check(mask, 8 + 1)) { value = -value; } // Assuming bit 9 is sign? Check spec.\n                             position.set(Position.PREFIX_TEMP + 1, value);\n                         } else { // ADC reading\n                             int value = BitUtil.to(mask, 5); // Assuming 5 bits for ADC value? Check spec.\n                             if (BitUtil.check(mask, 8 + 5)) { // Flag for raw ADC?\n                                 position.set(Position.PREFIX_ADC + 1, value);\n                             } else { // Flag for scaled ADC?\n                                 position.set(Position.PREFIX_ADC + 1, value * 0.1);\n                             }\n                         }\n                    } else { LOGGER.warn(\"Buffer short for BENWAY mask.\"); }\n                } else if (variant == Variant.VXT01) { // Status(3)+Power(2)+RSSI(1)+AlarmExt(1)+tail\n                    if (buf.readableBytes() >= 3 + 2 + 1 + 1 + minTailSize) {\n                         decodeStatus(position, buf); // Reads 3 bytes if not already done? Redundant?\n                         position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);\n                         position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                         buf.readUnsignedByte(); // alarm extension raw\n                    } else { LOGGER.warn(\"Buffer short for VXT01 extension.\"); }\n                } else if (variant == Variant.S5) { // Status(3)+Power(2)+RSSI(1)+Alarm(1)+Oil(2)+Temp(1)+Odo(4)+tail\n                     if (buf.readableBytes() >= 3 + 2 + 1 + 1 + 2 + 1 + 4 + minTailSize) {\n                         decodeStatus(position, buf); // Redundant?\n                         position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);\n                         position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                         position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedByte()));\n                         position.set(\"oil\", buf.readUnsignedShort());\n                         int temperatureRaw = buf.readUnsignedByte();\n                         int temperature = BitUtil.to(temperatureRaw, 7);\n                         if (BitUtil.check(temperatureRaw, 7)) { temperature = -temperature; }\n                         position.set(Position.PREFIX_TEMP + 1, temperature);\n                         position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 10); // Scaling * 10\n                     } else { LOGGER.warn(\"Buffer short for S5 extension.\"); }\n                }\n            }\n\n            if ((type == MSG_GPS_LBS_2 || type == MSG_GPS_LBS_3 || type == MSG_GPS_LBS_4) // A8, B1, B2\n                    && buf.readableBytes() >= 3 + minTailSize) { // Ignition(1)+Event(1)+Archive(1)+tail\n                position.set(Position.KEY_IGNITION, buf.readUnsignedByte() > 0);\n                position.set(Position.KEY_EVENT, buf.readUnsignedByte()); // reason code raw\n                position.set(Position.KEY_ARCHIVE, buf.readUnsignedByte() > 0);\n            }\n\n            if (type == MSG_GPS_LBS_3 && buf.readableBytes() >= 3 + minTailSize) { // B1 module: ID(2)+Len(1)+Data(var)+tail\n                 int module = buf.readUnsignedShort();\n                 int subLength = buf.readUnsignedByte();\n                 if (buf.readableBytes() >= subLength + minTailSize) {\n                     switch (module) {\n                         case 0x0027: if (subLength == 2) position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01); else buf.skipBytes(subLength); break;\n                         case 0x002E: if (subLength == 4) position.set(Position.KEY_ODOMETER, buf.readUnsignedInt()); else buf.skipBytes(subLength); break;\n                         case 0x003B: if (subLength == 2) position.setAccuracy(buf.readUnsignedShort() * 0.01); else buf.skipBytes(subLength); break;\n                         default: buf.skipBytes(subLength); break;\n                     }\n                 } else { LOGGER.warn(\"Buffer short for GPS_LBS_3 module data. Module {}, SubLen {}\", module, subLength); }\n            }\n            // Removed general odometer check: if (buf.readableBytes() == 4 + 6)\n\n        } else if (type == MSG_ALARM) { // 0x16\n             // Base=1(type)+1(alarm)+Tail(6)=8. Time=6. GPS=18.\n             boolean extendedAlarm = length > 14; // Length includes Type(1)+Data+Tail(6)\n             if (extendedAlarm) { // GPS + Alarm Type + Tail\n                 if (buf.readableBytes() >= 18 + 1 + minTailSize) { // GPS(18)+AlarmType(1)+tail\n                     decodeGps(position, buf, false, deviceSession.get(DeviceSession.KEY_TIMEZONE));\n                 } else { LOGGER.warn(\"Buffer short for extended Alarm GPS.\"); buf.readerIndex(buf.writerIndex()); return null; }\n             } else { // Time + Alarm Type + Tail\n                 if (buf.readableBytes() >= 6 + 1 + minTailSize) { // Time(6)+AlarmType(1)+tail\n                     DateBuilder dateBuilder = new DateBuilder((TimeZone) deviceSession.get(DeviceSession.KEY_TIMEZONE))\n                             .setDate(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte())\n                             .setTime(buf.readUnsignedByte(), buf.readUnsignedByte(), buf.readUnsignedByte());\n                     getLastLocation(position, dateBuilder.getDate());\n                 } else { LOGGER.warn(\"Buffer short for non-extended Alarm time.\"); buf.readerIndex(buf.writerIndex()); return null; }\n             }\n             // Read Alarm Type (1 byte)\n             if (buf.readableBytes() >= 1 + minTailSize) {\n                 short alarmCode = buf.readUnsignedByte();\n                 switch (alarmCode) {\n                     case 0x01: position.set(Position.KEY_ALARM, extendedAlarm ? Position.ALARM_SOS : Position.ALARM_GENERAL); break;\n                     case 0x80: position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION); break;\n                     case 0x87: position.set(Position.KEY_ALARM, Position.ALARM_OVERSPEED); break;\n                     case 0x90: position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION); break;\n                     case 0x91: position.set(Position.KEY_ALARM, Position.ALARM_BRAKING); break;\n                     case 0x92: position.set(Position.KEY_ALARM, Position.ALARM_CORNERING); break;\n                     case 0x93: position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT); break;\n                     default:   position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); break;\n                 }\n             } else { LOGGER.warn(\"Buffer short for Alarm type code.\"); buf.readerIndex(buf.writerIndex()); return null; }\n\n        } else { // Unknown message type\n\n            if (type != MSG_COMMAND_0 && type != MSG_COMMAND_1 && type != MSG_COMMAND_2) {\n                if (length >= 5) { // Check if length allows for Type+Serial+CRC\n                    try {\n                        // Attempt to read serial using packet length relative index\n                        short serial = buf.getShort(length - 3);\n                        sendResponse(channel, false, type, serial, null);\n                    } catch (IndexOutOfBoundsException e) {\n                         LOGGER.warn(\"Failed to get serial for unknown type {} len {}. Index {} OOB for capacity {}.\",\n                                type, length, length - 3, buf.capacity());\n                    }\n                } else {\n                     LOGGER.warn(\"Invalid length {} for unknown type {}, cannot send response\", length, type);\n                }\n            }\n             // Consume remaining bytes of the buffer for unknown type\n             buf.readerIndex(buf.writerIndex());\n            return null;\n        }\n\n        // Common tail processing (Language, Geofence) for types that fall through\n\n        if (hasLanguage(type)) {\n             // Check if enough bytes remain for Lang(2) + Serial(2) + CRC(2) = 6\n             if (buf.readableBytes() >= 6) {\n                 buf.readUnsignedShort(); // Read Language field\n             } else {\n                 // Avoid reading if buffer is short, but log it. Data might be truncated/malformed.\n                 LOGGER.warn(\"Buffer too short for language field. Type: {}, Length: {}, Readable: {}\", type, length, buf.readableBytes());\n                 // Don't return null here, maybe partial data is still useful.\n             }\n        }\n\n        if (type == MSG_GPS_LBS_STATUS_3 || type == MSG_FENCE_MULTI) { // A9, AA check Geofence byte\n             // Check if enough bytes remain for Geofence(1) + Serial(2) + CRC(2) = 5\n             if (buf.readableBytes() >= 5) {\n                 position.set(Position.KEY_GEOFENCE, buf.readUnsignedByte());\n             } else {\n                 LOGGER.warn(\"Buffer too short for geofence field. Type: {}, Length: {}, Readable: {}\", type, length, buf.readableBytes());\n             }\n        }\n\n        // Final common response send (only if not already sent, e.g., by Login, Heartbeat, BMS)\n        // Check if response should be sent based on type\n        boolean responseSent = (type == MSG_LOGIN || type == MSG_HEARTBEAT || type == MSG_BMS ||\n                                type == MSG_ADDRESS_REQUEST || type == MSG_TIME_REQUEST);\n\n        if (!responseSent) {\n            if (length >= 5) { // Ensure length allows for serial+crc\n                 // Check if buffer has enough readable bytes for serial+crc (4 bytes)\n                 if (buf.readableBytes() >= 4) {\n                     try {\n                         // Use packet length relative index for serial number\n                         sendResponse(channel, false, type, buf.getShort(length - 3), null);\n                     } catch (IndexOutOfBoundsException e) {\n                         LOGGER.warn(\"Failed to get serial at common point for type {} len {}. Index {} OOB for readable {}.\",\n                                 type, length, length - 3, buf.readableBytes(), e);\n                     }\n                 } else {\n                      LOGGER.warn(\"Buffer short for Serial/CRC at common point. Type {}, Len {}, Readable {}\", type, length, buf.readableBytes());\n                 }\n            } else {\n                 LOGGER.warn(\"Invalid length {} for type {}, cannot send response at common point\", length, type);\n            }\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}