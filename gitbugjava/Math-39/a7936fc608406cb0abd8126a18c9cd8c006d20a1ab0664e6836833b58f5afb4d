{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // iterate over step size, ensuring local normalized error is smaller than 1\n      double error = 10;\n      boolean firstAttempt = true; // Flag for first attempt within this step\n      while (error >= 1.0) {\n\n        // Determine step size for this attempt\n        if (firstAttempt) {\n            if (firstTime) {\n                // Compute derivatives for the first stage (\u00a74.1 compute g(tn, yn))\n                computeDerivatives(stepStart, y, yDotK[0]);\n\n                // Compute initial step size suggestion\n                final double[] scale = new double[mainSetDimension];\n                if (vecAbsoluteTolerance == null) {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n                    }\n                } else {\n                    for (int i = 0; i < scale.length; ++i) {\n                        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n                    }\n                }\n                hNew = initializeStep(forward, getOrder(), scale,\n                                      stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                firstTime = false; // Overall first time initialization done\n            }\n            // For the first attempt of any step, use the suggested step size\n            stepSize = hNew;\n            firstAttempt = false; // Mark first attempt as done\n        } else {\n            // Step was rejected, reduce step size based on error\n            final double factor =\n                FastMath.min(maxGrowth,\n                             FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            stepSize = stepSize * factor; // Reduce the previously attempted stepSize\n        }\n\n        // If !fsal, compute the first stage derivative f(stepStart, y) for this attempt.\n        // (If fsal, yDotK[0] is assumed to be correct from the previous step or initial computation).\n        // Skip if firstTime was true (handled above), otherwise yDotK[0] needs recomputation if !fsal.\n        // Note: firstTime is false after the first attempt of the first step.\n        if (!fsal && !firstTime && firstAttempt) { // Condition simplifies: compute if !fsal and not the very first attempt overall\n             // Error in logic simplification above. Revert to original logic structure for computing yDotK[0].\n             // It should be computed if it's the first attempt OR if !fsal. The 'firstTime' check is separate for hNew init.\n             // Let's rethink: yDotK[0] = f(stepStart, y). It only needs recomputation if !fsal OR if it's the very first step.\n             // The original code's check `if (firstTime || !fsal)` before the loop was almost correct, but needs to be inside.\n        }\n        // Correct logic for yDotK[0] computation inside the loop:\n        // It needs to be computed before step size determination only on the very first step (firstTime=true).\n        // If !fsal, it needs to be computed at the start of *every* attempt within the while loop.\n        // If fsal, it's computed only on the very first step, and subsequent attempts reuse the value from the previous *accepted* step.\n        // The calculation is split: initial computation during firstTime, re-computation if !fsal inside the loop.\n\n        if (!fsal && !firstTime) { // If not FSAL and not the first step ever (where it was already computed)\n            computeDerivatives(stepStart, y, yDotK[0]); // Recompute f(t_n, y_n) for this attempt\n        }\n\n\n        // Ensure the step size for THIS attempt does not overshoot the final time t\n        final double dt = t - stepStart; // Remaining time\n        if (forward) {\n            if (stepSize > dt) {\n                stepSize = dt;\n            }\n        } else { // backward\n            if (stepSize < dt) { // dt is negative, stepSize is negative\n                stepSize = dt;\n            }\n        }\n\n        // Apply min/max step and other filtering\n        // Accept small steps if we were capped by dt (means this is effectively the last step segment)\n        stepSize = filterStep(stepSize, forward, FastMath.abs(stepSize) <= FastMath.abs(dt));\n\n\n        // Prevent zero step size if possible (filterStep should handle minStep)\n        if (stepSize == 0.0 && stepStart != t) {\n             // This might indicate dt was zero or smaller than minStep and filterStep returned 0.\n             // Or floating point issues. The integration should likely stop.\n             // Let acceptStep handle the isLastStep logic based on comparing stepStart+stepSize to t.\n             // If stepSize is truly zero, the RK stages might fail.\n             // However, filterStep is expected to throw if step size is below minimum (unless acceptSmall is true).\n             // If stepSize==dt and dt was < minStep, acceptSmall=true allows it.\n        }\n\n\n        // Perform the Runge-Kutta stages\n        // yDotK[0] is assumed to be correctly set at this point.\n        for (int k = 1; k < stages; ++k) {\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n          // Time evaluation below uses the capped stepSize, ensuring t is not exceeded.\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n        }\n\n        // Estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // Estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // Reject the step. The loop will continue, step size will be reduced\n          // based on the rejected stepSize in the next iteration.\n          // firstAttempt remains false.\n          // If !fsal, yDotK[0] will be recomputed.\n        }\n\n      } // End of error control loop (while error >= 1.0)\n\n      // local error is small enough: accept the step\n      interpolator.storeTime(stepStart + stepSize); // Store time for the end of the accepted step\n      System.arraycopy(yTmp, 0, y, 0, y0.length); // Update main state vector y\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length); // Store last derivative for FSAL/handlers\n      stepStart = acceptStep(interpolator, y, yDotTmp, t); // Perform end-of-step tasks, update stepStart, update isLastStep\n      System.arraycopy(y, 0, yTmp, 0, y.length); // Update yTmp for interpolator consistency (y is the state at new stepStart)\n\n      if (!isLastStep) {\n          // Prepare for the next step\n\n          interpolator.storeTime(stepStart); // Store the new stepStart for the interpolator\n\n          if (fsal) {\n              // Save the last evaluation for the next step's first stage\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          // Estimate step size for the next step attempt (hNew)\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp))); // error < 1.0 here\n          final double scaledH = stepSize * factor; // stepSize is the accepted size of the completed step\n          final double nextT = stepStart + scaledH; // Potential time at end of next step\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n\n          // Filter the suggested step size (min/max bounds)\n          // Pass nextIsLast hint to potentially allow a small step if it's the final one\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          // Now, explicitly check if the filtered step size would still overshoot t,\n          // and if so, adjust it to hit t exactly. This corrects the aim for the next step.\n          final double filteredNextT = stepStart + hNew;\n          final boolean filteredIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredIsLast) {\n              hNew = t - stepStart; // Aim exactly for the final time\n          }\n          // hNew now holds the recommended step size for the *next* attempt\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart); // Should be == t if integration finished normally\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}