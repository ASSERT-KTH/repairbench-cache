{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Assuming 'full' map and 'unescapePattern' are accessible static members of the containing class.\n// e.g. static Map<String, Integer> full;\n// e.g. static Pattern unescapePattern = Pattern.compile(\"&(#(?:x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Note: The original code had a comment indicating 'unescapePattern' is:\n        // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        // Group 1: (#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+) -> Either the numeric structure starting with # OR the name\n        // Group 2: (x|X)?                             -> Captures 'x' or 'X' if present (numeric hex)\n        // Group 3: ([0-9a-fA-F]+)                    -> Captures the digits/hex digits (numeric)\n        Matcher m = unescapePattern.matcher(string);\n\n        // Use StringBuilder for efficiency as synchronization is not required.\n        StringBuilder accum = new StringBuilder(string.length());\n\n        while (m.find()) {\n            int charval = -1;\n            String entityMatch = m.group(0); // The full matched entity text e.g., \"&amp;\" or \"&#123;\"\n            String numValStr = m.group(3);   // The numeric value string (digits/hex), or null for named entities\n            String hexIndicator = m.group(2); // \"x\" or \"X\" if present, indicating hex\n\n            if (numValStr != null) {\n                // Numeric entity: &#...; or &#x...;\n                try {\n                    int base = (hexIndicator != null) ? 16 : 10;\n                    charval = Integer.parseInt(numValStr, base);\n                    // Check if the parsed codepoint is valid. Integer.parseInt doesn't throw for invalid codepoints.\n                    if (!Character.isValidCodePoint(charval)) {\n                        charval = -1; // Treat invalid codepoints as unrecognized entities\n                    }\n                } catch (NumberFormatException e) {\n                    // Malformed numeric entity (e.g., \"&#xG;\"), treat as unrecognized\n                    // charval remains -1\n                }\n            } else {\n                // Named entity: &...;\n                String name = m.group(1); // Group 1 contains the name if numValStr (group 3) is null\n                if (full.containsKey(name)) { // Assuming 'full' is the Map<String, Integer> of named entities\n                    charval = full.get(name);\n                    // No need to check isValidCodePoint here if we trust the 'full' map contents\n                }\n                // else: Unknown named entity - charval remains -1\n            }\n\n            if (charval != -1) {\n                // Successfully decoded a known entity to a valid codepoint\n                // Convert codepoint to String (handles BMP and supplementary characters)\n                String decodedChar = new String(Character.toChars(charval));\n                // CRITICAL FIX: Use Matcher.quoteReplacement to escape special characters (like \\ and $)\n                // in the replacement string, preventing IllegalArgumentException.\n                m.appendReplacement(accum, Matcher.quoteReplacement(decodedChar));\n            } else {\n                // Unrecognized entity (malformed numeric, unknown name, or invalid codepoint)\n                // Append the original matched entity text verbatim.\n                // Use quoteReplacement here too for safety, in case the original text contained $ or \\.\n                m.appendReplacement(accum, Matcher.quoteReplacement(entityMatch));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}