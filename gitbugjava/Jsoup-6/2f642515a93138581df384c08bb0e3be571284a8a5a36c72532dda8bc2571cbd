{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.Map; // Assuming 'full' map is of type Map<String, Integer>\n\n// Assume 'full' map and 'unescapePattern' pattern are defined and accessible in the surrounding class.\n// Example definitions (based on typical usage in libraries like Jsoup):\n// static final Map<String, Integer> full = Entities.full; // Assuming Entities class provides the map\n// static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|([a-zA-Z]+));?\");\n// Note: The original code's group index usage (group 1 for name, 3 for num, 2 for hex) suggests a different pattern was potentially used or the indices were confused.\n// The fix below uses the group indices as per the original code's logic (1=name, 3=num, 2=hex).\n// If the actual 'unescapePattern' uses different group indices (like the common pattern above where 4=name, 3=num, 2=hex),\n// the group indices (1, 2, 3) in the code below would need adjustment to match the pattern.\n\n/**\n * Unescapes HTML entities in a string.\n *\n * @param string input string containing potentially escaped entities.\n * @return string with entities unescaped.\n */\nstatic String unescape(String string) {\n    // Assume unescapePattern is defined elsewhere and matches the logic below:\n    // Group 2: Optional hex indicator (x|X)\n    // Group 3: Numeric value ([0-9a-fA-F]+)\n    // Group 1: Named entity ([a-zA-Z]+) <-- This assignment implies a specific regex structure was intended or used.\n\n    if (string == null || !string.contains(\"&\")) // Added null check for robustness\n        return string;\n\n    // This pattern reflects the group indices used in the original buggy code (1=name, 2=hex, 3=num).\n    // If the actual `unescapePattern` has different groups, this might need adjustment.\n    // Example pattern matching the code's group usage: Pattern.compile(\"&(?:([a-zA-Z]+)|#(x|X)?([0-9a-fA-F]+));?\");\n    Matcher m = unescapePattern.matcher(string);\n    // Using StringBuffer because Matcher.appendReplacement requires it (pre-Java 9).\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3); // Numeric value (Group 3)\n\n        if (num != null) { // If it's a numeric entity (Group 3 matched)\n            try {\n                String hexIndicator = m.group(2); // Hex indicator (Group 2)\n                int base = hexIndicator != null ? 16 : 10;\n                charval = Integer.parseInt(num, base);\n            } catch (NumberFormatException e) {\n                // skip, charval remains -1 (malformed numeric entity)\n            }\n        } else { // Otherwise, try matching as a named entity\n            String name = m.group(1); // Named entity (Group 1, as per original code logic)\n            // Assuming 'full' is the map from entity name to character value\n            if (name != null && full.containsKey(name)) {\n               charval = full.get(name);\n            }\n            // If name was null or not in map, charval remains -1\n        }\n\n        // Now, decide what to append based on whether a valid charval was found\n        if (charval != -1) { // If a valid entity was found and parsed (charval >= 0)\n            String replacement;\n            // Correctly handle supplementary Unicode characters (codepoints > 0xFFFF)\n            // Character.MAX_VALUE is 0xFFFF\n            if (charval > Character.MAX_VALUE) {\n                replacement = new String(Character.toChars(charval));\n            } else {\n                // Handle BMP characters (codepoints <= 0xFFFF)\n                replacement = Character.toString((char) charval);\n            }\n            // *** FIX: Use Matcher.quoteReplacement ***\n            // This escapes special characters ('$' and '\\') in the replacement string,\n            // preventing IllegalArgumentException.\n            m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n        } else {\n            // Entity was not recognized (numeric parse failed or named entity unknown)\n            // Append the original matched sequence (e.g., \"&unknown;\", \"&#invalid;\") literally.\n            // *** FIX: Use Matcher.quoteReplacement ***\n            // Applied here for safety, although m.group(0) (the original entity like \"&amp;\")\n            // is less likely to contain problematic '$' or '\\' characters.\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}