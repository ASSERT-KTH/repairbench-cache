{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Assume Entities.full map and Entities.unescapePattern pattern exist and are accessible static members of the enclosing class.\n// Assume Entities.unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|([a-zA-Z]+));?\");\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Use the pattern assumed in the original code's comments and logic structure\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|([a-zA-Z]+));?\n        // Use StringBuilder for performance as hinted by original code comment, avoids unnecessary synchronization.\n        StringBuilder accum = new StringBuilder(string.length());\n\n        while (m.find()) {\n            int charval = -1;\n            String entity = m.group(0); // The full matched entity string (e.g., \"&#123;\", \"&amp;\")\n            String num = m.group(3);   // Group 3 captures the numeric value part\n            String name = m.group(4);  // Group 4 captures the named entity name part (Fix: Original code used group 1 incorrectly)\n\n            if (num != null) {\n                // Numeric entity &#[xX]?<NUM>;\n                try {\n                    String hexIndicator = m.group(2); // Group 2 captures the hex indicator 'x' or 'X'\n                    int base = hexIndicator != null ? 16 : 10;\n                    // Use parseInt instead of valueOf for potentially better performance (avoids object creation)\n                    charval = Integer.parseInt(num, base);\n                } catch (NumberFormatException e) {\n                    // Malformed numeric entity (e.g., \"&#xFG;\"). Keep charval = -1.\n                }\n            } else if (name != null) {\n                // Named entity &<NAME>;\n                if (full.containsKey(name)) { // Assuming 'full' is the map of named entities\n                    charval = full.get(name);\n                }\n                // If name is not in the map, charval remains -1 (unrecognized named entity).\n            }\n            // else: The pattern matched, but neither group 3 nor group 4 was captured.\n            // This shouldn't happen with the assumed pattern structure but check handles it defensively. Keep charval = -1.\n\n            if (charval != -1) {\n                // Successfully decoded a valid entity codepoint.\n                // Convert codepoint to String. Character.toChars correctly handles supplementary characters (codepoints > 0xFFFF).\n                String replacement = new String(Character.toChars(charval));\n\n                // CRITICAL FIX: Use Matcher.quoteReplacement to escape special characters ('$' and '\\')\n                // in the replacement string. This prevents the IllegalArgumentException.\n                m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n            } else {\n                // The entity was malformed or unrecognized (charval remained -1).\n                // Append the original matched text back to the accumulator.\n                // Use quoteReplacement here too for robustness, although m.group(0) is less likely to contain problematic chars.\n                m.appendReplacement(accum, Matcher.quoteReplacement(entity));\n            }\n        }\n        m.appendTail(accum); // Append the remainder of the input string after the last match.\n        return accum.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}