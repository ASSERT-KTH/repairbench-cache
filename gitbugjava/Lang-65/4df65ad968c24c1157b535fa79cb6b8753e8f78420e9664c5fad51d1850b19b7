{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     *\n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        // Note: fields array must be ordered from smallest to largest time unit\n        // eg. {{Calendar.MILLISECOND}, {Calendar.SECOND}, {Calendar.MINUTE}, {Calendar.HOUR_OF_DAY, Calendar.HOUR}, ... }\n\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        // Using Calendar.add(), as done below, is thought to be potentially safer\n        // than Calendar.set() around DST transitions based on the discussion in LANG-59.\n        // No separate handling block is implemented here; the change is integrated into the main loop.\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        boolean roundUpSet = false; // Tracks if roundUp has been determined by the first modified field\n\n        for (int i = 0; i < fields.length; i++) {\n            int[] currentFieldGroup = fields[i];\n            int primaryField = currentFieldGroup[0]; // The primary field representative of the group\n\n            // Check if the target field 'field' is part of the current field group\n            boolean fieldFound = false;\n            for (int currentField : currentFieldGroup) {\n                if (currentField == field) {\n                    fieldFound = true;\n                    break;\n                }\n            }\n\n            if (fieldFound) {\n                // Target field found. Stop processing smaller units.\n                // Apply rounding if needed, based on the roundUp flag from the first smaller field modified.\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // Special case: SEMI_MONTH rounding\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field == Calendar.AM_PM) {\n                        // Special case: AM_PM rounding adds 12 hours\n                        val.add(Calendar.HOUR_OF_DAY, 12);\n                    } else {\n                        // General case: Add 1 to the primary field of the target group\n                        val.add(primaryField, 1);\n                    }\n                }\n                return; // Modification complete\n            }\n\n            // We are processing a field group smaller than the target field (e.g., processing minutes when target is hours).\n            // We need to truncate this field group and determine if its value requires rounding up the target field.\n            int offset = 0;\n            boolean offsetSet = false; // Indicates if offset/currentRoundUp is handled by special logic\n            boolean currentRoundUp = false; // Rounding decision based *only* on this field group's value\n\n            // Handle special truncation/rounding logic based on the *target* field 'field'\n            // This logic applies when modifying a *smaller* field (primaryField) in preparation for the target field.\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    // Rules apply when modifying the DATE field (primaryField) because the target is SEMI_MONTH\n                    if (primaryField == Calendar.DATE) {\n                        int date = val.get(Calendar.DATE);\n                        offset = date - 1; // Offset from day 1\n                        if (offset >= 15) {\n                            offset -= 15; // Offset within the second half (0-15 approx)\n                        }\n                        // Round up if more than halfway through the semi-month period (7 days)\n                        currentRoundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    // Rules apply when modifying HOUR_OF_DAY (primaryField) because the target is AM_PM\n                    if (primaryField == Calendar.HOUR_OF_DAY) { // Assuming HOUR_OF_DAY is the primary field for its group\n                        int hourOfDay = val.get(Calendar.HOUR_OF_DAY);\n                        // Determine roundUp based on hour within the current 12-hour cycle (AM or PM)\n                        int hourInCycle = hourOfDay % 12; // Hour 0-11\n                        currentRoundUp = hourInCycle >= 6; // Round up if hour is 6 or more in the cycle\n\n                        // Determine offset for truncation: truncate to 0 for AM, 12 for PM\n                        offset = hourOfDay; // Default offset for AM (truncate to 0)\n                        if (hourOfDay >= 12) { // If PM\n                            offset = hourOfDay - 12; // Offset from 12 PM\n                        }\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // Default truncation/rounding logic if not handled by special cases\n            if (!offsetSet) {\n                int min = val.getActualMinimum(primaryField);\n                int max = val.getActualMaximum(primaryField);\n                offset = val.get(primaryField) - min; // Offset from the minimum value\n                // Round up if value is more than halfway through the range\n                currentRoundUp = offset * 2 > (max - min);\n            }\n\n            // Determine the overall roundUp decision based on the *first* field group modified.\n            // If a field is already at its minimum (offset == 0), it doesn't contribute to rounding up.\n            if (!roundUpSet && offset != 0) {\n                roundUp = currentRoundUp;\n                roundUpSet = true;\n            }\n\n            // Truncate the current field group by removing the calculated offset.\n            if (offset != 0) {\n                // Use Calendar.add() instead of Calendar.set() to subtract the offset.\n                // This is hypothesized to be safer regarding DST issues per LANG-59.\n                val.add(primaryField, -offset);\n            }\n        }\n\n        // If the loop completes without finding the field, it's unsupported.\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n\n    // --- Helper fields/constants assumed to exist (replace with actual definitions) ---\n\n    /** Represents the middle of the month or the start of the second half. Placeholder value. */\n    private static class DateUtils { // Dummy class for context\n        public static final int SEMI_MONTH = 1001; // Example value\n    }\n\n    /**\n     * Field groups, ordered smallest unit to largest. The first field in each group\n     * is considered the primary field for modification.\n     */\n    private static final int[][] fields = {\n        {Calendar.MILLISECOND},\n        {Calendar.SECOND},\n        {Calendar.MINUTE},\n        {Calendar.HOUR_OF_DAY, Calendar.HOUR}, // HOUR_OF_DAY is primary\n        {Calendar.AM_PM}, // Governed by HOUR_OF_DAY modification\n        {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.DAY_OF_YEAR}, // DATE is primary\n        {DateUtils.SEMI_MONTH}, // Special handling based on DATE\n        {Calendar.MONTH},\n        {Calendar.YEAR}\n    };",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}