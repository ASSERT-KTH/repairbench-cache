{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods if the target field is HOUR or larger.\n        // This prevents issues during DST transitions where Calendar.set() on lower\n        // fields might trigger unnecessary recalculations and change the DST offset.\n        if (field == Calendar.HOUR_OF_DAY || field == Calendar.HOUR || field == Calendar.AM_PM\n                || field == Calendar.DATE || field == Calendar.DAY_OF_YEAR || field == DateUtils.SEMI_MONTH\n                || field == Calendar.MONTH || field == Calendar.YEAR) {\n            // reset time Milliseconds, Seconds and Minutes\n            val.set(Calendar.MILLISECOND, 0);\n            val.set(Calendar.SECOND, 0);\n            val.set(Calendar.MINUTE, 0);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        // fields is expected to be an array like:\n        // {{Calendar.MILLISECOND}, {Calendar.SECOND}, {Calendar.MINUTE}, {Calendar.HOUR_OF_DAY, Calendar.HOUR}, ...}\n        // It iterates from smaller fields to larger fields.\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        // } else if (field == Calendar.AM_PM) { // Original code didn't handle AM_PM rounding explicitly here\n                        //     // If AM/PM is to be rounded, midnight becomes noon, noon becomes midnight\n                        //     // val.add(Calendar.HOUR_OF_DAY, 12); // This might be the logic\n                        } else {\n                            //We need to add one to this field since the\n                            //  last number causes us to round up\n                            // Add to the primary field of the group (fields[i][0])\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return; // Found the target field, modification complete.\n                }\n            }\n            \n            // Current field group fields[i] is smaller than the target field.\n            // We need to truncate this field group and determine if rounding affects the next level.\n            int offset = 0;\n            boolean offsetSet = false;\n            int currentField = fields[i][0]; // The primary field to truncate in this group.\n\n            // These are special types of fields that require different rounding rules\n            // The switch is on the TARGET field ('field'), affecting how the CURRENT field ('currentField') is handled.\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    // When truncating/rounding to SEMI_MONTH, DATE handling is special.\n                    if (currentField == Calendar.DATE) {\n                        // If we're processing the DATE field group before reaching SEMI_MONTH:\n                        // Calculate offset within the 1-15 or 16-end range.\n                        offset = val.get(Calendar.DATE) - 1; // Offset from day 1\n                        if (offset >= 15) {\n                            offset -= 15; // Offset within the second half (0-15 range approx)\n                        }\n                        // roundUp if day is 8-15 or 23-31\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    // When truncating/rounding to AM_PM, HOUR_OF_DAY handling is special.\n                    if (currentField == Calendar.HOUR_OF_DAY) {\n                         // If we're processing the HOUR_OF_DAY field group before reaching AM_PM:\n                        // Calculate offset within the AM or PM block (0-11).\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12; // hours past noon (0-11)\n                        }\n                        // roundUp if hour is 7-11 or 19-23. Original code had > 6.\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // If not a special case handled above, calculate offset and roundUp based on standard field range.\n            if (!offsetSet) {\n                int min = val.getActualMinimum(currentField);\n                int max = val.getActualMaximum(currentField);\n                // Calculate the offset from the minimum allowed value\n                offset = val.get(currentField) - min;\n                // Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n            \n            // Truncate the current field value.\n            // We need to remove the calculated offset from the current value.\n            if (currentField == Calendar.MILLISECOND) {\n                 // Specific fix for LANG-59 related test failure: avoid Calendar.set(MILLISECOND, 0)\n                 // which can cause DST issues. Use setTimeInMillis instead.\n                 // Offset for MILLISECOND is val.get(MILLISECOND) since min is 0.\n                 long T = val.getTimeInMillis();\n                 val.setTimeInMillis(T - offset); // Equivalent to T - (T % 1000)\n            } else {\n                 // For other fields (SECOND, MINUTE, HOUR_OF_DAY, etc.):\n                 // Truncate by setting the field to its minimum value.\n                 // The original calculation val.get(currentField) - offset achieves this:\n                 // val.get(currentField) - (val.get(currentField) - min) = min\n                 // This set call might still be problematic for SECOND/MINUTE near DST, but\n                 // it's handled by the preemptive LANG-59 fix if the target field is >= HOUR.\n                 // If the target field is MINUTE or SECOND, this set is called for smaller fields.\n                 val.set(currentField, val.get(currentField) - offset);\n            }\n        }\n        // Should not happen if 'field' is valid and present in 'fields' array.\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}