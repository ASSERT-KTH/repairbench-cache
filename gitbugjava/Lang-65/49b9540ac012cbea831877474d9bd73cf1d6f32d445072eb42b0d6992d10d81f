{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        // Check if year is too large for accurate calculations\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // Use Calendar.add() to modify fields smaller than the target field instead of Calendar.set().\n        // This avoids issues where set() recalculates DST incorrectly, particularly for\n        // MILLISECOND, SECOND, and MINUTE fields near DST transitions.\n        // See http://issues.apache.org/jira/browse/LANG-59\n        // Assumes the 'fields' array (static member, not shown) is ordered from smallest time unit (MILLISECOND) to largest (YEAR).\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false; // Stores whether the previous (smaller) field's value indicated rounding up.\n\n        // Iterate through the field levels defined in the 'fields' array (expected smallest to largest).\n        for (int i = 0; i < fields.length; i++) {\n\n            // Check if the target field 'field' exists at the current level fields[i]\n            boolean fieldFound = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    fieldFound = true;\n                    break; // Target field found in this group\n                }\n            }\n\n            // If the target field was found at the current level:\n            if (fieldFound) {\n                // Apply rounding if requested ('round' is true) and if the previous, smaller field\n                // calculation determined we should round up ('roundUp' is true).\n                if (round && roundUp) {\n                    // Special handling for SEMI_MONTH field rounding\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // If date is 1, round to 16th; otherwise (it's 16), round to next month 1st.\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    // General rounding: add 1 unit to the primary field of the current level.\n                    } else {\n                        // Add 1 to the primary field of this level (e.g., add 1 hour if field is HOUR)\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                // Modification stops once the target field level is processed.\n                return;\n            }\n\n            // If the target field was NOT found at level i:\n            // This means the fields at level 'i' are smaller than the target field.\n            // These fields need to be truncated (set to their minimum value),\n            // and we need to determine if their original value warrants rounding up\n            // the next higher field (which might be the target field in the next iteration).\n\n            int currentField = fields[i][0]; // The primary field for this level to be modified.\n            int offset = 0;           // The amount this field is above its minimum value.\n            boolean offsetSet = false; // Flag for special offset calculation.\n\n            // Special calculation for offset and roundUp decision for specific target fields (SEMI_MONTH, AM_PM)\n            // when processing smaller, contributing fields (DATE, HOUR_OF_DAY).\n            switch (field) { // Switch on the *target* field\n                case DateUtils.SEMI_MONTH:\n                    // This case applies only if the target field is SEMI_MONTH.\n                    // We are processing a smaller field level 'i'. Check if it's DATE level.\n                    if (currentField == Calendar.DATE) {\n                        // Calculate offset from the start of the semi-month (1st or 16th)\n                        offset = val.get(Calendar.DATE) - 1;\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        // Determine roundUp based on midpoint (7) of the 15-day half\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                     // This case applies only if the target field is AM_PM.\n                     // We are processing a smaller field level 'i'. Check if it's HOUR_OF_DAY level.\n                    if (currentField == Calendar.HOUR_OF_DAY) {\n                        // Calculate offset from the start of the AM/PM period (0 or 12)\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        // Determine roundUp based on midpoint (6) of the 12-hour half\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // If offset wasn't determined by special rules, calculate it generally.\n            if (!offsetSet) {\n                int min = val.getActualMinimum(currentField);\n                int max = val.getActualMaximum(currentField);\n                // Offset is the value relative to the minimum for this field.\n                offset = val.get(currentField) - min;\n                // Determine if rounding is needed based on whether the value is past the midpoint.\n                // Check against (max - min) / 2. Using multiplication avoids potential floating point issues and integer division truncation.\n                roundUp = offset * 2 > (max - min);\n            }\n\n            // If the field is not already at its minimum value (offset > 0), truncate it\n            // by subtracting the calculated offset using add().\n            if (offset != 0) {\n                // *** THE FIX for LANG-59: Use add() instead of set() ***\n                // Subtracting the offset using add() effectively resets the field to its minimum value\n                // (e.g., add(MILLISECOND, -millis), add(SECOND, -seconds), add(DATE, -(day-1)) )\n                // while avoiding the DST recalculation issues associated with set().\n                val.add(currentField, -offset); // Use add() to adjust the field value\n            }\n            // The 'roundUp' value calculated here is carried to the next loop iteration,\n            // potentially affecting the rounding of the next larger field group.\n        }\n\n        // If the loop finishes without finding the target field, it's unsupported.\n        // This implies 'field' was not a value present in the 'fields' array structure.\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}