{
    "generation": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (tb.framesetOk() && isWhitespace(c)) { // only ignore whitespace if framesetOk\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            Constants.Formatters)) { // Includes: b, big, code, em, font, i, s, small, strike, strong, tt, u\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements(); // Doubled?\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name, Constants.FormattingElements)) { // Includes: a, b, big, code, em, font, i, nobr, s, small, strike, strong, tt, u\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb); // nothing to close\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true; // not on stack, skip closing\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this); // Can't close elements outside of scope violations\n                                return false;\n                            } else if (tb.currentElement() != formatEl) {\n                                tb.error(this); // Active formatting element is not the current element. Indicates mis-nested content.\n                                // Uses adoption agency algorithm.\n                            }\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            //boolean seenFormattingElement = false; // not used as logic simplified vs spec\n                            LinkedList<Element> stack = tb.getStack();\n                            int formatElPos = stack.indexOf(formatEl);\n                            Validate.isTrue(formatElPos != -1); // already checked segment exists on stack\n\n                            // Find the furthest matching node, limited depth Scan down stack from formatEl position + 1\n                            // ref https://html.spec.whatwg.org/multipage/parsing.html#adoption-agency-algorithm - steps 4 - 7\n                            // \"Let furthest block be the topmost node in the stack of open elements below the formatting element...\"\n                            final int MaxUsedAdjustedInsertionLocation = 64; // same as spec suggestion (\"somewhat arbitrary\")\n                            for (int si = formatElPos + 1; si < stack.size() && si < formatElPos + MaxUsedAdjustedInsertionLocation; si++) {\n                                Element el = stack.get(si);\n                                if (tb.isSpecial(el)) {\n                                    furthestBlock = el;\n                                    break;\n                                }\n                            }\n\n                            if (furthestBlock == null) {\n                                // didn't find a scope marker barrier, so pop up to element formatEl node.\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // Adoption agency scenarios follow:\n                            // Find common ancestor node:\n                            commonAncestor = tb.aboveOnStack(furthestBlock); // Element above the furthest block.\n                            if (commonAncestor == null) { // If it's null, it's an error. Should always have the stack root.\n                                tb.error(this); return false;\n                            }\n\n                            // bookmark concepts are dropped in favour of directly tracking node positions in stack + AFE list\n\n                            // The inner loop is the core of the adoption agency algorithm. Create elements as required + foster nodes\n                            // ref https://html.spec.whatwg.org/multipage/parsing.html#adoption-agency-algorithm - steps 10 - 15\n                            Element node = furthestBlock; // Start with the furthest block being examined/moved\n                            Element lastNode = furthestBlock; // Track the last node that was moved\n\n                            INNER:\n                            // foster up to 3 elements.: https://html.spec.whatwg.org/multipage/parsing.html#adoption-agency-algorithm (step 10)\n                            for (int j = 0; j < 3; j++) {\n                                // Find the element BEFORE the current node 'node' in the stack\n                                node = tb.aboveOnStack(node);\n                                if (node == null || !tb.onStack(node)) // Fell off stack = error\n                                     break INNER; // should not happen in normal flow\n\n                                if (!tb.isInActiveFormattingElements(node)) { // If node is not an active formatting element. Remove from stack (and AFE?)\n                                    tb.removeFromStack(node); // remove it from stack. an bookmark would be dropped\n                                    continue INNER; // Restart inner loop with node above node\n                                } else if (node == formatEl) { // Found the element we wanted to foster past\n                                    break INNER; // Do nothing else in inner loop\n                                }\n\n                                // If we are here, node is an AFE element that is not the expected formatEl\n                                // Create a clone of the element node to foster past:\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                replacement.attributes().addAll(node.attributes().clone()); // copy attributes\n\n                                // Replace node with replacement element in AFE, Stack\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                // ^^ node is still the original node element; replacement is the clone. node is removed ^^\n\n                                // Foster the lastNode (first iteration: furthestBlock) into the replacement clone:\n                                if (lastNode.parent() != null)\n                                    lastNode.remove(); // remove from existing parent\n                                replacement.appendChild(lastNode); // foster into replacement\n\n                                lastNode = replacement; // update last node for next foster iteration\n                            }\n\n\n                            // Foster the last node (including newly fostered children) into the common ancestor:\n                            // ref https://html.spec.whatwg.org/multipage/parsing.html#adoption-agency-algorithm (step 16)\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                // Foster parent fosters lastNode outside the table structure\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                // Otherwise, foster to the common ancestor:\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            // Adoption phase: create new element for original formatting element, move children of furthest block to it\n                            // ref https://html.spec.whatwg.org/multipage/parsing.html#adoption-agency-algorithm (steps 17-20)\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes().clone()); // copy attributes\n\n                            // Move children of furthest block node into the new adopter node\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter); // Add the adopted element to the furthest block node\n\n                            // Cleanup + Reinsert / update state:\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // Insert the adopted node adopter onto the stack after the furthest block node:\n                            tb.removeFromStack(formatEl); // Remove original formatting node from stack\n                            tb.insertOnStackAfter(furthestBlock, adopter); // Insert adopter node after furthest block node\n                            // Ok to process next token. Continue to OUTER to process stack for next formatting element.\n                        }\n\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) { // Should be \"!tb.inScope(name)\"?\n                             // Fixed based on spec: check for current tag name in scope\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}