{
    "generation": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Initialize roots.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      hoistExterns(externsRoot);\n\n      // Check if the sources need to be re-ordered.\n      boolean staleInputs = false;\n      // Use the instance moduleGraph. It might be null if modules are not used.\n      JSModuleGraph graph = moduleGraph;\n      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        // Initialize the graph if it doesn't exist.\n        // IMPORTANT: Assign back to the instance variable 'moduleGraph'\n        // so that repartitionInputs() later uses the same instance.\n        if (graph == null) {\n           graph = new JSModuleGraph(modules);\n           this.moduleGraph = graph;\n        }\n\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (CompilerInput input : inputs) {\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          // Perform dependency management using the graph. This potentially\n          // modifies the order of the inputs list.\n          inputs =\n              graph.manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true; // Inputs may have been re-ordered.\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          // If in IDE mode, we ignore the error and keep going.\n          // Otherwise, stop processing if errors occurred.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          // If in IDE mode, we ignore the error and keep going.\n          // Otherwise, stop processing if errors occurred.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      // Hoisting of @nocompile files might change input order and\n      // trigger repartitioning internally.\n      hoistNoCompileFiles();\n\n      // Repartition inputs if dependency management detected staleness (inputs reordered).\n      // This ensures module structure matches the potentially new input order.\n      // It needs to run *after* hoistNoCompileFiles, as that function might\n      // alter the inputs list and trigger its own repartitioning.\n      // The check here handles the case where only dependency sorting occurred.\n      if (staleInputs) {\n        // Because 'graph' was initialized and assigned to this.moduleGraph\n        // within the 'if' block above (where staleInputs was set to true),\n        // this.moduleGraph is guaranteed non-null here.\n        repartitionInputs();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) { // Iterate the final ordered inputs\n        Node n = input.getAstRoot(this);\n        if (n == null) { // Input may be empty or skipped due to errors\n          continue;\n        }\n\n        if (devMode) {\n          // TODO(b/146424846): Reinstate runSanityCheck once it is faster.\n          // runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      // Check for errors introduced during parsing or AST generation.\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}