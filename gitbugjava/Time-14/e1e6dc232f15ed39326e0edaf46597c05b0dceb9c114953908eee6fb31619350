{
    "generation": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // This method is typically called when the field is the largest in the partial,\n        // or when it is computed based on larger fields (like dayOfYear based on year).\n        // The calculation relies on having a full date context for accuracy,\n        // especially around leap years.\n        if (DateTimeUtils.isContiguous(partial)) {\n            // Use a known leap year (e.g., 2004) as the base instant context\n            // for calculations involving partial dates like MonthDay or DayOfYear\n            // to ensure correct handling of Feb 29th and end-of-month adjustments.\n            // Epoch (1970) is not a leap year, leading to errors.\n            long instant = iChronology.getDateTimeMillis(2004, 1, 1, 0); // Base instant in a leap year\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                // Reconstruct the date fields onto the base instant\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            // Perform the addition using the DateTimeField's add method\n            instant = add(instant, valueToAdd);\n            // Extract the updated values from the resulting instant\n            return iChronology.get(partial, instant);\n        } else {\n            // If the partial is not contiguous (e.g., YearMonth), the superclass\n            // algorithm might be sufficient, or a different approach is needed.\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}