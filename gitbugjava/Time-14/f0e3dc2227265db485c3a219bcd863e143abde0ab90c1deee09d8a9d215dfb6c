{
    "generation": "    //-----------------------------------------------------------------------\n    /**\n     * Adds the value to the specified fieldIndex and values array throwing\n     * exceptions if arguments are invalid or the new values are invalid.\n     * <p>\n     * This implementation is suitable for month-day partials handling\n     * calculations involving Feb 29. It uses a full datetime based on\n     * a leap year (2004) to perform the calculation.\n     *\n     * @param partial  the partial instant to add to\n     * @param fieldIndex  the index of the field to add to\n     * @param values  the values of the partial instant fields\n     * @param valueToAdd  the value to add\n     * @return the new values array\n     * @throws IllegalArgumentException if the value is invalid\n     */\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n\n        // This method is typically called by Partial fields (like MonthDay)\n        // The partial fields should be contiguous for this specialized logic to work.\n        if (DateTimeUtils.isContiguous(partial)) {\n            // Use a reference point in a leap year (2004) to handle Feb 29 correctly.\n            // Using the middle of a day avoids potential DST crossover issues.\n            // Note: This assumes the chronology is year-based.\n            // Use UTC midnight to avoid timezone issues entirely. The time part doesn't\n            // affect month/day calculations. Let chronology handle any specifics.\n            long instant = iChronology.getDateTimeMillis(2004, 1, 1, 0, 0, 0, 0);\n\n            // Set the partial's values onto this reference instant.\n            // This establishes a concrete point in time like 2004-MM-DD HH:MM:SS.\n            // Chronology's set method should handle the partial fields correctly.\n            instant = iChronology.set(partial, instant);\n\n            // Get the appropriate field from the chronology based on the fieldIndex\n            // (e.g., 0 for month, 1 for day in MonthDay) and add the value to the instant\n            // using that field's specific addition logic (handles month lengths, leap years etc.).\n            instant = partial.getField(fieldIndex, iChronology).add(instant, valueToAdd);\n\n            // Extract the relevant field values from the resulting instant back into\n            // the partial's structure.\n            return iChronology.get(partial, instant);\n        } else {\n            // Delegate to the superclass implementation for non-contiguous partials\n            // or other cases not handled here.\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}