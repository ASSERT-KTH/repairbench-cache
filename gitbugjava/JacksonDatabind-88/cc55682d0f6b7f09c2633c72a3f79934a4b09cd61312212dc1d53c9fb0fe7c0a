{
    "generation": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        JavaType t;\n\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            // Use constructFromCanonical to handle generics\n            t = tf.constructFromCanonical(id);\n            // Need to check compatibility with base type\n            // 11-Nov-2017, tatu: Also need to ensure type compatibility with base type\n            // N \u09b0\u09ac\u09bf, 18 \u05de\u05e8\u05e5 2018, \u05d3\u05d9\u05de\u05d4: use isTypeOrSubTypeOf instead of isAssignableFrom\n            if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n                 throw new IllegalArgumentException(String.format(\n \"Invalid type id '%s' (for id type '%s'): specified type %s not subtype of base type %s\",\n                         id, _idType.name(), t.toCanonical(), _baseType.toCanonical()));\n             }\n             // We trust the external type id mechanism to produce valid type (relative to base)\n             // -- we cannot check that further, only make sure it's somewhat compatible.\n             // Compatibility is checked above; this should be fine.\n            return t;\n        }\n        // Else, non-generic type\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\n                    \"Invalid type id '%s' (for id type '%s'): %s\", id, _idType.name(), e.getMessage()), e);\n        }\n        // Now construct the specialized type: this also checks for basic compatibility\n        t = tf.constructSpecializedType(_baseType, cls);\n        // 08-Mar-2017, tatu: Maybe this should be moved earlier, theoretically?\n        // Or possibly should not do? For now, keep as is. See [databind#1576]\n        return t;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}