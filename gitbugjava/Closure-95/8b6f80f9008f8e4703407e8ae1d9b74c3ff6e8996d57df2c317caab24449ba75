{
    "generation": "    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Determine the variable name.\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // Determine the scope where the variable should be declared.\n      Scope scopeToDeclareIn = scope; // Default to current scope.\n      boolean isQualifiedName = n.getType() == Token.GETPROP;\n\n      if (isQualifiedName) {\n        // For qualified names (e.g., ns.foo), find the scope of the root object (e.g., ns).\n        Preconditions.checkArgument(\n            parent.getType() == Token.ASSIGN ||\n            parent.getType() == Token.EXPR_RESULT);\n        String rootName = n.getFirstChild().getQualifiedName();\n        // If rootName is null, this might be complex expression like (a + b).c = 1;\n        // Such cases might not be handled robustly by getQualifiedName(), but typically\n        // we're dealing with simple names or chains like a.b.c.\n        if (rootName != null) {\n          Var rootVar = scope.getVar(rootName);\n          if (rootVar != null) {\n            // Declare in the scope where the root object is defined.\n            scopeToDeclareIn = rootVar.getScope();\n          }\n          // If rootVar is not found, it might be an undeclared variable,\n          // error reporting for that happens elsewhere. We default to the current scope,\n          // though ideally it might go in the global scope if intended as a global property.\n          // However, sticking to the root var's scope or current scope is safer.\n        }\n      } else { // n.getType() == Token.NAME\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n      }\n\n\n      // Check if the variable is already declared in the target scope.\n      // Use isDeclared specific to the scope, not checking parents.\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        // Declare the variable in the determined scope.\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        // Update the global 'this' object if this variable is declared in the\n        // global scope.\n        boolean shouldDeclareOnGlobalThis = false;\n        if (scopeToDeclareIn.isGlobal()) {\n           if (n.getType() == Token.NAME) {\n               // Only VARs and FUNCTIONs defined directly in global scope\n               // should be properties of globalThis.\n               shouldDeclareOnGlobalThis = (parent.getType() == Token.VAR ||\n                                            parent.getType() == Token.FUNCTION);\n           } else { // GETPROP\n               // Qualified names assigned in the global scope represent properties\n               // on the global scope (directly or indirectly via other global objects).\n               // We model these as properties of globalThis for type checking.\n               shouldDeclareOnGlobalThis = true;\n           }\n        }\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                // Use UNKNOWN_TYPE if type is null, consistent with function comment.\n                type == null ? getNativeType(JSTypeNative.UNKNOWN_TYPE) : type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // If we're declaring a function in the global scope, also declare its prototype.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}