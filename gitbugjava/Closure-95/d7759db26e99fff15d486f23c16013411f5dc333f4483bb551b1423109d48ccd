{
    "generation": "    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualified names.\n      // Check the structure is valid.\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.isName()) {\n        Preconditions.checkArgument(\n            parent.isFunction() ||\n            parent.isVar() ||\n            parent.isParamList() || // Use isParamList for function parameters (formerly LP)\n            parent.isCatch());\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.isVar() ||\n             parent.isFunction());\n      } else {\n        Preconditions.checkArgument(\n            n.isGetProp() && // Use Node predicate\n            (parent.isAssign() ||\n             parent.isExprResult()));\n      }\n      String variableName = n.getQualifiedName();\n      // Make sure variableName is not null or empty, which can happen for\n      // some invalid code structures or complex GETPROPs.\n      Preconditions.checkArgument(variableName != null && !variableName.isEmpty(), \"VariableName is empty or null for node %s\", n);\n\n\n      // If n is a property (GETPROP), determine the scope in which to declare it.\n      // Typically, this is the scope where the root object of the property chain is defined.\n      // For example, if 'a' is global, 'a.b.c = 1' inside a function should declare\n      // 'a.b.c' in the global scope.\n      Scope scopeToDeclareIn = scope; // Default to the current scope.\n      if (n.isGetProp()) {\n        Node rootNode = n;\n        // Traverse down the property chain to find the root, e.g., 'a' in 'a.b.c'.\n        while (rootNode.isGetProp()) {\n          rootNode = rootNode.getFirstChild();\n        }\n\n        // If the root is a simple variable name (e.g., 'a' in 'a.b.c = 1').\n        if (rootNode.isName()) {\n          String rootVarName = rootNode.getString();\n          // Find the variable in the current scope chain.\n          Var rootVar = scope.getVar(rootVarName);\n          if (rootVar != null) {\n            Scope definingScope = rootVar.getScope();\n            if (definingScope != null) {\n              // Declare the property in the scope where the base variable is defined.\n              scopeToDeclareIn = definingScope;\n            }\n            // If definingScope is null (e.g., perhaps for built-ins or externs\n            // defined without a clear scope pointer?), we fall back to declaring\n            // in the current scope, which matches the original behavior in\n            // ambiguous cases.\n          }\n          // If the root variable itself is not found (e.g., 'undeclared.prop = 1'),\n          // declare the property in the current scope. This matches the original\n          // behavior and allows handling of potentially undeclared variables.\n        }\n        // If the root is not a name (e.g., 'this.prop', '(getObj()).prop', 'arr[0].prop'),\n        // then declaring the property in the current scope ('scope') is generally\n        // the most sensible approach.\n      }\n\n      // Check if the variable name is already declared in the target scope.\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        // If it is declared, it might be an error (redeclaration) or\n        // a harmless assignment. The validator handles this determination.\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        // If it's not declared in the target scope, declare it now.\n        if (!inferred) {\n          // Associate the declared type with the node if it wasn't inferred.\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        // It's possible that input is null if the sourceName is unknown (e.g., synthetic code).\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        // If 'n' was a NAME declared at the top level of the global scope\n        // (e.g., var x = 1; or function x() {}), also define it on the GlobalThis object type\n        // for accurate modeling of the global object.\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          // Input can be null, indicating the source file is unknown.\n          // Treat this as non-extern in that case.\n          boolean isExtern = (input != null && input.isExtern());\n          if (inferred) {\n             // Use NO_TYPE if type is null for inferred properties on GlobalThis,\n             // consistent with the original code's apparent behavior.\n            JSType typeToDeclare = type == null ? getNativeType(JSTypeNative.NO_TYPE) : type;\n            globalThis.defineInferredProperty(variableName, typeToDeclare, isExtern);\n          } else {\n            // If not inferred, type should not be null based on the initial precondition.\n            Preconditions.checkNotNull(type);\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // Handle '.prototype' property specifically. If we just declared a function type\n        // (constructor or interface) in the *global* scope, we should also implicitly\n        // declare its '.prototype' property in the global scope.\n        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            // Determine if the prototype itself should be marked as \"declared\".\n            // This seems to depend on whether an explicit superclass other than Object is involved.\n            boolean prototypeMarkedDeclared = !(superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n\n            // Declare \"FunctionName.prototype\" in the global scope.\n            // Use the same CompilerInput as the function declaration.\n            // There's no specific AST node for the prototype property itself, so pass null.\n            scopeToDeclareIn.declare(variableName + \".prototype\", null,\n                fnType.getPrototype(), input,\n                prototypeMarkedDeclared);\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}