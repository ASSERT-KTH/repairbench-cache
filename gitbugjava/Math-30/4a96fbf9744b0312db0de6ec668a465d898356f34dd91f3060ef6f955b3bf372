{
    "generation": "    /**\n     * @param Umin smallest Mann-Whitney U value\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final long n1n2prod = (long) n1 * n2; // Use long to avoid intermediate overflow\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        // Cast to double before multiplying by (n1 + n2 + 1) to avoid overflow\n        final double VarU = n1n2prod / 12.0 * (n1 + n2 + 1);\n\n        // Compute z using VarU. If VarU is 0, handle appropriately.\n        // (VarU can be 0 if n1=0 or n2=0 or n1+n2+1=0, though checks upstream might prevent this)\n        // However, the direct formula for z is robust towards VarU = 0 if handled correctly later.\n        // If VarU is 0, Umin must equal EU (both 0), z should be 0?\n        // Let's consider edge cases: If n1=0 or n2=0, n1n2prod=0, EU=0, VarU=0. Umin would also be 0.\n        // z = (0 - 0) / sqrt(0) -> 0/0 -> NaN.\n        // A p-value for n=0 is typically undefined or 1. The calling method likely handles n=0 cases.\n        // Assuming n1, n2 > 0.\n\n        // Check for VarU == 0 to avoid division by zero or sqrt of negative (though VarU formula >= 0)\n        if (VarU == 0) {\n             // If variance is 0, data is likely identical or samples are empty.\n             // Umin should equal EU in this case. z = 0, p-value = 1.\n             // Or handle as per statistical convention for zero variance.\n             // Let's assume standard normal CDF of 0 gives 0.5, so 2 * 0.5 = 1.\n             // This case implies no variance/difference.\n             final double z = 0; // Effectively (Umin - EU) is 0 if VarU is 0\n        }\n\n        // Calculate z-score\n        final double sqrtVarU = FastMath.sqrt(VarU);\n        // Avoid division by zero if VarU is extremely small but not exactly 0.\n        if (sqrtVarU == 0) {\n            // Consider Umin == EU, z=0. P-value=1.\n             final double z = 0;\n        }\n\n        final double z = (Umin - EU) / sqrtVarU;\n\n\n        final NormalDistribution standardNormal = new NormalDistribution(null, 0, 1, // Use default RNG, mean 0, sd 1\n                                           NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}