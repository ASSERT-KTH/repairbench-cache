{
    "generation": "  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match contraints on anonymous types.\n    // This function is permissive, viewing {a:1} as compatible with {a:number|undefined},\n    // and {} as compatible with {a: number} by inferring an optional property.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraintObj.isRecordType()) {\n      RecordType constraintRecordType = constraintObj.toMaybeRecordType();\n      for (String prop : constraintRecordType.getOwnPropertyNames()) {\n        JSType propType = constraintRecordType.getPropertyType(prop);\n\n        // If the property is not explicitly declared (e.g., in JSDoc)\n        // AND it's not present on the object literal type itself,\n        // then we infer it from the constraint, making it optional.\n        // This allows an object literal like {} to satisfy a constraint like {prop: number}.\n        // We check !hasProperty before defining, to ensure we don't overwrite\n        // a property declared on the object literal. Type checking handles mismatches\n        // for existing properties.\n        if (!isPropertyTypeDeclared(prop) && !hasProperty(prop)) {\n          // Make the inferred property optional, by unioning with void.\n          JSType typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(propType);\n          defineInferredProperty(prop, typeToInfer, /* propertyNode= */ null);\n        }\n        // NOTE: The previous code had an 'else' path here (effectively):\n        // if (!isPropertyTypeDeclared(prop)) {\n        //   if (!hasProperty(prop)) { .. make optional .. }\n        //   defineInferredProperty(prop, non_optional_prop_type, null);\n        // }\n        // This meant that if a property was present on the literal (hasProperty=true)\n        // but not declared (isPropertyTypeDeclared=false), its type would be\n        // overwritten by the constraint's propType via defineInferredProperty.\n        // This could mask type errors if the literal's type didn't match the\n        // constraint's type. The corrected code avoids this overwrite.\n      }\n    }\n    // TODO(nicksantos): Handle the case where the constraint object is a function.\n    // TODO(nicksantos): Handle the case where the constraint object is some other\n    // crazy type. Maybe throw an error. Or maybe this is OK.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}