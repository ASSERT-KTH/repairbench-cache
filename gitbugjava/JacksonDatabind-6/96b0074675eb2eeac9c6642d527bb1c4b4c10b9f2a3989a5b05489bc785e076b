{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         * Handle Z, +hh:mm, +hhmm, +hh, -hh:mm, -hhmm, -hh formats.\n         * Also, handle missing seconds and milliseconds. Added checks for varying\n         * number of millisecond digits (databind#570). Trim excess (databind#172).\n         */\n        int len = dateStr.length();\n        String normDateStr = dateStr;\n        DateFormat df;\n\n        // 1. Handle Plain Date (no time, YYYY-MM-DD)\n        if (len <= 10 && Character.isDigit(normDateStr.charAt(len-1))) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n            // No normalization needed\n            return df.parse(normDateStr, pos);\n        }\n\n        // 2. Handle 'Z' (UTC) Timezone\n        if (normDateStr.endsWith(\"Z\")) {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n\n            // Need to normalize for missing/partial seconds/milliseconds\n            int zIndex = len - 1;\n            // Find the location of 'T' separator; needed to find beginning of time part\n            int tIndex = normDateStr.lastIndexOf('T', zIndex);\n             // If no T, base index calculations on first colon, assuming HH:mm... format\n            if (tIndex == -1) tIndex = normDateStr.indexOf(':') -2;\n            if (tIndex < 0) tIndex = 0; // Failsafe\n\n            // Locate decimal point separating seconds and milliseconds (must be after 'T')\n            int dotIndex = normDateStr.lastIndexOf('.', zIndex);\n            if (dotIndex < tIndex) dotIndex = -1;\n\n            StringBuilder sb = new StringBuilder(normDateStr);\n            if (dotIndex == -1) { // No fractional seconds found\n                // Check for presence of seconds: find the second colon after 'T'\n                int colonIndex1 = normDateStr.indexOf(':', tIndex + 1);\n                int colonIndex2 = (colonIndex1 == -1) ? -1 : normDateStr.indexOf(':', colonIndex1 + 1);\n\n                // Append \":ss.SSS\" based on number of colons found before 'Z'\n                if (colonIndex1 == -1 || colonIndex1 >= zIndex) { // Format like \"THHZ\"? (No colons after T)\n                    // Insert default time only if 'T' was actually present\n                    if (tIndex != -1 && tIndex < zIndex -1) {\n                        sb.insert(zIndex, \":00:00.000\");\n                        normDateStr = sb.toString();\n                    } // else: malformed or just date? Let parser fail\n                } else if (colonIndex2 == -1 || colonIndex2 >= zIndex) { // Format like \"THH:mmZ\"? (One colon after T)\n                    sb.insert(zIndex, \":00.000\"); // Insert missing seconds and millis\n                    normDateStr = sb.toString();\n                } else { // Format like \"THH:mm:ssZ\"? (Two colons after T)\n                    sb.insert(zIndex, \".000\"); // Insert missing millis\n                    normDateStr = sb.toString();\n                }\n            } else { // Fractional seconds present: HH:mm:ss.SSS...Z\n                // Normalize milliseconds to exactly 3 digits\n                int fractionLen = zIndex - (dotIndex + 1);\n                if (fractionLen < 3) { // Pad with trailing '0's\n                    for (; fractionLen < 3; ++fractionLen) {\n                        sb.insert(zIndex, '0');\n                    }\n                    normDateStr = sb.toString();\n                } else if (fractionLen > 3) { // Trim excess digits [databind#172]\n                    sb.delete(dotIndex + 1 + 3, zIndex);\n                    normDateStr = sb.toString();\n                }\n                // else fractionLen == 3, perfect\n            }\n        }\n        // 3. Handle +/-HH:mm or +/-HHmm Timezone\n        else if (hasTimeZone(normDateStr)) {\n            df = _formatISO8601;\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n\n            // Find start of timezone ('+' or '-')\n            int signIndex = Math.max(normDateStr.lastIndexOf('+'), normDateStr.lastIndexOf('-'));\n            String tzPart = normDateStr.substring(signIndex);\n            String dateTimePart = normDateStr.substring(0, signIndex);\n            StringBuilder sb = new StringBuilder(dateTimePart); // Build normalized string starting with date/time part\n\n            // Normalize timezone: remove ':', add '00' if missing minutes\n            if (tzPart.indexOf(':') != -1) { // Format \"+HH:mm\" -> \"+HHmm\"\n                 tzPart = tzPart.substring(0, 3) + tzPart.substring(4);\n            } else if (tzPart.length() == 3) { // Format \"+HH\" -> \"+HH00\"\n                 tzPart += \"00\";\n            } // else: assume \"+HHmm\" format is ok, or malformed -> let parser fail\n\n            // Normalize the dateTimePart for missing/partial seconds/milliseconds\n            int dtLen = dateTimePart.length();\n            int tIndex = dateTimePart.lastIndexOf('T');\n            if (tIndex == -1) tIndex = dateTimePart.indexOf(':') -2;\n            if (tIndex < 0) tIndex = 0;\n\n            int dotIndex = dateTimePart.lastIndexOf('.');\n            if (dotIndex < tIndex) dotIndex = -1; // Dot must be after 'T'\n\n            if (dotIndex == -1) { // No fractional seconds\n                int colonIndex1 = dateTimePart.indexOf(':', tIndex+1);\n                int colonIndex2 = (colonIndex1 == -1) ? -1 : dateTimePart.indexOf(':', colonIndex1 + 1);\n\n                // Append \":ss.SSS\" based on number of colons found in dateTimePart\n                if (colonIndex1 == -1 || colonIndex1 >= dtLen) { // Format like \"THH+zone\"?\n                    if (tIndex != -1 && tIndex < dtLen-1) { // Check T exists and time part not empty\n                         sb.append(\":00:00.000\");\n                    }\n                } else if (colonIndex2 == -1 || colonIndex2 >= dtLen) { // Format like \"THH:mm+zone\"?\n                     sb.append(\":00.000\"); // Append missing seconds and millis\n                } else { // Format like \"THH:mm:ss+zone\"?\n                    sb.append(\".000\"); // Append missing millis\n                }\n            } else { // Fractional seconds present HH:mm:ss.SSS...\n                 // Normalize milliseconds to exactly 3 digits\n                 int fractionLen = dtLen - (dotIndex + 1);\n                 if (fractionLen < 3) { // Pad with trailing '0's\n                     for (int i = fractionLen; i < 3; ++i) {\n                         sb.append('0');\n                     }\n                 } else if (fractionLen > 3) { // Trim excess digits\n                     sb.setLength(dotIndex + 1 + 3); // Truncate dateTimePart in StringBuilder\n                 }\n                 // else fractionLen == 3, perfect\n            }\n\n            // Append the normalized timezone\n            sb.append(tzPart);\n            normDateStr = sb.toString();\n        }\n        // 4. Handle No Timezone (Implicit UTC, append 'Z')\n        else {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n\n            // Normalize seconds/milliseconds before appending 'Z'\n            StringBuilder sb = new StringBuilder(normDateStr);\n            int currentLen = sb.length();\n            int tIndex = normDateStr.lastIndexOf('T');\n            if (tIndex == -1) tIndex = normDateStr.indexOf(':') -2;\n            if (tIndex < 0) tIndex = 0;\n\n            int dotIndex = normDateStr.lastIndexOf('.');\n            if (dotIndex < tIndex) dotIndex = -1;\n\n            if (dotIndex == -1) { // No fractional seconds\n                 int colonIndex1 = normDateStr.indexOf(':', tIndex+1);\n                 int colonIndex2 = (colonIndex1 == -1) ? -1 : normDateStr.indexOf(':', colonIndex1 + 1);\n\n                 // Append \":ss.SSS\" based on number of colons found\n                 if (colonIndex1 == -1 || colonIndex1 >= currentLen) { // Format like \"THH\"?\n                     if (tIndex != -1 && tIndex < currentLen-1) { // Check T exists and time part not empty\n                        sb.append(\":00:00.000\");\n                     }\n                 } else if (colonIndex2 == -1 || colonIndex2 >= currentLen) { // Format like \"THH:mm\"?\n                    sb.append(\":00.000\"); // Append missing seconds and millis\n                 } else { // Format like \"THH:mm:ss\"?\n                    sb.append(\".000\"); // Append missing millis\n                 }\n            } else { // Fractional seconds present (HH:mm:ss.SSS...)\n                 // Normalize milliseconds to exactly 3 digits\n                 int fractionLen = currentLen - (dotIndex + 1);\n                 if (fractionLen < 3) { // Pad\n                     for (; fractionLen < 3; ++fractionLen) {\n                        sb.append('0');\n                     }\n                 } else if (fractionLen > 3) { // Trim\n                     sb.setLength(dotIndex + 1 + 3);\n                 }\n                 // else fractionLen == 3, perfect\n            }\n\n            // Append 'Z' for implicit UTC\n            sb.append('Z');\n            normDateStr = sb.toString();\n        }\n\n        // Final Parse with the appropriate formatter and normalized string\n        return df.parse(normDateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}