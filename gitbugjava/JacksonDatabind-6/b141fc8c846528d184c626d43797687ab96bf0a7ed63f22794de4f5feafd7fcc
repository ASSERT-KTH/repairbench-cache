{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         *    (see [JACKSON-42], [JACKSON-103], [JACKSON-200], [JACKSON-334])\n         *\n         * And possibly even more robust handling would be needed, see\n         * http://www.w3.org/TR/NOTE-datetime for more complete handling.\n         * But for now, let's try this approach.\n         */\n        final int len = dateStr.length();\n        DateFormat df;\n\n        // First things first: remove optional colon from +/+MM:SS timezone indicator\n        // (parse pattern Z requires it be removed)\n        char c = dateStr.charAt(len-1);\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        // Another consideration: need to ensure format is yyyy-MM-dd\n        if (len <= 10 && Character.isDigit(c)) {\n             df = _formatPlain;\n             if (df == null) {\n                 df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n             }\n        // Zulu-formatted date?\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // Let's handle possible trailing junk here? Or should we fail?\n            // For now, fail will occur if junk is found\n\n            // Additionally, need to handle missing seconds / milliseconds\n            // \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"\n\n            // First: find 'T'\n            int tIndex = dateStr.lastIndexOf('T');\n            if (tIndex >= 0) {\n                // Then see if we have seconds specification\n                // 18-Oct-2014, tatu: Specs differ on this; some indicate 'T' is enough...\n                //   Let's assume it's optional. Find last colon.\n                int timeEndIdx = len-1; // Index of 'Z'\n                int dotIdx = -1;\n                int lastColonIdx = -1;\n                for (int i = tIndex + 1; i < timeEndIdx; ++i) {\n                    char ch = dateStr.charAt(i);\n                    if (ch == ':') lastColonIdx = i;\n                    else if (ch == '.') dotIdx = i;\n                }\n                StringBuilder sb = null;\n\n                if (lastColonIdx != -1) { // Ok, must have hours, minutes OR hours, minutes, seconds\n                    int secondColonIdx = -1;\n                    for (int i = tIndex + 1; i < lastColonIdx; ++i) {\n                         if (dateStr.charAt(i) == ':') secondColonIdx = i;\n                    }\n\n                    if (secondColonIdx != -1) { // We have HH:mm:ss\n                        if (dotIdx < lastColonIdx) dotIdx = -1; // dot must be after seconds\n                        if (dotIdx == -1) { // No milliseconds indicated.\n                             sb = new StringBuilder(dateStr);\n                             sb.insert(timeEndIdx, \".000\");\n                             dateStr = sb.toString();\n                        } else { // Milliseconds indicated\n                            int millisDigits = timeEndIdx - (dotIdx + 1);\n                            if (millisDigits < 3) {\n                                 sb = new StringBuilder(dateStr);\n                                 for (; millisDigits < 3; ++millisDigits) {\n                                     sb.insert(timeEndIdx, '0');\n                                 }\n                                 dateStr = sb.toString();\n                            }\n                        }\n                    } else { // Assume HH:mm\n                        sb = new StringBuilder(dateStr);\n                        sb.insert(timeEndIdx, \":00.000\");\n                        dateStr = sb.toString();\n                    }\n                } else { // Assume \"THH\" / \"THH.\" / \"THH.mm\" / \"THH.mmm\" format\n                    sb = new StringBuilder(dateStr);\n                    if (dotIdx < tIndex) dotIdx = -1; // dot must be after 'T'\n                    if (dotIdx == -1) { // \"THH\" -> \"THH:00:00.000\"\n                        sb.insert(timeEndIdx, \":00:00.000\");\n                    } else { // \"THH.mmm\" -> \"THH:00:00.mmm\" (or fewer m's)\n                        sb.insert(dotIdx, \":00:00\");\n                        // Pad milliseconds if needed\n                        int currentLen = sb.length();\n                        int newTimeEndIdx = currentLen - 1;\n                        int newDotIdx = sb.lastIndexOf('.');\n                        int millisDigits = newTimeEndIdx - (newDotIdx + 1);\n                        for (; millisDigits < 3; ++millisDigits) {\n                           sb.insert(newTimeEndIdx, '0');\n                        }\n                    }\n                    dateStr = sb.toString();\n                }\n            }\n        // Date with timezone offset (+HH:MM / +HHMM / +HH)\n        } else if (hasTimeZone(dateStr)) {\n             // Need to remove colon, if present: Z supports \"+HHMM\" / \"-HHMM\"\n             int signIdx = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n             String timezonePartOrig = dateStr.substring(signIdx);\n             if (timezonePartOrig.length() == 6 && timezonePartOrig.charAt(3) == ':') { // \"+HH:MM\" -> \"+HHMM\"\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.deleteCharAt(signIdx + 3);\n                 dateStr = sb.toString();\n             } else if (timezonePartOrig.length() == 3) { // \"+HH\" -> \"+HH00\"\n                 dateStr += \"00\";\n             } else if (timezonePartOrig.length() != 5) { // \"+HHMM\" is ok\n                 // Otherwise, invalid format, let parser deal with it\n             }\n\n             // Ensure \"yyyy-MM-dd'T'HH:mm:ss.SSS\" part before timezone\n            int timeEndIdx = signIdx;\n            int tIndex = dateStr.lastIndexOf('T');\n            if (tIndex >= 0) {\n                 int dotIdx = -1;\n                 int lastColonIdx = -1;\n                 for (int i = tIndex + 1; i < timeEndIdx; ++i) {\n                     char ch = dateStr.charAt(i);\n                     if (ch == ':') lastColonIdx = i;\n                     else if (ch == '.') dotIdx = i;\n                 }\n                 StringBuilder sb = null;\n\n                 if (lastColonIdx != -1) { // Ok, must have hours, minutes OR hours, minutes, seconds\n                     int secondColonIdx = -1;\n                     for (int i = tIndex + 1; i < lastColonIdx; ++i) {\n                          if (dateStr.charAt(i) == ':') secondColonIdx = i;\n                     }\n\n                     if (secondColonIdx != -1) { // We have HH:mm:ss\n                        if (dotIdx < lastColonIdx) dotIdx = -1; // dot must be after seconds\n                         if (dotIdx == -1) { // No milliseconds indicated.\n                              sb = new StringBuilder(dateStr);\n                              sb.insert(timeEndIdx, \".000\");\n                              dateStr = sb.toString();\n                         } else { // Milliseconds indicated\n                             int millisDigits = timeEndIdx - (dotIdx + 1);\n                             if (millisDigits < 3) {\n                                  sb = new StringBuilder(dateStr);\n                                  for (; millisDigits < 3; ++millisDigits) {\n                                      sb.insert(timeEndIdx, '0');\n                                  }\n                                  dateStr = sb.toString();\n                             }\n                         }\n                     } else { // Assume HH:mm\n                         sb = new StringBuilder(dateStr);\n                         sb.insert(timeEndIdx, \":00.000\");\n                         dateStr = sb.toString();\n                     }\n                 } else { // Assume \"THH\" / \"THH.\" / \"THH.mm\" / \"THH.mmm\" format\n                     sb = new StringBuilder(dateStr);\n                     if (dotIdx < tIndex) dotIdx = -1; // dot must be after 'T'\n                     if (dotIdx == -1) { // \"THH\" -> \"THH:00:00.000\"\n                         sb.insert(timeEndIdx, \":00:00.000\");\n                     } else { // \"THH.mmm\" -> \"THH:00:00.mmm\" (or fewer m's)\n                         sb.insert(dotIdx, \":00:00\");\n                         // Pad milliseconds if needed\n                         int currentLen = sb.length();\n                         // Need to find sign index again\n                         int currentSignIdx = Math.max(sb.lastIndexOf(\"+\", currentLen - 2), sb.lastIndexOf(\"-\", currentLen - 2));\n                         int newTimeEndIdx = currentSignIdx;\n                         int newDotIdx = sb.lastIndexOf('.');\n                         int millisDigits = newTimeEndIdx - (newDotIdx + 1);\n                         for (; millisDigits < 3; ++millisDigits) {\n                            sb.insert(newTimeEndIdx, '0');\n                         }\n                     }\n                     dateStr = sb.toString();\n                 }\n            }\n             df = _formatISO8601;\n             if (_formatISO8601 == null) {\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n             }\n        // If not, plain date. Easiest to just patch 'Z' in the end?\n        } else {\n            // If not timezone indicator, and not ending in Z, let's assume\n            // that it's local time and needs 'Z' appended (as per prior behavior).\n             StringBuilder sb = new StringBuilder(dateStr);\n             int timeEndIdx = dateStr.length();\n             int tIndex = dateStr.lastIndexOf('T');\n             // If 'T' is present, parse time part, otherwise assume plain date which should have been handled already\n             if (tIndex >= 0) {\n                 int dotIdx = -1;\n                 int lastColonIdx = -1;\n                 for (int i = tIndex + 1; i < timeEndIdx; ++i) {\n                     char ch = dateStr.charAt(i);\n                     if (ch == ':') lastColonIdx = i;\n                     else if (ch == '.') dotIdx = i;\n                 }\n\n                 if (lastColonIdx != -1) { // Has time separator\n                     int secondColonIdx = -1;\n                      for (int i = tIndex + 1; i < lastColonIdx; ++i) {\n                          if (dateStr.charAt(i) == ':') secondColonIdx = i;\n                     }\n\n                     if (secondColonIdx != -1) { // We have HH:mm:ss\n                         if (dotIdx < lastColonIdx) dotIdx = -1; // dot must be after seconds\n                         if (dotIdx == -1) { // No millis\n                             sb.append(\".000\");\n                         } else { // Has millis\n                             int millisDigits = timeEndIdx - (dotIdx + 1);\n                             for (; millisDigits < 3; ++millisDigits) {\n                                 sb.append('0');\n                             }\n                         }\n                     } else { // Assume HH:mm\n                         sb.append(\":00.000\");\n                     }\n                 } else { // Assume \"THH\" / \"THH.\" / \"THH.mm\" / \"THH.mmm\" format\n                      if (dotIdx < tIndex) dotIdx = -1; // dot must be after T\n                      if (dotIdx == -1) { // \"THH\" -> \"THH:00:00.000\"\n                         sb.append(\":00:00.000\");\n                      } else { // \"THH.mmm\" -> \"THH:00:00.mmm\"\n                          // Insert :00:00 before the dot\n                           sb.insert(dotIdx, \":00:00\");\n                           // Pad millis that are already there (at the end of the string now)\n                           int currentLen = sb.length();\n                           int newDotIdx = sb.lastIndexOf('.');\n                           int millisDigits = currentLen - (newDotIdx + 1);\n                           for (int i=millisDigits; i < 3; ++i) {\n                               sb.append('0');\n                           }\n                      }\n                 }\n                 sb.append('Z');\n                 dateStr = sb.toString();\n             } else {\n                 // If no 'T', we may have plain date (pre-10 chars) or something else...\n                 // Ideally we shouldn't get here for plain dates, but what the heck:\n                 // Let's append 'Z', see what happens\n                 sb.append('Z');\n                 dateStr = sb.toString();\n             }\n\n             df = _formatISO8601_z;\n             if (df == null) {\n                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                         _timezone, _locale);\n             }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}