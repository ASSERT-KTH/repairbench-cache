{
    "generation": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n\n          // Determining the dependency scope node based on the position in the FOR loop.\n          // The init section uses the name node, condition and increment use the recordNode.\n          if (parent.getFirstChild().getNext() != n && parent.getFirstChild().getNext().getNext() != n) {\n             // If 'n' is the initializer part of the FOR loop. parent.getFirstChild() is init var node\n             // Need to check if n is the initializer. The initializer is the first child.\n             // In \"for(var i=0;...\", the VAR is the first child.\n             // In \"for(i=0;...\", the ASSIGN is the first child.\n             // Let's refine the condition. n is the init if it's the first child of parent.\n             if (parent.getFirstChild() == n) {\n               recordDepScope(nameNode, ns); // Use name node for init\n             } else {\n               // n is condition or increment part\n               recordDepScope(recordNode, ns); // Use assign node for condition/increment\n             }\n          } else {\n             // n is condition or increment part (original logic had these reversed?)\n             // Let's stick to the logic: init uses nameNode, others use recordNode.\n             // If n is NOT the first child, it must be condition or increment.\n             recordDepScope(recordNode, ns);\n          }\n          // Simplified logic based on position:\n          // Node init = parent.getFirstChild();\n          // Node cond = init.getNext();\n          // Node incr = cond.getNext();\n          // if (n == init) { recordDepScope(nameNode, ns); } else { recordDepScope(recordNode, ns); }\n\n        } else if (parent.isCall() && n == parent.getFirstChild()) {\n            // If the assignment is the expression being called,\n            // A() in B = A()\n            // (function(){})() in var x = (function(){})()\n            // x = function(){} in (x = function(){})() <-- this case\n            // The CALL node is the context, not the assignment node.\n            recordDepScope(parent, ns);\n        } else {\n          // The general case. This includes assignments in expressions like:\n          // var a = (b = 1);  // parent is ASSIGN\n          // foo(c = 2);       // parent is CALL (but n is not the first child)\n          // if (d = 3)        // parent is IF\n          // Originally used recordNode. Using parent seems more correct\n          // for relating the assignment to the context where it happens.\n          // The failing test (fun = function(){})() hits the case above now.\n          // Let's consider if using parent here is always right.\n          // In `var a = (b = 1);`, parent of `b=1` is the outer assign. OK.\n          // In `foo(c=2);`, parent of `c=2` is CALL. OK.\n          // In `if (d=3)`, parent of `d=3` is IF. OK.\n          // In `e = 5;`, parent of `e=5` is EXPR_RESULT. OK.\n          // Using parent seems generally better than using the assign node itself.\n          recordDepScope(parent, ns);\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}