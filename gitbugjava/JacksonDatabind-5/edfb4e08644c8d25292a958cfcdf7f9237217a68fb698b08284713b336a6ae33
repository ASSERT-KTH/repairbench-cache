{
    "generation": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        // Process methods declared directly in the mixin class.\n        // Hierarchy traversal is handled by the caller (_addMixIns, _addInterfaces).\n        for (Method m : mixInCls.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod am = methods.find(m);\n            /* Do we already have a method to augment (from sub-class\n             * that will mask this mixIn)? If so, add if visible\n             * without masking (no such annotation)\n             */\n            if (am != null) {\n                // Apply annotations from mixin method 'm' to the existing target method 'am'\n                _addMixUnders(m, am);\n            /* Otherwise, if no corresponding method found in the target class hierarchy yet,\n             * add this mixin method to the separate 'mixIns' map.\n             * It might be added later in _addMixIns if it's a valid property\n             * (like a getter), or if it overrides a method discovered later.\n             */\n            } else {\n                // Well, or, as per [Issue#515], multi-level merge within mixins...\n                // Add the mixin's method itself to the mixIns map for later processing.\n                mixIns.add(_constructMethod(m));\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}