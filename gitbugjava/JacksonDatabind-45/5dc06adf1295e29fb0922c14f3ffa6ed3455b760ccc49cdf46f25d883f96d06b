{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        // Use the standard method for finding format overrides, considering annotations and type defaults\n        // (This part assumes findFormatOverrides is available as in later Jackson versions,\n        // replacing the older findFormat call)\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n             return this;\n        }\n\n        JsonFormat.Shape shape = format.getShape();\n\n        // Simple case first: serialize as numeric timestamp?\n        if (shape.isNumeric()) {\n            // Ensure this is mutually exclusive with string formatting based on pattern/locale/tz\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // Check if shape implies string format.\n        // This is true if shape is explicitly STRING or SCALAR.\n        // Also, if shape is ANY, check if format settings (pattern, locale, timezone) are present,\n        // which also implies string format should be used.\n        boolean treatAsString = (shape == JsonFormat.Shape.STRING) || (shape == JsonFormat.Shape.SCALAR);\n\n        if (!treatAsString && shape == JsonFormat.Shape.ANY) {\n            // For Shape.ANY, presence of pattern, locale or timezone indicates String format.\n            if (format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {\n                treatAsString = true;\n            }\n        }\n\n        // If it needs to be treated as String based on the checks above:\n        if (treatAsString) {\n            TimeZone tz = format.getTimeZone();\n            final String pattern = format.hasPattern()\n                            ? format.getPattern()\n                            // If no pattern is specified, fall back to the default ISO-8601 format string\n                            : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            // If no locale specified, use the default locale from serializer provider\n                            : serializers.getLocale();\n\n            // Create a SimpleDateFormat instance with the determined pattern and locale.\n            // Note: For some date/time types, custom formatters might be needed,\n            // but SimpleDateFormat is the standard for java.util.Date.\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n\n            if (tz == null) {\n                // If no explicit timezone is set in the format annotation,\n                // use the default timezone from the serializer provider.\n                tz = serializers.getTimeZone();\n            }\n            // Apply the determined timezone to the date format.\n            df.setTimeZone(tz);\n\n            // Return a new serializer instance configured with Boolean.FALSE (-> not timestamp)\n            // and the configured DateFormat.\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // If the shape is not numeric, and does not imply String format\n        // (e.g., Shape.ANY without pattern/locale/timezone, or other shapes like BOOLEAN),\n        // return the default serializer instance ('this'). This instance will respect\n        // global serialization features like WRITE_DATES_AS_TIMESTAMPS.\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}