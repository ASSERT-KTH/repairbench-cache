{
    "generation": "@Override\nprotected Object decode(\n        Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n    ByteBuf buf = (ByteBuf) msg;\n\n    // Minimal check for header size\n    if (buf.readableBytes() < 8) {\n        return null;\n    }\n\n    buf.readUnsignedByte(); // header\n    int flags = buf.readUnsignedByte();\n    buf.readUnsignedShortLE(); // length\n    buf.readUnsignedShortLE(); // checksum\n    int index = buf.readUnsignedShortLE();\n    int type = buf.readUnsignedByte();\n\n    if (BitUtil.check(flags, 4)) {\n        sendResponse(channel, remoteAddress, index, type, buf);\n    }\n\n    // FIX: Process both type 1 and type MSG_DATA messages as they seem to use the same payload structure.\n    // Assuming MSG_DATA is defined elsewhere in the class (likely as 3).\n    if (type == MSG_DATA || type == 0x01) {\n\n        List<Position> positions = new LinkedList<>();\n        Set<Integer> keys = new HashSet<>();\n        boolean hasLocation = false;\n        Position position = new Position(getProtocolName());\n\n        DeviceSession deviceSession = null;\n\n        // Loop through key-value blocks in the payload\n        while (buf.readableBytes() > 1) { // Need at least length and key bytes\n            int blockLength = buf.readUnsignedByte();\n            // Check if buffer has enough bytes for the declared block length (which includes the key byte)\n            if (blockLength == 0 || buf.readableBytes() < blockLength) {\n                 break; // Invalid block or not enough data\n            }\n            // Calculate the end index for this block *before* reading the key\n            int endIndex = buf.readerIndex() + blockLength;\n            int key = buf.readUnsignedByte(); // Read the data key\n\n            // If a key repeats, it indicates the start of a new position record within the same message\n            if (keys.contains(key)) {\n                if (!hasLocation) {\n                    // Try to set location from last known if current record lacks it\n                    getLastLocation(position, position.getDeviceTime()); // Pass time if available\n                }\n                positions.add(position); // Add the completed position\n                keys.clear(); // Reset for the new position\n                hasLocation = false;\n                position = new Position(getProtocolName()); // Create a new position object\n                // If device session is already known, set ID on new position object immediately\n                if (deviceSession != null) {\n                    position.setDeviceId(deviceSession.getDeviceId());\n                }\n            }\n            keys.add(key);\n\n            // Process data based on key, using original logic structure\n            // Added checks for readable bytes before reading data for robustness\n            switch (key) {\n                case 0x01: // Device Identifier\n                    // blockLength includes key(1), so need blockLength>=16 for 15 bytes ID\n                    if (blockLength >= 16 && buf.readableBytes() >= 15) {\n                        String uniqueId = buf.readCharSequence(15, StandardCharsets.US_ASCII).toString();\n                        // Retrieve session only once per message if not already known\n                        if (deviceSession == null) {\n                            deviceSession = getDeviceSession(channel, remoteAddress, uniqueId);\n                        }\n                        // If session successfully retrieved/created, set device ID\n                        if (deviceSession != null) {\n                            position.setDeviceId(deviceSession.getDeviceId());\n                        }\n                    }\n                    break;\n                case 0x02: // Alarm\n                    // blockLength includes key(1), need blockLength>=5 for 4 bytes alarm\n                    if (blockLength >= 5 && buf.readableBytes() >= 4) {\n                        long alarm = buf.readUnsignedIntLE();\n                        position.set(Position.KEY_ALARM, decodeAlarm(alarm));\n                        if (BitUtil.check(alarm, 31)) {\n                            position.set(\"bark\", true);\n                        }\n                    }\n                    break;\n                case 0x14: // Battery\n                    // blockLength includes key(1), need blockLength>=4 for level(1)+voltage(2)\n                    if (blockLength >= 4 && buf.readableBytes() >= 3) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShortLE() * 0.001);\n                    }\n                    break;\n                case 0x20: // GPS Location\n                    // key(1) + 4(lat)+4(lon)+2(spd)+2(crs)+2(alt)+2(hdop)+4(odom)+1(sat) = 22 bytes total block\n                    if (blockLength >= 22 && buf.readableBytes() >= 21) {\n                        hasLocation = true;\n                        position.setLatitude(buf.readIntLE() * 0.0000001);\n                        position.setLongitude(buf.readIntLE() * 0.0000001);\n                        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShortLE()));\n                        position.setCourse(buf.readUnsignedShortLE());\n                        position.setAltitude(buf.readShortLE());\n                        int hdop = buf.readUnsignedShortLE();\n                        position.setValid(hdop > 0); // Original validity check based on HDOP\n                        position.set(Position.KEY_HDOP, hdop * 0.1);\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedIntLE());\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0x21: // Cell Tower (variable length)\n                    if (buf.readableBytes() >= 3) { // Need at least MCC(2) + MNC(1)\n                        int mcc = buf.readUnsignedShortLE();\n                        int mnc = buf.readUnsignedByte();\n                        if (position.getNetwork() == null) {\n                            position.setNetwork(new Network());\n                        }\n                        // Read cell tower entries until the end of the block\n                        while (buf.readerIndex() < endIndex && buf.readableBytes() >= 5) { // Need rssi(1)+lac(2)+cid(2)\n                            int rssi = buf.readByte();\n                            position.getNetwork().addCellTower(CellTower.from(\n                                    mcc, mnc, buf.readUnsignedShortLE(), buf.readUnsignedShortLE(), rssi));\n                        }\n                    }\n                    break;\n                case 0x22: // WiFi AP (variable length)\n                    if (position.getNetwork() == null) {\n                        position.setNetwork(new Network());\n                    }\n                    // Read WiFi AP entries until the end of the block\n                    while (buf.readerIndex() < endIndex && buf.readableBytes() >= 7) { // Need rssi(1)+mac(6)\n                        int rssi = buf.readByte();\n                        String mac = ByteBufUtil.hexDump(buf.readSlice(6)).replaceAll(\"(..)\", \"$1:\");\n                        position.getNetwork().addWifiAccessPoint(WifiAccessPoint.from(\n                                mac.substring(0, mac.length() - 1), rssi)); // Remove trailing ':'\n                    }\n                    break;\n                case 0x23: // Tag Location\n                    int tagIdLength = 6; // Assuming readTagId reads 6 bytes (e.g., BLE MAC)\n                    // key(1)+tagId(6)+lat(4)+lon(4) = 15 bytes total block\n                    if (blockLength >= 15 && buf.readableBytes() >= tagIdLength + 8) {\n                        position.set(\"tagId\", readTagId(buf)); // Consumes tagIdLength bytes\n                        position.setLatitude(buf.readIntLE() * 0.0000001);\n                        position.setLongitude(buf.readIntLE() * 0.0000001);\n                        position.setValid(true);\n                        hasLocation = true;\n                    }\n                    break;\n                case 0x24: // Time and Status\n                    // key(1)+time(4)+status(4) = 9 bytes total block\n                    if (blockLength >= 9 && buf.readableBytes() >= 8) {\n                        position.setTime(new Date(buf.readUnsignedIntLE() * 1000));\n                        long status = buf.readUnsignedIntLE();\n                        position.setValid(true); // Time makes the record generally valid\n                        if (BitUtil.check(status, 4)) position.set(Position.KEY_CHARGE, true);\n                        if (BitUtil.check(status, 7)) position.set(Position.KEY_ARCHIVE, true);\n                        position.set(Position.KEY_MOTION, BitUtil.check(status, 9));\n                        position.set(Position.KEY_RSSI, BitUtil.between(status, 19, 24));\n                        position.set(Position.KEY_BATTERY_LEVEL, BitUtil.from(status, 24));\n                        position.set(Position.KEY_STATUS, status);\n                    }\n                    break;\n                case 0x28: // Beacon Info\n                    tagIdLength = 6; // Assuming readTagId reads 6 bytes\n                    // key(1)+flags(1)+tagId(6)+rssi(1)+rssi1m(1) = 10 bytes minimum\n                    if (blockLength >= 10 && buf.readableBytes() >= 1 + tagIdLength + 1 + 1) {\n                        int beaconFlags = buf.readUnsignedByte();\n                        position.set(\"tagId\", readTagId(buf)); // Consumes tagIdLength\n                        position.set(\"tagRssi\", (int) buf.readByte());\n                        position.set(\"tag1mRssi\", (int) buf.readByte());\n                        // Check if location data is present (flag) and there are enough bytes remaining\n                        if (BitUtil.check(beaconFlags, 7) && buf.readerIndex() <= endIndex - 8 && buf.readableBytes() >= 8) {\n                            position.setLatitude(buf.readIntLE() * 0.0000001);\n                            position.setLongitude(buf.readIntLE() * 0.0000001);\n                            position.setValid(true);\n                            hasLocation = true;\n                        }\n                        // Check if description is present (flag) and there are bytes remaining\n                        if (BitUtil.check(beaconFlags, 6) && buf.readerIndex() < endIndex) {\n                            int descriptionLength = endIndex - buf.readerIndex();\n                            if (buf.readableBytes() >= descriptionLength) { // Ensure enough bytes for description\n                                position.set(\"description\", buf.readCharSequence(\n                                        descriptionLength, StandardCharsets.US_ASCII).toString());\n                            }\n                        }\n                    }\n                    break;\n                case 0x2A: // WiFi Location\n                    // key(1)+flags(1)+mac(6)+rssi(1)+lat(4)+lon(4) = 17 bytes total block\n                    if (blockLength >= 17 && buf.readableBytes() >= 16) {\n                        buf.readUnsignedByte(); // flags\n                        buf.skipBytes(6); // mac\n                        buf.readUnsignedByte(); // rssi\n                        position.setLatitude(buf.readIntLE() * 0.0000001);\n                        position.setLongitude(buf.readIntLE() * 0.0000001);\n                        position.setValid(true);\n                        hasLocation = true;\n                    }\n                    break;\n                case 0x30: // Steps\n                    // key(1)+timestamp(4)+steps(4) = 9 bytes total block\n                    if (blockLength >= 9 && buf.readableBytes() >= 8) {\n                        buf.readUnsignedIntLE(); // timestamp (ignore, use time from 0x24 if available)\n                        position.set(Position.KEY_STEPS, buf.readUnsignedIntLE());\n                    }\n                    break;\n                case 0x31: // Activity (variable length)\n                    int i = 1;\n                    // Read pairs of timestamp(4)+activity(4) until end of block\n                    while (buf.readerIndex() <= endIndex - 8 && buf.readableBytes() >= 8) {\n                        position.set(\"activity\" + i + \"Time\", buf.readUnsignedIntLE());\n                        position.set(\"activity\" + i, buf.readUnsignedIntLE());\n                        i += 1;\n                    }\n                    break;\n                case 0x37: // Barking\n                    // key(1)+timestamp(4)+barking(4) = 9 bytes total block\n                    if (blockLength >= 9 && buf.readableBytes() >= 8) {\n                        buf.readUnsignedIntLE(); // timestamp (ignore)\n                        long barking = buf.readUnsignedIntLE();\n                        if (BitUtil.check(barking, 31)) {\n                            position.set(\"barkStop\", true);\n                        }\n                        position.set(\"barkCount\", BitUtil.to(barking, 31));\n                    }\n                    break;\n                case 0x40: // Heart Rate\n                    // key(1)+timestamp(4)+hr(1) = 6 bytes total block\n                    if (blockLength >= 6 && buf.readableBytes() >= 5) {\n                        buf.readUnsignedIntLE(); // timestamp (ignore)\n                        int heartRate = buf.readUnsignedByte();\n                        if (heartRate > 1) { // Basic validity check\n                            position.set(Position.KEY_HEART_RATE, heartRate);\n                        }\n                    }\n                    break;\n                default:\n                    // Unknown key: data will be skipped by readerIndex update below\n                    break;\n            }\n            // Ensure reader index is at the end of the block, skipping any unread/unknown data within it.\n            // Check bounds to prevent errors if endIndex calculation was somehow wrong.\n            if (endIndex > buf.writerIndex()) {\n                endIndex = buf.writerIndex();\n            }\n            if (buf.readerIndex() < endIndex) {\n                 buf.readerIndex(endIndex);\n            } else if (buf.readerIndex() > endIndex) {\n                 // This indicates a bug in parsing logic above, stop processing message.\n                 break;\n            }\n        } // End while loop\n\n        // Add the last position object being built, if it contains any data\n        if (!keys.isEmpty()) {\n            if (!hasLocation) {\n                getLastLocation(position, position.getDeviceTime());\n            }\n            positions.add(position);\n        }\n\n        // We must have identified the device to return data\n        if (deviceSession != null) {\n            if (positions.isEmpty()) {\n                // No complete positions were decoded, possibly due to empty/malformed payload\n                return null;\n            }\n            // Ensure all decoded positions have the device ID set\n            for (Position p : positions) {\n                p.setDeviceId(deviceSession.getDeviceId());\n            }\n            return positions;\n        } else {\n            // No device identified (e.g., key 0x01 was missing or device unknown)\n            return null;\n        }\n\n    } // End if (type == MSG_DATA || type == 0x01)\n\n    // Message type was not handled by the above logic\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}