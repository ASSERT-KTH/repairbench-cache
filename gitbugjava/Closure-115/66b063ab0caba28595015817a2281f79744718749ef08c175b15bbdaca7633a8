{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   * 2) If a call's arguments may be mutated and the corresponding function\n   * parameter is referenced more than once.\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(obj); // obj may be mutated by code executed between the two references to 'a'\n   * </pre>\n   * 3) If a call has arguments that are not represented by named parameters\n   * (e.g. var_args or arguments passed to a function declared with fewer parameters),\n   * those arguments must not have side effects.\n   * <pre>\n   *     function foo(a) { return a; }\n   *     x = foo(1, i++); // i++ is not represented by a named parameter.\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild(); // The function body block\n\n    // Check arguments vs parameters\n    Node fnParamsNode = NodeUtil.getFunctionParameters(fnNode);\n    Node cArg = callNode.getFirstChild().getNext(); // First actual argument\n\n    // Adjust for '.call' where 'this' is the first argument passed at the call site.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // Require the first argument ('this') to be the keyword 'this'.\n        // TODO(johnlenz): Support replacing 'this' with other values.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext(); // Skip 'this' argument for parameter matching below.\n      } else {\n        // '.apply' is not inlined directly and should be filtered before reaching here.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    int argIndex = 0;\n    while (cArg != null) {\n      Node fnParam = fnParamsNode.getChildAtIndex(argIndex); // Get the corresponding parameter NAME node\n\n      if (fnParam != null) {\n        // Argument corresponds to a named parameter.\n        String paramName = fnParam.getString();\n        // Note: Getting the reference count requires traversing the function body,\n        // potentially multiple times (if we check different params). This could be\n        // optimized if necessary by doing a single traversal.\n        int refCount = NodeUtil.getNameReferenceCount(block, paramName);\n\n        // Check #1: Argument has side effects AND parameter is used > 1 time. (Rule 1)\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler) && refCount > 1) {\n          return CanInlineResult.NO;\n        }\n        // Check #2: Argument is potentially mutable AND parameter is used > 1 time. (Rule 2)\n        // Guards against cases where the argument's state might change between references.\n        if (NodeUtil.mayEffectMutableState(cArg, compiler) && refCount > 1) {\n          return CanInlineResult.NO;\n        }\n        // NOTE: Side effects in arguments for parameters used 0 or 1 times are considered safe\n        // for this direct replacement, as the effect happens before the body substitution.\n      } else {\n        // Argument does not correspond to a named parameter (e.g., var_args).\n        // Check #3: Extra arguments must not have side-effects. (Rule 3)\n        // If an extra argument has side-effects, direct call node replacement is unsafe\n        // because the side-effect would be lost (as only the return value is substituted).\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      // Move to the next argument.\n      cArg = cArg.getNext();\n      argIndex++;\n    }\n\n    // If all argument checks pass for all arguments, inlining is considered safe.\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}