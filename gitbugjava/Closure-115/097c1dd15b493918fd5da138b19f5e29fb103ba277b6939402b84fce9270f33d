{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // Determine if the function body has side-effects.\n    // For direct replacement, we only consider the side effects of the\n    // expression in the return statement.\n    boolean hasFunctionBodySideEffects = false;\n    if (block.hasChildren()) {\n      // isDirectCallNodeReplacementPossible ensures the block is valid\n      Preconditions.checkState(block.hasOneChild(), \"Function body expected to have only one child.\");\n      Node stmt = block.getFirstChild();\n      // isDirectCallNodeReplacementPossible should ensure this is a return\n      Preconditions.checkState(stmt.isReturn(), \"Function body expected to be a return statement.\");\n      Node returnValue = stmt.getFirstChild();\n      if (returnValue != null) {\n         // Check the expression returned for side effects.\n         hasFunctionBodySideEffects = NodeUtil.mayHaveSideEffects(returnValue, compiler);\n      }\n    } // An empty function body has no side effects.\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check analysis.\n      if (fnParam != null) {\n        if (cArg != null) {\n          // Check #1: If argument may affect state, parameter must be used <= 1 time.\n          // This prevents duplicating side effects or state-affecting operations.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n\n          // Check #2: Interaction between function body side effects and argument side effects.\n          // If the function body has side effects (e.g., in the return expression like `global++`)\n          // and the argument *also* may affect mutable state (e.g., `foo(bar())`),\n          // inlining might change execution order or evaluation counts in problematic ways.\n          // Avoid inlining in this specific scenario.\n          if (hasFunctionBodySideEffects\n              && NodeUtil.mayEffectMutableState(cArg, compiler)) {\n            // Example: f(a) { global++; return a; }, called as f(bar()). Disallowed.\n            // Example: f(a) { a.x = 1; return a; }, called as f(bar()). Disallowed.\n            // Example: f(a) { a.x = 1; return a; }, called as f(obj). Allowed by this check (obj doesn't effect state).\n            return CanInlineResult.NO;\n          }\n\n           // Removed the overly strict checks from the original code:\n           // 1. if (hasSideEffects && NodeUtil.canBeSideEffected(cArg))\n           //    This incorrectly disallowed f(o) for f(a){a.x=1;return a;}\n           // 2. The check for NodeUtil.mayHaveSideEffects(cArg) for every argument.\n           //    This incorrectly disallowed f(g()) for f(a){return h(a);} when param 'a' is used once.\n        } else {\n           // Argument is missing (value is undefined). Check if the parameter\n           // is used multiple times, as 'undefined' might be substituted.\n           // Handled by the ref count check.\n        }\n        // Move to the next parameter.\n        fnParam = fnParam.getNext();\n      } else {\n          // No more parameters exist, processing extra arguments (var_args).\n          Preconditions.checkState(cArg != null); // Loop condition ensures cArg is non-null if fnParam is null\n          // Side effects of unused arguments are generally preserved by evaluating them before the call.\n          // Direct replacement drops them if 'arguments' isn't used. This behavior\n          // is generally accepted or handled by other passes (e.g. pure function marking).\n          // No specific check needed here for direct inlining safety related to argument/body interactions.\n      }\n\n      // Move to the next argument.\n      if (cArg != null) {\n        cArg = cArg.getNext();\n      }\n    }\n\n    // Final checks for constructs incompatible with direct replacement.\n    if (NodeUtil.referencesThis(block)) {\n      // Accessing 'this' requires context preservation not done here.\n      return CanInlineResult.NO;\n    }\n    if (NodeUtil.referencesArguments(block)) {\n      // Accessing 'arguments' requires the arguments object, not simple substitution.\n      return CanInlineResult.NO;\n    }\n\n    // If all checks pass, inlining is possible.\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}