{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once\n   * in the returned expression.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   * 2) If the function's return expression has side effects, none of the call's\n   * arguments may have side effects.\n   * 3) A parameter that has no corresponding argument must not be referenced\n   * in the function body.\n   * 4) An argument that has no corresponding parameter must not have side\n   * effects (as they would be lost).\n   * 5) The function must not use {@code this} if it is called via {@code .call}\n   * or as a method call on an object (unless the function doesn't use this).\n   * 6) Calls using {@code .apply} are never directly inlined.\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n    Node returnExpr = null;\n    boolean functionBodyHasSideEffects = false;\n\n    // Function body is known to be empty or 'return expr;'\n    if (block.hasChildren()) { // Can only be 'return expr;'\n      Node ret = block.getFirstChild();\n      Preconditions.checkState(ret.isReturn());\n      if (ret.hasChildren()) {\n        returnExpr = ret.getFirstChild();\n        functionBodyHasSideEffects = NodeUtil.mayHaveSideEffects(returnExpr, compiler);\n      }\n    }\n\n    // Arguments start after the call target.\n    Node cArg = callNode.getFirstChild().getNext();\n    Node callTarget = callNode.getFirstChild();\n\n    // Rule 5 & 6: Check 'this' usage and call type.\n    if (!callTarget.isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // fn.call(thisVal, args...)\n        Node thisNode = cArg;\n        if (NodeUtil.referencesThis(block)) {\n          // Function uses 'this', direct substitution isn't possible.\n          return CanInlineResult.NO; // Rule 5 violation\n        }\n        // Function doesn't use 'this'. Check if thisVal has side effects.\n        if (thisNode != null && NodeUtil.mayHaveSideEffects(thisNode, compiler)) {\n          // Evaluating 'this' argument has side-effects.\n          return CanInlineResult.NO;\n        }\n        // Skip the thisVal node to align with actual parameters.\n        if (thisNode != null) {\n          cArg = thisNode.getNext();\n        }\n      } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n         // Rule 6: apply() is not inlinable this way.\n         // Preconditions.checkState should ensure this isn't reached, but double-check.\n         return CanInlineResult.NO;\n      } else {\n        // It's a method call, e.g., obj.method() or (function(){}).call() etc.\n        if (NodeUtil.referencesThis(block)) {\n           // Rule 5: Function uses 'this', direct substitution isn't possible for method calls.\n          return CanInlineResult.NO;\n        }\n        // Function does not use 'this'. Proceed normally.\n        // cArg already points to the first argument.\n      }\n    }\n\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n    // 1. Process arguments and parameters that pair up.\n    while (cArg != null && fnParam != null) {\n      boolean argMayHaveSideEffects = NodeUtil.mayHaveSideEffects(cArg, compiler);\n      if (argMayHaveSideEffects) {\n        // Calculate use count within the return expression only.\n        int paramUseCount = (returnExpr == null) ? 0 : NodeUtil.getNameReferenceCount(returnExpr, fnParam.getString());\n        // Rule 1: Side-effecting arg used > 1 time in return expression?\n        if (paramUseCount > 1) {\n          return CanInlineResult.NO;\n        }\n        // Rule 2: Side-effecting arg and side-effecting body?\n        if (functionBodyHasSideEffects) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      cArg = cArg.getNext();\n      fnParam = fnParam.getNext();\n    }\n\n    // 2. Check remaining parameters (arguments exhausted).\n    while (fnParam != null) {\n      // Rule 3: Parameter without argument must not be used in return expression.\n      int paramUseCount = (returnExpr == null) ? 0 : NodeUtil.getNameReferenceCount(returnExpr, fnParam.getString());\n      if (paramUseCount > 0) {\n        return CanInlineResult.NO;\n      }\n      fnParam = fnParam.getNext();\n    }\n\n    // 3. Check remaining arguments (parameters exhausted).\n    while (cArg != null) {\n      // Rule 4: Extra arguments must not have side-effects (would be lost).\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n\n    // All checks passed.\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}