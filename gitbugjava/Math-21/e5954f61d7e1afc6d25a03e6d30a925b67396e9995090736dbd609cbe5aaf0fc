{
    "generation": "import org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.util.FastMath;\n\n// Assume class RectangularCholeskyDecomposition exists with fields:\n// private RealMatrix root;\n// private int rank;\n\n    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which columns are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     * @exception DimensionMismatchException if the matrix is not square.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException, DimensionMismatchException {\n\n        final int order = matrix.getRowDimension();\n        if (matrix.getColumnDimension() != order) {\n             // Add dimension check for robustness.\n             throw new DimensionMismatchException(matrix.getColumnDimension(), order);\n        }\n        // Work on a copy of the matrix data to avoid modifying the input matrix\n        final double[][] c = matrix.copy().getData();\n        final double[][] b = new double[order][order]; // Stores intermediate L factors\n\n        int[] swap  = new int[order]; // Stores index i (r..order-1) of pivot chosen at step r\n        int[] index = new int[order]; // index[k] stores the original index of the row/column currently at position k\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0; // Number of successful steps / rank\n        for (boolean loop = true; loop;) {\n\n            // Find maximal diagonal element in the remaining submatrix c(r..order-1, r..order-1)\n            int maxDiagCurrentIndex = r; // Index in r..order-1 range corresponding to max diagonal element\n            // Use index[r] to get the original index for comparison start\n            double maxDiag = c[index[r]][index[r]];\n\n            for (int i = r + 1; i < order; ++i) {\n                int ii = index[i]; // Original index of the element at position i\n                if (c[ii][ii] > maxDiag) {\n                    maxDiag = c[ii][ii];\n                    maxDiagCurrentIndex = i; // Update the index (in r..order-1 range) pointing to the max element\n                }\n            }\n            // swap[r] = maxDiagCurrentIndex; // Storing this is not essential\n\n            // Swap elements in index array if max isn't already at r\n            if (maxDiagCurrentIndex != r) {\n                int tmp = index[r];\n                index[r] = index[maxDiagCurrentIndex];\n                index[maxDiagCurrentIndex] = tmp;\n            }\n\n            // Get the original index of the pivot row/column (now at position r)\n            int ir = index[r];\n            double pivot = c[ir][ir];\n\n            // Check the pivot diagonal element\n            if (pivot < small) {\n                // Pivot is too small (close to zero or negative).\n\n                // Check all remaining diagonal elements (including the pivot) for significant negativity.\n                // A PSD matrix cannot have negative diagonal elements.\n                for (int i = r; i < order; ++i) {\n                    int originalIndex = index[i];\n                    if (c[originalIndex][originalIndex] < -small) {\n                        // Found a significantly negative diagonal element, matrix not PSD.\n                        throw new NonPositiveDefiniteMatrixException(c[originalIndex][originalIndex], originalIndex, small);\n                    }\n                }\n\n                // If no significantly negative elements found, assume rank deficiency.\n                // The pivot is non-negative (>= -small) but smaller than 'small'.\n                // The rank is the number of steps completed successfully, which is 'r'.\n                loop = false; // Exit loop\n                // No ++r here, rank is determined after the loop by the value of r.\n\n            } else {\n                // Pivot is large enough (>= small) and non-negative, perform Cholesky step\n\n                // Compute the r-th column of L (corresponding to the permuted matrix)\n                final double sqrt = FastMath.sqrt(pivot);\n                b[r][r] = sqrt; // L_rr\n                final double inverse = 1.0 / sqrt;\n\n                // Compute elements L_ir for i > r\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original index for row i\n                    // c[ii][ir] is the element A'_{ii, ir} where A' is permuted and partially updated A\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e; // Store L_ir (in the permuted sense)\n                }\n\n                // Update the trailing submatrix (Schur complement) c = c - L_(:,r) * L_(:,r)^T\n                // This must be done AFTER computing all elements of column r of L (b[i][r])\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original index for row i\n                    final double e = b[i][r]; // L_ir\n                    // Update diagonal element: c_ii = c_ii - L_ir^2\n                    c[ii][ii] -= e * e;\n                    // Update off-diagonal elements: c_ij = c_ij - L_ir * L_jr\n                    for (int j = r + 1; j < i; ++j) { // Lower triangle (j < i)\n                        final int ij = index[j]; // Original index for row j\n                        final double f = c[ii][ij] - e * b[j][r]; // b[j][r] is L_jr\n                        c[ii][ij] = f;\n                        c[ij][ii] = f; // Maintain symmetry\n                    }\n                }\n\n                // Prepare for the next iteration\n                // Increment r only if the step was successful\n                loop = ++r < order;\n            }\n        } // End of main loop\n\n        // Build the root matrix R = P^T L\n        this.rank = r; // Rank is the final value of r\n        this.root = MatrixUtils.createRealMatrix(order, this.rank);\n        // Fill the root matrix based on the computed L factors (stored in b) and the permutation P (represented by index)\n        // Root_{k,j} = L_{p_k, j} where index[p_k] = k.\n        // The assignment root.setEntry(index[i], j, b[i][j]) achieves this.\n        for (int i = 0; i < order; ++i) { // Loop through rows 0..order-1 (indices used in b)\n            for (int j = 0; j < this.rank; ++j) { // Loop through columns 0..rank-1\n                this.root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}