{
    "generation": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        // Use copy() to prevent modifying the input matrix data if getData() returns a reference\n        final double[][] c = matrix.copy().getData();\n        final double[][] b = new double[order][order];\n\n        int[] swap  = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0;\n        for (boolean loop = true; loop;) {\n\n            // find maximal diagonal element\n            swap[r] = r; // Assume current pivot is maximal\n            for (int i = r + 1; i < order; ++i) {\n                int ii  = index[i]; // Original index of row/col i in current permutation\n                int isi = index[swap[r]]; // Original index of current max row/col candidate\n                if (c[ii][ii] > c[isi][isi]) {\n                    swap[r] = i; // Update the index (in the r..order-1 range) of the max diagonal element\n                }\n            }\n\n\n            // swap elements: bring the maximal diagonal element row/col to position r\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            // check diagonal element\n            int ir = index[r]; // Original index of the pivot element now at position r\n            if (c[ir][ir] < small) {\n                // The maximal diagonal element is too small\n\n                if (r == 0) {\n                    // The rank is 0, and the largest diagonal element is smaller than threshold.\n                    // The matrix might be negative definite or semi-definite with small diagonal elements.\n                    // Check for negative elements first. Find the most negative diagonal element.\n                    double maxValue = -Double.MAX_VALUE;\n                    int maxIndex = -1;\n                    for (int i = 0; i < order; ++i) {\n                         // Check original diagonal elements stored in c initially, but c is modified.\n                         // It's better to check the current diagonal elements c[index[i]][index[i]]\n                         final double d = c[index[i]][index[i]];\n                         if (d < -small) { // Check if significantly negative\n                             if (d < maxValue) {\n                                 maxValue = d;\n                                 maxIndex = index[i]; // Store original index\n                             }\n                         }\n                    }\n                    if (maxIndex != -1) {\n                         // Found a significantly negative diagonal element\n                         throw new NonPositiveDefiniteMatrixException(maxValue, maxIndex, small);\n                    } else {\n                         // No element is significantly negative, but the pivot is too small.\n                         // Report the pivot element that's below threshold.\n                         throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                    }\n                }\n\n                // If r > 0, we've already processed r pivots.\n                // Check remaining diagonal elements for negative values.\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        // there is at least one sufficiently negative diagonal element,\n                        // the symmetric positive semidefinite matrix is wrong\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], index[i], small); // Report original index index[i]\n                    }\n                }\n\n                // all remaining diagonal elements are non-negative or slightly negative but close to zero (>= -small),\n                // and the largest one (the pivot c[ir][ir]) is smaller than 'small'.\n                // We consider we have found the rank of the symmetric positive semidefinite matrix.\n                // The rank is r, stop the decomposition.\n                loop = false; // FIX: Removed ++r;\n\n            } else {\n                // The pivot element is large enough, process it.\n\n                // transform the matrix\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt; // Store diagonal element L(r,r)\n                final double inverse  = 1 / sqrt;\n\n                // Compute column r of L and update the trailing submatrix C\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original index for row i (in pivoted order)\n                    // Calculate L(i, r) = C(i, r) / L(r, r) using C(ii, ir)\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e; // Store L(i, r) in row i (pivoted), column r\n                    // Update diagonal C(i, i) = C(i, i) - L(i, r)^2\n                    c[ii][ii] -= e * e;\n                    // Update off-diagonal C(i, j) = C(i, j) - L(i, r) * L(j, r) for j from r+1 to i-1\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j]; // Original index for row j (in pivoted order)\n                        // b[j][r] holds L(j, r) computed in previous iterations of the outer loop (or this one if j < i)\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f; // Maintain symmetry of C\n                    }\n                }\n\n                // prepare next iteration\n                loop = ++r < order; // Increment rank and check if done\n            }\n        }\n\n        // build the root matrix B such that B*B^T = A\n        // The decomposition computed L such that P*A*P^T = L*L^T\n        // We need B = P^T*L\n        rank = r; // The final rank\n        root = MatrixUtils.createRealMatrix(order, r);\n        // L is stored in the first r columns of b (in pivoted row order)\n        // B(orig_row, j) = (P^T*L)(orig_row, j) = L(pivoted_row, j) where orig_row = index[pivoted_row]\n        // So, B(index[i], j) = L(i, j) = b[i][j]\n        for (int i = 0; i < order; ++i) { // i iterates through rows of L (pivoted order)\n            for (int j = 0; j < r; ++j) { // j iterates through columns of L (rank)\n                root.setEntry(index[i], j, b[i][j]); // Set root[original_row, j] = L[pivoted_row, j]\n            }\n        }\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}