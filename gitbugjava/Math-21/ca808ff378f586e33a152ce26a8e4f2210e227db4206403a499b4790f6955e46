{
    "generation": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        // The algorithm modifies the input matrix data in place via c.\n        // If the original matrix should be preserved, a copy must be made beforehand.\n        final double[][] c = matrix.getData();\n        // b stores the factor L' of the permuted matrix P^T*matrix*P = L'*L'^T\n        final double[][] b = new double[order][order];\n\n        // index[] tracks the permutation P: index[k] = original index of row/column k\n        // swap[] is auxiliary for pivoting: swap[r] stores the index i >= r of the max diagonal element found at step r\n        int[] swap  = new int[order];\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0; // Current rank / column index being processed\n        for (boolean loop = true; loop;) {\n\n            // Find the index 'i' (in the range [r, order-1]) which corresponds to the\n            // maximal diagonal element c[index[i]][index[i]] among the remaining rows/columns.\n            // Store this index 'i' in swap[r].\n            swap[r] = r; // Assume max is at current position r initially\n            for (int i = r + 1; i < order; ++i) {\n                int ii = index[i]; // Original index corresponding to row/col i (in the current permuted view)\n                int maxIndexCurrent = index[swap[r]]; // Original index corresponding to the current max pivot candidate found so far\n                // Compare diagonal elements using their original indices\n                if (c[ii][ii] > c[maxIndexCurrent][maxIndexCurrent]) {\n                    swap[r] = i; // Update the position index 'i' that holds the new maximum diagonal value\n                }\n            }\n\n\n            // Swap elements in the index array if the maximal element was not already at position r.\n            // This brings the row/column with the maximal diagonal element to position r.\n            if (swap[r] != r) {\n                final int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            // Check the diagonal element (pivot) at the current position r.\n            int ir = index[r]; // The original index of the row/column now at position r after pivoting.\n            if (c[ir][ir] < small) {\n                // Pivot element c[ir][ir] (which is the largest among remaining diagonals) is too small.\n                // This indicates rank deficiency or potential non-positive semidefiniteness.\n\n                // Before concluding rank=r, check remaining diagonal elements c[index[i]][index[i]] for i >= r\n                // for significantly negative values, which would mean the matrix is not PSD.\n                for (int i = r; i < order; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        // Found a significantly negative diagonal element -> Matrix is not positive semidefinite.\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], index[i], small);\n                    }\n                }\n\n                // If no significantly negative diagonal elements were found, but the current pivot c[ir][ir]\n                // (the largest remaining diagonal) is smaller than 'small', we conclude that the\n                // matrix rank is r. All remaining columns are considered dependent.\n\n                // If r is 0 and the first pivot is already < small, the original code threw an exception.\n                // Keep this behavior, assuming 'small' is chosen such that this indicates an issue\n                // (e.g., matrix is not PSD or rank is definitively 0 in a way that requires an exception).\n                if (r == 0 && c[ir][ir] < small) {\n                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n\n                // All remaining diagonal elements are non-negative but close to zero (<= small).\n                // The rank is determined to be r. Stop the decomposition process.\n                loop = false; // Terminate the main loop\n\n            } else {\n                // Pivot c[ir][ir] is positive and sufficiently large. Proceed with the Cholesky update step.\n\n                // Calculate the diagonal element L'_{r,r} and its inverse for column calculation.\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt; // Store L'_{r,r}\n                final double inverse = 1.0 / sqrt;\n\n                // Compute the r-th column of L' (elements below the diagonal L'_{i,r} for i > r).\n                // Simultaneously update the trailing submatrix c = c - l_r * l_r^T, where l_r is the r-th column of L'.\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original index for row i (in the current permuted order)\n                    // Calculate L'_{i,r} = c'_{i,r} / L'_{r,r} = c_{p(i),p(r)} / sqrt(c_{p(r),p(r)})\n                    // Note: c[ii][ir] refers to element (p(i), p(r)) of the original matrix C,\n                    // which is element (i, r) of the permuted matrix C' = P^T C P being decomposed.\n                    final double e = inverse * c[ii][ir];\n                    b[i][r] = e; // Store L'_{i,r} in matrix b using loop indices (i, r)\n\n                    // Update the trailing submatrix elements C'_{k,l} for k, l > r.\n                    // C' = C' - l_r * l_r^T\n                    c[ii][ii] -= e * e; // Update diagonal element C'_{i,i} = c_{p(i),p(i)}\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j]; // Original index for column j (in the current permuted order)\n                        // Update off-diagonal element C'_{i,j} = C'_{i,j} - L'_{i,r} * L'_{j,r}\n                        // L'_{j,r} was computed and stored in b[j][r] earlier in this outer loop iteration 'r'.\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f; // Maintain symmetry of the submatrix c being updated\n                    }\n                }\n\n                // Prepare for the next iteration: increment rank and check if we have processed all columns.\n                loop = ++r < order;\n            }\n        }\n\n        // Decomposition finished. Build the final root matrix R such that matrix = R * R^T.\n        // The relationship is matrix = P * L' * (L')^T * P^T = (P * L') * (P * L')^T, so R = P * L'.\n        rank = r; // The final rank is the value of r when the loop terminated.\n        // Create the root matrix of size order x rank.\n        root = MatrixUtils.createRealMatrix(order, rank);\n        // Fill the root matrix using the relationship R = P * L'.\n        // L' is stored in b (using loop indices i, j), P is the permutation defined by the index array.\n        for (int i = 0; i < order; ++i) { // Iterates through rows 'i' of L' (as stored in b)\n            for (int j = 0; j < rank; ++j) { // Iterates through columns 'j' of L' and R\n                // root_{k, j} = L'_{i, j} where k = index[i].\n                // This applies the permutation P to the rows of L'.\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n        // Assuming 'rank' and 'root' are instance variables, they are now set.\n        // this.rank = rank; // Implicitly set by using the instance variable 'rank'\n        // this.root = root; // Implicitly set by using the instance variable 'root'\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}