{
    "generation": "import org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.util.FastMath;\n\n// Assume fields this.rank and this.root are declared elsewhere in the class\n// private RealMatrix root;\n// private int rank;\n\n    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData(); // Matrix data is modified in-place\n        final double[][] b = new double[order][order]; // Stores the factor L for P^T A P = L L^T\n\n        int[] swap  = new int[order]; // Stores permutation info during pivoting\n        int[] index = new int[order]; // Stores the permutation p: index[k] is original index at position k\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0; // Current rank / column index\n        // The loop continues as long as loop is true, which is initially set\n        // and controlled inside the loop based on rank completion or matrix size.\n        for (boolean loop = true; loop;) {\n\n            // Find maximal diagonal element in the remaining submatrix (from r to order-1)\n            swap[r] = r; // Position of the max diagonal element found so far, initialized to current position r\n            // Initialize maxDiag with the diagonal element at the current position r\n            double maxDiag = c[index[r]][index[r]];\n\n            for (int i = r + 1; i < order; ++i) {\n                int ii = index[i]; // Original index of element at position i\n                double diag = c[ii][ii];\n                if (diag > maxDiag) {\n                    maxDiag = diag;\n                    swap[r] = i; // Update position of max diagonal\n                }\n            }\n\n            // Swap elements to bring the maximal diagonal element to position r\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            // Check the pivot element (maximal diagonal element, now at position r)\n            int ir = index[r]; // Original index of the pivot element\n            double pivot = c[ir][ir];\n\n            // Check for positive definiteness and handle rank deficiency\n            if (pivot < -small) {\n                // The pivot is significantly negative, matrix is not positive semidefinite.\n                // Use the original index 'ir' for reporting the problematic element.\n                throw new NonPositiveDefiniteMatrixException(pivot, ir, small);\n            } else if (pivot < small) {\n                // Pivot is close to zero (or slightly negative but within tolerance).\n                // This indicates potential rank deficiency.\n                // Check remaining diagonal elements for significant negative values before concluding.\n                for (int i = r; i < order; ++i) { // Check all remaining diagonal elements (including pivot position r)\n                     int currentOriginalIndex = index[i];\n                     // If any remaining diagonal element is significantly negative, the matrix is not PSD.\n                     if (c[currentOriginalIndex][currentOriginalIndex] < -small) {\n                         // Found a significantly negative diagonal element, matrix is not positive semidefinite.\n                         // Report the original index and value found.\n                         throw new NonPositiveDefiniteMatrixException(c[currentOriginalIndex][currentOriginalIndex], currentOriginalIndex, small);\n                     }\n                }\n                // All remaining diagonal elements are non-negative (within tolerance -small).\n                // The matrix is positive semidefinite but rank deficient. Rank is determined to be r.\n                loop = false; // Terminate the decomposition process; rank is r.\n            } else {\n                // Pivot is sufficiently positive (>= small). Perform Cholesky update step.\n                final double sqrtPivot = FastMath.sqrt(pivot);\n                b[r][r] = sqrtPivot; // Store diagonal element L_rr of the factor L\n                final double inverseSqrtPivot = 1.0 / sqrtPivot;\n\n                // Compute column r of L and update the trailing submatrix C (Schur complement)\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original index at position i (outer loop)\n                    // Compute L_ir = c[ii][ir] / L_rr (where ii=index[i], ir=index[r] refer to original indices)\n                    final double e = inverseSqrtPivot * c[ii][ir];\n                    // Store L_ir in b using the permuted row index i\n                    b[i][r] = e;\n                    // Update diagonal element C_ii = C_ii - L_ir^2\n                    // This update happens in the matrix c using original indices ii = index[i]\n                    c[ii][ii] -= e * e;\n\n                    // Update off-diagonal elements C_ij = C_ij - L_ir * L_jr\n                    // This update happens in the matrix c using original indices ii=index[i], ij=index[j]\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j]; // Original index at position j (inner loop)\n                        // b[j][r] stores L_jr (using permuted index j)\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f; // Maintain symmetry\n                    }\n                }\n\n                // Prepare for the next iteration: increment rank and check if we reached the end\n                r++; // Increment the rank since we successfully processed column r\n                loop = (r < order); // Continue if there are more columns/rows to process\n            }\n        } // End of main loop\n\n        // Build the root matrix R such that A = R R^T\n        // The algorithm computes L and P such that P^T A P = L L^T.\n        // This implies A = P L L^T P^T = (P L) (P L)^T.\n        // Therefore, the root matrix R must be R = P L.\n        // R_ij = (P L)_ij = L_{p(i), j}, where p(i) = index[i] is the original index corresponding to row i after permutation.\n        // The matrix b stores L using permuted indices: b[k][j] = L_kj.\n        // So, R_ij = L_{index[i], j} = b[index[i]][j].\n        rank = r; // The final rank is the value of r when the loop terminated.\n        this.rank = r; // Store rank in the instance field\n        root = MatrixUtils.createRealMatrix(order, rank);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < rank; ++j) {\n                 // Populate the root matrix R using the formula R_ij = b[index[i]][j]\n                 root.setEntry(i, j, b[index[i]][j]);\n            }\n        }\n        this.root = root; // Store the computed root matrix in the instance field\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}