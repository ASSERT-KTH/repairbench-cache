{
    "generation": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which columns are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     * @throws NonSquareMatrixException if the matrix is not square.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException, NonSquareMatrixException {\n\n        final int order = matrix.getRowDimension();\n        if (order != matrix.getColumnDimension()) {\n             throw new NonSquareMatrixException(order, matrix.getColumnDimension());\n        }\n\n        // Get a modifiable copy of the matrix data, as the algorithm updates it in place.\n        // This assumes matrix.copy() returns a matrix type (like Array2DRowRealMatrix)\n        // whose getData() provides direct access to the internal array.\n        final double[][] c = matrix.copy().getData();\n        // Stores columns of the Cholesky factor B of the permuted matrix P A P^T\n        final double[][] b = new double[order][order];\n\n        // 'index' array tracks permutations P such that P A P^T = B B^T\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0; // number of pivots processed (current rank)\n        for (boolean loop = true; loop; ) {\n\n            // Find maximal diagonal element in the remaining submatrix c[r..order-1][r..order-1]\n            // The indices used (ii, ipivot) are the actual indices in the matrix 'c'.\n            // The permutation is applied via the 'index' array.\n            int pivot = r; // 'pivot' is the index within the loop range [r, order-1] corresponding to max diagonal\n            int ipivot = index[pivot]; // Actual index in 'c' corresponding to index 'r' before searching\n            double maxDiag = c[ipivot][ipivot];\n\n            for (int i = r + 1; i < order; ++i) {\n                int ii = index[i]; // Actual index in 'c' corresponding to index 'i'\n                double diag = c[ii][ii];\n                if (diag > maxDiag) {\n                    maxDiag = diag;\n                    pivot = i; // Update 'pivot' to 'i' if a larger diagonal is found\n                }\n            }\n\n            // Swap elements in 'index' array and corresponding rows in 'b' matrix if necessary\n            if (pivot != r) {\n                // Swap indices in the permutation array 'index'\n                int tmpIdx = index[r];\n                index[r] = index[pivot];\n                index[pivot] = tmpIdx;\n\n                // Swap the corresponding already computed rows in 'b' (columns 0 to r-1)\n                // This ensures b[row_idx][col_idx] corresponds correctly to B_{row_idx, col_idx}\n                // relative to the *current* permutation P represented by 'index'.\n                for (int j = 0; j < r; ++j) {\n                    double tmpB = b[r][j];\n                    b[r][j] = b[pivot][j];\n                    b[pivot][j] = tmpB;\n                }\n            }\n\n            // The actual index in 'c' for the pivot element (row/column r after potential swap)\n            int ir = index[r];\n            double diag_ir = c[ir][ir]; // Pivot diagonal element value\n\n            // Check diagonal element: is it positive enough?\n            if (diag_ir < small) {\n                // Pivot is too small (close to zero or negative).\n\n                // Check if the pivot is significantly negative -> not positive semidefinite\n                if (diag_ir < -small) {\n                     // Use index[r] (== ir) which is the original index causing the issue\n                    throw new NonPositiveDefiniteMatrixException(diag_ir, ir, small);\n                }\n\n                // Pivot is close to zero (>= -small and < small).\n                // Check the remaining diagonal elements for significant negativity.\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Actual index in 'c'\n                    if (c[ii][ii] < -small) {\n                        // Found a subsequent significantly negative diagonal element.\n                        // Use index[i] (== ii) which is the original index causing the issue\n                        throw new NonPositiveDefiniteMatrixException(c[ii][ii], ii, small);\n                    }\n                }\n\n                // All remaining diagonal elements are non-negative or negligibly negative.\n                // The matrix is positive semidefinite but rank-deficient.\n                // Rank is 'r', the number of pivots processed so far.\n                // Stop the decomposition.\n                loop = false; // Exit the main loop\n\n            } else {\n                // Pivot is sufficiently large and positive. Process it.\n\n                // Compute the r-th column of the Cholesky factor B\n                final double sqrt_diag_ir = FastMath.sqrt(diag_ir);\n                b[r][r] = sqrt_diag_ir; // B_{r,r}\n                final double inverse = 1.0 / sqrt_diag_ir;\n\n                // Compute column r of B below the diagonal: B_{i,r} for i > r\n                // These are stored in b[i][r]\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Actual index for row i\n                    // Use c[ii][ir], element from (permuted) matrix C\n                    final double c_ii_ir = c[ii][ir];\n                    final double B_ir = inverse * c_ii_ir; // B_{i,r} = C_{ii,ir} / B_{r,r}\n                    b[i][r] = B_ir;\n                }\n\n                // Update the remaining submatrix C_22 = C_22 - B_21 * B_21^T\n                // where B_21 is the column vector [B_{r+1,r}, ..., B_{order-1,r}]^T\n                // This updates the matrix 'c' in place for the next iteration's pivot search.\n                // The element C_{ii,ij} is updated by subtracting B_{i,r} * B_{j,r}\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Actual index for row i\n                    // Update diagonal element first C_{ii,ii} = C_{ii,ii} - B_{i,r}^2\n                    // Need to use b[i][r] which was just computed\n                    c[ii][ii] -= b[i][r] * b[i][r];\n                    // Update off-diagonal elements C_{ii,ij} = C_{ii,ij} - B_{i,r} * B_{j,r} for j < i\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j]; // Actual index for row j\n                        // Need b[i][r] and b[j][r] which were computed above\n                        final double update = b[i][r] * b[j][r];\n                        c[ii][ij] -= update;\n                        // Explicitly maintain symmetry\n                        c[ij][ii] = c[ii][ij];\n                    }\n                }\n\n                // Prepare for the next iteration: increment rank and check if loop should continue\n                loop = ++r < order;\n            }\n        } // End of main loop\n\n        // Final rank is 'r', the number of successful pivots.\n        rank = r;\n\n        // Build the root matrix R such that A = R R^T.\n        // We have P A P^T = B B^T, where B is stored in 'b'.\n        // We need R = P^T B.\n        // The code correctly implements this via: root_{index[i], j} = b[i][j]\n        root = MatrixUtils.createRealMatrix(order, rank);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < rank; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}