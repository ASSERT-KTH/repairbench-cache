{
    "generation": "    /**\n     * <p>Checks if String contains a search String irrespective of case,\n     * handling <code>null</code>. Case-insensitivity is defined as by\n     * {@link String#equalsIgnoreCase(String)}.\n     *\n     * <p>A <code>null</code> String will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.contains(null, *) = false\n     * StringUtils.contains(*, null) = false\n     * StringUtils.contains(\"\", \"\") = true\n     * StringUtils.contains(\"abc\", \"\") = true\n     * StringUtils.contains(\"abc\", \"a\") = true\n     * StringUtils.contains(\"abc\", \"z\") = false\n     * StringUtils.contains(\"abc\", \"A\") = true\n     * StringUtils.contains(\"abc\", \"Z\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @param searchStr  the String to find, may be null\n     * @return true if the String contains the search String irrespective of\n     * case or false if not or <code>null</code> string input\n     */\n    public static boolean containsIgnoreCase(String str, String searchStr) {\n        if (str == null || searchStr == null) {\n            return false;\n        }\n        // Older versions of commons-lang used regionMatches().\n        // This is valid, but String.toLowerCase().indexOf() is slightly faster\n        // (based on profiling)\n        //\n        // Note: This is reversed from the previous implementation (comparison\n        // is case insensitive) because the previous implementation suffered\n        // from character encoding issues with specific locales where\n        // String.toUpperCase() did not work as expected.\n        // It is also better for performance as indexOf() works with\n        // compiled patterns/sequences - see Issue LANG-60\n        //\n        // It is known that this implementation is Locale dependent,\n        // despite the Javadoc stating that case-insensitivity is defined\n        // by String#equalsIgnoreCase(String).\n        // For a future major release, this method should be changed to use\n        // regionMatches again, or locale-sensitive equals used.\n\n        // A better approach that avoids locale issues of toUpperCase/toLowerCase\n        // based on the test failure and the goal of locale independence.\n        int len = searchStr.length();\n        int max = str.length() - len;\n        for (int i = 0; i <= max; i++) {\n            if (str.regionMatches(true, i, searchStr, 0, len)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}