{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n        if (buf.readableBytes() < 10) { // Basic check for minimum length (e.g., [AB*1*1234*TYPE])\n            return null;\n        }\n\n        if (buf.getByte(buf.readerIndex()) != '[') {\n            return null; // Doesn't start with '['\n        }\n        buf.skipBytes(1); // Skip '['\n\n        // Determine end index (ignoring ']')\n        int endSearchIndex = buf.writerIndex() - 1;\n        if (endSearchIndex < buf.readerIndex() || buf.getByte(endSearchIndex) != ']') {\n            // Malformed or ']' missing at the end\n            return null;\n        }\n\n        // 1. Manufacturer (2 bytes)\n        if (buf.readableBytes() < 2 + 1) return null; // Need manufacturer + '*' delimiter\n        String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        if (buf.readByte() != '*') return null; // Ensure '*' delimiter follows manufacturer\n\n        // 2. ID (variable length until '*')\n        int idEndIndex = buf.indexOf(buf.readerIndex(), endSearchIndex, (byte) '*');\n        if (idEndIndex < 0) return null; // No '*' delimiter after ID\n        String id = buf.readSlice(idEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        buf.readerIndex(idEndIndex + 1); // Position reader after ID and '*'\n\n        // Retrieve device session early\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null; // Cannot process without a session\n        }\n\n        // 3. Optional Index / Length / Payload Structure Determination\n        // Count remaining '*' delimiters before the final ']'\n        int starCount = 0;\n        int currentSearchIndex = buf.readerIndex();\n        while (currentSearchIndex < endSearchIndex) {\n            int starIndex = buf.indexOf(currentSearchIndex, endSearchIndex, (byte) '*');\n            if (starIndex < 0) {\n                break;\n            }\n            starCount++;\n            currentSearchIndex = starIndex + 1;\n        }\n\n        String index = null;\n        boolean hasIndex; // Track if index was present and parsed\n\n        // Parse based on delimiter count\n        if (starCount == 2) { // Format: [manufacturer*id*index*length*payload]\n            hasIndex = true;\n            int indexEndIndex = buf.indexOf(buf.readerIndex(), endSearchIndex, (byte) '*');\n            if (indexEndIndex < 0) return null; // Should be found based on starCount\n            index = buf.readSlice(indexEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n            buf.readerIndex(indexEndIndex + 1); // Position after index and '*'\n\n            // Skip length (4 bytes assumed) and final '*' before payload\n            if (buf.readableBytes() < 4 + 1) return null; // Need length field + '*' delimiter\n            buf.skipBytes(4); // Skip length field\n            if (buf.readByte() != '*') return null; // Ensure '*' delimiter follows length\n\n        } else if (starCount == 1) { // Format: [manufacturer*id*length*payload]\n            hasIndex = false; // Explicitly set for clarity, though index remains null\n            index = null;\n            // Skip length (4 bytes assumed) and final '*' before payload\n            if (buf.readableBytes() < 4 + 1) return null; // Need length field + '*' delimiter\n            buf.skipBytes(4); // Skip length field\n            if (buf.readByte() != '*') return null; // Ensure '*' delimiter follows length\n        } else {\n            // Invalid number of '*' delimiters found\n            return null;\n        }\n\n        // Now buf.readerIndex points to the start of the payload\n        // Adjust writerIndex to effectively ignore the final ']' for payload processing\n        buf.writerIndex(endSearchIndex);\n\n        // 4. Payload Type (string until first ',' or end of payload)\n        int payloadStartIndex = buf.readerIndex();\n        if (!buf.isReadable()) {\n            return null; // No payload present\n        }\n\n        int commaIndex = buf.indexOf(payloadStartIndex, buf.writerIndex(), (byte) ',');\n        int typeEndIndex;\n\n        if (commaIndex < 0) {\n            typeEndIndex = buf.writerIndex(); // Type is the whole remaining payload\n        } else {\n            typeEndIndex = commaIndex; // Type is up to the comma\n        }\n\n        String type = buf.readSlice(typeEndIndex - payloadStartIndex).toString(StandardCharsets.US_ASCII);\n        buf.readerIndex(typeEndIndex); // Position reader after the type string\n\n        // Move reader index past the comma if it exists, ready for payload data\n        if (commaIndex >= 0) {\n            buf.skipBytes(1); // Skip ','\n        }\n\n        // --- Process Payload based on Type ---\n\n        if (type.equals(\"INIT\")) {\n            sendResponse(channel, id, index, \"INIT,1\");\n            return null;\n\n        } else if (type.equals(\"LK\")) {\n            sendResponse(channel, id, index, \"LK\");\n            if (buf.isReadable()) {\n                String payload = buf.toString(StandardCharsets.US_ASCII);\n                String[] values = payload.split(\",\");\n                if (values.length >= 3) { // Expect steps, ?, battery\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null); // Use last known location\n                    try {\n                        position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                        position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    } catch (NumberFormatException e) {\n                        // Ignore parsing errors for LK optional data\n                    }\n                    return position;\n                }\n            }\n            return null; // No position if LK payload is missing/invalid or unreadable\n\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n            String payload = buf.toString(StandardCharsets.US_ASCII); // Pass remaining buffer as string\n            Position position = decodePosition(deviceSession, payload);\n\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    // Consider decoding specific alarm types from payload if needed\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n                sendResponse(channel, id, index, \"AL\"); // Send response even if position is null/failed decoding\n            }\n            return position;\n\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n            sendResponse(channel, id, index, type);\n            return null;\n\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n\n            if (buf.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, new Date()); // Use current time for health data\n\n                String payload = buf.toString(StandardCharsets.US_ASCII);\n                String[] values = payload.split(\",\");\n                int valueIndex = 0;\n\n                try {\n                    if (type.equalsIgnoreCase(\"btemp2\")) {\n                        if (values.length > valueIndex + 1 && Integer.parseInt(values[valueIndex++]) > 0) {\n                            position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    } else {\n                        if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                            if (values.length > valueIndex + 1) {\n                                position.set(\"pressureHigh\", values[valueIndex++]);\n                                position.set(\"pressureLow\", values[valueIndex++]);\n                            }\n                        }\n                        if (valueIndex < values.length) { // Check index bounds\n                            position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                        }\n                    }\n                    if (!position.getAttributes().isEmpty()) {\n                        return position; // Return only if data was successfully parsed\n                    }\n                } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {\n                    // Log error parsing health data? Ignore for now.\n                }\n            }\n            return null;\n\n        } else if (type.equals(\"img\")) {\n            // Assuming image data is the rest of the buffer after \"img,\"\n            if (buf.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null); // Use last known location\n                position.set(Position.KEY_IMAGE, writeMediaFile(id, buf, \"jpg\"));\n                return position;\n            }\n            return null;\n\n        } else if (type.equals(\"JXTK\")) {\n            // Payload: meta_0,meta_1,current_chunk,total_chunks,audio_data...\n\n            int jxtkPayloadStart = buf.readerIndex();\n            int comma1 = buf.indexOf(jxtkPayloadStart, buf.writerIndex(), (byte) ',');\n            if (comma1 < 0) return null;\n            int comma2 = buf.indexOf(comma1 + 1, buf.writerIndex(), (byte) ',');\n            if (comma2 < 0) return null;\n            int comma3 = buf.indexOf(comma2 + 1, buf.writerIndex(), (byte) ',');\n            if (comma3 < 0) return null;\n            int comma4 = buf.indexOf(comma3 + 1, buf.writerIndex(), (byte) ','); // Comma after total_chunks\n            if (comma4 < 0) return null;\n\n            String metadata = buf.toString(jxtkPayloadStart, comma4 - jxtkPayloadStart, StandardCharsets.US_ASCII);\n            String[] values = metadata.split(\",\");\n            if (values.length < 4) return null; // Expect at least 4 parts in metadata\n\n            int current;\n            int total;\n            try {\n                current = Integer.parseInt(values[2]);\n                total = Integer.parseInt(values[3]);\n            } catch (NumberFormatException e) {\n                return null; // Failed to parse chunk numbers\n            }\n\n            // Position reader at the start of audio data\n            buf.readerIndex(comma4 + 1);\n\n            // Use session attribute for audio buffer accumulation (key assumed to be \"audioBuffer\")\n            ByteBuf audio = (ByteBuf) deviceSession.get(\"audioBuffer\");\n            if (audio == null) {\n                audio = Unpooled.buffer();\n                deviceSession.set(\"audioBuffer\", audio);\n            }\n\n            // Append current audio chunk data (rest of the buffer)\n            audio.writeBytes(buf);\n\n            sendResponse(channel, id, index, \"JXTKR,1\");\n\n            if (current < total) {\n                // More chunks coming, buffer is stored in session\n                return null;\n            } else {\n                // Last chunk received\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null); // Use last known location\n\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n\n                // Clean up session buffer\n                audio.release();\n                deviceSession.set(\"audioBuffer\", null);\n\n                return position;\n            }\n\n        } else if (type.equals(\"TK\")) {\n            // Assuming TK payload is raw audio data\n            if (buf.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, buf, \"amr\")); // Pass remaining buffer\n                return position;\n            }\n            return null;\n        }\n\n        // Unknown type or case not handled\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}