{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        // Assume frame includes '[' and ']'\n        // Basic check for minimal structure like [M*I*L*C] requires more bytes\n        if (buf.readableBytes() < 8) {\n            return null;\n        }\n\n        buf.skipBytes(1); // Skip '['\n        // Determine the end of content, which is before the final ']'\n        // We assume the buffer ends exactly with ']', so writerIndex - 1 is the position of ']'\n        int contentEndLimit = buf.writerIndex() - 1;\n        if (contentEndLimit <= buf.readerIndex()) {\n            return null; // Empty or invalid frame\n        }\n\n        // 1. Manufacturer (2 bytes)\n        if (buf.readableBytes() < 2 + 1) return null; // Need Manu + '*' before content end\n        String parsedManufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        // Store manufacturer in instance variable if needed by sendResponse, or pass it.\n        // Assuming sendResponse is modified or manufacturer is accessible via instance var.\n        // Let's store it for compatibility with original sendResponse helper usage pattern.\n        this.manufacturer = parsedManufacturer;\n        buf.skipBytes(1); // Skip '*' (first '*')\n\n        // 2. ID (variable length until '*')\n        int idEndIndex = buf.indexOf(buf.readerIndex(), contentEndLimit, (byte) '*');\n        if (idEndIndex < 0 || idEndIndex == buf.readerIndex()) {\n             return null; // No ID or delimiter found\n        }\n        String id = buf.readSlice(idEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n             return null; // Unknown device\n        }\n        buf.skipBytes(1); // Skip '*' (second '*')\n\n        // 3. Optional Index / Length (Check format)\n        String index = null;\n        // Find the third '*' which delimits the index or length field\n        int thirdStarIndex = buf.indexOf(buf.readerIndex(), contentEndLimit, (byte) '*');\n        if (thirdStarIndex < 0) {\n            return null; // Malformed structure, missing third '*'\n        }\n\n        // Look ahead: Check if the field *after* the third star looks like a 4-hex-digit length followed by '*'\n        int lengthCheckStartIndex = thirdStarIndex + 1;\n        // Ensure space for 4 hex digits + 1 for '*' before the content end limit ']'\n        if (lengthCheckStartIndex + 4 < contentEndLimit &&\n            buf.getByte(lengthCheckStartIndex + 4) == '*' &&    // Check for the fourth '*' delimiter\n            buf.toString(lengthCheckStartIndex, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n\n            // Format matches: Field *before* third star is index, field *after* is length.\n            int indexLength = thirdStarIndex - buf.readerIndex();\n            if (indexLength > 0) {\n                index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n            } // else: empty index field, index remains null\n            buf.skipBytes(1); // Skip '*' (third '*') - delimiter after index\n\n            // Now skip the length field (which we confirmed looks like length) and its delimiter\n            if (buf.readableBytes() < 4 + 1) return null; // Not enough bytes left\n            buf.skipBytes(4); // Skip length\n            buf.skipBytes(1); // Skip '*' (fourth '*') - delimiter after length\n\n        } else {\n            // Format doesn't match: Field *before* third star is assumed to be length. No index field.\n            // index remains null.\n            int lengthLength = thirdStarIndex - buf.readerIndex();\n            // Validate the assumed length field: must be 4 hex digits\n            if (lengthLength != 4 || !buf.toString(buf.readerIndex(), 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n                 return null; // Malformed message, field doesn't look like length\n            }\n            if (buf.readableBytes() < lengthLength + 1) return null; // Not enough bytes left\n            buf.skipBytes(lengthLength); // Skip length\n            buf.skipBytes(1); // Skip '*' (third '*') - delimiter after length\n        }\n\n        // Now readerIndex is at the start of the message content (type + data)\n        int actualContentEnd = contentEndLimit; // The effective end of the payload\n\n        // 4. Message Type (until first comma or end of content)\n        int typeEndIndex = buf.indexOf(buf.readerIndex(), actualContentEnd, (byte) ',');\n        if (typeEndIndex < 0) { // No comma found before end\n             typeEndIndex = actualContentEnd; // Type is everything up to end\n        }\n\n        // Ensure type is not empty\n        if (typeEndIndex <= buf.readerIndex()) {\n             return null; // No type found or empty content after headers\n        }\n        String type = buf.readSlice(typeEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        // Position reader index after the type (and comma, if present)\n        int dataStartIndex = (typeEndIndex < actualContentEnd && buf.getByte(typeEndIndex) == ',') ? typeEndIndex + 1 : typeEndIndex;\n        // Ensure dataStartIndex doesn't exceed actualContentEnd\n        dataStartIndex = Math.min(dataStartIndex, actualContentEnd);\n        buf.readerIndex(dataStartIndex); // Position reader at start of data payload\n\n        // Create a buffer representing only the data payload\n        // Slice creates a view, doesn't copy or retain unless needed later.\n        int dataLength = actualContentEnd - dataStartIndex;\n        ByteBuf data = buf.slice(dataStartIndex, dataLength);\n\n\n        // --- Process message based on type ---\n        // Use the 'data' buffer for payload processing\n\n        if (type.equals(\"INIT\")) {\n            sendResponse(channel, id, index, \"INIT,1\");\n            return null;\n        } else if (type.equals(\"LK\")) {\n            sendResponse(channel, id, index, \"LK\");\n            if (data.isReadable()) {\n                String[] values = data.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    try {\n                        Position position = new Position(getProtocolName());\n                        position.setDeviceId(deviceSession.getDeviceId());\n                        getLastLocation(position, null);\n                        position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                        position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                        return position;\n                    } catch (NumberFormatException e) { /* Log potentially */ return null; }\n                }\n            }\n             return null;\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n            // decodePosition handles parsing the payload string\n            String payload = data.toString(StandardCharsets.US_ASCII);\n            Position position = decodePosition(deviceSession, payload);\n            if (position != null && type.startsWith(\"AL\")) {\n                 // Keep original alarm logic, decodePosition might set specifics\n                 position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                 sendResponse(channel, id, index, \"AL\");\n            }\n            return position;\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n             sendResponse(channel, id, index, type);\n             return null;\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n             if (data.isReadable()) {\n                 Position position = new Position(getProtocolName());\n                 position.setDeviceId(deviceSession.getDeviceId());\n                 getLastLocation(position, new Date()); // Use current time for health data\n                 String[] values = data.toString(StandardCharsets.US_ASCII).split(\",\");\n                 int valueIndex = 0;\n                 try {\n                    if (type.equalsIgnoreCase(\"btemp2\")) {\n                        // values[0] is status, values[1] is temp\n                        if (values.length > valueIndex + 1 && Integer.parseInt(values[valueIndex++]) > 0) {\n                            position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    } else {\n                        if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                            // values[0] high, values[1] low, values[2] rate\n                            if (values.length > valueIndex + 1) {\n                                position.set(\"pressureHigh\", values[valueIndex++]);\n                                position.set(\"pressureLow\", values[valueIndex++]);\n                            } else { return null; /* Malformed */ }\n                        }\n                        // Heart rate might be present alone or after blood pressure\n                        if (valueIndex < values.length) {\n                            position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                        }\n                    }\n                    // Only return if we successfully parsed some attributes\n                    if (!position.getAttributes().isEmpty()) {\n                        return position;\n                    }\n                 } catch (NumberFormatException | IndexOutOfBoundsException e) { /* Log potentially */ return null; }\n             }\n             return null;\n        } else if (type.equals(\"img\")) {\n             if (!data.isReadable()) return null;\n             Position position = new Position(getProtocolName());\n             position.setDeviceId(deviceSession.getDeviceId());\n             getLastLocation(position, null); // Image may not correspond to current location\n             // Assume format is time,image_bytes\n             int commaIndex = data.indexOf(data.readerIndex(), data.writerIndex(), (byte) ',');\n             if (commaIndex >= data.readerIndex()) { // Allow comma at start if time is empty? Check protocol.\n                 data.readerIndex(commaIndex + 1); // Skip time and comma\n                 if (data.isReadable()) {\n                     // Pass a retained slice to writeMediaFile as 'data' might be invalidated\n                     position.set(Position.KEY_IMAGE, writeMediaFile(id, data.readRetainedSlice(data.readableBytes()), \"jpg\"));\n                     return position;\n                 }\n             }\n             return null; // Image data format error or empty after comma\n        } else if (type.equals(\"JXTK\")) {\n            // Payload: 0,watch_7_...,1,6,AMR_BYTES\n            if (!data.isReadable()) return null;\n            // Find the 4th comma to locate the end of the header section\n            int headerEndIndex = BufferUtil.indexOf(data, data.readerIndex(), data.writerIndex(), (byte) ',', 4);\n            if (headerEndIndex < 0) { return null; } // Not enough commas\n\n            // Read header for parsing without advancing reader yet\n            String headerPart = data.toString(data.readerIndex(), headerEndIndex - data.readerIndex(), StandardCharsets.US_ASCII);\n            String[] values = headerPart.split(\",\");\n            if (values.length < 4) { return null; } // Malformed header\n\n            // Advance reader index of 'data' buffer past header and the final comma\n            data.readerIndex(headerEndIndex + 1);\n\n            try {\n                int current = Integer.parseInt(values[2]);\n                int total = Integer.parseInt(values[3]);\n\n                // Get the actual audio bytes from the rest of the data buffer\n                ByteBuf audioChunk = data.readRetainedSlice(data.readableBytes()); // Use retained slice\n\n                // Manage the combined audio buffer (instance field 'audio')\n                if (audio == null) {\n                    audio = Unpooled.buffer();\n                }\n                audio.writeBytes(audioChunk);\n                audioChunk.release(); // Release the slice\n\n                sendResponse(channel, id, index, \"JXTKR,1\");\n\n                if (current < total) {\n                    return null; // Intermediate chunk\n                } else {\n                    // Last chunk arrived, process the complete audio buffer\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null); // Get last known location\n                    // 'audio' now holds the complete data\n                    position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                    audio.release(); // Release the combined buffer\n                    audio = null;    // Reset the instance field\n                    return position; // Return position with audio key\n                }\n            } catch (NumberFormatException e) {\n                 // Clean up partially assembled audio if header parsing fails\n                 if (audio != null) { audio.release(); audio = null; }\n                 return null;\n            }\n        } else if (type.equals(\"TK\")) {\n            // Standalone audio message\n            if (!data.isReadable()) return null;\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n            // Pass retained slice of data buffer to writer\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, data.readRetainedSlice(data.readableBytes()), \"amr\"));\n            return position;\n        }\n\n        return null; // Unknown type\n    }\n\n    // Assumes this.manufacturer field is set in decode method\n    // Or modify to accept manufacturer as a parameter\n    private void sendResponse(Channel channel, String id, String index, String text) {\n        if (channel != null && channel.isActive()) {\n            if (this.manufacturer == null) {\n                // Log.error(\"Manufacturer not available for sending response\");\n                return;\n            }\n            StringBuilder response = new StringBuilder(\"[\");\n            response.append(this.manufacturer); // Use instance field\n            response.append(\"*\");\n            response.append(id);\n            response.append(\"*\");\n            if (index != null) {\n                response.append(index);\n                response.append(\"*\");\n            }\n            // Format length as 4 hex digits\n            String hexLength = String.format(\"%04x\", text.length());\n            response.append(hexLength);\n            response.append(\"*\");\n            response.append(text);\n            response.append(\"]\");\n            channel.writeAndFlush(new NetworkMessage(\n                    Unpooled.copiedBuffer(response.toString(), StandardCharsets.US_ASCII),\n                    channel.remoteAddress()));\n        }\n    }\n\n    // Instance field for manufacturer (if using the sendResponse pattern above)\n    // Alternatively, pass manufacturer explicitly to sendResponse\n    private String manufacturer;\n\n    // Instance field for JXTK audio assembly\n    private ByteBuf audio;\n\n    // Abstract methods assumed to be implemented elsewhere:\n    // protected abstract DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress, String... uniqueIds);\n    // protected abstract void getLastLocation(Position position, Date date);\n    // protected abstract String writeMediaFile(String uniqueId, ByteBuf buf, String extension);\n    // protected abstract Position decodePosition(DeviceSession deviceSession, String data);\n    // private String getProtocolName() { return protocol.getName(); } // Assumed helper",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}