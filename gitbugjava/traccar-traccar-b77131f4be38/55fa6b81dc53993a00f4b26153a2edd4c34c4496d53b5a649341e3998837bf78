{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idIndex < 0) {\n            // Malformed message: missing ID delimiter\n            return null;\n        }\n        String id = buf.readSlice(idIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter\n\n        String index = null;\n        boolean hasIndex = false;\n\n        // Check if there's an index field. It's identified by being 4 hex digits followed by '*'\n        int potentialIndexDelimiter = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (potentialIndexDelimiter >= 0) {\n            // Check if the segment between current readerIndex and potentialIndexDelimiter is 4 chars long\n            // and contains hex digits, indicating it's the 'index' field.\n            // Also, check if the part *after* this potential index field and its delimiter is a 4-char length field\n            // followed by another '*' delimiter.\n            if (potentialIndexDelimiter - buf.readerIndex() == 4\n                    && buf.toString(buf.readerIndex(), 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")\n                    && potentialIndexDelimiter + 5 < buf.writerIndex() // Ensure enough bytes for length and its delimiter\n                    && buf.getByte(potentialIndexDelimiter + 5) == '*') { // Check the byte after the 4-char length is '*'\n                hasIndex = true;\n                index = buf.readSlice(4).toString(StandardCharsets.US_ASCII); // Read the 4-char index\n                buf.skipBytes(1); // Skip '*' delimiter after index\n            }\n        }\n\n        // Now readerIndex is at the beginning of the length field (e.g., \"0009\").\n        // Parse the length field (4 ASCII hex characters)\n        int length = Integer.parseInt(buf.readSlice(4).toString(StandardCharsets.US_ASCII), 16);\n        buf.skipBytes(1); // Skip '*' delimiter after length\n\n        // The content is of `length` bytes, starting from the current reader index.\n        // The last byte of the entire message is ']', which should not be included in the content processing.\n        int contentEndIndex = buf.readerIndex() + length;\n        // Ensure the calculated contentEndIndex does not exceed the actual buffer's bounds before the final ']'\n        if (contentEndIndex > buf.writerIndex() - 1) {\n             contentEndIndex = buf.writerIndex() - 1; // Adjust to the end of readable bytes before ']'\n        }\n\n        // Create a slice for the content to ensure all operations (indexOf, readSlice, toString)\n        // are confined to the actual message payload, ignoring potential delimiters in binary data\n        // outside this range or the trailing ']'\n        ByteBuf contentBuf = buf.readSlice(contentEndIndex - buf.readerIndex());\n\n        // Now, advance the main buffer's reader index past the content and the trailing ']'\n        // This is important because `readSlice` advances the reader index of the *original* buffer.\n        // So `buf.readerIndex()` is now at `contentEndIndex`. We just need to skip the final `]`.\n        buf.skipBytes(1); // Skip the ']'\n\n        // Determine the type by finding the first comma within the content\n        int typeDelimiterIndex = contentBuf.indexOf(contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ',');\n        if (typeDelimiterIndex < 0) {\n            // If no comma, the whole content is the type string\n            typeDelimiterIndex = contentBuf.writerIndex();\n        }\n\n        String type = contentBuf.readSlice(typeDelimiterIndex - contentBuf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        if (typeDelimiterIndex < contentBuf.writerIndex()) {\n            contentBuf.readerIndex(typeDelimiterIndex + 1); // Advance contentBuf's reader index past the comma\n        }\n\n        if (type.equals(\"INIT\")) {\n            sendResponse(channel, id, index, \"INIT,1\");\n        } else if (type.equals(\"LK\")) {\n            sendResponse(channel, id, index, \"LK\");\n            if (contentBuf.isReadable()) {\n                String[] values = contentBuf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) { // Expecting \"steps,battery_level,...\" (e.g. \"0,10,100\")\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n\n                    getLastLocation(position, null);\n\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n\n                    return position;\n                }\n            }\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n            Position position = decodePosition(deviceSession, contentBuf.toString(StandardCharsets.US_ASCII));\n\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n                sendResponse(channel, id, index, \"AL\");\n            }\n            return position;\n\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n\n            sendResponse(channel, id, index, type);\n\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n\n            if (contentBuf.isReadable()) {\n\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                getLastLocation(position, new Date());\n\n                String[] values = contentBuf.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    // Example: \"btemp2,1,35.29\" -> values={\"1\", \"35.29\"}\n                    if (valueIndex < values.length && Integer.parseInt(values[valueIndex++]) > 0\n                            && valueIndex < values.length) {\n                        position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                    }\n                } else {\n                    // Example: \"BPHRT,120,79,73\" -> values={\"120\", \"79\", \"73\"}\n                    // Example: \"PULSE,72\" -> values={\"72\"}\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        if (valueIndex < values.length) {\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                        if (valueIndex < values.length) {\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        }\n                    }\n                    if (valueIndex < values.length) {\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n\n                return position;\n\n            }\n\n        } else if (type.equals(\"img\")) {\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            // The contentBuf starts after \"img,\" and contains \"time_string,counter,image_data\".\n            // First, skip \"time_string,\"\n            int firstComma = contentBuf.indexOf(contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ',');\n            if (firstComma >= 0) {\n                contentBuf.readerIndex(firstComma + 1); // Skip past \"time_string,\"\n\n                // Then, skip \"counter,\" if present\n                int secondComma = contentBuf.indexOf(contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ',');\n                if (secondComma >= 0) {\n                    contentBuf.readerIndex(secondComma + 1); // Skip past \"counter,\"\n                }\n            }\n            // The remaining contentBuf is the image data\n            position.set(Position.KEY_IMAGE, writeMediaFile(id, contentBuf, \"jpg\"));\n\n            return position;\n\n        } else if (type.equals(\"JXTK\")) {\n            // JXTK format: JXTK,packet_index,file_id,current_chunk,total_chunks,data\n            // Example: JXTK,0,watch_7_20220526093954,1,6,#!AMR...\n            // Need to find the 4th comma to parse current_chunk and total_chunks\n\n            // Find the absolute index of the 4th comma within the current contentBuf's readable bytes\n            // The `BufferUtil.indexOf` expects absolute indexes, but internally works with slice offsets.\n            int fourCommaIndex = BufferUtil.indexOf(contentBuf, contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ',', 4);\n            \n            if (fourCommaIndex < 0) {\n                // Malformed message: Not enough commas for JXTK parameters\n                return null;\n            }\n\n            // Read the string containing \"packet_index,file_id,current_chunk,total_chunks\"\n            // This slice goes from current readerIndex to the 4th comma.\n            String[] values = contentBuf.readSlice(fourCommaIndex - contentBuf.readerIndex()).toString(StandardCharsets.US_ASCII).split(\",\");\n            \n            if (values.length < 4) { // Ensure all expected values are present\n                return null;\n            }\n\n            // Extract current and total chunk numbers\n            int current = Integer.parseInt(values[2]); // current_chunk (e.g., 1)\n            int total = Integer.parseInt(values[3]);   // total_chunks (e.g., 6)\n\n            // Advance contentBuf's reader index past the 4th comma\n            contentBuf.readerIndex(fourCommaIndex + 1);\n\n            if (audio == null) {\n                audio = Unpooled.buffer();\n            }\n            audio.writeBytes(contentBuf); // Write remaining binary data to audio buffer\n\n            sendResponse(channel, id, index, \"JXTKR,1\");\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                audio.release();\n                audio = null;\n                return position;\n            }\n\n        } else if (type.equals(\"TK\")) {\n            // TK message format: TK,audio_data\n            // The contentBuf's reader index is already after \"TK,\"\n            // The remaining contentBuf is the audio data.\n            if (!contentBuf.isReadable()) { // If no content after \"TK,\"\n                return null;\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, contentBuf, \"amr\"));\n\n            return position;\n\n        }\n\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}