{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        this.hasIndex = false; // Reset state for each message\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        if (buf.readableBytes() < 1) { return null; } // Need at least '['\n        buf.skipBytes(1); // '[' header\n\n        if (buf.readableBytes() < 2 + 1) { return null; } // Need 'MF*'\n        this.manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII); // Assuming 'manufacturer' is a field\n        buf.skipBytes(1); // '*' delimiter\n\n        int idEndIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idEndIndex < 0 || idEndIndex == buf.readerIndex()) { // ID delimiter not found or ID is empty\n            return null;\n        }\n        String id = buf.readSlice(idEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter after ID\n\n        String index = null; // Local variable for current message's index string\n        \n        // Check for ZJ-style optional index: ID*INDEX*LENGTH*TYPE\n        // Current readerIndex is at the start of the field after ID (either INDEX or LENGTH)\n        int firstStarInPayload = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        // Check if the pattern INDEX*LENGTH_HEX(4)* exists\n        if (firstStarInPayload != -1 && (firstStarInPayload + 1 + 4) < buf.writerIndex() // Enough bytes for LENGTH_HEX(4)\n                && buf.getByte(firstStarInPayload + 1 + 4) == '*' // Check for '*' after LENGTH_HEX(4)\n                && buf.toString(StandardCharsets.US_ASCII, firstStarInPayload + 1, 4).matches(\"\\\\p{XDigit}+\")) { // Check if LENGTH_HEX(4) is hex\n            \n            // Format seems to be ID*<current_field_is_index>*<4_hex_length_field>*TYPE\n            // <current_field_is_index> is from buf.readerIndex() to firstStarInPayload\n            int indexLength = firstStarInPayload - buf.readerIndex();\n            if (indexLength > 0) { // Ensure index string is not empty\n                index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n                this.hasIndex = true; // Set field indicating an index is present for response formatting\n            }\n            // If indexLength is 0, index remains null and hasIndex remains false.\n            buf.skipBytes(1); // Skip '*' delimiter after the index field (or after the position if index was empty)\n            // Reader index is now at the start of the 4-char hex LENGTH field\n        }\n        // If ZJ-style index was not found (or was empty):\n        //   `this.hasIndex` remains false. `index` (local) remains null.\n        //   Reader index is still at the start of the (single) 4-char hex LENGTH field.\n\n        if (buf.readableBytes() < 4 + 1) { // Check for LENGTH (4) + delimiter (1)\n            return null; // Malformed\n        }\n        buf.skipBytes(4); // Skip 4-char LENGTH field\n        buf.skipBytes(1); // Skip '*' delimiter after LENGTH field\n        // Reader index is now at the start of the TYPE string\n\n        // Ensure buffer ends with ']' and has content for TYPE\n        if (buf.readableBytes() == 0 || buf.getByte(buf.writerIndex() - 1) != ']') {\n            return null; // Malformed (empty after length or no trailing ']')\n        }\n        buf.writerIndex(buf.writerIndex() - 1); // Temporarily remove ']' for parsing TYPE and content\n\n        int commaAfterType = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        int typeEndPosition;\n        if (commaAfterType < 0) {\n            typeEndPosition = buf.writerIndex(); // No comma, type is till (modified) end\n        } else {\n            typeEndPosition = commaAfterType;\n        }\n\n        if (typeEndPosition <= buf.readerIndex()) { // TYPE string is empty\n            buf.writerIndex(buf.writerIndex() + 1); // Restore ']' before returning\n            return null; // Malformed\n        }\n        String type = buf.readSlice(typeEndPosition - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        if (commaAfterType >= 0 && commaAfterType < buf.writerIndex()) { // If comma was found and it's before end of buffer\n            buf.readerIndex(commaAfterType + 1); // Move reader index past comma to start of content\n        }\n        // Note: buf.writerIndex() is still one less than original due to ']' removal. This is implicitly handled\n        // as operations like buf.toString(StandardCharsets.US_ASCII) use readableBytes().\n\n        if (type.equals(\"INIT\")) {\n\n            sendResponse(channel, id, index, \"INIT,1\");\n\n        } else if (type.equals(\"LK\")) {\n\n            sendResponse(channel, id, index, \"LK\");\n\n            if (buf.isReadable()) {\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n\n                    getLastLocation(position, null);\n\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n\n                    return position;\n                }\n            }\n\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n\n            Position position = decodePosition(deviceSession, buf.toString(StandardCharsets.US_ASCII));\n\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n                sendResponse(channel, id, index, \"AL\");\n            }\n\n            return position;\n\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n\n            sendResponse(channel, id, index, type);\n\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n\n            if (buf.isReadable()) {\n\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                getLastLocation(position, new Date());\n\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    if (values.length > valueIndex + 1 && Integer.parseInt(values[valueIndex++]) > 0) { // Check length\n                        position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                    }\n                } else {\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        if (values.length > valueIndex + 1) { // Check length\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        } else if (values.length > valueIndex) { // Check length for at least one value\n                             position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                    }\n                    if (valueIndex <= values.length - 1) {\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n                // Return position only if some data was actually set, or always?\n                // Original code returns position even if parsing of values fails or nothing is set.\n                // For now, matching original behavior.\n                return position;\n            }\n\n        } else if (type.equals(\"img\")) {\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            // Ensure comma exists before trying to find timeIndex\n            int timePartIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n            if (timePartIndex > 0 && (timePartIndex + 12 + 2) <= buf.writerIndex()) { // Check bounds\n                buf.readerIndex(timePartIndex + 12 + 2);\n                if (buf.isReadable()) { // Check if there's image data left\n                    position.set(Position.KEY_IMAGE, writeMediaFile(id, buf, \"jpg\"));\n                }\n            }\n            return position;\n\n        } else if (type.equals(\"JXTK\")) {\n\n            int dataIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), (byte) ',', 4);\n            if (dataIndex < 0) { // Ensure 4 commas are found\n                 // Malformed JXTK header, or not enough parts.\n                 // Restore writerIndex if returning early, though 'buf' is usually discarded after decode.\n                 buf.writerIndex(buf.writerIndex() + 1);\n                 return null;\n            }\n            dataIndex +=1; // Move past the 4th comma\n\n            // Ensure dataIndex is not past readerIndex, can happen if BufferUtil.indexOf returns -1 and dataIndex becomes 0.\n            // Already checked with dataIndex < 0. Now check if length is non-negative.\n            if (dataIndex - buf.readerIndex() < 0) {\n                buf.writerIndex(buf.writerIndex() + 1);\n                return null;\n            }\n\n            String headerPart = buf.readCharSequence(dataIndex - buf.readerIndex(), StandardCharsets.US_ASCII).toString();\n            String[] values = headerPart.split(\",\"); // headerPart itself ends with a comma if 4th comma was found\n\n            if (values.length < 4) { // current and total are at index 2 and 3 of 0-indexed parts from split\n                buf.writerIndex(buf.writerIndex() + 1);\n                return null; // Not enough parts for current/total\n            }\n\n            int current = Integer.parseInt(values[2]);\n            int total = Integer.parseInt(values[3]);\n\n            if (audio == null) {\n                audio = Unpooled.buffer();\n            }\n            audio.writeBytes(buf); // Write remaining part of buf (audio data)\n\n            sendResponse(channel, id, index, \"JXTKR,1\");\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                audio.release();\n                audio = null;\n                return position;\n            }\n\n        } else if (type.equals(\"TK\")) {\n\n            if (buf.readableBytes() <= 1) { // If only ']' potentially, or very short\n                // original check was == 1. <=1 is safer.\n                // If readableBytes is 0 after type parsing and ']' removal, this also handles it.\n                buf.writerIndex(buf.writerIndex() + 1); // Restore ']'\n                return null;\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, buf, \"amr\"));\n\n            return position;\n\n        }\n        \n        // Restore writerIndex if it was modified, for consistency, although frame is usually consumed.\n        // This depends on whether subsequent processing in the pipeline might re-read the buffer.\n        // In Traccar, usually not. So, not strictly necessary to restore if returning.\n        // buf.writerIndex(buf.writerIndex() + 1); // If we didn't return earlier.\n\n        return null;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}