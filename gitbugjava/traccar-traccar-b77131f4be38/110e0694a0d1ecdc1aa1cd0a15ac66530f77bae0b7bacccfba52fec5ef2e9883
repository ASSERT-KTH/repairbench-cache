{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idEndIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idEndIndex < 0) {\n            return null; // Malformed: ID delimiter not found\n        }\n        String id = buf.readSlice(idEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter (after id)\n\n        String index = null;\n        // Check for optional index field.\n        // Peek at the next field: if it's not a 4-hex-char length followed by '*', then current field is length.\n        // Otherwise, current field is index.\n        int nextStar = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (nextStar < 0) {\n            return null; // Malformed: delimiter for index/length not found\n        }\n\n        // If (the field after nextStar) is (4 hex chars + '*') then current field is index\n        if (nextStar + 1 + 4 < buf.writerIndex() && buf.getByte(nextStar + 1 + 4) == '*'\n                && buf.toString(StandardCharsets.US_ASCII, nextStar + 1, 4).matches(\"\\\\p{XDigit}+\")) {\n            int indexLength = nextStar - buf.readerIndex();\n            index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n            buf.skipBytes(1); // '*' delimiter after index\n            hasIndex = true;\n        } else {\n            hasIndex = false; // No index field, or malformed\n        }\n\n        // Current readerIndex is at the start of the 4-char hex length field.\n        if (buf.readableBytes() < 4 + 1) { // 4 for length, 1 for delimiter\n             return null; // Not enough data for length and delimiter\n        }\n        String hexLength = buf.readCharSequence(4, StandardCharsets.US_ASCII).toString();\n        int messageDataLength = Integer.parseInt(hexLength, 16);\n        buf.skipBytes(1); // Skip '*' delimiter after length field\n\n        if (buf.readableBytes() < messageDataLength + 1) { // messageData + ']'\n            return null; // Not enough data for payload and trailer\n        }\n        ByteBuf dataSlice = buf.readSlice(messageDataLength); // Contains \"type,payload\"\n        \n        buf.skipBytes(1); // Consume the trailing ']' from the main buffer 'buf'\n\n        // Parse 'type' from 'dataSlice'. dataSlice.readerIndex() is 0.\n        int commaIndexInSlice = dataSlice.indexOf(dataSlice.readerIndex(), dataSlice.writerIndex(), (byte) ',');\n        \n        String type;\n        if (commaIndexInSlice != -1) { // Found comma\n            type = dataSlice.toString(dataSlice.readerIndex(), commaIndexInSlice - dataSlice.readerIndex(), StandardCharsets.US_ASCII);\n            dataSlice.readerIndex(dataSlice.readerIndex() + (commaIndexInSlice - dataSlice.readerIndex()) + 1); // Advance past type and comma\n        } else { // No comma\n            type = dataSlice.toString(StandardCharsets.US_ASCII); // Type is the whole remaining slice\n            dataSlice.readerIndex(dataSlice.writerIndex()); // Consume the whole slice\n        }\n        \n        // Now 'dataSlice' has its readerIndex at the start of the payload.\n\n        if (type.equals(\"INIT\")) {\n            sendResponse(channel, id, index, \"INIT,1\");\n        } else if (type.equals(\"LK\")) {\n            sendResponse(channel, id, index, \"LK\");\n            if (dataSlice.isReadable()) {\n                String[] values = dataSlice.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                    return position;\n                }\n            }\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n            Position position = decodePosition(deviceSession, dataSlice.toString(StandardCharsets.US_ASCII));\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    // decodePosition should set the specific alarm type if available in payload\n                    // This is a fallback or default\n                    if (position.getAttributes().get(Position.KEY_ALARM) == null) {\n                        position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                    }\n                }\n                sendResponse(channel, id, index, \"AL\");\n            }\n            return position;\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n            sendResponse(channel, id, index, type);\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n            if (dataSlice.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, new Date());\n                String[] values = dataSlice.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    if (values.length > valueIndex && Integer.parseInt(values[valueIndex++]) > 0) {\n                        if (values.length > valueIndex) {\n                           position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    }\n                } else {\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        }\n                    }\n                    if (valueIndex < values.length) { // Check if valueIndex is a valid index\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n                return position;\n            }\n        } else if (type.equals(\"img\")) {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n\n            // Payload in dataSlice starts after \"img,\". Example: \"DDMMYYHHMMSS,garbage,binary_image_data\"\n            // Original logic: buf.readerIndex(timeIndex + 12 + 2); where timeIndex is the first comma.\n            // This means skipping the content up to the first comma, the comma itself, then 12 bytes (timestamp), then 2 more bytes.\n            int firstCommaInPayload = dataSlice.indexOf(dataSlice.readerIndex(), dataSlice.writerIndex(), (byte) ',');\n            if (firstCommaInPayload != -1) {\n                // Calculate offset of firstCommaInPayload from current dataSlice.readerIndex()\n                int offsetToComma = firstCommaInPayload - dataSlice.readerIndex();\n                // Check if there's enough data to skip\n                if (dataSlice.readableBytes() >= offsetToComma + 1 + 12 + 2) {\n                    dataSlice.skipBytes(offsetToComma); // Skip to comma\n                    dataSlice.skipBytes(1);             // Skip comma\n                    dataSlice.skipBytes(12 + 2);        // Skip timestamp and 2 more bytes\n                    if (dataSlice.isReadable()) {\n                        position.set(Position.KEY_IMAGE, writeMediaFile(id, dataSlice, \"jpg\"));\n                    }\n                }\n            }\n            return position;\n        } else if (type.equals(\"JXTK\")) {\n            // dataSlice contains JXTK payload: \"0,watch_name,current_chunk,total_chunks,audio_data\"\n            int fourthCommaIndex = BufferUtil.indexOf(dataSlice, dataSlice.readerIndex(), dataSlice.writerIndex(), (byte) ',', 4);\n            if (fourthCommaIndex < 0) { \n                return null; // Malformed JXTK payload (not enough commas)\n            }\n\n            ByteBuf csvHeaderSlice = dataSlice.readSlice(fourthCommaIndex - dataSlice.readerIndex());\n            dataSlice.skipBytes(1); // Skip the 4th comma\n            \n            String[] values = csvHeaderSlice.toString(StandardCharsets.US_ASCII).split(\",\");\n            if (values.length < 4) {\n                return null; // Malformed JXTK CSV part\n            }\n\n            int current = Integer.parseInt(values[2]);\n            int total = Integer.parseInt(values[3]);\n\n            if (audio == null) {\n                audio = Unpooled.buffer(256 * 1024); // Initialize with a reasonable capacity\n            }\n            audio.writeBytes(dataSlice); // Write the remaining part of dataSlice (audio chunk)\n\n            sendResponse(channel, id, index, \"JXTKR,1\");\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                audio.release(); \n                audio = null;    \n                return position;\n            }\n        } else if (type.equals(\"TK\")) {\n            if (dataSlice.readableBytes() <= 1) { // If only 1 byte or less, might be incomplete/invalid\n                return null;\n            }\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, dataSlice, \"amr\"));\n            return position;\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}