{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idIndex < 0) { // Should not happen with spec-compliant messages\n            return null;\n        }\n        String id = buf.readSlice(idIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter (after ID)\n\n        String index = null;\n        // The following block parses an optional index.\n        // 'starBeforeLengthIndex' is the '*' that should precede the 4-byte length field.\n        int starBeforeLengthIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (starBeforeLengthIndex != -1 && starBeforeLengthIndex + 5 < buf.writerIndex()\n                && buf.getByte(starBeforeLengthIndex + 5) == '*' // Check for '*' after the 4-hex-digit length\n                && buf.toString(starBeforeLengthIndex + 1, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n            // If the structure *LLLL* (Length) is confirmed after starBeforeLengthIndex,\n            // then the part from current readerIndex to starBeforeLengthIndex is the index.\n            int indexLength = starBeforeLengthIndex - buf.readerIndex();\n            if (indexLength >= 0) { // Allow empty index if hasIndex is true\n                 hasIndex = true; // Mark that index field is structurally present\n                 if (indexLength > 0) {\n                     index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n                 }\n            }\n            buf.skipBytes(1); // Skip the '*' at starBeforeLengthIndex\n        }\n        // If the condition above was false, no index is parsed; readerIndex remains at the start of the length field (or its preceding '*').\n        // The original code structure implies that if the above \"if\" is false, the '*' found by starBeforeLengthIndex\n        // was not the one before a valid length field, or no '*' was found.\n        // It assumes subsequent skips will align correctly.\n\n        buf.skipBytes(4); // length\n        buf.skipBytes(1); // '*' delimiter (after length)\n\n        buf.writerIndex(buf.writerIndex() - 1); // ']' ignore ending\n\n        // 'contentIndex' here refers to the comma before the message type (e.g. \"UD,\" \"LK,\").\n        int contentIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (contentIndex < 0) { // If no comma, type is the whole remaining part.\n            contentIndex = buf.writerIndex();\n        }\n\n        String type = buf.readSlice(contentIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        if (contentIndex < buf.writerIndex()) { // If there was a comma, advance reader past it.\n            buf.readerIndex(contentIndex + 1);\n        }\n\n        if (type.equals(\"INIT\")) {\n            if (channel != null) {\n                sendResponse(channel, id, index, \"INIT,1\");\n            }\n        } else if (type.equals(\"LK\")) {\n            if (channel != null) {\n                sendResponse(channel, id, index, \"LK\");\n            }\n            if (buf.isReadable()) {\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                    return position;\n                }\n            }\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n            Position position = decodePosition(deviceSession, buf.toString(StandardCharsets.US_ASCII));\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL); // Note: This might override specific alarm from decodePosition\n                    if (channel != null) {\n                        sendResponse(channel, id, index, \"AL\");\n                    }\n                }\n            }\n            return position;\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n            if (channel != null) {\n                sendResponse(channel, id, index, type);\n            }\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")\n                || type.equalsIgnoreCase(\"TEMP\")) { // Added TEMP\n\n            if (buf.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, new Date()); // Using current time for these health metrics\n\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    if (values.length > valueIndex && Integer.parseInt(values[valueIndex++]) > 0) {\n                        if (values.length > valueIndex) { // Check if temperature value exists\n                            position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    }\n                } else if (type.equalsIgnoreCase(\"TEMP\")) { // Handle TEMP specific format\n                    if (values.length > valueIndex) { // Check if temperature value exists\n                        position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                    }\n                } else { // PULSE, HEART, BLOOD, BPHRT\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        }\n                    }\n                    if (values.length > valueIndex) { // Check if heart rate value exists\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n                return position;\n            }\n        } else if (type.equals(\"img\")) {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n            int timeIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n            if (timeIndex > -1 && timeIndex + 12 + 2 <= buf.writerIndex()) { // check bounds\n                buf.readerIndex(timeIndex + 12 + 2);\n                position.set(Position.KEY_IMAGE, writeMediaFile(id, buf, \"jpg\"));\n            }\n            return position;\n        } else if (type.equals(\"JXTK\")) {\n            int commaAfterTotalIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), (byte) ',', 4);\n            if (commaAfterTotalIndex == -1) {\n                return null; // Malformed: not enough commas for JXTK header\n            }\n            \n            // Length of \"val1,val2,current,total\" part\n            int headerLength = commaAfterTotalIndex - buf.readerIndex();\n            if (headerLength < 0) return null; // Should not happen if commaAfterTotalIndex is valid\n\n            String headerString = buf.readCharSequence(headerLength, StandardCharsets.US_ASCII).toString();\n            buf.skipBytes(1); // Skip the 4th comma\n\n            String[] values = headerString.split(\",\");\n            if (values.length < 4) { // Expect at least 4 parts from split\n                return null; // Malformed\n            }\n\n            int current = Integer.parseInt(values[2]);\n            int total = Integer.parseInt(values[3]);\n\n            if (audio == null) {\n                audio = Unpooled.buffer();\n            }\n            audio.writeBytes(buf); // Write remaining part of buf (audio data)\n\n            if (channel != null) {\n                sendResponse(channel, id, index, \"JXTKR,1\");\n            }\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                if (audio != null) { // Check audio is not null before release\n                    audio.release();\n                    audio = null;\n                }\n                return position;\n            }\n        } else if (type.equals(\"TK\")) {\n            if (buf.readableBytes() == 1) { // Original check\n                return null;\n            }\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, buf, \"amr\"));\n            return position;\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}