{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        String id = buf.readSlice(idIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter\n\n        String index = null;\n        int contentIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        // Check if index part exists (4 hex digits followed by '*')\n        // Ensure contentIndex is valid and there are enough bytes for the 4-digit index plus the next delimiter '*'\n        if (contentIndex != -1 && contentIndex + 5 < buf.writerIndex()\n                && buf.getByte(contentIndex + 5) == '*'\n                && buf.toString(contentIndex + 1, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n            int indexLength = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*') - buf.readerIndex();\n            index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n            buf.skipBytes(1); // '*' delimiter\n        }\n\n        buf.skipBytes(4); // length\n        buf.skipBytes(1); // '*' delimiter\n\n        buf.writerIndex(buf.writerIndex() - 1); // ']' ignore ending\n\n        contentIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (contentIndex < 0) {\n            contentIndex = buf.writerIndex();\n        }\n\n        String type = buf.readSlice(contentIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        if (contentIndex < buf.writerIndex()) {\n            buf.readerIndex(contentIndex + 1);\n        }\n\n        if (type.equals(\"INIT\")) {\n\n            sendResponse(channel, id, index, \"INIT,1\");\n\n        } else if (type.equals(\"LK\")) {\n\n            sendResponse(channel, id, index, \"LK\");\n\n            if (buf.isReadable()) {\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                // Original logic: values.length >= 3 check ensures values[0] and values[2] are available.\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n\n                    getLastLocation(position, null);\n\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n\n                    return position;\n                }\n            }\n\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n\n            Position position = decodePosition(deviceSession, buf.toString(StandardCharsets.US_ASCII));\n\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n                sendResponse(channel, id, index, \"AL\");\n            }\n\n            return position;\n\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n\n            sendResponse(channel, id, index, type);\n\n        } else if (type.equalsIgnoreCase(\"TEMP\")) { // NEW BLOCK TO HANDLE TEMP TYPE\n\n            if (buf.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, new Date());\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length > 0) { // Ensure there is at least one value for temperature\n                    position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[0]));\n                }\n                return position;\n            }\n\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n\n            if (buf.isReadable()) {\n\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                getLastLocation(position, new Date());\n\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    // btemp2,1,35.29 -> values={\"1\", \"35.29\"}\n                    if (values.length > valueIndex) { // Check if values[0] (status) exists\n                        if (Integer.parseInt(values[valueIndex++]) > 0) {\n                            if (values.length > valueIndex) { // Check if values[1] (temperature) exists\n                                position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                            }\n                        }\n                    }\n                } else { // PULSE, HEART, BLOOD, BPHRT\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        // BPHRT,120,79 -> values={\"120\", \"79\"}\n                        if (values.length > valueIndex + 1) { // Ensure values[0] and values[1] for pressure\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        } else if (values.length > valueIndex) { // Fallback if only pressureHigh is provided\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                    }\n                    // HEART,71 -> values={\"71\"}\n                    if (valueIndex < values.length) { // Ensure value for heart rate exists\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n\n                return position;\n\n            }\n\n        } else if (type.equals(\"img\")) {\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            int timeIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n            // timeIndex points to the comma, +1 for start of next field (timestamp)\n            // +12 for timestamp length, +2 for CRC or other fixed bytes\n            if (timeIndex != -1 && timeIndex + 1 + 12 + 2 <= buf.writerIndex()) {\n                buf.readerIndex(timeIndex + 1 + 12 + 2);\n            } else {\n                // If the expected format for 'img' data header isn't found,\n                // it's safer to return null rather than proceeding with incorrect readerIndex\n                return null;\n            }\n            position.set(Position.KEY_IMAGE, writeMediaFile(id, buf, \"jpg\"));\n\n            return position;\n\n        } else if (type.equals(\"JXTK\")) {\n\n            // Find the 4th comma to delineate the audio data section.\n            // Example: JXTK,0,watch_7_20220526093954,1,6,#AMR...\n            // current, filename, total, data\n            int dataIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), (byte) ',', 4);\n            if (dataIndex == -1) { // If 4th comma not found, message is malformed\n                return null;\n            }\n\n            // Read the \"current,filename,total\" part before the 4th comma.\n            String[] values = buf.readCharSequence(\n                    dataIndex - buf.readerIndex(), StandardCharsets.US_ASCII).toString().split(\",\");\n            buf.readerIndex(dataIndex + 1); // Move readerIndex past the 4th comma to the actual audio data\n\n            if (values.length < 4) { // Ensure we have current and total fields in the parsed values\n                return null; // Malformed JXTK header\n            }\n            int current = Integer.parseInt(values[2]);\n            int total = Integer.parseInt(values[3]);\n\n            if (audio == null) {\n                audio = Unpooled.buffer();\n            }\n            audio.writeBytes(buf); // This correctly appends the remaining audio data from 'buf'\n\n            sendResponse(channel, id, index, \"JXTKR,1\");\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                audio.release();\n                audio = null;\n                return position;\n            }\n\n        } else if (type.equals(\"TK\")) {\n\n            if (buf.readableBytes() == 1) { // Special case for a TK message with only one byte (e.g., just a null byte)\n                return null;\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, buf, \"amr\"));\n\n            return position;\n\n        }\n\n        return null;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}