{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        // Assume idIndex is valid based on tests for now\n        String id = buf.readSlice(idIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter\n\n        String index = null;\n        // Use local variable for index detection start point\n        int indexParseStart = buf.readerIndex();\n        int contentIndex = buf.indexOf(indexParseStart, buf.writerIndex(), (byte) '*');\n        // Optional index check logic\n        // Check for *XXXX* pattern where XXXX is hex\n        if (contentIndex > indexParseStart) { // Found the first '*' after id delimiter\n            int nextDelimiter = buf.indexOf(contentIndex + 1, buf.writerIndex(), (byte) '*');\n            if (nextDelimiter == contentIndex + 5 // Check if next '*' is exactly 5 bytes away\n                    && buf.toString(contentIndex + 1, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n                index = buf.readSlice(contentIndex - indexParseStart).toString(StandardCharsets.US_ASCII);\n                buf.skipBytes(1); // '*' delimiter after index\n            }\n            // If pattern doesn't match, assume no index, reader index is automatically correct\n        }\n\n\n        buf.skipBytes(4); // length\n        buf.skipBytes(1); // '*' delimiter\n\n        // Store original writer index before modifying it\n        int originalWriterIndex = buf.writerIndex();\n        // Modify writerIndex to ignore trailing ']' during type/payload parsing\n        buf.writerIndex(originalWriterIndex - 1);\n\n        contentIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (contentIndex < 0) {\n            contentIndex = buf.writerIndex(); // No comma, type is till the end (before ']')\n        }\n\n        String type = buf.readSlice(contentIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        // Advance reader index past type and comma (if exists)\n        if (contentIndex < buf.writerIndex()) {\n            buf.readerIndex(contentIndex + 1);\n        } else {\n            buf.readerIndex(contentIndex); // If no comma, reader is already at the end (before ']')\n        }\n\n        // Slice the payload part (from current reader index to the adjusted writer index)\n        ByteBuf payloadBuf = buf.slice(buf.readerIndex(), buf.writerIndex() - buf.readerIndex());\n\n        // Restore original writer index now that parsing that depends on the adjusted index is done\n        buf.writerIndex(originalWriterIndex);\n        // Advance reader index of the original buffer past the payload slice\n        buf.readerIndex(buf.readerIndex() + payloadBuf.readableBytes());\n\n\n        if (type.equals(\"INIT\")) {\n\n            sendResponse(channel, id, index, \"INIT,1\");\n\n        } else if (type.equals(\"LK\")) {\n\n            sendResponse(channel, id, index, \"LK\");\n\n            if (payloadBuf.isReadable()) {\n                String[] values = payloadBuf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    try { // Add try-catch for robustness\n                        Position position = new Position(getProtocolName());\n                        position.setDeviceId(deviceSession.getDeviceId());\n                        getLastLocation(position, null);\n                        position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                        position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                        return position;\n                    } catch (NumberFormatException | NullPointerException e) {\n                        // Log or ignore parse errors\n                    }\n                }\n            }\n\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n\n            Position position = decodePosition(deviceSession, payloadBuf.toString(StandardCharsets.US_ASCII));\n\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    // Ensure alarm key is set if decodePosition didn't set one\n                    if (!position.hasAttribute(Position.KEY_ALARM)) {\n                        position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                    }\n                }\n                sendResponse(channel, id, index, \"AL\");\n            }\n\n            return position;\n\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n\n            sendResponse(channel, id, index, type);\n\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n\n            if (payloadBuf.isReadable()) {\n               try { // Add try-catch\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, new Date());\n\n                    String[] values = payloadBuf.toString(StandardCharsets.US_ASCII).split(\",\");\n                    int valueIndex = 0;\n\n                    if (type.equalsIgnoreCase(\"btemp2\")) {\n                        if (values.length > valueIndex && Integer.parseInt(values[valueIndex++]) > 0) {\n                             if (values.length > valueIndex) { // Check temp value exists\n                                position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                             }\n                        }\n                    } else {\n                        if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                            if (values.length > valueIndex) { // Check high pressure exists\n                               position.set(\"pressureHigh\", values[valueIndex++]);\n                            }\n                            if (values.length > valueIndex) { // Check low pressure exists\n                               position.set(\"pressureLow\", values[valueIndex++]);\n                            }\n                        }\n                        if (values.length > valueIndex && !values[valueIndex].isEmpty()) { // Check heart rate exists and is not empty\n                            position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                        }\n                    }\n                    // Only return if health data was found\n                    if (position.getAttributes().size() > 1) { // deviceId is always present\n                        return position;\n                    }\n               } catch (Exception e) { /* Log or ignore */ }\n            }\n\n        } else if (type.equals(\"img\")) {\n\n            int timeIndex = payloadBuf.indexOf(payloadBuf.readerIndex(), payloadBuf.writerIndex(), (byte) ',');\n            // Expected format: YYMMDD,HHMMSS,<image-data>\n            if (timeIndex >= 0 && payloadBuf.readableBytes() >= timeIndex + 14) { // 1 (,) + 6 (date) + 1 (,) + 6 (time) = 14\n                payloadBuf.readerIndex(payloadBuf.readerIndex() + timeIndex + 14); // Skip time part and delimiters\n                if (payloadBuf.isReadable()) {\n                     Position position = new Position(getProtocolName());\n                     position.setDeviceId(deviceSession.getDeviceId());\n                     getLastLocation(position, null);\n                     // Pass the rest of the payload slice as image data\n                     position.set(Position.KEY_IMAGE, writeMediaFile(id, payloadBuf.readSlice(payloadBuf.readableBytes()), \"jpg\"));\n                     return position;\n                }\n            }\n            // If format invalid or no image data, return null at the end\n\n        } else if (type.equals(\"JXTK\")) {\n\n            // Find 4th comma within the payloadBuf slice\n            int dataIndex = BufferUtil.indexOf(payloadBuf, payloadBuf.readerIndex(), payloadBuf.writerIndex(), (byte) ',', 4);\n            if (dataIndex < 0) {\n                 return null; // Invalid format\n            }\n\n            // Read header part from payloadBuf up to the 4th comma\n            String headerPart = payloadBuf.readCharSequence(dataIndex - payloadBuf.readerIndex(), StandardCharsets.US_ASCII).toString();\n            String[] values = headerPart.split(\",\");\n            payloadBuf.skipBytes(1); // Skip the 4th comma itself to get to audio data\n\n            if (values.length < 5) {\n                 return null; // Invalid format: expected at least 5 parts\n            }\n\n            try {\n                // *** THE FIX: Use correct indices for current/total chunk numbers ***\n                int current = Integer.parseInt(values[3]); // Current chunk number is at index 3\n                int total = Integer.parseInt(values[4]);   // Total chunks number is at index 4\n\n                if (audio == null) {\n                    audio = Unpooled.buffer();\n                }\n                // Append remaining data from payloadBuf (the actual audio chunk)\n                audio.writeBytes(payloadBuf);\n\n                sendResponse(channel, id, index, \"JXTKR,1\");\n\n                if (current < total) {\n                    return null; // Not the last chunk\n                } else {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                    if (audio != null) { // Check audio not null before release\n                        audio.release();\n                        audio = null;\n                    }\n                    return position;\n                }\n            } catch (NumberFormatException e) {\n                 // Log error: Failed to parse chunk numbers\n                 if (audio != null) { // Clean up buffer on error\n                     audio.release();\n                     audio = null;\n                 }\n                 return null;\n            }\n\n        } else if (type.equals(\"TK\")) {\n\n             // Original code checked readableBytes == 1, which seemed arbitrary.\n             // Treat any non-empty payload as audio data.\n            if (payloadBuf.readableBytes() > 0) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                // Pass the entire payload slice as audio data\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, payloadBuf.readSlice(payloadBuf.readableBytes()), \"amr\"));\n                return position;\n            } else {\n                 return null; // Return null if payload is empty\n            }\n\n        }\n\n        return null; // Default return if type not handled or no position generated\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}