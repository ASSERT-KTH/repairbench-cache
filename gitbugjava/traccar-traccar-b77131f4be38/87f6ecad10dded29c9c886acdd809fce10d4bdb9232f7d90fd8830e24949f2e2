{
    "generation": "    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idIndex == -1) {\n            return null; // Malformed: No '*' after manufacturer\n        }\n        String id = buf.readSlice(idIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter (after ID)\n\n        String pkIndex = null; // Renamed for clarity (Packet Index)\n        int starAfterFirstField = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        \n        if (starAfterFirstField == -1) {\n            return null; // Malformed: No '*' after ID field complex (PKINDEX or LEN)\n        }\n\n        // Check if PKINDEX is present. Structure: PKINDEX * LEN * CONTENT\n        // starAfterFirstField is '*' after PKINDEX.\n        // So, (starAfterFirstField + 1) is start of LEN (4 hex digits).\n        // (starAfterFirstField + 5) is '*' after LEN.\n        if (starAfterFirstField + 5 < buf.writerIndex() &&\n            buf.getByte(starAfterFirstField + 5) == '*' &&\n            buf.slice(starAfterFirstField + 1, 4).toString(StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}{4}\")) {\n            \n            int pkIndexLength = starAfterFirstField - buf.readerIndex();\n            hasIndex = true;\n            pkIndex = buf.readSlice(pkIndexLength).toString(StandardCharsets.US_ASCII);\n            buf.skipBytes(1); // Skip '*' after PKINDEX\n        }\n        // If PKINDEX wasn't parsed, readerIndex is still at start of LEN.\n        // If PKINDEX was parsed, readerIndex is now at start of LEN.\n\n        buf.skipBytes(4); // Skip LEN field (4 chars)\n        buf.skipBytes(1); // Skip '*' delimiter (after LEN)\n\n        // Preserve writerIndex before modification, if necessary for 'buf' lifecycle.\n        // For this method, modifying writerIndex to ignore ']' is usually fine if 'buf' is message-specific.\n        int originalWriterIndex = buf.writerIndex();\n        buf.writerIndex(originalWriterIndex - 1); // ']' ignore ending bracket\n\n        int typeSeparatorIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (typeSeparatorIndex < 0) { // No comma, type is the whole remaining content until ']'\n            typeSeparatorIndex = buf.writerIndex();\n        }\n\n        String type = buf.readSlice(typeSeparatorIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        if (typeSeparatorIndex < buf.writerIndex()) { // If there was a comma and data exists after it\n            buf.readerIndex(typeSeparatorIndex + 1); // Move readerIndex past comma\n        }\n        // At this point, buf.readerIndex() is at the start of payload data after type and its comma.\n        // buf.writerIndex() is still (originalWriterIndex - 1).\n\n        if (type.equals(\"INIT\")) {\n            sendResponse(channel, id, pkIndex, \"INIT,1\");\n        } else if (type.equals(\"LK\")) {\n            sendResponse(channel, id, pkIndex, \"LK\");\n            if (buf.isReadable()) {\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, null);\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                    return position;\n                }\n            }\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n            Position position = decodePosition(deviceSession, buf.toString(StandardCharsets.US_ASCII));\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n                sendResponse(channel, id, pkIndex, \"AL\");\n            }\n            return position;\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n            sendResponse(channel, id, pkIndex, type);\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n            if (buf.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, new Date());\n                String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    if (values.length > valueIndex && Integer.parseInt(values[valueIndex++]) > 0) {\n                        if (values.length > valueIndex) { // Check has next value\n                           position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    }\n                } else {\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        }\n                    }\n                    if (values.length > valueIndex) { // Check if heart rate value exists\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n                return position;\n            }\n        } else if (type.equals(\"img\")) {\n            // Payload format: YYYYMMDDHHMMSS,<IMAGE_DATA>\n            // readerIndex is at start of YYYYMMDDHHMMSS\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n\n            // Find comma after timestamp\n            int commaAfterTimestamp = buf.indexOf(buf.readerIndex() + 12, buf.writerIndex(), (byte) ',');\n            if (commaAfterTimestamp != buf.readerIndex() + 12) { // Comma should be immediately after 12 char timestamp\n                 return null; // Malformed: timestamp not 12 chars or no comma after it\n            }\n            \n            buf.readerIndex(buf.readerIndex() + 12 + 1); // Skip YYYYMMDDHHMMSS (12) and comma (1)\n            position.set(Position.KEY_IMAGE, writeMediaFile(id, buf, \"jpg\"));\n            return position;\n        } else if (type.equals(\"JXTK\")) {\n            // Payload format: P1,P2,CURR,TOTAL,AUDIODATA (readerIndex is at start of P1)\n            // Need to find 4th comma from current readerIndex (comma after TOTAL)\n            int endHeaderIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), (byte) ',', 4);\n            if (endHeaderIndex == -1) {\n                return null; // Malformed JXTK header (not enough fields)\n            }\n            String headerPart = buf.readCharSequence(endHeaderIndex - buf.readerIndex(), StandardCharsets.US_ASCII).toString();\n            String[] values = headerPart.split(\",\"); // values will be [P1, P2, CURR, TOTAL]\n\n            // buf.readerIndex is now at the 4th comma (after TOTAL). Skip it.\n            buf.skipBytes(1); // Position reader at start of AUDIODATA\n\n            if (values.length < 4) { // Should be 4 parts: P1, P2, CURR, TOTAL\n                 return null; // Malformed if split resulted in fewer parts\n            }\n            int current = Integer.parseInt(values[2]); // CURR is values[2]\n            int total = Integer.parseInt(values[3]);   // TOTAL is values[3]\n\n            if (audio == null) {\n                // Estimate initial capacity; JXTK audio data can be large.\n                // Smallest AMR frame is 13 bytes. Max JXTK payload seems ~1KB from hex.\n                // Default Unpooled.buffer() capacity might be too small, leading to reallocations.\n                audio = Unpooled.buffer(2048 * total); // Rough estimate based on potential total size\n            }\n            audio.writeBytes(buf); // buf now contains only current AUDIODATA chunk\n\n            sendResponse(channel, id, pkIndex, \"JXTKR,1\");\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                audio.release();\n                audio = null;\n                return position;\n            }\n        } else if (type.equals(\"TK\")) {\n            // Common empty/ack payload for TK might be just \"0\"\n            if (buf.readableBytes() == 1 && buf.getByte(buf.readerIndex()) == (byte) '0') {\n                return null;\n            }\n            if (!buf.isReadable()) { // No actual audio data\n                return null;\n            }\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, buf, \"amr\"));\n            return position;\n        }\n\n        // Restore writerIndex if it was essential for 'buf' lifecycle outside this decode call.\n        // buf.writerIndex(originalWriterIndex); // Generally not needed if 'buf' is consumed or sliced by Netty framework.\n\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}