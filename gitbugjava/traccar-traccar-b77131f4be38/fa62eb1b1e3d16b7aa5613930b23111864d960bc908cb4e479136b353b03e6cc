{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport org.traccar.session.DeviceSession;\nimport org.traccar.model.Position;\nimport org.traccar.helper.BufferUtil;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\n\n// Assume necessary base class, helper methods (getDeviceSession, getProtocolName, sendResponse,\n// decodePosition, getLastLocation, writeMediaFile) and member variable 'audio' are defined elsewhere.\n\n    private ByteBuf audio; // Declare member variable if not present in the actual class\n\n    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n        if (buf.readableBytes() < 10) { // Minimal length check (e.g., [AA*I*L*T])\n             return null;\n        }\n\n        // Remember starting reader index in case we need to roll back due to insufficient data\n        int initialReaderIndex = buf.readerIndex();\n\n        if (buf.getByte(buf.readerIndex()) != '[') {\n             // Not starting with expected header\n             return null;\n        }\n        buf.skipBytes(1); // '[' header\n\n        // Manufacturer (2 bytes ASCII)\n        if (buf.readableBytes() < 2 + 1) { // Need manufacturer + delimiter\n             buf.readerIndex(initialReaderIndex); // Roll back\n             return null;\n        }\n        String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        if (buf.readByte() != '*') { // Read and check '*' delimiter\n             buf.readerIndex(initialReaderIndex); // Roll back\n             return null;\n        }\n\n        // ID (until next '*')\n        int idEndIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idEndIndex < 0) { // No delimiter found\n             buf.readerIndex(initialReaderIndex); // Roll back\n             return null;\n        }\n        String id = buf.readSlice(idEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        buf.readerIndex(idEndIndex + 1); // Position after ID and '*' delimiter\n\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            // Cannot process without session. Returning null might leave unconsumed data if length isn't parsed.\n            // Ideally, we'd parse length and skip, but we'll stick to original behavior for now.\n            return null;\n        }\n\n        // Now parse optional Index and mandatory Length\n        // Format: *INDEX*LENGTH* or *LENGTH*\n        int headerStartIndex = buf.readerIndex(); // Start of index/length part\n        int firstStarPos = headerStartIndex;\n        int secondStarPos = buf.indexOf(firstStarPos, buf.writerIndex(), (byte) '*');\n        if (secondStarPos < 0) { // Need at least one more '*' for length\n             buf.readerIndex(initialReaderIndex); // Roll back\n             return null;\n        }\n\n        String index = null;\n        int length = -1;\n\n        // Check for optional index by looking ahead for the next '*'\n        int thirdStarPos = buf.indexOf(secondStarPos + 1, buf.writerIndex(), (byte) '*');\n        if (thirdStarPos > 0) {\n            // Potential index between firstStarPos and secondStarPos\n            // Potential length between secondStarPos + 1 and thirdStarPos (length is 4 hex digits)\n            int potentialLengthFieldLen = thirdStarPos - (secondStarPos + 1);\n            if (potentialLengthFieldLen == 4) {\n                String potentialLengthHex = buf.toString(secondStarPos + 1, 4, StandardCharsets.US_ASCII);\n                if (potentialLengthHex.matches(\"\\\\p{XDigit}{4}\")) {\n                    // Found format *INDEX*LENGTH*\n                    index = buf.toString(firstStarPos, secondStarPos - firstStarPos, StandardCharsets.US_ASCII);\n                    buf.readerIndex(thirdStarPos + 1); // Position reader after '*' following length\n                    length = Integer.parseInt(potentialLengthHex, 16);\n                }\n            }\n        }\n\n        // If format wasn't *INDEX*LENGTH*, check for *LENGTH* format\n        if (length == -1) {\n            int potentialLengthFieldLen = secondStarPos - firstStarPos;\n            if (potentialLengthFieldLen == 4) {\n                 String potentialLengthHex = buf.toString(firstStarPos, 4, StandardCharsets.US_ASCII);\n                 if (potentialLengthHex.matches(\"\\\\p{XDigit}{4}\")) {\n                      // Found format *LENGTH*\n                      length = Integer.parseInt(potentialLengthHex, 16);\n                      index = null;\n                      buf.readerIndex(secondStarPos + 1); // Position reader after '*' following length\n                 }\n            }\n        }\n\n        if (length == -1) {\n             // Failed to parse length/structure\n             buf.readerIndex(initialReaderIndex); // Roll back\n             return null;\n        }\n\n        // Payload parsing begins. We know the total expected payload length is 'length'.\n        int payloadStartIndex = buf.readerIndex();\n        int expectedEndIndex = payloadStartIndex + length;\n\n        // Check if the buffer actually contains enough data for the declared payload length\n        if (buf.writerIndex() < expectedEndIndex) {\n             // Not enough data received yet for the full payload.\n             buf.readerIndex(initialReaderIndex); // Roll back reader index to before this message attempt\n             return null; // Expecting more data\n        }\n\n        // Check for trailing ']' at the expected end of the message\n        boolean trailingBracketFound = (buf.writerIndex() > expectedEndIndex && buf.getByte(expectedEndIndex) == ']');\n\n\n        // Find type (until comma or end of payload)\n        int typeEndIndex = buf.indexOf(payloadStartIndex, expectedEndIndex, (byte) ',');\n        int typeActualEndIndex;\n        boolean commaFound;\n        if (typeEndIndex > 0 && typeEndIndex < expectedEndIndex) { // Check bounds: must be > payloadStart and < expectedEnd\n            typeActualEndIndex = typeEndIndex;\n            commaFound = true;\n        } else {\n            // No comma within payload, type is the whole payload up to expectedEndIndex.\n            typeActualEndIndex = expectedEndIndex;\n            commaFound = false;\n        }\n\n        // Slice the type without advancing reader index yet, in case of errors\n        String type = buf.toString(payloadStartIndex, typeActualEndIndex - payloadStartIndex, StandardCharsets.US_ASCII);\n\n        // Calculate data start index and length based on type parsing\n        int dataStartIndex;\n        if (commaFound) {\n            dataStartIndex = typeActualEndIndex + 1; // After comma\n        } else {\n            dataStartIndex = typeActualEndIndex; // Immediately after type (no comma)\n        }\n        // Ensure dataLength is not negative if expectedEndIndex == dataStartIndex\n        int dataLength = Math.max(0, expectedEndIndex - dataStartIndex);\n\n        Object result = null; // Store result position/null\n\n        // Use try-catch for parsing potentially invalid data within payload\n        try {\n            // Process message types based on parsed 'type' and data boundaries\n            if (type.equals(\"INIT\")) {\n                sendResponse(channel, id, index, \"INIT,1\"); // Assumes sendResponse handles null index\n            } else if (type.equals(\"LK\")) {\n                sendResponse(channel, id, index, \"LK\"); // Assumes sendResponse handles null index\n                if (dataLength > 0) {\n                    String data = buf.toString(dataStartIndex, dataLength, StandardCharsets.US_ASCII);\n                    String[] values = data.split(\",\");\n                    if (values.length >= 3) {\n                        Position position = new Position(getProtocolName());\n                        position.setDeviceId(deviceSession.getDeviceId());\n                        getLastLocation(position, null);\n                        position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                        position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                        result = position;\n                    }\n                }\n            } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n                String data = buf.toString(dataStartIndex, dataLength, StandardCharsets.US_ASCII);\n                Position position = decodePosition(deviceSession, data); // decodePosition needs the data part only\n                if (position != null) {\n                     if (type.startsWith(\"AL\")) {\n                         // Set alarm based on original logic.\n                         position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                         sendResponse(channel, id, index, \"AL\");\n                     }\n                     result = position;\n                } else if (type.startsWith(\"AL\")) {\n                     // Send response even if position decoding failed (matches original behavior)\n                     sendResponse(channel, id, index, \"AL\");\n                }\n            } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n                sendResponse(channel, id, index, type);\n            } else if (type.equalsIgnoreCase(\"PULSE\")\n                    || type.equalsIgnoreCase(\"HEART\")\n                    || type.equalsIgnoreCase(\"BLOOD\")\n                    || type.equalsIgnoreCase(\"BPHRT\")\n                    || type.equalsIgnoreCase(\"btemp2\")) {\n                if (dataLength > 0) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    getLastLocation(position, new Date()); // Using current time\n\n                    String data = buf.toString(dataStartIndex, dataLength, StandardCharsets.US_ASCII);\n                    String[] values = data.split(\",\");\n                    int valueIndex = 0;\n\n                    if (type.equalsIgnoreCase(\"btemp2\")) {\n                        // Format seems to be: count,value (e.g., \"1,35.29\")\n                        if (values.length > valueIndex + 1 && Integer.parseInt(values[valueIndex++]) > 0) {\n                            position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    } else {\n                        if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                            if (values.length > valueIndex) position.set(\"pressureHigh\", values[valueIndex++]);\n                            if (values.length > valueIndex) position.set(\"pressureLow\", values[valueIndex++]);\n                        }\n                        if (values.length > valueIndex) {\n                            String heartRateStr = values[valueIndex].trim();\n                            if (!heartRateStr.isEmpty()) {\n                                position.set(Position.KEY_HEART_RATE, Integer.parseInt(heartRateStr));\n                            }\n                        }\n                    }\n                    result = position; // Return position even if only base data is set\n                }\n            } else if (type.equals(\"img\")) {\n                 if (dataLength > 0) {\n                     Position position = new Position(getProtocolName());\n                     position.setDeviceId(deviceSession.getDeviceId());\n                     getLastLocation(position, null);\n                     // Find comma within the data part\n                     int imgCommaIndex = BufferUtil.indexOf(buf, dataStartIndex, expectedEndIndex, (byte) ',');\n                     if (imgCommaIndex >= dataStartIndex) { // Check comma is within data segment\n                          int imgPayloadStartIndex = imgCommaIndex + 14; // Skip time etc. based on original code's magic number\n                          if (imgPayloadStartIndex < expectedEndIndex) {\n                               int imgPayloadLength = expectedEndIndex - imgPayloadStartIndex;\n                               if (imgPayloadLength > 0) {\n                                    // Slice only the image bytes - slice creates a view, no copy\n                                    ByteBuf imgData = buf.slice(imgPayloadStartIndex, imgPayloadLength);\n                                    position.set(Position.KEY_IMAGE, writeMediaFile(id, imgData, \"jpg\"));\n                                    result = position;\n                               }\n                          }\n                     }\n                 }\n            } else if (type.equals(\"JXTK\")) {\n                // Find 4th comma within data part to separate metadata and audio\n                int metadataEndIndexInData = BufferUtil.indexOf(buf, dataStartIndex, expectedEndIndex, (byte) ',', 4);\n                if (metadataEndIndexInData >= dataStartIndex) { // Check 4th comma is within data segment\n                     int audioStartIndex = metadataEndIndexInData + 1; // Start of audio data relative to buffer start\n                     String metadataStr = buf.toString(dataStartIndex, metadataEndIndexInData - dataStartIndex, StandardCharsets.US_ASCII);\n                     String[] values = metadataStr.split(\",\");\n\n                     if (values.length >= 4) {\n                          int current = Integer.parseInt(values[2]);\n                          int total = Integer.parseInt(values[3]);\n\n                          if (this.audio == null) { // Use this.audio for member variable\n                              this.audio = Unpooled.buffer();\n                          }\n                          int audioChunkLength = expectedEndIndex - audioStartIndex;\n                          if (audioChunkLength > 0) {\n                              // Write the audio chunk from the main buffer to the accumulating audio buffer\n                              this.audio.writeBytes(buf, audioStartIndex, audioChunkLength);\n                          }\n\n                          sendResponse(channel, id, index, \"JXTKR,1\");\n\n                          if (current >= total) { // Check if this is the last part\n                              Position position = new Position(getProtocolName());\n                              position.setDeviceId(deviceSession.getDeviceId());\n                              getLastLocation(position, null);\n                              position.set(Position.KEY_AUDIO, writeMediaFile(id, this.audio, \"amr\"));\n                              if (this.audio != null) { // Release the accumulated buffer\n                                  this.audio.release();\n                              }\n                              this.audio = null; // Reset member variable\n                              result = position; // Return the position with audio link\n                          } // else: more parts expected, result remains null\n                     }\n                }\n            } else if (type.equals(\"TK\")) {\n                 if (dataLength > 0) { // Check if there is data\n                     Position position = new Position(getProtocolName());\n                     position.setDeviceId(deviceSession.getDeviceId());\n                     getLastLocation(position, null);\n                     // Slice only the audio bytes\n                     ByteBuf tkAudioData = buf.slice(dataStartIndex, dataLength);\n                     position.set(Position.KEY_AUDIO, writeMediaFile(id, tkAudioData, \"amr\"));\n                     result = position;\n                 }\n            }\n\n            // If processing was successful (no exception), advance reader index\n            buf.readerIndex(expectedEndIndex);\n\n            // Consume trailing ']' if it exists right after payload\n            if (trailingBracketFound) {\n                buf.skipBytes(1);\n            }\n\n        } catch (Exception e) {\n            // Log exception and return null, ensure reader index is advanced past corrupted/unparseable message\n            // Log.warn(\"WatchProtocolDecoder parsing error for type \" + type + \" for device \" + id, e); // Example logging\n            buf.readerIndex(expectedEndIndex); // Skip the message payload\n             if (trailingBracketFound) { // Also skip bracket if present\n                buf.skipBytes(1);\n            }\n             // Clean up partial JXTK state if error occurred during JXTK processing\n             if (type.equals(\"JXTK\") && this.audio != null) {\n                  this.audio.release();\n                  this.audio = null;\n             }\n             return null; // Indicate failure for this message\n        }\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}