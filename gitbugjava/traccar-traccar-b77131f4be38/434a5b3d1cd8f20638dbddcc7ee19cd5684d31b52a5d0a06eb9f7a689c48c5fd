{
    "generation": "@Override\nprotected Object decode(\n        Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n    ByteBuf buf = (ByteBuf) msg;\n\n    buf.skipBytes(1); // '[' header\n    String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n    buf.skipBytes(1); // '*' delimiter\n\n    int nextAsteriskIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n    if (nextAsteriskIndex < 0) {\n        return null;\n    }\n    String id = buf.readSlice(nextAsteriskIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n    DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n    if (deviceSession == null) {\n        return null;\n    }\n\n    buf.skipBytes(1); // '*' delimiter\n\n    String index = null;\n    boolean hasIndex = false;\n\n    // Save readerIndex for checking index presence\n    int indexFieldStart = buf.readerIndex();\n\n    int nextAsteriskIndex2 = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n    if (nextAsteriskIndex2 >= 0) {\n        // Check for possible index by content after asterisk (length = 4 = 0001, typically hex, then another asterisk)\n        int afterLen = nextAsteriskIndex2 + 5; // 4 for length, 1 for *\n        if (afterLen < buf.writerIndex()\n                && buf.getByte(nextAsteriskIndex2 + 5) == '*' // There is another '*' after 4 chars after index\n                && buf.toString(nextAsteriskIndex2 + 1, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n            // Index is present\n            index = buf.readSlice(nextAsteriskIndex2 - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n            buf.skipBytes(1); // '*' delimiter\n            hasIndex = true;\n        }\n    }\n\n    // Now at length field (always fixed 4 chars), followed by '*'\n    buf.skipBytes(4); // length\n    buf.skipBytes(1); // '*' delimiter\n\n    // Remove the trailing ']' for further processing, but only if present\n    int endBracket = buf.writerIndex() - 1;\n    if (buf.getByte(endBracket) == ']') {\n        buf.writerIndex(endBracket);\n    }\n\n    int commaIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n    int typeEndIndex = commaIndex >= 0 ? commaIndex : buf.writerIndex();\n    String type = buf.readSlice(typeEndIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n    if (commaIndex >= 0 && buf.readerIndex() < buf.writerIndex()) {\n        buf.readerIndex(commaIndex + 1);\n    }\n\n    // Remove any potential trailing \\r or \\n\n    int finalDataEnd = buf.writerIndex();\n    while (finalDataEnd > buf.readerIndex() && (\n            buf.getByte(finalDataEnd - 1) == '\\r' || buf.getByte(finalDataEnd - 1) == '\\n')) {\n        finalDataEnd--;\n    }\n    buf.writerIndex(finalDataEnd);\n\n    if (type.equals(\"INIT\")) {\n\n        sendResponse(channel, id, index, \"INIT,1\");\n\n    } else if (type.equals(\"LK\")) {\n\n        sendResponse(channel, id, index, \"LK\");\n\n        if (buf.isReadable()) {\n            String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n            if (values.length >= 3) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                getLastLocation(position, null);\n\n                position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2].trim()));\n                position.set(Position.KEY_STEPS, Integer.parseInt(values[0].trim()));\n\n                return position;\n            }\n        }\n\n    } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n\n        String contentString = buf.toString(StandardCharsets.US_ASCII);\n        Position position = decodePosition(deviceSession, contentString);\n\n        if (type.startsWith(\"AL\")) {\n            if (position != null) {\n                // Try to detect specific alarm type by defaulting to removing alarm if the alarm bit is set in content.\n                String upperContent = contentString.toUpperCase();\n                // Extract 17-th element (alarm flags) for removing alarm (common for watch)\n                // Find alarm field (commonly after 17 commas)\n                int alarmFlagIndex = 0;\n                int countCommas = 0;\n                for (int i = 0; i < contentString.length(); i++) {\n                    if (contentString.charAt(i) == ',') {\n                        countCommas++;\n                        if (countCommas == 17) {\n                            alarmFlagIndex = i + 1;\n                            break;\n                        }\n                    }\n                }\n                boolean alarmRemoving = false;\n                if (alarmFlagIndex > 0 && alarmFlagIndex < contentString.length()) {\n                    int end = contentString.indexOf(',', alarmFlagIndex);\n                    if (end == -1) end = contentString.length();\n                    String alarmFlag = contentString.substring(alarmFlagIndex, end);\n                    if (alarmFlag.length() >= 3 && alarmFlag.charAt(alarmFlag.length() - 3) == '1') {\n                        // Common logic: 3rd from end\n                        alarmRemoving = true;\n                    }\n                }\n                if (alarmRemoving) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_REMOVING);\n                } else {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n            }\n            sendResponse(channel, id, index, \"AL\");\n        }\n\n        return position;\n\n    } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n\n        sendResponse(channel, id, index, type);\n\n    } else if (type.equalsIgnoreCase(\"PULSE\")\n            || type.equalsIgnoreCase(\"HEART\")\n            || type.equalsIgnoreCase(\"BLOOD\")\n            || type.equalsIgnoreCase(\"BPHRT\")\n            || type.equalsIgnoreCase(\"btemp2\")\n            || type.equalsIgnoreCase(\"TEMP\")) {\n\n        if (buf.isReadable()) {\n            String[] values = buf.toString(StandardCharsets.US_ASCII).split(\",\");\n            int valueIndex = 0;\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, new Date());\n\n            if (type.equalsIgnoreCase(\"btemp2\") || type.equalsIgnoreCase(\"TEMP\")) {\n                // Covers both TEMP and btemp2\n                if (values.length > valueIndex + 1 && Double.parseDouble(values[valueIndex + 1].trim()) > 0) {\n                    position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex + 1].trim()));\n                }\n            } else if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                if (values.length > valueIndex) {\n                    position.set(\"pressureHigh\", values[valueIndex++].trim());\n                }\n                if (values.length > valueIndex) {\n                    position.set(\"pressureLow\", values[valueIndex++].trim());\n                }\n                // May be heart rate next\n                if (values.length > valueIndex && !values[valueIndex].trim().isEmpty()) {\n                    position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex].trim()));\n                }\n            } else {\n                // PULSE, HEART, etc., commonly just heart rate and maybe steps\n                if (values.length > valueIndex && !values[valueIndex].trim().isEmpty()) {\n                    position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex].trim()));\n                }\n                if (values.length > valueIndex + 1 && !values[valueIndex + 1].trim().isEmpty()) {\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[valueIndex + 1].trim()));\n                }\n            }\n\n            return position;\n        }\n\n    } else if (type.equals(\"img\")) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        getLastLocation(position, null);\n\n        // Move readerIndex to after ',<YYYYMMDDHHMM>,'\n        int timeIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ',');\n        if (timeIndex >= 0 && timeIndex + 12 + 2 <= buf.writerIndex()) {\n            buf.readerIndex(timeIndex + 12 + 2); // skip ',' + time(12) + ','\n        }\n        position.set(Position.KEY_IMAGE, writeMediaFile(id, buf, \"jpg\"));\n\n        return position;\n\n    } else if (type.equals(\"JXTK\")) {\n\n        // Find fourth comma (after 'JXTK,0,...')\n        int dataIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), (byte) ',', 4);\n        if (dataIndex < 0) {\n            return null;\n        }\n        dataIndex += 1;\n\n        String[] values = buf.readCharSequence(\n                dataIndex - buf.readerIndex(), StandardCharsets.US_ASCII).toString().split(\",\");\n\n        if (values.length <= 3) return null;\n        int current = Integer.parseInt(values[2]);\n        int total = Integer.parseInt(values[3]);\n\n        if (audio == null) {\n            audio = Unpooled.buffer();\n        }\n        buf.readerIndex(dataIndex); // Move readerIndex to data\n        audio.writeBytes(buf);\n\n        sendResponse(channel, id, index, \"JXTKR,1\");\n\n        if (current < total) {\n            return null;\n        } else {\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n            getLastLocation(position, null);\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n            audio.release();\n            audio = null;\n            return position;\n        }\n\n    } else if (type.equals(\"TK\")) {\n\n        if (buf.readableBytes() <= 1) {\n            return null;\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        getLastLocation(position, null);\n\n        position.set(Position.KEY_AUDIO, writeMediaFile(id, buf, \"amr\"));\n\n        return position;\n\n    }\n\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}