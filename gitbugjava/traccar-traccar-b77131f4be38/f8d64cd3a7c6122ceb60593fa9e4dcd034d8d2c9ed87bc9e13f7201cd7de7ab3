{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport org.traccar.BaseProtocolDecoder;\nimport org.traccar.session.DeviceSession;\nimport org.traccar.Protocol;\nimport org.traccar.helper.BufferUtil;\nimport org.traccar.model.Position;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\n\n// Assume the class includes necessary methods like getDeviceSession, sendResponse, getProtocolName,\n// decodePosition, getLastLocation, writeMediaFile and the member variable 'private ByteBuf audio;'\npublic abstract class FixedWatchProtocolDecoder extends BaseProtocolDecoder {\n\n    private ByteBuf audio; // State variable for JXTK audio assembly\n\n    // Constructor matching the original test setup hint\n    public FixedWatchProtocolDecoder(Protocol protocol) {\n        super(protocol);\n    }\n\n    // Abstract methods assumed to be implemented in concrete subclass\n    // protected abstract DeviceSession getDeviceSession(Channel channel, SocketAddress remoteAddress, String... uniqueIds);\n    // protected abstract void sendResponse(Channel channel, String id, String index, String command);\n    // protected abstract Position decodePosition(DeviceSession deviceSession, String data);\n    // protected abstract void getLastLocation(Position position, Date date);\n    // protected abstract String writeMediaFile(String uniqueId, ByteBuf buf, String extension);\n\n\n    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        // Basic sanity checks\n        if (buf.readableBytes() < 8) { // Minimal frame e.g. [ZJ*1*L*T]\n            return null;\n        }\n        // Check start and end markers without consuming bytes yet\n        if (buf.getByte(buf.readerIndex()) != '[' || buf.getByte(buf.writerIndex() - 1) != ']') {\n            return null; // Must start with '[' and end with ']'\n        }\n\n        buf.skipBytes(1); // Skip '[' header\n\n        // Manufacturer (2 bytes)\n        if (buf.readableBytes() < 2) return null;\n        String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n\n        // Delimiter after manufacturer\n        if (buf.readableBytes() < 1 || buf.readByte() != '*') {\n            return null; // Expecting '*'\n        }\n\n        // ID (variable length until next '*')\n        int idEndIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), \"*\");\n        if (idEndIndex < 0) {\n            return null; // No '*' after ID\n        }\n        String id = buf.toString(buf.readerIndex(), idEndIndex - buf.readerIndex(), StandardCharsets.US_ASCII);\n        if (id.isEmpty()) {\n             return null; // ID cannot be empty\n        }\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            // Log unknown device?\n            return null; // Unknown device session\n        }\n        buf.readerIndex(idEndIndex + 1); // Move reader past ID and '*'\n\n        // Parse optional Index and mandatory Length fields\n        String index = null;\n        boolean hasIndex = false; // Keep track if an index field was parsed\n\n        int firstDelimiterIndex = BufferUtil.indexOf(buf, buf.readerIndex(), buf.writerIndex(), \"*\");\n        if (firstDelimiterIndex < 0) {\n            return null; // Invalid format: No '*' found after ID field (must have at least length)\n        }\n\n        // Check for pattern \"XXXX*\" (representing the Length field) *after* the first segment\n        int lengthStartIndex = firstDelimiterIndex + 1;\n        int lengthEndIndex = lengthStartIndex + 4; // Potential end of 4-char length field\n\n        // Check if length field pattern exists and is followed by '*'\n        if (lengthEndIndex < buf.writerIndex() && buf.getByte(lengthEndIndex) == '*'\n                && buf.toString(lengthStartIndex, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n            // Found Length pattern after the first segment. This means the first segment is the Index.\n            int indexLength = firstDelimiterIndex - buf.readerIndex();\n            // Read the index (can be empty or non-empty based on protocol variations)\n            index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n            hasIndex = true; // Mark index as found\n            buf.skipBytes(1); // Skip '*' after index\n\n            // Skip the confirmed length field and its delimiter\n            buf.skipBytes(4); // Skip length field (XXXX)\n            buf.skipBytes(1); // Skip '*' after length field\n\n        } else {\n            // Length pattern not found after first segment. This means the first segment must *be* the length.\n            int lengthLength = firstDelimiterIndex - buf.readerIndex();\n            // Validate that this segment looks like a 4-digit hex length\n            if (lengthLength != 4 || !buf.toString(buf.readerIndex(), lengthLength, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n                 return null; // Invalid format: Segment after ID is not a valid 4-hex length field\n            }\n            // No index field present\n            hasIndex = false;\n            index = null;\n\n            // Skip the confirmed length field and its delimiter\n            buf.skipBytes(lengthLength); // Skip length field (XXXX)\n            buf.skipBytes(1); // Skip '*' after length field\n        }\n        // Reader index is now positioned at the start of the content type\n\n        // Define effective content end, ignoring the trailing ']'\n        int effectiveWriterIndex = buf.writerIndex() - 1;\n        if (effectiveWriterIndex < buf.readerIndex()) {\n             // This case should ideally not happen if initial checks pass and parsing is correct\n             return null; // No content after header fields\n        }\n\n        // Find the end of the type identifier (either at the first comma or the end of content)\n        int typeEndIndex = BufferUtil.indexOf(buf, buf.readerIndex(), effectiveWriterIndex, \",\");\n        if (typeEndIndex < 0) {\n            // No comma found, type identifier is the entire remaining content section\n            typeEndIndex = effectiveWriterIndex;\n        }\n\n        String type = buf.toString(buf.readerIndex(), typeEndIndex - buf.readerIndex(), StandardCharsets.US_ASCII);\n\n        // Move reader index past the type identifier\n        buf.readerIndex(typeEndIndex);\n        // If there was a comma separating type from payload, skip the comma as well\n        if (typeEndIndex < effectiveWriterIndex && buf.getByte(typeEndIndex) == ',') {\n            buf.skipBytes(1);\n        }\n\n        // Create a slice for the payload (from current reader index to the effective end)\n        // This avoids modifying the original buffer's writer index\n        ByteBuf payload = buf.slice(buf.readerIndex(), effectiveWriterIndex - buf.readerIndex());\n\n        // ***** Handle message based on type *****\n\n        if (type.equals(\"INIT\")) {\n            sendResponse(channel, id, index, \"INIT,1\"); // Acknowledge INIT\n        } else if (type.equals(\"LK\")) { // Keep-alive message\n            sendResponse(channel, id, index, \"LK\"); // Acknowledge LK\n            if (payload.isReadable()) {\n                String[] values = payload.toString(StandardCharsets.US_ASCII).split(\",\");\n                // LK payload often includes steps, battery etc.\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n                    // Get last known location but update with current time and LK data\n                    getLastLocation(position, new Date()); // Use current time for LK status update\n                    try { // Protect against parsing errors\n                        position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                        position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n                    } catch (NumberFormatException e) {\n                        // Log warning: Failed to parse LK data\n                    }\n                    return position; // Return position with updated status\n                }\n            }\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) { // Position/Alarm/Way Pts\n             // Decode the payload into a Position object using a helper method\n             Position position = decodePosition(deviceSession, payload.toString(StandardCharsets.US_ASCII));\n             if (position != null && type.startsWith(\"AL\")) {\n                 // Acknowledge Alarm messages\n                 // Assume decodePosition correctly sets Position.KEY_ALARM based on payload content\n                 sendResponse(channel, id, index, \"AL\");\n             }\n             return position; // Return the decoded position (or null if decoding failed)\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) { // Tracking request?\n            sendResponse(channel, id, index, type); // Acknowledge request\n        } else if (type.equalsIgnoreCase(\"PULSE\") // Health data messages\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n            if (payload.isReadable()) {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, new Date()); // Use current time for health data update\n                String[] values = payload.toString(StandardCharsets.US_ASCII).split(\",\");\n                int valueIndex = 0;\n                try { // Protect against parsing errors and array bounds\n                    if (values.length > valueIndex) {\n                        if (type.equalsIgnoreCase(\"btemp2\")) {\n                            // Format: btemp2,status,temperature\n                            if (Integer.parseInt(values[valueIndex++]) > 0 && values.length > valueIndex) {\n                                position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                            }\n                        } else {\n                            // Format: BPHRT/BLOOD,high,low,heartRate (heartRate optional?)\n                            if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                                if (values.length > valueIndex + 1) { // Need at least high and low pressure\n                                    position.set(\"pressureHigh\", values[valueIndex++]);\n                                    position.set(\"pressureLow\", values[valueIndex++]);\n                                } else { valueIndex = values.length; } // Skip if not enough values\n                            }\n                            // Format: PULSE/HEART,heartRate (or after pressure for BPHRT/BLOOD)\n                            if (valueIndex <= values.length - 1) { // Check if heart rate value exists\n                                position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                            }\n                        }\n                    }\n                } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {\n                    // Log warning: Failed to parse health data\n                }\n                // Return position even if parsing failed, might contain deviceId and time at least\n                return position;\n            }\n        } else if (type.equals(\"img\")) { // Image data\n             if (payload.isReadable()) {\n                 Position position = new Position(getProtocolName());\n                 position.setDeviceId(deviceSession.getDeviceId());\n                 getLastLocation(position, new Date()); // Use current time for image received event\n                 // Assume the entire payload after \"img,\" is the image data\n                 // Use retain() on the slice if writeMediaFile might process it asynchronously\n                 position.set(Position.KEY_IMAGE, writeMediaFile(id, payload.retain(), \"jpg\"));\n                 return position;\n             }\n        } else if (type.equals(\"JXTK\")) { // Multi-part audio message\n             // Find the 4th comma in the payload to separate metadata from audio data\n             int audioDataStartIndex = BufferUtil.indexOf(payload, payload.readerIndex(), payload.writerIndex(), (byte) ',', 4);\n             if (audioDataStartIndex < 0) {\n                 return null; // Invalid JXTK format: Not enough commas\n             }\n             audioDataStartIndex += 1; // Index of first byte of audio data\n\n             // Read metadata part (up to the 4th comma)\n             String metadata = payload.toString(payload.readerIndex(), audioDataStartIndex - payload.readerIndex(), StandardCharsets.US_ASCII);\n             String[] values = metadata.split(\",\");\n             // Metadata format: ?, ?, current_chunk, total_chunks\n             if (values.length < 4) {\n                 return null; // Invalid JXTK format: Not enough metadata fields\n             }\n\n             int current;\n             int total;\n             try { // Protect against non-integer values\n                 current = Integer.parseInt(values[2]);\n                 total = Integer.parseInt(values[3]);\n             } catch (NumberFormatException e) {\n                 return null; // Invalid metadata format\n             }\n\n             // Move payload reader index past metadata to the start of the audio data chunk\n             payload.readerIndex(audioDataStartIndex);\n\n             // Initialize audio buffer if this is the first chunk\n             if (audio == null) {\n                 audio = Unpooled.buffer();\n             }\n             // Append the current audio data chunk to the buffer\n             // Use retain() as the payload slice is temporary, but the audio buffer persists\n             audio.writeBytes(payload.retain());\n\n             // Acknowledge receipt of the chunk\n             sendResponse(channel, id, index, \"JXTKR,1\");\n\n             if (current < total) {\n                 // This is an intermediate chunk, wait for more\n                 return null;\n             } else {\n                 // This is the final chunk, process the complete audio data\n                 Position position = new Position(getProtocolName());\n                 position.setDeviceId(deviceSession.getDeviceId());\n                 getLastLocation(position, new Date()); // Use current time for audio received event\n\n                 ByteBuf audioToSend = this.audio; // Get the reference to the complete buffer\n                 this.audio = null; // Reset state *before* potential errors below, preventing reuse\n                 try {\n                     // Check if buffer is valid before writing\n                     if (audioToSend != null && audioToSend.isReadable()) {\n                         position.set(Position.KEY_AUDIO, writeMediaFile(id, audioToSend, \"amr\"));\n                     }\n                 } finally {\n                     // Ensure the accumulated buffer is always released\n                     if (audioToSend != null) {\n                         audioToSend.release();\n                     }\n                 }\n                 return position; // Return position with audio key set\n             }\n        } else if (type.equals(\"TK\")) { // Single-part audio message?\n             if (payload.readableBytes() <= 1) { // Require some payload data\n                 return null;\n             }\n             Position position = new Position(getProtocolName());\n             position.setDeviceId(deviceSession.getDeviceId());\n             getLastLocation(position, new Date()); // Use current time\n             // Assume payload is the audio data\n             position.set(Position.KEY_AUDIO, writeMediaFile(id, payload.retain(), \"amr\"));\n             return position;\n        }\n\n        // Return null if message type was not recognized or handled\n        return null;\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}