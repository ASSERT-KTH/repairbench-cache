{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport org.traccar.BaseProtocolDecoder;\nimport org.traccar.helper.BufferUtil;\nimport org.traccar.model.Position;\nimport org.traccar.session.DeviceSession;\n\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Date;\n\npublic class WatchProtocolDecoder extends BaseProtocolDecoder {\n\n    private ByteBuf audio;\n\n    public WatchProtocolDecoder(org.traccar.Protocol protocol) {\n        super(protocol);\n    }\n\n    @Override\n    protected Object decode(\n            Channel channel, SocketAddress remoteAddress, Object msg) throws Exception {\n\n        ByteBuf buf = (ByteBuf) msg;\n\n        buf.skipBytes(1); // '[' header\n        String manufacturer = buf.readSlice(2).toString(StandardCharsets.US_ASCII);\n        buf.skipBytes(1); // '*' delimiter\n\n        int idIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n        if (idIndex < 0) {\n            return null; // Malformed message: ID delimiter not found\n        }\n        String id = buf.readSlice(idIndex - buf.readerIndex()).toString(StandardCharsets.US_ASCII);\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, id);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        buf.skipBytes(1); // '*' delimiter\n\n        String index = null;\n        boolean hasIndex = false;\n\n        // Check if there's an optional index field (hexadecimal, 4 digits, followed by '*')\n        // The check (contentIndex + 5 < buf.writerIndex() && buf.getByte(contentIndex + 5) == '*')\n        // implies contentIndex is the asterisk after ID, and then it looks 5 bytes ahead (4 for length, 1 for next *)\n        // If there's an index, the current readerIndex is at the start of the index field.\n        // If no index, current readerIndex is at the start of the length field.\n\n        // Find the next asterisk, which could be after the index or directly after the ID.\n        int firstAsteriskAfterId = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '*');\n\n        if (firstAsteriskAfterId >= 0 && (firstAsteriskAfterId + 5 < buf.writerIndex())\n                && buf.getByte(firstAsteriskAfterId + 5) == '*'\n                && buf.toString(firstAsteriskAfterId + 1, 4, StandardCharsets.US_ASCII).matches(\"\\\\p{XDigit}+\")) {\n            // It looks like an index field followed by length\n            int indexLength = firstAsteriskAfterId - buf.readerIndex();\n            hasIndex = true;\n            index = buf.readSlice(indexLength).toString(StandardCharsets.US_ASCII);\n            buf.skipBytes(1); // '*' delimiter after index\n        }\n\n        // buf.readerIndex() is now at the start of the 4-byte length field\n        String lengthString = buf.readSlice(4).toString(StandardCharsets.US_ASCII);\n        int contentLength = Integer.parseInt(lengthString, 16);\n        buf.skipBytes(1); // '*' delimiter\n\n        // Now, buf.readerIndex() is at the start of the actual content.\n        // Create a slice to ensure subsequent operations only read from the content part of this message.\n        // This implicitly moves buf.readerIndex() of the main 'buf' to the end of the current frame's content.\n        // This also consumes the entire current message's content, preventing spillover to other parts of the buffer.\n        if (contentLength > buf.readableBytes()) {\n            return null; // Malformed message: declared content length exceeds readable bytes\n        }\n        ByteBuf contentBuf = buf.readSlice(contentLength);\n\n        // Ignore ending ']' - it was handled by the `contentLength` and `readSlice` implicitly.\n        // The original `buf.writerIndex(buf.writerIndex() - 1);` line at the top was likely problematic\n        // if this is indeed a MessageToMessageDecoder. It's removed. The `readSlice(contentLength)`\n        // handles the current frame's boundary.\n\n        // Parse type and content from contentBuf\n        int typeEndIndex = contentBuf.indexOf(\n                contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ',');\n        if (typeEndIndex < 0) {\n            typeEndIndex = contentBuf.writerIndex();\n        }\n\n        String type = contentBuf.readSlice(\n                typeEndIndex - contentBuf.readerIndex()).toString(StandardCharsets.US_ASCII);\n\n        if (typeEndIndex < contentBuf.writerIndex()) {\n            contentBuf.readerIndex(typeEndIndex + 1); // Skip the comma if present\n        }\n\n        if (type.equals(\"INIT\")) {\n\n            sendResponse(channel, id, index, \"INIT,1\");\n\n        } else if (type.equals(\"LK\")) {\n\n            sendResponse(channel, id, index, \"LK\");\n\n            if (contentBuf.isReadable()) { // Use contentBuf for all content parsing\n                String[] values = contentBuf.toString(StandardCharsets.US_ASCII).split(\",\");\n                if (values.length >= 3) {\n                    Position position = new Position(getProtocolName());\n                    position.setDeviceId(deviceSession.getDeviceId());\n\n                    getLastLocation(position, null);\n\n                    // Ensure array access is safe\n                    position.set(Position.KEY_BATTERY_LEVEL, Integer.parseInt(values[2]));\n                    position.set(Position.KEY_STEPS, Integer.parseInt(values[0]));\n\n                    return position;\n                }\n            }\n\n        } else if (type.startsWith(\"UD\") || type.startsWith(\"AL\") || type.startsWith(\"WT\")) {\n\n            // Use contentBuf for decoding position data\n            Position position = decodePosition(deviceSession, contentBuf.toString(StandardCharsets.US_ASCII));\n\n            if (type.startsWith(\"AL\")) {\n                if (position != null) {\n                    position.set(Position.KEY_ALARM, Position.ALARM_GENERAL);\n                }\n                sendResponse(channel, id, index, \"AL\");\n            }\n\n            return position;\n\n        } else if (type.equals(\"TKQ\") || type.equals(\"TKQ2\")) {\n\n            sendResponse(channel, id, index, type);\n\n        } else if (type.equalsIgnoreCase(\"PULSE\")\n                || type.equalsIgnoreCase(\"HEART\")\n                || type.equalsIgnoreCase(\"BLOOD\")\n                || type.equalsIgnoreCase(\"BPHRT\")\n                || type.equalsIgnoreCase(\"btemp2\")) {\n\n            if (contentBuf.isReadable()) { // Use contentBuf\n\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n\n                getLastLocation(position, new Date());\n\n                String[] values = contentBuf.toString(StandardCharsets.US_ASCII).split(\",\"); // Use contentBuf\n                int valueIndex = 0;\n\n                if (type.equalsIgnoreCase(\"btemp2\")) {\n                    if (values.length > valueIndex && Integer.parseInt(values[valueIndex++]) > 0) {\n                        if (values.length > valueIndex) {\n                            position.set(Position.PREFIX_TEMP + 1, Double.parseDouble(values[valueIndex]));\n                        }\n                    }\n                } else {\n                    if (type.equalsIgnoreCase(\"BPHRT\") || type.equalsIgnoreCase(\"BLOOD\")) {\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureHigh\", values[valueIndex++]);\n                        }\n                        if (values.length > valueIndex) {\n                            position.set(\"pressureLow\", values[valueIndex++]);\n                        }\n                    }\n                    if (valueIndex <= values.length - 1) { // Check for heart rate value existence\n                        position.set(Position.KEY_HEART_RATE, Integer.parseInt(values[valueIndex]));\n                    }\n                }\n\n                return position;\n\n            }\n\n        } else if (type.equals(\"img\")) {\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            int timeIndex = contentBuf.indexOf(contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ','); // Use contentBuf\n            if (timeIndex < 0) { // Handle malformed or incomplete image data\n                return null;\n            }\n            contentBuf.readerIndex(timeIndex + 12 + 2); // Use contentBuf\n            position.set(Position.KEY_IMAGE, writeMediaFile(id, contentBuf, \"jpg\")); // Use contentBuf\n\n            return position;\n\n        } else if (type.equals(\"JXTK\")) {\n\n            // Find the 4th comma within the contentBuf\n            int dataIndex = BufferUtil.indexOf(contentBuf, contentBuf.readerIndex(), contentBuf.writerIndex(), (byte) ',', 4);\n            if (dataIndex < 0) {\n                return null; // Malformed JXTK header (not enough commas)\n            }\n            dataIndex += 1; // Move past the 4th comma to the start of the audio metadata values\n\n            String[] values = contentBuf.readCharSequence(\n                    dataIndex - contentBuf.readerIndex(), StandardCharsets.US_ASCII).toString().split(\",\");\n\n            if (values.length < 4) { // Ensure current and total packet numbers are present\n                return null;\n            }\n\n            int current = Integer.parseInt(values[2]);\n            int total = Integer.parseInt(values[3]);\n\n            if (audio == null) {\n                audio = Unpooled.buffer();\n            }\n            // Write remaining readable bytes in contentBuf (which is only the audio data for this message) to audio buffer\n            audio.writeBytes(contentBuf);\n\n            sendResponse(channel, id, index, \"JXTKR,1\");\n\n            if (current < total) {\n                return null;\n            } else {\n                Position position = new Position(getProtocolName());\n                position.setDeviceId(deviceSession.getDeviceId());\n                getLastLocation(position, null);\n                position.set(Position.KEY_AUDIO, writeMediaFile(id, audio, \"amr\"));\n                audio.release();\n                audio = null;\n                return position;\n            }\n\n        } else if (type.equals(\"TK\")) {\n\n            if (contentBuf.readableBytes() == 1) { // Use contentBuf\n                return null;\n            }\n\n            Position position = new Position(getProtocolName());\n            position.setDeviceId(deviceSession.getDeviceId());\n\n            getLastLocation(position, null);\n\n            position.set(Position.KEY_AUDIO, writeMediaFile(id, contentBuf, \"amr\")); // Use contentBuf\n\n            return position;\n\n        }\n\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}