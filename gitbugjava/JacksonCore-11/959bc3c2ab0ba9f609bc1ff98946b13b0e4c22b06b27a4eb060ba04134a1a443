{
    "generation": "    private void _verifySharing()\n    {\n        if (_hashShared) {\n            // Create copies of arrays, become independent:\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n\n            // 09-Sep-2015, tatu: As per [jackson-core#216], need to check if we already\n            // need to rehash, even if _needRehash is false (not copied from parent).\n            // Check is based on current number of entries (_count) vs size and fill\n            // factor for spill-over area. Using the same calculations as in `addName()`\n            // for triggering rehashing.\n            // Note: must verify primary AND secondary hash areas. Primary is easy:\n            // `_count` includes primary entries. Spill area/tertiary needs separate check.\n            if (_count > _size) { // primary area full?\n                rehash();\n            } else {\n                // Maybe tertiary area full? Use field that tracks insertion point (_spilloverEnd)\n                // and compare against calculated max size for secondary/tertiary area.\n                // Max size for secondary/tertiary is same as primary hash size (_size),\n                // so max index is (_tertiaryStart + _size - 1).\n                // But let's use simpler check based on 50% spillover fill, similar to\n                // original logic in _verifyRehash() helper from the fix commit.\n                // (Note: _spilloverEnd tracks number of entries in spill area)\n                int spillCount = _spilloverEnd - _tertiaryStart; // Number of entries in spill area\n                if (spillCount > (_size >> 1)) { // Spill area > 50% full?\n                   rehash();\n                }\n            }\n            // NOTE: If rehash() was called, it will have set _needRehash = false.\n        }\n        // If we were not shared OR if we were shared but the state after copy\n        // didn't immediately require rehashing, we might still need to rehash\n        // if the child itself set the flag (_needRehash = true).\n        // The 'else if' structure avoids double-rehashing if the above check triggered.\n        else if (_needRehash) {\n            // Note: rehash() will clear the _needRehash flag\n            rehash();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}