{
    "generation": "  @Override\n  public boolean isSubtype(JSType other) {\n    if (!(other instanceof ArrowType)) {\n      return false;\n    }\n    ArrowType that = (ArrowType) other;\n\n    // Covariant return types.\n    // Special casing for unknown is important. It allows <? extends Unknown> to\n    // be subtypes of <? extends Object> and vice versa.\n    if (!this.returnType.isSubtype(that.returnType) &&\n        !this.returnType.isUnknownType() && !that.returnType.isUnknownType() &&\n        // Allow Function subtypes to be subtypes of Object.\n        // TODO(nicksantos): Don't specialize the Function graph.\n        !that.returnType.isObject()) {\n      return false;\n    }\n\n    // Parameter checks:\n    // A function 'this' is a subtype of 'that' if:\n    // 1. Parameter types are contravariant: that.param[i] <: this.param[i].\n    // 2. Optionality: If that.param[i] is optional, this.param[i] must be optional/varargs.\n    // 3. Arity:\n    //    - 'this' cannot have more required parameters than 'that'.\n    //    - If 'that' takes varargs, 'this' must take varargs.\n\n    Node thisParam = parameters.getFirstChild();\n    Node thatParam = that.parameters.getFirstChild();\n    boolean thisIsVarArgs = false;\n    boolean thatIsVarArgs = false;\n\n    while (thisParam != null && thatParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType thatParamType = thatParam.getJSType();\n\n      // 1. Check parameter type contravariance.\n      // Account for unknown types, which are subtypes/supertypes of everything.\n      if (thisParamType != null && thatParamType != null &&\n          !thisParamType.isUnknownType() && !thatParamType.isUnknownType() &&\n          !thatParamType.isSubtype(thisParamType)) {\n        return false;\n      }\n\n      // Track varargs status, needed for optionality check and post-loop logic.\n      thisIsVarArgs = thisParam.isVarArgs();\n      thatIsVarArgs = thatParam.isVarArgs();\n\n      // 2. Check optionality constraint.\n      // A required parameter in 'this' cannot fulfill an optional parameter in 'that'.\n      // isVarArgs needs to be checked because varargs parameters are implicitly optional.\n      if (thatParam.isOptionalArg() && !thisParam.isOptionalArg() && !thisIsVarArgs) {\n        return false;\n      }\n\n      // Advance pointers, stopping at varargs.\n      if (thisIsVarArgs || thatIsVarArgs) {\n        // If either hits varargs, stop the pairwise comparison here.\n        // Post-loop logic will handle varargs and remaining parameters.\n        break;\n      }\n\n      thisParam = thisParam.getNext();\n      thatParam = thatParam.getNext();\n    }\n\n    // Post-loop checks for arity and varargs.\n\n    // 3a. Check remaining 'this' parameters: must not be required.\n    // If thisIsVarArgs is true, it means the loop terminated on this's varargs node\n    // or a subsequent check found it. Any following nodes are covered by varargs.\n    if (!thisIsVarArgs && thisParam != null) {\n      Node currentThis = thisParam;\n      while (currentThis != null) {\n        // Varargs check inside loop needed if loop didn't break on varargs exactly.\n        if (currentThis.isVarArgs()) {\n          thisIsVarArgs = true;\n          break;\n        }\n        // Check requiredness. A parameter is required if it's not optional and not varargs.\n        if (!currentThis.isOptionalArg()) {\n          // 'this' has a required parameter that 'that' doesn't -> not a subtype.\n          return false;\n        }\n        currentThis = currentThis.getNext();\n      }\n    }\n\n    // 3b. Check remaining 'that' parameters to determine if 'that' ends in varargs.\n    // We don't check if remaining 'that' params are required, per lenient rules in comments.\n    if (!thatIsVarArgs && thatParam != null) {\n       Node currentThat = thatParam;\n       while (currentThat != null) {\n         if (currentThat.isVarArgs()) {\n           thatIsVarArgs = true;\n           break;\n         }\n         currentThat = currentThat.getNext();\n       }\n    }\n\n    // 3c. Final varargs check: If 'that' is varargs, 'this' must be varargs.\n    // This catches cases where 'this' ran out of parameters before 'that' hit varargs,\n    // or where both hit varargs simultaneously (covered by thisIsVarArgs update).\n    if (thatIsVarArgs && !thisIsVarArgs) {\n      return false;\n    }\n\n    // All subtype checks passed.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}