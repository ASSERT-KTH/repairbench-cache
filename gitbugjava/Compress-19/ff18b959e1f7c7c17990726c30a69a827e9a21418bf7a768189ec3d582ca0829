{
    "generation": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     *\n     * <p>According to the ZIP specification, the extra field may contain\n     * additional data beyond the fields listed for Zip64. We ignore any\n     * surplus data.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            // Fields present in order: size, compressedSize, relativeHeaderOffset, diskStart\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            // The actual data could be longer than expected if there are other fields\n            // unknown to us. Need to ensure we have *at least* the expected length.\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" is too short, expected at least \"\n                                       + expectedLength + \" but is only \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                // The constructor validates the length available from the offset.\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                 // The constructor validates the length available from the offset.\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                 // The constructor validates the length available from the offset.\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                 // The constructor validates the length available from the offset.\n                // Note: ZipLong uses WORD (4 bytes) not DWORD (8 bytes)\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                // offset += WORD; // No need to increment offset beyond this point\n            }\n            // Any data beyond the known fields is ignored, as allowed by the spec.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}