{
    "generation": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     *\n     * <p>According to APPNOTE.TXT version 6.3.2, the order is:</p>\n     * <ol>\n     *   <li>Original Size (8 bytes) - only if actual size is 0xFFFFFFFF</li>\n     *   <li>Compressed Size (8 bytes) - only if actual compressed size is 0xFFFFFFFF</li>\n     *   <li>Relative Header Offset (8 bytes) - only if actual relative header offset is 0xFFFFFFFF</li>\n     *   <li>Disk Start Number (4 bytes) - only if actual disk start is 0xFFFF</li>\n     * </ol>\n     *\n     * <p>Therefore, the extra field may be between 0 and 28 bytes long.</p>\n     *\n     * @param hasUncompressedSize     if the corresponding central directory entry requires an uncompressed size\n     * @param hasCompressedSize       if the corresponding central directory entry requires a compressed size\n     * @param hasRelativeHeaderOffset if the corresponding central directory entry requires a relative header offset\n     * @param hasDiskStart            if the corresponding central directory entry requires a disk start number\n     * @throws ZipException on error\n     * @since 1.1\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            // Fields are stored in the order listed by APPNOTE.TXT 6.3.2\n            // Original Size (8)\n            // Compressed Size (8)\n            // Relative Header Offset (8)\n            // Disk Start Number (4)\n            // -> minimum length is 0, maximum length is 28\n            int expectedLength = (hasUncompressedSize ? ZipConstants.DWORD : 0) // DWORD is 8 bytes for ZipEightByteInteger\n                + (hasCompressedSize ? ZipConstants.DWORD : 0)\n                + (hasRelativeHeaderOffset ? ZipConstants.DWORD : 0)\n                + (hasDiskStart ? ZipConstants.WORD : 0); // WORD is 4 bytes for ZipLong (disk number)\n\n            // Compare against actual length\n            // It's possible that the extra field contains more data than\n            // indicated by the flags based on the central directory header,\n            // for example interaction with ZipOutputStream#putArchiveEntry.\n            // Let's just parse the data indicated by the flags and ignore\n            // any extra bytes. See: COMPRESS-228\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                // The constructor creates a copy of the byte array\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += ZipConstants.DWORD;\n            }\n            if (hasCompressedSize) {\n                // The constructor creates a copy of the byte array\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += ZipConstants.DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                // The constructor creates a copy of the byte array\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += ZipConstants.DWORD;\n            }\n            if (hasDiskStart) {\n                // The constructor creates a copy of the byte array\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                // offset += ZipConstants.WORD; // No need to increment offset beyond this point\n            }\n            // Data is now parsed, getting rid of the raw data is tempting,\n            // but callers like ZipFile#getEntries need the field based on\n            // the parsed data. Resetting it to null would potentially require\n            // recreation from the parsed fields. Keep rawCentralDirectoryData.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}