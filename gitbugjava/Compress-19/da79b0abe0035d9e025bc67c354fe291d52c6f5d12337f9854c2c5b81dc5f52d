{
    "generation": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     *\n     * <p>The central directory extra field size is variable, depending on\n     * which fields are present. According to the spec, the size should be\n     * exactly the sum of the sizes of the fields that MUST be present.\n     * However, some tools may add extra data, which we should tolerate.</p>\n     *\n     * @param hasUncompressedSize     if the uncompressed size is expected to be present.\n     * @param hasCompressedSize       if the compressed size is expected to be present.\n     * @param hasRelativeHeaderOffset if the relative header offset is expected to be present.\n     * @param hasDiskStart            if the disk start number is expected to be present.\n     * @throws ZipException if the arguments are inconsistent or the extra field data is too short.\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            // Calculate the expected minimum length based on which fields are expected.\n            // DWORD is 8 bytes (ZipEightByteInteger), WORD is 4 bytes (ZipLong).\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n\n            // Tolerate extra data in the zip64 extra field segment.\n            // See https://issues.apache.org/jira/browse/COMPRESS-228\n            // Some ZIP writers may include fields that aren't strictly required\n            // (e.g., disk start number when it's < 0xFFFF) or add padding.\n            // We only need to ensure that there's *enough* data for the fields\n            // that we expect based on the central directory flags.\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" is too short, expected at least \"\n                                       + expectedLength + \" bytes, but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n\n            int offset = 0;\n            if (hasUncompressedSize) {\n                // Ensure offset + DWORD is within bounds implicitly by ZipEightByteInteger constructor\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                // Ensure offset + DWORD is within bounds implicitly by ZipEightByteInteger constructor\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                // Ensure offset + DWORD is within bounds implicitly by ZipEightByteInteger constructor\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n                // Ensure offset + WORD is within bounds implicitly by ZipLong constructor\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                // offset += WORD; // No need to update offset beyond the last field parsed\n            }\n            // Any data beyond the expected length (offset) is ignored.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}