{
    "generation": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     *\n     * <p>Blocks of extra data that are too short to contain the expected\n     * fields are considered errors.</p>\n     *\n     * @param hasUncompressedSize     must the uncompressed size field be present\n     * @param hasCompressedSize       must the compressed size field be present\n     * @param hasRelativeHeaderOffset must the relative header offset field be present\n     * @param hasDiskStart            must the disk start number field be present\n     * @throws ZipException on error\n     * @since 1.1\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            // Fields are expected in this order:\n            // - uncompressed size\n            // - compressed size\n            // - relative header offset\n            // - disk start\n            // NOTE: The constants WORD and DWORD are misleadingly named - WORD is 4 bytes, DWORD is 8 bytes\n            int expectedLength = (hasUncompressedSize ? DWORD : 0) // DWORD is 8 bytes\n                + (hasCompressedSize ? DWORD : 0) // DWORD is 8 bytes\n                + (hasRelativeHeaderOffset ? DWORD : 0) // DWORD is 8 bytes\n                + (hasDiskStart ? WORD : 0); // WORD is 4 bytes\n            // Tolerate extra data characters like Ant's zip task does - see Compress-228\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" is too short, expected minimal length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD; // DWORD = 8\n            }\n            if (hasCompressedSize) {\n                // The offset is relative to the start of the raw data\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD; // DWORD = 8\n            }\n            if (hasRelativeHeaderOffset) {\n                // The offset is relative to the start of the raw data\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD; // DWORD = 8\n            }\n            if (hasDiskStart) {\n                // The offset is relative to the start of the raw data\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                // offset += WORD; // WORD = 4 - not needed as it's the last field\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}