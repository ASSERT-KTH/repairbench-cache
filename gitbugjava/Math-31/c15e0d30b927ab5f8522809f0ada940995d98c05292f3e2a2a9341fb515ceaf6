{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     * @throws MaxCountExceededException if the maximum number of iterations is reached before convergence.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50; // A small number to prevent division by zero\n\n        // Initialize using MathWorld notation: a'_0 = getA(0, x)\n        // This corresponds to b_0 in the standard notation b0 + a1/(b1 + a2/(b2 + ...))\n        // which the modified Lentz algorithm typically uses.\n        double hPrev = getA(0, x); // f_0 = b_0 = a'_0\n\n        // Handle the case b_0 = 0 (or a'_0 = 0 in MathWorld terms)\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        double cPrev = hPrev; // C_0 = f_0\n        double dPrev = 0.0; // D_0 = 0\n        double hN = hPrev; // Current estimate f_n, initially f_0\n\n        int n = 1;\n        while (n < maxIterations) {\n            // Get MathWorld coefficients a'_n, b'_n\n            final double an = getA(n, x); // a'_n corresponds to b_n in standard notation\n            final double bn = getB(n, x); // b'_n corresponds to a_n in standard notation\n\n            // Modified Lentz iteration (using standard notation mapped variables):\n            // D_curr = b_n + a_n * D_prev = an + bn * dPrev\n            double dN = an + bn * dPrev;\n            if (Precision.equals(dN, 0.0, small)) {\n                dN = small;\n            }\n            // C_curr = b_n + a_n / C_prev = an + bn / cPrev\n            double cN = an + bn / cPrev;\n            if (Precision.equals(cN, 0.0, small)) {\n                cN = small;\n            }\n\n            dN = 1.0 / dN;\n            final double deltaN = cN * dN;\n            hN = hPrev * deltaN; // f_n = f_{n-1} * delta_n\n\n            // Check for NaN or Infinity immediately after update\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence: |deltaN - 1| = |f_n / f_{n-1} - 1| < epsilon\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            // Update for next iteration\n            dPrev = dN;\n            cPrev = cN;\n            hPrev = hN; // hPrev now stores f_n for the next iteration's calculation f_{n+1} = f_n * delta_{n+1}\n            n++;\n        }\n\n        // Check if maxIterations was reached without convergence\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN; // Return the last computed convergent value\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}