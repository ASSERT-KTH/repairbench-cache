{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 5 Lentz, W. J. \"Generating Bessel functions in Mie scattering calculations using continued fractions.\" Appl. Opt. 15, 668-671 (1976)\n     * and Thompson, I. J., and A. R. Barnett. \"Coulomb and Bessel functions of complex arguments and order.\" Journal of Computational Physics 64.2 (1986): 490-509.\n     * </p>\n     * <p>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>,\n     * which corresponds to b<sub>i</sub> and a<sub>i</sub> in the NR/Lentz/Thompson notation respectively.\n     * The continued fraction is written as:\n     * <pre>\n     *               b1              b2\n     * f = a0 + ---------------   ---------------\n     *          a1 +            a2 + ...\n     * </pre>\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed relative to the value.\n     * @param maxIterations maximum number of iterations.\n     * @return the value of the continued fraction evaluated at x.\n     * @throws MaxCountExceededException if the algorithm exceeds the maximum number of iterations.\n     * @throws ConvergenceException if the algorithm generates infinite or NaN values.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        // Use the modified Lentz algorithm (Numerical Recipes section 5.2)\n        // F = b0 + a1 / (b1 + a2 / (b2 + ...))\n        // In our code: b0 = getA(0, x), bn = getA(n, x), an = getB(n, x) for n >= 1\n\n        final double small = 1e-50; // A small number to prevent division by zero\n\n        double h_n = getA(0, x); // Initialize h_n = b0 (f_0 in NR notation)\n\n        // Handle the case b0 = 0\n        if (Precision.equals(h_n, 0.0, small)) {\n            h_n = small;\n        }\n\n        double C_n = h_n;  // C_0 = h_0\n        double D_n = 0.0;  // D_0 = 0\n\n        for (int n = 1; n <= maxIterations; ++n) {\n            final double a_n = getB(n, x); // NR a_n corresponds to code's b_n\n            final double b_n = getA(n, x); // NR b_n corresponds to code's a_n\n\n            // Calculate D_n = b_n + a_n * D_{n-1}\n            // Note: D_n holds D_{n-1} from the previous iteration before this calculation\n            D_n = b_n + a_n * D_n;\n            // Prevent D_n from being zero\n            if (Precision.equals(D_n, 0.0, small)) {\n                D_n = small;\n            }\n\n            // Calculate C_n = b_n + a_n / C_{n-1}\n            // Note: C_n holds C_{n-1} from the previous iteration before this calculation\n            C_n = b_n + a_n / C_n;\n            // Prevent C_n from being zero\n            if (Precision.equals(C_n, 0.0, small)) {\n                C_n = small;\n            }\n\n            // Calculate the change factor Delta_n = C_n / D_n\n            // Update rule requires D_n = 1 / D_n for the next iteration calculation\n            D_n = 1.0 / D_n;\n            final double delta_n = C_n * D_n;\n\n            // Update the continued fraction value h_n = h_{n-1} * Delta_n\n            h_n = h_n * delta_n;\n\n            // Check for divergence (Infinity or NaN)\n            if (Double.isInfinite(h_n)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(h_n)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence: |Delta_n - 1| < epsilon\n            if (FastMath.abs(delta_n - 1.0) < epsilon) {\n                return h_n; // Converged\n            }\n        }\n\n        // Maximum number of iterations reached without convergence\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}