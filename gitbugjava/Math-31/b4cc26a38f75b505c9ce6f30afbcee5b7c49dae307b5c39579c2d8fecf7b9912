{
    "generation": "import org.apache.commons.math3.exception.ConvergenceException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Precision;\n\n// Assume the enclosing class ContinuedFraction and necessary imports exist.\n\n    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * in Section 5.2 of \"Numerical Recipes\". This implementation avoids potential\n     * overflow/underflow problems that may occur using the direct evaluation of\n     * the recurrence relations for numerator and denominator.\n     * </p>\n     * <p>\n     * The continued fraction is assumed to be of the form:\n     * <pre>\n     *        a1\n     * b0 + --------\n     *      b1 + a2\n     *           --------\n     *           b2 + ...\n     * </pre>\n     * where b<sub>0</sub> = {@link #getA(int, double) getA(0, x)},\n     * a<sub>n</sub> = {@link #getA(int, double) getA(n, x)} for n &ge; 1, and\n     * b<sub>n</sub> = {@link #getB(int, double) getB(n, x)} for n &ge; 1.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum relative error allowed for convergence.\n     * @param maxIterations maximum number of iterations.\n     * @return the value of the continued fraction evaluated at x.\n     * @throws MaxCountExceededException if the algorithm fails to converge after\n     * {@code maxIterations} iterations.\n     * @throws ConvergenceException if the algorithm diverges (produces NaN or Infinite).\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) throws ConvergenceException, MaxCountExceededException {\n        // Use the modified Lentz algorithm described in Numerical Recipes, Chapter 5.2\n        final double small = 1e-50; // A small number to prevent division by zero\n\n        double h_n; // Stores the convergent value f_n = P_n / Q_n\n        double b_n; // Term b_n from getB(n, x)\n        double a_n; // Term a_n from getA(n, x)\n\n        // Initialize with b0 = getA(0, x)\n        h_n = getA(0, x);\n\n        // Handle b0 = 0 case as suggested by Numerical Recipes\n        // If b0 is very close to zero, Subsequent calculations may lead to NaN or Inf.\n        if (Precision.equals(h_n, 0.0, small)) {\n            h_n = small;\n        }\n\n        double C_n = h_n;  // Lentz's C_n variable, initialized C_0 = h_0 = b0\n        double D_n = 0.0;  // Lentz's D_n variable, initialized D_0 = 0\n\n        double delta_n; // The ratio C_n * D_n, used for convergence check\n\n        int n = 1;\n        while (n <= maxIterations) {\n            a_n = getA(n, x);\n            b_n = getB(n, x);\n\n            // Lentz recurrence relation for D_n\n            // D_n = b_n + a_n * D_{n-1}\n            D_n = b_n + a_n * D_n;\n            // Prevent division by zero / handle underflow\n            if (Precision.equals(D_n, 0.0, small)) {\n                D_n = small;\n            }\n            D_n = 1.0 / D_n; // D_n now stores 1 / (b_n + a_n * D_{n-1})\n\n            // Lentz recurrence relation for C_n\n            // C_n = b_n + a_n / C_{n-1}\n            C_n = b_n + a_n / C_n;\n            // Prevent division by zero / handle underflow\n            if (Precision.equals(C_n, 0.0, small)) {\n                C_n = small;\n            }\n            // C_n now stores b_n + a_n / C_{n-1}\n\n            // Calculate the ratio delta_n = C_n * D_n\n            delta_n = C_n * D_n;\n\n            // Update the convergent value h_n = h_{n-1} * delta_n\n            h_n = h_n * delta_n;\n\n            // Check for divergence (NaN or Infinity) after the update\n            if (Double.isInfinite(h_n)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(h_n)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence: |delta_n - 1| < epsilon\n            if (FastMath.abs(delta_n - 1.0) < epsilon) {\n                break; // Converged\n            }\n\n            n++;\n        }\n\n        // Check if convergence was achieved within maxIterations\n        if (n > maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return h_n;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}