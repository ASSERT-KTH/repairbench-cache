{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 520 in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   Journal of Computational Physics 64, 490-509 (1986).\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * The formula implemented is F = b<sub>0</sub> + a<sub>1</sub> / (b<sub>1</sub> + a<sub>2</sub> / (b<sub>2</sub> + ...))\n     * where a<sub>n</sub> = {@link #getA(int, double)} and b<sub>n</sub> = {@link #getB(int, double)}.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum relative error allowed.\n     * @param maxIterations maximum number of iterations.\n     * @return the value of the continued fraction evaluated at x.\n     * @throws MaxCountExceededException if the algorithm fails to converge after\n     * the maximum number of iterations allowed.\n     * @throws ConvergenceException if the algorithm diverges (produces NaN or infinite result).\n     * @deprecated as of 3.4 not used anymore internally and not planned for general use.\n     */\n    @Deprecated\n    public double evaluate(double x, double epsilon, int maxIterations)\n            throws MaxCountExceededException, ConvergenceException {\n        final double small = 1e-50; // A small number to prevent division by zero\n\n        double b0 = getB(0, x);\n        // Compute the first term h_0 = b_0\n        double hN = b0;\n\n        // Avoid division by zero, just use small value instead. This follows the NR recommendation.\n        if (Precision.equals(hN, 0.0, small)) {\n            hN = small;\n        }\n\n        double dPrev = 0.0; // D_0 = 0\n        double cPrev = hN;  // C_0 = h_0 = b_0 (or small if b_0 is 0)\n\n        int n = 1;\n        while (n <= maxIterations) {\n            final double a = getA(n, x); // a_n\n            final double b = getB(n, x); // b_n\n\n            // Compute D_n = b_n + a_n * D_{n-1}\n            double dN = b + a * dPrev;\n            if (Precision.equals(dN, 0.0, small)) {\n                // Replace 0 with small to avoid division by zero\n                dN = small;\n            }\n\n            // Compute C_n = b_n + a_n / C_{n-1}\n            double cN = b + a / cPrev;\n            if (Precision.equals(cN, 0.0, small)) {\n                // Replace 0 with small to avoid division by zero\n                cN = small;\n            }\n\n            // Compute D_n = 1 / D_n (update D_n)\n            dN = 1.0 / dN;\n\n            // Compute Delta_n = C_n * D_n\n            final double deltaN = cN * dN;\n\n            // Compute h_n = h_{n-1} * Delta_n\n            hN = hN * deltaN;\n\n            // Check for divergence\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence: |Delta_n - 1| < epsilon\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break; // Convergence achieved.\n            }\n\n            // Update variables for next iteration C_{n-1} -> C_n and D_{n-1} -> D_n\n            dPrev = dN;\n            cPrev = cN;\n\n            n++;\n        }\n\n        // Check if maximum iterations were exceeded\n        if (n > maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}