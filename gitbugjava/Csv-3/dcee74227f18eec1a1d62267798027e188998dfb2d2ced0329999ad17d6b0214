{
    "generation": "    /**\n     * Handle an escape sequence.\n     * The current character must be the escape character.\n     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n     * on the input stream.\n     *\n     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n     * the escape character is not allowed at end of strem\n     */\n    int readEscape() throws IOException {\n        // the escape char has just been read (normally a backslash)\n        final int c = in.read();\n        switch (c) {\n        case 'r':\n            return CR;\n        case 'n':\n            return LF;\n        case 't':\n            return TAB;\n        case 'b':\n            return BACKSPACE;\n        case 'f':\n            return FF;\n        // Removed erroneous cases for literal control characters CR, LF, FF, TAB, BACKSPACE.\n        // These characters are not standard escape sequences like \\r, \\n, etc.\n        // If the character following the escape is one of these control characters,\n        // it should be handled by the default case, returning the character itself.\n        // The lexer logic (caller) determines how to handle the returned character\n        // (e.g., append directly if it's a meta char, or prepend escape if it's not).\n        // case CR:\n        // case LF:\n        // case FF: // TODO is this correct? -> No\n        // case TAB: // TODO is this correct? Do tabs need to be escaped? -> No\n        // case BACKSPACE: // TODO is this correct? -> No\n        //    return c;\n        case END_OF_STREAM:\n            throw new IOException(\"EOF whilst processing escape sequence\");\n        default:\n            // Return the character following the escape character.\n            // This character might be a meta character (quote, delimiter, escape itself)\n            // or a regular character. The caller (CSVLexer) is responsible for\n            // interpreting this returned character correctly based on the CSVFormat settings.\n            // For example, if \\ cancels the escaping functionality of the escape character\n            // and the character following the escape is not a meta character then the escape\n            // character is itself appended to the token, followed by the character read.\n            return c;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}