{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     *\n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // Find the transition occurring strictly before instant + 1\n        // This ensures we find the transition potentially relevant to the specified instant.\n        // Add 1 to handle the case where the instant is exactly at the transition.\n        // If instant is Long.MAX_VALUE, adding 1 wraps around, but previousTransition should handle it.\n        // If instant is Long.MIN_VALUE, Long.MIN_VALUE + 1 is safe.\n        long transition = previousTransition(instant + 1);\n\n        // If there is no transition before this instant, return original instant\n        if (transition == Long.MIN_VALUE) {\n            return instant;\n        }\n\n        // Get offsets before and after the transition\n        int offsetBefore = getOffset(transition - 1);\n        int offsetAfter = getOffset(transition);\n\n        // Check if it's an overlap transition (offset decreases)\n        // Example: Fall back from UTC-2 to UTC-3. offsetBefore=-7200000, offsetAfter=-10800000. offsetBefore > offsetAfter.\n        if (offsetBefore > offsetAfter) {\n            // Calculate the start and end of the ambiguous local time interval\n            // The interval is [transition + offsetAfter, transition + offsetBefore)\n            long localOverlapStart = transition + offsetAfter;\n            long localOverlapEnd = transition + offsetBefore;\n\n            // Calculate the local time of the input instant using its current offset\n            // This offset might be offsetBefore or offsetAfter if the instant is in the overlap.\n            int instantOffset = getOffset(instant);\n            long localInstant = instant + instantOffset;\n\n            // Check if the instant's local time falls within the ambiguous range [start, end)\n            if (localInstant >= localOverlapStart && localInstant < localOverlapEnd) {\n                // Instant is in the overlap ambiguity.\n                // We need to return the instant corresponding to the earlier or later offset,\n                // which corresponds to the earlier or later UTC instant mapping to the same local time.\n\n                // Find the two possible UTC instants for this local time.\n                // utcEarlier corresponds to the offsetBefore (the one active before the transition)\n                // utcLater corresponds to the offsetAfter (the one active at and after the transition)\n                long utcEarlier = localInstant - offsetBefore;\n                long utcLater = localInstant - offsetAfter;\n\n                // Return the requested one based on the flag\n                // false means earlier offset (-> utcEarlier instant)\n                // true means later offset (-> utcLater instant)\n                return earlierOrLater ? utcLater : utcEarlier;\n            }\n            // else: Instant's local time is not in the ambiguous range, so no adjustment needed.\n        }\n        // else: It wasn't an overlap transition (either a gap or no change)\n\n        // If it wasn't an overlap transition, or the instant's local time was not ambiguous,\n        // return the original instant.\n        return instant;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}