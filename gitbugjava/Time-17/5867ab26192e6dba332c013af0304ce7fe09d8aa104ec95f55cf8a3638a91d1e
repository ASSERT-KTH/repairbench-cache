{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * <p>\n     * If the zone performs overlaps, then these operations specify which offset\n     * to use.\n     * <p>\n     * If the specified instant is not in an overlap, it is returned unaltered.\n     * If the zone does not perform overlaps, the instant is returned unaltered.\n     *\n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // This method needs to return an instant equivalent to the input instant\n        // but with the earlier or later offset choice resolved if the instant\n        // falls within an overlap.\n\n        // The core idea is to use the behavior of convertLocalToUTC(local, false, referenceUTC).\n        // When the local time 'local' is ambiguous (falls in an overlap), this method\n        // resolves the ambiguity by choosing the UTC instant (out of the two possibilities)\n        // whose offset matches the offset of the 'referenceUTC' instant provided.\n\n        // Choose reference UTC instants far enough before and after the potential transition\n        // related to 'instant'. A 12-hour buffer is likely safe for typical DST changes.\n        // These instants act as anchors representing the time zone state before and after a transition.\n        long instantBeforeTransition = instant - 12 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfterTransition = instant + 12 * DateTimeConstants.MILLIS_PER_HOUR;\n\n        // Calculate the local time associated with the input UTC instant.\n        long localInstant = convertUTCToLocal(instant);\n\n        // Determine the reference instant to use for disambiguation based on the desired outcome.\n        long referenceInstant;\n        if (earlierOrLater) {\n            // true: We want the later offset (e.g., the standard time after DST ends).\n            // The time after the transition has the later offset.\n            // So, use instantAfterTransition as the reference. Its offset will guide\n            // convertLocalToUTC to select the UTC instant with the later offset.\n            referenceInstant = instantAfterTransition;\n        } else {\n            // false: We want the earlier offset (e.g., the DST time before it ends).\n            // The time before the transition has the earlier offset.\n            // So, use instantBeforeTransition as the reference. Its offset will guide\n            // convertLocalToUTC to select the UTC instant with the earlier offset.\n            referenceInstant = instantBeforeTransition;\n        }\n\n        // Convert the local time back to UTC using the chosen reference instant.\n        // If localInstant is unambiguous (not in an overlap), this call should simply\n        // return the unique UTC instant corresponding to localInstant, which will be\n        // equivalent to the original 'instant'.\n        // If localInstant is ambiguous (in an overlap), this call will return the\n        // UTC instant (either the first or second occurrence) whose offset matches\n        // the offset of referenceInstant, thus selecting the earlier or later instant as desired.\n        return convertLocalToUTC(localInstant, false, referenceInstant);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}