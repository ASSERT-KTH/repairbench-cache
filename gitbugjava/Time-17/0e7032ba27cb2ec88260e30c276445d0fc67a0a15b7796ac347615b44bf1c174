{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     *\n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // Check the transition point AFTER the instant, if any.\n        long nextTrans = nextTransition(instant);\n        // Check if the transition happens AFTER the instant and involves an overlap\n        if (nextTrans != Long.MAX_VALUE && nextTrans > instant) {\n            long offsetBefore = getOffset(nextTrans - 1);\n            long offsetAfter = getOffset(nextTrans);\n            // Check if this transition is an overlap (offset decreases, e.g., -2 -> -3 for southern hemisphere DST end)\n            if (offsetBefore > offsetAfter) {\n                long duration = offsetBefore - offsetAfter;\n                // Check if the instant is in the first UTC interval of the overlap: [nextTrans - duration, nextTrans)\n                if (instant >= nextTrans - duration) {\n                    // Instant is in the overlap.\n                    // Calculate the local time using the offset before the transition.\n                    long local = instant + offsetBefore;\n                    // Find the two UTC instants mapping to this local time.\n                    // utcEarlier corresponds to the offset before transition (offsetBefore)\n                    // utcLater corresponds to the offset after transition (offsetAfter)\n                    // Note: utcEarlier = instant, by definition of local = instant + offsetBefore\n                    // So, utcEarlier = local - offsetBefore\n                    long utcLater = local - offsetAfter;\n                    // Return the requested instant.\n                    // If earlierOrLater is false (earlier), return instant (utcEarlier).\n                    // If earlierOrLater is true (later), return utcLater.\n                    return earlierOrLater ? utcLater : instant; // Simplified: utcEarlier is always 'instant' in this block\n                }\n            }\n        }\n\n        // Check the transition point AT or BEFORE the instant, if any.\n        long prevTrans = previousTransition(instant);\n        // Check if the transition happens AT or BEFORE the instant and involves an overlap\n        if (prevTrans != Long.MIN_VALUE && prevTrans <= instant) {\n            long offsetBefore = getOffset(prevTrans - 1);\n            long offsetAfter = getOffset(prevTrans);\n            // Check if this transition is an overlap (offset decreases)\n            if (offsetBefore > offsetAfter) {\n                long duration = offsetBefore - offsetAfter;\n                // Check if the instant is in the second UTC interval of the overlap: [prevTrans, prevTrans + duration)\n                if (instant < prevTrans + duration) {\n                    // Instant is in the overlap.\n                    // Calculate the local time using the offset after the transition.\n                    long local = instant + offsetAfter;\n                    // Find the two UTC instants mapping to this local time.\n                    long utcEarlier = local - offsetBefore; // Corresponds to the offset before transition\n                    // utcLater corresponds to the offset after transition (offsetAfter)\n                    // Note: utcLater = instant, by definition of local = instant + offsetAfter\n                    // So, utcLater = local - offsetAfter\n                    // Return the requested instant.\n                    // If earlierOrLater is false (earlier), return utcEarlier.\n                    // If earlierOrLater is true (later), return instant (utcLater).\n                    return earlierOrLater ? instant : utcEarlier; // Simplified: utcLater is always 'instant' in this block\n                }\n            }\n        }\n\n        // If the instant is not within any overlap period found, return it unchanged.\n        return instant;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}