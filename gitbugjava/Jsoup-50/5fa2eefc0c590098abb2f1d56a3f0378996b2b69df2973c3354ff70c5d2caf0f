{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// Replaced the buggy function with the fixed version below\nclass FixedDataUtil { // Helper class to contain the static method and potential dependencies\n\n    // Assume defaultCharset is defined elsewhere, e.g., static final String defaultCharset = \"UTF-8\";\n    // Assume getCharsetFromContentType is defined elsewhere.\n    // Assume UNICODE_BOM is no longer needed here.\n    private static final String defaultCharset = \"UTF-8\"; // Assuming UTF-8 is the default\n\n    /**\n     * Placeholder for the actual utility method if needed by the logic below.\n     * Extracts charset name from a Content-Type header value.\n     * @param contentType e.g. \"text/html; charset=UTF-8\"\n     * @return \"UTF-8\" or null if not found.\n     */\n    private static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        // Basic implementation, real one might be more robust\n        String[] params = contentType.split(\";\");\n        for (String param : params) {\n            param = param.trim();\n            if (param.toLowerCase().startsWith(\"charset=\")) {\n                String charset = param.substring(\"charset=\".length());\n                // Remove quotes if present\n                if (charset.startsWith(\"\\\"\") && charset.endsWith(\"\\\"\") || charset.startsWith(\"'\") && charset.endsWith(\"'\")) {\n                    charset = charset.substring(1, charset.length() - 1);\n                }\n                return charset.trim();\n            }\n        }\n        return null;\n    }\n\n\n    // todo - this is getting gnarly. needs a rewrite. // Note: Rewritten based on analysis\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String foundCharset = null; // Used to hold detected charset based on BOM or meta tags\n\n        // -- BOM Detection --\n        // First, try reading UTF-32 BOM. Needs 4 bytes.\n        byteData.mark(); // Mark the start\n        byte[] bom = new byte[4];\n        if (byteData.remaining() >= 4) {\n            byteData.get(bom);\n            byteData.reset(); // Go back to the start to read the actual sequence\n\n            // UTF-32 BE: 00 00 FE FF\n            if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte)0xFE && bom[3] == (byte)0xFF) {\n                foundCharset = \"UTF-32BE\";\n                byteData.position(byteData.position() + 4); // Consume BOM\n            }\n            // UTF-32 LE: FF FE 00 00\n            else if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE && bom[2] == 0x00 && bom[3] == 0x00) {\n                foundCharset = \"UTF-32LE\";\n                byteData.position(byteData.position() + 4); // Consume BOM\n            }\n            // UTF-16 BE: FE FF\n            else if (bom[0] == (byte)0xFE && bom[1] == (byte)0xFF) {\n                foundCharset = \"UTF-16BE\";\n                byteData.position(byteData.position() + 2); // Consume BOM\n            }\n            // UTF-16 LE: FF FE\n            else if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE) {\n                foundCharset = \"UTF-16LE\";\n                byteData.position(byteData.position() + 2); // Consume BOM\n            }\n            // UTF-8: EF BB BF\n            else if (bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) {\n                foundCharset = \"UTF-8\"; // Explicitly UTF-8\n                byteData.position(byteData.position() + 3); // Consume BOM\n            }\n            // No matching BOM, reset() is effectively called by lack of position change or was called explicitly earlier\n        } else if (byteData.remaining() >= 3) {\n             // Try reading UTF-8 BOM\n             byteData.get(bom, 0, 3);\n             byteData.reset();\n             // UTF-8: EF BB BF\n             if (bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) {\n                 foundCharset = \"UTF-8\";\n                 byteData.position(byteData.position() + 3);\n             }\n        } else if (byteData.remaining() >= 2) {\n            // Try reading UTF-16 BOM\n             byteData.get(bom, 0, 2);\n             byteData.reset();\n            // UTF-16 BE: FE FF\n             if (bom[0] == (byte)0xFE && bom[1] == (byte)0xFF) {\n                 foundCharset = \"UTF-16BE\";\n                 byteData.position(byteData.position() + 2);\n             }\n             // UTF-16 LE: FF FE\n             else if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE) {\n                 foundCharset = \"UTF-16LE\";\n                 byteData.position(byteData.position() + 2);\n             }\n        }\n        // If no BOM found, foundCharset remains null. Position is at the start (due to reset or no match).\n\n        final String effectiveCharset; // The charset used for final decoding\n\n        if (foundCharset != null) {\n            // BOM dictates charset. Use it.\n            effectiveCharset = foundCharset;\n        } else if (charsetName != null) {\n            // No BOM, but charset provided externally (e.g. HTTP header). Use it.\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            effectiveCharset = charsetName;\n        } else {\n            // No BOM, no external charset. Detect from meta tags.\n            // Tentatively decode using default charset (UTF-8)\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri); // Parse tentatively to find meta tags\n\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String metaCharset = null;\n            if (meta != null) { // If not found, will keep utf-8 as best attempt\n                if (meta.hasAttr(\"http-equiv\")) {\n                    metaCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (metaCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            metaCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // ignore invalid charset attribute\n                        metaCharset = null;\n                    }\n                }\n            }\n\n            if (metaCharset != null && metaCharset.length() != 0 && !metaCharset.equalsIgnoreCase(defaultCharset)) {\n                 // Found a different charset in meta tag, use it. Need to re-decode.\n                 metaCharset = metaCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 effectiveCharset = metaCharset;\n                 doc = null; // Signal that we need to parse again after re-decoding\n                 byteData.reset(); // Rewind to start (before BOM check mark) for re-decoding\n            } else {\n                // No usable meta charset found, or it matched the default. Stick with default.\n                // Keep the doc parsed with default charset.\n                effectiveCharset = defaultCharset;\n            }\n        }\n\n        // If doc is null, it means we either had a BOM, an explicit charset, or found a meta charset requiring re-decode.\n        // In these cases, we need to decode the (remaining) byte data using the effectiveCharset.\n        if (doc == null) {\n            // Decode the byte buffer from its current position (after BOM, or from start if no BOM/re-decode)\n            docData = Charset.forName(effectiveCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the document's output charset to the determined effective charset\n        doc.outputSettings().charset(effectiveCharset);\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}