{
    "generation": "import org.jsoup.helper.Validate;\nimport org.jsoup.internal.StringUtil; // Assuming defaultCharset is defined here or accessible\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// Note: This code assumes 'defaultCharset' and 'getCharsetFromContentType' are accessible\n// static constants/methods within the same class or imported appropriately.\n\n    // todo - this is getting gnarly. needs a rewrite. // Original comment preserved\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData = null;\n        Document doc = null;\n        String foundCharset = null; // Charset found from BOM\n\n        // 1. Check for BOM. This overrides any provided or meta charset.\n        byteData.mark(); // Mark the start position\n        byte[] bom = new byte[4];\n        int bomLen = 0;\n        // Try reading 4 bytes\n        if (byteData.remaining() >= 4) {\n            byteData.get(bom);\n            // Important: Check LONGEST sequences first\n            if (bom[0] == (byte)0x00 && bom[1] == (byte)0x00 && bom[2] == (byte)0xFE && bom[3] == (byte)0xFF) { // UTF-32BE\n                foundCharset = \"UTF-32BE\";\n                bomLen = 4;\n            } else if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE && bom[2] == (byte)0x00 && bom[3] == (byte)0x00) { // UTF-32LE\n                foundCharset = \"UTF-32LE\";\n                bomLen = 4;\n            } else if (bom[0] == (byte)0xFE && bom[1] == (byte)0xFF) { // UTF-16BE\n                foundCharset = \"UTF-16BE\";\n                bomLen = 2;\n            } else if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE) { // UTF-16LE\n                foundCharset = \"UTF-16LE\";\n                bomLen = 2;\n            } else if (bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) { // UTF-8\n                foundCharset = \"UTF-8\";\n                bomLen = 3;\n            } else {\n                 // No 4-byte BOM found. The checks above implicitly cover 2 & 3 byte sequences if 4 bytes were read.\n                 bomLen = 0;\n            }\n        } // else: not enough bytes for a 4-byte BOM, maybe could check 2/3 bytes but previous logic handles it. bomLen remains 0.\n\n        byteData.reset(); // Reset position to mark (start)\n\n        if (bomLen > 0) {\n            byteData.position(byteData.position() + bomLen); // Consume BOM bytes\n            charsetName = foundCharset; // BOM determines charset, overrides passed charsetName parameter\n            doc = null; // We need to parse using this charset\n        } else if (charsetName == null) { // No BOM found and no charsetName specified, try to detect from meta tag\n            // Decode using default for meta scan. Use a duplicate buffer to avoid changing original position yet.\n            ByteBuffer bufferForScan = byteData.duplicate();\n            try {\n                docData = Charset.forName(defaultCharset).decode(bufferForScan).toString();\n            } catch (Exception e) {\n                // Decoding with default failed. Cannot scan. Log or handle?\n                // For now, treat as if no meta tag found, fallback to default later.\n                docData = null; // Indicate failure to decode for scan\n            }\n\n            // Only parse if decoding for meta scan succeeded\n            if (docData != null) {\n                doc = parser.parseInput(docData, baseUri); // Tentative parse based on default charset\n                Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n                String metaCharset = null;\n\n                if (meta != null) { // Found meta tag\n                    if (meta.hasAttr(\"http-equiv\")) {\n                        metaCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    }\n                    if (metaCharset == null && meta.hasAttr(\"charset\")) {\n                        metaCharset = meta.attr(\"charset\");\n                    }\n                }\n\n                if (metaCharset != null && metaCharset.length() > 0) {\n                    metaCharset = metaCharset.trim().replaceAll(\"[\\\"']\", \"\"); // Clean found charset\n                    try {\n                        if (Charset.isSupported(metaCharset)) {\n                            charsetName = metaCharset; // Use found supported charset\n                        } else {\n                            // Unsupported charset in meta, fallback to default\n                            metaCharset = null; // Indicate no valid meta charset found\n                            charsetName = defaultCharset;\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                         // Invalid charset name syntax in meta, fallback to default\n                         metaCharset = null;\n                         charsetName = defaultCharset;\n                    }\n                } else {\n                    // No meta tag or empty/invalid charset found, use default\n                    charsetName = defaultCharset;\n                }\n\n                // If the detected charset differs significantly from default, we must re-parse\n                // Using equalsIgnoreCase to be safe\n                if (metaCharset != null && !metaCharset.equalsIgnoreCase(defaultCharset)) {\n                    // Meta charset is valid, supported, and different from default. Re-decode & re-parse is required.\n                    doc = null; // Discard tentative parse\n                }\n                // else: meta charset is null or same as default, keep tentative parse in 'doc'\n                // charsetName is already set to defaultCharset in this case.\n                // byteData position is still at the start (because we used duplicate for scan).\n            } else {\n                 // Decoding with default charset failed. Cannot parse or determine meta. Fallback to default.\n                 charsetName = defaultCharset;\n                 doc = null; // Ensure doc is null as parse failed\n            }\n\n        } else { // No BOM, but charsetName was specified by caller. Validate it.\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            doc = null; // Will parse using this specified charset. byteData position still at start.\n        }\n\n        // 3. Decode and parse if necessary\n        if (doc == null) {\n            // We must have a charsetName by now (from BOM, specified, default, or meta-detected)\n            // Ensure charsetName is not null (this is a fallback, should always be set by now)\n             if (charsetName == null) charsetName = defaultCharset;\n\n            // Decode the data from the buffer's *current* position.\n            // If BOM was found, position is after BOM. Otherwise, it's at the start (byteData.reset() was called earlier).\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n\n            // Check for potentially misinterpreted UTF-8 BOM character (\\uFEFF) if decoded as something else?\n            // The CharsetDecoder should handle stripping the BOM for the correct encoding.\n            // Let's assume standard decoder behavior is sufficient. If tests fail, re-evaluate.\n\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // 4. Set output charset\n        // Use the charset name that was determined (from BOM, meta, specified, or default)\n        doc.outputSettings().charset(charsetName);\n        return doc;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}