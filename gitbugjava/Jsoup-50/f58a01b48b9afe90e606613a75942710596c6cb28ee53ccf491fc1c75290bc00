{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\n// Assuming DataUtil class structure and access to its static members/methods like:\n// import static org.jsoup.helper.DataUtil.defaultCharset;\n// import static org.jsoup.helper.DataUtil.getCharsetFromContentType;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n    // todo - this is getting gnarly. needs a rewrite. (Still complex, but handles BOM correctly now)\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData = null;\n        Document doc = null;\n        String foundCharset = null; // Charset determined by BOM, meta tag, or caller\n        final char UNICODE_BOM = '\\uFEFF';\n        // Assuming DataUtil.defaultCharset is accessible and static final\n        final String defaultCharset = org.jsoup.helper.DataUtil.defaultCharset;\n\n        // 1. Check for BOM - overrides any other header or input. Does not change byteData position yet.\n        byteData.mark(); // Mark the start\n        byte[] bom = new byte[4];\n        int bomLength = 0;\n        if (byteData.remaining() >= 4) {\n            // Read first 4 bytes without changing position for BOM detection\n            bom[0] = byteData.get(0);\n            bom[1] = byteData.get(1);\n            bom[2] = byteData.get(2);\n            bom[3] = byteData.get(3);\n\n            if (bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) { // UTF-32BE\n                 foundCharset = \"UTF-32BE\";\n                 bomLength = 4;\n            } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) { // UTF-32LE\n                 foundCharset = \"UTF-32LE\";\n                 bomLength = 4;\n            } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) { // UTF-16BE\n                 foundCharset = \"UTF-16BE\";\n                 bomLength = 2;\n            } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { // UTF-16LE\n                 foundCharset = \"UTF-16LE\";\n                 bomLength = 2;\n            } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { // UTF-8\n                 foundCharset = \"UTF-8\";\n                 bomLength = 3;\n             }\n            // Add other BOMs if needed (e.g., UTF-7 - unlikely)\n        } else if (byteData.remaining() >= 2) { // Check for 2-byte BOMs only if not enough for 4\n            bom[0] = byteData.get(0);\n            bom[1] = byteData.get(1);\n\n            if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) { // UTF-16BE\n                 foundCharset = \"UTF-16BE\";\n                 bomLength = 2;\n            } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { // UTF-16LE\n                 foundCharset = \"UTF-16LE\";\n                 bomLength = 2;\n            }\n        }\n\n        if (bomLength > 0) {\n             byteData.position(byteData.position() + bomLength); // Advance position past BOM if detected\n        }\n        // Reset not needed here as we used absolute gets and only advanced position if BOM found.\n\n        // 2. Determine encoding if not found via BOM\n        if (foundCharset == null) { // No BOM found\n             if (charsetName != null) { // Caller provided charset takes precedence over meta tag\n                 Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n                 foundCharset = charsetName;\n             } else { // No BOM, no caller charset - attempt meta tag detection\n                 // We need to tentatively decode using the default charset to find meta tag.\n                 // byteData is still positioned at 0 (or start after mark).\n                 byteData.mark(); // Mark position before tentative decode\n                 try {\n                     String tentativeDocData = Charset.forName(defaultCharset).decode(byteData).toString();\n                     // tentativeDocData now contains the decoded string. byteData position is advanced.\n                     doc = parser.parseInput(tentativeDocData, baseUri); // Parse tentatively\n                     Element meta = doc.selectFirst(\"meta[http-equiv=content-type], meta[charset]\");\n                     String metaCharset = null;\n                     if (meta != null) { // Found a meta tag\n                         if (meta.hasAttr(\"http-equiv\")) {\n                             // Assuming DataUtil.getCharsetFromContentType is accessible and static\n                             metaCharset = org.jsoup.helper.DataUtil.getCharsetFromContentType(meta.attr(\"content\"));\n                         }\n                         if (metaCharset == null && meta.hasAttr(\"charset\")) {\n                             metaCharset = meta.attr(\"charset\");\n                         }\n                     }\n\n                     if (metaCharset != null && metaCharset.length() > 0) {\n                         metaCharset = metaCharset.trim().replaceAll(\"[\\\"']\", \"\"); // Clean input\n                         // Validate meta charset\n                         try {\n                            if (Charset.isSupported(metaCharset) && !metaCharset.equalsIgnoreCase(defaultCharset)) {\n                                 // Different, valid charset found in meta. Use it.\n                                 foundCharset = metaCharset;\n                                 doc = null; // Discard initial parse result\n                                 byteData.reset(); // IMPORTANT: Rewind buffer to re-decode with correct charset\n                            } else {\n                                 // Meta charset is same as default, invalid, or unsupported.\n                                 // Stick with the default charset parse. 'doc' is already parsed.\n                                 foundCharset = defaultCharset;\n                                 docData = tentativeDocData; // Keep the decoded data from default decode\n                                 // Buffer already consumed by decode, no reset needed.\n                            }\n                         } catch (IllegalCharsetNameException e) {\n                             // Meta charset is invalid (e.g., unsupported format). Stick with default.\n                             foundCharset = defaultCharset;\n                             docData = tentativeDocData; // Keep the doc parsed with default\n                         }\n                     } else {\n                         // No meta charset found, or empty. Stick with default charset parse.\n                         foundCharset = defaultCharset;\n                         docData = tentativeDocData; // Keep the doc parsed with default\n                     }\n                 } catch (Exception e) {\n                     // Catch exceptions during tentative parse/decode (e.g., CharacterCodingException)\n                     byteData.reset(); // Rewind on error\n                     foundCharset = defaultCharset; // Fallback to default\n                     doc = null; // Ensure re-parse below if possible\n                     docData = null;\n                 }\n             }\n        }\n\n        // 3. Decode and Parse (if not already parsed in step 2)\n        if (doc == null) { // Happens if BOM found, caller charset provided, meta required re-parse, or tentative parse failed\n            Validate.notEmpty(foundCharset, \"Charset must be resolved by now for re-parse\");\n            // Decode using the determined charset (from BOM, caller, or meta)\n            // byteData position is either advanced past BOM or at the start (due to reset or first read)\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n\n            // Strip potential leading BOM character (\\uFEFF) from decoded string.\n            // Although BOM bytes were skipped, some decoders might still insert the char.\n            if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n                docData = docData.substring(1);\n            }\n            // Check for null docData? If decode failed, Charset.decode throws exception.\n            // If byteData was empty after BOM skip, docData would be empty string.\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // 4. Set final charset and return\n        Validate.notNull(doc, \"Doc should not be null here\");\n        // Ensure foundCharset reflects the actual encoding used for the final parse\n        if (foundCharset == null) { // Should not happen if logic above is sound, but as fallback\n            foundCharset = defaultCharset;\n        }\n        doc.outputSettings().charset(foundCharset);\n\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}