{
    "generation": "    // The contents of this method were rewritten as there were many competing objectives, including\n    // - read BOM\n    // - charset detection from meta tags\n    // - support for parsing from InputStream, potentially with wrong charset specified in header\n    // - etc.\n    // The previous implementation resulted in multiple passes and complex logic. My objective is to simplify.\n    // Simplification:\n    // 1. Always read buffer fully into memory. This allows fallback on charset detection failure.\n    // 2. Read BOM. If found, use that charset; String = decode(buffer, bomCharset). goto Done.\n    // 3. If known charset provided, and no BOM, use it; String = decode(buffer, charset). goto Done.\n    // 4. If no BOM, no known charset, try defaultCharSet; String = decode(buffer, default). goto CheckMeta.\n    // CheckMeta:\n    // 5. Look for <meta charset/http-equiv>. If found, String = decode(buffer, metaCharset). goto Done.\n    // 6. If not found, use the default decode attempt. goto Done.\n    // Done:\n    // 7. Parse string. Set Document.outputsettings.\n\n\n    /**\n     * Parse the input ByteBuffer into a Document.\n     * @param byteData data to parse\n     * @param charsetName character set of input; null if not known. Passable charsets are determined by {@link Charset#forName(String)}\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n     * @return Document doc. {@link Document#outputSettings()} will have the character set of the parsed document.\n     */\n    static Document parseByteData(ByteBuffer byteData, @Nullable String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String foundCharset = null;\n        // Use the default charset from StringUtil if available, otherwise fallback to UTF-8\n        final String defaultCharset = DataUtil.defaultCharsetName(); // Use default from DataUtil or UTF-8\n\n        byteData.mark(); // Mark the start position\n\n        // *** 1. Check for BOM ***\n        // Reference: https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n        byte[] bom = new byte[4];\n        int read = Math.min(byteData.remaining(), 4);\n        if (read > 0) byteData.get(bom, 0, read);\n        byteData.reset(); // Reset position to start\n\n        // Order matters: check for longer BOMs first\n        if (read >= 4 && bom[0] == (byte)0x00 && bom[1] == (byte)0x00 && bom[2] == (byte)0xFE && bom[3] == (byte)0xFF) { // UTF-32BE\n            foundCharset = StandardCharsets.UTF_32BE.name(); byteData.position(byteData.position() + 4);\n        } else if (read >= 4 && bom[0] == (byte)0xFF && bom[1] == (byte)0xFE && bom[2] == (byte)0x00 && bom[3] == (byte)0x00) { // UTF-32LE\n            foundCharset = StandardCharsets.UTF_32LE.name(); byteData.position(byteData.position() + 4);\n        } else if (read >= 2 && bom[0] == (byte)0xFE && bom[1] == (byte)0xFF) { // UTF-16BE\n            foundCharset = StandardCharsets.UTF_16BE.name(); byteData.position(byteData.position() + 2);\n        } else if (read >= 2 && bom[0] == (byte)0xFF && bom[1] == (byte)0xFE) { // UTF-16LE\n            foundCharset = StandardCharsets.UTF_16LE.name(); byteData.position(byteData.position() + 2);\n        } else if (read >= 3 && bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) { // UTF-8\n            foundCharset = StandardCharsets.UTF_8.name(); byteData.position(byteData.position() + 3);\n        }\n        // If BOM found, byteData position is advanced, and foundCharset is set.\n        // If not found, byteData position is still at the start, and foundCharset is null.\n\n        String finalCharset;\n\n        if (foundCharset != null) { // ** Case 1: BOM found\n            finalCharset = foundCharset;\n        } else if (charsetName != null) { // ** Case 2: User provided charset, no BOM\n             // Validate the user provided charset name\n            finalCharset = validateCharset(charsetName);\n            if (finalCharset == null) { // Provided charset invalid/unsupported\n                // Keep finalCharset null, fallback to detection / default\n                 Validate.fail(\"Provided charset '\" + charsetName + \"' is not supported or invalid.\"); // Or maybe fallback? Current code errors. Let's stick to erroring for invalid input charset.\n            }\n        } else { // ** Case 3: No BOM, no user charset -> detect from meta or use default\n            finalCharset = null; // Will be determined below\n            byteData.mark(); // Mark position after BOM (or start) for potential reset\n            try {\n                // Decode using default charset for tentative parse\n                Charset defaultCs = Charset.forName(defaultCharset);\n                docData = defaultCs.decode(byteData).toString(); // Consumes buffer from marked position\n                doc = parser.parseInput(docData, baseUri); // Tentative parse\n                Element meta = doc.selectFirst(\"meta[http-equiv=content-type], meta[charset]\");\n                String metaCharset = null;\n                if (meta != null) {\n                    if (meta.hasAttr(\"http-equiv\")) metaCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (metaCharset == null && meta.hasAttr(\"charset\")) metaCharset = meta.attr(\"charset\");\n                }\n\n                if (metaCharset != null) { // Check if found meta charset is valid and supported\n                     String validatedMetaCharset = validateCharset(metaCharset);\n                     if (validatedMetaCharset != null && !validatedMetaCharset.equalsIgnoreCase(defaultCharset)) {\n                        // Meta charset is valid, supported, and different from default\n                        finalCharset = validatedMetaCharset; // Use validated meta charset\n                        doc = null; // Discard the tentatively parsed doc\n                     }\n                }\n            } catch (Exception e) {\n                 // Includes UnsupportedCharsetException, CharacterCodingException, parser exceptions...\n                 // If tentative parse fails, we can't check meta. Fallback below.\n                 doc = null; // Ensure doc is null if tentative parse failed\n            } finally {\n                // Reset buffer position to after BOM / start for final decode, regardless of meta outcome\n                byteData.reset();\n            }\n\n            // If meta detection didn't yield a supported charset different from default, use default\n            if (finalCharset == null) {\n                finalCharset = defaultCharset;\n                // If doc was successfully parsed with default and no overriding meta found, keep it.\n            }\n        }\n\n        // *** Final Decode and Parse ***\n        if (doc == null) { // If tentative parse wasn't done, wasn't successful, or needs to be redone with different charset\n             Validate.notEmpty(finalCharset, \"Charset not determined? Please report bug.\"); // Should always have a charset here\n             try {\n                 Charset cs = Charset.forName(finalCharset);\n                 docData = cs.decode(byteData).toString(); // Decode from current buffer position (after BOM or start)\n                 doc = parser.parseInput(docData, baseUri);\n             } catch (UnsupportedCharsetException | IllegalCharsetNameException e) {\n                 // If the determined charset (from BOM, user, or meta) is unsupported, there's not much we can do.\n                 // The Charset.forName should handle validation, but decode might fail.\n                 // If it came from user input, Validate.fail above handled it.\n                 // If it came from BOM/Meta/Default, this indicates a deeper issue.\n                 // Throwing an informative exception seems appropriate.\n                 throw new UncheckedIOException(\"Unsupported charset specified: \" + finalCharset, e);\n             }\n        }\n\n        // Set the determined charset on the document\n        // Use the charset that was actually used for the final parse\n        doc.outputSettings().charset(finalCharset);\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}