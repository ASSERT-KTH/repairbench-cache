{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors, interfaces or have the @this\n      // or @override annotation. Functions nested in object literals are\n      // handled by the CheckProvides pass.\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() || // Added: Don't traverse interfaces\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; Assignment case handled below.\n      // Object literal methods are handled by CheckProvides. Check\n      // other unlikely cases here.\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n            // GETPROP/GETELEM corresponds to obj.prop = function() {}; handled below\n            pType == Token.GETPROP ||\n            pType == Token.GETELEM ||\n            // STRING_KEY corresponds to obj = { prop: function() {} }; handled by CheckProvides\n            pType == Token.STRING_KEY)) {\n        return false;\n      }\n    }\n\n    // Don't traverse the right side of assignments if the left side is a prototype\n    // property or subproperty assignment.\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == rhs) { // Check the right side (the function node 'n')\n        // Check if the LHS involves '.prototype'. Walk up the LHS GETPROP/GETELEM chain.\n        Node current = lhs;\n        boolean isPrototypeAssign = false;\n        while (current != null && (current.getType() == Token.GETPROP || current.getType() == Token.GETELEM)) {\n            if (current.getType() == Token.GETPROP) {\n                if (current.getLastChild().getString().equals(\"prototype\")) {\n                    isPrototypeAssign = true;\n                    break;\n                }\n            }\n            // Move to the object part of the access\n            current = current.getFirstChild();\n        }\n\n        if (isPrototypeAssign) {\n            return false; // Don't traverse the function assigned to prototype\n        }\n      }\n      // Note: The original code had special handling for `assignLhsChild` when n == lhs.\n      // This state variable is managed by the CheckGlobalThis pass itself in its\n      // visit/shouldTraverse methods and doesn't need modification here based on\n      // the failing tests provided. We focus on skipping the RHS function body traversal.\n    }\n\n    return true; // Traverse by default\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}