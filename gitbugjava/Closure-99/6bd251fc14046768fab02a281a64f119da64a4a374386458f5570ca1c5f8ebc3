{
    "generation": "import com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeUtil;\n\n// Assuming this method is part of a class that implements NodeTraversal.Callback\n\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override // Add Override if this method implements an interface method\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors, interfaces or have the @this\n      // or @override annotation. These functions are methods or documented\n      // constructors/interfaces, so 'this' refers to the object instance, not the global scope.\n      // Use getBestJSDocInfo to get JSDoc from the parent node if necessary\n      // (e.g., for var declarations like: var x = /** @constructor */ function() {};)\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() || // Added: skip @interface functions\n           jsDoc.hasThisType() || // @this specifies the type of 'this'\n           jsDoc.isOverride())) { // @override implies it's a method\n        return false;\n      }\n\n      // Don't traverse functions unless they are defined in a scope where 'this'\n      // might be global. We skip functions defined as methods in object literals\n      // or assigned to prototype properties (handled below).\n      if (parent != null) {\n        int pType = parent.getType();\n\n        // Functions defined inside object literals: { method: function() {...} }\n        // 'this' refers to the object literal.\n        if (parent.isObjectLit()) {\n             return false;\n        }\n\n        // Allow traversal for functions defined in blocks, scripts, named function\n        // declarations, and assignments, as these *might* be global 'this'.\n        // Other contexts (like arguments to calls, return values) usually imply\n        // 'this' is not global or is bound elsewhere.\n        if (!(pType == Token.BLOCK ||\n              pType == Token.SCRIPT ||\n              pType == Token.NAME || // function declaration: function f() {}\n              pType == Token.ASSIGN)) { // Assignment: x = function() {} or o.p = function() {}\n          return false;\n        }\n      } else if (n.getParent() != null && n.getParent().isScript()) {\n         // Function declaration in global scope (already handled by pType == Token.SCRIPT)\n      } else {\n         // Function node without a parent or not in SCRIPT? Avoid traversal.\n         return false;\n      }\n    }\n\n    // Don't traverse the right side of an assignment if the left side\n    // is a prototype property or sub-property.\n    // Examples: Foo.prototype = function() {};\n    //           Foo.prototype.bar = function() {};\n    //           Foo.prototype['bar'] = function() {};\n    // In these cases, the function is a method, and 'this' refers to the instance.\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == rhs) { // Only check when traversing the RHS (the function)\n        // NodeUtil.isPrototypeProperty() checks for assignments to \".prototype\"\n        // or \".prototype.something\" or \"['prototype']\" etc.\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n          return false;\n        }\n      }\n      // Always traverse the LHS of an assignment.\n    }\n\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}