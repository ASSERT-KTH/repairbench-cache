{
    "generation": "    /**\n     * Builds the {@link BackOffPolicy} with the given parameters.\n     * @return the {@link BackOffPolicy} instance\n     */\n    public BackOffPolicy build() {\n        // Exponential backoff if a multiplier (direct or supplied) is present\n        if ((this.multiplier != null && this.multiplier > 0) || this.multiplierSupplier != null) {\n            ExponentialBackOffPolicy policy = Boolean.TRUE.equals(this.random)\n                    ? new ExponentialRandomBackOffPolicy()\n                    : new ExponentialBackOffPolicy();\n            // initial interval\n            if (this.delay != null) {\n                policy.setInitialInterval(this.delay);\n            }\n            if (this.delaySupplier != null) {\n                long initial = this.delaySupplier.get();\n                policy.setInitialInterval(initial);\n                policy.initialIntervalSupplier(this.delaySupplier);\n            }\n            // multiplier\n            if (this.multiplier != null) {\n                policy.setMultiplier(this.multiplier);\n            }\n            if (this.multiplierSupplier != null) {\n                double mult = this.multiplierSupplier.get();\n                policy.setMultiplier(mult);\n                policy.multiplierSupplier(this.multiplierSupplier);\n            }\n            // max interval\n            if (this.maxDelay != null && this.delay != null) {\n                policy.setMaxInterval(this.maxDelay > this.delay\n                        ? this.maxDelay\n                        : ExponentialBackOffPolicy.DEFAULT_MAX_INTERVAL);\n            }\n            if (this.maxDelaySupplier != null) {\n                long max = this.maxDelaySupplier.get();\n                policy.setMaxInterval(max);\n                policy.maxIntervalSupplier(this.maxDelaySupplier);\n            }\n            // sleeper\n            if (this.sleeper != null) {\n                policy.setSleeper(this.sleeper);\n            }\n            return policy;\n        }\n\n        // Uniform random backoff if both min and max are specified (directly)\n        if (this.maxDelay != null && this.delay != null && this.maxDelay > this.delay) {\n            UniformRandomBackOffPolicy policy = new UniformRandomBackOffPolicy();\n            // min period\n            if (this.delay != null) {\n                policy.setMinBackOffPeriod(this.delay);\n            }\n            if (this.delaySupplier != null) {\n                long min = this.delaySupplier.get();\n                policy.setMinBackOffPeriod(min);\n                policy.minBackOffPeriodSupplier(this.delaySupplier);\n            }\n            // max period\n            if (this.maxDelay != null) {\n                policy.setMaxBackOffPeriod(this.maxDelay);\n            }\n            if (this.maxDelaySupplier != null) {\n                long max = this.maxDelaySupplier.get();\n                policy.setMaxBackOffPeriod(max);\n                policy.maxBackOffPeriodSupplier(this.maxDelaySupplier);\n            }\n            // sleeper\n            if (this.sleeper != null) {\n                policy.setSleeper(this.sleeper);\n            }\n            return policy;\n        }\n\n        // Fixed backoff otherwise\n        FixedBackOffPolicy policy = new FixedBackOffPolicy();\n        if (this.delay != null) {\n            policy.setBackOffPeriod(this.delay);\n        }\n        if (this.delaySupplier != null) {\n            long period = this.delaySupplier.get();\n            policy.setBackOffPeriod(period);\n        }\n        if (this.sleeper != null) {\n            policy.setSleeper(this.sleeper);\n        }\n        return policy;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}