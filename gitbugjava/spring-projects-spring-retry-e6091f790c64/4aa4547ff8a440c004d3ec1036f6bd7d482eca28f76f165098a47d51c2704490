{
    "generation": "\t/**\n\t * Builds the {@link BackOffPolicy} with the given parameters.\n\t * @return the {@link BackOffPolicy} instance\n\t */\n\tpublic BackOffPolicy build() {\n\t\t// Determine if Exponential policy is requested\n\t\tboolean isExponential = (this.multiplier != null && this.multiplier > 0) || this.multiplierSupplier != null;\n\n\t\tif (isExponential) {\n\t\t\tExponentialBackOffPolicy policy;\n\t\t\tif (Boolean.TRUE.equals(this.random)) {\n\t\t\t\tpolicy = new ExponentialRandomBackOffPolicy();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpolicy = new ExponentialBackOffPolicy();\n\t\t\t}\n\t\t\t// Set initial interval using value or supplier\n\t\t\tif (this.delay != null) {\n\t\t\t\tpolicy.setInitialInterval(this.delay);\n\t\t\t}\n\t\t\tif (this.delaySupplier != null) {\n\t\t\t\tpolicy.initialIntervalSupplier(this.delaySupplier);\n\t\t\t}\n\t\t\t// Set multiplier using value or supplier\n\t\t\tif (this.multiplier != null) {\n\t\t\t\tpolicy.setMultiplier(this.multiplier);\n\t\t\t}\n\t\t\tif (this.multiplierSupplier != null) {\n\t\t\t\tpolicy.multiplierSupplier(this.multiplierSupplier);\n\t\t\t}\n\t\t\t// Set max interval using value or supplier\n\t\t\t// Original logic only set maxInterval if both maxDelay and delay (value) were set,\n\t\t\t// and used DEFAULT_MAX_INTERVAL if maxDelay <= delay.\n\t\t\t// Simplified: Set max interval if 'this.maxDelay' value is provided.\n\t\t\t// The policy itself should handle validation (e.g., maxInterval >= initialInterval).\n\t\t\tif (this.maxDelay != null) {\n\t\t\t\tpolicy.setMaxInterval(this.maxDelay);\n\t\t\t}\n\t\t\t// Set max interval supplier if provided\n\t\t\tif (this.maxDelaySupplier != null) {\n\t\t\t\tpolicy.maxIntervalSupplier(this.maxDelaySupplier);\n\t\t\t}\n\t\t\t// Set sleeper if provided\n\t\t\tif (this.sleeper != null) {\n\t\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t\t}\n\t\t\treturn policy;\n\t\t}\n\n\t\t// Determine if UniformRandom policy is requested (and not exponential)\n\t\t// Original condition: this.maxDelay != null && this.delay != null && this.maxDelay > this.delay\n\t\t// This condition remains, as it specifically selects UniformRandom *only* if a specific range is given via direct values.\n\t\tif (this.maxDelay != null && this.delay != null && this.maxDelay > this.delay) {\n\t\t\tUniformRandomBackOffPolicy policy = new UniformRandomBackOffPolicy();\n\t\t\t// Set min period using value or supplier\n\t\t\tif (this.delay != null) {\n\t\t\t\tpolicy.setMinBackOffPeriod(this.delay);\n\t\t\t}\n\t\t\tif (this.delaySupplier != null) {\n\t\t\t\tpolicy.minBackOffPeriodSupplier(this.delaySupplier);\n\t\t\t}\n\t\t\t// Set max period using value or supplier\n\t\t\tif (this.maxDelay != null) {\n\t\t\t\tpolicy.setMaxBackOffPeriod(this.maxDelay);\n\t\t\t}\n\t\t\tif (this.maxDelaySupplier != null) {\n\t\t\t\tpolicy.maxBackOffPeriodSupplier(this.maxDelaySupplier);\n\t\t\t}\n\t\t\t// Set sleeper if provided\n\t\t\tif (this.sleeper != null) {\n\t\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t\t}\n\t\t\treturn policy;\n\t\t}\n\n\t\t// Default to FixedBackOffPolicy if neither Exponential nor UniformRandom conditions met\n\t\tFixedBackOffPolicy policy = new FixedBackOffPolicy();\n\t\t// Set backoff period if value is provided\n\t\tif (this.delay != null) {\n\t\t\tpolicy.setBackOffPeriod(this.delay);\n\t\t}\n\t\t// Note: FixedBackOffPolicy does not support suppliers for backOffPeriod.\n\t\t// If only delaySupplier is set, it won't be used here.\n\t\tif (this.delaySupplier != null && this.delay == null) {\n\t\t\t// Log or handle the case where only supplier is provided for FixedBackOffPolicy?\n\t\t\t// For now, stick to original behavior where only direct value is used.\n\t\t}\n\t\t// Set sleeper if provided\n\t\tif (this.sleeper != null) {\n\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t}\n\t\treturn policy;\n\t}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}