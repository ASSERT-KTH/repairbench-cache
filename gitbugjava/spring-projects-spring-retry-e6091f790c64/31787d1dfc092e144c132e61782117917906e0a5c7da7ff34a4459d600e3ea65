{
    "generation": "/**\n * Builds the {@link BackOffPolicy} with the given parameters.\n * @return the {@link BackOffPolicy} instance\n */\npublic BackOffPolicy build() {\n    // Exponential backoff if a multiplier was specified\n    if ((this.multiplier != null && this.multiplier > 0) || this.multiplierSupplier != null) {\n        ExponentialBackOffPolicy policy = Boolean.TRUE.equals(this.random)\n                ? new ExponentialRandomBackOffPolicy()\n                : new ExponentialBackOffPolicy();\n\n        // resolve static values (give precedence to a numeric value or, if absent, evaluate the supplier)\n        Long initial = (this.delay != null\n                ? this.delay\n                : (this.delaySupplier != null ? this.delaySupplier.get() : null));\n        Double factor = (this.multiplier != null\n                ? this.multiplier\n                : (this.multiplierSupplier != null ? this.multiplierSupplier.get() : null));\n        Long max = (this.maxDelay != null\n                ? this.maxDelay\n                : (this.maxDelaySupplier != null ? this.maxDelaySupplier.get() : null));\n\n        if (initial != null) {\n            policy.setInitialInterval(initial);\n        }\n        if (factor != null) {\n            policy.setMultiplier(factor);\n        }\n        if (initial != null && max != null) {\n            policy.setMaxInterval(max > initial\n                    ? max\n                    : ExponentialBackOffPolicy.DEFAULT_MAX_INTERVAL);\n        }\n\n        // now register any suppliers for dynamic evaluation\n        if (this.delaySupplier != null) {\n            policy.initialIntervalSupplier(this.delaySupplier);\n        }\n        if (this.multiplierSupplier != null) {\n            policy.multiplierSupplier(this.multiplierSupplier);\n        }\n        if (this.maxDelaySupplier != null) {\n            policy.maxIntervalSupplier(this.maxDelaySupplier);\n        }\n        if (this.sleeper != null) {\n            policy.setSleeper(this.sleeper);\n        }\n        return policy;\n    }\n\n    // Uniform\u2010random backoff if both a min and a max delay were explicitly provided\n    if (this.maxDelay != null && this.delay != null && this.maxDelay > this.delay) {\n        UniformRandomBackOffPolicy policy = new UniformRandomBackOffPolicy();\n\n        if (this.delay != null) {\n            policy.setMinBackOffPeriod(this.delay);\n        }\n        if (this.delaySupplier != null) {\n            policy.minBackOffPeriodSupplier(this.delaySupplier);\n        }\n        if (this.maxDelay != null) {\n            policy.setMaxBackOffPeriod(this.maxDelay);\n        }\n        if (this.maxDelaySupplier != null) {\n            policy.maxBackOffPeriodSupplier(this.maxDelaySupplier);\n        }\n        if (this.sleeper != null) {\n            policy.setSleeper(this.sleeper);\n        }\n        return policy;\n    }\n\n    // Fixed backoff otherwise\n    FixedBackOffPolicy policy = new FixedBackOffPolicy();\n    if (this.delay != null) {\n        policy.setBackOffPeriod(this.delay);\n    }\n    else if (this.delaySupplier != null) {\n        // support a supplier for fixed backoff as well\n        policy.backOffPeriodSupplier(this.delaySupplier);\n    }\n    if (this.sleeper != null) {\n        policy.setSleeper(this.sleeper);\n    }\n    return policy;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}