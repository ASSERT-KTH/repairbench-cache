{
    "generation": "\t/**\n\t * Builds the {@link BackOffPolicy} with the given parameters.\n\t * @return the {@link BackOffPolicy} instance\n\t */\n\tpublic BackOffPolicy build() {\n\t\tif (this.multiplier != null && this.multiplier > 0 || this.multiplierSupplier != null) {\n\t\t\tExponentialBackOffPolicy policy;\n\t\t\tif (Boolean.TRUE.equals(this.random)) {\n\t\t\t\tpolicy = new ExponentialRandomBackOffPolicy();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpolicy = new ExponentialBackOffPolicy();\n\t\t\t}\n\t\t\tif (this.delay != null) {\n\t\t\t\tpolicy.setInitialInterval(this.delay);\n\t\t\t}\n\t\t\tif (this.delaySupplier != null) {\n\t\t\t\tpolicy.initialIntervalSupplier(this.delaySupplier);\n\t\t\t}\n\t\t\tif (this.multiplier != null) {\n\t\t\t\tpolicy.setMultiplier(this.multiplier);\n\t\t\t}\n\t\t\tif (this.multiplierSupplier != null) {\n\t\t\t\tpolicy.multiplierSupplier(this.multiplierSupplier);\n\t\t\t}\n\n\t\t\t// Fixed logic for setting maxInterval\n\t\t\tif (this.maxDelay != null) {\n\t\t\t\t// Get the actual initial interval that the policy will use,\n\t\t\t\t// considering values from this.delay and/or this.delaySupplier, or defaults.\n\t\t\t\tlong actualInitialInterval = policy.getInitialInterval();\n\t\t\t\tif (this.maxDelay > actualInitialInterval) {\n\t\t\t\t\tpolicy.setMaxInterval(this.maxDelay);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If the configured maxDelay is not greater than the actual initial interval,\n\t\t\t\t\t// fall back to the policy's default maximum interval.\n\t\t\t\t\t// This maintains the behavior of not letting maxInterval collapse to initialInterval\n\t\t\t\t\t// if a small or invalid maxDelay is provided.\n\t\t\t\t\tpolicy.setMaxInterval(ExponentialBackOffPolicy.DEFAULT_MAX_INTERVAL);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.maxDelaySupplier != null) {\n\t\t\t\tpolicy.maxIntervalSupplier(this.maxDelaySupplier);\n\t\t\t}\n\t\t\tif (this.sleeper != null) {\n\t\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t\t}\n\t\t\treturn policy;\n\t\t}\n\t\tif (this.maxDelay != null && this.delay != null && this.maxDelay > this.delay) {\n\t\t\tUniformRandomBackOffPolicy policy = new UniformRandomBackOffPolicy();\n\t\t\tif (this.delay != null) {\n\t\t\t\tpolicy.setMinBackOffPeriod(this.delay);\n\t\t\t}\n\t\t\tif (this.delaySupplier != null) {\n\t\t\t\tpolicy.minBackOffPeriodSupplier(this.delaySupplier);\n\t\t\t}\n\t\t\tif (this.maxDelay != null) {\n\t\t\t\tpolicy.setMaxBackOffPeriod(this.maxDelay);\n\t\t\t}\n\t\t\tif (this.maxDelaySupplier != null) {\n\t\t\t\tpolicy.maxBackOffPeriodSupplier(this.maxDelaySupplier);\n\t\t\t}\n\t\t\tif (this.sleeper != null) {\n\t\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t\t}\n\t\t\treturn policy;\n\t\t}\n\t\tFixedBackOffPolicy policy = new FixedBackOffPolicy();\n\t\tif (this.delay != null) {\n\t\t\tpolicy.setBackOffPeriod(this.delay);\n\t\t}\n\t\t// Note: The original code does not check for this.delaySupplier for FixedBackOffPolicy.\n\t\t// If this.delaySupplier is intended to be used for FixedBackOffPolicy too,\n\t\t// a line like `if (this.delaySupplier != null) { policy.setBackOffPeriodSupplier(this.delaySupplier); }`\n\t\t// would be needed here for consistency. However, the fix is focused on the identified bug\n\t\t// related to ExponentialBackOffPolicy and its maxInterval configuration.\n\t\tif (this.sleeper != null) {\n\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t}\n\t\treturn policy;\n\t}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}