{
    "generation": "\t/**\n\t * Builds the {@link BackOffPolicy} with the given parameters.\n\t * @return the {@link BackOffPolicy} instance\n\t */\n\tpublic BackOffPolicy build() {\n\t\t// Helper flags to simplify and correct policy selection logic,\n\t\t// considering both direct values and their suppliers.\n\t\tboolean hasDelay = this.delay != null || this.delaySupplier != null;\n\t\tboolean hasMultiplier = this.multiplier != null || this.multiplierSupplier != null;\n\t\tboolean hasMaxDelay = this.maxDelay != null || this.maxDelaySupplier != null;\n\t\tboolean hasRandom = Boolean.TRUE.equals(this.random);\n\n\t\t// 1. ExponentialBackOffPolicy:\n\t\t// Chosen if a multiplier (or its supplier) is defined.\n\t\tif (hasMultiplier) {\n\t\t\tExponentialBackOffPolicy policy;\n\t\t\tif (hasRandom) {\n\t\t\t\tpolicy = new ExponentialRandomBackOffPolicy();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpolicy = new ExponentialBackOffPolicy();\n\t\t\t}\n\t\t\tif (this.delay != null) {\n\t\t\t\tpolicy.setInitialInterval(this.delay);\n\t\t\t}\n\t\t\tif (this.delaySupplier != null) {\n\t\t\t\tpolicy.initialIntervalSupplier(this.delaySupplier);\n\t\t\t}\n\t\t\tif (this.multiplier != null) {\n\t\t\t\tpolicy.setMultiplier(this.multiplier);\n\t\t\t}\n\t\t\tif (this.multiplierSupplier != null) {\n\t\t\t\tpolicy.multiplierSupplier(this.multiplierSupplier);\n\t\t\t}\n\t\t\t// Retain original defensive maxInterval logic for ExponentialBackOffPolicy\n\t\t\tif (this.maxDelay != null && this.delay != null) {\n\t\t\t\tpolicy.setMaxInterval(\n\t\t\t\t\t\tthis.maxDelay > this.delay ? this.maxDelay : ExponentialBackOffPolicy.DEFAULT_MAX_INTERVAL);\n\t\t\t}\n\t\t\tif (this.maxDelaySupplier != null) {\n\t\t\t\tpolicy.maxIntervalSupplier(this.maxDelaySupplier);\n\t\t\t}\n\t\t\tif (this.sleeper != null) {\n\t\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t\t}\n\t\t\treturn policy;\n\t\t}\n\n\t\t// 2. UniformRandomBackOffPolicy:\n\t\t// Chosen if no multiplier, but both initial (min) and max delays\n\t\t// (or their suppliers) are effectively defined.\n\t\t// The original condition was too restrictive by only checking concrete values.\n\t\tif (hasDelay && hasMaxDelay) {\n\t\t\tUniformRandomBackOffPolicy policy = new UniformRandomBackOffPolicy();\n\t\t\tif (this.delay != null) {\n\t\t\t\tpolicy.setMinBackOffPeriod(this.delay);\n\t\t\t}\n\t\t\tif (this.delaySupplier != null) {\n\t\t\t\tpolicy.minBackOffPeriodSupplier(this.delaySupplier);\n\t\t\t}\n\t\t\tif (this.maxDelay != null) {\n\t\t\t\tpolicy.setMaxBackOffPeriod(this.maxDelay);\n\t\t\t}\n\t\t\tif (this.maxDelaySupplier != null) {\n\t\t\t\tpolicy.maxBackOffPeriodSupplier(this.maxDelaySupplier);\n\t\t\t}\n\t\t\tif (this.sleeper != null) {\n\t\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t\t}\n\t\t\treturn policy;\n\t\t}\n\n\t\t// 3. FixedBackOffPolicy:\n\t\t// This is the default/fallback policy if neither Exponential nor UniformRandom conditions are met.\n\t\t// FixedBackOffPolicy does not support a Supplier for its back-off period directly.\n\t\t// If 'delay' is null but 'delaySupplier' is present, we must resolve the value from the supplier here.\n\t\tFixedBackOffPolicy policy = new FixedBackOffPolicy();\n\t\tLong backOffPeriod = this.delay; // Start with the explicitly set delay value\n\n\t\t// If no explicit delay value is set, but a supplier is provided, resolve it.\n\t\tif (backOffPeriod == null && this.delaySupplier != null) {\n\t\t\tbackOffPeriod = this.delaySupplier.get();\n\t\t}\n\n\t\tif (backOffPeriod != null) {\n\t\t\tpolicy.setBackOffPeriod(backOffPeriod);\n\t\t}\n\t\t// If backOffPeriod is still null (neither explicit delay nor supplier was provided),\n\t\t// FixedBackOffPolicy will use its default value (1000L).\n\n\t\tif (this.sleeper != null) {\n\t\t\tpolicy.setSleeper(this.sleeper);\n\t\t}\n\t\treturn policy;\n\t}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}