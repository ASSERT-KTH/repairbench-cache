{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // Calculate an initial guess of the offset, by treating the local instant\n        // as a UTC instant. This estimate will be corrected later.\n        final int offsetLocal = getOffset(instantLocal);\n\n        // Calculate the UTC instant based on the initial guess of the offset.\n        final long instantAdjusted = instantLocal - offsetLocal;\n        // Get the offset for the estimated UTC instant. This is often the correct offset.\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // Calculate the UTC instant based on the second offset guess.\n        final long instantBasedOnAdjusted = instantLocal - offsetAdjusted;\n        // Get the offset for this potentially more accurate UTC instant.\n        final int finalOffset = getOffset(instantBasedOnAdjusted);\n\n        // Check if the second offset guess (offsetAdjusted) is consistent.\n        // If finalOffset is the same as offsetAdjusted, it means that\n        // instantLocal - offsetAdjusted maps to a UTC instant that has offsetAdjusted.\n        if (finalOffset == offsetAdjusted) {\n            // The offsetAdjusted is consistent. Now, check for overlaps.\n            // An overlap occurs if the initial offset guess (offsetLocal) is *also* consistent.\n            long instantBasedOnLocal = instantLocal - offsetLocal;\n            if (getOffset(instantBasedOnLocal) == offsetLocal) {\n                 // Both offsetLocal and offsetAdjusted could be consistent mappings for instantLocal.\n                 if (offsetLocal != offsetAdjusted) {\n                     // The offsets are different, confirming an overlap based on the initial estimates.\n                     // Rule for overlaps: Favor DST/Summer time. Assume this corresponds to the maximum offset.\n                     return Math.max(offsetLocal, offsetAdjusted);\n                 }\n                 // If offsetLocal == offsetAdjusted, it might still be an overlap if the\n                 // initial guess landed on the standard time during an overlap.\n                 // Perform a more robust check using the transition history near the estimated UTC instant.\n                 // Use instantBasedOnAdjusted as it's our best estimate of the UTC instant.\n                 // Add 1 millisecond to avoid potential issues if the instant is exactly on a transition.\n                 long transition = previousTransition(instantBasedOnAdjusted + 1);\n                 // Ensure the transition is strictly before the estimated UTC instant.\n                 if (transition < instantBasedOnAdjusted) {\n                     int offsetBefore = getOffset(transition - 1); // Offset effective right before the transition\n                     if (offsetBefore != offsetAdjusted) { // Check if the offset actually changed across this transition\n                         // Verify if this offsetBefore is also a consistent mapping for instantLocal\n                         long instantBeforeUTC = instantLocal - offsetBefore;\n                         if (getOffset(instantBeforeUTC) == offsetBefore) {\n                             // The offsetBefore is also consistent. Overlap confirmed.\n                             // Rule for overlaps: Favor DST/Summer time (max offset).\n                             return Math.max(offsetBefore, offsetAdjusted);\n                         }\n                     }\n                 }\n                 // No overlap detected through the transition check, or initial offsets were same.\n                 // Return the consistent offsetAdjusted.\n                 return offsetAdjusted;\n            } else {\n                 // Only offsetAdjusted was consistent based on the initial checks. Return it.\n                 // This handles normal time or edge cases near transitions where only one offset maps correctly.\n                 return offsetAdjusted;\n            }\n        } else {\n            // finalOffset != offsetAdjusted. This indicates inconsistency, typically meaning instantLocal\n            // falls within a DST gap where neither offset works perfectly backwards.\n            // Rule for gaps: Return the offset suitable for calculating the instant *after* the gap.\n            // The calculation chain offsetLocal -> instantAdjusted -> offsetAdjusted -> instantBasedOnAdjusted -> finalOffset\n            // effectively probes the offsets around the transition. When they differ, finalOffset\n            // represents the offset calculated using the offset from the other side of the transition,\n            // which corresponds to the offset *after* the gap.\n            return finalOffset;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}