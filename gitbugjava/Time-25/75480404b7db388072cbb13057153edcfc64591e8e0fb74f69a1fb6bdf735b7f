{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // Check if we are in an overlap period. This occurs when the offset decreased,\n            // meaning offsetLocal > offsetAdjusted (e.g., +4 an hour ago vs +3 now).\n            // For overlaps, the documentation requires returning the earlier instant's offset,\n            // which means favouring DST (summer) time = the larger offset.\n            if (offsetLocal > offsetAdjusted) {\n                 // Return the larger offset (offsetLocal), which corresponds to DST/summer time.\n                 return offsetLocal;\n            }\n            // Original code for handling the gap (offsetLocal < offsetAdjusted)\n            // This block handles cases where the offset increases (e.g., +1 to +2),\n            // indicating a gap in local time. The goal is to return an offset\n            // that places the ambiguous time *after* the gap.\n            // The complex transition check below might handle edge cases at the exact\n            // transition point. If the check fails, it falls through to return offsetAdjusted.\n            // offsetAdjusted should be the offset *after* the gap.\n            // Note: The logic `return offsetLocal;` inside the check seems questionable\n            // for gaps, but we preserve the original structure as the tests focus on overlaps.\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n            // Fall through intended for gap cases where the next transition is consistent,\n            // returning the offset after the gap (offsetAdjusted).\n        }\n        // If offsets are equal, or if it's a gap and the nextTransition logic fell through,\n        // return offsetAdjusted. This assumes the calculation converged correctly for non-ambiguous times\n        // or correctly resolved the gap situation.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}