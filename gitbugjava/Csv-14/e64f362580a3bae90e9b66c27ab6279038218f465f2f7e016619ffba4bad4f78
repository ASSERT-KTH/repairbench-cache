{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset; // pos is used for scanning in MINIMAL mode\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharObj = getQuoteCharacter(); // Keep as Character object initially\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                final char firstChar = value.charAt(start);\n                // In case of len=1, firstChar == lastChar. This check is thus safe.\n                final char lastChar = value.charAt(end - 1);\n\n                // Define conditions for quoting:\n                // Note: The tests require specific handling for MINIMAL mode. We should only quote if\n                // - the field contains the delimiter, quote character, or record separator (CR/LF).\n                // - the field starts or ends with whitespace (here defined as <= SP).\n                // - the field is empty on a new record (handled above).\n                // - the field starts with the comment character on a new record (commons-csv specific).\n\n                // 1. Check for leading or trailing whitespace (SP = Space, ASCII 32)\n                if (firstChar <= SP || lastChar <= SP) {\n                    quote = true;\n                } else {\n                    // 2. Check if comment character starts the field on a new record (if comments enabled)\n                    final Character commentStart = getCommentMarker();\n                    if (newRecord && commentStart != null && commentStart.charValue() == firstChar) {\n                        quote = true;\n                    } else {\n                        // 3. Scan for internal special characters (delimiter, quote char, newlines LF, CR)\n                        // Need the actual quote char here if quoting is potentially active.\n                        final boolean quotingActive = quoteCharObj != null;\n                        final char qChar = quotingActive ? quoteCharObj.charValue() : Constants.UNDEFINED; // Use a local variable\n\n                        // Scan the field using 'pos', starting from the beginning.\n                        pos = start; // Reset pos for scanning the whole field\n                        while (pos < end) {\n                            final char c = value.charAt(pos);\n                            // Check for LF, CR, Delimiter, or Quote Character (if quoting is active)\n                            if (c == LF || c == CR || c == delimChar || (quotingActive && c == qChar)) {\n                                quote = true;\n                                break; // Found a character requiring quoting\n                            }\n                            pos++;\n                        }\n                        // Note: The check for trailing space (lastChar <= SP) was already done upfront.\n                    }\n                }\n            }\n\n            // If MINIMAL decided not to quote after all checks, print and return\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // Fall through to the quoting logic below if quote = true\n            break; // End of MINIMAL case\n\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End of switch\n\n        // ----- Quoting Logic -----\n        // If quote is false (e.g., NON_NUMERIC found a number), print directly and return.\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n\n        // If we are here, quote is true. We MUST have a quote character.\n        // This will throw NullPointerException if quoteCharObj is null, which is the expected behavior\n        // if the format is inconsistent (e.g., QuoteMode.ALL without a quote character defined).\n        final char quoteChar = quoteCharObj.charValue();\n\n        // Append the opening quote character\n        out.append(quoteChar);\n\n        // Reset start and pos for the loop that handles quote character doubling.\n        start = offset; // Represents the start of the current segment to append\n        for (pos = offset; pos < end; pos++) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // Append the segment before the quote character\n                out.append(value, start, pos);\n                // Append the quote character twice (escaping it)\n                out.append(quoteChar);\n                out.append(quoteChar);\n                // Update the start position for the next segment to be after the quote character\n                start = pos + 1;\n            }\n            // Note: When quoting is active (as it is here), the escape character is NOT used according to RFC4180.\n            // Only quote character doubling is performed.\n        }\n\n        // Append the remaining segment (from the last quote character to the end, or the whole string if no quotes were found)\n        out.append(value, start, end); // 'end' is the exclusive boundary index\n\n        // Append the closing quote character\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}