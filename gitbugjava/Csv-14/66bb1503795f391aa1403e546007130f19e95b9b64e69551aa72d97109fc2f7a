{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        // Use final int for start/end to avoid confusion with loop variables\n        final int start = offset;\n        final int end = offset + len;\n        int pos = offset; // pos is used by the original MINIMAL logic loop\n\n        final char delimChar = getDelimiter();\n        // Ensure quote char is available (guaranteed by CSVFormat if quoting is enabled)\n        final Character quoteCharOption = getQuoteCharacter();\n        // Escape character may be null\n        final Character escapeCharOption = getEscapeCharacter();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code - this mode bypasses quoting determination.\n            // It assumes printAndEscape handles escapeCharOption == null correctly.\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            // --- Start of original MINIMAL quoting logic ---\n            // Check if quoting is needed based on content and context\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos); // pos initially equals offset\n\n                // Define constants used in original logic (assuming standard values)\n                final char LF = '\\n';\n                final char CR = '\\r';\n                final char SP = ' ';\n                // Get quote char if set, needed for checks (use a sentinel value if null, though format should prevent null here)\n                final char quoteChar = quoteCharOption != null ? quoteCharOption.charValue() : '\"'; // Default fallback if null? Format likely prevents.\n\n                // Check based on first character (original logic)\n                // This complex condition might be for specific parser compatibility.\n                 if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                     quote = true;\n                 }\n                 // Original check used hardcoded '#' - assuming it meant comment marker or similar boundary\n                 // Let's refine to check for leading space or standard separators first.\n                 else if (c <= SP || c == delimChar || c == LF || c == CR || c == quoteChar) {\n                    quote = true;\n                 } else {\n                    // Internal loop checking for critical characters\n                    // This loop modifies 'pos', state is used later if quote becomes true here.\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break; // pos left at triggering char\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) { // If loop did not find a trigger\n                        // Check last char <= SP without modifying 'pos' state\n                        // (Original code reset pos = end - 1 here, potentially breaking quoting loop state)\n                        char lastChar = value.charAt(end - 1);\n                        if (lastChar <= SP) {\n                            quote = true;\n                            // If quote becomes true here, original 'pos' remains 'end' (from the loop finishing)\n                            // The subsequent quoting `while(pos < end)` loop won't run, which is correct.\n                        }\n                    }\n                }\n            }\n            // --- End of original MINIMAL quoting logic ---\n            break; // Break from MINIMAL case\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End switch\n\n        // --- Decision Point ---\n        if (!quote) {\n            // Not quoting based on policy. Check if escape character is defined.\n            if (escapeCharOption != null) {\n                // Delegate to escape function if escape char is defined.\n                // Assumes printAndEscape handles escaping correctly based on escapeCharOption.\n                printAndEscape(value, offset, len, out);\n            } else {\n                // No quote, no escape: print raw value.\n                out.append(value, start, end); // Use original start/end indices\n            }\n            return; // Finished processing this field\n        }\n\n        // --- Apply Quoting ---\n        // If we reach here, 'quote' is true. Use the original quote-doubling logic.\n        // This logic relies on the state of 'pos' as set by the MINIMAL check section.\n        // We also need the actual quote character.\n        final char quoteChar = quoteCharOption.charValue(); // Should be non-null if quote=true\n        out.append(quoteChar);\n\n        // Use a separate variable for the start of the segment being written.\n        int segmentStart = start;\n        // The loop starts from 'pos', which is where the MINIMAL check loop left it\n        // (either at the trigger char, or offset if triggered early, or end if triggered by last char).\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point (and the quote)\n                out.append(value, segmentStart, pos + 1);\n                // next segment starts at the quote char (effectively doubling it)\n                // Note: original code set start = pos, which works because the next append\n                // implicitly includes the char at 'start'. Let's stick to that.\n                segmentStart = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment (from last quote encountered or start, up to end)\n        out.append(value, segmentStart, end); // Use 'end', as 'pos' equals 'end' after loop\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}