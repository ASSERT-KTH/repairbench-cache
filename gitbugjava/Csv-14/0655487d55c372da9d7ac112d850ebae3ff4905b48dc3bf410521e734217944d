{
    "generation": "    // Constants for characters used in CSV format (assuming they are defined in the class or accessible)\n    // private static final char LF = '\\n';\n    // private static final char CR = '\\r';\n    // private static final char SP = ' ';\n\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset; // pos for scanning inside MINIMAL mode or for the final quoting loop\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharNullable = getQuoteCharacter(); // Quote char can be null\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code, handles null quote char\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            // MINIMAL mode requires a quote character.\n            if (quoteCharNullable == null) {\n                 // If quote char is null, MINIMAL is same as NONE.\n                 printAndEscape(value, offset, len, out);\n                 return;\n            }\n            final char quoteChar = quoteCharNullable.charValue(); // Safe now\n\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char firstChar = value.charAt(start);\n                char lastChar = value.charAt(end - 1);\n                final Character commentChar = getCommentMarker();\n                // isCommentMarkerSet() checks if commentChar is not null\n                final boolean commentMarkerSet = isCommentMarkerSet();\n\n                // Check for mandatory quoting conditions first (delimiter, quote char, CR, LF)\n                // Use a local variable for scanning to avoid interfering with outer 'pos' used later\n                int scanPos = start;\n                while (scanPos < end) {\n                    final char c = value.charAt(scanPos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    scanPos++;\n                }\n\n                if (!quote) {\n                    // Check for optional/compatibility conditions if not already quoted\n                    // Quote if starts or ends with whitespace (or control characters <= SP)\n                    // Note: The original code only checked the last char against SP.\n                    // Checking both first and last seems more consistent for whitespace sensitivity.\n                    if (firstChar <= SP || lastChar <= SP) {\n                        quote = true;\n                    } else if (commentMarkerSet && firstChar == commentChar.charValue()) {\n                        // Quote if starts with comment marker (and comments are enabled)\n                        // Note: The original code checked firstChar <= COMMENT ('#') which was too broad.\n                        quote = true;\n                    }\n                }\n            }\n\n            if (!quote) {\n                // No quoting needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            // If we reach here, quoting is needed (quote == true)\n            break; // End of MINIMAL case\n\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End of switch\n\n        // If quote is false after the switch (e.g. for NON_NUMERIC on a Number), write directly.\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n\n        // --- Quoting logic ---\n        // We must have a quote character if we reach here, as checked in MINIMAL case,\n        // and ALL/NON_NUMERIC modes imply a quote char is configured.\n        // If quoteCharNullable were null, MINIMAL would have returned earlier.\n        // Assume CSVFormat validation ensures quoteCharNullable is non-null for ALL/NON_NUMERIC.\n        final char quoteChar = quoteCharNullable.charValue();\n\n        out.append(quoteChar);\n\n        // Reset start and pos for the quoting loop, as 'pos' might have been used differently above.\n        start = offset;\n        pos = offset;\n\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point, including the quote char\n                out.append(value, start, pos + 1);\n                // Set start to the position of the quote char, so the next chunk also includes it\n                // This effectively doubles the quote character in the output\n                start = pos;\n            }\n            // No need to check for escape character here; the CSV standard escapes quotes by doubling them.\n            pos++;\n        }\n\n        // Write the last segment (from last detected quote char or from the beginning)\n        out.append(value, start, pos); // pos is 'end' here\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}