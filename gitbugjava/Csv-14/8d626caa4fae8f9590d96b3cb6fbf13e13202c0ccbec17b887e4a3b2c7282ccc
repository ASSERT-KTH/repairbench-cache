{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        // Use a separate variable for the scanning position in MINIMAL mode\n        // to avoid interfering with the 'start' variable used for output segments.\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharOpt = getQuoteCharacter(); // Fetch once\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n            if (quoteCharOpt == null) { throw new IllegalStateException(\"No quote character defined for QuoteMode.ALL\"); }\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            if (quoteCharOpt == null) { throw new IllegalStateException(\"No quote character defined for QuoteMode.NON_NUMERIC\"); }\n            // Check object nullity? Original code didn't, assumes non-null?\n            // Or rely on !(null instanceof Number) == true? Let's keep original behaviour.\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code (which should handle null escape char)\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (quoteCharOpt == null) { throw new IllegalStateException(\"No quote character defined for QuoteMode.MINIMAL\"); }\n            final char quoteChar = quoteCharOpt.charValue(); // Safe to get char value now\n\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos); // pos is still offset here\n\n                // FIX 1: Removed overly aggressive quoting of fields starting with non-alphanumeric\n                //        when newRecord is true. Minimal quoting should only quote when necessary\n                //        due to delimiters, quotes, line breaks, etc.\n                // Original check was:\n                // if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                //     quote = true;\n                // } else\n\n                // Check if the first character necessitates quoting (conservative check for control chars/comment)\n                if (c <= COMMENT) { // Includes default comment char '#' and chars below it\n                    quote = true;\n                } else {\n                    // Scan the rest of the value for chars that require quoting\n                    int scanPos = pos; // Use a separate variable for scanning position\n                    while (scanPos < end) {\n                        c = value.charAt(scanPos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break; // Found a character needing quoting\n                        }\n                        scanPos++;\n                    }\n\n                    if (!quote) {\n                        // Check if the last character necessitates quoting (leading/trailing space handling)\n                        c = value.charAt(end - 1);\n                        if (c <= SP) { // Includes space and chars below it\n                            quote = true;\n                            // If quote becomes true here, the common quoting logic below will handle it.\n                            // Fix 2 (resetting pos/start below) ensures the entire field is scanned\n                            // for internal quote chars that need doubling.\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // No quoting deemed necessary for MINIMAL mode, write raw value\n                out.append(value, start, end);\n                return;\n            }\n            // If quote is true, break from switch and fall through to the common quoting logic\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // --- Common Quoting Logic ---\n        // If we reach here, quote=true was determined by the policy (ALL, NON_NUMERIC, or MINIMAL).\n        // quoteCharOpt must be non-null based on checks above.\n        final char quoteChar = quoteCharOpt.charValue();\n\n        // Append the opening quote character\n        out.append(quoteChar);\n\n        // FIX 2: Reset start and pos to the beginning of the segment before scanning for\n        // internal quote characters that need to be doubled. This ensures the entire\n        // value is processed correctly, regardless of why quoting was triggered.\n        start = offset;\n        pos = offset;\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            // Check for the quote character\n            if (c == quoteChar) {\n                // Append the segment leading up to *and including* the quote character\n                out.append(value, start, pos + 1);\n                // Set the start for the next segment to the position *of* the quote character.\n                // This ensures that when the loop continues and eventually the final segment\n                // is appended, the quote character is included again, effectively doubling it.\n                start = pos;\n            }\n            // NOTE: This block does not handle the escape character. In Commons CSV,\n            // escaping is typically handled by printAndEscape when QuoteMode is NONE.\n            // When quoting is active, only quote doubling is performed as per RFC4180.\n            pos++;\n        }\n\n        // Append the final segment of the value (from the last special char encountered, or the beginning)\n        out.append(value, start, pos); // pos is equal to 'end' here\n\n        // Append the closing quote character\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}