{
    "generation": "    /**\n     * Compare two node pointers based on their depth and position.\n     * Handles comparisons involving variable pointers and node pointers.\n     *\n     * @param p1     the first node pointer\n     * @param depth1 the depth of the first node pointer\n     * @param p2     the second node pointer\n     * @param depth2 the depth of the second node pointer\n     * @return -1 if p1 precedes p2, 1 if p1 follows p2, 0 if they are equal\n     */\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        if (p1 == p2) { // Identity check, also handles p1 == null && p2 == null\n            return 0;\n        }\n\n        // Handle VariablePointer vs non-VariablePointer comparison\n        // Check for null first before using instanceof\n        boolean p1IsVar = p1 != null && p1 instanceof VariablePointer;\n        boolean p2IsVar = p2 != null && p2 instanceof VariablePointer;\n\n        // If types differ (and both are non-null), define order: Variables come first.\n        if (p1 != null && p2 != null && p1IsVar != p2IsVar) {\n            // Variables sort before nodes\n            return p1IsVar ? -1 : 1;\n        }\n        // Now, either both are variables, both are nodes, or at least one is null.\n\n        // Depth adjustment (recursive calls)\n        // Bring the deeper pointer up to the level of the shallower one.\n        if (depth1 < depth2) {\n            // If p2 is null, but depth2 > depth1, this suggests an inconsistency,\n            // but we handle nulls later. Assume p2 is non-null if depth logic is consistent.\n            // Getting p2.parent might yield null if p2 is a root/variable.\n            NodePointer p2parent = (p2 == null) ? null : p2.parent;\n            int r = compareNodePointers(p1, depth1, p2parent, depth2 - 1);\n            // If parents are equivalent (r=0), p1 represents an ancestor of p2.\n            // In document order, ancestor comes first. Return -1.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n             // Assume p1 is non-null here for parent access.\n            NodePointer p1parent = (p1 == null) ? null : p1.parent;\n            int r = compareNodePointers(p1parent, depth1 - 1, p2, depth2);\n            // If parents are equivalent (r=0), p2 represents an ancestor of p1.\n            // In document order, ancestor (p2) comes first. p1 comes after p2. Return 1.\n            return r == 0 ? 1 : r;\n        }\n\n        // Depths are equal (depth = depth1 = depth2)\n\n        // We already checked p1 == p2. Handle remaining null cases at this level.\n        if (p1 == null) { // p2 must be non-null (due to p1==p2 check)\n            return -1; // Use nulls-first convention\n        }\n        if (p2 == null) { // p1 must be non-null\n            return 1;  // Use nulls-first convention\n        }\n\n        // Both p1 and p2 are non-null and at the same depth.\n        // Check equality using the object's equals method (might differ from identity)\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // Compare parents recursively to find the common ancestor or determine order based on ancestors.\n        NodePointer parent1 = p1.parent;\n        NodePointer parent2 = p2.parent;\n        int depth = depth1; // Current depth\n\n        // Recursive call to compare parents\n        int r = compareNodePointers(parent1, depth - 1, parent2, depth - 1);\n\n        if (r != 0) {\n            return r; // Parent order determines node order\n        }\n\n        // If parents compare as equal (r == 0), the nodes are siblings relative to that comparison level.\n        // We need to compare them based on their order under the common parent.\n        // The 'common parent' is represented by parent1 (or parent2, as they compared equal).\n        // This common parent pointer could be null if we have reached the top (e.g., comparing root nodes or variables).\n\n        // The original code threw an exception here if depth == 1. This check is removed.\n\n        if (parent1 == null) { // implies parent2 == null because r == 0\n            // Both nodes are roots, or variables, or otherwise lack a common JXPath parent object\n            // capable of comparing children.\n            // Use NodePointer.compareTo() for final ordering determination.\n            // This relies on NodePointer subclasses implementing compareTo consistently.\n            try {\n                 return p1.compareTo(p2);\n            } catch (UnsupportedOperationException e) {\n                 // Fallback if compareTo is not supported between these types?\n                 // This might indicate pointers from truly different contexts.\n                 // Returning 0 might merge them unexpectedly, throwing might be better,\n                 // but let's try a consistent arbitrary order based on class name?\n                 // Or revert to the original exception? The original exception check was\n                 // specifically at depth 1, which was too restrictive. A general exception\n                 // here might be acceptable if compareTo fails and parent is null.\n                 // Let's stick to compareTo and assume it works or throws appropriately.\n                 // If compareTo itself throws, let it propagate. If it's specifically\n                 // UnsupportedOperationException, maybe throw the JXPathException?\n                 // For now, let's assume compareTo handles it or throws.\n                 // Re-throwing the original specific exception seems wrong as the condition is different.\n                 // Let compareTo's exception propagate, or return an arbitrary order.\n                 // Defaulting to 0 is dangerous. Let's use hash codes for arbitrary but consistent order?\n                 return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));\n            }\n        } else {\n            // There is a common non-null parent object (parent1).\n            // Use the parent's method to compare its children (p1 and p2).\n            // This assumes parent1 implements compareChildNodePointers correctly.\n            return parent1.compareChildNodePointers(p1, p2);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}