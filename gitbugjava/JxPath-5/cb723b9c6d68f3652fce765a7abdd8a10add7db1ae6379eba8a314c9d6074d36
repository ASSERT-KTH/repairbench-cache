{
    "generation": "    /**\n     * Compare two node pointers based on their depth and position.\n     * This method is used for sorting pointers within a NodeSet.\n     * Handles pointers from potentially different trees (e.g., variable vs. node).\n     *\n     * @param p1     First node pointer.\n     * @param depth1 Depth of the first pointer.\n     * @param p2     Second node pointer.\n     * @param depth2 Depth of the second pointer.\n     * @return -1 if p1 precedes p2, 1 if p1 follows p2, 0 if equal.\n     */\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        // 1. Equalize depths by moving up the tree for the deeper pointer\n        if (depth1 < depth2) {\n            // If p2 has no parent, we cannot equalize further by moving p2 up.\n            // The recursive call will handle the case where p2.parent is null.\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If parents end up being equal (r=0), p1 is shallower, so it comes first (-1).\n            // Otherwise, the order is determined by the parent comparison (r).\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            // If p1 has no parent, we cannot equalize further by moving p1 up.\n            // The recursive call will handle the case where p1.parent is null.\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If parents end up being equal (r=0), p2 is shallower, so p1 comes after p2 (1).\n            // Otherwise, the order is determined by the parent comparison (r).\n            return r == 0 ? 1 : r;\n        }\n\n        // 2. Depths are equal (depth1 == depth2)\n\n        // Handle null pointers first for safety and consistency (nulls first)\n        if (p1 == p2) { // Identity check\n            return 0;\n        }\n        if (p1 == null) {\n            return p2 == null ? 0 : -1; // null < non-null\n        }\n        if (p2 == null) {\n            return 1; // non-null > null\n        }\n\n        // Now p1 and p2 are guaranteed non-null. Check for semantic equality.\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // If pointers represent roots (depth=1) but are different,\n        // they might be from different conceptual trees (e.g., a variable vs a document node).\n        // The original code threw an exception here, preventing comparison across trees (like in unions).\n        // FIX: Replace the exception with a fallback comparison based on path strings.\n        if (depth1 == 1) {\n            /* Original buggy code:\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n            */\n            // Compare paths to establish a consistent, albeit arbitrary, order for root nodes.\n            String path1 = p1.asPath();\n            String path2 = p2.asPath();\n            // asPath() should return non-null strings like \"$var\", \"/\", \"\", etc.\n            return path1.compareTo(path2);\n        }\n\n        // 3. Depths > 1 and pointers are different. Compare parents recursively.\n        // We assume that if depth > 1, the parent pointers used for recursion are meaningful,\n        // even if they might be null in some edge cases (handled by recursive calls).\n        // The original code used direct field access (.parent).\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            // Parents are different or have a defined order, which determines the order of p1 and p2.\n            return r;\n        }\n\n        // 4. Parents are the same (r == 0). Compare siblings using the parent's method.\n        // If r == 0, it means the recursive call determined the parents to be \"equal\".\n        // Since depth > 1, this implies they share a common, non-null parent object according\n        // to the comparison logic (unless the parent comparison itself used a fallback like path).\n        // Assume p1.parent is the correct, non-null parent object here based on original logic.\n        // A null parent at this stage would indicate an inconsistency, potentially if parents were\n        // compared equal based on path fallback but were not the same object instance.\n        if (p1.parent == null) {\n             // This state should ideally not be reached if depth > 1 implies a non-null parent\n             // capable of comparing children after the parent comparison returned 0.\n             // Log a warning and provide a fallback comparison based on path.\n             // Consider logging this potential issue if it occurs in practice.\n             // System.err.println(\"JXPath: Warning - comparing node pointers with equal null parents at depth > 1.\");\n             return p1.asPath().compareTo(p2.asPath()); // Fallback comparison\n        }\n        \n        // Delegate comparison to the common parent node.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}