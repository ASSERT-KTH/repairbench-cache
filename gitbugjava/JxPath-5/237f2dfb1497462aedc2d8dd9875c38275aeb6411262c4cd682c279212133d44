{
    "generation": "    /**\n     * Recursive comparison of two NodePointers based on depth and ancestry.\n     * Handles comparisons between pointers in the same tree, and defines\n     * an order for comparing VariablePointers vs NodePointers at the root level.\n     * Throws JXPathException if comparing NodePointers from different trees.\n     */\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        // Ensure pointers are at the same depth by traversing up the shallower pointer's ancestry\n        if (depth1 < depth2) {\n            NodePointer p2Parent = p2 == null ? null : p2.getParent();\n            // If parents compare equal (r=0), it means p1 is an ancestor or sibling of p2Parent.\n            // Since p1 is shallower, it must come first in document order.\n            int r = compareNodePointers(p1, depth1, p2Parent, depth2 - 1);\n            // If parents are the same (r==0), the shallower pointer (p1) comes first.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            NodePointer p1Parent = p1 == null ? null : p1.getParent();\n            // If parents compare equal (r=0), p2 is an ancestor or sibling of p1Parent.\n            // Since p2 is shallower, p1 must come after p2 in document order.\n            int r = compareNodePointers(p1Parent, depth1 - 1, p2, depth2);\n            // If parents are the same (r==0), the deeper pointer (p1) comes second.\n            return r == 0 ? 1 : r;\n        }\n\n        // Depths are equal from here\n\n        if (p1 == p2) { // Identical pointers\n            return 0;\n        }\n\n        // Handle nulls after ensuring depths are equal\n        // If pointers have same depth, but one is null, order nulls first.\n        if (p1 == null) {\n            return -1; // null < non-null\n        }\n        if (p2 == null) {\n            return 1; // non-null > null\n        }\n\n        // Use the NodePointer's equals method for value equality\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // Pointers are different, non-null, and at the same depth.\n\n        // Special handling for root-level comparison (depth = 1)\n        // This is reached when comparing roots, or after adjusting depths.\n        if (depth1 == 1) {\n            // Check if we are comparing a VariablePointer with a non-VariablePointer.\n            // Use FQN for VariablePointer to avoid direct dependency if possible,\n            // but direct instanceof is clearer and likely necessary here.\n            boolean p1IsVar = p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n            boolean p2IsVar = p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n\n            if (p1IsVar != p2IsVar) {\n                // Define an order between Variable roots and Node roots: Variables first.\n                // This allows unions of variables and nodes to be sorted consistently.\n                return p1IsVar ? -1 : 1;\n            }\n            else if (!p1IsVar /* && !p2IsVar */) {\n                 // Both are NodePointers at depth 1 and different (checked by equals).\n                 // They must belong to different trees (e.g., different documents).\n                 // Comparison is not possible based on document order.\n                 // Keep the original behavior of throwing an exception.\n                 throw new JXPathException(\n                         \"Cannot compare pointers that do not belong to the same tree: '\"\n                                 + p1 + \"' and '\" + p2 + \"'\");\n            }\n            // If both are VariablePointers at depth 1, we fall through.\n            // The logic below will compare their parents (likely the same RootPointer\n            // for the JXPathContext's variables). If parents compare equal (r=0),\n            // it will proceed to compare the variables themselves via the null parent check.\n        }\n\n        // Recursively compare parents to find the first differing ancestor.\n        NodePointer parent1 = p1.getParent();\n        NodePointer parent2 = p2.getParent();\n\n        // This recursive call compares the parents. It will eventually bottom out\n        // when depths are 0 or parents are null or equal.\n        int r = compareNodePointers(parent1, depth1 - 1, parent2, depth2 - 1);\n\n        if (r != 0) {\n            // Parents differ at some level, the order is determined by the parent comparison.\n            return r;\n        }\n\n        // If r == 0, the parents at this level are considered equal.\n        // This implies p1 and p2 are siblings or have equivalent ancestor paths.\n\n        // If the common parent is null, it means p1 and p2 are roots whose parents (null)\n        // compared equal (e.g., compareNodePointers(null, 0, null, 0) returned 0).\n        if (parent1 == null) {\n            // This case should only be reachable if p1 and p2 are roots (depth1 was 1).\n            // We handled Var vs Node and Node vs Node roots above in the depth1==1 block.\n            // The only remaining possibility is Var vs Var roots.\n            if (p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer\n                && p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer) {\n                 // Compare the variable names for a consistent order.\n                 org.apache.commons.jxpath.ri.QName name1 = p1.getName();\n                 org.apache.commons.jxpath.ri.QName name2 = p2.getName();\n                 // Perform null-safe comparison of name strings\n                 String s1 = name1 == null ? null : name1.toString();\n                 String s2 = name2 == null ? null : name2.toString();\n                 if (s1 == s2) return 0; // Handles both null or same string\n                 if (s1 == null) return -1; // Null name first\n                 if (s2 == null) return 1;\n                 return s1.compareTo(s2);\n            }\n            // If not variables, reaching here indicates an internal inconsistency,\n            // as Node vs Node roots should have thrown an exception earlier.\n             throw new JXPathException(\n                    \"Internal error: Cannot compare pointers with null parent: '\"\n                     + p1 + \"' and '\" + p2 + \"'\");\n        }\n\n        // Parents are the same (r=0) and non-null.\n        // Ask the common parent to compare its children p1 and p2 using its specific logic.\n        return parent1.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}