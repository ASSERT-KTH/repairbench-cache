{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        if (depth1 < depth2) {\n            NodePointer p2Parent = p2.parent;\n            // If r == 0, it means p1 and p2's parent path match up to depth1.\n            // Since p2 is deeper, p1 must be an ancestor or on a path \"before\" p2's deeper path.\n            // Returning -1 indicates p1 comes before p2.\n            int r = compareNodePointers(p1, depth1, p2Parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            NodePointer p1Parent = p1.parent;\n            // Symmetrical argument: if r == 0, p2 is ancestor or on path \"before\" p1.\n            // p1 comes after p2. Returning 1 indicates p1 comes after p2.\n            int r = compareNodePointers(p1Parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n\n        // Depths are equal (depth1 == depth2)\n\n        // Base case: check object identity first\n        if (p1 == p2) {\n            return 0;\n        }\n\n        // Base case: handle nulls (important for recursion termination)\n        // If one is null and the other isn't, they are different. Define order.\n        if (p1 == null) {\n            // If p2 is also null, they are equal (handled by p1==p2). So p2 is non-null here.\n            return -1; // Define null < non-null\n        }\n        if (p2 == null) {\n            // p1 is non-null, p2 is null.\n            return 1; // Define non-null > null\n        }\n\n        // Both p1 and p2 are non-null NodePointers at the same depth.\n        // Check logical equality using the pointer's equals method.\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // The original code threw an exception here if depth1 == 1,\n        // assuming unequal pointers at the root level meant different trees.\n        // We remove this exception to allow comparing pointers from different\n        // conceptual trees (like VariablePointer vs NodePointer).\n\n        // Recursively compare parents.\n        NodePointer parent1 = p1.parent;\n        NodePointer parent2 = p2.parent;\n\n        // The current depth must be >= 1 for non-null p1/p2, so depth1 - 1 >= 0.\n        int r = compareNodePointers(parent1, depth1 - 1, parent2, depth1 - 1);\n\n        if (r == 0) {\n            // Parent paths are equivalent (e.g., both null, or same path up to root).\n            // Now compare p1 and p2 themselves.\n\n            // Check if they share the *same* non-null parent instance.\n            // Use instance equality (==) because compareChildNodePointers assumes\n            // it's called on the actual parent instance shared by both children.\n            if (parent1 != null && parent1 == parent2) {\n                 // Common parent instance exists, delegate sibling comparison to it.\n                 return parent1.compareChildNodePointers(p1, p2);\n            } else {\n                 // No common parent instance (e.g., comparing roots, variables, nodes in\n                 // different subtrees whose parent paths resolved to equal via recursion,\n                 // or one/both parents are null).\n                 // Need a fallback comparison mechanism.\n\n                 // 1. Compare by type: Variable vs Non-Variable.\n                 // Use the isVariable() method from the Pointer interface.\n                 boolean p1IsVar = p1.isVariable();\n                 boolean p2IsVar = p2.isVariable();\n\n                 if (p1IsVar != p2IsVar) {\n                     // One is a variable, the other is not.\n                     // Define an order: Variables come before non-variables.\n                     return p1IsVar ? -1 : 1;\n                 }\n\n                 // 2. Both are variables OR both are non-variables.\n                 // They don't share a parent capable of comparing them, or are roots.\n                 // Fallback to using identity hash code for a consistent, arbitrary order.\n                 // This handles cases like comparing root nodes of different documents,\n                 // or comparing two distinct variables.\n                 int h1 = System.identityHashCode(p1);\n                 int h2 = System.identityHashCode(p2);\n\n                 if (h1 < h2) {\n                    return -1;\n                 } else if (h1 > h2) {\n                    return 1;\n                 } else {\n                    // Extremely unlikely hash collision for distinct objects p1 and p2\n                    // (we already know p1 != p2 and !p1.equals(p2)).\n                    // If it happens, return an arbitrary but consistent result (e.g., 1)\n                    // to enforce a total order, satisfying comparator contracts\n                    // which often require compare(a,b) == 0 iff a.equals(b).\n                    return 1;\n                 }\n            }\n        } else {\n            // Parents compare differently based on the recursive call (r != 0).\n            // This establishes the order based on ancestor paths.\n            return r;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}