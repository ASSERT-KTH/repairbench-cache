{
    "generation": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Random;\n\n// The following definitions are assumed to be available from the context\n// where the fixed function will be used. They are provided here for\n// completeness of the standalone example.\ninterface Clusterable<T> {\n    double distanceFrom(T p);\n}\n\nclass Cluster<T extends Clusterable<T>> {\n    private T center;\n    public Cluster(T center) { this.center = center; }\n    public T getCenter() { return center; }\n}\n\n\n    /**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param <T> type of the points to cluster\n     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        // Convert to list for indexed access. Make a copy, because the list is modified by Clusterer.\n        // Note: The fixed version below does not modify the list, but a copy protects against\n        // modification of the input collection if it's mutable and used elsewhere.\n        final List<T> pointList = new ArrayList<T>(points);\n        final int numPoints = pointList.size();\n\n        // Corner case: If k is 0 or there are no points, return empty list.\n        if (k == 0 || numPoints == 0) {\n            return new ArrayList<Cluster<T>>();\n        }\n\n        // Corner case: If k is greater than or equal to the number of points, return all points.\n        if (k >= numPoints) {\n           final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(numPoints);\n           for(final T p : pointList) {\n               resultSet.add(new Cluster<T>(p));\n           }\n           return resultSet;\n        }\n\n        // Stores the initial centers chosen.\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(k);\n\n        // Keep track of points selected as centers.\n        final boolean[] selected = new boolean[numPoints];\n\n        // 1. Choose one center uniformly at random from among the data points.\n        final int firstPointIndex = random.nextInt(numPoints);\n        final T firstPoint = pointList.get(firstPointIndex);\n        resultSet.add(new Cluster<T>(firstPoint));\n        selected[firstPointIndex] = true;\n        int numSelected = 1;\n\n        // Keep track of the squared distance from the nearest center for each point.\n        // Initialize using the first chosen center.\n        final double[] minDistSquared = new double[numPoints];\n        for (int i = 0; i < numPoints; i++) {\n            if (i != firstPointIndex) { // Skip the selected point (distance is 0)\n                final double d = firstPoint.distanceFrom(pointList.get(i));\n                minDistSquared[i] = d * d;\n            }\n            // minDistSquared[firstPointIndex] is implicitly 0.0\n        }\n\n        while (numSelected < k) {\n            // 2a. For each point x not chosen yet, compute D(x)^2, the squared distance to\n            // the nearest center that has already been chosen.\n            // Note: minDistSquared already holds the D(x)^2 value.\n\n            // Calculate the sum of minimum squared distances for points not yet selected.\n            double distSqSum = 0.0;\n            for (int i = 0; i < numPoints; i++) {\n                if (!selected[i]) {\n                    distSqSum += minDistSquared[i];\n                }\n            }\n\n            // 2b. Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)^2.\n            int nextCenterIndex = -1;\n\n            // Handle case where sum is zero (e.g., all remaining points coincide with centers)\n            // Use <= 0 to handle potential floating point inaccuracies.\n            if (distSqSum <= 0) {\n                 // Arbitrarily choose the first available point from the list.\n                 for (int i = 0; i < numPoints; ++i) {\n                     if (!selected[i]) {\n                         nextCenterIndex = i;\n                         break;\n                     }\n                 }\n                 // If no point found (should not happen as numSelected < k <= numPoints), break.\n                 if (nextCenterIndex == -1) {\n                     break; // Should not be reached in practice if k < numPoints\n                 }\n            } else {\n                // Perform weighted sampling based on minDistSquared using the standard method.\n                // Generate r uniformly in [0, distSqSum).\n                double r = random.nextDouble() * distSqSum;\n\n                // Iterate through points, subtracting weights until r is non-positive.\n                 for (int i = 0; i < numPoints; i++) {\n                     if (!selected[i]) {\n                        double weight = minDistSquared[i];\n                        r -= weight; // Subtract the point's weight (contribution to the sum)\n                        // Check if the budget r is exceeded. Use <= 0 for robustness against\n                        // floating point issues and the r=0 case with leading zero weights.\n                        if (r <= 0) {\n                            nextCenterIndex = i;\n                            break;\n                        }\n                     }\n                 }\n\n                 // Fallback: If loop finishes without selecting an index (due to precision issues\n                 // where r remains slightly positive), pick the last available point evaluated.\n                 // This ensures a point is always selected if distSqSum > 0.\n                 if (nextCenterIndex == -1) {\n                      for (int i = numPoints - 1; i >= 0; i--) {\n                          if (!selected[i]) {\n                              nextCenterIndex = i; // Found the last non-selected point\n                              break;\n                          }\n                      }\n                      // If still -1 (all points selected?), loop will break below.\n                 }\n            }\n\n            // If no center index found (e.g., all points selected, though k < numPoints check should prevent this), break.\n            if (nextCenterIndex == -1) {\n                 break;\n            }\n\n            // Add the chosen point to the result set.\n            final T nextCenter = pointList.get(nextCenterIndex);\n            resultSet.add(new Cluster<T>(nextCenter));\n            selected[nextCenterIndex] = true;\n            numSelected++;\n\n            // 3. Update minDistSquared for all non-selected points:\n            // Check if the newly chosen center is closer than any previously chosen center.\n            // This optimization avoids recalculating all distances from scratch.\n            if (numSelected < k) { // No need to update after the last center is chosen\n                for (int i = 0; i < numPoints; i++) {\n                    if (!selected[i]) {\n                        final double d = nextCenter.distanceFrom(pointList.get(i));\n                        final double d2 = d * d;\n                        // Update if the new center provides a shorter distance\n                        if (d2 < minDistSquared[i]) {\n                            minDistSquared[i] = d2;\n                        }\n                    }\n                }\n            }\n\n        } // End while loop (repeats steps 2a, 2b, 3)\n\n        return resultSet;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}