{
    "generation": "    /**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param <T> type of the points to cluster\n     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        // dx2 will store the cumulative distances squared D(x)^2\n        final double[] dx2 = new double[pointSet.size()];\n\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            // Store the cumulative sum of squared distances in dx2\n            double sum = 0.0; // Use double for sum to avoid precision loss\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n\n            // Find the first point index 'i' for which the cumulative sum of squared\n            // distances is greater than or equal to the random number 'r'. This\n            // ensures points with larger D(x)^2 have a higher probability of being chosen.\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    // Need to recalculate dx2 for the reduced pointSet on the next iteration\n                    // Note: The current dx2 array length matches the old pointSet size.\n                    // We remove element 'i', so elements from 'i+1' onwards shift.\n                    // The dx2 array needs to be rebuilt based on the *new* pointSet size\n                    // in the next iteration of the outer 'while' loop. The current\n                    // implementation implicitly does this by recomputing dx2 from scratch.\n                    // However, we need to adjust dx2's size if we were to reuse it.\n                    // Since pointSet is modified, we break and let the next while loop iteration\n                    // handle the recalculation with the updated pointSet and dx2 size.\n                    // We also need to update the size of dx2 for the next iteration.\n                    // Re-creating dx2 inside the loop (or resizing) is necessary.\n                    // The original code already implicitly handles this by having dx2 declared\n                    // outside but sized based on pointSet.size() *at the start* of the iteration.\n                    // However, if pointSet becomes empty, dx2.length could be 0.\n                    // The loop structure ensures this won't be an issue as long as k <= points.size().\n                    // Let's resize dx2 array for the next iteration if needed. Although since\n                    // we recompute dx2 fully, just breaking here is sufficient.\n                    // The allocation 'new double[pointSet.size()]' inside the loop would be safer,\n                    // but the original code allocates it outside. Let's stick to the minimal change.\n                    break; // Center found, break inner loop\n                }\n            }\n            // If sum == 0.0 (all remaining points are duplicates of centers),\n            // the loop 'if (dx2[i] >= r)' with r=0 will select the first point (i=0).\n            // This is acceptable behavior.\n\n            // Re-adjust size of dx2 array if pointSet changed size (it did)\n            // The original code didn't explicitly resize, it relied on the next loop iteration using\n            // the new pointSet.size(). This is slightly inefficient if dx2 is large and shrinks,\n            // but correct. Let's keep the original structure. The fix is only changing 'int sum'.\n        }\n\n        return resultSet;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}