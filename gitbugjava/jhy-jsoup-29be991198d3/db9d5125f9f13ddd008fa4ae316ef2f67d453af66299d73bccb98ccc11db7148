{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Determine if leading whitespace should be trimmed from this text node.\n            // This applies if it's the first child of a block parent, or a direct child of the document.\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document;\n            // Determine if trailing whitespace should be trimmed from this text node.\n            // This applies if it's the last child of a block parent.\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // If this text node is just whitespace, and the next node will cause an indent, or is blank, skip this text.\n            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n                || (next instanceof TextNode && (((TextNode) next).isBlank()));\n            if (couldSkip && isBlank()) return;\n\n            // Determine if an indent (newline + spaces) is needed before this text node.\n            boolean doIndent = false;\n            if (out.outline()) {\n                // In outline mode, indent if the text node is not blank.\n                if (!isBlank()) {\n                    doIndent = true;\n                }\n            } else if (prettyPrint) {\n                // In standard pretty print mode, indent if:\n                // 1. This text node is not blank.\n                // 2. Its parent is a block element.\n                // 3. It is preceded by a block element OR a line-break element (like <br>).\n                //    This ensures newlines after block elements or <br> tags.\n                //    Crucially, it avoids indenting the very first inline text within a block.\n                if (!isBlank() && parent != null && parent.tag().isBlock()) {\n                    Node prev = this.previousSibling();\n                    boolean prevIsBlock = (prev instanceof Element && ((Element) prev).tag().formatAsBlock());\n                    // A line break element is typically self-closing and not a block (e.g., <br>, <wbr>)\n                    boolean prevIsLineBreak = (prev instanceof Element && (((Element) prev).tag().isSelfClosing() && !((Element) prev).tag().isBlock()));\n\n                    if (prevIsBlock || prevIsLineBreak) {\n                        doIndent = true;\n                    }\n                }\n            }\n\n            if (doIndent) {\n                indent(accum, depth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}