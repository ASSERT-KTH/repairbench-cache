{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? (Element) parentNode : null;\n        // Whether to normalize adjacent whitespace nodes. If disabled, will collapse consecutive whitespace sequences.\n        // And whether nodes need indenting.\n        final boolean normaliseWhite = prettyPrint && parent != null && !Element.preserveWhitespace(parent);\n\n        boolean trimLeading = false; // Tracks if this node should be trimmed. Used by escape.\n        boolean trimTrailing = false;\n\n        if (normaliseWhite) {\n            // calculate trim flags, used for Entities.escape:\n            // trimLeading if first node in block parent, or parent is document.\n            trimLeading = (siblingIndex == 0 && ( (parent != null && parent.tag().isBlock()) || parentNode instanceof Document ));\n            // trimTrailing if last node in block parent.\n            trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock());\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text node:\n            Node next = this.nextSibling();\n            boolean couldSkip = false;\n            if (next instanceof Element)\n                couldSkip = ((Element) next).shouldIndent(out); // next element will indent\n            else if (next instanceof TextNode)\n                couldSkip = ((TextNode) next).isBlank(); // next is blank text node\n\n            if (couldSkip && isBlank()) return; // don't output this node\n\n\n            // Indentation logic: Only indent if this node is not blank.\n            if (!isBlank()) {\n                // Conditions for indent:\n                // 1) Output is outlined\n                // 2) First child of a block element or document\n                // 3) Follows a block element or a <br> element\n                boolean indentRequired = false;\n                if (out.outline()) {\n                    indentRequired = true;\n                } else {\n                    Node prev = previousSibling();\n                    // Indent if: First child of block/doc OR follows block/br (and not in pre). normaliseWhite check implies not in pre.\n                    if (siblingIndex == 0 && ((parent != null && parent.tag().isBlock()) || parentNode instanceof Document)) {\n                        indentRequired = true; // First child of block or doc\n                    } else if (prev instanceof Element) {\n                        Element prevElem = (Element) prev;\n                        if (prevElem.tag().isBlock() || \"br\".equals(prevElem.normalName())) {\n                            indentRequired = true; // Follows block or br\n                        }\n                    }\n                }\n\n                if (indentRequired) {\n                    indent(accum, depth, out);\n                }\n            } // end if (!isBlank())\n        } // end if(normaliseWhite)\n\n        // Finally, escape and append the text:\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}