{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // Element.preserveWhitespace handles null parent (returns false), which is correct\n        // for children of Document, or if parentNode is not an Element.\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parent);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Determine if leading/trailing whitespace in this text node should be removed.\n            // Original logic for trimLeading:\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document;\n            // Original logic for trimTrailing:\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // If this text node is just whitespace, and the next sibling node will start\n            // with an indent, then this whitespace can be skipped.\n            Node next = this.nextSibling(); // 'this.' is optional, kept for consistency\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next element will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text (e.g. from re-parenting)\n            if (couldSkip && isBlank()) return; // Don't print anything if it's skippable blank text\n\n            // Indentation logic:\n            boolean doIndent = false;\n            if (!isBlank()) { // Common check: only indent if there's actual text content.\n                // Condition 1 (Original): This TextNode is the first child of an Element\n                // that is formatted as a block (e.g., <p>Text...</p>).\n                if (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock()) {\n                    doIndent = true;\n                }\n                // Condition 2 (Original): Outline mode is on, and this TextNode is part of a list of siblings.\n                // siblingNodes().size() is parentNode.childNodeSize(). Using siblingNodes() as in original.\n                // If parentNode is null, siblingNodes() is an empty list, so size is 0.\n                else if (out.outline() && siblingNodes().size() > 0) {\n                    doIndent = true;\n                }\n                // Condition 3 (New): This TextNode follows a <br> tag within a parent Element\n                // that is formatted as a block. (e.g., <p>Hello<br>Text...</p>)\n                else { // Only consider if other indent conditions were not met.\n                    Node prev = previousSibling();\n                    if (prev instanceof Element && ((Element) prev).tag().getName().equals(\"br\")) {\n                        // Parent must be a block-formatting element for <br> to trigger indent.\n                        if (parent != null && parent.tag().formatAsBlock()) {\n                            doIndent = true;\n                        }\n                    }\n                }\n            }\n\n            if (doIndent) {\n                indent(accum, depth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}