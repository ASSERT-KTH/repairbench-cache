{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // parentNode must exist for TextNode, no need to check for null\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false; // Tracks if space should be trimmed from the start of the string\n        boolean trimTrailing = false; // Tracks if space should be trimmed from the end of the string\n\n        if (normaliseWhite) {\n            // Determine if this node should be skipped completely\n            Node next = this.nextSibling();\n            // Conditions to skip this TextNode:\n            // 1) It's blank.\n            // 2) The next node exists, and is either an Element that will indent, or another blank TextNode.\n            boolean couldSkip = isBlank() && next != null &&\n                ( (next instanceof Element && ((Element) next).shouldIndent(out)) ||\n                  (next instanceof TextNode && ((TextNode) next).isBlank()) );\n\n            if (couldSkip) return; // Don't output this node if blank and next node indents or is blank\n\n            // Determine if this node needs an indent sequence prepended\n            boolean indentThis = false;\n            if (!isBlank()) { // Don't indent blank nodes unless outline mode forces it? (Existing check is !isBlank)\n                // Outline mode indents all non-blank nodes with siblings\n                if (out.outline() && siblingNodes().size() > 0) {\n                    indentThis = true;\n                } else if (parentNode instanceof Element) {\n                    Element parent = (Element) parentNode;\n                    // Indent required if:\n                    // - Parent is a block tag that doesn't preserve whitespace.\n                    // - AND This node is the first child.\n                    // - OR This node follows a <br> tag.\n                    if (parent.tag().formatAsBlock()) { // Check if parent is block\n                        Node prev = previousSibling();\n                        final boolean isFirstChild = (siblingIndex == 0);\n                        // Check if previous sibling was a <br> element\n                        final boolean previousIsBr = (!isFirstChild && prev instanceof Element && ((Element)prev).tag().getName().equals(\"br\"));\n\n                        if (isFirstChild || previousIsBr) {\n                            indentThis = true;\n                        }\n                    }\n                }\n            }\n\n            if (indentThis) {\n                indent(accum, depth, out);\n            }\n\n            // Determine if the node's text should have leading/trailing whitespace trimmed.\n            // Trim leading if this is the first node in a block parent or the document root.\n            // Trim trailing if this is the last node in a block parent.\n            Element parent = parentNode instanceof Element ? ((Element) parentNode) : null; // Need parent Element again\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                           parentNode instanceof Document;\n            trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock());\n        }\n\n        // Finally, call the escape helper to append the text content, applying normalization and trimming as needed.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}