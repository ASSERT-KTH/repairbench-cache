{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                (parentNode instanceof Document);\n            trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock());\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n            if (couldSkip && isBlank()) return;\n\n            // Indentation logic:\n            // In pretty-print mode, a TextNode is only indented if it's not blank.\n            if (!isBlank()) {\n                boolean shouldIndentThisNode = false;\n\n                // Case 1: In outline mode, all non-blank text nodes are indented.\n                if (out.outline()) {\n                    shouldIndentThisNode = true;\n                }\n                // Case 2: Not in outline mode. Indent if follows a <br> or a block-level element,\n                // and the parent is also a block-level formatting element.\n                else {\n                    Node prev = previousSibling();\n                    if (prev instanceof Element) {\n                        Element prevElement = (Element) prev;\n                        // Check if previous element implies a newline (is block or <br>)\n                        // and parent is a block context (and not a Document node)\n                        if ((prevElement.tag().formatAsBlock() || prevElement.tagName().equals(\"br\")) &&\n                            (parent != null && parent.tag().formatAsBlock())) {\n                            shouldIndentThisNode = true;\n                        }\n                    }\n                }\n\n                if (shouldIndentThisNode) {\n                    indent(accum, depth, out);\n                }\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}