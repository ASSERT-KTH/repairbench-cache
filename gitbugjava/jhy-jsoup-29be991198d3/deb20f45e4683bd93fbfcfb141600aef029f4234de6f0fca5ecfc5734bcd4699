{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // normaliseWhite needs Element.preserveWhitespace, which needs parent. Ensure parent not null.\n        final boolean normaliseWhite = prettyPrint && parent != null && !Element.preserveWhitespace(parent);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // calculate trims based on relationship to block elements or document root\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                (parentNode instanceof Document); // trim leading if first node in block parent, or first node in doc\n            trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock()); // trim trailing if last node in block parent\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n            if (couldSkip && isBlank()) return; // Don't print empty text nodes stacked before elements that require indent\n\n\n            // Indentation logic:\n            boolean indentOutput = false;\n            // 1. Outline mode: indent non-blank nodes being outlined.\n            if (out.outline() && siblingNodes().size() > 0 && !isBlank()) {\n                 indentOutput = true;\n            }\n            // 2. After <br>: indent after a <br> element.\n            // Uses 'else' to avoid double indent if outline mode is already indenting.\n            else {\n                Node prev = previousSibling();\n                // Check if the previous sibling is an Element and its tag name is \"br\".\n                if (prev instanceof Element && ((Element) prev).tag().getName().equals(\"br\")) {\n                    // We need to indent after a <br> in pretty print mode.\n                    // No need to check !isBlank() here, as indent (newline + space) should\n                    // precede the text regardless of its content, matching the expectation.\n                    indentOutput = true;\n                }\n            }\n\n            // Perform indentation if required.\n            if (indentOutput) {\n                indent(accum, depth, out);\n            }\n        }\n\n        // Escape and write text, applying normalization and trimming as calculated.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}