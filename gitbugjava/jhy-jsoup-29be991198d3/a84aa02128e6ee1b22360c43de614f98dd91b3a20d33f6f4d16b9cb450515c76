{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        // preserveWhitespace check is recursive up the stack; use the parent node to start the check.\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false; // Default value if normaliseWhite is false\n        boolean trimTrailing = false; // Default value if normaliseWhite is false\n\n        if (normaliseWhite) {\n            // Calculation of indent and trimming needed only if normalising whitespace\n            Node prev = previousSibling();\n            // Check if the previous sibling was a <br> element.\n            boolean precededByBr = (prev instanceof Element && ((Element) prev).tag().getName().equals(\"br\"));\n            boolean isFirstChild = siblingIndex == 0;\n\n            boolean needsIndent = false;\n            // Indent calculation: determine if this node needs indentation.\n            // Conditions: non-blank node, within a block parent, based on position/outline setting/preceding <br>.\n            if (!isBlank()) { // Indentation logic only applies to non-blank nodes\n                 boolean indentBasedOnPos = false;\n                 if (parent != null && parent.tag().formatAsBlock()) { // Parent must be a block/formatAsBlock for these rules\n                     if (out.outline()) {\n                         // Outline mode: indent if first child OR preceded by <br>\n                         indentBasedOnPos = (isFirstChild || precededByBr);\n                     } else {\n                         // Default mode: indent ONLY if preceded by <br> (implicit: not first child indent unless outline)\n                         indentBasedOnPos = precededByBr;\n                     }\n                 }\n                 // Original outline check might cover other rare cases (e.g. list of textnodes in non-block parent?)\n                 boolean indentForGeneralOutline = (out.outline() && siblingNodes() != null && siblingNodes().size() > 0);\n\n                 needsIndent = indentBasedOnPos || indentForGeneralOutline;\n            }\n\n            // Calculate trim flags based on position and indent need\n            boolean isFirstInBlockOrDoc = (isFirstChild && parent != null && parent.tag().isBlock()) || // isBlock check for trimming context\n                                          (parentNode instanceof Document);\n            // Trim leading space if it's the first node in a block/doc OR if we are indenting it (starts a new logical line)\n            trimLeading = isFirstInBlockOrDoc || needsIndent;\n\n            // Trim trailing space only if it's the last node in a block parent\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // Skip check: if this node is blank, and the next node will require indent, or is another blank node,\n            // skip emission of this node (effectively collapsing blank lines).\n            Node next = this.nextSibling();\n            // Need to check next sibling exists. Refs https://github.com/jhy/jsoup/issues/1062\n            boolean nextWillIndent = next != null && (next instanceof Element && ((Element) next).shouldIndent(out));\n            boolean nextIsBlankText = next != null && (next instanceof TextNode && (((TextNode) next).isBlank()));\n            if ((nextWillIndent || nextIsBlankText) && isBlank()) {\n                return; // Don't output this node\n            }\n\n            // Perform indent if required (needsIndent already implies !isBlank())\n            if (needsIndent) {\n                indent(accum, depth, out);\n            }\n        } // end if(normaliseWhite)\n\n        // Call escape helper, passing the normalise / trim flags.\n        // These flags control whitespace handling within the Entities.escape method.\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}