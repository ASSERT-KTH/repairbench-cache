{
    "generation": "    @Override // Assuming this overrides a method in Node or a base class\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        // parent node is needed for whitespace preservation checks\n        // Element.preserveWhitespace handles null parentNode check\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // calculates if this node should be trimmed based on context (block parent, document root)\n            final Element parent = parentNode instanceof Element ? (Element) parentNode : null;\n            // trim leading if first in block or document root.\n            trimLeading = (siblingIndex == 0 && ( (parent != null && parent.tag().isBlock()) || (parentNode instanceof Document)) );\n            // trim trailing if last in block or document root.\n            trimTrailing = (nextSibling() == null && ( (parent != null && parent.tag().isBlock()) || (parentNode instanceof Document)) );\n        }\n\n        if (normaliseWhite) {\n            // if this text is just whitespace, and the next node will output a newline (or is blank), skip this text node\n            Node next = nextSibling();\n            boolean nextWillIndentOrIsBlank = false;\n            if (next instanceof Element) {\n                // Check if the next element should indent. Element.shouldIndent calculates based on prettyPrint, block/outline settings.\n                nextWillIndentOrIsBlank = ((Element) next).shouldIndent(out);\n            } else if (next instanceof TextNode) {\n                // Check if the next text node is blank. Can happen typically during DOM manipulation.\n                nextWillIndentOrIsBlank = ((TextNode) next).isBlank();\n            }\n\n            if (nextWillIndentOrIsBlank && isBlank()) {\n                // sibling will likely output a newline+indent, and this node is blank, so skip outputting this node.\n                return;\n            }\n\n            // Determine if indentation is needed before this text node\n            boolean indentThis = false;\n            if (!isBlank()) { // Only consider indenting non-blank nodes\n                Node prev = previousSibling();\n                if (out.outline()) { // Outline mode always indents (unless parent preserves whitespace, handled by normaliseWhite check)\n                    indentThis = true;\n                } else {\n                    // Standard indenting rules for text nodes:\n                    // 1. First node in a block parent or document root\n                    if (siblingIndex == 0 && (parentNode instanceof Document || (parentNode instanceof Element && ((Element)parentNode).tag().formatAsBlock()))) {\n                         indentThis = true;\n                    }\n                    // 2. After a block element or a <br> element\n                    else if (prev instanceof Element) {\n                        Element prevEl = (Element) prev;\n                        // Indent after blocks or <br> tags when pretty printing.\n                        // Using normalName() for case-insensitivity (\"br\", \"BR\", etc.)\n                        if (prevEl.tag().isBlock() || prevEl.normalName().equals(\"br\")) {\n                             indentThis = true;\n                        }\n                    }\n                    // Note: preserveWhitespace checks are implicitly handled by the top-level `if (normaliseWhite)` guard.\n                }\n            }\n\n            // Apply indentation if required\n            if (indentThis) {\n                indent(accum, depth, out); // indent() handles adding newline and spaces\n            }\n\n            // Adjust trimLeading flag for Entities.escape:\n            // If we added an indent, then we must strip leading spaces from the text node's *content*,\n            // otherwise preserve the original trimLeading calculation (which is based on block context).\n            boolean passTrimLeading = trimLeading || indentThis;\n\n            // Output the text content, applying normalization, trimming, and escaping\n            // Core value is the raw text content of this TextNode.\n            // The normaliseWhite flag enables space collapsing.\n            // passTrimLeading/trimTrailing control trimming based on context and preceding indent.\n            Entities.escape(accum, coreValue(), out, false, normaliseWhite, passTrimLeading, trimTrailing);\n\n        } else {\n            // Not normalizing (prettyPrint=false or preserveWhitespace=true): output raw core value escaped, no normalization/trimming.\n            Entities.escape(accum, coreValue(), out, false, false, false, false);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}