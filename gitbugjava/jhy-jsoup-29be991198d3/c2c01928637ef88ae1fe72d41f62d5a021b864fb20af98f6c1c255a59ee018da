{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parent(); // Use parent() method for convenience & null safety\n        // Should whitespace be normalized and indentation applied?\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parent);\n\n        if (!normaliseWhite) {\n            // If not normalizing, just escape the raw value\n            Entities.escape(accum, coreValue(), out, false, false, false, false);\n            return;\n        }\n\n        // Whitespace normalization is active:\n\n        // 1. Skip entirely if this node is blank and the next node will indent or is blank.\n        // (Preserves original skip logic)\n        if (isBlank()) {\n            Node next = this.nextSibling();\n            // Originally: Element.shouldIndent() required parent.formatAsBlock and !parentIsBlock. TextNodes don't have that directly.\n            // Let's simplify the nextWillIndent check: Is the next sibling an Element that is block formatted?\n            boolean nextWillIndent = (next instanceof Element && ((Element) next).tag().formatAsBlock()); // Simplified check if next could cause newline/indent\n            boolean nextIsBlank = (next instanceof TextNode && ((TextNode) next).isBlank());\n            if (nextWillIndent || nextIsBlank) {\n                 return; // Skip this blank node\n            }\n            // If a blank node is not skipped, it should proceed to output (likely just spaces, handled by escape)\n            // but should not trigger indentation itself.\n        }\n\n        // 2. Determine if indentation (\\n + spaces) is required before this text node.\n        boolean indentBefore = false;\n        if (!isBlank()) { // Indentation only applies to non-blank nodes\n            Node prev = previousSibling();\n            // ** Indent if previous sibling was <br> **\n            if (prev instanceof Element && ((Element) prev).tag().getName().equals(\"br\")) {\n                indentBefore = true;\n            } else {\n                // ** OR Indent if this is the first node in a block parent **\n                // ** OR Indent if outline mode is active and node has siblings ** (Original logic)\n                // Note: Element.formatAsBlock is the deciding factor if the parent needs indenting children\n                if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock()) ||\n                    (out.outline() && siblingNodes().size() > 0)) {\n                     indentBefore = true;\n                }\n            }\n        }\n\n        // 3. Perform indentation if needed.\n        if (indentBefore) {\n            indent(accum, depth, out);\n        }\n\n        // 4. Determine if leading/trailing whitespace *within the node's value* should be trimmed by Entities.escape\n        // This is based on position within a block parent or Document.\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        // Check parent() result directly\n        if (parent != null && parent.tag().isBlock()) {\n             trimLeading = (siblingIndex == 0); // Trim leading space if first child in block\n             trimTrailing = (nextSibling() == null); // Trim trailing space if last child in block\n         } else if (parentNode instanceof Document) { // Handle direct child of Document (root)\n             trimLeading = (siblingIndex == 0);\n             trimTrailing = (nextSibling() == null);\n         }\n         // Note: Original code had a specific check for parentNode instanceof Document separate from the parent block check.\n\n        // 5. Escape and append the node's value.\n        // Pass normaliseWhite=true, and the calculated trim flags.\n        Entities.escape(accum, coreValue(), out, false, true /* normaliseWhite */, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}