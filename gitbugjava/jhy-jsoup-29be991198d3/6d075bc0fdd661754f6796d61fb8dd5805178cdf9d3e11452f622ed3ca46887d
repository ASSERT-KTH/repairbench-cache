{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parent); // Use 'parent' which is checked for null later\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Conditions for trimming leading space of this text node\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document; // Direct child of Document\n\n            // Conditions for trimming trailing space of this text node\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock();\n\n            // Skip this node if it's blank and the next node requires indent or is also blank\n            Node next = this.nextSibling();\n            boolean nextCond = (next instanceof Element && ((Element) next).shouldIndent(out)) ||\n                               (next instanceof TextNode && ((TextNode) next).isBlank());\n            if (nextCond && isBlank()) return; // Skip blank text node\n\n            // Indent before the text if it's the first non-blank node in a block/outline context\n            // simplified the logic slightly from original, but same intent:\n            if ((out.outline() || (parent != null && parent.tag().formatAsBlock())) && !isBlank() ) {\n                // only indent if the first node in a block and not preserving whitespace. Or in outline mode.\n                if (siblingIndex == 0 && parent != null && !parent.tag().preserveWhitespace()) {\n                     indent(accum, depth, out);\n                } else if (out.outline() && siblingNodes().size() > 0) {\n                    // Re-enable careful indent for outline mode Disabled in original: && siblingNodes().size() > 0\n                    indent(accum, depth, out);\n                }\n                // todo: check if this sufficient for all cases? It differs slightly from original. Let's revert to original indent logic.\n            }\n            // Revert indent logic to original exactly:\n            if ((siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank()) ||\n                (out.outline() && siblingNodes().size() > 0 && !isBlank())) {\n                indent(accum, depth, out);\n            }\n        }\n\n        // Issue #1858: Add a leading space if this text node follows a <br> tag during pretty-printing normalization.\n        Node prev = previousSibling();\n        if (prettyPrint && normaliseWhite && !isBlank() && prev instanceof Element && ((Element)prev).tag().getName().equals(\"br\")) {\n            // The indent logic elsewhere should have added the newline; we add the space.\n            accum.append(' ');\n        }\n\n        // Escape and append the text content.\n        // Use coreValue() for TextNode, or potentially getWholeText() if it needs to span? No, outerHtmlHead is per node.\n        boolean isCData = this instanceof CDataNode; // Check if instanceof CDataNode for escape settings\n        Entities.escape(accum, coreValue(), out, isCData, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}