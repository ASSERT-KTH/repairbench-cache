{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode);\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        Node previousSiblingNode = null;\n        if (siblingIndex > 0) {\n            Element p = parentNode instanceof Element ? ((Element) parentNode) : null;\n            if (p != null && p.childNodeSize() > siblingIndex - 1) {\n                previousSiblingNode = p.childNode(siblingIndex - 1);\n            }\n        }\n\n        if (normaliseWhite) {\n            trimLeading = (siblingIndex == 0 && (parent != null && parent.tag().isBlock()) || \n                parentNode instanceof Document);\n            trimTrailing = (nextSibling() == null && parent != null && parent.tag().isBlock());\n\n            // Check if this text node can be skipped due to next node\n            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) || \n                (next instanceof TextNode && (((TextNode) next)).isBlank());\n            if (couldSkip && isBlank()) return;\n\n            boolean shouldIndent = false;\n            shouldIndent |= (siblingIndex == 0 && parent != null && parent.tag().formatAsBlock() && !isBlank());\n            shouldIndent |= (parentNode instanceof Document);\n            if (out.outline()) {\n                shouldIndent |= (siblingNodes().size() > 0 && !isBlank());\n            }\n            if (previousSiblingNode != null && previousSiblingNode instanceof Element) {\n                if (parent != null && parent.tag().isBlock() && !isBlank()) {\n                    shouldIndent = true;\n                }\n            }\n\n            if (shouldIndent) {\n                int indentDepth = depth;\n                // Adjust depth if after an element in a block parent\n                if (previousSiblingNode instanceof Element && \n                    parent != null && parent.tag().isBlock() && \n                    !isBlank() && \n                    (siblingIndex == 0 || previousSiblingNode instanceof Element)) {\n            indentDepth--;\n        }\n                indent(accum, indentDepth, out);\n            }\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}