{
    "generation": "    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        final Element parent = parentNode instanceof Element ? ((Element) parentNode) : null;\n        //final Document owner = ownerDocument(); // Unused in this logic path\n        final boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parentNode); // Needs to check parent chain (as preserveWhitespace does)\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // Calculate trimming flags based on position within block parents\n            trimLeading = (siblingIndex == 0 && parent != null && parent.tag().isBlock()) ||\n                parentNode instanceof Document; // First node in block container, or root node\n            trimTrailing = nextSibling() == null && parent != null && parent.tag().isBlock(); // Last node in block container\n\n            // If this node is blank, and is followed by a node that will receive an indent, skip this node\n            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out))\n                || (next instanceof TextNode && ((TextNode) next).isBlank()); // Don't output blank text followed by blank text or indenting element\n            if (couldSkip && isBlank()) return; // Skip printing if we are blank and the next node will handle spacing\n\n            // Indentation logic for non-blank text nodes:\n            if (!isBlank()) {\n                Node prev = previousSibling();\n                // Indent if:\n                // 1. We are preceded by a <br> tag.\n                // 2. We are the first child of a parent element that requires indentation itself (e.g., a div, but not a p).\n                // 3. Outline mode is on and we have siblings (original check was siblingNodes().size() > 0).\n                boolean followsBr = prev != null && prev.nodeName().equals(\"br\");\n                boolean parentIndent = parent != null && parent.shouldIndent(out); // Check if the parent element itself is indented\n                boolean isFirstChild = siblingIndex == 0;\n                boolean outline = out.outline();\n                // Check used in original outline mode logic was siblingNodes().size() > 0. Assuming this is correct for outline indent.\n                boolean inOutlineWithSiblings = outline && siblingNodes().size() > 0;\n\n                if (followsBr || (isFirstChild && parentIndent) || inOutlineWithSiblings) {\n                    indent(accum, depth, out);\n                }\n            }\n            // Note: The original indentation logic was different and has been replaced by the block above.\n        }\n\n        // Delegate printing of the text content to Entities for escaping and normalization, applying trimming flags\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}