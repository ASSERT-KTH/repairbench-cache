{
    "generation": "    @Override\n    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        final boolean prettyPrint = out.prettyPrint();\n        Element parent = parentNode instanceof Element ? (Element) parentNode : null;\n        boolean normaliseWhite = prettyPrint && !Element.preserveWhitespace(parent); // inline parent check below\n\n        boolean trimLeading = false;\n        boolean trimTrailing = false;\n        if (normaliseWhite) {\n            // if is block element or document, normalize suppression rules\n            if (parent != null && parent.tag().isBlock() || parentNode instanceof Document) {\n                trimLeading = siblingIndex == 0;\n                trimTrailing = nextSibling() == null;\n            } // todo - else if inline parent, we may still want to normalize. This is the fix for #1858\n            // however, this node may be the only node in an inline parent, so we need to check nextSib\n            else if (parent != null && parent.tag().isInline()) {\n                // only trim if we are adjacent to an element, or are the only node\n                Node prev = previousSibling();\n                Node next = nextSibling();\n                trimLeading = prev instanceof Element; // only trim leading if adjacent to element, not other text\n                trimTrailing = next instanceof Element || parent.childNodes().size() == 1; // only trim trailing if adjacent to element, or if only node\n            }\n\n            // if this text is just whitespace, and the next node will cause an indent, skip this text:\n            Node next = this.nextSibling();\n            boolean couldSkip = (next instanceof Element && ((Element) next).shouldIndent(out)) // next will indent\n                || (next instanceof TextNode && (((TextNode) next).isBlank())); // next is blank text, from re-parenting\n            if (couldSkip && isBlank()) return;\n\n            // indent determines if this node starts on a new line. For leading text, pad to space\n            boolean indent = prettyPrint && !isBlank() && // makes sense to indent if !blank\n                ( // and:\n                    (parent != null && parent.tag().formatAsBlock()) // parent is block level\n                    || (out.outline() && (siblingNodes().size() > 0)) // outline mode and siblings\n                );\n\n            if (indent)\n                indent(accum, depth, out);\n        }\n\n        Entities.escape(accum, coreValue(), out, false, normaliseWhite, trimLeading, trimTrailing);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}