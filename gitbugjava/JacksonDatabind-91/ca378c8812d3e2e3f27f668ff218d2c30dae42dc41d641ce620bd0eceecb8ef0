{
    "generation": "    /**\n     * Helper method used to prevent both caching and cache lookups for structured\n     * types that have custom value handlers\n     *\n     * @since 2.8.11\n     */\n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have value or type handler\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                // For structured types, check value handlers (could be custom serializer)\n                // or type handlers (could be custom polymorphic type handling)\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                     return true;\n                }\n            }\n            // Second: map(-like) types may have value handler for key (key serializer/deserializer)\n            if (t.isMapLikeType()) {\n                 JavaType kt = t.getKeyType();\n                 // Check key type's value handler (represents custom key serializer/deserializer)\n                 if (kt.getValueHandler() != null) {\n                     return true;\n                 }\n            }\n        }\n        // Added check for the main type itself as well, seems logical\n        // although original code only checked container contents. But this is safer.\n        /*\n        if (t.getValueHandler() != null || t.getTypeHandler() != null) {\n            return true;\n        }\n        */\n        // 17-Jan-2022, tatu: Let's revert [databind#3348] fix -- problematic,\n        //   reverted for 2.13.2. Need to reconsider for 2.14 or later.\n\n        // If we reach here, no custom handlers were found based on original logic scope\n        return false;\n    }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}