{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils; // Assuming this import is available\n\n// Add import for NumberUtils if createFloat/Double/etc. are static methods of the same class\n// import static org.apache.commons.lang3.math.NumberUtils.*; // Example if they are in NumberUtils\n\n/**\n * Contains the fixed createNumber method.\n * Assuming helper methods like isAllZeros, isDigits, createFloat, createDouble,\n * createInteger, createLong, createBigInteger are available and function correctly\n * (especially handling hex/octal for integral types).\n * The implementation below assumes these helpers are accessible, potentially\n * as static methods of the same class or another utility class.\n */\npublic class NumberUtilsFixed {\n\n    // Dummy helper methods for context - replace with actual implementations from NumberUtils\n    private static Float createFloat(String str) throws NumberFormatException { return Float.valueOf(str); }\n    private static Double createDouble(String str) throws NumberFormatException { return Double.valueOf(str); }\n    private static Integer createInteger(String str) throws NumberFormatException { return Integer.decode(str); }\n    private static Long createLong(String str) throws NumberFormatException { return Long.decode(str); }\n    private static BigInteger createBigInteger(String str) throws NumberFormatException {\n        if (str == null) {\n             throw new NumberFormatException(\"Input string is null\"); // Or return null based on contract? Method doc says throws NFE for blank.\n         }\n        int index = 0;\n        int sign = 1;\n        if (str.startsWith(\"-\")) {\n            sign = -1;\n            index++;\n        }\n\n        int radix = 10;\n        boolean stripPrefix = true; // Flag to indicate if prefix needs stripping for BigInteger constructor\n\n        if (str.startsWith(\"0x\", index) || str.startsWith(\"0X\", index)) {\n            radix = 16;\n            index += 2;\n        } else if (str.startsWith(\"#\", index)) {\n            radix = 16;\n            index++;\n        } else if (str.startsWith(\"0\", index) && str.length() > index + 1) {\n            // Check for explicit octal (0 followed by 0-7 digits)\n            boolean allOctal = true;\n            for (int i = index + 1; i < str.length(); i++) {\n                if (str.charAt(i) < '0' || str.charAt(i) > '7') {\n                    allOctal = false;\n                    break;\n                }\n            }\n            if (allOctal) {\n                 radix = 8;\n                 index++; // Skip the '0' prefix\n            } else {\n                 // Starts with 0 but not octal (e.g. \"09\"), treat as decimal. BigInteger constructor handles this.\n                 radix = 10;\n                 stripPrefix = false; // Let BigInteger constructor parse the whole string as decimal\n                 index = 0; // Reset index, don't strip prefix\n                 sign = 1; // Sign handled by BigInteger constructor\n            }\n\n        } else {\n             // Standard decimal\n             radix = 10;\n             stripPrefix = false; // Let BigInteger constructor parse the whole string\n             index = 0; // Reset index\n             sign = 1; // Sign handled by BigInteger constructor\n        }\n\n        String numberPart = stripPrefix ? str.substring(index) : str;\n\n        if (numberPart.isEmpty()) {\n            throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n        }\n\n        try {\n             BigInteger bi;\n             if (stripPrefix) {\n                 // We manually handle sign and prefix, parse the rest with radix\n                 bi = new BigInteger(numberPart, radix);\n                 if (sign == -1) {\n                     bi = bi.negate();\n                 }\n             } else {\n                 // Let BigInteger constructor handle sign and potential octal/decimal interpretation\n                 bi = new BigInteger(numberPart, radix); // Radix is 10 or 8 here based on previous logic\n             }\n             return bi;\n        } catch (NumberFormatException e) {\n             // Add context to the exception\n             throw new NumberFormatException(\"For input string: \\\"\" + str + \"\\\"\");\n        }\n    }\n    private static BigDecimal createBigDecimal(String str) throws NumberFormatException { return new BigDecimal(str); }\n    // A more robust isAllZeros check needed? This handles basic cases.\n    // It should probably check mantissa and exponent parts identified earlier.\n    private static boolean isAllZeros(String s) {\n        if (s == null) return true;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '0' || c == '.' || c == '+' || c == '-') continue;\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits. Hex numbers can be followed optionally by L or l.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} followed by octal digits will be interpreted as octal;\n     * the returned number will be Integer, Long or BigInteger as appropriate.\n     * A single '0' will be interpreted as decimal Integer 0. Strings like \"09\" will be treated as decimal.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n\n        // Hex processing\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for (final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length();\n                break;\n            }\n        }\n\n        if (pfxLen > 0) { // Hex number\n            String hexNum = str;\n            char lastChar = str.charAt(str.length() - 1);\n            boolean hadL = false;\n\n            if (lastChar == 'l' || lastChar == 'L') {\n                hadL = true;\n                hexNum = str.substring(0, str.length() - 1); // String without 'L'\n            }\n\n            String hexDigitsStr = hexNum.substring(pfxLen);\n            if (hexDigitsStr.isEmpty() || !hexDigitsStr.matches(\"[0-9a-fA-F]+\")) {\n                 throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid hexadecimal number.\");\n             }\n            final int hexDigits = hexDigitsStr.length();\n\n            if (hadL) {\n                // With 'L', must be Long or BigInteger\n                if (hexDigits > 16) {\n                    return createBigInteger(hexNum); // Assumes handles hex prefix\n                }\n                try {\n                     return createLong(hexNum); // Assumes handles hex prefix\n                 } catch (NumberFormatException nfe) {\n                      // Value might be too large for Long (e.g., unsigned > Long.MAX_VALUE)\n                      return createBigInteger(hexNum);\n                 }\n            } else {\n                // No 'L', can be Integer, Long, or BigInteger\n                if (hexDigits > 16) {\n                    return createBigInteger(hexNum); // Assumes handles hex prefix\n                }\n                try {\n                     // Try Long first, as it covers Integer range too\n                     Long val = createLong(hexNum); // Assumes handles hex prefix\n                     // Check if it fits within Integer range without loss\n                     if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n                         return Integer.valueOf(val.intValue());\n                     }\n                     return val;\n                 } catch (NumberFormatException nfe) {\n                      // If createLong fails (e.g., too large), fall back to BigInteger\n                      return createBigInteger(hexNum);\n                 }\n            }\n        } // End hex processing\n\n\n        // Not hex. Process qualifiers, decimal points, exponents.\n        final char lastChar = str.charAt(str.length() - 1);\n        final int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        String mant;\n        String dec = null; // Initialize dec to null\n        String exp = null; // Initialize exp to null\n\n        // Split string into parts based on decimal and exponent\n        if (decPos > -1) { // Has decimal point\n            if (expPos > -1) { // Has exponent\n                if (expPos < decPos || expPos >= str.length() - 1) { // Invalid exponent position or format\n                    throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                }\n                mant = str.substring(0, decPos);\n                dec = str.substring(decPos + 1, expPos);\n                exp = str.substring(expPos + 1);\n            } else { // No exponent\n                mant = str.substring(0, decPos);\n                dec = str.substring(decPos + 1);\n            }\n        } else { // No decimal point\n            if (expPos > -1) { // Has exponent\n                 if (expPos >= str.length() - 1) { // Invalid exponent position or format\n                     throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                 }\n                mant = str.substring(0, expPos);\n                exp = str.substring(expPos + 1);\n            } else { // No decimal, no exponent -> integral\n                mant = str;\n                // dec and exp remain null\n            }\n        }\n\n        // Check for type qualifiers (f, F, d, D, l, L)\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            final String numeric = str.substring(0, str.length() - 1); // Numeric part before qualifier\n\n            // Check if the numeric part is non-empty and potentially valid\n            if (numeric.isEmpty() || (numeric.length() == 1 && (numeric.charAt(0) == '-' || numeric.charAt(0) == '+'))) {\n                 throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n             }\n\n             // Recalculate mantissa and exponent based on 'numeric' for allZeros check\n             String qualMant = numeric; // Default if no dec/exp in numeric\n             String qualExp = null;\n             final int qualDecPos = numeric.indexOf('.');\n             int qualExpPos = numeric.indexOf('e');\n             if (qualExpPos == -1) { qualExpPos = numeric.indexOf('E'); }\n\n             if(qualDecPos > -1) {\n                 qualMant = numeric.substring(0, qualDecPos);\n                 if(qualExpPos > -1) {\n                      if(qualExpPos < qualDecPos || qualExpPos >= numeric.length() - 1) throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                     qualExp = numeric.substring(qualExpPos + 1);\n                 }\n             } else if (qualExpPos > -1) {\n                 if(qualExpPos >= numeric.length() - 1) throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                 qualMant = numeric.substring(0, qualExpPos);\n                 qualExp = numeric.substring(qualExpPos + 1);\n             }\n            // Use qualMant and qualExp for allZeros check\n            final boolean allZeros = isAllZeros(qualMant) && isAllZeros(qualExp);\n\n            switch (lastChar) {\n                case 'l':\n                case 'L':\n                    // L/l only valid for integer types (no decimal, no exponent in original string structure)\n                    if (dec == null && exp == null && numeric.matches(\"-?(\\\\d+)\")) {\n                         try {\n                             // Use createLong which handles octal/sign if needed (hex handled earlier)\n                             return createLong(numeric);\n                         } catch (final NumberFormatException nfe) {\n                             // Fall through to BigInteger for overflow\n                         }\n                         return createBigInteger(numeric); // Handles octal/sign if needed\n                    }\n                    throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n\n                case 'f':\n                case 'F':\n                    try {\n                        final Float f = createFloat(numeric);\n                        // Original behavior check: prevent returning 0.0f for tiny non-zero values if !allZeros\n                        if (f.isInfinite() || (f.floatValue() == 0.0F && !allZeros)) {\n                             // Match original behavior: if Float representation is zero or infinite (and input wasn't all zeros),\n                             // it might indicate precision/range issue for Float. Fall through (implicitly handled by throwing NFE below).\n                             // Throw NFE because Float type was explicitly requested but resulted in value loss/range issue.\n                             throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                        }\n                        // If it parses to a non-infinite, non-zero (or zero if input was zero) float, return it.\n                        return f;\n                    } catch (final NumberFormatException nfe) {\n                         throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                    }\n                    // No fall-through\n\n                case 'd':\n                case 'D':\n                    try {\n                        final Double d = createDouble(numeric);\n                         // Original behavior check (similar to Float)\n                        if (d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros)) { // Fixed: use doubleValue\n                            throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                        }\n                         return d;\n                    } catch (final NumberFormatException nfe) {\n                         throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n                    }\n                    // No fall-through\n\n                default:\n                    throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n            }\n        } // End type qualifier processing\n\n\n        // No type qualifier: Auto-detect best type\n\n        // Case 1: Integral number (no decimal, no exponent)\n        if (decPos == -1 && expPos == -1) {\n             // Check for octal: starts with '0', length > 1, all digits 0-7\n             // Special case: \"0\" is Integer 0, not octal.\n            if (str.charAt(0) == '0' && str.length() > 1) {\n                boolean allOctalDigits = true;\n                for (int i = 1; i < str.length(); i++) {\n                    if (str.charAt(i) < '0' || str.charAt(i) > '7') {\n                        allOctalDigits = false;\n                        break;\n                    }\n                }\n                if (allOctalDigits) {\n                    // Try parsing as octal Integer -> Long -> BigInteger\n                     try {\n                         // Use decode for octal handling\n                         return createInteger(str);\n                     } catch (final NumberFormatException nfe1) {\n                          try {\n                              return createLong(str);\n                          } catch (final NumberFormatException nfe2) {\n                               // BigInteger helper must handle octal prefix\n                               return createBigInteger(str);\n                          }\n                     }\n                }\n                // If starts with '0' but not valid octal (e.g., \"09\"), treat as decimal below.\n            }\n\n            // Treat as decimal Integer -> Long -> BigInteger\n             try {\n                 return createInteger(str); // Assumes handles decimal/sign\n             } catch (final NumberFormatException nfe1) {\n                 try {\n                     return createLong(str); // Assumes handles decimal/sign\n                 } catch (final NumberFormatException nfe2) {\n                      return createBigInteger(str); // Assumes handles decimal/sign\n                 }\n             }\n        } // End integral auto-detect\n\n\n        // Case 2: Floating point number (has decimal and/or exponent)\n        // Auto-detect Float -> Double -> BigDecimal, checking precision.\n        final boolean checkAllZeros = isAllZeros(mant) && isAllZeros(exp);\n\n        try {\n            final Float f = createFloat(str);\n            // Check for range issues and spurious zero compared to original string\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !checkAllZeros))) {\n                // Float is in range and not spuriously zero. Check precision.\n                // Compare its BigDecimal value to the original string's BigDecimal value.\n                // Use try-with-resources or careful NFE handling for BigDecimal creation.\n                 try {\n                     final BigDecimal bd = createBigDecimal(str);\n                    if (BigDecimal.valueOf(f.floatValue()).compareTo(bd) == 0) {\n                        return f; // Float is precise enough\n                    }\n                 } catch (NumberFormatException nfeIgnore) {\n                      // Ignore NFE from createBigDecimal, proceed to Double check\n                 }\n            }\n        } catch (final NumberFormatException nfeIgnore) {\n            // Ignore NFE from createFloat, proceed to Double check\n        }\n\n        try {\n            final Double d = createDouble(str);\n            // Check for range issues and spurious zero (fixed: use doubleValue)\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !checkAllZeros))) {\n                 // Double is in range. Check precision.\n                 try {\n                    final BigDecimal bd = createBigDecimal(str);\n                    if (BigDecimal.valueOf(d.doubleValue()).compareTo(bd) == 0) {\n                         return d; // Double is precise enough\n                    }\n                 } catch (NumberFormatException nfeIgnore) {\n                     // Ignore NFE from createBigDecimal, proceed to final BigDecimal fallback\n                 }\n            }\n        } catch (final NumberFormatException nfeIgnore) {\n             // Ignore NFE from createDouble, proceed to final BigDecimal fallback\n        }\n\n        // Fallback for floating point numbers: Create and return BigDecimal\n        return createBigDecimal(str);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}