{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\n// Added missing imports and helper stubs if needed for context, actual fix is within the function.\n// Assumed helper methods like createFloat, createDouble, createBigDecimal, createInteger, createLong, createBigInteger, isDigits, isAllZeros exist and function correctly based on their names.\n\npublic class NumberUtils {\n\n    // Stubs for dependencies - Actual implementations are in Apache Commons Lang\n    private static Float createFloat(String s) { return Float.valueOf(s); }\n    private static Double createDouble(String s) { return Double.valueOf(s); }\n    private static Integer createInteger(String s) { return Integer.decode(s); }\n    private static Long createLong(String s) { return Long.decode(s); }\n    private static BigInteger createBigInteger(String s) {\n        // Simplified stub: Real impl needs proper hex/octal handling\n        int radix = 10;\n        int pfxLen = 0;\n        if (s.startsWith(\"0x\") || s.startsWith(\"0X\")) { radix = 16; pfxLen=2; }\n        else if (s.startsWith(\"#\")) { radix = 16; pfxLen=1; }\n        else if (s.startsWith(\"0\") && s.length() > 1) { radix = 8; pfxLen=1; } // Basic octal detection\n\n        if (pfxLen > 0) s = s.substring(pfxLen);\n\n        // Handle negative sign if present after prefix removal (e.g. \"-#abc\")\n        boolean negative = false;\n        if (s.startsWith(\"-\")) {\n           negative = true;\n           s = s.substring(1);\n           if (s.startsWith(\"0x\") || s.startsWith(\"0X\")) { radix = 16; pfxLen=2; }\n           else if (s.startsWith(\"#\")) { radix = 16; pfxLen=1; }\n           else if (s.startsWith(\"0\") && s.length() > 1 && radix == 10) { radix = 8; pfxLen=1; } // Handle -0... as octal? Standard might not. Let's assume decimal unless 0x/#\n\n           if (pfxLen > 0) s = s.substring(pfxLen);\n        }\n\n        BigInteger val = new BigInteger(s, radix);\n        return negative ? val.negate() : val;\n    }\n    private static BigDecimal createBigDecimal(String s) { return new BigDecimal(s); }\n    private static boolean isDigits(final String str) {\n        if (StringUtils.isEmpty(str)) return false;\n        for (char c : str.toCharArray()) { if (!Character.isDigit(c)) return false; } return true;\n    }\n    private static boolean isAllZeros(final String str) {\n        if (str == null) return true;\n        for (char c : str.toCharArray()) { if (c != '0') return false; } return str.length() > 0;\n    }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigInteger as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Hex Handling - Simplified using Long.decode / BigInteger parsing logic\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        boolean isHex = false;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                isHex = true;\n                break;\n            }\n        }\n        if (isHex) {\n             // Long.decode handles \"0x\", \"0X\", \"#\" prefixes, signs, and range up to Long.MAX_VALUE\n             try {\n                 return Long.decode(str);\n             } catch (final NumberFormatException nfe) {\n                 // If value is too large for Long, Long.decode throws NFE.\n                 // Fallback to BigInteger for hex. Assumes createBigInteger handles hex.\n                 return createBigInteger(str);\n             }\n        }\n\n        // Octal Handling (added based on JavaDoc)\n        if (str.startsWith(\"0\") && str.length() > 1) {\n            char char1 = str.charAt(1);\n            if (char1 >= '0' && char1 <= '7') { // Possible octal integer\n                 boolean isOctal = true;\n                 // Check if it's purely octal digits and doesn't contain decimal/exponent\n                 for(int i = 1; i < str.length(); i++) {\n                     char c = str.charAt(i);\n                     if (c == '.' || c == 'e' || c == 'E') {\n                         isOctal = false; // Contains decimal/exponent, treat as float below\n                         break;\n                     }\n                     if (c < '0' || c > '7') {\n                         isOctal = false; // Contains non-octal digit (e.g., \"09\"), treat as decimal/float below\n                         break;\n                     }\n                 }\n                 if (isOctal) {\n                     try {\n                         // Long.decode handles octal prefixed with 0 and range up to Long.MAX_VALUE\n                         return Long.decode(str);\n                     } catch (NumberFormatException nfe) {\n                         // If value is too large for Long, fall back to BigInteger.\n                         // Assumes createBigInteger handles octal based on leading 0.\n                         return createBigInteger(str);\n                     }\n                 }\n            } else if (char1 == 'x' || char1 == 'X') {\n                // Should have been caught by hex check above. Defensive check.\n                throw new NumberFormatException(str + \" is not a valid number.\"); // Invalid state\n            }\n            // If starts with \"0\" but not octal (e.g. \"0.\", \"0e\", \"09\"), treat as decimal/float below.\n        }\n\n        // General number parsing\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        // Corrected exponent position finding\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        // Split string into parts\n        if (decPos > -1) { // has decimal\n            if (expPos > -1) { // has exponent\n                if (expPos < decPos || expPos >= str.length()) { // Invalid exponent position\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, decPos);\n                dec = str.substring(decPos + 1, expPos);\n            } else { // no exponent\n                mant = str.substring(0, decPos);\n                dec = str.substring(decPos + 1);\n            }\n        } else { // no decimal\n            if (expPos > -1) { // has exponent\n                if (expPos == 0 || expPos >= str.length()) { // Invalid exponent position\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else { // no decimal, no exponent\n                mant = str;\n            }\n            dec = null; // No decimal part\n        }\n\n        // Check for type qualifier suffix\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            // Determine exponent string if qualifier exists\n            if (expPos > -1 && expPos < str.length() - 1) { // Exponent exists before qualifier\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else if (expPos > -1) { // Exponent indicator right before qualifier (invalid)\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            } else { // No exponent\n                exp = null;\n            }\n\n            final String numeric = str.substring(0, str.length() - 1); // String without qualifier\n            // Corrected allZeros check to include decimal part\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp);\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // L/l suffix requires an integer-like format (no decimal, no exponent part)\n                    if (dec == null && exp == null &&\n                        !numeric.isEmpty() && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric)) ) {\n                        try {\n                            // Assumes createLong/BigInteger can handle potential hex/octal prefixes within `numeric` string\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // If Long parsing fails, try BigInteger\n                             return createBigInteger(numeric);\n                        }\n                    }\n                    // Invalid format for L/l suffix\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = createFloat(numeric);\n                        // Check prevents returning 0.0f if numeric string has non-zeros\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                         // Allow returning Inf/-Inf or 0.0f if the string truly represents them\n                         if (f.isInfinite() && !allZeros) return f; // Allow Inf if not all zeros\n                         if (f.floatValue() == 0.0F && allZeros) return f; // Allow 0.0f if all zeros\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // If createFloat fails, the numeric part is invalid for float\n                    }\n                    // If createFloat failed or produced an unexpected result (like 0.0f for non-zero)\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = createDouble(numeric);\n                         // Check prevents returning 0.0d if numeric string has non-zeros\n                         if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                         // Allow returning Inf/-Inf or 0.0d if the string truly represents them\n                         if (d.isInfinite() && !allZeros) return d; // Allow Inf if not all zeros\n                         if (d.doubleValue() == 0.0D && allZeros) return d; // Allow 0.0d if all zeros\n\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // If createDouble fails, the numeric part is invalid for double\n                    }\n                     // If createDouble failed or produced an unexpected result\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n\n                default : // Character is not a valid number part or known qualifier\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else { // No type qualifier (ends with digit or '.')\n            // Determine exponent string\n            if (expPos > -1 && expPos < str.length() - 1) { // Exponent exists and is not the last char\n                 exp = str.substring(expPos + 1);\n                 // Validate exponent part has valid digits (and optional sign)\n                 char firstExp = exp.charAt(0);\n                 String expDigits = (firstExp == '+' || firstExp == '-') ? exp.substring(1) : exp;\n                 if (expDigits.isEmpty() || !isDigits(expDigits)) {\n                     throw new NumberFormatException(str + \" has invalid exponent.\");\n                 }\n            } else if (expPos > -1) { // Exponent indicator 'e'/'E' is last char or has no digits after it\n                throw new NumberFormatException(str + \" has incomplete exponent.\");\n            } else { // No exponent\n                exp = null;\n            }\n\n            // Determine type: Integral vs Floating Point\n            if (dec == null && exp == null) { // Integral number (no decimal, no exponent)\n                // Try Integer -> Long -> BigInteger\n                try { return createInteger(str); } catch (NumberFormatException nfe) { /* ignore */ }\n                try { return createLong(str); } catch (NumberFormatException nfe) { /* ignore */ }\n                return createBigInteger(str); // Final fallback for integrals\n\n            } else { // Floating point number (has decimal or exponent)\n                final boolean checkZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp);\n\n                // Try Float -> Double -> BigDecimal, checking for precision loss\n                try {\n                    final Float f = createFloat(str);\n                     // Check basic validity (not Inf/NaN, not 0.0 for non-zero string)\n                     if (!(f.isInfinite() || Float.isNaN(f.floatValue()) || (f.floatValue() == 0.0F && !checkZeros))) {\n                         // ** FIX: Check if Float representation is exact **\n                         // Compare BigDecimal created from string with BigDecimal created from Float's string representation\n                         try {\n                             final BigDecimal bd = createBigDecimal(str);\n                             // Use compareTo for numerical comparison, ignoring trailing zeros difference\n                             if (bd.compareTo(new BigDecimal(f.toString())) == 0) {\n                                 return f; // Return Float if it's an exact representation\n                             }\n                         } catch (NumberFormatException nfe_bd) { /* ignore NFE from BigDecimal creation */ }\n                     }\n                } catch (NumberFormatException nfe_float) { /* ignore NFE from createFloat */ }\n\n                try {\n                    final Double d = createDouble(str);\n                    // Check basic validity (not Inf/NaN, not 0.0 for non-zero string)\n                     if (!(d.isInfinite() || Double.isNaN(d.doubleValue()) || (d.doubleValue() == 0.0D && !checkZeros))) {\n                         // ** FIX: Check if Double representation is exact **\n                         // Compare BigDecimal created from string with BigDecimal created from Double's string representation\n                          try {\n                             final BigDecimal bd = createBigDecimal(str);\n                             if (bd.compareTo(new BigDecimal(d.toString())) == 0) {\n                                 return d; // Return Double if it's an exact representation\n                             }\n                         } catch (NumberFormatException nfe_bd) { /* ignore NFE from BigDecimal creation */ }\n                     }\n                } catch (NumberFormatException nfe_double) { /* ignore NFE from createDouble */ }\n\n                // Final fallback for floating point numbers if Float/Double lost precision or failed\n                return createBigDecimal(str);\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}