{
    "generation": "  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exits a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function. (Handled by CFG builder separately)\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If parent is a governing control structure, we special case.\n    switch (parent.getType()) {\n      // The follow() of any path from IF would be what follows IF.\n      case Token.IF:\n        // From the THEN or ELSE block, the follow is the node after the IF.\n        return computeFollowNode(fromNode, parent, cfa);\n\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE/DEFAULT, control goes to the body of the\n        // next case/default, or out of the switch.\n        Node nextCase = parent.getNext();\n        // Find the next CASE or DEFAULT, skipping other nodes (e.g. LABELs).\n        while (nextCase != null && !nextCase.isCase() && !nextCase.isDefaultCase()) {\n          nextCase = nextCase.getNext();\n        }\n\n        if (nextCase != null) {\n          // Go to the body of the next case/default.\n          if (nextCase.isCase()) {\n            // Next case body is the second child (first child is the case value).\n            return computeFallThrough(nextCase.getLastChild());\n          } else { // Default case\n            // Default case body is the first child.\n            return computeFallThrough(nextCase.getFirstChild());\n          }\n        } else {\n          // Done with CASES, flow should continue after the SWITCH.\n          return computeFollowNode(fromNode, parent.getParent(), cfa);\n        }\n\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          // For-in loops are essentially while loops. Fall through leads back to the loop.\n          return parent;\n        } else {\n          // Standard FOR loop: determines the next node based on the current position.\n          Node init = NodeUtil.getForInit(parent);\n          Node condition = NodeUtil.getForCond(parent);\n          Node increment = NodeUtil.getForIncr(parent);\n          Node body = NodeUtil.getForBody(parent);\n\n          if (node == init || node == increment) {\n             // After init or increment, go to condition (at FOR node).\n             return parent;\n          } else if (node == condition) {\n            // After condition (if true), go to body.\n            // This is handled by the edge creation for the condition, not fall-through.\n            // computeFollowNode computes fall-through assuming condition is false.\n            return computeFollowNode(fromNode, parent, cfa); // After the loop\n          } else if (node == body) {\n             // After body, go to increment. If increment is empty, go back to condition (at FOR node).\n            return increment.isEmpty() ? parent : computeFallThrough(increment);\n          }\n        }\n        break; // Added break for FOR loop logic clarity\n\n      case Token.WHILE:\n        // Follow of the body is the WHILE node (re-test condition).\n        // Follow of the condition (false) is after the WHILE loop.\n        if (node == parent.getFirstChild()) { // Node is Condition\n           return computeFollowNode(fromNode, parent, cfa);\n        } else { // Node is Body\n           return parent;\n        }\n\n      case Token.DO:\n        // Follow of the body is the DO node (re-test condition).\n        // Follow of the condition (false) is after the DO loop.\n        if (node == parent.getLastChild()) { // Node is Condition\n            return computeFollowNode(fromNode, parent, cfa);\n        } else { // Node is Body\n            return parent;\n        }\n\n      case Token.TRY:\n        Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n        Node catchNode = NodeUtil.getCatchNode(parent); // The CATCH node itself.\n\n        // If we are coming out of the TRY block body...\n        if (parent.getFirstChild() == node) {\n          // Control flows to CATCH block body (if present), else FINALLY (if present), else after TRY.\n          if (catchNode != null) {\n            return computeFallThrough(catchNode.getFirstChild()); // Catch block body\n          } else if (finallyBlock != null) {\n            return computeFallThrough(finallyBlock);\n          } else {\n            return computeFollowNode(fromNode, parent, cfa); // After TRY\n          }\n        // If we are coming out of the CATCH block body...\n        } else if (catchNode != null && catchNode.getFirstChild() == node) {\n           // Control flows to FINALLY (if present), else after TRY.\n           if (finallyBlock != null) {\n             return computeFallThrough(finallyBlock);\n           } else {\n             return computeFollowNode(fromNode, parent, cfa); // After TRY\n           }\n        // If we are coming out of the FINALLY block...\n        } else if (finallyBlock != null && finallyBlock == node) {\n           // Check if any jumps (return, break, continue, throw) targeted this finally.\n           // A finallyMap entry exists if a jump occurred in the corresponding try/catch.\n           boolean jumpTargetedThisFinally = cfa != null && cfa.finallyMap.containsKey(parent);\n           Node outerFinally = (cfa == null) ? null : cfa.getFinallyBlock(parent.getParent());\n\n           if (outerFinally != null) {\n             // If there is an outer finally, control always transfers there next,\n             // regardless of whether we got here normally or via jump.\n             return computeFallThrough(outerFinally);\n           } else {\n             // No outer finally block.\n             if (jumpTargetedThisFinally) {\n               // This finally was entered due to a jump. Resume the jump.\n               // Create edges from the exit of this finally ('node') to the jump target(s).\n               // This is necessary because handleFinally may not correctly create these edges\n               // from the *exit* of the finally block.\n               for (Node finallyTarget : cfa.finallyMap.get(parent)) {\n                   cfa.createEdge(node, Branch.UNCOND, finallyTarget);\n               }\n               // Return null: flow determined by jump edges, not normal fall-through.\n               return null;\n             } else {\n               // Normal fall-through from finally. Continue after the TRY statement.\n               return computeFollowNode(fromNode, parent, cfa);\n             }\n           }\n        }\n        // If control reaches here, 'node' is likely the TRY node itself, or CATCH node.\n        // Fall through to sibling logic.\n        break; // End of TRY case\n    } // End switch\n\n    // If not handled by special parent processing, follow should be the next sibling.\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      // Fall through to the next statement in the block.\n      return computeFallThrough(nextSibling);\n    } else {\n      // No more siblings. Transfer control up the AST.\n      // Let the parent's computeFollowNode decide.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}