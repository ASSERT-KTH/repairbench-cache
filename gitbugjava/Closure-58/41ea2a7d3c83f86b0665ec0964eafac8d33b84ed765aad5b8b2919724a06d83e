{
    "generation": "  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        // Avoid visiting function blocks for definitions. Recurse into function\n        // blocks for expressions.\n        if (n.getParent() != null && n.getParent().isFunction()) {\n          return;\n        }\n        // Otherwise, definitions are always visited and computed.\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeGenKill(c, gen, kill, conditional);\n        }\n        return;\n\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          // Regular FOR loop. We compute the gen/kill for the condition,\n          // increment, and initialization. The body is handled by the\n          // dataflow analysis framework.\n          if (NodeUtil.isForIn(n)) throw new IllegalStateException(); // Should not happen\n\n          Node init = n.getFirstChild();\n          Node cond = init.getNext();\n          Node incr = cond.getNext();\n          // Compute the initialization.\n          computeGenKill(init, gen, kill, conditional);\n          // Compute the condition.\n          computeGenKill(cond, gen, kill, conditional);\n          // Compute the increment.\n          computeGenKill(incr, gen, kill, conditional);\n        } else {\n          // FOR-IN loop. Format: for(iteratee in collection) { body }\n          Node iteratee = n.getFirstChild();\n          Node collection = iteratee.getNext();\n\n          // 1. Analyze the collection expression (RHS). Its value is used.\n          computeGenKill(collection, gen, kill, conditional);\n\n          // 2. Handle the iteratee (LHS). It's assigned to.\n          if (NodeUtil.isVar(iteratee)) {\n             // E.g., for(var x in collection)\n             // The VAR node itself doesn't read/write, but its child NAME does.\n             Node varNameNode = iteratee.getFirstChild();\n             if (varNameNode != null && varNameNode.isName()) {\n               // The assignment to 'x' kills the variable. It's unconditional.\n               addToSetIfLocal(varNameNode, kill);\n               // NOTE: A VAR declaration like this doesn't *read* the variable 'x'.\n             } else {\n               // Might be destructuring, e.g., for(var {a,b} in ...)\n               // Analyze the pattern recursively for reads/writes.\n               computeGenKill(iteratee, gen, kill, conditional);\n             }\n           } else if (NodeUtil.isName(iteratee)) {\n             // E.g., for(x in collection)\n             // The assignment to 'x' kills the variable. It's unconditional.\n             addToSetIfLocal(iteratee, kill);\n             // NOTE: This assignment doesn't *read* the variable 'x'.\n           } else {\n             // E.g., for(a[i] in collection) or for(obj.prop in collection)\n             // This assigns to a property, not directly to a local variable.\n             // We need to analyze the iteratee expression for any local variables read.\n             computeGenKill(iteratee, gen, kill, conditional);\n           }\n           // The body is handled by the dataflow analysis framework.\n        }\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          // Must be NAME node.\n          if (!c.isName()) {\n             throw new IllegalStateException(\"Expected NAME node, got \" + c.getToken());\n          }\n          // If the variable has an initializer, compute its gen/kill set.\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n          }\n          // A variable definition always kills the variable. If the definition\n          // is conditional (i.e. VAR declaration within an IF), it might not\n          // kill the variable. LiveVariableAnalysis assumes VAR declarations are\n          // hoisted and always kill. But FlowSensitiveInlineVariables needs it.\n          if (!conditional) {\n              addToSetIfLocal(c, kill);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK: // ternary operator ?:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          // A read of a variable generates the variable.\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n)) {\n           Node lhs = n.getFirstChild();\n           Node rhs = n.getLastChild(); // Assignments are BINOPs\n\n           // Analyze RHS first, as its value is used for assignment.\n           computeGenKill(rhs, gen, kill, conditional);\n\n           if (NodeUtil.isName(lhs)) {\n             // Simple assignment: x = ... or x += ...\n             if (!conditional) {\n               // Unconditional assignment kills the LHS variable.\n               addToSetIfLocal(lhs, kill);\n             }\n             if (!NodeUtil.isAssign(n)) {\n               // Compound assignments (e.g., +=, *=) also read the LHS.\n               addToSetIfLocal(lhs, gen);\n             }\n           } else {\n             // Complex assignment LHS (e.g., a[i] = ..., obj.prop = ...)\n             // Analyze the LHS expression for reads.\n             computeGenKill(lhs, gen, kill, conditional);\n             // This assignment doesn't directly kill a local variable.\n           }\n\n        } else {\n          // For other node types, traverse the children.\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}