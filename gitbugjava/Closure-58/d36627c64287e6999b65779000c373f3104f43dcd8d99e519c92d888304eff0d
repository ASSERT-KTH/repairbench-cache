{
    "generation": "  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        // These nodes defines scopes, they are not part of the CFG itself.\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // Only the condition expression affects the GEN/KILL sets locally.\n        // The body is handled by the dataflow graph traversal.\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          // Handles FOR(init; condition; increment)\n          // We only compute the GEN/KILL for the parts executed before the\n          // loop body in the first iteration or between iterations.\n          // The order is: init, condition, body, increment\n          // GEN/KILL for the FOR node itself should represent the condition.\n          // Init and increment GEN/KILL influence the state *before* the\n          // condition check or *after* the body, handled by graph edges.\n          // Let's stick to the original simple approach of just condition for now.\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          // Handles FOR(lhs IN rhs)\n          // The node represents the check and assignment part of the loop.\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n\n          // Compute GEN/KILL for the RHS expression (e.g., 'obj' in for(k in obj))\n          // Variables used in 'rhs' are read here.\n          computeGenKill(rhs, gen, kill, conditional);\n\n          // Handle the LHS, which is the target of assignment.\n          if (NodeUtil.isVar(lhs)) {\n            // Case: for(var x in rhs)\n            // The variable 'x' is declared and assigned within the loop.\n            Node nameNode = lhs.getFirstChild(); // The NAME node 'x'\n            // This assignment might kill a previous value of 'x' if not conditional.\n            if (!conditional) {\n              addToSetIfLocal(nameNode, kill);\n            }\n            // The VAR declaration itself or the NAME node 'x' is not read here.\n          } else if (NodeUtil.isName(lhs)) {\n            // Case: for(x in rhs)\n            // The variable 'x' is assigned.\n            // This assignment might kill a previous value of 'x' if not conditional.\n             if (!conditional) {\n               addToSetIfLocal(lhs, kill);\n            }\n            // The NAME node 'x' is not read here; it's the assignment target.\n          } else {\n            // Case: for(a[i] in rhs) or other complex LHS\n            // Compute GEN/KILL for the LHS expression itself to find reads\n            // within it (e.g., 'a' and 'i' in a[i]).\n            computeGenKill(lhs, gen, kill, conditional);\n            // The assignment is to a property or element, not directly to a\n            // local variable, so no local variable is killed here.\n          }\n        }\n        return;\n\n      case Token.VAR:\n        // Variable declaration: var name1 [= expr1] [, name2 [= expr2] ...];\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          // c is the NAME node.\n          if (c.hasChildren()) {\n            // If there's an initializer (c.getFirstChild()), compute its GEN/KILL.\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            // The assignment from the initializer kills the variable.\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n          // A var declaration introduces the variable, but doesn't kill unless\n          // there is an initializer and it's unconditional.\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        // Short-circuiting operators: lhs && rhs, lhs || rhs\n        // Process LHS first.\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // The RHS is conditional.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        // Ternary operator: condition ? trueExpr : falseExpr\n        // Process condition first.\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Both branches are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        // A use of a variable name.\n        if (isArgumentsName(n)) {\n          // Special handling for 'arguments'.\n          markAllParametersEscaped();\n        } else {\n          // Reading a variable adds it to the GEN set.\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        // Handle assignment operations and other expressions recursively.\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          // Assignment: lhs = rhs, lhs += rhs, etc., where lhs is a simple NAME.\n          Node lhs = n.getFirstChild();\n\n          // Process RHS first to compute its GEN set.\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n\n          // If it's a compound assignment (e.g., +=), the LHS is also read.\n          if (!NodeUtil.isAssign(n)) {\n            addToSetIfLocal(lhs, gen);\n          }\n          // The assignment kills the LHS variable if unconditional.\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n        } else {\n          // For other operations or complex assignments (e.g., a[i] = rhs),\n          // recursively compute GEN/KILL for children.\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}