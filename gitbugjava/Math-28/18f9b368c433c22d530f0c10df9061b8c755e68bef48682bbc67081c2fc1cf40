{
    "generation": "    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        // Start loop from the first constraint row\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col); // Entry in pivot column\n\n            // Check if the entry in the pivot column is positive (greater than zero within precision)\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // Use Double.compare for strict comparison as in original code\n                // Note: Consider Precision.compareTo for robustness if needed later\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    // Add row to the list of ties\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    // Found a new minimum ratio\n                    minRatio = ratio;\n                    minRatioPositions.clear(); // Clear existing list\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.isEmpty()) { // Check if list is empty\n            return null; // No suitable pivot row found (unbounded solution likely)\n        } else if (minRatioPositions.size() > 1) {\n            // Degeneracy: Tie in the minimum ratio test\n\n            // 1. Check if there's an artificial variable that can be forced out of the basis\n            //    among the tied rows. Prioritize removing artificial variables.\n            for (Integer row : minRatioPositions) {\n                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                    int artificialCol = i + tableau.getArtificialVariableOffset();\n                    // Ensure the artificial variable column index is valid\n                    if (artificialCol < tableau.getWidth() - 1) {\n                         final double entry = tableau.getEntry(row, artificialCol);\n                         // Check if the entry is 1 (within precision) and if this artificial variable\n                         // is basic in the current row according to the tableau's state.\n                         Integer basicRow = tableau.getBasicRow(artificialCol);\n                         if (basicRow != null && basicRow.equals(row) && Precision.equals(entry, 1d, maxUlps)) {\n                             // Found an artificial variable basic in this tied row, choose this row.\n                             return row;\n                         }\n                    }\n                }\n            }\n\n            // 2. If no artificial variable can be forced out, apply Bland's rule to prevent cycling:\n            //    Select the row for which the corresponding basic variable has the smallest index.\n            Integer minRow = null;\n            int minIndex = Integer.MAX_VALUE; // Initialize with max value for correct comparison\n\n            for (Integer row : minRatioPositions) { // Iterate through the tied rows\n                int basicVarIndex = -1; // Index of the basic variable for this row\n\n                // Find the column index 'j' of the basic variable for the current 'row'\n                // Iterate through ALL variable columns (index 0 to width - 2)\n                for (int j = 0; j < tableau.getWidth() - 1; j++) {\n                    Integer basicRowForJ = tableau.getBasicRow(j);\n                    // Use .equals() for Integer comparison and check for null\n                    if (basicRowForJ != null && basicRowForJ.equals(row)) {\n                        basicVarIndex = j;\n                        break; // Found the unique basic variable for this row\n                    }\n                }\n\n                // If a basic variable was found (should always be true for a valid basic row in the basis)\n                // and its index is smaller than the current minimum index found so far\n                if (basicVarIndex != -1 && basicVarIndex < minIndex) {\n                    minIndex = basicVarIndex;\n                    minRow = row; // Update the row associated with the smallest basic variable index\n                }\n            }\n            // Return the row selected by Bland's rule.\n            // The heuristic mentioned in the original comments (based on maxIterations) is not applied here,\n            // relying solely on the correctness of Bland's rule implementation.\n            return minRow;\n\n        } else {\n            // No tie, return the unique row with the minimum ratio\n            return minRatioPositions.get(0);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}