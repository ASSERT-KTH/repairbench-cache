{
    "generation": "import java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.math3.util.Precision;\n\n// Assuming the context of the SimplexSolver class where SimplexTableau, Precision,\n// and the maxUlps field are defined and accessible.\n\n    /**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio\n     */\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        // Iterate through constraint rows (from first constraint row to last)\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col); // Pivot column entry in this row\n\n            // Check if the entry in the pivot column is positive (standard MRT condition)\n            // Consider numerical precision using Precision.compareTo with maxUlps\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // Compare ratio with current minimum ratio\n                // Use precise comparison for tie detection (no epsilon/ulp check here for equality)\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    // Ratio is equal to the current minimum, add row to the list of ties\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    // Found a new minimum ratio\n                    minRatio = ratio;\n                    minRatioPositions.clear(); // Clear previous ties\n                    minRatioPositions.add(i);  // Add the new minimum row\n                }\n            }\n        }\n\n        if (minRatioPositions.isEmpty()) { // Use isEmpty() for clarity\n            return null; // No eligible pivot row found (unbounded solution likely)\n        } else if (minRatioPositions.size() > 1) {\n            // Degeneracy: Tie in the minimum ratio test. Apply tie-breaking rules.\n\n            // 1. Check if an artificial variable can be forced out.\n            // Prioritize rows where an artificial variable is basic.\n            for (Integer row : minRatioPositions) {\n                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                    int artificialVarColumn = i + tableau.getArtificialVariableOffset();\n                    Integer basicRow = tableau.getBasicRow(artificialVarColumn);\n                    // Check if this artificial variable is basic in the current candidate row 'row'\n                    // Use .equals() for Integer comparison and handle null basicRow.\n                    if (basicRow != null && basicRow.equals(row)) {\n                         // Check if the entry is 1 (standard for basic variable in canonical form)\n                         // This check was in the original code, retain it for robustness.\n                         final double entry = tableau.getEntry(row, artificialVarColumn);\n                         if (Precision.equals(entry, 1d, maxUlps)) {\n                             // Found an artificial variable basic in this row. Choose this row.\n                             return row;\n                         }\n                    }\n                }\n            }\n\n            // 2. Apply Bland's rule if no artificial variable could be forced out.\n            // Choose the row corresponding to the basic variable with the smallest column index.\n            Integer minRow = null;\n            int minIndex = Integer.MAX_VALUE; // Initialize with a value larger than any possible column index\n\n            for (Integer row : minRatioPositions) {\n                int basicVarIndex = -1; // Index of the basic variable in this row\n                // Find the column index 'j' of the basic variable for 'row'\n                // Iterate over all columns that could represent variables (typically 0 to width - 2)\n                // Assuming getBasicRow(j) returns null or the row index if column j corresponds to a basic variable.\n                for (int j = 0; j < tableau.getWidth() - 1; j++) { // Check columns 0 to width-2 (excluding RHS)\n                    Integer basicRowForJ = tableau.getBasicRow(j);\n                    // Check if variable 'j' is basic and if it's basic in the current 'row'\n                    if (basicRowForJ != null && basicRowForJ.equals(row)) {\n                        basicVarIndex = j;\n                        break; // Found the basic variable for this row\n                    }\n                }\n\n                // If we found a basic variable for this row (basicVarIndex != -1)\n                // and its index is smaller than the minimum index found so far among the tied rows\n                if (basicVarIndex != -1 && basicVarIndex < minIndex) {\n                    minIndex = basicVarIndex;\n                    minRow = row;\n                }\n            }\n            // Return the row selected by Bland's rule.\n            // If minRow remains null (e.g., if getBasicRow failed unexpectedly for all tied rows),\n            // this will return null, consistent with the original code's potential outcome in that scenario.\n             return minRow;\n\n        } else {\n            // No tie, return the unique row with the minimum ratio.\n            return minRatioPositions.get(0);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}