{
    "generation": "    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     * Vowels and H, W are mapped to '0'.\n     * Y is also mapped to '0'.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        // mappedChar is expected to be '0' for vowels and H, W, Y\n        final char mappedChar = this.map(str.charAt(index));\n\n        // HW rule check: Consonants (non-'0') from the same code group (#)\n        // separated by H or W, are treated as one: C1 H C2 -> C1 #, C1 W C2 -> C1 #\n        // Only apply the rule if the current character has a mapping code (is a consonant).\n        if (index > 0 && mappedChar != '0') {\n            final char prevChar = str.charAt(index - 1);\n            // Check if the previous character was H or W\n            if ('H' == prevChar || 'W' == prevChar) {\n                // Need to check the character before H/W\n                // Ensure index isn't too low (at least 2 chars before current)\n                if (index > 1) {\n                    final char preHWChar = str.charAt(index - 2);\n                    final char firstCode = this.map(preHWChar);\n                    // If the code before H/W is the same as the current code,\n                    // the current char is ignored (treated as one with C1)\n                    if (firstCode == mappedChar) {\n                        return '0'; // Return '0' to signify it should be ignored\n                    }\n                }\n                // If index is 1 (i.e., sequence is H C2 or W C2 at start),\n                // C2 is not ignored by HW rule (no C1 to compare). Handled by main loop.\n            }\n        }\n        // Also handle the case where the character immediately preceding\n        // the current character maps to the same code.\n        // This logic is typically handled in the main loop comparing with 'last',\n        // but the original code had index > 1 check which suggests some context awareness here.\n        // However, based on test case failure analysis, the primary issue seems to be\n        // either the extra condition `|| 'H' == preHWChar || 'W' == preHWChar`\n        // or the return of integer 0 instead of char '0'.\n        // The extra condition `|| 'H' == preHWChar || 'W' == preHWChar` in the original code\n        // caused characters to be ignored incorrectly (e.g. the 'D' in 'yhwdyt').\n        // Removing it makes the HW rule check more precise.\n        // Returning '0' (char) is consistent with how map() indicates ignored chars.\n\n        // Corrected HW Rule check (simplified from original buggy version):\n        if (index > 1 && mappedChar != '0') { // Need index > 1 for preHWChar\n            final char hwChar = str.charAt(index - 1);\n            if ('H' == hwChar || 'W' == hwChar) {\n                final char preHWChar = str.charAt(index - 2);\n                final char firstCode = this.map(preHWChar);\n                // If the consonant before H/W maps to the same code, ignore current consonant.\n                if (firstCode == mappedChar) {\n                    return '0'; // Use char '0'\n                }\n            }\n        }\n\n        return mappedChar;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}