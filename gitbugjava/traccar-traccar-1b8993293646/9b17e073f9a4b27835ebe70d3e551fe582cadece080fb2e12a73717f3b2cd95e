{
    "generation": "    private Object decodeLocationNew(\n            Channel channel, SocketAddress remoteAddress, String sentence) {\n\n        Parser parser = new Parser(PATTERN_NEW, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        String imei = parser.next(); // Group 1: IMEI\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        String index = parser.next(); // Group 2: Index (used for response)\n\n        parser.next(); // Group 3: Skip Type (e.g., \"A03\")\n        \n        // Group 4: Alarm. parser.nextInt(0) gets the next group as int, defaults to 0 if empty/invalid.\n        position.set(Position.KEY_ALARM, decodeAlarm(parser.nextInt(0)));\n\n        // Group 5: Device Time. Fifotrack protocol often uses UTC.\n        position.setDeviceTime(parser.nextDateTime(TimeZone.getTimeZone(\"UTC\")));\n\n        // Parser now operates on Group 6: (.*) data part.\n        // e.g., \"460|0|25FC|AC2AB0B,3.74,52,0019,0,A,0,13,22.643466,114.018211\"\n\n        Network network = new Network();\n        String cellTowerString = parser.next(); // Consumes cell tower data e.g., \"460|0|25FC|AC2AB0B\"\n        if (cellTowerString != null) {\n            String[] cellParts = cellTowerString.split(\"\\\\|\");\n            if (cellParts.length == 4) {\n                try {\n                    network.addCellTower(CellTower.from(\n                            Integer.parseInt(cellParts[0]),   // MCC\n                            Integer.parseInt(cellParts[1]),   // MNC\n                            Integer.parseInt(cellParts[2], 16), // LAC (Hex)\n                            Integer.parseInt(cellParts[3], 16)  // CID (Hex)\n                    ));\n                } catch (NumberFormatException e) {\n                    // Silently ignore malformed cell tower data\n                }\n            }\n        }\n        // Parser is now at the token after cell tower string (e.g., \"3.74\")\n\n        position.set(Position.KEY_BATTERY, parser.nextDouble());\n        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n        position.set(Position.KEY_STATUS, parser.nextHexInt());\n\n        // Parser is now at the token after status (e.g., \"0\" for Ignition)\n        // This field is ignition, consume it.\n        if (parser.hasNext()) {\n            position.set(Position.KEY_IGNITION, parser.nextInt() == 1);\n        }\n        // Parser is now at the token after ignition (e.g., \"A\" for Validity)\n\n        // Check remaining fields to determine GPS data structure\n        if (parser.hasNext(6)) { // Full GPS: Valid, FixOffset, Sats, Speed, Lat, Lon\n            position.setValid(parser.next().equals(\"A\"));\n            position.setFixTime(position.getDeviceTime()); // Original logic, set fix time to device time\n            parser.skip(); // Skip FixOffset\n            position.set(Position.KEY_SATELLITES, parser.nextInt());\n            position.setSpeed(UnitsConverter.knotsFromKph(parser.nextInt()));\n            position.setLatitude(parser.nextDouble());\n            position.setLongitude(parser.nextDouble());\n        } else if (parser.hasNext(5)) { // GPS without Speed: Valid, FixOffset, Sats, Lat, Lon\n            position.setValid(parser.next().equals(\"A\"));\n            position.setFixTime(position.getDeviceTime());\n            parser.skip(); // Skip FixOffset\n            position.set(Position.KEY_SATELLITES, parser.nextInt());\n            // No Speed field in this variant\n            position.setLatitude(parser.nextDouble());\n            position.setLongitude(parser.nextDouble());\n        } else {\n            // Not enough fields for standard GPS, assume WiFi data\n            // This branch is taken if parser.hasNext() < 5 after ignition\n            if (parser.hasNext()) { // Check if there's any data left for WiFi\n                String[] points = parser.next().split(\"\\\\|\");\n                for (String point : points) {\n                    String[] wifi = point.split(\":\");\n                    if (wifi.length == 2) {\n                        String mac = wifi[0].replaceAll(\"(..)\", \"$1:\");\n                        // Remove trailing colon if present (e.g. AA:BB:CC:)\n                        if (mac.length() > 0 && mac.charAt(mac.length() - 1) == ':') {\n                            mac = mac.substring(0, mac.length() - 1);\n                        }\n                        network.addWifiAccessPoint(WifiAccessPoint.from(\n                                mac, Integer.parseInt(wifi[1])));\n                    }\n                }\n            }\n        }\n\n        position.setNetwork(network);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyMMddHHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        String response = index + \",A03,\" + dateFormat.format(new Date()); // Type \"A03\" is hardcoded\n        sendResponse(channel, remoteAddress, imei, response);\n\n        return position;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}