{
    "generation": "    private Object decodeLocationNew(\n            Channel channel, SocketAddress remoteAddress, String sentence) {\n\n        Parser parser = new Parser(PATTERN_NEW, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        String imei = parser.next();\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        String index = parser.next();\n        String type = parser.next(); // Consume message type (e.g., \"A03\")\n        parser.next(); // Consume reserved field (often empty)\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.setDeviceTime(parser.nextDateTime());\n\n        Network network = new Network();\n        String cellData = parser.next();\n        String[] cellParts = cellData.split(\"\\\\|\");\n        if (cellParts.length >= 4) {\n            try {\n                network.addCellTower(CellTower.from(\n                        Integer.parseInt(cellParts[0]),   // mcc\n                        Integer.parseInt(cellParts[1]),   // mnc\n                        Integer.parseInt(cellParts[2], 16), // lac (hex)\n                        Integer.parseInt(cellParts[3], 16)));// cid (hex)\n            } catch (NumberFormatException e) {\n                // Optional: Log parsing error for cell data\n            }\n        }\n\n        position.set(Position.KEY_BATTERY, parser.nextDouble());\n        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n        position.set(Position.KEY_STATUS, parser.nextHexInt());\n\n        // Parse alarm from its correct field (after status)\n        position.set(Position.KEY_ALARM, decodeAlarm(parser.nextInt()));\n\n        if (parser.hasNext(5)) { // GPS data: validity, (field for speed), (field for satellites), latitude, longitude\n\n            position.setValid(parser.next().equals(\"A\"));\n            position.setFixTime(position.getDeviceTime()); // Using deviceTime as fixTime, common if no separate GPS timestamp\n\n            // Swapped order to match test expectation for satellites=13 from \"A,0,13\" (0=speed, 13=sat)\n            position.setSpeed(UnitsConverter.knotsFromKph(parser.nextInt()));\n            position.set(Position.KEY_SATELLITES, parser.nextInt());\n            \n            position.setLatitude(parser.nextDouble());\n            position.setLongitude(parser.nextDouble());\n\n        } else { // WiFi data\n\n            String[] points = parser.next().split(\"\\\\|\");\n            for (String point : points) {\n                String[] wifi = point.split(\":\");\n                if (wifi.length == 2) {\n                    String mac = wifi[0].replaceAll(\"(..)\", \"$1:\");\n                    if (mac.endsWith(\":\")) {\n                        mac = mac.substring(0, mac.length() - 1);\n                    }\n                    try {\n                        network.addWifiAccessPoint(WifiAccessPoint.from(\n                                mac, Integer.parseInt(wifi[1])));\n                    } catch (NumberFormatException e) {\n                        // Optional: Log parsing error for wifi data\n                    }\n                }\n            }\n        }\n\n        position.setNetwork(network);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyMMddHHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        // Use parsed 'type' in response instead of hardcoded \"A03\"\n        String response = index + \",\" + type + \",\" + dateFormat.format(new Date());\n        sendResponse(channel, remoteAddress, imei, response);\n\n        return position;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}