{
    "generation": "    private Object decodeLocationNew(\n            Channel channel, SocketAddress remoteAddress, String sentence) {\n\n        Parser parser = new Parser(PATTERN_NEW, sentence);\n        if (!parser.matches()) {\n            return null;\n        }\n\n        String imei = parser.next();\n        DeviceSession deviceSession = getDeviceSession(channel, remoteAddress, imei);\n        if (deviceSession == null) {\n            return null;\n        }\n\n        String index = parser.next();\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(parser.nextHexInt())); // Alarm is hexadecimal\n\n        parser.next(); // Consume reserved field\n\n        position.setDeviceTime(parser.nextDateTime());\n\n        Network network = new Network();\n        // Cell Tower: MCC is 460 (fixed), MNC is decimal, LAC/CID are hexadecimal\n        network.addCellTower(CellTower.from(\n                460, parser.nextInt(), parser.nextHexInt(), parser.nextHexInt()));\n\n        position.set(Position.KEY_BATTERY, parser.nextDouble());\n        position.set(Position.KEY_BATTERY_LEVEL, parser.nextInt());\n        position.set(Position.KEY_STATUS, parser.nextHexInt()); // Status is hexadecimal\n\n        // GPS/LBS data parsing logic\n        // Regex structure implies: (status G11), then choice:\n        // 1. (type G12), (optional GPS G13-G17)\n        // 2. (WiFi G18)\n        // Parser index is at G11 (status). parser.hasNext() checks G12.\n        if (parser.hasNext()) {\n            String typeFieldValue = parser.peekNext(); // Peek at G12 content\n\n            // Check if G12 is the \"type\" field (\"0\" or \"1\")\n            if (typeFieldValue != null && (typeFieldValue.equals(\"0\") || typeFieldValue.equals(\"1\"))) {\n                // Path 1: G12 is type. So, (type G12), (optional GPS G13-G17)\n                parser.next(); // Consume G12 (type field)\n\n                // Check for optional GPS fields (G13-G17). hasNext(5) checks G13 through G17.\n                if (parser.hasNext(5)) {\n                    position.setValid(parser.next().equals(\"A\")); // G13 (validity)\n                    position.setFixTime(position.getDeviceTime()); // Use device time as fix time\n                    position.set(Position.KEY_SATELLITES, parser.nextInt()); // G14 (satellites)\n                    position.setSpeed(UnitsConverter.knotsFromKph(parser.nextInt())); // G15 (speed)\n                    position.setLatitude(parser.nextDouble());  // G16 (latitude)\n                    position.setLongitude(parser.nextDouble()); // G17 (longitude)\n                } else {\n                    // Type was present, but GPS fields G13-G17 are not (e.g. \"0\" type but no fix)\n                    parser.skip(5); // Skip the 5 null placeholder groups for G13-G17\n                }\n                // The other branch of OR (WiFi G18) should be null. Skip its placeholder.\n                parser.skip(1);\n\n            } else {\n                // Path 2: G12 is not type, so it must be the WiFi data branch.\n                // This means G12 (type placeholder) and G13-G17 (GPS placeholders) are null.\n                // Parser index is at G11. Skip G12-G17 (6 groups) to get to G18 (WiFi).\n                parser.skip(6);\n                if (parser.hasNext()) { // Check for G18 (WiFi data)\n                    String wifiData = parser.next(); // Consume G18\n                    if (wifiData != null && !wifiData.isEmpty()) {\n                        String[] points = wifiData.split(\"\\\\|\");\n                        for (String point : points) {\n                            String[] wifi = point.split(\":\");\n                            if (wifi.length == 2) { // Ensure two parts: MAC and RSSI\n                                String mac = wifi[0].replaceAll(\"(..)\", \"$1:\");\n                                if (mac.endsWith(\":\")) { // Remove trailing colon if any\n                                    mac = mac.substring(0, mac.length() - 1);\n                                }\n                                network.addWifiAccessPoint(WifiAccessPoint.from(\n                                        mac, Integer.parseInt(wifi[1])));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // If neither GPS nor WiFi data path was taken (e.g. G12 and G18 both effectively null),\n        // position relies on cell tower data if available.\n\n        position.setNetwork(network);\n\n        DateFormat dateFormat = new SimpleDateFormat(\"yyMMddHHmmss\");\n        dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        String response = index + \",A03,\" + dateFormat.format(new Date());\n        sendResponse(channel, remoteAddress, imei, response);\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}