{
    "generation": "\tprotected JavaType _fromClass(ClassStack context, Class<?> cl, TypeBindings bindings)\n\t{\n\t\t// Sanity check: cannot handle array types with this method\n\t\tif (cl.isArray()) {\n\t\t\t// Neither can we do with this one.\n\t\t\t// ... note: we could actually deal with array-types, possibly\n\t\t\t// (depending on whether constructing array types recursively makes sense)\n\t\t\t// but for now this seems safest:\n\t\t\treturn ArrayType.construct(_fromAny(context, cl.getComponentType(), bindings), bindings);\n\t\t}\n\t\t// Also, no Enums\n\t\tif (cl.isEnum()) {\n\t\t\treturn EnumType.construct(cl, bindings);\n\t\t}\n\t\t// Map?\n\t\tif (Map.class.isAssignableFrom(cl)) {\n\t\t\t// Need to check if we need bindings for generic types\n\t\t\tif (cl == Properties.class) {\n\t\t\t\treturn MapType.construct(cl, bindings, CORE_TYPE_OBJECT, CORE_TYPE_STRING, CORE_TYPE_STRING);\n\t\t\t}\n\t\t\tJavaType[] mapParams = findTypeParameters(context, cl, Map.class, bindings);\n\t\t\t// ok, need 2 type parameters\n\t\t\tJavaType keyType, contentType;\n\t\t\tswitch (mapParams.length) {\n\t\t\tcase 0: // parameters not defined, use defaults\n\t\t\t\tkeyType = contentType = CORE_TYPE_OBJECT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkeyType = mapParams[0];\n\t\t\t\tcontentType = mapParams[1];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t    throw new IllegalArgumentException(\"Strange Map type \"+cl.getName()+\": can not determine type parameters\");\n\t\t\t}\n\t\t\treturn MapType.construct(cl, bindings, _fromClass(context, cl.getSuperclass(), bindings), keyType, contentType);\n\t\t}\n\t\t// Collection?\n\t\tif (Collection.class.isAssignableFrom(cl)) {\n\t\t\tJavaType[] collectionParams = findTypeParameters(context, cl, Collection.class, bindings);\n\t\t\tJavaType elementType;\n\t\t\tif (collectionParams.length == 0) { // raw type\n\t\t\t     elementType = CORE_TYPE_OBJECT;\n\t\t\t} else if (collectionParams.length == 1) {\n\t\t\t\telementType = collectionParams[0];\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"Strange Collection type \"+cl.getName()+\": can not determine type parameters\");\n\t\t\t}\n\t\t\treturn CollectionType.construct(cl, bindings, _fromClass(context, cl.getSuperclass(), bindings), elementType);\n\t\t}\n\n        // ReferenceType? (New for 2.6)\n\t\t// 18-Sep-2017, tatu: Should probably consider an annotation for selecting this...\n\t\tif (AtomicReference.class.isAssignableFrom(cl)) {\n\t\t    JavaType[] refParams = findTypeParameters(context, cl, AtomicReference.class, bindings);\n\t\t    JavaType referencedType;\n\t\t    if (refParams.length == 0) { // raw type\n\t\t        referencedType = CORE_TYPE_OBJECT;\n\t\t    } else {\n\t\t        referencedType = refParams[0];\n\t\t    }\n\t\t    return ReferenceType.construct(cl, bindings, CORE_TYPE_OBJECT, null, referencedType);\n\t\t}\n\n\t\t// Otherwise, check for recursion...\n\t\tfinal boolean recCheck = (context != null);\n\t\tfinal ClassStack prev = recCheck ? context : new ClassStack(cl);\n\n\t\t// 18-Nov-2016, tatu: As per [databind#1415], need to handle recursive definitions\n\t\tif (recCheck) {\n\t\t    ResolvedRecursiveType rrt = prev.findRecursiveType(cl);\n\t\t    if (rrt != null) {\n                // Yes, we have seen this type, use placeholder for now\n\t\t        // NOTE! We expect it be properly resolved AFTER type is constructed (if created).\n\t\t        return rrt;\n\t\t    }\n\t\t}\n\n\t\t// If not recursive, find from cache...\n\t\tJavaType resultType = _findCachedType(cl);\n\n\t\tif (resultType != null) {\n            // [databind#1647]: If we find cached simple type, it means we haven't resolved\n\t\t    // hierarchy for it yet; if so, should be done now -- this seems to occur\n\t\t    // only for recursive types.\n\t\t    //\n\t\t    // NOTE: problematic definition of \"recursive type\"; should perhaps try to find\n\t\t    // better logic? For now, `recCheck` seems to cover direct recursion cases,\n\t\t    // but not necessarily indirect ones.\n\t\t    // Also: only applies to `SimpleType`s? Looks like it?\n\t\t    if (recCheck && (resultType.getClass() == SimpleType.class)) {\n                 // 26-Jan-2018, tatu: Not 100% sure this is safe / optimal, but fixes the issue:\n                 //    ... must force re-calculation of type hierarchy?\n                 ((SimpleType) resultType).setHierarchy(new HierarchicType(cl));\n\t\t    }\n\t\t\treturn resultType;\n\t\t}\n\n\t\tResolvedRecursiveType recursiveType = null;\n\t\t// Nope: need to construct it. Any chance of recursion?\n\t\tif (recCheck) {\n\t\t    recursiveType = new ResolvedRecursiveType(cl, bindings);\n\t\t    prev.addSelfReference(recursiveType);\n            // and let's also cache it for now\n            _addPlaceholder(cl, recursiveType);\n\t\t} else {\n\t\t    // default for non-recursive case: context created, needs to be expanded\n\t\t    context = prev;\n\t\t}\n\n\t\t// Ok, need to resolve it.\n\t\t// 18-Nov-2016, tatu: As per [databind#1415], MUST calculate super-types first,\n\t\t//   except for Object.class\n\t\tHierarchicType selfRef;\n\n\t\tif (cl == Object.class) {\n\t\t    // Should not really get here, but just in case; needs no hierarchy\n\t\t    selfRef = null;\n\t\t} else {\n\t         // Otherwise, find super-class, interfaces:\n\t\t    selfRef = _constructSuperTypeHierarchy(context, cl, bindings);\n\t\t}\n\n\t\tSimpleType newType = _newSimpleType(cl, bindings, selfRef, null);\n\t\t// must be set prior to binding type variables\n\t\tif (selfRef != null) {\n\t\t    newType.setSuperClass(selfRef.getSuperType());\n\t\t    newType.setInterfaces(selfRef.getInterfaces());\n\t\t}\n\n\t\t// important: MUST cache the unresolved type first (see [databind#107])\n\t\t// -> although, note, this is never for Map/Collection/Array/Enum types\n\t\tif (!newType.hasHandlers()) { // never cache types with handlers\n\t\t    // 26-Jan-2018, tatu: Not 100% sure why non-placeholder caching needed here;\n\t\t    //    but perhaps helps performance. It is regrettable that we can not use the\n\t\t    //    placeholder as it may need to be resolved: if so, resolution requires that\n\t\t    //    this raw instance is available via cache. Does that make sense?\n\t\t    _addAndResolveNonTyped(cl, newType);\n\t\t}\n\n\t\t// Self-reference: needs to be resolved before further processing\n\t\tif (recursiveType != null) {\n\t\t    recursiveType.setReference(newType);\n\n\t        // Need to resolve type parameters as well\n\t        // 18-Nov-2016, tatu: Must resolve type parameters AFTER \u0441\u043a\u0435\u043b\u0435\u0442 type is available\n\t\t    _resolveSelfReferences(newType, selfRef.getBindings());\n\t\t} else {\n\t        // 18-Nov-2016, tatu: Not needed for recursive case, already done there\n\t        _resolveSelfReferences(newType, bindings);\n\t\t}\n\n\t\t// Finally: any type modifiers? (usually none)\n\t\tif (_modifiers != null) {\n\t\t    TypeBindings b = newType.getBindings(); // may have been augmented by _resolveSelfReferences\n\t\t    if (b == null) {\n\t\t        b = TypeBindings.emptyBindings();\n\t\t    }\n\t\t    for (TypeModifier mod : _modifiers) {\n\t\t        JavaType modified = mod.modifyType(newType, cl, b, this);\n\t\t        if (modified == null) { // sanity check\n\t\t            throw new IllegalStateException(String.format(\n\t\t                    \"TypeModifier %s returned null for type %s\", mod.getClass().getName(), newType));\n\t\t        }\n\t\t        newType = (SimpleType) modified;\n\t\t    }\n\t\t    // might need to re-cache, if modifier changed type or added handler\n\t\t    if (!newType.hasHandlers()) { // never cache types with handlers\n\t\t         _addAndResolveNonTyped(cl, newType);\n\t\t    }\n\t\t}\n\t\treturn newType;\n\t}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}