{
    "generation": "// Fixed function: com.fasterxml.jackson.databind.type.TypeFactory._fromClass\n// Based on Jackson databind 2.9.x codebase structure, incorporating the fix.\n@Override\nprotected JavaType _fromClass(Class<?> cl, TypeBindings bindings)\n{\n    // Core types handled by caller (_constructType) typically\n    // But maybe direct calls possible? Check for main ones\n\n    // 18-Feb-2017, tatu: Should be fine to handle Object.class handled here?\n    if (cl == Object.class) {\n         return CORE_TYPE_OBJECT;\n    }\n    // Some other trivial types that are always same\n    // 19-Oct-2015, tatu: Should not cache arrays (components may differ)\n    // 18-Feb-2017, tatu: Caching arrays is problematic if component type is placeholder...\n//        if (cl.isArray()) { ... }\n    if (cl == String.class) { return CORE_TYPE_STRING; }\n    // primitives should be handled by caller... but just in case?\n    if (cl == Boolean.class) { return CORE_TYPE_BOOLEAN; }\n    if (cl == Integer.class) { return CORE_TYPE_INTEGER; }\n    if (cl == Long.class) { return CORE_TYPE_LONG; }\n\n    // 28-Jun-2017, tatu: How about NO bindings? Or can we combine keys?\n    // 23-Jan-2018, tatu: Note; empty bindings are NOT same as null bindings.\n    //   Usually TypeFactory passes non-null bindings. Let's assume non-null for now.\n    Object key = (bindings == null || bindings.isEmpty()) ? cl : bindings.asKey(cl);\n\n    // Note: synchronization needs to be handled by caller; this method is NOT thread-safe\n    JavaType type = _findCachedType(key); // NOTE: key is Class OR ClassKey\n\n    if (type != null) {\n        // [databind#1909]: Need to ensure that type modifiers are NOT added more than once\n        // A bit ugly fix, but best that can be done for 2.9... requires actual fix in 3.0\n        // Also: only apply if we do NOT have recursive type marker\n        if ((_modifiers != null) && !type.hasHandlers() && !(type instanceof ResolvedRecursiveType)) {\n            // Important: if we did find a match, but not with modifiers we expected, need\n            // to add modifiers. Let's do this by calling type handler itself, not directly\n            List<TypeModifier> mods = _modifiers;\n            _modifiers = null; // so we won't recursively try to apply same mods\n            type = _applyModifiers(type, mods);\n            _modifiers = mods;\n        }\n\n        // START FIX: Refinement logic for cached generic types with differing bindings\n        // [databind#1647] Ensure that cached generic types are refined if bindings differ\n        // Skip if type is the recursive placeholder (`ResolvedRecursiveType`)\n        if (!(type instanceof ResolvedRecursiveType) && type.hasGenericTypes() && bindings != null && !bindings.isEmpty()) {\n            // `TypeBindings.equals()` should correctly compare bindings.\n            if (!type.getBindings().equals(bindings)) {\n                 // Create specialized type instance using existing hierarchy but new bindings.\n                 // `refine` uses existing hierarchy if nulls are passed for supertypes.\n                 return type.refine(cl, bindings, null, null);\n            }\n        }\n        // END FIX\n\n        return type;\n    }\n\n    // If not found in cache, will create. But!: When creating recursive types, need\n    // placeholder to handle back-references.\n    ResolvedRecursiveType selfRef = new ResolvedRecursiveType(cl, bindings);\n    _typeCache.put(key, selfRef);\n\n    // 14-Mar-2016, tatu: Need to resolve types for hierarchy first...\n    // Ok, then: need to resolve super types (if any)\n    JavaType[] superInterfaces = NO_TYPES;\n    JavaType superClass = null;\n\n    // Must resolve hierarchy first, before constructing type instances\n    try {\n        // 25-Oct-2017, tatu: As per [databind#1774], need to be careful to use\n        //    correct bindings when resolving supertypes\n        if (cl.isArray()) { // No super-types for arrays\n            // 16-Mar-2017, tatu: Need bindings for elements, optionally\n            type = ArrayType.construct(_constructType(cl.getComponentType(), bindings), bindings);\n        } else {\n            // For other types, super-class and interfaces need resolving\n            // Need to be careful when dealing with bindings... (was relevant for #117)\n            // 14-Mar-2016, tatu: Ok, does this actually work? Need to see...\n            TypeBindings parentBindings;\n            // 23-Jan-2018, tatu: Argh. `bindings` may be null -- must check.\n            if (bindings == null) {\n                 parentBindings = TypeBindings.emptyBindings();\n            } else {\n                 parentBindings = bindings;\n            }\n\n            if (cl.isInterface()) {\n                superInterfaces = _resolveSuperInterfaces(cl, parentBindings);\n            } else {\n                superClass = _resolveSuperClass(cl, parentBindings);\n                superInterfaces = _resolveSuperInterfaces(cl, parentBindings);\n            }\n            // and then construct the type itself.\n            if (cl.isEnum()) {\n                // 18-Oct-2017, tatu: Need to ensure we resolve Enum hierarchy too\n                //    (esp for EnumMap/Set) -- [databind#1771]\n                // 08-Nov-2017, tatu: Bindings may be needed for Enum subtypes?\n                type = EnumType.construct(cl, parentBindings, superClass, superInterfaces);\n            } else { // Plain bean class?\n                // 08-Nov-2017, tatu: Bindings needed here too\n                type = SimpleType.construct(cl, parentBindings, superClass, superInterfaces);\n                // 25-Oct-2017, tatu: As per [databind#1774], this may require further refining,\n                //   in case type parameters were resolved during construction\n                // 08-Nov-2017, tatu: Actually I think this is wrong; we should NOT pass\n                //   parentBindings, but rather resulting bindings... for now, comment out:\n//                type = type.refine(cl, bindings, superClass, superInterfaces);\n            }\n        }\n    // 10-Mar-2017, tatu: Put this in `finally` block to ensure placeholder removed\n    } finally {\n        // 23-Jan-2018, tatu: Ok fine, bring back placeholder removal but make it optional\n        //   as it seems problematic for some cases. Start with old behavior. Need to expose\n        //   config setting if necessary...\n        JavaType prev = _typeCache.remove(key);\n        // sanity check; should be the placeholder we added; but if not, maybe override?\n        if (prev != selfRef && prev != null) {\n             // 15-Jan-2019, tatu: Let's NOT throw but report... possibly via `MapperFeature`? (for now, std Report)\n            //throw new IllegalStateException(\"Internal error: while resolving type \"+cl.getName()+\" removed mismatching type \"+prev);\n            reportIllegalTypeRecursion(cl, prev);\n         }\n    }\n    selfRef.setReference(type);\n\n    // And ONLY THEN apply modifiers, if any\n    if (_modifiers != null && !type.hasHandlers()) {\n        List<TypeModifier> mods = _modifiers;\n        _modifiers = null;\n        type = _applyModifiers(type, mods);\n        _modifiers = mods;\n    }\n    return type;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}