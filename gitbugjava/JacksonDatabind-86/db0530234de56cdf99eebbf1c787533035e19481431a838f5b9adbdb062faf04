{
    "generation": "// Located in class com.fasterxml.jackson.databind.type.TypeFactory\n@Override\nprotected JavaType _fromClass(Class<?> cl, TypeBindings bindings)\n{\n    // Simplistic types handled directly\n    JavaType type = _findWellKnownSimple(cl);\n    if (type != null) {\n        return type;\n    }\n\n    // First: do we already know about it?\n    // 17-Mar-2017, tatu: As per [databind#1531], must ensure we will use passed bindings, not just raw class\n    final Object key = (bindings == null || bindings.isEmpty()) ? cl : bindings.asKey(cl);\n    type = _typeCache.get(key);\n    if (type != null) {\n        return type;\n    }\n\n    // 15-Jan-2016, tatu: Need to handle recursive references like [databind#1036]\n    // Yet another twist: we may be inquiring type for which there is resolution in progress.\n    // If so, must use ResolvedRecursiveType instance instead.\n    // 19-Jul-2017, tatu: ... and this turns out to be only case needed for detection of\n    //   infinite recursion; other approaches not needed. For example:\n    // if (_stack.contains(key)) { ... }\n    // See [databind#1700]\n    {\n        JavaType current = _findPendingType(key);\n        if (current != null) {\n            return current;\n        }\n    }\n\n    // Nope: start processing\n    // 19-Jul-2017, tatu: Let's use placeholder to mark type resolution in process\n    ResolvedRecursiveType selfRef = new ResolvedRecursiveType(cl, bindings);\n    _typeCache.put(key, selfRef);\n    _addPendingType(key, selfRef);\n\n    try {\n        // First, handle critical types that need to be handled specially:\n        // (note: minor optimization; let's not bother with interface checks etc)\n        if (cl.isArray()) {\n            type = ArrayType.construct(_fromAny(null, cl.getComponentType(), bindings), bindings);\n        } else {\n            // Then interfaces first\n            JavaType[] superInterfaces;\n            JavaType superClass;\n\n            // Map?\n            if (cl.isInterface()) {\n                superClass = null; // interfaces don't have superclass, only super-interfaces\n                superInterfaces = _constructSuperInterfaces(cl, cl.getGenericInterfaces(), bindings);\n            } else {\n                // Super-class; something is wrong if not Object.class?\n                superClass = _constructSuperClass(cl.getGenericSuperclass(), bindings);\n                superInterfaces = _constructSuperInterfaces(cl, cl.getGenericInterfaces(), bindings);\n            }\n\n            // Otherwise consider list of standard Jackson types...\n            if (cl == Properties.class) {\n                type = MapType.construct(cl, bindings, superClass, superInterfaces,\n                        CORE_TYPE_STRING, CORE_TYPE_STRING);\n            } else if (superClass != null) { // regular class? needs super types\n                 // 17-Mar-2017, tatu: As per [databind#1554], need to ensure Object.class handled ok\n                 if (superClass.getRawClass() == Object.class) {\n                    JavaType betterSuperClass = _resolveMemberClass(cl, bindings);\n                    if (betterSuperClass != null) {\n                         superClass = betterSuperClass;\n                    }\n                }\n                type = HierarchicType.construct(cl, bindings, superClass, superInterfaces);\n            } else { // interface\n                type = HierarchicType.construct(cl, bindings, null, /* nominally superClass, but interf have none */\n                        superInterfaces);\n            }\n            // 13-Mar-2018, tatu: This is where we may be able to refine the actual type,\n            //   after seeing contents. For example, Map/Collection types may have key/value/element\n            //   type information available.\n            JavaType refined = _refineType(cl, bindings, superClass, superInterfaces);\n            if (refined != null) {\n                type = refined;\n            }\n\n            // 16-Feb-2018, tatu: This is bit torturous, but seems like the place where we\n            //    may need to resolve type variable bindings possibly missed, using supertype\n            //    definitions... NOTE: MUST be done before refining reference type below\n            _resolveVariableViaSubTypes(type, cl.getName(), bindings, superClass, superInterfaces);\n\n            // And possibly we have self-reference type to handle?\n            if (type.isReferenceType()) {\n                JavaType t = type.getRefinedType(cl, bindings, superClass, superInterfaces);\n                if (t != null) type = t;\n            }\n        }\n        // Self-reference is special, need to link it...\n        selfRef.setReference(type);\n\n        // And apply type modifiers, if any (except on placeholders)\n        if (_modifiers != null) {\n            // Type could be cached already but that's ok; this is different resolution path\n            // Need to be careful here, stack overflow is possible for recursive types\n            JavaType modType = type; // just to avoid var hiding warning\n            for (TypeModifier mod : _modifiers) {\n                modType = mod.modifyType(modType, cl, bindings, this);\n                if (modType == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (%s) returned null for type %s\",\n                            mod, mod.getClass().getName(), type));\n                }\n            }\n            // 13-Mar-2018, tatu: As per [databind#1935], need to consider possibility of ending\n            //    up with placeholder type; if so, replace self-ref... maybe?\n            // For now let's assume linkage MUST be to non-placeholder type.\n            if (modType != type) {\n                // 13-Mar-2018, tatu: But wait! What if `modType` is same as `selfRef`?\n                //    For now, assume this is illegal\n                if (modType == selfRef) { // should never occur\n                    throw new IllegalStateException(\"TypeModifier \"+_modifiers.get(0).getClass().getName()\n                            +\" returned self-referential type \"+selfRef+\" for \"+cl);\n                }\n                selfRef.setReference(modType);\n                type = modType;\n            }\n        }\n    } finally {\n        // 19-Jul-2017, tatu: We are now done with resolving this type, must remove from pending\n        _removePendingType(key);\n    }\n    // We are done with resolving this type\n    // note: cache has had placeholder value ('selfRef') until this point; override\n    _typeCache.put(key, type);\n    return type;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}