{
    "generation": "  /**\n   * Tracks whether {@code resolveInternal} is currently being executed. Used\n   * to detect circular dependencies.\n   */\n  private boolean resolving = false;\n\n  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // Check for recursive resolution calls, which indicate a cycle.\n    if (resolving) {\n      // Cycle detected via recursion. Report the error and mark the type as\n      // resolved to break the cycle. handleTypeCycle should modify the type\n      // state appropriately (e.g., mark as resolved, possibly to an error type).\n      handleTypeCycle(t);\n      // Return the type reported by the registry, which might be an error type,\n      // or 'this' if it's not the last generation.\n      return registry.isLastGeneration() ? getReferencedType() : this;\n    }\n    resolving = true;\n\n    try {\n      // TODO(user): Investigate whether it is really necessary to keep two\n      // different mechanisms for resolving named types, and if so, which order\n      // makes more sense. Now, resolution via registry is first in order to\n      // avoid triggering the warnings built into the resolution via properties.\n      boolean resolved = resolveViaRegistry(t, enclosing);\n\n      // Even if resolved via registry, check for cycles detected afterward.\n      // detectImplicitPrototypeCycle might rely on partial resolution info\n      // set by resolveViaRegistry, or catch cycles not caught by the direct\n      // recursion check (though the 'resolving' flag should catch most).\n      if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n        // If a cycle is found, handleTypeCycle should mark it resolved.\n        // We allow the normal resolution finalization steps below to proceed.\n      }\n\n      if (resolved) {\n        // Resolution via registry succeeded. Finalize the resolution.\n        super.resolveInternal(t, enclosing); // Resolve the proxy object itself.\n        finishPropertyContinuations();\n        // Return the resolved type (or 'this' based on generation).\n        return registry.isLastGeneration() ?\n            getReferencedType() : this;\n      }\n\n      // Resolution via registry failed or didn't happen; try resolving via properties.\n      resolveViaProperties(t, enclosing);\n\n      // Check for cycles again after the second resolution attempt.\n      if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n      }\n\n      // Complete the resolution process. This runs whether properties resolved\n      // the type or a cycle was detected and handled.\n      super.resolveInternal(t, enclosing); // Resolve the proxy object itself.\n      if (isResolved()) {\n        // isResolved() should be true now if either resolution path\n        // succeeded or if a cycle was detected and handled (by handleTypeCycle).\n        finishPropertyContinuations();\n      }\n      // Return the final resolved type or 'this'.\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    } finally {\n      // Ensure the resolving flag is reset regardless of how the function exits.\n      resolving = false;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}