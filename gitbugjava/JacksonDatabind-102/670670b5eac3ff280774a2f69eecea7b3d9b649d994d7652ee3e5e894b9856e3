{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // Note: Handling of `property` being null is now integrated below,\n        // allowing type-based configuration overrides (like @JsonFormat on class,\n        // or global config overrides) to work correctly for root values or values\n        // within Collections/arrays.\n        // Previous version had an early `if (property == null) return this;` which\n        // prevented overrides for root values.\n\n        // First find format from property annotation, type annotation, config override, or default\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            // No overrides found, return the default serializer instance\n            return this;\n        }\n\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            // Explicit request for timestamp format\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // If explicit pattern provided, it overrides everything else\n        if (format.hasPattern()) {\n            // Determine Locale/TimeZone: from format if specified, otherwise from global config\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            // We must have a non-null Locale for SimpleDateFormat\n            final Locale locale = (loc == null) ? serializers.getLocale() : loc;\n\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), locale);\n\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                    : null; // IMPORTANT: must NOT use default TZ if it comes from format!\n            // If format did not specify timezone, use Provider's configuration\n            if (tz == null) {\n                 tz = serializers.getTimeZone();\n            }\n            df.setTimeZone(tz);\n            // Return new serializer instance configured for string output with custom format\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // No pattern, but other format settings? (Locale, TimeZone, Shape=String)\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        // Shape=STRING implies we must use String formatting, even if default pattern\n        final boolean asString = (shape == JsonFormat.Shape.STRING || shape == JsonFormat.Shape.ANY /* see [databind#2462] */);\n\n        // If no Locale/TimeZone override, no explicit String shape requested,\n        // and no pattern (already checked), then no changes needed based on format.\n        if (!hasLocale && !hasTZ && !asString) {\n             // This could happen if format only specifies things like lenient, features, etc.\n             // which are not handled here. Or if format is empty.\n             // Return the current instance.\n            return this;\n        }\n\n        // We need to apply Locale/TimeZone changes to the default formatter,\n        // or ensure String format is used (potentially with default formatter).\n\n        // Get the globally configured DateFormat (base for modifications)\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n        // Is the globally configured DateFormat suitable for modification?\n        // Jackson's own `StdDateFormat` is preferred as it's immutable & easy to configure\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n            \n            Locale    loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n            if (loc != null && !loc.equals(std.getLocale())) {\n                 std = std.withLocale(loc);\n            }\n\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : null;\n            // If format did not specify timezone, use Provider's configuration\n            if (tz == null) {\n                 tz = serializers.getTimeZone();\n            }\n            if (tz != null && !tz.equals(std.getTimeZone())) {\n                std = std.withTimeZone(tz);\n            }\n            // Return new serializer configured for String output (Boolean.FALSE) using potentially modified StdDateFormat\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // If global DateFormat is not StdDateFormat, require SimpleDateFormat for modifications\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n        if (!(df0 instanceof SimpleDateFormat)) {\n            // Cannot configure Locale/TimeZone for unknown DateFormat types.\n            // Report error only if Locale/TimeZone configuration was explicitly requested.\n            if (hasLocale || hasTZ) {\n                serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ndf0.getClass().getName()));\n            }\n            // If we only got here due to `asString=true` (Shape=String), can we still proceed?\n            // If the df0 is not null and produces a String, maybe we can use it.\n            // The implication is that we should use the configured `df0` as-is, but force String output.\n            // This requires returning a new instance via `withFormat`, potentially cloning `df0` for safety.\n            if (asString) {\n                // We are requested to use String format. df0 is the configured format.\n                // We assume df0 produces a String. Create new serializer using it, forcing String mode.\n                DateFormat newDf = (DateFormat) df0.clone();\n                return withFormat(Boolean.FALSE, newDf);\n            }\n            // Otherwise (no modifications requested, not forcing String), return `this`.\n            return this;\n        }\n\n        // Global DateFormat is SimpleDateFormat, we can try to modify it.\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n        \n        // Handle Locale change: must create new instance\n        Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        if (loc != null && !loc.equals(df.getDateFormatSymbols().getLocale())) {\n            // Must re-create entirely, preserving original pattern but applying new Locale\n            df = new SimpleDateFormat(df.toPattern(), loc);\n            // Timezone from original df is lost, must re-apply below using original logic.\n        } else {\n            // No locale change needed, just clone to safely modify TimeZone\n            df = (SimpleDateFormat) df.clone();\n        }\n\n        // Determine and apply TimeZone\n        TimeZone newTz = format.hasTimeZone() ? format.getTimeZone() : null;\n        // If format did not specify timezone, use Provider's configuration\n        if (newTz == null) {\n            newTz = serializers.getTimeZone();\n        }\n\n        // Apply the determined TimeZone if it's different from the current one in 'df'\n        if (newTz != null && !newTz.equals(df.getTimeZone())) {\n            df.setTimeZone(newTz);\n        }\n\n        // Return new serializer configured for String output (Boolean.FALSE) with the modified SimpleDateFormat\n        return withFormat(Boolean.FALSE, df);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}