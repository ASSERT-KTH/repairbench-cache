{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table. Also handles JSDoc declarations\n     * attached to assignments and expressions.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Attach types to literals, 'this', etc. This is necessary for type checking\n      // and should happen regardless of the specific declaration type below.\n      attachLiteralTypes(n);\n\n      // Don't process the scope root itself.\n      if (n == scope.getRootNode()) {\n        return;\n      }\n\n      // Handle function parameters when visiting the LP (parameter list) node\n      // of a function definition.\n      if (n.isParamList() && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        // Parameters are handled, no further processing needed for LP node itself.\n        return;\n      }\n\n      // Handle declarations and JSDoc-annotated expressions.\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // Function declaration statements (like 'function foo() {}') have parent NAME.\n          // These are typically handled by hoisting logic (e.g., processing the VAR node\n          // created for the function name) calling declareNamespace.\n          // We only need to explicitly handle function expressions here.\n          if (parent.getType() != Token.NAME) {\n            // Defines the function symbol for expressions, handles its inner scope.\n            defineDeclaredFunction(n, parent);\n          }\n          break;\n\n        case Token.CATCH:\n          // Define the variable introduced in a catch clause, e.g., catch (e) { ... }\n          defineCatch(n, parent);\n          break;\n\n        case Token.VAR:\n          // Define variables declared with 'var', 'let', 'const'.\n          // This calls declareNamespace internally, handling JSDoc on the VAR.\n          defineVar(n, parent);\n          break;\n\n        // Handle JSDoc-based declarations on qualified names via assignments.\n        case Token.ASSIGN:\n          // Look for assignments used as statements, like /** @type {T} */ ns.prop = value;\n          // These often carry JSDoc type information.\n          if (parent.isExprResult()) {\n            Node lhs = n.getFirstChild();\n            // Check if the left-hand side is a qualified name (NAME or GETPROP).\n            if (lhs.isQualifiedName()) {\n              // Delegate to declareNamespace, which checks for JSDoc on the ASSIGN node (n)\n              // and defines the symbol accordingly.\n              // Arguments: traversal, block (parent=EXPR_RESULT), name node (lhs), parent of name (n=ASSIGN)\n              declareNamespace(t, parent, lhs, n);\n            }\n          }\n          break;\n\n        // Handle JSDoc-based stub declarations on qualified names.\n        case Token.GETPROP:\n          // Look for qualified names used as statements, like /** @type {T} */ ns.prop;\n          // These are stub declarations providing type information via JSDoc.\n          if (parent.isExprResult()) {\n            // Delegate to declareNamespace, which checks for JSDoc on the GETPROP node (n)\n            // or its parent (parent=EXPR_RESULT) and defines the symbol.\n            // Arguments: traversal, block (parent=EXPR_RESULT), name node (n=GETPROP), parent of name (parent=EXPR_RESULT)\n            declareNamespace(t, parent, n, parent);\n          }\n          break;\n\n        // Note: A similar case for Token.NAME under EXPR_RESULT (e.g., /** @type {T} */ myVar;)\n        // could be added but is less common for explicit declarations and often handled\n        // implicitly through VAR or ASSIGN processing.\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}