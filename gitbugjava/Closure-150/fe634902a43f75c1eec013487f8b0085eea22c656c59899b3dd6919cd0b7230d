{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      // Handle function inputs before traversing the function body.\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      // Try attaching type info to literal values.\n      attachLiteralTypes(n);\n\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // Function declarations are handled via checkDeclaredFunctions.\n          // We only need to handle function assignments here, by treating\n          // the function node as a constant value.\n          // We special-case this because we don't want to declare a symbol\n          // for the function name node.\n          if (NodeUtil.isFunctionExpression(n)) {\n            // Assigned function expressions are handled implicitly by VAR/ASSIGN\n            // or object literal handling. Don't declare here. Example: var x = function() {};\n            // Need to handle name of named function expressions: var x = function foo() {}; 'foo' scope\n            if (n.getFirstChild().hasChildren() && parent.getType() != Token.NAME) {\n              // It's a named function expression. Define the name locally\n              // to the function body.\n              defineDeclaredFunction(n, parent);\n            }\n          } else {\n            // Function declaration: function f() {}\n            // Handled by checkDeclaredFunctions or need to be defined here?\n            // Based on original logic, only define if parent is not NAME.\n            if (parent.getType() != Token.NAME) {\n               defineDeclaredFunction(n, parent);\n            }\n          }\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n\n        // Added case to handle JSDoc declarations on expression statements.\n        case Token.EXPR_RESULT:\n          // Check for JSDoc on the EXPR_RESULT node itself.\n          // This handles patterns like:\n          // /** @type {string} */ MyClass.prototype.prop;\n          // /** @param {number} x */ Namespace.method;\n          // /** @return {void} */ this.init = function() {}; // Assignment case\n          JSDocInfo jsDoc = n.getJSDocInfo();\n          if (jsDoc != null) {\n            Node child = n.getFirstChild();\n            if (child != null) {\n              if (child.isAssign()) {\n                // Case: /** @type ... */ a.b = ...;\n                // The JSDoc applies to the entire assignment expression result.\n                // Delegate to maybeDeclareQualifiedName, providing the JSDoc node (n),\n                // the L-Value (assignment target), and the R-Value (assigned value).\n                maybeDeclareQualifiedName(t, n, child.getFirstChild(), child.getLastChild());\n              } else if (child.isGetProp() || child.isQualifiedName()) { // Check for GETPROP and NAME (e.g., /** @type {number} */ var x;) - Though NAME usually handled by VAR\n                // Case: /** @type ... */ a.b;\n                // Only declare qualified names (GETPROP) here. Simple names are handled by VAR/params.\n                if (child.isGetProp()) {\n                   maybeDeclareQualifiedName(t, n, child, null); // No R-Value for stub declarations\n                }\n              }\n            }\n          }\n          break; // End of EXPR_RESULT case\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}