{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      // Handle function inputs (parameters) specially. They are declared\n      // in the function's scope, but appear in the AST before the scope\n      // root node (the FUNCTION node).\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      // Attach types to literals and handle special cases.\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // Function declarations are handled when visiting the NAME node.\n          // Function expressions are handled here.\n          if (NodeUtil.isFunctionDeclaration(n)) {\n             // Function declarations are handled by the NAME node.\n             return;\n          }\n          // Defines the function symbol and potentially its 'this' type.\n          defineDeclaredFunction(n, parent);\n          break;\n        case Token.CATCH:\n          // Define the catch variable in the catch block scope.\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          // Define variables declared with 'var'.\n          defineVar(n, parent);\n          break;\n        case Token.EXPR_RESULT:\n          // Handle qualified name declarations via expression statements\n          // with JSDoc annotations, like:\n          // /** @type {SomeType} */ ns.subns.MyClass;\n          // /** @param {string} s */ ns.func;\n          // /** @return {number} */ this.method;\n          Node expr = n.getFirstChild();\n          JSDocInfo info = expr.getJSDocInfo();\n          if (info != null) {\n            // maybeDeclareQualifiedName checks if the expression is a qualified name\n            // (NAME or GETPROP) and if the JSDoc indicates a declaration\n            // (e.g., @type, @enum, @const, @interface, @constructor, @param, @return).\n            // If so, it declares the name/property in the current scope.\n            // Parameters: traversal, JSDoc, qualified name node, parent, grandparent\n            maybeDeclareQualifiedName(t, info, expr, n, parent);\n          }\n          break;\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}