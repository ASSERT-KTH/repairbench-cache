{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) { // No context? Use defaults\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) { // No overrides? Use defaults\n            return this;\n        }\n\n        // 1. Shape override?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            // If explicit numeric timestamp, easy\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 2. Pattern override? If so, create SimpleDateFormat based on pattern\n        //    Need to ensure we have timezone, potentially locale as well\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale() : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n            TimeZone tz = format.hasTimeZone()\n                            ? format.getTimeZone() : serializers.getTimeZone();\n            // 12-Jun-2020, tatu: As per [databind#2743], need null check:\n            if (tz == null) {\n                tz = serializers.getTimeZone();\n            }\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // 3. Locale/timezone override? Need to modify non-pattern settings\n        boolean hasLocale = format.hasLocale();\n        boolean hasTZ = format.hasTimeZone();\n        // Shape could be STRING or ANY/default\n        boolean specificShape = (shape == JsonFormat.Shape.STRING);\n\n        // If any of these are specified, need to figure out DateFormat to use\n        if (hasLocale || hasTZ || specificShape) {\n            // Get base format; may be null if default timestamp format is used\n            DateFormat df = serializers.getConfig().getDateFormat();\n\n            // If default is Jackson's own StdDateFormat, easy to work with\n            if (df instanceof StdDateFormat) {\n                StdDateFormat std = (StdDateFormat) df;\n                TimeZone tz = format.getTimeZone();\n                if (format.hasTimeZone()) {\n                    std = std.withTimeZone(tz);\n                }\n                if (hasLocale) {\n                    std = std.withLocale(format.getLocale());\n                }\n                return withFormat(Boolean.FALSE, std);\n            }\n\n            // If not, must be SimpleDateFormat (or error)\n            if (!(df instanceof SimpleDateFormat)) {\n                // 13-Jan-2018, tatu: Let's add reference to the property, to help locate source\n                String msg = String.format(\"Cannot override DateFormat with concrete type %s: must be instance of %s\",\n                        df.getClass().getName(), SimpleDateFormat.class.getName());\n                if (property != null) {\n                    msg = String.format(\"%s (for property '%s')\", msg, property.getName());\n                }\n                serializers.reportBadDefinition(handledType(), msg);\n            }\n\n            // SimpleDateFormat is mutable, so must make a copy\n            SimpleDateFormat sdf = (SimpleDateFormat) df.clone();\n            TimeZone tz = format.getTimeZone();\n            if (hasTZ) {\n                // At this point, `tz` is not null if `hasTZ` is true\n                sdf.setTimeZone(tz);\n            }\n            if (hasLocale) {\n                // Locale is trickier: must create new instance\n                sdf = new SimpleDateFormat(sdf.toPattern(), format.getLocale());\n                // And reapply timezone, original or overridden one\n                sdf.setTimeZone(hasTZ ? tz : ((SimpleDateFormat)df).getTimeZone());\n            }\n            return withFormat(Boolean.FALSE, sdf);\n        }\n\n        // 4. If shape is STRING, but no other overrides, might need to switch\n        // from default timestamp to default string format\n        // 17-Mar-2017, tatu: Minor twist, shape=STRING means \"use String\", overrides default\n        //    (which might be timestamp)\n        if (shape == JsonFormat.Shape.STRING) {\n            // Check if the default would be timestamp\n            Boolean useTimestamp = _useTimestamp;\n            if (useTimestamp == null) {\n                useTimestamp = serializers.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n            }\n            // If default was timestamp, need to ensure format is available.\n            if (Boolean.TRUE.equals(useTimestamp)) {\n                DateFormat df = serializers.getConfig().getDateFormat();\n                // If default format is explicitly disabled (or missing) need to use default standard format\n                if (df == null) {\n                    // Borrowed from `DateSerializer.serialize()`:\n                    StdDateFormat defaultFormat = (StdDateFormat) StdDateFormat.getISO8601Format(\n                            serializers.getTimeZone(), serializers.getLocale());\n                    // Use a clone for thread-safety? StdDateFormat claims usually thread-safe. Cloning is safer.\n                    df = (DateFormat) defaultFormat.clone();\n                }\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n\n        // Otherwise no changes needed, return original\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}