{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            // 16-Oct-2018, tatu: For [databind#2146], better ensure no format String is used\n            return withFormat(Boolean.TRUE, null); // ensure no format is passed\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // Does annotation specify formatting details? If so, need to construct new instance\n        if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                || format.hasLocale() || format.hasTimeZone()) {\n\n            // Determine locale: annotation > default\n            final Locale loc = format.hasLocale()\n                    ? format.getLocale()\n                    : serializers.getLocale();\n\n            // Determine pattern: Annotation > Default Mapper Format Pattern > ISO8601\n            String pattern;\n            if (format.hasPattern()) {\n                pattern = format.getPattern();\n            } else {\n                // No pattern in annotation: check for default formatter\n                DateFormat defaultFormatter = serializers.getConfig().getDateFormat();\n                // [databind#1648]: If default is SimpleDateFormat, use its pattern\n                if (defaultFormatter instanceof SimpleDateFormat) {\n                    pattern = ((SimpleDateFormat) defaultFormatter).toPattern();\n                } else {\n                    // otherwise, default to ISO8601\n                    // 16-Oct-2018, tatu: Should possibly allow configuration of default format String?\n                    pattern = StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                }\n            }\n\n            // Construct SimpleDateFormat using determined pattern and locale\n            // TODO: [databind#1744] Need to ensure `SimpleDateFormat` construction is correct\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n\n            // Determine timezone: Annotation > Default Mapper Timezone\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : null;\n            if (tz == null) {\n                tz = serializers.getTimeZone();\n            }\n            // Important: [databind#1744] MUST set timezone AFTER constructing, affects formatting\n            df.setTimeZone(tz);\n\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, default formatting, but possible timezone override?\n\n        // 16-Oct-2018, tatu: [databind#2146] If shape is `DEFAULT_FORMAT`, and no pattern/timezone/locale,\n        //    should simply use `_defaultFormat`, assuming it has been configured.\n        // 05-Dec-2018, tatu: Wait. Above assumption isn't quite correct. Need to check if\n        //    timezone was specified or not...\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : null;\n        // If TimeZone is specified, need to create a clone:\n        if (tz != null) {\n            // One special case: the default `DateFormat` is `StdDateFormat`\n            DateFormat df = serializers.getConfig().getDateFormat();\n            // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n            //    mechanism for changing `DateFormat` instances (or even clone()ing)\n            //    So: require it be `SimpleDateFormat`; can't config other types\n            // 05-Dec-2018, tatu: ... OR, StdDateFormat! Let's add support for that too.\n            DateFormat newDf;\n            if (df.getClass() == SimpleDateFormat.class) {\n                 newDf = (SimpleDateFormat) df.clone();\n                 newDf.setTimeZone(tz);\n            } else if (df instanceof StdDateFormat) {\n                 // important: make sure we create derived instance with potentially new timezone\n                 newDf = ((StdDateFormat) df).withTimeZone(tz);\n            } else {\n                // 05-Dec-2018, tatu: otherwise we don't know how to change timezone, must report\n                serializers.reportBadDefinition(handledType(), String.format(\n                        \"Cannot modify existing Formatter of type %s to use alternative TimeZone '%s': must be `SimpleDateFormat` or `StdDateFormat`\",\n                        df.getClass().getName(), tz.getID()));\n                // but let's fall back to using default formatter without TZ override, if possible?\n                // (actually, probably shouldn't: fail loud)\n                newDf = null; // to trigger error below? Or should we return `this`?\n\n                // 17-Oct-2018, tatu: Let's actually return `this` for now; needed for 2.10 release\n                return this;\n            }\n            return withFormat(Boolean.FALSE, newDf);\n        }\n        \n        // Otherwise, keep existing settings (might be default, might be something else)\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}