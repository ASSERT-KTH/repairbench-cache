{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // If shape is explicitly set to String, or pattern/locale/timezone is set,\n        // we need to potentially configure a new format.\n        Boolean asTimestamp = null; // default (null means use default)\n        DateFormat df = null;\n\n        if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                || format.hasLocale() || format.hasTimeZone()) {\n\n            asTimestamp = Boolean.FALSE; // must be textual serialization if any of these are specified\n\n            // Get explicitly configured timezone, or default if not specified\n            TimeZone tz = format.getTimeZone();\n            if (tz == null) {\n                tz = serializers.getTimeZone();\n            }\n\n            // Get explicitly configured locale, or default if not specified\n            final Locale loc = format.hasLocale()\n                    ? format.getLocale()\n                    : serializers.getLocale();\n\n            // Pattern handling:\n            // 1. Explicit pattern in annotation\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                // If pattern is same as StdDateFormat's default, use it directly\n                if (pattern.equals(StdDateFormat.DATE_FORMAT_STR_ISO8601)) {\n                    //TimeZone might be different, Locale may be different... so can't just use StdDateFormat.instance\n                     StdDateFormat std = StdDateFormat.instance\n                           .withTimeZone(tz)\n                           .withLocale(loc);\n                    df = std;\n                } else {\n                    df = new SimpleDateFormat(pattern, loc);\n                    df.setTimeZone(tz);\n                }\n            } else {\n                // 2. No pattern in annotation: use settings from base format if available\n                DateFormat baseFormat = serializers.getConfig().getDateFormat();\n                // If no base format configured, use StdDateFormat default.\n                if (baseFormat == null) {\n                    // Clone the default StdDateFormat instance and configure it\n                    StdDateFormat std = (StdDateFormat) StdDateFormat.instance.clone();\n                    // Configure with potentially overridden locale/tz\n                    if (!loc.equals(std.getLocale())) {\n                        std = std.withLocale(loc);\n                    }\n                    if (!tz.equals(std.getTimeZone())) {\n                        std = std.withTimeZone(tz);\n                    }\n                    df = std;\n                }\n                // If base format is SimpleDateFormat, we can extract pattern and apply overrides\n                else if (baseFormat instanceof SimpleDateFormat) {\n                    SimpleDateFormat baseSdf = (SimpleDateFormat) baseFormat;\n                    final String pattern = baseSdf.toPattern();\n                    // Create new instance with potentially different locale/tz\n                    df = new SimpleDateFormat(pattern, loc);\n                    df.setTimeZone(tz);\n                }\n                // If base format is not SimpleDateFormat, try cloning and setting TimeZone. Locale is hard.\n                else {\n                    // Report issue for Locale override attempt if locale actually changed?\n                    // (Original code didn't error out, let's try to proceed)\n                    /*\n                    if (format.hasLocale() && !loc.equals(serializers.getLocale())) {\n                         serializers.reportBadDefinition(handledType(), String.format(\n                                 \"Cannot apply locale override (%s) for non-SimpleDateFormat DateFormat (%s)\",\n                                 loc, baseFormat.getClass().getName()));\n                    }\n                    */\n                    // Try cloning\n                    try {\n                         df = (DateFormat) baseFormat.clone();\n                         // Set timezone if it differs from base or was specified in annotation\n                         if (!tz.equals(df.getTimeZone())) {\n                            df.setTimeZone(tz);\n                         }\n                         // Cannot reliably set Locale after construction for most DateFormats\n                    } catch (Exception e) {\n                         // Cloning failed, report and potentially fallback\n                          serializers.reportBadDefinition(handledType(), String.format(\n                             \"Cannot clone non-SimpleDateFormat DateFormat %s to apply TimeZone override (%s): %s\",\n                                 baseFormat.getClass().getName(), tz, e.getMessage()), e);\n                         return this; // Cannot apply format changes reliably\n                    }\n                }\n            }\n        } else if (shape == JsonFormat.Shape.ANY) {\n            // Shape ANY means \"use default\", which is what we have, so:\n            return this;\n        } else {\n             // Other shapes (ARRAY etc) not supported: revert to default\n             serializers.reportBadDefinition(handledType(),\n                     String.format(\"Unsupported serialization shape (%s) for %s, defaulting to standard\",\n                             shape, handledType().getName()));\n             return this;\n        }\n\n        // Compare final settings to current ones, maybe return `this` if no change\n        // NOTE: as per [databind#2129], should NOT check `asTimestamp` if `df` is passed\n        if ((_useTimestamp != null) && asTimestamp != null && _useTimestamp.booleanValue() == asTimestamp.booleanValue()) {\n             // If timestamps settings are same, and DateFormat object remains same, nothing to do\n             // Note: timezone part of DateFormat, cannot check distinctly\n             // Also: possible that null _customFormat should be compared to non-null df?\n             if (df == _customFormat) { // Identity check works if `withFormat` preserves identity\n                  return this;\n             }\n             // Or, perhaps, check equality? But DateFormat.equals() is not universally reliable.\n             // Let's rely on `withFormat` to do the right thing.\n        }\n        // If we get this far, settings have changed, create new serializer\n        return withFormat(asTimestamp, df);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}