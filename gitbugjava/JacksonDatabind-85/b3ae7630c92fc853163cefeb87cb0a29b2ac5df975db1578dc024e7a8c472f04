{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            // If no overrides, and currently configured for timestamp, should revert to default format\n            // (see [databind#2407])\n            if ((_useTimestamp != null) && _useTimestamp.booleanValue()) {\n                 // Let's assume null format means \"use standard\"\n                 return withFormat(Boolean.FALSE, null);\n            }\n            return this;\n        }\n\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            // If specifying that shape, and not already configured similarly, create new\n            // NOTE: `_useTimestamp` is `Boolean`, not `boolean`, can be null\n            Boolean useTimestamp = Boolean.TRUE;\n            // Use Objects.equals() for null-safe comparison\n            if (java.util.Objects.equals(_useTimestamp, useTimestamp)) {\n                return this;\n            }\n            return withFormat(useTimestamp, null);\n        }\n\n        // Otherwise, need to figure out format String:\n        // If shape explicitly defined as STRING, definitely not timestamp.\n        // Otherwise depends on defaults... Assume null means \"default\" for timestamp\n        final Boolean useTimestamp = (shape == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;\n        final TimeZone tz = format.getTimeZone();\n        final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n        final String pattern = format.hasPattern() ? format.getPattern() : null;\n        DateFormat df = null; // The new DateFormat to use, if different from current\n\n        // Case 1: Annotation specified pattern: create new SimpleDateFormat\n        if (pattern != null && pattern.length() > 0) {\n            df = new SimpleDateFormat(pattern, loc);\n            // Timezone override? If annotation did not specify, use SerializerProvider's default.\n            TimeZone actualTz = (tz == null) ? serializers.getTimeZone() : tz;\n            df.setTimeZone(actualTz);\n        }\n        // Case 2: No pattern, but Locale or TimeZone specified in annotation\n        else if (format.hasLocale() || tz != null) {\n            // Need to base modifications on the existing format (`_customFormat` or global default)\n            DateFormat baseFormat = _customFormat;\n            if (baseFormat == null) {\n                baseFormat = serializers.getConfig().getDateFormat();\n            }\n\n            // Special handling for StdDateFormat (which is immutable wrt configuration)\n            if (baseFormat instanceof StdDateFormat) {\n                StdDateFormat std = (StdDateFormat) baseFormat;\n                // Apply overrides if specified in annotation\n                if (tz != null) {\n                    std = std.withTimeZone(tz);\n                }\n                // Use format.hasLocale() to check if annotation explicitly set locale\n                if (format.hasLocale()) {\n                    std = std.withLocale(loc);\n                }\n                df = std;\n            }\n            // Otherwise, assume SimpleDateFormat or similar cloneable/modifiable\n            else {\n                // We must have a SimpleDateFormat, or we cannot proceed\n                if (!(baseFormat instanceof SimpleDateFormat)) {\n                    // Cannot reliably modify locale/timezone for unknown DateFormat types\n                    serializers.reportBadDefinition(handledType(), String.format(\n                            \"Cannot modify existing format (%s) configured via `ObjectMapper.setDateFormat()`: not a SimpleDateFormat instance\",\n                            baseFormat.getClass().getName()));\n                    return this; // Return unmodified serializer as a fallback\n                }\n\n                // Clone the base SimpleDateFormat to allow modification\n                SimpleDateFormat sdf = (SimpleDateFormat) baseFormat.clone();\n\n                // Apply TimeZone override. Use annotation's TZ if present, otherwise SerializerProvider's default.\n                // This aligns with behavior when pattern IS specified.\n                TimeZone actualTz = (tz != null) ? tz : serializers.getTimeZone();\n                sdf.setTimeZone(actualTz);\n\n                // Apply Locale override (requires recreation for SimpleDateFormat)\n                if (format.hasLocale()) {\n                    // Recreate SimpleDateFormat with the original pattern but new Locale\n                    sdf = new SimpleDateFormat(sdf.toPattern(), loc);\n                    // Reapply the effective timezone as recreation might reset it\n                    sdf.setTimeZone(actualTz);\n                }\n                df = sdf;\n            }\n        }\n        // Case 3: Shape is explicitly STRING, but no pattern/locale/timezone overrides in annotation\n        else if (shape == JsonFormat.Shape.STRING) {\n             // Use the default string format. If already configured for string format, no change needed.\n             if (_useTimestamp == null || !_useTimestamp.booleanValue()) { // Already using string format?\n                 // If _customFormat is null, using global default string format -> OK\n                 // If _customFormat is non-null, using that specific string format -> OK\n                return this;\n            }\n            // Need to switch from timestamp to the default string format.\n            // `withFormat(Boolean.FALSE, null)` should handle reverting to the default.\n            return withFormat(Boolean.FALSE, null);\n        } else {\n             // No overrides relevant to string formatting, and shape wasn't explicitly STRING. Return self.\n             return this;\n        }\n\n        // Check if the resulting configuration (useTimestamp, df) is the same as the current one\n        // Use Objects.equals for null-safe comparison\n        if (java.util.Objects.equals(useTimestamp, _useTimestamp) && java.util.Objects.equals(df, _customFormat)) {\n             return this; // No change needed\n        }\n        // If configuration changed, return a new serializer instance with the modifications\n        return withFormat(useTimestamp, df);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}