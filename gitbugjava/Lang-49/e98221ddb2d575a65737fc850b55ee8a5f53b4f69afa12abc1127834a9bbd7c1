{
    "generation": "    /**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce() {\n        // Handle zero numerator\n        if (numerator == 0) {\n            // Ensure we return the canonical ZERO instance unless this fraction is already ZERO.\n            return equals(ZERO) ? this : ZERO;\n        }\n\n        int n = numerator;\n        int d = denominator;\n        boolean signNormalized = false;\n\n        // Normalize sign so denominator is positive.\n        // The standard representation of a fraction has a positive denominator.\n        if (d < 0) {\n            // Check for potential overflow before negating.\n            if (n == Integer.MIN_VALUE || d == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: can't negate\");\n            }\n            n = -n;\n            d = -d;\n            // Keep track if normalization happened, as we'll need a new Fraction instance.\n            signNormalized = true; \n        }\n\n        // Calculate gcd using positive values (d is guaranteed positive here).\n        // Use Math.abs(n) in case the numerator was Integer.MIN_VALUE and couldn't be negated before.\n        // (Although the check above handles the case where d was negative,\n        // n could still be MIN_VALUE if d was positive originally).\n        int gcd = greatestCommonDivisor(Math.abs(n), d);\n\n        // Check if already reduced (after potential sign normalization).\n        if (gcd == 1) {\n            // If we normalized the sign, we must return a new instance\n            // with the normalized values. Otherwise, the fraction was already\n            // in reduced, normalized form, so return the original instance 'this'.\n            return signNormalized ? Fraction.getFraction(n, d) : this;\n        }\n\n        // Create reduced fraction using the (potentially sign-normalized) numerator and denominator.\n        return Fraction.getFraction(n / gcd, d / gcd);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}