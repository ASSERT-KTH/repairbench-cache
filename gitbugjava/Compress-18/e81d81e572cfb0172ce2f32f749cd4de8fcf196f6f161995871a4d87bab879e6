{
    "generation": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.utils.CharsetNames;\n\n// Wrapper class to provide context for the method\nclass TarArchiveOutputStreamHelper {\n    // Dummy fields and methods to allow the function to compile\n    private TarArchiveOutputStream outputStream; // Assume this exists and is used by putArchiveEntry, write, closeArchiveEntry\n    private TarBuffer buffer; // Assume this exists if needed by other methods called internally\n    private String encoding = CharsetNames.UTF_8; // Assume default encoding\n    private long currBytes = 0;\n    private long currSize = 0;\n    private TarArchiveEntry currEntry = null;\n    private boolean finished = false;\n\n    // Dummy implementations of methods called by writePaxHeaders\n    void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        // Simulate setting current entry and size, considering the directory bug\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        this.currEntry = entry;\n        if (entry.isDirectory()) { // This was the problematic part\n            this.currSize = 0;\n        } else {\n             this.currSize = entry.getSize();\n        }\n        this.currBytes = 0;\n        // Simulate writing header (not strictly needed for fixing the logic)\n        System.out.println(\"Simulating putArchiveEntry for: \" + entry.getName() + \" with size in header: \" + entry.getSize() + \", setting currSize to: \" + this.currSize);\n    }\n\n    void write(byte[] b) throws IOException {\n        write(b, 0, b.length);\n    }\n\n    void write(byte[] b, int off, int len) throws IOException {\n         // Simulate write check\n        System.out.println(\"Simulating write: trying to write \" + len + \" bytes. Current pos: \" + this.currBytes + \", Expected size: \" + this.currSize);\n        if (this.currBytes + len > this.currSize) {\n            throw new IOException(\"request to write '\" + len\n                                  + \"' bytes exceeds size in header of '\"\n                                  + this.currSize + \"' bytes for entry '\"\n                                  + this.currEntry.getName() + \"'\");\n        }\n        this.currBytes += len;\n        System.out.println(\"Simulating write: success. New pos: \" + this.currBytes);\n    }\n\n    void closeArchiveEntry() throws IOException {\n        // Simulate closing entry\n        System.out.println(\"Simulating closeArchiveEntry for: \" + (currEntry != null ? currEntry.getName() : \"null\"));\n        if (currEntry != null && !currEntry.isDirectory() && currBytes < currSize) {\n             System.err.println(\"Warning: Entry closed before expected size was reached.\");\n        }\n        this.currEntry = null;\n        this.currBytes = 0;\n        this.currSize = 0;\n    }\n\n    // Helper method needed by the function (dummy implementation)\n    private String stripTo7Bits(String name) {\n        // Simple replacement for the sake of the example\n        return name.replace(\"\\u00f6\", \"v\");\n    }\n\n\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        // Truncate if name is too long\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        // Remove trailing slash if present, as PAX headers are not directories\n        // and TarArchiveEntry#isDirectory checks for trailing slashes.\n        // If the original entry was a directory, the PAX header name generated\n        // might end with a slash, incorrectly flagging it as a directory\n        // which leads to putArchiveEntry setting the expected size to 0.\n        if (name.endsWith(\"/\")) {\n            name = name.substring(0, name.length() - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            // Use UTF-8 for PAX headers as specified by POSIX.1-2001\n            byte[] lineBytes = line.getBytes(CharsetNames.UTF_8);\n            int actualLength = lineBytes.length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second pass.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                lineBytes = line.getBytes(CharsetNames.UTF_8);\n                actualLength = lineBytes.length;\n            }\n            w.write(line);\n        }\n        // Use UTF-8 for PAX headers as specified by POSIX.1-2001\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex); // This should now use the correct size (data.length) because pex.isDirectory() is false\n        write(data);\n        closeArchiveEntry();\n    }\n    // Dummy TarBuffer class if needed\n    private static class TarBuffer {\n        void writeRecord(byte[] record) throws IOException {}\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}