{
    "generation": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    // Ensure left is an ARRAYLIT and right is a NUMBER index.\n    // Caller (visitGetElem) ensures left is ARRAYLIT.\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    // Bail out if the array access is used as an LValue. We could be assigning\n    // to an index past the end of the array, which is valid in JS, but\n    // the array literal is immutable here, so we can't fold it.\n    // e.g. \"[][0] = 1\", \"[1,2][2] = 3\", or \"([][0])++\"\n    if (NodeUtil.isLValue(n)) {\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n\n    // Check the index is a non-negative integer.\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n; // Do not fold invalid index access.\n    }\n    // Negative index is also invalid, should report error and not fold.\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    // Search for the intIndex-th child of the ARRAYLIT.\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    // If the index is out of bounds (elem is null) or the element is EMPTY (a hole),\n    // the result of the array access is 'undefined'. Fold to a VOID node.\n    if (elem == null || elem.getType() == Token.EMPTY) {\n      // Use the original node 'n' for source information, as 'elem' could be null.\n      Node undefined = NodeUtil.newUndefinedNode(n);\n      n.getParent().replaceChild(n, undefined);\n      reportCodeChange();\n      return undefined;\n    }\n\n    // Otherwise, the element is a valid node. Detach it from the ARRAYLIT.\n    left.removeChild(elem);\n\n    // Replace the GETELEM node with the element itself.\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem; // Return the element node that replaced n.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}