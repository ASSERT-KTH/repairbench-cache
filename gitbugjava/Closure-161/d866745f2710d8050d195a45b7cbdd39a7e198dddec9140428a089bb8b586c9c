{
    "generation": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    // or \"[][0] = 1;\". Let the runtime handle errors.\n    if (NodeUtil.isLValue(n)) {\n      return n;\n    }\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    // Check for floating point indices, or indices that are too large\n    // We don't handle negative indices because they are always invalid.\n    // Note: maybe we should handle Number.MAX_VALUE, Number.MIN_VALUE,\n    // and +/-Infinity, but Closure doesn't report errors in those cases.\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    // Fetch the element\n    Node elem = left.getFirstChild();\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    // Element is not found, attempt to fold to undefined\n    if (elem == null) {\n      // We can't fold if the index is clearly out of bounds,\n      // because we would be changing the runtime behavior of the program.\n      // JS runtimes will throw an error in this case.\n      int knownLength = left.getChildCount();\n      if (intIndex >= knownLength) {\n          // Report error for known out-of-bounds access, but don't fold.\n          // The runtime error should be preserved.\n          // The test case testIssue522 fails because this error was reported\n          // for an L-value, which is now handled by the isLValue check above.\n          // For R-values like `var x = [][1];`, reporting the error is appropriate.\n          error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n          return n;\n      }\n      // It is not possible to determine the element, maybe there are side effects\n      // in the array literal. Don't fold it.\n      return n;\n    }\n\n    // If the element is empty, replace it with undefined.\n    if (elem.isEmpty()) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      // Otherwise, clone the element and replace the GETELEM node with it.\n      // Cloning is necessary because the element node belongs to the array literal.\n      elem = elem.cloneNode();\n    }\n\n    // Replace the entire GETELEM with the element.\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}