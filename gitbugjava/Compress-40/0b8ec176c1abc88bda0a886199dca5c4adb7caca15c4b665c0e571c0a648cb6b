{
    "generation": "    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (count == 0) {\n             return 0L;\n        }\n\n        // Ensure we have enough bits cached to satisfy the request\n        while (bitsCachedSize < count) {\n            // Read the next byte from the input stream\n            final long nextByte = in.read(); // Returns int (0-255), or -1 for EOF\n            if (nextByte < 0) {\n                // If EOF is reached before accumulating enough bits, return -1\n                return -1;\n            }\n\n            // Incorporate the bits from the new byte into the cache based on byte order\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                // For Little Endian, new byte's bits are added conceptually at the MSB end.\n                // Implementation: Place bits manually starting at index bitsCachedSize.\n                // This avoids potential data loss from 'nextByte << bitsCachedSize'\n                // if bitsCachedSize is large (>= 57), where the byte's MSBs could be shifted out.\n                for (int i = 0; i < 8; i++) {\n                    final int targetBitIndex = bitsCachedSize + i;\n                    // Only add bits that fit within the 64-bit cache\n                    if (targetBitIndex >= 64) {\n                        break;\n                    }\n                    // If the i-th bit of nextByte is set, set the corresponding bit in the cache\n                    if ((nextByte & (1L << i)) != 0) {\n                        bitsCached |= (1L << targetBitIndex);\n                    }\n                }\n                // Increment the logical size of cached bits\n                bitsCachedSize += 8;\n            } else { // BIG_ENDIAN\n                // For Big Endian, new byte's bits are added conceptually at the LSB end.\n                // Implementation: Keep the most recent bits at the MSB end of the 'bitsCached' long.\n                // Shift existing cache content right (unsigned) to discard the oldest byte.\n                bitsCached >>>= 8;\n                // Place the new byte in the most significant 8 bits (bits 63..56).\n                // This avoids the overflow issue of 'bitsCached <<= 8' when bitsCachedSize > 56.\n                bitsCached |= (nextByte << 56);\n                // Increment the logical size of cached bits\n                bitsCachedSize += 8;\n            }\n        }\n\n        // Extract the requested number of bits from the cache\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            // Extract 'count' LSBs from the cache\n            bitsOut = (bitsCached & MASKS[count]);\n            // Remove the extracted bits from the LSB end of the cache (unsigned shift)\n            bitsCached >>>= count;\n        } else { // BIG_ENDIAN\n            // Extract 'count' MSBs from the cache.\n            // The required bits are at the MSB end due to the accumulation logic.\n            // Shift right by (64 - count) to align the top 'count' bits at the LSB end for masking.\n            bitsOut = (bitsCached >>> (64 - count)) & MASKS[count];\n            // Remove the extracted bits from the MSB end of the cache by shifting left.\n            bitsCached <<= count;\n        }\n\n        // Update the count of valid bits remaining in the cache\n        bitsCachedSize -= count;\n\n        return bitsOut;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}