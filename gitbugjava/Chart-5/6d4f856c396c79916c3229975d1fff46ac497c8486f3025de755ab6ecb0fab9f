{
    "generation": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        XYDataItem overwritten = null;\n        // Find the index of the item with the specified x-value.\n        // If 'autoSort' is true, this will be via a binary search.\n        int index = indexOf(x);\n\n        if (index >= 0) { // An item with the specified x-value already exists\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            if (this.allowDuplicateXValues) {\n                // If duplicates are allowed, we add a new item rather than update.\n                if (this.autoSort) {\n                    // If the list is sorted, we need to ensure the new item is inserted\n                    // in the correct position. binarySearch might return any index\n                    // if multiple items have the same x-value. We scan forward\n                    // from the found index to find the position *after* all existing\n                    // items with the same x-value.\n                    int insertionPoint = index;\n                    while (insertionPoint < this.data.size() &&\n                           ((XYDataItem) this.data.get(insertionPoint)).getX().equals(x)) {\n                        insertionPoint++;\n                    }\n                    this.data.add(insertionPoint, new XYDataItem(x, y));\n                } else {\n                    // If not sorted, just add the new item to the end.\n                    this.data.add(new XYDataItem(x, y));\n                }\n\n                // Check if adding the new item exceeds the maximum item count\n                if (getItemCount() > this.maximumItemCount) {\n                    this.data.remove(0);\n                }\n                fireSeriesChanged(); // Notify listeners of the change (add)\n                // No item was overwritten in this case\n            } else {\n                // If duplicates are not allowed, update the existing item's y-value.\n                try {\n                    // Clone the existing item to return as 'overwritten'\n                    overwritten = (XYDataItem) existing.clone();\n                } catch (CloneNotSupportedException e) {\n                    // This should not happen if XYDataItem is cloneable\n                    throw new SeriesException(\"Couldn't clone XYDataItem!\");\n                }\n                // Update the y-value of the existing item\n                existing.setY(y);\n                fireSeriesChanged(); // Notify listeners of the change (update)\n            }\n        } else { // No item with the specified x-value exists, add a new one\n            XYDataItem newItem = new XYDataItem(x, y);\n            if (this.autoSort) {\n                // If sorted, add the item at the calculated insertion point.\n                // The negative index from binarySearch indicates the insertion point.\n                this.data.add(-index - 1, newItem);\n            } else {\n                // If not sorted, just add the new item to the end.\n                this.data.add(newItem);\n            }\n\n            // Check if adding the new item exceeds the maximum item count\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n            fireSeriesChanged(); // Notify listeners of the change (add)\n            // No item was overwritten in this case\n        }\n\n        return overwritten;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}