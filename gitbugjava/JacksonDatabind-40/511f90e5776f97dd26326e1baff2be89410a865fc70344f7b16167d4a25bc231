{
    "generation": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.cfg.CoercionAction;\nimport com.fasterxml.jackson.databind.cfg.CoercionInputShape;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.LogicalType;\nimport com.fasterxml.jackson.databind.util.AccessPattern;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\n/**\n * Base class for common deserializers. Contains shared functionality.\n */\npublic abstract class StdScalarDeserializer<T> extends StdDeserializer<T>\n{\n    private static final long serialVersionUID = 1L;\n\n    protected StdScalarDeserializer(Class<?> vc) { super(vc); }\n    protected StdScalarDeserializer(JavaType valueType) { super(valueType); }\n\n    protected StdScalarDeserializer(StdScalarDeserializer<?> src) { super(src); }\n\n    @Override\n    public LogicalType logicalType() {\n        // By defaultscalar types are... scalar. Fine.\n        return LogicalType.OtherScalar;\n    }\n\n    @Override\n    public Boolean supportsUpdate(DeserializationConfig config) {\n        return Boolean.FALSE;\n    }\n\n    @Override\n    public AccessPattern getNullAccessPattern() {\n        // As per [databind#2135], needs to be dynamic\n        return AccessPattern.ALWAYS_NULL;\n    }\n\n    @Override\n    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n            TypeDeserializer typeDeserializer) throws IOException {\n        return typeDeserializer.deserializeTypedFromScalar(p, ctxt);\n    }\n\n    /**\n     * Overridden to handle coercion problem: if we are getting String value,\n     * need to handle \"\" perhaps coercing to null, even if input is not textual.\n     * This leads to this somewhat convoluted processing.\n     *<p>\n     * Separate method since this is only needed for textual values and\n     * hence for {@code String}, {@code Enum} and {@code Number} valued types.\n     *\n     * @since 2.12\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected T _deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // [databind#381] Need to ensure we check for null explicitly here:\n        // note that `p.getText()` should never return null, but just in case\n        String text = p.getValueAsString();\n        if (text != null) {\n            if (text.length() == 0 || text.trim().length() == 0) {\n                // 11-Jun-2020, tatu: In 2.12 need to delegate; behavior likely\n                //   to change for 3.0 (see [databind#2644])\n                return (T) _deserializeFromEmptyString(p, ctxt);\n            }\n            // 16-Aug-2019, tatu: Let's also consider \"null\" string, see [databind#2435]\n            // 25-Jul-2020, tatu: For 2.12 let's NOT coerce from \"null\" String using global defaults,\n            //    but only if coercion specifically enabled for this type\n            if (_hasTextualNull(text)) {\n                return (T) _deserializeFromTextualNull(p, ctxt, text);\n            }\n\n            // NOTE: `deserialize(JsonParser, DeserializationContext)` below\n            // is the method implemented by concrete scalar types; NOT the method\n            // in this class. And yes, `getValueAsString()` is probably redundant...\n            try {\n                return deserialize(p, ctxt);\n            } catch (IllegalArgumentException | JsonMappingException e) {\n                // And if it fails, maybe scalar wants to handle it?\n                return (T) ctxt.handleWeirdStringValue(_valueClass, text,\n                        \"not a valid textual representation\");\n            }\n        }\n\n        // But what if we get, say, number? It should be fine, actually... except... perhaps we\n        // should check for possibilities? For now, let's assume it's ok.\n        // But we have seen cases like [databind#1121]\n        // 16-Oct-2016, tatu: As per [databind#1121], we may also be given non-string,\n        //   non-null token. Need to see if we can make sense of it.\n\n        JsonToken t = p.currentToken();\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // 20-Oct-2016, tatu: Need to see if this is palatable. May need to indicate\n            //    that we can actually handle embedded Opaque value...\n            Object ob = p.getEmbeddedObject();\n            if (ob != null) {\n                if (_valueClass.isAssignableFrom(ob.getClass())) {\n                    return (T) ob;\n                }\n                return (T) ctxt.handleWeirdNativeValue(_valueClass, ob,\n                        \"Cannot deserialize instance of %s out of %s token: given Embedded Object value is of type %s\",\n                        ClassUtil.getClassDescription(_valueClass),\n                        t, ClassUtil.classNameOf(ob));\n            }\n            // if null, fall through\n        } else if (t.isScalarValue()) {\n            // Ok, see [databind#381]; need to handle null from VALUE_NULL but\n            // also possible that other scalar types might have been coerced...\n            // However: we probably should NOT allow such coercion, without annotation/feature,\n            // so:\n            return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        } else {\n            // 13-Dec-2015, tatu: Should not be possible but perhaps we just want to expedite?\n            //   Need to be careful with JsonToken.VALUE_NULL, however\n            if (t == JsonToken.VALUE_NULL) {\n                // 15-Jan-2019, tatu: Should call `getNullValue()` but not sure if we can?\n                //return getNullValue(ctxt);\n                // 03-Nov-2020, tatu: As per [databind#2916] cannot just return `getNullValue()`\n                //    as that bypasses coercion checks. Need to call this:\n                return _deserializeNull(p, ctxt);\n            }\n        }\n        // 14-Jul-2020, tatu: Should perhaps check for START_ARRAY too? But for now let's expect\n        //   callers deal with unwrapping etc.\n\n        // 19-May-2017, tatu: Let's see if we can report this more accurately, assuming\n        //   non-textual scalar is some sort of mismatch\n        return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    }\n\n    /**\n     * Helper method called for {@link JsonToken#VALUE_NULL}.\n     * Mostly needed to support {@link CoercionAction#Fail} for primitive types.\n     *\n     * @since 2.12.1\n     */\n    protected T _deserializeNull(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 03-Nov-2020, tatu: As per [databind#2916] need to check coercion for VALUE_NULL too\n        final Class<?> targetType = handledType();\n        final CoercionAction act = ctxt.findCoercionAction(logicalType(), targetType,\n                CoercionInputShape.EmptyString);\n        if (ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n            _checkCoercionFail(ctxt, act, targetType, null, \"JSON null\");\n        }\n        // Almost always returns `getNullValue(ctxt)` but may fail if config overrides:\n        return getNullValue(ctxt);\n    }\n\n    /**\n     * Helper method called when deserializing String value that is empty (or contains only\n     * whitespace). Needs to take into account coercion settings.\n     * May be overridden by sub-classes.\n     *\n     * @since 2.12\n     */\n    protected Object _deserializeFromEmptyString(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        final Class<?> targetType = handledType();\n        // 11-Jun-2020, tatu: Should we allow configuration of this? Yes, with CoercionConfigs.\n        // If not specified, how should behave? Let's check legacy setting(s), keeping\n        // in mind that [databind#2644] is proposing removal for 3.0\n        final CoercionAction act = ctxt.findCoercionAction(logicalType(), targetType,\n                CoercionInputShape.EmptyString);\n\n        // This helper will check for `CoercionAction.Fail` first and handle appropriately\n        // (throw exception if necessary; or return action)\n        final CoercionAction act2 = _checkCoercionFail(ctxt, act, targetType, \"\",\n                \"empty String (\\\"\\\")\");\n\n        if (act2 == null) { // null means `TryConvert`, basically: rely on legacy settings\n            // If indicated to be ok, needs to return `null` or \"empty\" value...\n            // 06-Oct-2020, tatu: Should only honor legacy setting for non-primitive types\n            if (!targetType.isPrimitive()) {\n                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                    return getNullValue(ctxt);\n                }\n            }\n            // If not ok, ought to fail, usually by indicating unexpected token:\n            _reportMissingContent(ctxt, \"empty String (\\\"\\\")\");\n            return null; // never reached\n        }\n        // Otherwise specific action:\n        switch (act2) {\n        case AsNull:\n            return getNullValue(ctxt);\n        case AsEmpty:\n            // 29-Sep-2020, tatu: Should use `getEmptyValue()` which may report an error\n            //    if such value not supported\n            return getEmptyValue(ctxt);\n        // case Fail handled by _checkCoercionFail above\n        // case TryConvert handled above\n        default: // Should not get here\n        }\n        // but if we do get here? Should probably fail.\n        _reportMissingContent(ctxt, \"empty String (\\\"\\\")\");\n        return null; // never reached\n    }\n\n    /**\n     * Helper method called when deserializing String value that is \"null\" text.\n     * Needs to take into account coercion settings.\n     * May be overridden by sub-classes.\n     *\n     * @since 2.12\n     */\n    protected Object _deserializeFromTextualNull(JsonParser p, DeserializationContext ctxt,\n            String nullText) throws IOException\n    {\n        // 25-Jul-2020, tatu: For 2.12 only check type-specific coercion; NOT global checks\n        //    (unless FAIL_ON_NULL_FOR_PRIMITIVES fails)\n        final Class<?> targetType = handledType();\n        final CoercionAction act = ctxt.findCoercionFromBlankString(logicalType(), targetType,\n                CoercionAction.Fail); // defaults to fail without config\n\n        if (act == CoercionAction.Fail) {\n            // 10-Aug-2020, tatu: For primitive target, use `null` as value for fail check;\n            //    for non-primitive (Object) target `null` is ok always (unless feature enabled?)\n            //    ... which makes it bit complicated. But for now seems like we can do this:\n            if (targetType.isPrimitive()) {\n                _checkCoercionFail(ctxt, act, targetType, null,\n                        \"String \\\"null\\\"\");\n            }\n        } else { // TryConvert, AsEmpty, AsNull...\n            if (act == CoercionAction.AsEmpty) {\n                // 29-Sep-2020, tatu: Should use `getEmptyValue()` which may report an error\n                //    if such value not supported\n                return getEmptyValue(ctxt);\n            }\n        }\n        // Otherwise, AsNull or TryConvert (which effectively means AsNull):\n        return getNullValue(ctxt);\n    }\n\n    /**\n     * Helper method called to determine if logical type is considered integral number.\n     *<p>\n     * Note: {@code float}, {@code double} and {@link java.math.BigDecimal} not considered\n     * integral.\n     *\n     * @since 2.12\n     */\n    protected boolean _isTrueScalarType(LogicalType explicit) {\n        if (explicit != null) {\n            switch (explicit) {\n            case Boolean:\n            case Integer:\n            case Float: // includes Double, BigDecimal\n            case DateTime: // maybe?\n                return true;\n            default:\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.12\n     */\n    protected CoercionAction _checkCoercionFail(DeserializationContext ctxt,\n            CoercionAction configuredAction, Class<?> targetType, Object inputValue,\n            String inputDesc) throws IOException\n    {\n        // First: if explicitly set to Fail, verify configuration allows that\n        if (configuredAction == CoercionAction.Fail) {\n            // Optional fail, if coercion FEATURES enabled\n            if (ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {\n                // 10-Aug-2020, tatu: As per [databind#2801], may need to check this case specifically,\n                //    for primitives. But ONLY if action is \"Fail\"\n                // 06-Oct-2020, tatu: And also... this depends on whether `null` input is problematic\n                //    and that is only true for primitives\n                if (targetType.isPrimitive()) {\n                    // If primitive, null not allowed (unless overridden):\n                    if (inputValue == null) {\n                        // Typically primitive defaults are ok... except when feature enabled\n                        if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                            // no fail means we should allow default value; which happens via `getNullValue()`\n                            // ... so need to indicate `AsNull`?\n                            return CoercionAction.AsNull;\n                        }\n                    }\n                    // But also need to consider case of empty String \"\" (if inputDesc has it)\n                    else if (\"\".equals(inputValue)) {\n                        if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_EMPTY_STRING_FOR_PRIMITIVES)) {\n                            return CoercionAction.AsNull;\n                        }\n                    }\n                }\n                // And in general non-primitive types are ok with null? Seems reasonable\n                // ... although perhaps there should be FAIL_ON_NULL_FOR_OBJECT_TYPES?\n            }\n\n            ctxt.reportBadCoercion(this, targetType, inputValue,\n                    \"Cannot coerce %s to Null value as %s (%s disabled)\",\n                    inputDesc, _coercedTypeDesc(), \"enable ConversionFeatures.ACCEPT_CASE_INSENSITIVE_PROPERTIES\");\n        }\n        return configuredAction;\n    }\n\n    /**\n     * Helper method used to report one of potentially many problems with content.\n     *\n     * @param ctxt Context for accessing configuration, getting factory\n     * @param msg Base message to use; may contain formatting arguments\n     * @param msgArgs Optional arguments, if message takes any.\n     *\n     * @since 2.12\n     */\n    protected final void _reportMissingContent(DeserializationContext ctxt,\n            String msg, Object... msgArgs) throws JsonMappingException\n    {\n        if (msgArgs.length > 0) {\n            msg = String.format(msg, msgArgs);\n        }\n        ctxt.reportInputMismatch(this, msg);\n    }\n\n    /**\n     * Method to use for accessing description of type that is being coerced to/from; usually\n     * based on {@code handledType()} but should typically be customized to produce more useful\n     * descriptions for users to indicate actual type being handled, especially within context\n     * of coercion. Defaults to {@code \"simple type into Collection\"}.\n     *\n     * @return Description of type, used in exception messages\n     *\n     * @since 2.12\n     */\n    protected String _coercedTypeDesc() {\n        // Try to determine actual type handling, if possible; otherwise indicates \"simple value\"\n        // But not sure this works that well. Sub-types should probably override.\n        JavaType type = getValueType(null);\n        boolean structured;\n        String typeDesc;\n\n        if ((type != null) && !type.isPrimitive()) {\n            structured = type.isContainerType() || type.isReferenceType();\n            typeDesc = ClassUtil.getTypeDescription(type);\n        } else {\n            Class<?> cls = handledType();\n            structured = cls.isArray() || ClassUtil.isCollectionMapOrRecord(cls);\n            typeDesc = ClassUtil.getClassDescription(cls);\n        }\n        if (structured) {\n            return \"element of \"+typeDesc;\n        }\n        return typeDesc+\" value\";\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}