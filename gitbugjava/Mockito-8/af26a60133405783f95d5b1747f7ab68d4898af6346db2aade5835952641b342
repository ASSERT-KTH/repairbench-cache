{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        // Ensure the raw type is a Class before casting and accessing type parameters\n        // This guards against potential issues with non-Class raw types (e.g., TypeVariable, WildcardType),\n        // although ParameterizedType should technically always have a Class as raw type.\n        if (!(parameterizedType.getRawType() instanceof Class)) {\n           return;\n        }\n        Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n        TypeVariable<?>[] typeParameters = rawType.getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n        // Basic check for length mismatch, though ParameterizedType contract usually guarantees matching lengths.\n        if (typeParameters.length != actualTypeArguments.length) {\n            // Mismatched arguments/parameters indicate an inconsistency.\n            // It's safer to return than proceed with potentially wrong indices.\n             return;\n        }\n\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable<?> typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            // Fix for StackOverflowError: Avoid infinite recursion in self-referential types.\n            // If a type variable (e.g., T) is mapped to itself in the context\n            // (e.g., processing the bound T extends Class<T>),\n            // registering T -> T can cause resolution algorithms to loop indefinitely.\n            // We skip registering the mapping in this specific case.\n            if (actualTypeArgument.equals(typeParameter)) {\n                continue;\n            }\n\n            if (actualTypeArgument instanceof WildcardType) {\n                // Assuming boundsOf extracts the relevant bound(s) from the wildcard\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                // Map the type parameter to its actual type argument in the current context.\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(parameterizedType) + \")\" + \"' }\");\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}