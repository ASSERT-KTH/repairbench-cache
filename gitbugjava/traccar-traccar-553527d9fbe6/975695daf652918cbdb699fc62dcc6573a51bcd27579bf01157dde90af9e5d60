{
    "generation": "    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf);\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        if (buf.readableBytes() == 20) {\n\n            buf.skipBytes(4); // remaining battery and mileage\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n            buf.readUnsignedInt(); // area id\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            buf.skipBytes(3); // reserved\n\n            return position;\n\n        }\n\n        while (buf.readableBytes() > 2) { // Loop while there's enough space for subtype and length fields\n\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n\n            // Check if the declared length is valid for the remaining buffer for the value part\n            if (length > buf.readableBytes()) {\n                // Log or handle error: declared length exceeds available buffer for value\n                // e.g. LOGGER.warn(\"Invalid TLV: subtype \" + subtype + \", length \" + length + \" exceeds readable \" + buf.readableBytes());\n                break; // Stop processing further TLVs\n            }\n            \n            int endIndex = buf.readerIndex() + length; // endIndex marks the end of the current TLV item's value\n            \n            String stringValue;\n            switch (subtype) {\n                case 0x01:\n                    position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    break;\n                case 0x02:\n                    position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1);\n                    break;\n                case 0x2b:\n                    position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt());\n                    break;\n                case 0x30:\n                    position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    break;\n                case 0x31:\n                    position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    break;\n                case 0x33:\n                    // Ensure length is not greater than readable bytes up to endIndex before reading CharSequence\n                    if (length <= buf.readableBytes()) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        if (stringValue.startsWith(\"*M00\")) {\n                            // Add boundary checks for substring operations if necessary\n                            if (stringValue.length() >= (8 + 7)) {\n                                String lockStatus = stringValue.substring(8, 8 + 7);\n                                if (lockStatus.length() >= 5) {\n                                    position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                                }\n                            }\n                        }\n                    } else {\n                        // Skip if length is problematic, already handled by main length check for buf.readerIndex(endIndex)\n                    }\n                    break;\n                case 0x60:\n                    if (length >= 2) { // Ensure there are enough bytes for a short\n                        position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                    }\n                    // Remaining bytes (if any, length - 2) will be skipped by buf.readerIndex(endIndex)\n                    break;\n                case 0x80:\n                    if (length >= 1) { // Ensure there's at least one byte for 'content'\n                        buf.readUnsignedByte(); // content\n                    }\n                    // The line \"endIndex = buf.writerIndex() - 2;\" was a bug and is removed.\n                    // decodeExtension should parse data from current buf.readerIndex() up to 'endIndex'\n                    // (which is the end of this 0x80 TLV item's value).\n                    decodeExtension(position, buf, endIndex);\n                    break;\n                case 0x91:\n                    // Add checks for length if this case expects a fixed number of bytes\n                    // For simplicity, assuming 'length' is correctly indicating enough data for all these reads.\n                    // If not, each read should be conditional or length checked.\n                    position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n                    position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                    position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte());\n                    position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255);\n                    position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255);\n                    position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40);\n                    buf.readUnsignedShort();\n                    position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01);\n                    buf.readUnsignedShort();\n                    buf.readUnsignedInt();\n                    buf.readUnsignedShort();\n                    position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01);\n                    break;\n                case 0x94:\n                    if (length > 0 && length <= buf.readableBytes()) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                case 0xA7:\n                    if (length >= 4) { // 2 shorts\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                        position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                    }\n                    break;\n                case 0xAC:\n                    if (length >= 4) { // 1 unsigned int\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                    }\n                    break;\n                case 0xBC:\n                    if (length > 0 && length <= buf.readableBytes()) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(\"driver\", stringValue.trim());\n                    }\n                    break;\n                case 0xBD:\n                    if (length > 0 && length <= buf.readableBytes()) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                    }\n                    break;\n                case 0xD0:\n                    if (length >= 4) { // 1 unsigned int\n                        long userStatus = buf.readUnsignedInt();\n                        if (BitUtil.check(userStatus, 3)) {\n                            position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                        }\n                    }\n                    break;\n                case 0xD3:\n                     if (length >= 2) { // 1 unsigned short\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    }\n                    break;\n                case 0xD4:\n                case 0xE1:\n                    if (length >= 1) { // 1 unsigned byte\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0xD5:\n                    if (length == 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 0) { // Basic check for non-empty before reading count\n                        int count = buf.readUnsignedByte();\n                        // Ensure remaining length is sufficient for 'count' items\n                        // Each item: 5 (id) + 5 (card) + 1 (battery) + 2 (status) = 13 bytes\n                        // Remaining length for loop: length - 1 (for count byte)\n                        if ((length -1) >= count * 13) {\n                            for (int i = 1; i <= count; i++) {\n                                position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                                int status = buf.readUnsignedShort();\n                                position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                            }\n                        }\n                    }\n                    break;\n                case 0xDA:\n                    if (length >= 3) { // 1 unsigned short + 1 unsigned byte\n                        buf.readUnsignedShort(); // string cut count\n                        int deviceStatus = buf.readUnsignedByte();\n                        position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                        position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                        position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                    }\n                    break;\n                case 0xE6:\n                    while (buf.readerIndex() < endIndex) {\n                        // Each item: 1 (index) + 6 (mac) + double + double (assume decodeCustomDouble reads fixed size e.g. 8 bytes)\n                        // Add check: if (buf.readableBytes() < (1+6+8+8) among other checks for endIndex) break;\n                        int sensorIndex = buf.readUnsignedByte();\n                        buf.skipBytes(6); // mac\n                        position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(buf));\n                        position.set(\"humidity\" + sensorIndex, decodeCustomDouble(buf));\n                    }\n                    break;\n                case 0xEB: // This case has complex internal logic, ensure all reads are within 'endIndex'\n                    if (buf.readableBytes() >= 2 && buf.getUnsignedShort(buf.readerIndex()) > 200) {\n                        // ... (Network parsing logic) ...\n                        // Ensure all reads in the inner while loop respect 'endIndex'\n                    } else {\n                        // ... (Extended data parsing logic) ...\n                        // Ensure all reads in the inner while loop and sub-switch respect 'endIndex'\n                    }\n                    break;\n                case 0xED:\n                     if (length > 0 && length <= buf.readableBytes()) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_CARD, stringValue.trim());\n                    }\n                    break;\n                case 0xEE:\n                    if (length >= 6) { // 1 (rssi) + 2 (power) + 2 (battery) + 1 (sats)\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0xF3: // Complex nested TLV, ensure inner loops respect 'endIndex'\n                    while (buf.readerIndex() < endIndex) {\n                        // ... (sub-TLV parsing logic) ...\n                        // Each sub-TLV's extendedLength should be checked against remaining bytes up to 'endIndex'\n                    }\n                    break;\n                case 0xFE: // Complex nested TLV\n                    if (length == 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else if (length > 1) { // Need at least 1 byte for mark\n                        int mark = buf.readUnsignedByte();\n                        if (mark == 0x7C) {\n                            while (buf.readerIndex() < endIndex) {\n                                // ... (sub-TLV parsing logic) ...\n                                // Each sub-TLV's extendedLength should be checked against remaining bytes up to 'endIndex'\n                            }\n                        }\n                        // Check if there's still space within this TLV item before reading the final byte\n                        if (buf.readerIndex() < endIndex) {\n                           position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                        }\n                    }\n                    break;\n                default:\n                    // For unhandled subtypes, data is skipped by buf.readerIndex(endIndex) below.\n                    // No action needed here if the goal is just to skip.\n                    break;\n            }\n            // Ensure reader index is advanced to the end of the current TLV item.\n            // This correctly positions for the next TLV or handles unconsumed/skipped bytes in a case.\n            buf.readerIndex(endIndex);\n        }\n\n        return position;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}