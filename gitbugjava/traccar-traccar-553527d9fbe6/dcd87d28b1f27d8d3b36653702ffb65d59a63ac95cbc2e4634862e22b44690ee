{
    "generation": "import io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport org.traccar.helper.BitUtil;\nimport org.traccar.helper.UnitsConverter;\nimport org.traccar.model.CellTower;\nimport org.traccar.model.Network;\nimport org.traccar.model.Position;\n\nimport java.nio.charset.StandardCharsets;\n\npublic abstract class HuabaoProtocolDecoder extends org.traccar.Base\n    implements org.traccar.ProtocolDecoder { // Assuming these are typical imports for context\n\n    protected abstract String getProtocolName();\n    protected abstract void decodeCoordinates(Position position, ByteBuf buf);\n    protected abstract String decodeAlarm(long value);\n    protected abstract java.util.Date readDate(ByteBuf buf, Object timezone);\n    protected abstract double decodeCustomDouble(ByteBuf buf);\n    protected abstract void decodeExtension(Position position, ByteBuf buf, int endIndex);\n\n    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf);\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        if (buf.readableBytes() == 20) {\n\n            buf.skipBytes(4); // remaining battery and mileage\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n            buf.readUnsignedInt(); // area id\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            buf.skipBytes(3); // reserved\n\n            return position;\n\n        }\n\n        while (buf.readableBytes() > 2) { // Need at least 1 byte for subtype, 1 for length\n            int currentReadPosition = buf.readerIndex(); // Store current position after subtype/length reads\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n            int blockEndIndex = currentReadPosition + length; // Calculate the end index for this block\n\n            // Defensive checks for malformed packets: if declared length exceeds remaining buffer\n            if (blockEndIndex > buf.writerIndex()) {\n                // Malformed packet: declared length goes beyond buffer's capacity.\n                // Consume remaining bytes to prevent further errors and exit the loop.\n                buf.readerIndex(buf.writerIndex());\n                break;\n            }\n\n            String stringValue;\n            switch (subtype) {\n                case 0x01: // Odometer\n                    if (length >= 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    }\n                    break;\n                case 0x02: // Fuel Level\n                    if (length >= 2) {\n                        position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1);\n                    }\n                    break;\n                case 0x2b: // Fuel Consumption\n                    if (length >= 4) {\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt());\n                    }\n                    break;\n                case 0x30: // RSSI\n                    if (length >= 1) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0x31: // Satellites\n                    if (length >= 1) {\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0x33: // String value containing lock status and battery\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        if (stringValue.startsWith(\"*M00\")) {\n                            // Ensure string has enough characters before attempting substring\n                            if (stringValue.length() >= 8 + 7) {\n                                String lockStatus = stringValue.substring(8, 8 + 7);\n                                if (lockStatus.length() >= 5) {\n                                    position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                                }\n                            }\n                        }\n                    }\n                    break;\n                case 0x60: // Event\n                    if (length >= 2) {\n                        position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                        buf.skipBytes(length - 2); // Consume remaining bytes if length is > 2\n                    } else { // Length < 2, malformed or insufficient data for subtype\n                        buf.skipBytes(length); // Skip all bytes of this block\n                    }\n                    break;\n                case 0x69: // New case for Battery (from test)\n                    if (length >= 2) { // Assuming it's a 2-byte unsigned short value\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01); // Multiplier to match test expectation\n                    }\n                    break;\n                case 0x80: // Special extension block\n                    // Note: This case redefines 'blockEndIndex' based on writerIndex,\n                    // which is a specific protocol behavior (reads till almost end of buffer).\n                    buf.readUnsignedByte(); // content\n                    blockEndIndex = buf.writerIndex() - 2; // Re-calculate the end index for this specific block\n                    decodeExtension(position, buf, blockEndIndex);\n                    break;\n                case 0x91: // OBD data block\n                    // This block reads fixed number of bytes, assuming 'length' is sufficient for all reads\n                    // If 'length' is less than expected total bytes (20 bytes based on fields),\n                    // the remaining 'length' bytes will be skipped by the final `buf.readerIndex(blockEndIndex)`\n                    if (length >= 2) { position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 2) { position.set(Position.KEY_RPM, buf.readUnsignedShort()); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 1) { position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte()); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 1) { position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 1) { position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 1) { position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 2) { buf.readUnsignedShort(); } else break; // skip\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 2) { position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01); } else break;\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 2) { buf.readUnsignedShort(); } else break; // skip\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 4) { buf.readUnsignedInt(); } else break; // skip\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 2) { buf.readUnsignedShort(); } else break; // skip\n                    if (length - (buf.readerIndex() - currentReadPosition) >= 2) { position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01); }\n                    break;\n                case 0x94: // VIN\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                case 0xA7: // ADC values\n                    if (length >= 4) { // Requires 2 unsigned shorts\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                        position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                    }\n                    break;\n                case 0xAC: // Odometer\n                    if (length >= 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                    }\n                    break;\n                case 0xBC: // Driver name\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(\"driver\", stringValue.trim());\n                    }\n                    break;\n                case 0xBD: // Driver Unique ID\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                    }\n                    break;\n                case 0xD0: // User Status / Alarm\n                    if (length >= 4) {\n                        long userStatus = buf.readUnsignedInt();\n                        if (BitUtil.check(userStatus, 3)) {\n                            position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                        }\n                    }\n                    break;\n                case 0xD3: // Power\n                    if (length >= 2) {\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    }\n                    break;\n                case 0xD4: // Battery Level\n                case 0xE1: // Battery Level\n                    if (length >= 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0xD5: // Battery / Lock Data\n                    if (length == 2) { // Specific length for battery percentage\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 2) { // Other structures with mark and extended types\n                        int count = buf.readUnsignedByte(); // First byte of data is count\n                        // Check if remaining length is sufficient for 'count' locks (each 13 bytes)\n                        if (1 + count * 13 > length) { // 1 for count byte, 13 for each lock\n                            buf.skipBytes(length - 1); // Skip remaining part of this length block\n                            break;\n                        }\n                        for (int i = 1; i <= count; i++) {\n                            if (buf.readableBytes() < 5) { break; }\n                            position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                            if (buf.readableBytes() < 5) { break; }\n                            position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                            if (buf.readableBytes() < 1) { break; }\n                            position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                            if (buf.readableBytes() < 2) { break; }\n                            int status = buf.readUnsignedShort();\n                            position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                        }\n                    }\n                    break;\n                case 0xDA: // Device status\n                    if (length >= 3) { // 2 for string cut count, 1 for device status byte\n                        buf.readUnsignedShort(); // string cut count\n                        int deviceStatus = buf.readUnsignedByte();\n                        position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                        position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                        position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                    }\n                    break;\n                case 0xE6: // Temperature/Humidity sensors\n                    while (buf.readerIndex() < blockEndIndex) {\n                        // Ensure enough bytes for a full sensor block (1+6+4+4 = 15 bytes)\n                        if (buf.readableBytes() < 15 || buf.readerIndex() + 15 > blockEndIndex) {\n                            buf.readerIndex(blockEndIndex); // Jump to end if malformed or incomplete sensor data\n                            break;\n                        }\n                        int sensorIndex = buf.readUnsignedByte();\n                        buf.skipBytes(6); // mac\n                        position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(buf));\n                        position.set(\"humidity\" + sensorIndex, decodeCustomDouble(buf));\n                    }\n                    break;\n                case 0xEB: // Network / Extended attributes\n                    // This case has two main branches based on peeked value and iterates till 'blockEndIndex'\n                    if (buf.readableBytes() < 2) { // Needs at least 2 bytes to peek\n                        break;\n                    }\n                    if (buf.getUnsignedShort(buf.readerIndex()) > 200) { // Check peeked value for branch logic\n                        Network network = new Network();\n                        if (length >= 3) { // Needs at least 3 for mcc/mnc\n                            int mcc = buf.readUnsignedShort();\n                            int mnc = buf.readUnsignedByte();\n                            while (buf.readerIndex() < blockEndIndex) {\n                                // Ensure enough bytes for a cell tower (5 bytes: 2 for lac, 2 for cid, 1 for rssi)\n                                if (buf.readableBytes() < 5 || buf.readerIndex() + 5 > blockEndIndex) {\n                                    buf.readerIndex(blockEndIndex);\n                                    break;\n                                }\n                                network.addCellTower(CellTower.from(\n                                        mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(),\n                                        buf.readUnsignedByte()));\n                            }\n                            position.setNetwork(network);\n                        } else {\n                            buf.skipBytes(length); // Skip block if not enough for mcc/mnc\n                        }\n                    } else {\n                        while (buf.readerIndex() < blockEndIndex) {\n                            // Ensure enough bytes for extended type header (2 for extendedLength, 2 for extendedType)\n                            if (buf.readableBytes() < 4 || buf.readerIndex() + 4 > blockEndIndex) {\n                                buf.readerIndex(blockEndIndex);\n                                break;\n                            }\n                            int extendedLength = buf.readUnsignedShort(); // This is the total length including its own header\n                            int extendedType = buf.readUnsignedShort();\n                            // Remaining bytes for data part is extendedLength - 2 (for type and length fields already read)\n                            int dataLength = extendedLength - 2;\n\n                            // Ensure data length does not exceed current block remaining bytes\n                            if (buf.readerIndex() + dataLength > blockEndIndex) {\n                                buf.readerIndex(blockEndIndex);\n                                break;\n                            }\n                            switch (extendedType) {\n                                case 0x0001: // Fuel 1\n                                    if (dataLength >= 3) { // 2 for fuel value, 1 for unused\n                                        position.set(\"fuel1\", buf.readUnsignedShort() * 0.1);\n                                        buf.readUnsignedByte(); // unused\n                                    } else { buf.skipBytes(dataLength); }\n                                    break;\n                                case 0x0023: // Fuel 2\n                                    if (dataLength >= 6) {\n                                        position.set(\"fuel2\", Double.parseDouble(\n                                                buf.readCharSequence(6, StandardCharsets.US_ASCII).toString()));\n                                    } else { buf.skipBytes(dataLength); }\n                                    break;\n                                case 0x00CE: // Power\n                                    if (dataLength >= 2) {\n                                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01);\n                                    } else { buf.skipBytes(dataLength); }\n                                    break;\n                                case 0x00D8: // Network (Cell Tower)\n                                    if (dataLength >= 9) { // 2+1+2+4 bytes for CellTower.from\n                                        Network network = new Network();\n                                        network.addCellTower(CellTower.from(\n                                                buf.readUnsignedShort(), buf.readUnsignedByte(),\n                                                buf.readUnsignedShort(), buf.readUnsignedInt()));\n                                        position.setNetwork(network);\n                                    } else { buf.skipBytes(dataLength); }\n                                    break;\n                                case 0xE1: // Battery Level\n                                    if (dataLength >= 1) {\n                                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                                    } else { buf.skipBytes(dataLength); }\n                                    break;\n                                default:\n                                    buf.skipBytes(dataLength);\n                                    break;\n                            }\n                        }\n                    }\n                    break;\n                case 0xED: // Card\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_CARD, stringValue.trim());\n                    }\n                    break;\n                case 0xEE: // Sensor data (RSSI, Power, Battery, Satellites)\n                    if (length >= 6) { // 1 (RSSI) + 2 (Power) + 2 (Battery) + 1 (Satellites) = 6 bytes\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    }\n                    break;\n                case 0xF3: // OBD/Extended data\n                    while (buf.readerIndex() < blockEndIndex) {\n                        // Ensure enough bytes for extended type header (2 for extendedType, 1 for extendedLength)\n                        if (buf.readableBytes() < 3 || buf.readerIndex() + 3 > blockEndIndex) {\n                            buf.readerIndex(blockEndIndex);\n                            break;\n                        }\n                        int extendedType = buf.readUnsignedShort();\n                        int extendedLength = buf.readUnsignedByte();\n\n                        // Ensure extendedLength does not exceed current block remaining bytes\n                        if (buf.readerIndex() + extendedLength > blockEndIndex) {\n                            buf.readerIndex(blockEndIndex);\n                            break;\n                        }\n                        switch (extendedType) {\n                            case 0x0002: if (extendedLength >= 2) { position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0003: if (extendedLength >= 2) { position.set(Position.KEY_RPM, buf.readUnsignedShort()); } break;\n                            case 0x0004: if (extendedLength >= 2) { position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001); } break;\n                            case 0x0005: if (extendedLength >= 4) { position.set(Position.KEY_OBD_ODOMETER, buf.readUnsignedInt() * 100); } break;\n                            case 0x0007: if (extendedLength >= 2) { position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0008: if (extendedLength >= 2) { position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0009: if (extendedLength >= 2) { position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShort() - 40); } break;\n                            case 0x000B: if (extendedLength >= 2) { position.set(\"intakePressure\", buf.readUnsignedShort()); } break;\n                            case 0x000C: if (extendedLength >= 2) { position.set(\"intakeTemp\", buf.readUnsignedShort() - 40); } break;\n                            case 0x000D: if (extendedLength >= 2) { position.set(\"intakeFlow\", buf.readUnsignedShort()); } break;\n                            case 0x000E: if (extendedLength >= 2) { position.set(Position.KEY_THROTTLE, buf.readUnsignedShort() * 100 / 255); } break;\n                            case 0x0050: if (extendedLength >= 17) { position.set(Position.KEY_VIN, buf.readSlice(17).toString(StandardCharsets.US_ASCII)); } break;\n                            case 0x0100: if (extendedLength >= 2) { position.set(Position.KEY_ODOMETER_TRIP, buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0102: if (extendedLength >= 2) { position.set(\"tripFuel\", buf.readUnsignedShort() * 0.1); } break;\n                            case 0x0112: if (extendedLength >= 2) { position.set(\"hardAccelerationCount\", buf.readUnsignedShort()); } break;\n                            case 0x0113: if (extendedLength >= 2) { position.set(\"hardDecelerationCount\", buf.readUnsignedShort()); } break;\n                            case 0x0114: if (extendedLength >= 2) { position.set(\"hardCorneringCount\", buf.readUnsignedShort()); } break;\n                            default:\n                                buf.skipBytes(extendedLength);\n                                break;\n                        }\n                    }\n                    break;\n                case 0xFE: // Battery Level / Alarm\n                    if (length == 1) { // Sets battery level\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else if (length == 2) { // Sets battery percentage\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 2) { // Handles structures with 'mark' and extended types\n                        // Check if remaining length is sufficient for 'mark' byte\n                        if (buf.readableBytes() < length) {\n                            buf.skipBytes(buf.readableBytes()); // Skip remaining till end of buffer if malformed\n                            break;\n                        }\n                        int mark = buf.readUnsignedByte(); // Reads the 'mark' byte (1 byte)\n                        if (mark == 0x7C) {\n                            while (buf.readerIndex() < blockEndIndex) {\n                                // Ensure enough bytes for extended type header (1 for type, 1 for length)\n                                if (buf.readableBytes() < 2 || buf.readerIndex() + 2 > blockEndIndex) {\n                                    buf.readerIndex(blockEndIndex); // Jump to end if malformed sub-block\n                                    break;\n                                }\n                                int extendedType = buf.readUnsignedByte();\n                                int extendedLength = buf.readUnsignedByte();\n                                // Ensure extendedLength does not exceed current block remaining bytes\n                                if (buf.readerIndex() + extendedLength > blockEndIndex) {\n                                    buf.readerIndex(blockEndIndex);\n                                    break;\n                                }\n                                switch (extendedType) {\n                                    case 0x01: // Alarms\n                                        if (extendedLength >= 4) {\n                                            long alarms = buf.readUnsignedInt();\n                                            if (BitUtil.check(alarms, 0)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION); }\n                                            if (BitUtil.check(alarms, 1)) { position.set(Position.KEY_ALARM, Position.ALARM_BRAKING); }\n                                            if (BitUtil.check(alarms, 2)) { position.set(Position.KEY_ALARM, Position.ALARM_CORNERING); }\n                                            if (BitUtil.check(alarms, 3)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT); }\n                                            if (BitUtil.check(alarms, 4)) { position.set(Position.KEY_ALARM, Position.ALARM_TAMPERING); }\n                                        }\n                                        break;\n                                    default:\n                                        buf.skipBytes(extendedLength);\n                                        break;\n                                }\n                            }\n                        } else {\n                            // Mark is not 0x7C. We consumed 1 byte for mark. Skip remaining `length - 1` bytes of this block.\n                            if (length - 1 > 0) { // Ensure there are bytes to skip\n                                buf.skipBytes(length - 1);\n                            }\n                        }\n                    }\n                    break;\n                default:\n                    // For any unhandled subtypes, or if the subtype handler did not consume all `length` bytes,\n                    // this will ensure the reader index is moved to the end of the current block.\n                    buf.skipBytes(length);\n                    break;\n            }\n            // Crucial: After processing the subtype, ensure the buffer reader index is exactly at `blockEndIndex`.\n            // This handles cases where a handler might read more or less than `length` bytes,\n            // or if the `default` case was used. This is vital for maintaining correct parsing state\n            // and preventing infinite loops if a case does not fully consume its declared length.\n            if (buf.readerIndex() != blockEndIndex) {\n                buf.readerIndex(blockEndIndex);\n            }\n        }\n\n        return position;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}