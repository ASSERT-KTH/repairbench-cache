{
    "generation": "    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf);\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        if (buf.readableBytes() == 20) {\n\n            buf.skipBytes(4); // remaining battery and mileage\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000);\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n            buf.readUnsignedInt(); // area id\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n            buf.skipBytes(3); // reserved\n\n            return position;\n\n        }\n\n        while (buf.readableBytes() > 1) { // Need at least Type and Length bytes\n\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n            int effectiveLength = length;\n\n            // Heuristic: Correct obviously invalid length for known fixed-length type 0x01\n            // Addresses cases where length byte seems wrong (e.g., 0xFE).\n            if (subtype == 0x01 && (length < 4 || length > buf.readableBytes())) {\n                if (buf.readableBytes() >= 4) {\n                    effectiveLength = 4; // Assume fixed length 4 for Odometer if length looks wrong\n                } else {\n                    // Not enough bytes even for fixed length, stop processing TLVs\n                    // Log potentially truncated message?\n                    break;\n                }\n            } else if (effectiveLength > buf.readableBytes()) {\n                // Check if the declared length is valid for other types\n                // Log potentially invalid length?\n                break; // Stop processing TLVs for this message\n            }\n\n            int valueStartIndex = buf.readerIndex();\n            int endIndex = valueStartIndex + effectiveLength;\n\n            String stringValue; // Hoisted declaration\n            switch (subtype) {\n                case 0x01:\n                    // Use effectiveLength derived above\n                    if (effectiveLength == 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    } else {\n                        // Skip based on effective length if it wasn't corrected to 4\n                        buf.skipBytes(effectiveLength);\n                    }\n                    break;\n                case 0x02:\n                    if (effectiveLength == 2) { position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1); } else { buf.skipBytes(effectiveLength); }\n                    break;\n                case 0x2b:\n                    if (effectiveLength == 4) { position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt()); } else { buf.skipBytes(effectiveLength); }\n                    break;\n                case 0x30:\n                    if (effectiveLength == 1) { position.set(Position.KEY_RSSI, buf.readUnsignedByte()); } else { buf.skipBytes(effectiveLength); }\n                    break;\n                case 0x31:\n                    if (effectiveLength == 1) { position.set(Position.KEY_SATELLITES, buf.readUnsignedByte()); } else { buf.skipBytes(effectiveLength); }\n                    break;\n                case 0x33: // Uses length\n                    stringValue = buf.readCharSequence(effectiveLength, StandardCharsets.US_ASCII).toString();\n                    if (stringValue.startsWith(\"*M00\")) {\n                        if (stringValue.length() >= 15) { // Ensure string is long enough\n                            String lockStatus = stringValue.substring(8, 8 + 7);\n                            if (lockStatus.length() >= 5) { // Ensure substring is long enough\n                                try {\n                                    position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                                } catch (NumberFormatException e) { /* Log error? */ }\n                            }\n                        }\n                    }\n                    break;\n                case 0x60: // Uses length\n                    if (effectiveLength >= 2) {\n                        position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                        buf.skipBytes(effectiveLength - 2); // Skip remaining\n                    } else {\n                        buf.skipBytes(effectiveLength); // Skip if length < 2\n                    }\n                    break;\n                 case 0x80: // Uses length\n                     if (effectiveLength >= 1) {\n                         buf.readUnsignedByte(); // content - Assume this is part of value\n                         // Ensure decodeExtension does not read past endIndex\n                         // endIndex is calculated using effectiveLength\n                         decodeExtension(position, buf, endIndex);\n                     }\n                     // Ensure reader index is advanced correctly, either by decodeExtension or by setting it here\n                     buf.readerIndex(endIndex); // Set to end, assuming decodeExtension might not consume all\n                     break;\n                case 0x91: // Fixed length 24 assumed\n                     if (effectiveLength == 24) {\n                         position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n                         position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                         position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte());\n                         position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255);\n                         position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255);\n                         position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40);\n                         buf.readUnsignedShort();\n                         position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01);\n                         buf.readUnsignedShort();\n                         buf.readUnsignedInt();\n                         buf.readUnsignedShort();\n                         position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01);\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                case 0x94: // Uses length\n                    if (effectiveLength > 0) {\n                        stringValue = buf.readCharSequence(effectiveLength, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                 case 0xA7: // Fixed length 4 assumed\n                     if (effectiveLength == 4) {\n                         position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                         position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                 case 0xAC: // Fixed length 4 assumed\n                     if (effectiveLength == 4) {\n                         position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                case 0xBC: // Uses length\n                    stringValue = buf.readCharSequence(effectiveLength, StandardCharsets.US_ASCII).toString();\n                    position.set(\"driver\", stringValue.trim());\n                    break;\n                case 0xBD: // Uses length\n                    stringValue = buf.readCharSequence(effectiveLength, StandardCharsets.US_ASCII).toString();\n                    position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                    break;\n                case 0xD0: // Fixed length 4 assumed\n                     if (effectiveLength == 4) {\n                         long userStatus = buf.readUnsignedInt();\n                         if (BitUtil.check(userStatus, 3)) {\n                             position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                         }\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                 case 0xD3: // Fixed length 2 assumed\n                     if (effectiveLength == 2) {\n                         position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                 case 0xD4: // Fixed length 1 assumed\n                 case 0xE1: // Fixed length 1 assumed\n                      if (effectiveLength == 1) {\n                          position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                      } else { buf.skipBytes(effectiveLength); }\n                      break;\n                case 0x69: // ADDED Fallthrough to handle battery on subtype 69 seen in test data\n                case 0xD5: // Uses original length field for logic, but effectiveLength for buffer reads/skips\n                    if (length == 2) { // Use original length for logic branch\n                        if (effectiveLength >= 2) { // Ensure we can read based on effectiveLength\n                             position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                        } else { buf.skipBytes(effectiveLength); } // Skip if cannot read\n                    } else if (length > 0) { // Use original length for lock structure logic\n                        if (effectiveLength >= 1) { // Ensure count byte is readable based on effectiveLength\n                            int count = buf.readUnsignedByte();\n                            int requiredBytes = count * (5 + 5 + 1 + 2);\n                            // Check if declared 'length' matches expected and we have enough bytes remaining in block based on effectiveLength\n                            if (length == 1 + requiredBytes && (effectiveLength - 1) >= requiredBytes) {\n                                for (int i = 1; i <= count; i++) {\n                                     position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                     position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                     position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                                     int status = buf.readUnsignedShort();\n                                     position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                                }\n                            } else {\n                                // Length mismatch or not enough effective bytes, skip remaining part of block\n                                buf.readerIndex(endIndex); // Use endIndex based on effectiveLength\n                            }\n                        } else { buf.skipBytes(effectiveLength); } // Skip if cannot read count byte\n                    }\n                    // If length == 0, skip 0 bytes.\n                    break;\n                case 0xDA: // Fixed length 3 assumed\n                     if (effectiveLength == 3) {\n                         buf.readUnsignedShort(); // string cut count\n                         int deviceStatus = buf.readUnsignedByte();\n                         position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                         position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                         position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                case 0xE6: // Uses length\n                     while (buf.readerIndex() < endIndex) {\n                         if (buf.readableBytes() < 1 + 6 + 8 + 8) break; // Check bytes needed for one iteration\n                         int sensorIndex = buf.readUnsignedByte();\n                         buf.skipBytes(6); // mac\n                         position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(buf));\n                         position.set(\"humidity\" + sensorIndex, decodeCustomDouble(buf));\n                     }\n                     buf.readerIndex(endIndex); // Ensure we are exactly at endIndex\n                     break;\n                case 0xEB: // Uses length, complex inner logic\n                     // Original logic preserved but wrapped with check against endIndex\n                     if (buf.readableBytes() < 2) { buf.readerIndex(endIndex); break; } // Check for getShort\n                     if (buf.getUnsignedShort(buf.readerIndex()) > 200) {\n                         if (buf.readableBytes() < 2 + 1) { buf.readerIndex(endIndex); break; } // Check for mcc/mnc read\n                         Network network = new Network();\n                         int mcc = buf.readUnsignedShort();\n                         int mnc = buf.readUnsignedByte();\n                         while (buf.readerIndex() < endIndex) {\n                             if (buf.readableBytes() < 2 + 2 + 1) break; // Check bytes needed for cell tower\n                             network.addCellTower(CellTower.from(\n                                     mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(),\n                                     buf.readUnsignedByte()));\n                         }\n                         position.setNetwork(network);\n                     } else {\n                         while (buf.readerIndex() < endIndex) {\n                              if (buf.readableBytes() < 2 + 2) break; // Check for extended header\n                             int extendedLength = buf.readUnsignedShort();\n                             int extendedType = buf.readUnsignedShort();\n                             int extendedValueLength = extendedLength - 2;\n                             if (extendedValueLength < 0 || buf.readerIndex() + extendedValueLength > endIndex) {\n                                 // Invalid extendedLength, stop processing this EB block\n                                 buf.readerIndex(endIndex);\n                                 break;\n                             }\n                             switch (extendedType) {\n                                 case 0x0001: if (extendedValueLength == 3) { position.set(\"fuel1\", buf.readUnsignedShort() * 0.1); buf.readUnsignedByte(); } else { buf.skipBytes(extendedValueLength); } break;\n                                 case 0x0023: if (extendedValueLength == 6) { position.set(\"fuel2\", Double.parseDouble(buf.readCharSequence(6, StandardCharsets.US_ASCII).toString())); } else { buf.skipBytes(extendedValueLength); } break;\n                                 case 0x00CE: if (extendedValueLength == 2) { position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.01); } else { buf.skipBytes(extendedValueLength); } break;\n                                 case 0x00D8: if (extendedValueLength == 9) { Network network = new Network(); network.addCellTower(CellTower.from(buf.readUnsignedShort(), buf.readUnsignedByte(), buf.readUnsignedShort(), buf.readUnsignedInt())); position.setNetwork(network); } else { buf.skipBytes(extendedValueLength); } break;\n                                 case 0xE1: if (extendedValueLength == 1) { position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte()); } else { buf.skipBytes(extendedValueLength); } break;\n                                 default: buf.skipBytes(extendedValueLength); break;\n                             }\n                         }\n                     }\n                     buf.readerIndex(endIndex); // Ensure readerIndex is at endIndex\n                     break;\n                case 0xED: // Uses length\n                    stringValue = buf.readCharSequence(effectiveLength, StandardCharsets.US_ASCII).toString();\n                    position.set(Position.KEY_CARD, stringValue.trim());\n                    break;\n                case 0xEE: // Fixed length 6 assumed\n                     if (effectiveLength == 6) {\n                         position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                         position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                         position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001);\n                         position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                     } else { buf.skipBytes(effectiveLength); }\n                     break;\n                case 0xF3: // Uses length, complex inner logic\n                     while (buf.readerIndex() < endIndex) {\n                         if (buf.readableBytes() < 2 + 1) break; // Check for extended header\n                         int extendedType = buf.readUnsignedShort();\n                         int extendedLength = buf.readUnsignedByte();\n                         if (buf.readerIndex() + extendedLength > endIndex) {\n                              // Invalid extendedLength, stop processing this F3 block\n                              buf.readerIndex(endIndex);\n                              break;\n                         }\n                         switch (extendedType) {\n                            case 0x0002: if (extendedLength == 2) position.set(Position.KEY_OBD_SPEED, buf.readUnsignedShort() * 0.1); else buf.skipBytes(extendedLength); break;\n                            case 0x0003: if (extendedLength == 2) position.set(Position.KEY_RPM, buf.readUnsignedShort()); else buf.skipBytes(extendedLength); break;\n                            case 0x0004: if (extendedLength == 2) position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001); else buf.skipBytes(extendedLength); break;\n                            case 0x0005: if (extendedLength == 4) position.set(Position.KEY_OBD_ODOMETER, buf.readUnsignedInt() * 100); else buf.skipBytes(extendedLength); break;\n                            case 0x0007: if (extendedLength == 2) position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.1); else buf.skipBytes(extendedLength); break;\n                            case 0x0008: if (extendedLength == 2) position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedShort() * 0.1); else buf.skipBytes(extendedLength); break;\n                            case 0x0009: if (extendedLength == 2) position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedShort() - 40); else buf.skipBytes(extendedLength); break;\n                            case 0x000B: if (extendedLength == 2) position.set(\"intakePressure\", buf.readUnsignedShort()); else buf.skipBytes(extendedLength); break;\n                            case 0x000C: if (extendedLength == 2) position.set(\"intakeTemp\", buf.readUnsignedShort() - 40); else buf.skipBytes(extendedLength); break;\n                            case 0x000D: if (extendedLength == 2) position.set(\"intakeFlow\", buf.readUnsignedShort()); else buf.skipBytes(extendedLength); break;\n                            case 0x000E: if (extendedLength == 2) position.set(Position.KEY_THROTTLE, buf.readUnsignedShort() * 100 / 255); else buf.skipBytes(extendedLength); break;\n                            case 0x0050: if (extendedLength == 17) position.set(Position.KEY_VIN, buf.readSlice(17).toString(StandardCharsets.US_ASCII)); else buf.skipBytes(extendedLength); break;\n                            case 0x0100: if (extendedLength == 2) position.set(Position.KEY_ODOMETER_TRIP, buf.readUnsignedShort() * 0.1); else buf.skipBytes(extendedLength); break;\n                            case 0x0102: if (extendedLength == 2) position.set(\"tripFuel\", buf.readUnsignedShort() * 0.1); else buf.skipBytes(extendedLength); break;\n                            case 0x0112: if (extendedLength == 2) position.set(\"hardAccelerationCount\", buf.readUnsignedShort()); else buf.skipBytes(extendedLength); break;\n                            case 0x0113: if (extendedLength == 2) position.set(\"hardDecelerationCount\", buf.readUnsignedShort()); else buf.skipBytes(extendedLength); break;\n                            case 0x0114: if (extendedLength == 2) position.set(\"hardCorneringCount\", buf.readUnsignedShort()); else buf.skipBytes(extendedLength); break;\n                             default:\n                                 buf.skipBytes(extendedLength);\n                                 break;\n                         }\n                     }\n                     buf.readerIndex(endIndex); // Ensure readerIndex is at endIndex\n                     break;\n                case 0xFE: // Uses length, complex inner logic\n                     if (length == 1) { // Use original length for logic check\n                         if (effectiveLength >= 1) { // Use effectiveLength for read check\n                              position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                         } else { buf.skipBytes(effectiveLength); }\n                     } else if (length > 0) { // Use original length for structure check\n                         if (effectiveLength >= 1) { // Ensure mark byte readable based on effectiveLength\n                             int mark = buf.readUnsignedByte();\n                             if (mark == 0x7C) {\n                                 // Loop reading internal TLVs until just before battery level byte\n                                 while (buf.readerIndex() < endIndex - 1) { // endIndex based on effectiveLength\n                                      if (buf.readableBytes() < 1 + 1) break; // Check for internal header\n                                     int extendedType = buf.readUnsignedByte();\n                                     int extendedLength = buf.readUnsignedByte();\n                                      // Check if internal TLV fits within outer TLV (before battery byte)\n                                      if (buf.readerIndex() + extendedLength > endIndex - 1) {\n                                           // Invalid internal structure, stop processing this FE block\n                                           buf.readerIndex(endIndex);\n                                           break; // Break inner loop\n                                      }\n                                     if (extendedType == 0x01) {\n                                          if (extendedLength == 4) {\n                                              long alarms = buf.readUnsignedInt();\n                                              if (BitUtil.check(alarms, 0)) position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION);\n                                              if (BitUtil.check(alarms, 1)) position.set(Position.KEY_ALARM, Position.ALARM_BRAKING);\n                                              if (BitUtil.check(alarms, 2)) position.set(Position.KEY_ALARM, Position.ALARM_CORNERING);\n                                              if (BitUtil.check(alarms, 3)) position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT);\n                                              if (BitUtil.check(alarms, 4)) position.set(Position.KEY_ALARM, Position.ALARM_TAMPERING);\n                                          } else { buf.skipBytes(extendedLength); }\n                                      } else {\n                                         buf.skipBytes(extendedLength);\n                                     }\n                                 }\n                                  // After loop, check if we are positioned correctly before final byte\n                                 if (buf.readerIndex() == endIndex -1) {\n                                      position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                                 } else {\n                                     // Error in inner loop or structure, ensure index is at end\n                                      buf.readerIndex(endIndex);\n                                 }\n                             } else { // Mark != 0x7C\n                                 // We read the mark byte, position reader before final byte\n                                 buf.readerIndex(endIndex - 1);\n                                  if (buf.readableBytes() >= 1) { // Check if final byte readable\n                                     position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                                  }\n                             }\n                         } else { buf.skipBytes(effectiveLength); } // Skip if cannot read mark\n                     }\n                     buf.readerIndex(endIndex); // Ensure readerIndex is at endIndex\n                     break;\n                default: // Unknown subtype\n                     buf.skipBytes(effectiveLength);\n                     break;\n            }\n\n            // Safety check: Ensure reader index is not past endIndex\n            // This corrects cases where internal logic might overshoot or undershoot.\n            if (buf.readerIndex() > endIndex) {\n                // Log error? Reader index is past expected end index for subtype \" + subtype\n                 buf.readerIndex(endIndex); // Force it back to expected end\n            } else if (buf.readerIndex() < endIndex) {\n                 // Log error? Case didn't consume expected bytes for subtype \" + subtype\n                 buf.readerIndex(endIndex); // Force skip to end index\n            }\n\n        } // End while loop\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}