{
    "generation": "    private Position decodeLocation(DeviceSession deviceSession, ByteBuf buf) {\n\n        Position position = new Position(getProtocolName());\n        position.setDeviceId(deviceSession.getDeviceId());\n\n        position.set(Position.KEY_ALARM, decodeAlarm(buf.readUnsignedInt()));\n\n        decodeCoordinates(position, buf);\n\n        position.setAltitude(buf.readShort());\n        position.setSpeed(UnitsConverter.knotsFromKph(buf.readUnsignedShort() * 0.1));\n        position.setCourse(buf.readUnsignedShort());\n        position.setTime(readDate(buf, deviceSession.get(DeviceSession.KEY_TIMEZONE)));\n\n        // This fixed 20-byte format seems rare and the logic was potentially buggy (18 bytes consumed?).\n        // Kept for potential compatibility but unlikely to be hit by TLV-based messages.\n        if (buf.readableBytes() == 20) {\n            buf.skipBytes(4); // remaining battery and mileage? Or just skip 4?\n            position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 1000); // 4 bytes\n            position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1); // 2 bytes - Note: multiplier might be wrong for some devices\n            buf.readUnsignedInt(); // area id (4 bytes)\n            position.set(Position.KEY_RSSI, buf.readUnsignedByte()); // 1 byte\n            buf.skipBytes(5); // reserved - Skip 5 to make total 4+4+2+4+1+5 = 20 bytes\n            return position;\n        }\n\n        while (buf.readableBytes() > 2) {\n\n            int subtype = buf.readUnsignedByte();\n            int length = buf.readUnsignedByte();\n            int startIndex = buf.readerIndex(); // Keep track of start index\n            int endIndex = startIndex + length;\n\n            // Ensure length does not exceed buffer bounds\n            if (endIndex > buf.writerIndex()) {\n                 break;\n            }\n\n            String stringValue;\n            switch (subtype) {\n                case 0x01: // ODOMETER\n                    if (length == 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt() * 100);\n                    } else {\n                        buf.skipBytes(length); // Skip if length is not 4\n                    }\n                    break;\n                case 0x02:\n                    if (length == 2) {\n                        position.set(Position.KEY_FUEL_LEVEL, buf.readUnsignedShort() * 0.1);\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x08: // Nested TLVs (observed in some logs)\n                    ByteBuf value08 = buf.readSlice(length); // Read the value part into a slice\n                    while (value08.readableBytes() > 2) {\n                        int subType = value08.readUnsignedByte();\n                        int subLength = value08.readUnsignedByte();\n                        int subEndIndex = value08.readerIndex() + subLength;\n                        if (subEndIndex > value08.writerIndex()) {\n                            break; // Avoid over-reading sub-buffer\n                        }\n                        switch (subType) {\n                            case 0x69: // Battery Voltage (based on analysis of test data)\n                                if (subLength == 2) {\n                                    // Assumes * 0.01 based on common patterns and test expectation\n                                    position.set(Position.KEY_BATTERY, value08.readUnsignedShort() * 0.01);\n                                } else {\n                                    value08.skipBytes(subLength);\n                                }\n                                break;\n                            // Add other potential subtypes found within 0x08 if known\n                            default:\n                                value08.skipBytes(subLength); // Skip unknown subtypes within 0x08\n                                break;\n                        }\n                        // Ensure reader index advances correctly within the slice\n                        if (value08.readableBytes() > 0 && value08.readerIndex() < subEndIndex) {\n                             value08.readerIndex(subEndIndex);\n                        }\n                    }\n                    // The main buffer's readerIndex is automatically advanced by readSlice(length)\n                    break;\n                case 0x2b:\n                    if (length == 4) {\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedInt());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x30:\n                    if (length == 1) {\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x31:\n                    if (length == 1) {\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x33:\n                    stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                    if (stringValue.startsWith(\"*M00\")) {\n                        // String format seems specific, ensure indices are safe\n                        if (stringValue.length() >= 15) {\n                            String lockStatus = stringValue.substring(8, 15); // length 7\n                            if (lockStatus.length() >= 5) {\n                                try {\n                                    position.set(Position.KEY_BATTERY, Integer.parseInt(lockStatus.substring(2, 5)) * 0.01);\n                                } catch (NumberFormatException e) {\n                                    // Ignore parsing error\n                                }\n                            }\n                        }\n                    }\n                    break;\n                case 0x60:\n                    if (length >= 2) {\n                        position.set(Position.KEY_EVENT, buf.readUnsignedShort());\n                        buf.skipBytes(length - 2);\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0x80:\n                    // Original code was broken (writerIndex, no length use). Skip until format is confirmed.\n                    buf.skipBytes(length);\n                    break;\n                case 0x91: // OBD data block - reads a fixed structure\n                    // Check if length matches expected fixed structure size (24 bytes)\n                    if (length == 24) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.1);\n                        position.set(Position.KEY_RPM, buf.readUnsignedShort());\n                        position.set(Position.KEY_OBD_SPEED, buf.readUnsignedByte());\n                        position.set(Position.KEY_THROTTLE, buf.readUnsignedByte() * 100 / 255);\n                        position.set(Position.KEY_ENGINE_LOAD, buf.readUnsignedByte() * 100 / 255);\n                        position.set(Position.KEY_COOLANT_TEMP, buf.readUnsignedByte() - 40);\n                        buf.readUnsignedShort(); // skip 2 bytes\n                        position.set(Position.KEY_FUEL_CONSUMPTION, buf.readUnsignedShort() * 0.01);\n                        buf.readUnsignedShort(); // skip 2 bytes\n                        buf.readUnsignedInt();   // skip 4 bytes\n                        buf.readUnsignedShort(); // skip 2 bytes\n                        position.set(Position.KEY_FUEL_USED, buf.readUnsignedShort() * 0.01);\n                    } else {\n                        buf.skipBytes(length); // Skip if length is not the expected 24\n                    }\n                    break;\n                case 0x94: // VIN\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_VIN, stringValue);\n                    }\n                    break;\n                case 0xA7: // ADC\n                    if (length == 4) {\n                        position.set(Position.PREFIX_ADC + 1, buf.readUnsignedShort());\n                        position.set(Position.PREFIX_ADC + 2, buf.readUnsignedShort());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xAC: // ODOMETER\n                     if (length == 4) {\n                        position.set(Position.KEY_ODOMETER, buf.readUnsignedInt());\n                     } else {\n                        buf.skipBytes(length);\n                     }\n                     break;\n                case 0xBC: // Driver Name\n                     if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(\"driver\", stringValue.trim());\n                     }\n                     break;\n                case 0xBD: // Driver ID\n                     if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_DRIVER_UNIQUE_ID, stringValue);\n                     }\n                     break;\n                case 0xD0: // User Status / Alarm\n                    if (length == 4) {\n                        long userStatus = buf.readUnsignedInt();\n                        if (BitUtil.check(userStatus, 3)) {\n                            position.set(Position.KEY_ALARM, Position.ALARM_VIBRATION);\n                        }\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xD3: // Power/Voltage\n                    if (length == 2) {\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.1);\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xD4: // Battery Level (%)\n                case 0xE1: // Battery Level (%) - also handled in 0xEB->0xE1\n                    if (length == 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xD5: // Lock / Battery Voltage\n                    if (length == 2) {\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.01);\n                    } else if (length > 1) { // Assuming multi-lock structure\n                        int count = buf.readUnsignedByte();\n                        int expectedLength = 1 + count * (5 + 5 + 1 + 2); // 1 byte count + N * (id + card + batt + status)\n                        if (length == expectedLength) {\n                            for (int i = 1; i <= count; i++) {\n                                if (buf.readableBytes() >= 13) {\n                                    position.set(\"lock\" + i + \"Id\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                    position.set(\"lock\" + i + \"Card\", ByteBufUtil.hexDump(buf.readSlice(5)));\n                                    position.set(\"lock\" + i + \"Battery\", buf.readUnsignedByte());\n                                    int status = buf.readUnsignedShort();\n                                    position.set(\"lock\" + i + \"Locked\", !BitUtil.check(status, 5));\n                                } else {\n                                    break; // Not enough data for full lock info\n                                }\n                            }\n                        }\n                        // Skip any remaining bytes within length if format didn't match or buffer ended\n                        buf.readerIndex(endIndex);\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xDA: // Device Status\n                    if (length == 3) {\n                        buf.readUnsignedShort(); // string cut count\n                        int deviceStatus = buf.readUnsignedByte();\n                        position.set(\"string\", BitUtil.check(deviceStatus, 0));\n                        position.set(Position.KEY_MOTION, BitUtil.check(deviceStatus, 2));\n                        position.set(\"cover\", BitUtil.check(deviceStatus, 3));\n                    } else {\n                        buf.skipBytes(length);\n                    }\n                    break;\n                case 0xE6: // Wireless Sensors (Temp/Humidity)\n                    ByteBuf valueE6 = buf.readSlice(length);\n                    while (valueE6.readableBytes() >= 16) { // Need 1(index) + 6(mac) + 4(temp) + 4(hum) + 1(batt)? format unclear\n                        int sensorIndex = valueE6.readUnsignedByte();\n                        valueE6.skipBytes(6); // mac\n                        position.set(Position.PREFIX_TEMP + sensorIndex, decodeCustomDouble(valueE6));\n                        position.set(\"humidity\" + sensorIndex, decodeCustomDouble(valueE6));\n                        // Assuming 1 byte battery level might follow, check documentation\n                        // valueE6.readUnsignedByte();\n                    }\n                    // Ensure main buffer index is correct\n                    buf.readerIndex(endIndex);\n                    break;\n                case 0xEB: // Network Info or Extended TLVs\n                    // Check for MCC style first\n                    if (length > 3 && buf.getUnsignedShort(buf.readerIndex()) > 200) { // Check MCC\n                        Network network = new Network();\n                        int mcc = buf.readUnsignedShort();\n                        int mnc = buf.readUnsignedByte();\n                        int consumed = 3;\n                        while (consumed + 5 <= length && buf.readableBytes() >= 5) { // LAC(2) + CI(2) + RSSI(1) = 5\n                            network.addCellTower(CellTower.from(\n                                    mcc, mnc, buf.readUnsignedShort(), buf.readUnsignedShort(),\n                                    buf.readUnsignedByte()));\n                            consumed += 5;\n                        }\n                        if (!network.getCellTowers().isEmpty()) {\n                             position.setNetwork(network);\n                        }\n                         buf.skipBytes(length - consumed); // Skip remaining bytes within length\n                    } else { // Nested Extended TLVs\n                        ByteBuf valueEB = buf.readSlice(length);\n                        while (valueEB.readableBytes() >= 4) { // Need ExtLen(2) + ExtType(2)\n                            int extendedLength = valueEB.readUnsignedShort(); // Length of following data (Type + Value) ?? Or just value? Docs unclear. Let's assume Type+Value\n                            int extendedType = valueEB.readUnsignedShort();\n                            int dataLength = extendedLength - 2; // Assuming value length\n\n                            if (dataLength < 0 || valueEB.readableBytes() < dataLength) {\n                                break; // Invalid length or not enough data\n                            }\n\n                            switch (extendedType) {\n                                case 0x0001: // fuel1\n                                    if (dataLength == 3) { // short(2) + byte(1)?\n                                        position.set(\"fuel1\", valueEB.readUnsignedShort() * 0.1);\n                                        valueEB.readUnsignedByte(); // unused\n                                    } else { valueEB.skipBytes(dataLength); }\n                                    break;\n                                case 0x0023: // fuel2\n                                     if (dataLength == 6) {\n                                        try {\n                                            position.set(\"fuel2\", Double.parseDouble(\n                                                valueEB.readCharSequence(6, StandardCharsets.US_ASCII).toString()));\n                                        } catch (NumberFormatException e) { /* ignore */ }\n                                     } else { valueEB.skipBytes(dataLength); }\n                                    break;\n                                case 0x00CE: // Power\n                                    if (dataLength == 2) {\n                                        position.set(Position.KEY_POWER, valueEB.readUnsignedShort() * 0.01);\n                                    } else { valueEB.skipBytes(dataLength); }\n                                    break;\n                                case 0x00D8: // Cell Tower (Extended format)\n                                     if (dataLength == 9) { // MCC(2)+MNC(1)+LAC(2)+CID(4) = 9\n                                        Network network = new Network();\n                                        network.addCellTower(CellTower.from(\n                                                valueEB.readUnsignedShort(), valueEB.readUnsignedByte(),\n                                                valueEB.readUnsignedShort(), valueEB.readUnsignedInt()));\n                                        position.setNetwork(network);\n                                     } else { valueEB.skipBytes(dataLength); }\n                                    break;\n                                case 0xE1: // Battery Level (%)\n                                    if (dataLength == 1) {\n                                        position.set(Position.KEY_BATTERY_LEVEL, valueEB.readUnsignedByte());\n                                    } else { valueEB.skipBytes(dataLength); }\n                                    break;\n                                default:\n                                    valueEB.skipBytes(dataLength);\n                                    break;\n                            }\n                        }\n                         // Ensure main buffer index is correct\n                        buf.readerIndex(endIndex);\n                    }\n                    break;\n                case 0xED: // Card Number\n                    if (length > 0) {\n                        stringValue = buf.readCharSequence(length, StandardCharsets.US_ASCII).toString();\n                        position.set(Position.KEY_CARD, stringValue.trim());\n                    }\n                    break;\n                case 0xEE: // Combined Status (RSSI, Power, Battery, Sats)\n                    if (length == 7) { // 1(rssi) + 2(power) + 2(battery) + 1(sats) + 1(gsm status?) - docs unclear\n                        position.set(Position.KEY_RSSI, buf.readUnsignedByte());\n                        position.set(Position.KEY_POWER, buf.readUnsignedShort() * 0.001);\n                        position.set(Position.KEY_BATTERY, buf.readUnsignedShort() * 0.001); // Note: multiplier 0.001\n                        position.set(Position.KEY_SATELLITES, buf.readUnsignedByte());\n                        buf.skipBytes(length - (1 + 2 + 2 + 1)); // Skip any remaining bytes if format varies\n                    } else {\n                         buf.skipBytes(length);\n                    }\n                    break;\n                case 0xF3: // Extended OBD\n                    ByteBuf valueF3 = buf.readSlice(length);\n                    while (valueF3.readableBytes() >= 3) { // Need ExtType(2) + ExtLen(1)\n                        int extendedType = valueF3.readUnsignedShort();\n                        int extendedDataLength = valueF3.readUnsignedByte();\n                         if (valueF3.readableBytes() < extendedDataLength) {\n                             break; // Not enough data for payload\n                         }\n                        switch (extendedType) {\n                            case 0x0002: position.set(Position.KEY_OBD_SPEED, valueF3.readUnsignedShort() * 0.1); break;\n                            case 0x0003: position.set(Position.KEY_RPM, valueF3.readUnsignedShort()); break;\n                            case 0x0004: position.set(Position.KEY_POWER, valueF3.readUnsignedShort() * 0.001); break;\n                            case 0x0005: position.set(Position.KEY_OBD_ODOMETER, valueF3.readUnsignedInt() * 100); break;\n                            case 0x0007: position.set(Position.KEY_FUEL_CONSUMPTION, valueF3.readUnsignedShort() * 0.1); break;\n                            case 0x0008: position.set(Position.KEY_ENGINE_LOAD, valueF3.readUnsignedShort() * 0.1); break;\n                            case 0x0009: position.set(Position.KEY_COOLANT_TEMP, valueF3.readUnsignedShort() - 40); break;\n                            case 0x000B: position.set(\"intakePressure\", valueF3.readUnsignedShort()); break;\n                            case 0x000C: position.set(\"intakeTemp\", valueF3.readUnsignedShort() - 40); break;\n                            case 0x000D: position.set(\"intakeFlow\", valueF3.readUnsignedShort()); break;\n                            case 0x000E: position.set(Position.KEY_THROTTLE, valueF3.readUnsignedShort() * 100 / 255); break; // Check scale factor\n                            case 0x0050: if (extendedDataLength == 17) { position.set(Position.KEY_VIN, valueF3.readSlice(17).toString(StandardCharsets.US_ASCII)); } else { valueF3.skipBytes(extendedDataLength); } break;\n                            case 0x0100: position.set(Position.KEY_ODOMETER_TRIP, valueF3.readUnsignedShort() * 0.1); break;\n                            case 0x0102: position.set(\"tripFuel\", valueF3.readUnsignedShort() * 0.1); break;\n                            case 0x0112: position.set(\"hardAccelerationCount\", valueF3.readUnsignedShort()); break;\n                            case 0x0113: position.set(\"hardDecelerationCount\", valueF3.readUnsignedShort()); break;\n                            case 0x0114: position.set(\"hardCorneringCount\", valueF3.readUnsignedShort()); break;\n                            default: valueF3.skipBytes(extendedDataLength); break;\n                        }\n                         // Ensure we don't read past the declared length for this item\n                        // This check is needed if a case above didn't read exactly extendedDataLength\n                        // if (valueF3.readerIndex() < startIndex_for_item + 2 + 1 + extendedDataLength) {\n                        //      valueF3.readerIndex(startIndex_for_item + 2 + 1 + extendedDataLength);\n                        // }\n                    }\n                    // Ensure main buffer index is correct\n                    buf.readerIndex(endIndex);\n                    break;\n                case 0xFE: // Driving Behavior / Battery Level\n                    if (length == 1) {\n                        position.set(Position.KEY_BATTERY_LEVEL, buf.readUnsignedByte());\n                    } else if (length > 1) {\n                         ByteBuf valueFE = buf.readSlice(length);\n                         if (valueFE.readableBytes() > 0 && valueFE.getByte(valueFE.readerIndex()) == 0x7C) { // Check for marker\n                             valueFE.readUnsignedByte(); // Consume marker\n                             while (valueFE.readableBytes() >= 2) { // Need ExtType(1) + ExtLen(1)\n                                 int extendedType = valueFE.readUnsignedByte();\n                                 int extendedDataLength = valueFE.readUnsignedByte();\n                                 if (valueFE.readableBytes() < extendedDataLength) {\n                                     break;\n                                 }\n                                 switch (extendedType) {\n                                     case 0x01: // Alarms\n                                         if (extendedDataLength == 4) {\n                                             long alarms = valueFE.readUnsignedInt();\n                                             if (BitUtil.check(alarms, 0)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCELERATION); }\n                                             if (BitUtil.check(alarms, 1)) { position.set(Position.KEY_ALARM, Position.ALARM_BRAKING); }\n                                             if (BitUtil.check(alarms, 2)) { position.set(Position.KEY_ALARM, Position.ALARM_CORNERING); }\n                                             if (BitUtil.check(alarms, 3)) { position.set(Position.KEY_ALARM, Position.ALARM_ACCIDENT); }\n                                             if (BitUtil.check(alarms, 4)) { position.set(Position.KEY_ALARM, Position.ALARM_TAMPERING); }\n                                             // Add more alarm checks if needed\n                                         } else { valueFE.skipBytes(extendedDataLength); }\n                                         break;\n                                     default:\n                                         valueFE.skipBytes(extendedDataLength);\n                                         break;\n                                 }\n                             }\n                         }\n                         // Some formats might have battery level after the 7C block or instead of it\n                         if (valueFE.readableBytes() >= 1) {\n                             position.set(Position.KEY_BATTERY_LEVEL, valueFE.readUnsignedByte());\n                         }\n                         // Ensure main buffer index is correct\n                         buf.readerIndex(endIndex);\n                    } else {\n                         // Length is 0 or invalid, skip\n                    }\n                    break;\n                default:\n                    // Skip unknown subtype's data\n                    buf.skipBytes(length);\n                    break;\n            }\n\n            // Ensure reader index is advanced to the end of the TLV's data part\n            // This handles cases where data was skipped or the case logic didn't consume full length.\n            // It prevents infinite loops if length > 0 but case logic fails.\n            if (buf.readerIndex() < endIndex) {\n                buf.readerIndex(endIndex);\n            } else if (buf.readerIndex() > endIndex) {\n                // Log potentially problematic case where readerIndex was advanced too far\n                // LOG.warn(\"Reader index (\" + buf.readerIndex() + \") beyond expected endIndex (\" + endIndex + \") for subtype 0x\" + String.format(\"%02X\", subtype));\n                // Resetting to endIndex might hide the bug but prevent further parsing errors\n                 buf.readerIndex(endIndex);\n            }\n        }\n\n        return position;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}