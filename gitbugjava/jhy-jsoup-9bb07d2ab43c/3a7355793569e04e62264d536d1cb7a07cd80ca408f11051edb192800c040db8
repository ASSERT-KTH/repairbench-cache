{
    "generation": "    protected void replaceChild(Node out, Node in) {\n        // If replacing a node with itself, perform a no-op.\n        // This test (`out == in`) is crucial because the original logic would:\n        // 1. Call `in.parentNode.removeChild(in)`, which is `this.removeChild(out)`. This removes `out` from\n        //    `childNodes`, sets `out.parentNode = null`, and re-indexes subsequent siblings.\n        // 2. Get `out.siblingIndex` (its original index).\n        // 3. Call `ensureChildNodes().set(index, in)`. Since `out` was removed, the node at `index` is now\n        //    `out`'s original next sibling (if any). This sibling gets replaced by `in` (which is `out`) and orphaned\n        //    (its `parentNode` is not cleared). If `out` was the last child, this results in an IndexOutOfBoundsException\n        //    as the list would be too short for `set(index, ...)`.\n        // 4. Set `in.parentNode = this` and `in.siblingIndex = index`.\n        // 5. Set `out.parentNode = null`. Since `out == in`, this nullifies `in.parentNode` which was just set in step 4.\n        // The test case `org.jsoup.nodes.ElementTest.replaceWithSelf` highlights issue (5) leading to `first.nextSibling()` == null.\n        // Issues like orphaning siblings or IndexOutOfBoundsException are also potential outcomes of the original logic for this case.\n        if (out == in) {\n            return;\n        }\n\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in); // Set 'in' at the 'out's position\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null; // 'out' is removed from tree so null its parent\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}