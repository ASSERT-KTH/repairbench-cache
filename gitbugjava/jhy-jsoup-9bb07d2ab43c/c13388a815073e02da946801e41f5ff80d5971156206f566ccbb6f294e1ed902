{
    "generation": "    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode == this); // out must be a child of 'this'\n        Validate.notNull(in);\n\n        final int index = out.siblingIndex; // Capture original index of 'out' BEFORE any potential removal\n\n        // If 'in' is currently attached to a parent, detach it.\n        // This is necessary if 'in' is being moved from another parent,\n        // or if 'in' is another child of 'this' that's being moved to 'out's position.\n        // We specifically skip this removal if 'in' IS 'out' and its parent IS 'this',\n        // because in that case, the node is simply replacing itself, and it should remain in place.\n        if (in.parentNode != null && (in.parentNode != this || in != out)) {\n            in.parentNode.removeChild(in);\n        }\n\n        // Replace 'out' with 'in' in the children list of 'this'.\n        // The 'index' captured earlier is the correct slot.\n        // If in == out, this effectively replaces the node with itself, which is a no-op on the list contents,\n        // but ensures parent/sibling index is correctly set below.\n        ensureChildNodes().set(index, in);\n\n        in.parentNode = this; // Set 'in's parent to 'this'\n        in.setSiblingIndex(index); // Set 'in's sibling index to the position where 'out' was\n\n        // Detach 'out' only if it's a different node than 'in'.\n        // If out == in, 'out' was effectively re-attached to 'this', so its parent should remain 'this'.\n        if (out != in) {\n            out.parentNode = null; // Detach 'out' from its parent\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}