{
    "generation": "    protected void replaceChild(Node out, Node in) {\n        // When replacing a node with itself, the operation should be a no-op\n        // from the perspective of the parent's child list structure.\n        // The original code, when out == in, would:\n        // 1. Remove 'out' from its parent ('this'). This modifies the childNodes list,\n        //    potentially shifting subsequent siblings and changing their indices.\n        //    If 'out' was the only child, childNodes becomes empty.\n        // 2. Get 'out.siblingIndex' (its original index).\n        // 3. Call childNodes.set(originalIndex, out).\n        //    - If childNodes became empty, this causes IndexOutOfBoundsException.\n        //    - If childNodes was shrunk, this overwrites the sibling that shifted\n        //      into 'out's original position.\n        // 4. Finally, set out.parentNode = null, incorrectly detaching the node.\n        // By returning early if out == in, we avoid these issues and ensure that\n        // replacing a node with itself does not alter the document structure.\n        if (out == in) {\n            return;\n        }\n\n        Validate.isTrue(out.parentNode == this);\n        Validate.notNull(in);\n        if (in.parentNode != null)\n            in.parentNode.removeChild(in);\n\n        final int index = out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode = this;\n        in.setSiblingIndex(index);\n        out.parentNode = null;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}