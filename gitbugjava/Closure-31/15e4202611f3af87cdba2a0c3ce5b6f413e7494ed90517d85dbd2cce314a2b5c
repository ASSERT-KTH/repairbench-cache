{
    "generation": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      // This must be done explicitly, because the process depends on\n      // ModuleMetadata to be initialized, which is done later in init()\n      // Note that it is OK to ignore this step if we're not doing any checks,\n      // because the core Compiler is robust to compilations without\n      // dependency management. The catch is that the SourceFile inputs\n      // are not necessarily in the right order, and the TypeRegistry does\n      // not have all the forward declarations it needs. Dependency management\n      // takes care of both of these things.\n      if (options.dependencyOptions.needsManagement() && !options.skipAllPasses) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          // Gathered from sources provided from the module graph. Forward\n          // declare here so that the compiler knows about the type even if the\n          // input is removed.\n          input.getProvides().forEach(getTypeRegistry()::forwardDeclareType);\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n\n      // --- Process File-Level Annotations ---\n      // If the file has @externs or @nocompile, these annotations should\n      // override the default assumptions. Do this even if dependency\n      // management is off. This needs to happen before\n      // `rebuildInputsFromModules` because it might change the results of that.\n      // It also needs to happen early, so that the AST is available for any\n      // checks that need it.\n      if (!options.skipAllPasses) {\n        for (CompilerInput input : inputs) {\n          Node n = input.getAstRoot(this);\n\n          // Inputs can have a null AST during initial parse.\n          if (n == null) {\n            continue;\n          }\n\n          if (n.getJSDocInfo() != null) {\n            JSDocInfo info = n.getJSDocInfo();\n            if (info.isExterns()) {\n              // If the input file is explicitly marked as an externs file, then\n              // assume the programmer made a mistake and throw it into\n              // the externs pile anyways.\n              externsRoot.addChildToBack(n);\n              input.setIsExtern(true);\n\n              if (input.getModule() != null) {\n                input.getModule().remove(input);\n              }\n\n              externs.add(input);\n              staleInputs = true;\n            } else if (info.isNoCompile()) {\n              if (input.getModule() != null) {\n                input.getModule().remove(input);\n              }\n              staleInputs = true;\n            }\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}