{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int initialReaderIndex = buf.readerIndex();\n\n        // Step 1: Find the opening bracket '['\n        // Skip any leading bytes that are not '[' (considered garbage or incomplete header)\n        int frameStartIndex = -1;\n        for (int i = initialReaderIndex; i < buf.writerIndex(); i++) {\n            if (buf.getByte(i) == '[') {\n                frameStartIndex = i;\n                break;\n            }\n            // Discard this byte as it's not the start of a frame\n            buf.readByte();\n            initialReaderIndex = buf.readerIndex(); // Update initialReaderIndex to reflect discarded bytes\n        }\n\n        if (frameStartIndex == -1) {\n            // No opening bracket '[' found in the current buffer, or all leading bytes were discarded.\n            // Wait for more data.\n            return null;\n        }\n\n        // At this point, buf.readerIndex() is at frameStartIndex (the '[' character).\n        // Now, scan from this point to find the *first unescaped* closing bracket ']'.\n        int currentScanIndex = buf.readerIndex();\n        int frameEndByteIndex = -1; // This will be the index of the closing ']' character\n\n        while (currentScanIndex < buf.writerIndex()) {\n            byte currentByte = buf.getByte(currentScanIndex);\n\n            if (currentByte == '}') {\n                // Potential escape sequence, check the next byte\n                if (currentScanIndex + 1 < buf.writerIndex()) {\n                    byte nextByte = buf.getByte(currentScanIndex + 1);\n                    if (nextByte >= 0x01 && nextByte <= 0x05) {\n                        // This is an escaped character. Skip both bytes.\n                        currentScanIndex++; // Increment to skip the escaped byte\n                    }\n                    // else: it's a literal '}' not followed by an escape code, just advance currentScanIndex normally\n                }\n                // else: '}' is the last byte in the buffer, not part of an escape sequence, treat as literal '}'\n            } else if (currentByte == ']') {\n                // Found an unescaped ']' - this marks the end of the current frame.\n                frameEndByteIndex = currentScanIndex;\n                break; // Found the end of the frame\n            }\n            currentScanIndex++;\n        }\n\n        if (frameEndByteIndex == -1) {\n            // No complete frame (no unescaped ']') found after the opening '['.\n            // Revert readerIndex to its state before processing this potential frame (after discarding garbage).\n            // This is effectively handled by not advancing readerIndex beyond frameStartIndex until a full frame is found.\n            // So, just return null and wait for more data.\n            return null;\n        }\n\n        // A complete frame is found from buf.readerIndex() (which is frameStartIndex)\n        // up to frameEndByteIndex (the closing ']').\n        // The length of the frame including '[' and ']' is `frameEndByteIndex - buf.readerIndex() + 1`.\n        int frameLength = frameEndByteIndex - buf.readerIndex() + 1;\n\n        // Create a new buffer to hold the decoded frame.\n        ByteBuf frame = Unpooled.buffer(frameLength); // Pre-allocate size for efficiency\n\n        // Now, read the bytes from the original buffer and apply the unescaping logic.\n        // The loop reads exactly `frameLength` bytes from `buf`.\n        int bytesToRead = frameLength;\n        while (bytesToRead > 0) {\n            byte b1 = buf.readByte(); // Read byte from input buffer, advances its readerIndex\n            bytesToRead--;\n\n            if (b1 == '}') {\n                // Check if there's a next byte available within the current frame's boundaries for an escape sequence\n                if (bytesToRead > 0) {\n                    byte b2 = buf.readByte(); // Read the next byte for escape sequence\n                    bytesToRead--;\n                    switch (b2) {\n                        case 0x01:\n                            frame.writeByte('}');\n                            break;\n                        case 0x02:\n                            frame.writeByte('[');\n                            break;\n                        case 0x03:\n                            frame.writeByte(']');\n                            break;\n                        case 0x04:\n                            frame.writeByte(',');\n                            break;\n                        case 0x05:\n                            frame.writeByte('*');\n                            break;\n                        default:\n                            // This indicates an invalid escape sequence. Throw an exception.\n                            // The original code had a similar default behavior.\n                            throw new IllegalArgumentException(String.format(\n                                    \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                    }\n                } else {\n                    // '}' is the last byte within the frame, and not part of a full escape sequence.\n                    // Treat it as a literal '}'.\n                    frame.writeByte(b1);\n                }\n            } else {\n                frame.writeByte(b1);\n            }\n        }\n        \n        // Return the successfully decoded frame.\n        return frame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}