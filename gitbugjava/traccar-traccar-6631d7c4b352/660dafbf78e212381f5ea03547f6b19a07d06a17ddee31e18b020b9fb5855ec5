{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // Find the start '[' bracket, beginning from the current reader index.\n        int startIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '[');\n        if (startIndex == -1) {\n            // No start bracket found in the readable bytes. Wait for more data.\n            return null;\n        }\n\n        // Discard any bytes before the start bracket '['.\n        // This handles potential garbage data between frames or at the beginning.\n        buf.readerIndex(startIndex);\n\n        // Find the end ']' bracket, searching after the start bracket.\n        // Need readerIndex + 1 because the frame must contain at least '[]'.\n        int endIndex = buf.indexOf(buf.readerIndex() + 1, buf.writerIndex(), (byte) ']');\n        if (endIndex == -1) {\n            // Found '[' but not the corresponding ']'. Frame is incomplete. Wait for more data.\n            return null;\n        }\n\n        // We have identified a complete frame from readerIndex (at '[') to endIndex (at ']').\n        int frameLength = endIndex - buf.readerIndex() + 1;\n        // Allocate buffer for the decoded frame (estimate initial capacity).\n        // Using Unpooled as in the original code. ctx.alloc() might be preferable if ctx is always available.\n        ByteBuf frame = Unpooled.buffer(frameLength);\n\n        // Read and write the opening bracket '['. This also advances the reader index.\n        frame.writeByte(buf.readByte());\n\n        // Process the content bytes between '[' and ']'.\n        while (buf.readerIndex() < endIndex) {\n            byte b1 = buf.readByte();\n            if (b1 == '}') { // Check for escape character\n                // Ensure there's a byte following '}' before the end ']'\n                if (buf.readerIndex() >= endIndex) {\n                    frame.release(); // Release partially built frame\n                    // Skip the corrupted frame by advancing reader index past ']'\n                    buf.readerIndex(endIndex + 1);\n                    // Use CorruptedFrameException for framing errors\n                    throw new io.netty.handler.codec.CorruptedFrameException(\n                            \"Malformed frame: escape character '}' found immediately before closing bracket ']'\");\n                }\n                byte b2 = buf.readByte(); // Read the byte being escaped\n                switch (b2) {\n                    case 0x01:\n                        frame.writeByte('}'); // 7d 01 -> 7d\n                        break;\n                    case 0x02:\n                        frame.writeByte('['); // 7d 02 -> 5b\n                        break;\n                    case 0x03:\n                        frame.writeByte(']'); // 7d 03 -> 5d\n                        break;\n                    case 0x04:\n                        frame.writeByte(','); // 7d 04 -> 2c\n                        break;\n                    case 0x05:\n                        frame.writeByte('*'); // 7d 05 -> 2a\n                        break;\n                    default:\n                        // Invalid byte sequence after escape character.\n                        frame.release(); // Release partially built frame\n                        // Skip the corrupted frame by advancing reader index past ']'\n                        buf.readerIndex(endIndex + 1);\n                        // Using IllegalArgumentException as in the original code for invalid content\n                        throw new IllegalArgumentException(String.format(\n                                \"Unexpected byte after escape character '}' at index %d: 0x%02x\",\n                                buf.readerIndex() - 1, b2));\n                }\n            } else {\n                // Normal byte, just copy it.\n                frame.writeByte(b1);\n            }\n        }\n\n        // Read and write the closing bracket ']'.\n        // At this point, readerIndex should be exactly endIndex.\n        frame.writeByte(buf.readByte()); // This reads the byte at endIndex\n\n        // The readerIndex of 'buf' is now at endIndex + 1, correctly positioned after the consumed frame.\n        return frame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}