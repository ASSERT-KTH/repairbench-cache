{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // Find the end of the first frame ('[...]' structure)\n        int endIndex = -1;\n        for (int i = buf.readerIndex(); i < buf.writerIndex(); i++) {\n            // Need to handle potential escape sequence for ']' which is 0x7d 0x03\n            if (buf.getByte(i) == ']') {\n                 // Check if this ']' is preceded by '}' (0x7d)\n                 if (i > buf.readerIndex() && buf.getByte(i - 1) == '}') {\n                     // If preceded by '}', check if the byte before '}' is part of a valid escape for ']'\n                     // However, the escape sequence is \"}0x03\" -> \"]\". A standalone ']' marks the end.\n                     // The original code searches for ']' directly. Let's stick to that simple frame boundary.\n                     // If ']' could be escaped, the framing logic would be more complex.\n                     // Assuming ']' always marks the end of a frame.\n                 }\n                 endIndex = i; // Found the index of the ']'\n                 break;\n            }\n        }\n\n        // If no ']' is found, the frame is incomplete\n        if (endIndex == -1) {\n            return null;\n        }\n\n        // We found a frame boundary. Calculate length and slice the buffer.\n        int frameLength = endIndex - buf.readerIndex() + 1;\n        ByteBuf frameData = buf.readSlice(frameLength); // Read frame bytes and advance readerIndex in buf\n\n        // Prepare buffer for the unescaped frame content\n        ByteBuf frame = Unpooled.buffer(frameLength); // Estimate capacity\n\n        // Process the sliced frame data, handling escapes\n        while (frameData.isReadable()) {\n            byte b1 = frameData.readByte();\n            if (b1 == '}') {\n                // Check if there's a next byte available for the escape code\n                if (!frameData.isReadable()) {\n                    // Malformed frame: '}' at the very end.\n                    // Calculate original position for error message\n                    int originalErrorPos = buf.readerIndex() - frameLength + (frameData.readerIndex() - 1);\n                    throw new IllegalArgumentException(String.format(\n                            \"incomplete escape sequence at end of frame: %d\", originalErrorPos));\n                }\n                byte b2 = frameData.readByte();\n                switch (b2) {\n                    case 0x01:\n                        frame.writeByte('}');\n                        break;\n                    case 0x02:\n                        frame.writeByte('[');\n                        break;\n                    case 0x03:\n                        frame.writeByte(']');\n                        break;\n                    case 0x04:\n                        frame.writeByte(',');\n                        break;\n                    case 0x05:\n                        frame.writeByte('*');\n                        break;\n                    default:\n                        // Calculate original position for error message\n                        int originalErrorPos = buf.readerIndex() - frameLength + (frameData.readerIndex() - 1);\n                        throw new IllegalArgumentException(String.format(\n                                \"unexpected escape byte at %d: 0x%02x\", originalErrorPos, b2));\n                }\n            } else {\n                frame.writeByte(b1);\n            }\n        }\n\n        return frame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}