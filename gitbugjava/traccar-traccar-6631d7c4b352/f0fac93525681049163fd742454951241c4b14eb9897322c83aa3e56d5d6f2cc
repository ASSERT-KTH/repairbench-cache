{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // Find '[' marking the start of a frame\n        // Use ByteBuf.indexOf(int fromIndex, int toIndex, byte value)\n        int startIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '[');\n        if (startIndex == -1) {\n            // No start bracket found in the readable bytes\n            return null;\n        }\n\n        // Discard any data before the start bracket, if any.\n        // This handles cases where noise might precede a valid frame.\n        // Note: This assumes frames are independent and data before '[' can be ignored.\n        buf.readerIndex(startIndex);\n\n        // Find ']' marking the end of the frame, searching strictly after '['\n        // Use ByteBuf.indexOf(int fromIndex, int toIndex, byte value)\n        int endIndexBracket = buf.indexOf(buf.readerIndex() + 1, buf.writerIndex(), (byte) ']');\n        if (endIndexBracket == -1) {\n            // Found '[' but no corresponding ']', frame is incomplete\n            // Need more data, so return null. ByteToMessageDecoder framework will recall decode when more data arrives.\n            return null;\n        }\n\n        // Calculate the full frame length including delimiters '[' and ']'\n        int frameLength = endIndexBracket - buf.readerIndex() + 1;\n\n        // Extract the complete frame bytes (including '[' and ']') into a new slice.\n        // readSlice advances the reader index of the original buffer 'buf' past this frame.\n        ByteBuf frameData = buf.readSlice(frameLength);\n\n        // Process the extracted frame slice for escape sequences.\n        // Allocate a new buffer for the decoded frame. Initial capacity can be frameLength,\n        // as escapes might slightly change the size but it's a good estimate.\n        ByteBuf decodedFrame = Unpooled.buffer(frameLength);\n        try {\n            while (frameData.isReadable()) {\n                byte b1 = frameData.readByte();\n                // Check for the escape character '}' followed by another byte within the slice\n                if (b1 == '}' && frameData.isReadable()) {\n                    byte b2 = frameData.readByte(); // Read the byte defining the escaped character\n                    switch (b2) {\n                        case 0x01:\n                            decodedFrame.writeByte('}'); // 7d 01 -> 7d\n                            break;\n                        case 0x02:\n                            decodedFrame.writeByte('['); // 7d 02 -> 5b\n                            break;\n                        case 0x03:\n                            decodedFrame.writeByte(']'); // 7d 03 -> 5d\n                            break;\n                        case 0x04:\n                            decodedFrame.writeByte(','); // 7d 04 -> 2c\n                            break;\n                        case 0x05:\n                            decodedFrame.writeByte('*'); // 7d 05 -> 2a\n                            break;\n                        default:\n                            // Encountered an invalid byte following the escape character '}'\n                            // Release the buffer we allocated before throwing.\n                            decodedFrame.release();\n                            // frameData is a slice, managed by buf usually, no explicit release needed normally.\n                            throw new IllegalArgumentException(String.format(\n                                    \"unexpected byte following escape character '}' at index %d: 0x%02x\",\n                                    buf.readerIndex() - frameLength + frameData.readerIndex() - 1, // Calculate approx original index\n                                    b2));\n                    }\n                } else {\n                    // This is a regular byte, or it's a '}' at the very end of the frame data\n                    // (just before the implicit final ']' which is included in frameData).\n                    // Or '}' appeared but there was no following byte (incomplete escape at end).\n                    // In these cases, write the byte as is, consistent with original logic's handling of non-escaped bytes.\n                    decodedFrame.writeByte(b1);\n                }\n            }\n        } catch (Exception e) {\n            // Ensure allocated buffer is released if any exception occurs during processing\n            if (decodedFrame.refCnt() > 0) {\n                decodedFrame.release();\n            }\n            throw e; // Re-throw the exception\n        }\n\n        // Return the buffer containing the processed frame (with escapes resolved).\n        // The caller (Netty pipeline/ByteToMessageDecoder framework) is responsible for releasing this buffer later.\n        return decodedFrame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}