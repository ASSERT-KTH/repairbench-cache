{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int readerIndex = buf.readerIndex();\n        int writerIndex = buf.writerIndex();\n\n        // 1. Find the first '[' character from the current readerIndex\n        int startIndex = -1;\n        for (int i = readerIndex; i < writerIndex; i++) {\n            if (buf.getByte(i) == '[') {\n                startIndex = i;\n                break;\n            }\n        }\n\n        if (startIndex == -1) {\n            // No '[' found in the buffer. Consume all current bytes as they don't form a frame start.\n            buf.readerIndex(writerIndex);\n            return null;\n        }\n\n        // If there's garbage before the first '[', consume it.\n        if (startIndex > readerIndex) {\n            buf.skipBytes(startIndex - readerIndex);\n            readerIndex = startIndex; // Update readerIndex to the start of the frame\n        }\n\n        // 2. Find the first ']' character after startIndex.\n        // The protocol's escape sequences (e.g., '}' + 0x03 for an escaped ']')\n        // mean that we are looking for the literal ']' (0x5d) as the frame delimiter.\n        // The inner loop handles escaping, so here we just need to find the literal ']' after the opening '['.\n        int endIndex = -1; // This will be the index of the closing ']'\n        for (int i = startIndex + 1; i < writerIndex; i++) {\n            if (buf.getByte(i) == ']') {\n                endIndex = i;\n                break;\n            }\n        }\n\n        if (endIndex == -1) {\n            // No closing ']' found for the current frame. Wait for more data.\n            return null;\n        }\n\n        // We have found '[' at `startIndex` and ']' at `endIndex`.\n        // The total length of the raw frame in the buffer (including brackets) is:\n        int frameTotalLength = endIndex - startIndex + 1;\n\n        // Ensure there is enough data for the full frame.\n        if (writerIndex - buf.readerIndex() < frameTotalLength) {\n            return null; // Not enough data for the complete frame\n        }\n\n        // Mark the reader index before parsing, in case of errors, so we can reset.\n        buf.markReaderIndex();\n\n        ByteBuf frame = Unpooled.buffer();\n        try {\n            // The `readLimit` is the index *after* the closing ']' byte.\n            int readLimit = endIndex + 1;\n\n            // Read bytes from the buffer, applying unescaping, until the end of the frame.\n            while (buf.readerIndex() < readLimit) {\n                byte b1 = buf.readByte();\n                if (b1 == '}') {\n                    // This is an escape sequence. Ensure there's a subsequent byte.\n                    if (buf.readerIndex() >= readLimit) {\n                        // The '}' is the last byte of the frame, but no control byte followed.\n                        // This indicates a malformed frame.\n                        throw new IllegalArgumentException(\"Incomplete escape sequence at end of frame\");\n                    }\n                    byte b2 = buf.readByte();\n                    switch (b2) {\n                        case 0x01:\n                            frame.writeByte('}');\n                            break;\n                        case 0x02:\n                            frame.writeByte('[');\n                            break;\n                        case 0x03:\n                            frame.writeByte(']');\n                            break;\n                        case 0x04:\n                            frame.writeByte(',');\n                            break;\n                        case 0x05:\n                            frame.writeByte('*');\n                            break;\n                        default:\n                            throw new IllegalArgumentException(String.format(\n                                    \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                    }\n                } else {\n                    frame.writeByte(b1);\n                }\n            }\n            return frame; // Return the successfully decoded frame\n        } catch (Exception e) {\n            // If an error occurs during parsing (e.g., unexpected byte), reset reader index\n            // so the problematic data can be re-processed or handled externally.\n            buf.resetReaderIndex();\n            throw e;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}