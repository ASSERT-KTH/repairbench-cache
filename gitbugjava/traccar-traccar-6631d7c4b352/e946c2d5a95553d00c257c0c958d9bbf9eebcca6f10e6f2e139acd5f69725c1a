{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int readerIndex = buf.readerIndex();\n        int writerIndex = buf.writerIndex();\n\n        // Search for the first unescaped ']'\n        int frameEndByteIndex = -1;\n        for (int i = readerIndex; i < writerIndex; i++) {\n            byte currentByte = buf.getByte(i);\n            if (currentByte == '}') {\n                // Check if this is an escape sequence\n                if (i + 1 < writerIndex) {\n                    byte nextByte = buf.getByte(i + 1);\n                    if (nextByte >= 0x01 && nextByte <= 0x05) {\n                        // This is a recognized escape sequence, skip both bytes for the delimiter search\n                        i++; // Skip the next byte as well\n                        continue; // Continue searching for ']'\n                    }\n                }\n                // If '}' is not part of a recognized escape sequence, or is the last byte,\n                // it's treated as a literal byte and cannot be a frame delimiter.\n                // Continue scanning.\n            } else if (currentByte == ']') {\n                // Found an unescaped ']' which marks the end of the current frame\n                frameEndByteIndex = i;\n                break;\n            }\n        }\n\n        if (frameEndByteIndex == -1) {\n            // No complete frame found yet, wait for more data\n            return null;\n        }\n\n        // The frame ends at frameEndByteIndex (inclusive ']')\n        // The total length of the frame is (frameEndByteIndex - readerIndex + 1)\n        int endIndex = frameEndByteIndex + 1;\n\n        // Now, extract the frame content and handle escaping\n        ByteBuf frame = Unpooled.buffer();\n        while (buf.readerIndex() < endIndex) {\n            byte b1 = buf.readByte();\n            if (b1 == '}') {\n                // Check if there's a next byte for the escape sequence within the frame boundary.\n                // Also, ensure it's a recognized escape code.\n                if (buf.readerIndex() < endIndex) {\n                    byte b2 = buf.readByte();\n                    switch (b2) {\n                        case 0x01:\n                            frame.writeByte('}');\n                            break;\n                        case 0x02:\n                            frame.writeByte('[');\n                            break;\n                        case 0x03:\n                            frame.writeByte(']');\n                            break;\n                        case 0x04:\n                            frame.writeByte(',');\n                            break;\n                        case 0x05:\n                            frame.writeByte('*');\n                            break;\n                        default:\n                            // If b2 is not a recognized escape code, write both b1 ('}') and b2 literally\n                            frame.writeByte(b1);\n                            frame.writeByte(b2);\n                            break;\n                    }\n                } else {\n                    // This scenario means '}' was the last byte in the frame,\n                    // implying a truncated escape sequence or a literal '}' at the end.\n                    // Based on test cases, treat it as a literal '}'.\n                    frame.writeByte(b1);\n                }\n            } else {\n                // Not '}', just write the byte literally\n                frame.writeByte(b1);\n            }\n        }\n\n        // Return the decoded frame. The buf.readerIndex() has been advanced\n        // to point past the end of the returned frame.\n        return frame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}