{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int initialReaderIndex = buf.readerIndex();\n        int frameEndAbsoluteIndex = -1; // This will be the absolute index of the ']' character\n        boolean escaped = false;\n\n        // Search for the *first* unescaped ']' from the current readerIndex\n        for (int i = initialReaderIndex; i < buf.writerIndex(); i++) {\n            byte currentByte = buf.getByte(i);\n            if (escaped) {\n                // This byte is part of an escape sequence, not a delimiter\n                escaped = false;\n                continue;\n            }\n            if (currentByte == '}') {\n                // Ensure there is a byte following '}' for the escape sequence itself\n                if (i + 1 >= buf.writerIndex()) {\n                    // Not enough data for a complete escape sequence at the end of the buffer.\n                    // This frame is incomplete, so we need to wait for more data.\n                    buf.readerIndex(initialReaderIndex); // Reset reader index as nothing was consumed\n                    return null;\n                }\n                escaped = true;\n            } else if (currentByte == ']') {\n                frameEndAbsoluteIndex = i;\n                break;\n            }\n        }\n\n        // If no complete frame (no unescaped ']') is found, return null.\n        // This tells the decoder to wait for more data.\n        if (frameEndAbsoluteIndex == -1) {\n            return null;\n        }\n\n        // At this point, `frameEndAbsoluteIndex` holds the absolute index of the *first* ']' character.\n        // The `targetEndIndex` defines the point *after* the frame has been fully read.\n        int targetEndIndex = frameEndAbsoluteIndex + 1;\n\n        // Pre-allocate buffer with the exact size of the raw frame data for efficiency.\n        ByteBuf frame = Unpooled.buffer(targetEndIndex - initialReaderIndex);\n\n        // Read bytes and decode escape sequences only up to the determined frame end.\n        while (buf.readerIndex() < targetEndIndex) {\n            byte b1 = buf.readByte(); // This advances buf.readerIndex()\n            if (b1 == '}') {\n                // The byte following '}' must be within the frame boundaries.\n                // If this condition is met, it indicates an incomplete escape sequence at the very end of the frame,\n                // which signifies a malformed frame according to the protocol.\n                if (buf.readerIndex() >= targetEndIndex) {\n                    throw new IllegalArgumentException(\"Incomplete escape sequence at end of frame at index: \" + (buf.readerIndex() - 1));\n                }\n                byte b2 = buf.readByte(); // This advances buf.readerIndex()\n                switch (b2) {\n                    case 0x01:\n                        frame.writeByte('}');\n                        break;\n                    case 0x02:\n                        frame.writeByte('[');\n                        break;\n                    case 0x03:\n                        frame.writeByte(']');\n                        break;\n                    case 0x04:\n                        frame.writeByte(',');\n                        break;\n                    case 0x05:\n                        frame.writeByte('*');\n                        break;\n                    default:\n                        throw new IllegalArgumentException(String.format(\n                                \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                }\n            } else {\n                frame.writeByte(b1);\n            }\n        }\n        return frame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}