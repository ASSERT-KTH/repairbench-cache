{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // Find the index of the first closing bracket ']' from the current reader index\n        int endIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) ']');\n\n        // If no ']' is found, the frame is incomplete, wait for more data\n        if (endIndex == -1) {\n            return null;\n        }\n\n        // Check if the potential frame starts with '[' at the current reader index.\n        // If not, it indicates corruption or misalignment.\n        if (buf.getByte(buf.readerIndex()) != '[') {\n            // Consider how to handle this - throwing an exception is usually safest\n            // to signal a protocol error rather than potentially skipping valid data\n            // or getting stuck on malformed data.\n            throw new IllegalArgumentException(\n                \"Invalid frame: does not start with '[' at reader index \" + buf.readerIndex());\n        }\n\n        // We have a complete frame identified from readerIndex to endIndex (inclusive).\n        // Create a buffer for the decoded frame content.\n        // Initial capacity estimation: frame length, may shrink due to unescaping.\n        ByteBuf frame = Unpooled.buffer(endIndex - buf.readerIndex() + 1);\n\n        try {\n            // Process bytes from readerIndex up to and including endIndex\n            while (buf.readerIndex() <= endIndex) {\n                byte b1 = buf.readByte();\n                if (b1 == '}') {\n                    // Found an escape character '}'. Check if the next byte exists within the frame.\n                    if (buf.readerIndex() > endIndex) {\n                        // Malformed: '}' is the last byte before expected ']'\n                        frame.release(); // Release allocated buffer\n                        throw new IllegalArgumentException(String.format(\n                                \"Incomplete escape sequence at index %d (frame end)\", buf.readerIndex() - 1));\n                    }\n                    byte b2 = buf.readByte(); // Read the byte following '}'\n                    switch (b2) {\n                        case 0x01:\n                            frame.writeByte('}');\n                            break;\n                        case 0x02:\n                            frame.writeByte('[');\n                            break;\n                        case 0x03:\n                            frame.writeByte(']');\n                            break;\n                        case 0x04:\n                            frame.writeByte(',');\n                            break;\n                        case 0x05:\n                            frame.writeByte('*');\n                            break;\n                        default:\n                            // Unknown byte follows escape character '}'\n                            frame.release(); // Release allocated buffer\n                            throw new IllegalArgumentException(String.format(\n                                    \"Unexpected escape byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                    }\n                } else {\n                    // Regular byte, not part of an escape sequence, write it directly.\n                    frame.writeByte(b1);\n                }\n            }\n            // The loop finishes when readerIndex passes endIndex (i.e., after reading ']').\n            // Return the fully decoded frame. Netty will pass it down the pipeline.\n            // The input buffer 'buf' readerIndex is now positioned after the consumed frame.\n            return frame;\n        } catch (Exception e) {\n            // If any exception occurs during processing (e.g., IllegalArgumentException),\n            // ensure the allocated 'frame' buffer is released before propagating the exception.\n            frame.release();\n            throw e;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}