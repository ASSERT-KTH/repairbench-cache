{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int endIndex = -1;\n        // Iterate from the current reader index to the writer index to find the first ']'\n        for (int i = buf.readerIndex(); i < buf.writerIndex(); i++) {\n            if (buf.getByte(i) == ']') {\n                endIndex = i + 1; // endIndex is the position *after* ']'\n                break;\n            }\n        }\n\n        if (endIndex > 0) { // If ']' was found, endIndex will be at least readerIndex + 1, so > 0.\n                            // If not found, endIndex remains -1.\n            ByteBuf frame = Unpooled.buffer();\n            // Process bytes up to the found endIndex\n            while (buf.readerIndex() < endIndex) {\n                byte b1 = buf.readByte();\n                if (b1 == '}') {\n                    // Check if there's another byte available for the escape sequence within the frame\n                    if (buf.readerIndex() < endIndex) {\n                        byte b2 = buf.readByte();\n                        switch (b2) {\n                            case 0x01:\n                                frame.writeByte('}');\n                                break;\n                            case 0x02:\n                                frame.writeByte('[');\n                                break;\n                            case 0x03:\n                                frame.writeByte(']');\n                                break;\n                            case 0x04:\n                                frame.writeByte(',');\n                                break;\n                            case 0x05:\n                                frame.writeByte('*');\n                                break;\n                            default:\n                                // If the byte after '}' is not a valid escape code, it's a protocol error\n                                throw new IllegalArgumentException(String.format(\n                                        \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                        }\n                    } else {\n                        // This case implies '}' was the last character in the segment defined by endIndex,\n                        // meaning an escape sequence started but was not completed before endIndex.\n                        // E.g., if the frame data was just \"{\" and endIndex was immediately after it.\n                        // This would typically indicate a malformed frame or an issue with endIndex calculation\n                        // if '}' could be a valid last character without being part of an escape sequence.\n                        // Given that endIndex is indexOf(']') + 1, this path means '}' was effectively ']',\n                        // which is not possible since '}' (0x7D) != ']' (0x5D).\n                        // Or, if frame is like \"[...{]\" and ']' is the terminator. b1='{', then b2 would be ']'.\n                        // The `if (buf.readerIndex() < endIndex)` for reading b2 should handle this by allowing\n                        // b2 to be read if it's before or at the final ']' character.\n                        // The current logic means if `}` is read and it's the last byte before `endIndex`\n                        // (i.e., `buf.readerIndex()` becomes `endIndex` after reading `b1`),\n                        // then `b1` (the `}`) is effectively dropped, and the loop terminates.\n                        // This should not happen if `endIndex` is correctly `indexOf(']') + 1` because there\n                        // would always be at least the `]` character for `b2` if `b1 = '}'` was immediately before `]`.\n                        // If `b1 = '}'` and `b2 = ']`, the default switch case handles it (throws exception).\n                        // So, this `else` branch is unlikely to be hit meaningfully for valid frame structures.\n                        // If it were hit, it implies an unterminated escape sequence at the very end of the frame part,\n                        // and the '{' would be lost. However, the design seems to expect '}' to always be followed by an escape char.\n                        // No change needed here as the primary bug is framing.\n                    }\n                } else {\n                    frame.writeByte(b1);\n                }\n            }\n            return frame;\n        }\n\n        return null; // No complete frame found (no ']' or not enough data)\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}