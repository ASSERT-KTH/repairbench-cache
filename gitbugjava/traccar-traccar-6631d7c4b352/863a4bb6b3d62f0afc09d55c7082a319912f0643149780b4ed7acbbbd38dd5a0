{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // Find the start delimiter '[' from the current reader index\n        int startIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), '[');\n\n        if (startIndex == -1) {\n            // No start delimiter found in the current buffer.\n            // No frame can be decoded yet. Do not modify readerIndex, wait for more data.\n            return null;\n        }\n\n        // If the start delimiter is not at the current reader index,\n        // it means there might be leading garbage. Discard it by advancing readerIndex.\n        // This ensures we always start looking for a frame from a '['.\n        if (startIndex > buf.readerIndex()) {\n            buf.readerIndex(startIndex);\n        }\n\n        // Now, find the end delimiter ']' for the current frame,\n        // starting the search from the identified 'startIndex' (which is now buf.readerIndex()).\n        int rawEndIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), ']');\n\n        if (rawEndIndex == -1) {\n            // No end delimiter found. The frame is incomplete.\n            // Do not modify readerIndex, wait for more data.\n            return null;\n        }\n\n        // The 'frameEndIndex' is the exclusive end position in the input buffer for the current frame.\n        // It includes the ']' character itself, so we add 1 to its index.\n        int frameEndIndex = rawEndIndex + 1;\n\n        // Allocate a new buffer for the decoded frame.\n        // Approximate initial capacity for efficiency.\n        ByteBuf frame = Unpooled.buffer(frameEndIndex - buf.readerIndex());\n        \n        // Read bytes from the input buffer up to the identified frame's end\n        while (buf.readerIndex() < frameEndIndex) {\n            byte b1 = buf.readByte(); // Read a byte and advance input buffer's readerIndex\n            if (b1 == '}') {\n                // Handle escaped characters\n                // Ensure there's a subsequent byte for the escape sequence\n                if (buf.readerIndex() >= frameEndIndex) {\n                    // This means '}' was the last byte in the frame, but it was an escape character\n                    // requiring a follow-up byte, indicating a malformed frame.\n                    throw new IllegalArgumentException(String.format(\n                            \"malformed frame: incomplete escape sequence at end of frame before index %d\",\n                            buf.readerIndex() - 1)); // -1 because b1 was just read\n                }\n                byte b2 = buf.readByte(); // Read the escaped byte and advance input buffer's readerIndex\n                switch (b2) {\n                    case 0x01:\n                        frame.writeByte('}');\n                        break;\n                    case 0x02:\n                        frame.writeByte('[');\n                        break;\n                    case 0x03:\n                        frame.writeByte(']');\n                        break;\n                    case 0x04:\n                        frame.writeByte(',');\n                        break;\n                    case 0x05:\n                        frame.writeByte('*');\n                        break;\n                    default:\n                        // Unexpected byte after escape character.\n                        // buf.readerIndex() - 1 points to the position of b2 in the original buffer.\n                        throw new IllegalArgumentException(String.format(\n                                \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                }\n            } else {\n                // Not an escape character, just copy the byte to the frame.\n                frame.writeByte(b1);\n            }\n        }\n        // Return the successfully decoded frame.\n        // The buf.readerIndex() is now correctly positioned at frameEndIndex,\n        // ready for the next call to decode.\n        return frame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}