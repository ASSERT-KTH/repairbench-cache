{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // 1. Find the start index '[' at or after the current reader index\n        int startIndex = -1;\n        for (int i = buf.readerIndex(); i < buf.writerIndex(); i++) {\n            if (buf.getByte(i) == '[') {\n                startIndex = i;\n                break;\n            }\n        }\n\n        // 2. If '[' not found, we need more data or the start marker is missing\n        if (startIndex == -1) {\n            return null; // Wait for '['\n        }\n\n        // 3. Discard any bytes before the frame start marker '['\n        buf.readerIndex(startIndex);\n\n        // 4. Find the end index ']' starting *after* the '['\n        int endIndex = -1;\n        // Start searching from the byte *after* '[' (startIndex + 1)\n        for (int i = startIndex + 1; i < buf.writerIndex(); i++) {\n            if (buf.getByte(i) == ']') {\n                endIndex = i;\n                break;\n            }\n        }\n\n        // 5. If ']' not found, the complete frame hasn't arrived yet\n        if (endIndex == -1) {\n            // Reset reader index to the start of the potential frame ('[')\n            // because we haven't consumed it yet. Netty will call decode again later.\n            buf.readerIndex(startIndex);\n            return null; // Wait for ']'\n        }\n\n        // 6. Calculate frame length and extract the frame slice\n        // The frame includes both '[' at startIndex and ']' at endIndex\n        int frameLength = endIndex - startIndex + 1;\n        // Use readSlice which advances the reader index of the input buffer 'buf'\n        ByteBuf rawFrame = buf.readSlice(frameLength);\n\n        // 7. Create the result buffer with an estimated capacity\n        ByteBuf resultFrame = Unpooled.buffer(frameLength);\n\n        // 8. Process the raw frame, unescaping content\n        while (rawFrame.isReadable()) {\n            byte b1 = rawFrame.readByte();\n            if (b1 == '}') {\n                // Check if there's a byte following the escape character\n                if (!rawFrame.isReadable()) {\n                    // Found '}' at the very end of the frame, which is invalid\n                    throw new IllegalArgumentException(\"Incomplete escape sequence at end of frame\");\n                }\n                byte b2 = rawFrame.readByte();\n                switch (b2) {\n                    case 0x01:\n                        resultFrame.writeByte('}');\n                        break;\n                    case 0x02:\n                        resultFrame.writeByte('[');\n                        break;\n                    case 0x03:\n                        resultFrame.writeByte(']');\n                        break;\n                    case 0x04:\n                        resultFrame.writeByte(',');\n                        break;\n                    case 0x05:\n                        resultFrame.writeByte('*');\n                        break;\n                    default:\n                        // Use a format similar to the original error message\n                        throw new IllegalArgumentException(String.format(\n                                \"unexpected byte after escape char '}' : 0x%02x\", b2));\n                }\n            } else {\n                // Regular byte (including '[' and ']'), write it directly\n                resultFrame.writeByte(b1);\n            }\n        }\n\n        // 9. Return the processed (unescaped) frame including '[' and ']'\n        return resultFrame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}