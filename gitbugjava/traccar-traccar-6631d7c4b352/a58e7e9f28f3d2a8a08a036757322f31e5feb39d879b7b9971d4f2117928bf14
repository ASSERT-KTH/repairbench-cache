{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int endIndex = -1;\n        // Search for the first ']' from the current readerIndex.\n        // A FrameDecoder should extract one complete frame at a time.\n        // Searching backward for the last ']' would cause multiple frames\n        // to be concatenated if the input buffer contains more than one.\n        for (int i = buf.readerIndex(); i < buf.writerIndex(); i++) {\n            if (buf.getByte(i) == ']') {\n                endIndex = i + 1; // endIndex should be the position AFTER the ']' character\n                break; // Found the first ']', this defines the boundary of the current frame\n            }\n        }\n\n        if (endIndex > 0) { // If a complete frame is found\n            ByteBuf frame = Unpooled.buffer();\n            // Read bytes from the input buffer up to the calculated endIndex.\n            // This loop correctly advances buf.readerIndex() as bytes are read.\n            while (buf.readerIndex() < endIndex) {\n                byte b1 = buf.readByte();\n                if (b1 == '}') { // Check for escape character '}'\n                    if (buf.readerIndex() < endIndex) { // Ensure there's a byte to read for the escape sequence\n                        byte b2 = buf.readByte();\n                        switch (b2) {\n                            case 0x01:\n                                frame.writeByte('}');\n                                break;\n                            case 0x02:\n                                frame.writeByte('[');\n                                break;\n                            case 0x03:\n                                frame.writeByte(']');\n                                break;\n                            case 0x04:\n                                frame.writeByte(',');\n                                break;\n                            case 0x05:\n                                frame.writeByte('*');\n                                break;\n                            default:\n                                // The index for the error message should point to the unexpected byte (b2).\n                                // Since buf.readByte() was called for b2, buf.readerIndex() is now past b2,\n                                // so buf.readerIndex() - 1 points to b2.\n                                throw new IllegalArgumentException(String.format(\n                                        \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                        }\n                    } else {\n                        // If '}' is the last byte in the detected frame, it's an incomplete escape sequence.\n                        // This case might signify a corrupted frame or an incomplete buffer.\n                        // For this specific protocol, it implies malformed data or a partial frame.\n                        // We can either throw an exception or return null to wait for more data.\n                        // Given it's within a determined frame, throwing an exception is safer.\n                        throw new IllegalArgumentException(\"incomplete escape sequence at end of frame\");\n                    }\n                } else {\n                    frame.writeByte(b1); // Write non-escaped byte directly\n                }\n            }\n            return frame; // Return the decoded frame\n        }\n\n        return null; // No complete frame found yet, wait for more data\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}