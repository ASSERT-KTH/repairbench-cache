{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int originalReaderIndex = buf.readerIndex();\n        int writerIndex = buf.writerIndex();\n        int nestingLevel = 0;\n        int frameEndPosition = -1; // This will store the absolute index of the byte *after* the closing ']'\n\n        // Step 1: Find the end of the first complete frame in the buffer\n        // Iterate from the current readerIndex to find the unescaped top-level ']'\n        for (int i = originalReaderIndex; i < writerIndex; i++) {\n            byte currentByte = buf.getByte(i);\n\n            if (currentByte == '}') {\n                // If '}' is encountered, check if it's an escape prefix.\n                if (i + 1 < writerIndex) {\n                    byte nextByte = buf.getByte(i + 1);\n                    // Check if nextByte is one of the defined escape codes (0x01-0x05)\n                    switch (nextByte) {\n                        case 0x01: // }\n                        case 0x02: // [\n                        case 0x03: // ]\n                        case 0x04: // ,\n                        case 0x05: // *\n                            // This is an escaped character. Skip both bytes as they form a single logical character.\n                            i++;\n                            break;\n                        default:\n                            // nextByte is not an escape code. This means currentByte '}' is a literal.\n                            // Do nothing special; the loop will proceed to the next byte normally.\n                            break;\n                    }\n                } else {\n                    // '}' is the last byte in the buffer, and there's no byte following it for an escape sequence.\n                    // Treat '}' as a literal. The loop will naturally end after processing this byte.\n                }\n            } else if (currentByte == '[') {\n                nestingLevel++;\n            } else if (currentByte == ']') {\n                if (nestingLevel == 0) {\n                    // Found the unescaped closing bracket for the current frame at the top level.\n                    frameEndPosition = i + 1; // Mark the position *after* the closing bracket.\n                    break; // Frame found, stop searching.\n                } else {\n                    // Found a closing bracket for a nested structure.\n                    nestingLevel--;\n                }\n            }\n        }\n\n        if (frameEndPosition == -1) {\n            // No complete frame found in the buffer. Return null to wait for more data.\n            return null;\n        }\n\n        // Step 2: Extract and decode the identified frame\n        ByteBuf frame = Unpooled.buffer(frameEndPosition - originalReaderIndex); // Allocate efficiently\n\n        // Mark the current readerIndex. This allows resetting the buffer's readerIndex\n        // if an unexpected error occurs during frame decoding (e.g., malformed data).\n        buf.markReaderIndex(); \n\n        try {\n            // Read bytes from the input buffer up to the determined frameEndPosition\n            while (buf.readerIndex() < frameEndPosition) {\n                byte b1 = buf.readByte(); // Read current byte and advance buf.readerIndex()\n\n                if (b1 == '}') {\n                    // Check if there's a byte following '}' within the frame bounds\n                    if (buf.readerIndex() < frameEndPosition) {\n                        // Peek the next byte without consuming it yet to determine if it's an escape code.\n                        byte b2 = buf.getByte(buf.readerIndex()); \n                        switch (b2) {\n                            case 0x01: // }\n                            case 0x02: // [\n                            case 0x03: // ]\n                            case 0x04: // ,\n                            case 0x05: // *\n                                // It's an escaped character. Consume b2 and write the unescaped form.\n                                buf.readByte(); // Consume b2, advances buf.readerIndex()\n                                switch (b2) { // Write the actual unescaped character\n                                    case 0x01: frame.writeByte('}'); break;\n                                    case 0x02: frame.writeByte('['); break;\n                                    case 0x03: frame.writeByte(']'); break;\n                                    case 0x04: frame.writeByte(','); break;\n                                    case 0x05: frame.writeByte('*'); break;\n                                }\n                                break;\n                            default:\n                                // b2 is not a defined escape code. This means b1 ('}') was a literal.\n                                // We've already read b1. Just write b1 as a literal.\n                                // b2 will be processed as the next b1 in the subsequent loop iteration.\n                                frame.writeByte(b1);\n                                break;\n                        }\n                    } else {\n                        // '}' is the last byte of the frame, but no byte followed for an escape sequence.\n                        // Treat '}' as a literal character.\n                        frame.writeByte(b1);\n                    }\n                } else {\n                    // Not an escape sequence, just write the byte as is.\n                    frame.writeByte(b1);\n                }\n            }\n            return frame; // Return the successfully decoded frame\n        } catch (Exception e) {\n            // If any error occurs during parsing (e.g., malformed data that wasn't caught by frame boundary detection),\n            // reset the readerIndex to its original position before throwing to ensure buffer state consistency.\n            buf.resetReaderIndex();\n            throw e; // Re-throw the exception\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}