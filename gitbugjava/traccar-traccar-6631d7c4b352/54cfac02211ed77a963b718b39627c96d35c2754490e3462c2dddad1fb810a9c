{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        // 1. Find the start bracket '[' starting from the current reader index\n        int startIndex = buf.indexOf(buf.readerIndex(), buf.writerIndex(), (byte) '[');\n        if (startIndex < 0) {\n            // No start bracket found in the readable bytes, need more data\n            return null;\n        }\n\n        // Discard any garbage data before the start bracket '['\n        // This assumes that garbage might exist before a valid frame.\n        if (startIndex > buf.readerIndex()) {\n            buf.readerIndex(startIndex);\n        }\n\n        // 2. Find the end bracket ']' after the start bracket\n        // Start searching from the byte *after* '['\n        int endIndex = buf.indexOf(buf.readerIndex() + 1, buf.writerIndex(), (byte) ']');\n        if (endIndex < 0) {\n            // Found '[' but no corresponding ']' yet, frame is incomplete\n            return null;\n        }\n\n        // 3. We have a complete frame from readerIndex (which is startIndex) to endIndex (inclusive)\n        int frameLength = endIndex - buf.readerIndex() + 1;\n\n        // 4. Slice the buffer to represent the frame without modifying reader index yet\n        ByteBuf frameSlice = buf.slice(buf.readerIndex(), frameLength);\n\n        // 5. Create output buffer for the decoded (unescaped) frame\n        // Use allocator from context, estimate initial capacity.\n        ByteBuf decodedFrame = ctx.alloc().buffer(frameLength);\n\n        // 6. Iterate through the frame slice and perform unescaping\n        int currentSliceIndex = 0;\n        boolean success = false;\n        try {\n            while (currentSliceIndex < frameLength) {\n                byte b1 = frameSlice.getByte(currentSliceIndex++);\n                if (b1 == '}') {\n                    // Check if there's a byte following the escape character within the slice\n                    if (currentSliceIndex >= frameLength) {\n                        // Malformed frame: escape character '}' at the very end\n                        throw new IllegalArgumentException(\"Malformed frame: escape character '}' at the end.\");\n                    }\n                    byte b2 = frameSlice.getByte(currentSliceIndex++);\n                    switch (b2) {\n                        case 0x01:\n                            decodedFrame.writeByte('}');\n                            break;\n                        case 0x02:\n                            decodedFrame.writeByte('[');\n                            break;\n                        case 0x03:\n                            decodedFrame.writeByte(']');\n                            break;\n                        case 0x04:\n                            decodedFrame.writeByte(',');\n                            break;\n                        case 0x05:\n                            decodedFrame.writeByte('*');\n                            break;\n                        default:\n                            throw new IllegalArgumentException(String.format(\n                                    \"Unexpected escape sequence byte 0x%02x after '}'\", b2));\n                    }\n                } else {\n                    decodedFrame.writeByte(b1);\n                }\n            }\n            success = true; // Decoding successful\n        } finally {\n            if (!success) {\n                // Release the potentially partially filled buffer if an error occurred\n                decodedFrame.release();\n            }\n        }\n\n        // 7. Consume the processed frame from the input buffer by advancing reader index\n        buf.readerIndex(endIndex + 1);\n\n        // 8. Return the fully decoded frame\n        return decodedFrame;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}