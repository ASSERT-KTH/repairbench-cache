{
    "generation": "    @Override\n    protected Object decode(\n            ChannelHandlerContext ctx, Channel channel, ByteBuf buf) throws Exception {\n\n        int initialReaderIndex = buf.readerIndex();\n        int frameEndPos = -1; // This will store the index of the *unescaped* ']' character\n\n        int currentScanIndex = initialReaderIndex;\n        // Iterate through the buffer to find the end of the current frame, respecting escape sequences\n        while (currentScanIndex < buf.writerIndex()) {\n            byte b = buf.getByte(currentScanIndex);\n            if (b == '}') { // Possible escape sequence\n                if (currentScanIndex + 1 < buf.writerIndex()) {\n                    // This is an escaped sequence, consume both bytes by advancing the scan index by 2\n                    currentScanIndex += 2;\n                } else {\n                    // Incomplete escape sequence at the very end of the buffer.\n                    // We don't have enough data for a full frame yet.\n                    // Do not advance readerIndex, return null.\n                    return null;\n                }\n            } else if (b == ']') { // Found an unescaped ']'\n                frameEndPos = currentScanIndex;\n                break; // Found the end of the frame\n            } else { // Regular byte, just advance the scan index by 1\n                currentScanIndex++;\n            }\n        }\n\n        if (frameEndPos == -1) {\n            // No unescaped ']' found in the current buffer.\n            // A full frame is not yet available.\n            // Do not advance readerIndex, return null.\n            return null;\n        }\n\n        // At this point, `frameEndPos` holds the index of the closing ']' for the current frame.\n        // We now need to read and decode the bytes from `initialReaderIndex` up to `frameEndPos` (inclusive).\n        // The `buf.readerIndex()` will be advanced by `buf.readByte()`.\n        ByteBuf frame = Unpooled.buffer();\n\n        // Read bytes from the original buffer and apply escape decoding\n        // The loop reads up to and including the ']' character\n        while (buf.readerIndex() < frameEndPos + 1) {\n            byte b1 = buf.readByte();\n            if (b1 == '}') {\n                // Ensure there's a byte to read after '}' for the escape sequence.\n                // `buf.readerIndex()` has already advanced past `b1`.\n                // Check if the next byte of the escape sequence is within the frame boundaries.\n                if (buf.readerIndex() < frameEndPos + 1) {\n                    byte b2 = buf.readByte();\n                    switch (b2) {\n                        case 0x01: frame.writeByte('}'); break;\n                        case 0x02: frame.writeByte('['); break;\n                        case 0x03: frame.writeByte(']'); break;\n                        case 0x04: frame.writeByte(','); break;\n                        case 0x05: frame.writeByte('*'); break;\n                        default:\n                            throw new IllegalArgumentException(String.format(\n                                    \"unexpected byte at %d: 0x%02x\", buf.readerIndex() - 1, b2));\n                    }\n                } else {\n                    // This case should ideally be caught by the initial scan if the data is well-formed,\n                    // but it acts as a defensive check for malformed frames ending with an incomplete escape.\n                    throw new IllegalArgumentException(\"Incomplete escape sequence at the end of the frame.\");\n                }\n            } else {\n                frame.writeByte(b1);\n            }\n        }\n        // After this loop, `buf.readerIndex()` is correctly advanced past the extracted frame.\n        return frame;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": null,
    "test": false
}