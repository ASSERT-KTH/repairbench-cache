{
    "generation": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    List<Field> orderedFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n    // First collect all eligible candidates before injecting\n    Map<Field, Optional<Object>> fieldToCandidate = new LinkedHashMap<>();\n\n    // First pass: collect all candidates\n    for (Field field : orderedFields) {\n        fieldToCandidate.put(field, mockCandidateFilter.filterCandidate(mocks, field, fieldInstance));\n    }\n\n    // Second pass: inject candidates, prioritizing exact type matches\n    for (Map.Entry<Field, Optional<Object>> entry : fieldToCandidate.entrySet()) {\n        Optional<Object> candidate = entry.getValue();\n        if (candidate.isPresent()) {\n            // Check if this is the best match (exact type match)\n            Field field = entry.getKey();\n            boolean isExactMatch = false;\n            for (Object mock : mocks) {\n                if (field.getType().isInstance(mock) &&\n                    mock.getClass().equals(field.getType())) {\n                    isExactMatch = true;\n                    break;\n                }\n            }\n            if (isExactMatch) {\n                // Inject exact type matches first\n                mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n            }\n        }\n    }\n\n    // Then inject the rest (less specific matches)\n    for (Field field : orderedFields) {\n        Optional<Object> candidate = fieldToCandidate.get(field);\n        if (candidate.isPresent()) {\n            // Check if this hasn't been injected yet (only if it wasn't an exact match)\n            // We'll inject it now\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}