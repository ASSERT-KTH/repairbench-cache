{
    "generation": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    List<MockCandidateFilter.MockCandidate> candidates = new ArrayList<>();\n    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        MockCandidateFilter.MockCandidate candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n        if (candidate != null) {\n            candidates.add(candidate);\n        }\n    }\n    // Sort candidates by type match priority (exact match first, then ancestors)\n    candidates.sort((c1, c2) -> {\n        Class<?> type1 = c1.getField().getType();\n        Class<?> type2 = c2.getField().getType();\n        if (type1.equals(type2)) {\n            return 0;\n        }\n        if (type1.isAssignableFrom(type2)) {\n            return -1; // type1 is a parent of type2, so it should come first\n        } else if (type2.isAssignableFrom(type1)) {\n            return 1; // type2 is a parent of type1, so it should come first\n        }\n        return 0;\n    });\n    // Inject the best matching candidate\n    if (!candidates.isEmpty()) {\n        candidates.get(0).thenInject();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}