{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Get all candidate fields for injection\n        List<Field> allFields = new ArrayList<>(orderedInstanceFieldsFrom(awaitingInjectionClazz));\n\n        // Sort fields to prioritize injection into more specific types first.\n        // This ensures that if a mock can be injected into multiple fields\n        // (e.g., a specific type field and an Object field), it will be injected\n        // into the most specific type, fulfilling the \"best matching type\" requirement.\n        Collections.sort(allFields, (f1, f2) -> {\n            Class<?> type1 = f1.getType();\n            Class<?> type2 = f2.getType();\n\n            // If type2 is a subtype of type1 (and they are not the same class),\n            // then type2 is more specific. We want f2 to come before f1.\n            // In a Comparator, if f2 should come before f1, compare(f1, f2) should return a positive value.\n            if (type1.isAssignableFrom(type2) && !type1.equals(type2)) {\n                return 1; // f2 is more specific than f1, so f1 comes after f2.\n            }\n            // If type1 is a subtype of type2 (and they are not the same class),\n            // then type1 is more specific. We want f1 to come before f2.\n            // In a Comparator, if f1 should come before f2, compare(f1, f2) should return a negative value.\n            if (type2.isAssignableFrom(type1) && !type1.equals(type2)) {\n                return -1; // f1 is more specific than f2, so f1 comes before f2.\n            }\n            // If types are the same or unrelated (e.g., sibling interfaces), maintain relative order.\n            return 0;\n        });\n\n        // Iterate through the sorted fields and attempt injection.\n        // It's assumed that `mockCandidateFilter.filterCandidate(...).thenInject()`\n        // will remove the injected mock from the `mocks` set, ensuring each mock\n        // is injected only once.\n        for(Field field : allFields) {\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}