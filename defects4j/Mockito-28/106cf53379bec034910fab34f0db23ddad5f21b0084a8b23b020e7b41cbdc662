{
    "generation": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    List<Field> orderedFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n    MockCandidateFilter.MockCandidate bestCandidate = null;\n\n    // First pass: find the best matching candidate\n    for (Field field : orderedFields) {\n        MockCandidateFilter.MockCandidate candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n        if (candidate != null && (bestCandidate == null || isBetterMatch(candidate, bestCandidate))) {\n            bestCandidate = candidate;\n        }\n    }\n\n    // Second pass: inject the best candidate\n    if (bestCandidate != null) {\n        bestCandidate.thenInject();\n    } else {\n        // If no best candidate is found, inject the first suitable candidate\n        for (Field field : orderedFields) {\n            MockCandidateFilter.MockCandidate candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n            if (candidate != null) {\n                candidate.thenInject();\n                break;\n            }\n        }\n    }\n}\n\nprivate boolean isBetterMatch(MockCandidateFilter.MockCandidate candidate1, MockCandidateFilter.MockCandidate candidate2) {\n    Class<?> type1 = candidate1.getField().getType();\n    Class<?> type2 = candidate2.getField().getType();\n    \n    // Exact type match is better than ancestor type match\n    return type1.equals(candidate1.getMock().getClass()) && !type2.equals(candidate2.getMock().getClass());\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}