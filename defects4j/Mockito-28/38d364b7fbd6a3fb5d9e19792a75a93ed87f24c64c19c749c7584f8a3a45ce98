{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Use LinkedHashSet to preserve mock order and allow efficient removal\n        Set<Object> availableMocks = new LinkedHashSet<>(mocks);\n        Set<Field> injectedFields = new HashSet<>();\n\n        // First Pass: Inject mocks into fields with the exact same type\n        for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object matchingMock = findExactMatchMockForField(field, availableMocks);\n\n            if (matchingMock != null) {\n                // Try injecting only the exact match mock.\n                // Pass a singleton set to filterCandidate to ensure only this mock is considered for this field.\n                // Assume thenInject() returns true upon successful injection.\n                boolean injected = mockCandidateFilter.filterCandidate(\n                                        Collections.singleton(matchingMock), field, fieldInstance)\n                                        .thenInject();\n\n                if (injected) {\n                    injectedFields.add(field);\n                    availableMocks.remove(matchingMock); // Remove successfully injected mock from available set\n                }\n                // If injection failed (e.g., final field), the mock remains available,\n                // but it's unlikely to be injected elsewhere if it was an exact match.\n            }\n        }\n\n        // Second Pass: Inject remaining mocks based on assignable types into the remaining fields\n        if (!availableMocks.isEmpty()) {\n            for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n                // Skip fields that were already injected in the first pass\n                if (!injectedFields.contains(field)) {\n                    // Pass the remaining available mocks. Let filterCandidate decide the best fit among them based on its internal logic (type, name, etc.).\n                    // We rely on filterCandidate/thenInject or the underlying injection engine\n                    // to handle the state (i.e., not injecting a mock that was already used,\n                    // even if passed again in the set). This prioritization ensures exact matches were handled first.\n                    mockCandidateFilter.filterCandidate(availableMocks, field, fieldInstance).thenInject();\n                    // We don't necessarily know which mock was injected here or if the availableMocks set\n                    // was modified by the call, but the primary goal (prioritizing exact matches) is achieved.\n                }\n            }\n        }\n    }\n\n    // Helper method to find an available mock with the exact type of the field\n    // Requires Mockito API access. Assumes 'mocks' contains Mockito mocks.\n    private Object findExactMatchMockForField(Field field, Set<Object> availableMocks) {\n        Class<?> fieldType = field.getType();\n        for (Object mock : availableMocks) {\n            // Check if it's a mock and get its mocked type\n            org.mockito.MockingDetails mockingDetails = org.mockito.Mockito.mockingDetails(mock);\n            if (!mockingDetails.isMock()) {\n                 continue; // Skip non-mocks if any are present\n            }\n            // We need the type that was originally requested to be mocked\n            Class<?> mockType = mockingDetails.getMockCreationSettings().getTypeToMock();\n\n            if (fieldType.equals(mockType)) { // Check for exact Class equality\n                return mock; // Found an available mock with the exact type\n            }\n        }\n        return null; // No exact type match found among available mocks\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}