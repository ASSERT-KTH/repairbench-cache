{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        List<MockCandidateFilter.MockCandidate> allCandidates = new ArrayList<>();\n\n        // 1. Collect all potential candidates for injection from all fields\n        for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            MockCandidateFilter.MockCandidate candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n\n            // Assuming MockCandidate.getMock() returns null if no suitable mock was found\n            // or if it's a NoOp candidate. We only want actual potential injections.\n            if (candidate != null && candidate.getMock() != null) {\n                allCandidates.add(candidate);\n            }\n        }\n\n        // 2. Sort candidates to prioritize the \"best matching type\"\n        // Prioritization logic:\n        // a) Exact type match between mock and field type is preferred.\n        // b) If not exact, prefer fields whose type is more specific (lower in inheritance hierarchy)\n        //    for the given mock's type.\n        allCandidates.sort((c1, c2) -> {\n            Class<?> fieldType1 = c1.getField().getType();\n            Class<?> mockType1 = c1.getMock().getClass(); // Assuming getMock().getClass() gives the mock's actual type\n\n            Class<?> fieldType2 = c2.getField().getType();\n            Class<?> mockType2 = c2.getMock().getClass();\n\n            // Prioritize candidates where the mock's actual type exactly matches the field's type\n            boolean c1ExactMatch = fieldType1.equals(mockType1);\n            boolean c2ExactMatch = fieldType2.equals(mockType2);\n\n            if (c1ExactMatch != c2ExactMatch) {\n                return c1ExactMatch ? -1 : 1; // c1 (exact match) comes before c2 (not exact match)\n            }\n\n            // If both or neither are exact matches, prioritize more specific field types\n            // A field type is more specific if it's a subtype of the other field type.\n            // E.g., MockedBean.class is more specific than Object.class.\n            if (fieldType1.isAssignableFrom(fieldType2) && !fieldType2.isAssignableFrom(fieldType1)) {\n                return -1; // fieldType1 is more specific (or same) than fieldType2, so c1 is preferred\n            }\n            if (fieldType2.isAssignableFrom(fieldType1) && !fieldType1.isAssignableFrom(fieldType2)) {\n                return 1; // fieldType2 is more specific (or same) than fieldType1, so c2 is preferred\n            }\n\n            // Fallback for same specificity (e.g., two Object fields, or two MockedBean fields)\n            // In such cases, the original ordering from orderedInstanceFieldsFrom (implicitly maintained\n            // by not re-sorting if specificity is equal) or field name matching might be used,\n            // but for this problem, the above type-based sorting is sufficient.\n            return 0;\n        });\n\n        // 3. Perform injections, ensuring \"injected once\"\n        // Track which mocks have already been injected and which fields have been filled.\n        Set<Object> injectedMocks = new HashSet<>();\n        Set<Field> injectedFields = new HashSet<>();\n\n        for (MockCandidateFilter.MockCandidate candidate : allCandidates) {\n            Object mockToInject = candidate.getMock();\n            Field targetField = candidate.getField();\n\n            // Inject only if:\n            // a) The specific mock has not been injected elsewhere yet.\n            // b) The target field has not received an injection yet.\n            if (!injectedMocks.contains(mockToInject) && !injectedFields.contains(targetField)) {\n                candidate.thenInject(); // Perform the actual injection\n                injectedMocks.add(mockToInject);\n                injectedFields.add(targetField);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}