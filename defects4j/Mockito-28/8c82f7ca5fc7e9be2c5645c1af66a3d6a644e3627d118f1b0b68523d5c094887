{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // First collect all fields that could potentially be injected\n        List<Field> fields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n\n        // Keep track of which mocks we've already injected to prevent duplicate injection\n        Set<Object> injectedMocks = new HashSet<Object>();\n\n        for(Field field : fields) {\n            // Get the most specific mock that matches the field type\n            Object bestMatchMock = findBestMockMatch(mocks, field.getType());\n\n            if (bestMatchMock != null && !injectedMocks.contains(bestMatchMock)) {\n                mockCandidateFilter.filterCandidate(Collections.singleton(bestMatchMock), field, fieldInstance)\n                                  .thenInject();\n                injectedMocks.add(bestMatchMock);\n            }\n        }\n    }\n\n    private Object findBestMockMatch(Set<Object> mocks, Class<?> targetType) {\n        Object bestMatch = null;\n\n        for(Object mock : mocks) {\n            if (targetType.isAssignableFrom(mock.getClass())) {\n                // If we have an exact match, use that\n                if (targetType.equals(mock.getClass())) {\n                    return mock;\n                }\n                // Otherwise keep track of this potential match\n                if (bestMatch == null) {\n                    bestMatch = mock;\n                }\n            }\n        }\n\n        return bestMatch;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}