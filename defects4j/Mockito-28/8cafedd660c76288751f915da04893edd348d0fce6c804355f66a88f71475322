{
    "generation": "import java.lang.reflect.Field;\nimport java.util.*;\nimport org.mockito.Mockito;\n// Imports assumed to be available from the original context/class:\n// import org.mockito.internal.configuration.injection.MockCandidateFilter;\n// import org.mockito.internal.configuration.injection.OngoingInjecter;\n\n    /**\n     * Injects mock candidates into fields of the given instance.\n     * This implementation prioritizes exact type matches and then assignable type matches.\n     * Among assignable type matches, it prioritizes fields with more specific types.\n     * Each mock is injected at most once, into the best possible matching field.\n     * Each field receives at most one mock.\n     *\n     * @param awaitingInjectionClazz The class level where injection is considered.\n     * @param mocks The set of mock objects available for injection.\n     * @param fieldInstance The instance into which mocks should be injected.\n     */\n    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Store potential injections with quality metrics.\n        // Using Object[]: {Object mock, Field field, Integer quality (0=exact, 1=assignable)}\n        List<Object[]> potentialInjections = new ArrayList<>();\n\n        // Helper function to safely get the mocked type using public API.\n        java.util.function.Function<Object, Class<?>> getMockedType = mock -> {\n            if (mock == null) return null;\n            org.mockito.MockingDetails details = Mockito.mockingDetails(mock);\n            if (!details.isMock()) return null;\n            return details.getMockCreationSettings().getTypeToMock();\n        };\n\n        // 1. Find all potential injections and score their quality.\n        for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            // Prevent injection into static fields\n            if (java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n                continue;\n            }\n            for (Object mock : mocks) {\n                Class<?> mockType = getMockedType.apply(mock);\n                // Ensure mockType is valid and field type is not primitive (mocks are objects)\n                if (mockType != null && !field.getType().isPrimitive()) {\n                    if (field.getType().equals(mockType)) {\n                        // Exact type match\n                        potentialInjections.add(new Object[]{mock, field, 0}); // Quality 0\n                    } else if (field.getType().isAssignableFrom(mockType)) {\n                        // Assignable type match (mockType is a subtype of fieldType)\n                        potentialInjections.add(new Object[]{mock, field, 1}); // Quality 1\n                    }\n                }\n            }\n        }\n\n        // 2. Sort potential injections to prioritize the best matches.\n        //    - Primary: Quality (0=Exact, 1=Assignable). Lower quality first.\n        //    - Secondary: Field type specificity. More specific types (subtypes) first.\n        //    - Tertiary: Field name (for consistent tie-breaking).\n        Collections.sort(potentialInjections, (p1, p2) -> {\n            Field field1 = (Field) p1[1];\n            int quality1 = (Integer) p1[2];\n            Field field2 = (Field) p2[1];\n            int quality2 = (Integer) p2[2];\n\n            // Compare quality (lower is better)\n            int qualityComparison = Integer.compare(quality1, quality2);\n            if (qualityComparison != 0) {\n                return qualityComparison;\n            }\n\n            // Compare field type specificity (more specific is better)\n            Class<?> type1 = field1.getType();\n            Class<?> type2 = field2.getType();\n\n            if (type1.equals(type2)) {\n                 // Same type, break tie with field name\n                 return field1.getName().compareTo(field2.getName());\n            } else if (type1.isAssignableFrom(type2)) {\n                 // type2 is subtype of type1, so type2 is more specific. It should come first.\n                 return 1; // Sort p2 before p1\n            } else if (type2.isAssignableFrom(type1)) {\n                 // type1 is subtype of type2, so type1 is more specific. It should come first.\n                 return -1; // Sort p1 before p2\n            } else {\n                 // Unrelated types, break tie with field name\n                 return field1.getName().compareTo(field2.getName());\n            }\n        });\n\n        // 3. Perform injections based on sorted potentials, ensuring each mock/field is used at most once.\n        Set<Object> injectedMocks = new HashSet<>();\n        Set<Field> injectedFields = new HashSet<>();\n\n        for (Object[] potential : potentialInjections) {\n            Object mock = potential[0];\n            Field field = (Field) potential[1];\n\n            // Inject only if both mock and field haven't been used yet.\n            if (!injectedMocks.contains(mock) && !injectedFields.contains(field)) {\n                try {\n                    // Make the field accessible before attempting injection.\n                    field.setAccessible(true);\n\n                    // Use Mockito's filter/injecter mechanism.\n                    // Pass only the single selected mock candidate.\n                    // Assumes mockCandidateFilter and OngoingInjecter are from Mockito's internal API\n                    // as implied by the original method structure.\n                    org.mockito.internal.configuration.injection.OngoingInjecter injecter =\n                        mockCandidateFilter.filterCandidate(Collections.singleton(mock), field, fieldInstance);\n\n                    // Attempt the injection.\n                    injecter.thenInject();\n\n                    // If thenInject() completes without throwing, assume success for this pair.\n                    // Mark mock and field as injected to prevent reuse.\n                    injectedMocks.add(mock);\n                    injectedFields.add(field);\n\n                } catch (Exception e) {\n                    // Injection failed for this pair (e.g., security restriction, final field, error in thenInject).\n                    // Log the error or ignore. The mock and field remain available for other potential pairings.\n                    // System.err.println(\"WARN: Injection failed for field \" + field.getName() + \": \" + e.getMessage());\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}