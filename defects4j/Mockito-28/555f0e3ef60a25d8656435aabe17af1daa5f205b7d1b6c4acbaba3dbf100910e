{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        // Collect all fields. `orderedInstanceFieldsFrom` provides an initial order,\n        // but it might not be the optimal order for type-based injection.\n        List<Field> fields = new ArrayList<>(orderedInstanceFieldsFrom(awaitingInjectionClazz));\n\n        // Sort fields to prioritize injection into the most specific type.\n        // A mock candidate should be injected into the most specific field type it matches.\n        // For example, if a mock of type MyBean can be injected into a MyBean field or an Object field,\n        // it should be injected into the MyBean field first. This is achieved by processing\n        // fields of more specific types before fields of less specific (ancestor) types.\n        Collections.sort(fields, (f1, f2) -> {\n            Class<?> type1 = f1.getType();\n            Class<?> type2 = f2.getType();\n\n            // If types are the same, their relative order doesn't matter for specificity.\n            if (type1.equals(type2)) {\n                return 0;\n            }\n\n            // If type1 is an ancestor of type2 (e.g., type1=Object, type2=MyBean),\n            // then type2 (MyBean) is more specific and should come first.\n            // So, f2 should be \"less than\" f1. Return a positive value to put f1 after f2.\n            if (type1.isAssignableFrom(type2)) {\n                return 1;\n            }\n\n            // If type2 is an ancestor of type1 (e.g., type1=MyBean, type2=Object),\n            // then type1 (MyBean) is more specific and should come first.\n            // So, f1 should be \"less than\" f2. Return a negative value to put f1 before f2.\n            if (type2.isAssignableFrom(type1)) {\n                return -1;\n            }\n\n            // If there's no assignable relationship (e.g., String vs Integer),\n            // their relative order doesn't affect specificity.\n            return 0;\n        });\n\n        // Iterate through the sorted fields and attempt to inject a mock candidate.\n        // The mockCandidateFilter is expected to find the best matching mock for the given field\n        // from the `mocks` set, and crucially, to remove the mock from the set once it's injected,\n        // ensuring \"inject once\".\n        for(Field field : fields) {\n            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}