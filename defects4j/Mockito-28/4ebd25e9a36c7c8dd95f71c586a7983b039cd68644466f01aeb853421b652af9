{
    "generation": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        InjectionCandidate bestCandidate = null;\n        for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n           InjectionCandidate candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n            if (candidate.isAccepted() && (bestCandidate == null || isBetterCandidate(bestCandidate, candidate))) {\n                bestCandidate = candidate;\n            }\n        }\n        if (bestCandidate != null) {\n            bestCandidate.thenInject();\n        }\n    }\n\n    private boolean isBetterCandidate(InjectionCandidate current, InjectionCandidate candidate) {\n        return isExactType(current) ? false : !isExactType(candidate) || getTypeHierarchyDepth(candidate.getType()) < getTypeHierarchyDepth(current.getType());\n    }\n\n    private boolean isExactType(InjectionCandidate candidate) {\n        return(candidate.getType().isAssignableFrom(candidate.getMockType()) && !candidate.getType().isInterface());\n    }\n\n    private int getTypeHierarchyDepth(Class<?> type) {\n        int depth = 0;\n        Class<?> current = type;\n        while (current.getSuperclass() != null && current != Object.class) {\n            depth++;\n            current = current.getSuperclass();\n        }\n        return depth;\n    }\n\n    private static class InjectionCandidate {\n        private final Object mock;\n        private final Class<?> type;\n\n        /* constructors and getters */\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}