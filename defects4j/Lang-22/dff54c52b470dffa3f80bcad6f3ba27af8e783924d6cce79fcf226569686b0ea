{
    "generation": "    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     * <p>\n     * Special cases:\n     * <ul>\n     *  <li>The result is always non-negative.</li>\n     *  <li>The GCD of identical numbers is the number itself.</li>\n     *  <li>The GCD of zero and any number is the absolute value of that number.</li>\n     *  <li>The GCD of {@code Integer.MIN_VALUE} and any number is problematic as {@code Math.abs(Integer.MIN_VALUE)} overflows. A specific check for this case is implemented.</li>\n     * </ul>\n     *\n     * @param u  a number\n     * @param v  a number\n     * @return the greatest common divisor, never negative\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        // Short circuit \u0430\u043a\u043e u or v is 0 or 1 or -1\n        if (u == 0 || v == 0) {\n            // gcd(0,x) := |x|, non-negative\n             if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n             }\n             return Math.abs(u) + Math.abs(v);\n         }\n\n        // Swift return 1 for |u|=1 or |v|=1:\n        // We already handled the case u=0 or v=0\n        // Check for MIN_VALUE specifically, as Math.abs(MIN_VALUE) overflows.\n        if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n             // Check if the other operand is 1 or -1\n            if ( (u == Integer.MIN_VALUE && (v == 1 || v == -1)) ||\n                 (v == Integer.MIN_VALUE && (u == 1 || u == -1)) ) {\n                return 1;\n            }\n             // If u == v == MIN_VALUE, overflow occurs during the algorithm execution\n             // Before the fix for MATH-1391, the algorithm loop would exit with k=31\n             // and throw an ArithmeticException. After the fix, this case is checked upfront.\n             if (u == Integer.MIN_VALUE && v == Integer.MIN_VALUE) {\n                  throw new ArithmeticException(\"overflow: gcd is 2^31\");\n             }\n             // One is MIN_VALUE, the other is > 1 or < -1.\n             // Proceed with the algorithm. The initial check for |u| <= 1 is bypassed.\n         } else if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             // Neither is MIN_VALUE, safe to use Math.abs\n             return 1;\n         }\n\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        // Handle the MIN_VALUE case safely. Assume inputs are not 0.\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n\n        // B1. [Find power of 2]\n        int k=0;\n        // The check for k<31 is necessary since the shift operation (1<<k) could overflow.\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        if (k==31) {\n            // This condition is reached only if u == v == Integer.MIN_VALUE.\n            // It might also be reached if the gcd is truly 2^31, which cannot be represented as a positive int.\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0 */\n            // B4/B3: cast out twos from t.\n            while ((t&1)==0) { // while t is even..\n                // This division is safe because abs(t) <= 2^30 (exact) if u or v started as MIN_VALUE\n                // or abs(t) <= 2^30 if result of (v-u)/2.\n                 t/=2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t>0) {\n                // u = -t is safe because t is positive and odd, hence t <= 2^31 - 1.\n                u = -t;\n            } else {\n                // v = t is safe because t is negative and odd, hence t >= - (2^31 - 1).\n                // t cannot be Integer.MIN_VALUE here, as MIN_VALUE is even.\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            // t = (v - u)/2; The computation (v-u) can overflow if u = MIN_VALUE\n            // This is checked indirectly: if the result t is 0, the loop terminates.\n            // The overflow in v-u leads to correct results for gcd.\n            t = (v - u)/2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t!=0);\n        // gcd is -u*2^k; u is negative. Result must be non-negative.\n        // -u is positive unless u was Integer.MIN_VALUE.\n        // The result is -(u * 2^k) but u is negative, so this is correct.\n        // Handle potential overflow from shift operation (1 << k).\n        // This can happen if k=31, but we already checked for that.\n        // It can also happen if -u is large and k makes the result exceed MAX_VALUE.\n        // E.g. gcd(MIN_VALUE, MIN_VALUE/2) = 2^30. u becomes -1. -u=1. k=30. 1*(1<<30) = 2^30. Okay.\n        // E.g. gcd(MIN_VALUE, 2) = 2. u becomes -1. -u=1. k=1. 1*(1<<1) = 2. Okay.\n        // E.g. gcd(MIN_VALUE, MIN_VALUE) -> throws exception.\n        // Consider the case where -u = Integer.MAX_VALUE + 1 (i.e., MIN_VALUE). This happens if u = MIN_VALUE.\n        // If u = MIN_VALUE at the end, it means the original inputs were u=MIN_VALUE, v=0 or v=MIN_VALUE.\n        // We handle v=0 earlier. We throw for u=v=MIN_VALUE earlier.\n        // So u cannot be MIN_VALUE here. It must be an odd negative number.\n        // Therefore, -u > 0.\n        // Check for potential overflow in the final multiplication.\n        if (-u > (Integer.MAX_VALUE >> k)) { // Check for potential overflow before multiplying\n            throw new ArithmeticException(\"overflow: gcd is too large for int\");\n        }\n        return -u*(1<<k); // gcd is (-u)*2^k -u is the negative odd component\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}