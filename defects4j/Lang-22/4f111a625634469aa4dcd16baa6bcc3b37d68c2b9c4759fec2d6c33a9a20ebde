{
    "generation": "    /**\n     * <p>Gets the greatest common divisor of the absolute value of\n     * two numbers, using the \"binary gcd\" method which avoids\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n     * This algorithm is due to Josef Stein (1961).</p>\n     * <p>\n     * Special cases:\n     * <ul>\n     *  <li>The invocations {@code greatestCommonDivisor(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n     *      {@code greatestCommonDivisor(Integer.MIN_VALUE, 0)} and\n     *      {@code greatestCommonDivisor(0, Integer.MIN_VALUE)} throw an\n     *      {@code ArithmeticException}, because the result would be 2^31, which\n     *      is too large for an int value.</li>\n     *  <li>The result of {@code greatestCommonDivisor(x, x)}, {@code greatestCommonDivisor(0, x)} and\n     *      {@code greatestCommonDivisor(x, 0)} is the absolute value of {@code x}, except\n     *      for the special cases above.</li>\n     *  <li>The invocation {@code greatestCommonDivisor(0, 0)} is 0.</li>\n     * </ul>\n     *\n     * @param u  an integer\n     * @param v  an integer\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException if the result cannot be represented as a non-negative int value\n     */\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math: handle 0 appropriately.\n        // This also handles the special case where one value is Integer.MIN_VALUE and the other is 0.\n        if (u == 0 || v == 0) {\n            if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            // gcd(0, x) = |x|, gcd(x, 0) = |x|, gcd(0, 0) = 0\n            // Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE, which is negative.\n            // The Javadoc promises a non-negative result, but this case is excluded by the exception above.\n            return Math.abs(u) + Math.abs(v);\n        }\n\n        // The original code's initial check `if (Math.abs(u) <= 1 || Math.abs(v) <= 1)` was removed.\n        // It was incorrect for cases involving 0, and the main algorithm handles abs(x) == 1 correctly anyway.\n\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        // This negation step is safe even for Integer.MIN_VALUE because\n        // MIN_VALUE is already negative.\n        if (u>0) { u=-u; } // make u negative\n        if (v>0) { v=-v; } // make v negative\n\n        // B1. [Find power of 2]\n        int k=0;\n        // The loop advances k while both u and v are even and k < 31.\n        // Integer division `u/=2` and `v/=2` works correctly for negative even numbers.\n        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n            u/=2; v/=2; k++; // cast out twos.\n        }\n        // If k=31, it means the gcd is >= 2^31, which overflows an int.\n        // This happens for gcd(MIN_VALUE, MIN_VALUE)\n        if (k==31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        // The initial value for t depends on which argument is odd.\n        // If u is odd, t = v.\n        // If u is even, v must be odd (because k<31), hence t = -(u/2).\n        // The division operation `/` truncates towards zero in Java, which is important.\n        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n\n        do {\n            /* assert u<0 && v<0; */ // This invariant is maintained here.\n\n            // B4/B3: cast out twos from t.\n            // Continue dividing t by 2 until it becomes odd.\n            while ((t&1)==0) { // while t is even..\n                t/=2; // cast out twos using integer division\n            }\n\n            // B5 [reset max(u,v)]\n            // At this point, t is odd.\n            // If t is positive, replace u with -t.\n            // If t is negative, replace v with t.\n            // This ensures u and v remain negative.\n            if (t>0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n\n            // B6/B3. At this point both u and v should be odd and negative.\n            // Calculate the new difference and divide by 2.\n            // Since u and v are both odd, (v-u) is always even.\n            // Integer division is used.\n            t = (v - u)/2;\n            // If |u| > |v| (u < v because both are negative), then v - u > 0, t is positive.\n            // If |v| > |u| (v < u), then v - u < 0, t is negative.\n            // The sign of t determines which variable (u or v) was effectively replaced in B5 for the next iteration.\n        } while (t!=0);\n\n        // The loop terminates when t=0, which implies u=v.\n        // The gcd is |u| * 2^k. Since u is negative, this is equal to -u * 2^k.\n        // u cannot be Integer.MIN_VALUE at this point, because if the original inputs\n        // were such that u = v = Integer.MIN_VALUE after dividing by 2^k,\n        // the k=31 check would have been triggered earlier.\n        // Therefore, -u will not overflow.\n        return -u*(1<<k); // gcd is -(u) * 2^k, which is |u| * 2^k\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}