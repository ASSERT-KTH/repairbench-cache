{
    "generation": "    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    // 13-Dec-2015, tatu: Let's allow special case of property being injectable...\n                    //    (although that seems odd)\n                     if (extProp.getProperty().getInjectableValueId() != null) {\n                         // allow missing type id for injected props\n                         continue;\n                     }\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                // 13-Dec-2015, tatu: Let's allow special case of property being injectable...\n                Object injectableValueId = prop.getInjectableValueId();\n                if (injectableValueId != null) {\n                    buffer.inject(prop);\n                    continue; // property will be injected, no need to do anything here\n                }\n                // ... normally fine, although we have default impl case to consider too...\n                // -> Let's assume this is an error; missing property is not ok\n                 ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), extProp.getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    Object typeValue = typeId;\n                    JavaType typePropType = typeProp.getType();\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    // If target type is not String, attempt conversion\n                    if (!typePropType.hasRawClass(String.class)) {\n                        Object codec = ctxt.getParser().getCodec();\n                        if (!(codec instanceof ObjectMapper)) {\n                             // Fail hard here, as conversion is impossible without ObjectMapper\n                             throw ctxt.mappingException(\n                                     \"Cannot convert external type id '%s' for creator property '%s' of type %s: `ObjectMapper` not available\",\n                                             typeId, typeProp.getName(), typePropType);\n                        }\n                        ObjectMapper mapper = (ObjectMapper) codec;\n                        try {\n                            // Use convertValue for robust conversion from basic String id\n                            typeValue = mapper.convertValue(typeId, typePropType);\n                        } catch (IllegalArgumentException e0) {\n                            // Need the property name (`typeProp.getName()`) and target type (`typePropType`)\n                            // We are essentially failing to bind the String `typeId` to the creator parameter `typeProp`\n                            throw ctxt.reportInputMismatch(typeProp,\n                                    \"Cannot convert external type id '%s' into type %s for creator parameter '%s' (property '%s'): %s\",\n                                        typeId, typePropType, typeProp.getName(), extProp.getTypePropertyName(), e0.getMessage());\n                            // Note: `reportInputMismatch` throws the exception, no need to return\n                        }\n                    }\n                    buffer.assignParameter(typeProp, typeValue);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n             // 13-Dec-2015, tatu: Make sure we don't call setter for injected properties,\n             //    could perhaps optimize more and not even buffer? For now seems ok tho.\n            if (prop.getCreatorIndex() < 0 && prop.getInjectableValueId() == null) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}