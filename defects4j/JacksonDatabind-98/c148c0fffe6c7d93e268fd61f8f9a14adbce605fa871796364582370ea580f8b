{
    "generation": "    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    // 13-Dec-2015, tatu: Should this be an error? For now, fine, but\n                    //    maybe should require default implementation or such?\n                     ctxt.reportInputMismatch(_beanType,\n                             \"Missing external type id property '%s'\",\n                             extProp.getTypePropertyName());\n                     // 13-Dec-2015, tatu: Probably implies we cannot create POJO either.\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                // 13-Dec-2015, tatu: Hmmh. Is this an error? Maybe not, if property allows nulls?\n                // Let's assume for now it is not fundamentally mandatory, just missing.\n                 ctxt.reportInputMismatch(_beanType,\n                         \"Missing property '%s' for external type id '%s'\",\n                         prop.getName(), extProp.getTypePropertyName());\n            }\n\n            // 28-Oct-2019, tatu: As per test [databind#2461], looks like we may need to\n            //    try deserialize from buffer first?\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    Object typeValue = typeId; // default unless coercible\n                    // [databind#2433]: We may need to actually deserialize type Id even if\n                    // target type IS String...\n                    // 16-Jun-2018, tatu: [databind#1328], Need to deserialize value (although let's\n                    //    see if we can optimize assuming it's String...)\n                    // Not String? Need to deserialize\n                    // 29-Jun-2019, tatu: ... or if target is String, maybe coercible?\n                    JsonDeserializer<Object> deser = typeProp.getValueDeserializer();\n                    // NOTE: #3031 limits this enhancement to ONLY non-String target types\n                    if ((deser != null) && deser.handledType() != String.class) { // Optimization: string-to-string case easy\n                         // Use TokenBuffer to wrap typed id value (JsonString) for deserializer\n                         TokenBuffer tb = new TokenBuffer(p, ctxt);\n                         tb.writeString(typeId);\n\n                         // 28-Oct-2019, tatu: Need to be careful to use proper Feature settings...\n                         //   so importantly configure from `p`, NOT `ctxt`.\n                         try (JsonParser p2 = tb.asParser(p)) { // IMPORTANT: use main parser features!\n                             p2.nextToken(); // need to move to point to the value\n                             // note: since it's from buffer, no need to check for null\n                             typeValue = deser.deserialize(p2, ctxt);\n                         } finally {\n                             tb.close();\n                         }\n                    }\n                    // And finally assign\n                    buffer.assignParameter(typeProp, typeValue);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                // 28-Oct-2019, tatu: As per [databind#2461], need to handle buffer first\n                Object value = values[i];\n                if (value == null) {\n                    TokenBuffer tokens = _tokens[i];\n                    if (tokens != null) {\n                        // Quite possible we have creator property... TBD / verify\n                        // TODO: Need to pass 'typeId' as well\n                        final String typeId = _typeIds[i];\n                        final JsonParser p2 = tokens.asParser(p); // need original parser for features etc\n                        p2.nextToken();\n                        // perhaps we could even use \"prop.deserializeWithView(p2, ctxt, null)\"?\n                        value = prop.getValueDeserializer().deserialize(p2, ctxt);\n                        p2.close();\n                    }\n                }\n                prop.set(bean, value);\n            }\n        }\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}