{
    "generation": "/**\n * Variant called when creation of the POJO involves buffering of creator properties\n * as well as property-based creator.\n */\npublic Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                // 31-May-2018, tatu: [databind#1328]: If creator property is an Enum etc,\n                //   instead of passing String id directly, need to deserialize\n                Object typeIdValue = typeId;\n                JsonDeserializer<Object> deser = typeProp.getValueDeserializer();\n                if (deser != null) {\n                    try {\n                        // Some deserializers may require token, simulate string token with type id\n                        JsonParser idParser = ctxt.getParser().codec().getFactory()\n                            .createParser(\"\\\"\" + typeId + \"\\\"\");\n                        idParser.nextToken(); // advance to VALUE_STRING\n                        typeIdValue = deser.deserialize(idParser, ctxt);\n                        idParser.close();\n                    } catch (IOException e) {\n                        ctxt.reportInputMismatch(typeProp.getType(),\n                                \"Failed to deserialize type id '%s' as %s: %s\",\n                                typeId, typeProp.getType(), e.getMessage());\n                    }\n                }\n\n                buffer.assignParameter(typeProp, typeIdValue);\n            }\n        }\n    }\n    Object bean = creator.build(ctxt, buffer);\n    for (int i = 0; i < len; ++i) {\n        SettableBeanProperty prop = _properties[i].getProperty();\n        if (prop.getCreatorIndex() < 0) {\n            prop.set(bean, values[i]);\n        }\n    }\n    return bean;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}