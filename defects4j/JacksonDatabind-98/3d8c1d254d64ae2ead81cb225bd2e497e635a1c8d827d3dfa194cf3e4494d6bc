{
    "generation": "import com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.util.TokenBuffer;\nimport com.fasterxml.jackson.databind.BeanProperty;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n// This is a placeholder for the surrounding class structure.\n// Assume necessary fields like _properties, _typeIds, _tokens, _beanType\n// and methods like _deserialize are defined in the actual class.\nabstract class ExternalTypeHandler_buggy {\n    protected final JavaType _beanType = null; // Placeholder\n    protected final ExtTypedProperty[] _properties = null; // Placeholder\n    protected final Map<String, Object> _nameToPropertyIndex = null; // Placeholder\n    protected final String[] _typeIds = null; // Placeholder\n    protected final TokenBuffer[] _tokens = null; // Placeholder\n    protected abstract Object _deserialize(JsonParser p, DeserializationContext ctxt, int index, String typeId) throws IOException; // Placeholder\n\n    // The fixed method:\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    // 11-Nov-2015, tatu: Should be ok to miss type id for creator property too...\n                     SettableBeanProperty prop = extProp.getProperty();\n                     // If it's creator property, maybe value is missing? Let buffer/creator fail if needed.\n                     if ((prop != null) && (prop.getCreatorIndex() >= 0)) {\n                        // 25-Mar-2019, tatu: Or possibly injectable value? For now let's assume it's ok\n                     } else {\n                        ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s' (and no 'defaultImpl' specified)\",\n                            extProp.getTypePropertyName());\n                    }\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n                // If type is now known, make sure value is available:\n                if (typeId == null) { // should not happen... but just in case\n                     ctxt.reportInputMismatch(_beanType,\n                            \"Internal error: null type id resolved for property '%s'\",\n                            extProp.getProperty().getName());\n                }\n                if (_tokens[i] == null) { // but value may be missing\n                    SettableBeanProperty prop = extProp.getProperty();\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing property '%s' for external type id '%s'\",\n                            prop.getName(), extProp.getTypePropertyName());\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                // 13-Jan-2016, tatu: Let's allow missing properties for creator properties,\n                //    and rely on creator complaining, or buffer assigning default value.\n                if (prop.getCreatorIndex() < 0 && !prop.isRequired()) {\n                    // But if it's not required, nor creator property, just use null\n                    values[i] = null; // this is explicitly handled later for non-creator properties\n                    continue; // no need to call _deserialize\n                }\n                // Otherwise, must have the value\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n\n            // Note: null typeId should have been handled earlier (by error or default impl)\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    final Object typeValue;\n\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    JavaType typePropType = typeProp.getType();\n                    // Minor optimization: If type is String, value is already good\n                    if (typePropType.hasRawClass(String.class)) {\n                        typeValue = typeId;\n                    } else {\n                        // Otherwise, need to deserialize String type Id value into actual type\n                        // Use a TokenBuffer to feed the String value to the deserializer\n                        TokenBuffer tb = ctxt.bufferForInputBuffering(p);\n                        tb.writeString(typeId);\n\n                        // important: need to make sure it's seen as VALUE_STRING Token\n                        JsonParser p2 = tb.asParserOnFirstToken();\n\n                        // Access deserializer using standard Jackson mechanisms, which encompass\n                        // potentially custom setup, key deserializers, etc.\n                        JsonDeserializer<Object> deser = typeProp.getValueDeserializer();\n                        // 16-Aug-2018, tatu: As per [databind#2126], may need to consider type overrides\n                        if (deser.getObjectIdReader() != null) {\n                             tb.close();\n                             ctxt.reportInputMismatch(typeProp,\n \"Deserializer for Creator property '%s' (%s) has `ObjectIdReader`, cannot assign it external type id property '%s'\",\n                                     typeProp.getName(), typePropType, extProp.getTypePropertyName());\n                        }\n                        typeValue = deser.deserialize(p2, ctxt);\n                        tb.close(); // Release buffer resources if appropriate\n                    }\n                    buffer.assignParameter(typeProp, typeValue);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                // 13-Jan-2016, tatu: Skip nulls for missing properties\n                // 03-Jun-2018, tatu: Only skip if NO tokens were seen; needed for ValueInstantiators\n                //     that require non-null values for properties with default value...\n                if (values[i] == null) {\n                     if (_tokens[i] == null) {\n                         continue;\n                     }\n                }\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }\n\n    // Placeholder for the nested class ExtTypedProperty\n    protected static final class ExtTypedProperty {\n        public SettableBeanProperty getProperty() { return null; } // Placeholder\n        public SettableBeanProperty getTypeProperty() { return null; } // Placeholder\n        public String getTypePropertyName() { return null; } // Placeholder\n        public boolean hasDefaultType() { return false; } // Placeholder\n        public String getDefaultTypeId() { return null; } // Placeholder\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}