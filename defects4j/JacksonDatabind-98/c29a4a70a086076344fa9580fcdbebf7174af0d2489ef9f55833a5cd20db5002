{
    "generation": "import com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.util.TokenBuffer;\nimport com.fasterxml.jackson.databind.DeserializationContext;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonDeserializer;\nimport com.fasterxml.jackson.databind.deser.SettableBeanProperty;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\nimport com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\n// NOTE: The following import is assumed based on context and variable names like `extProp`\n// It might differ based on the actual containing class, but ExtTypedProperty is a likely candidate.\nimport com.fasterxml.jackson.databind.jsontype.impl.AsExternalTypeDeserializer.ExtTypedProperty;\n\nimport java.io.IOException;\n\n// NOTE: This code assumes the presence of instance fields:\n// _properties (ExtTypedProperty[]), _typeIds (String[]), _tokens (TokenBuffer[]), _beanType (JavaType)\n// and a method:\n// _deserialize(JsonParser p, DeserializationContext ctxt, int index, String typeId) throws IOException\n// which uses _tokens[index] (a TokenBuffer) to deserialize the actual property value.\n\n    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // NOTE: Assumes _tokens field is of type TokenBuffer[] based on common Jackson internals for this pattern\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        boolean[] deserialized = new boolean[len]; // Track processed properties\n\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            // NOTE: Assuming _tokens is TokenBuffer[] based on typical implementation\n            final TokenBuffer valueTokens = _tokens[i];\n\n            // Logic for handling missing typeId or missing valueTokens\n            if (typeId == null) {\n                if (valueTokens == null) { // both missing? ignore\n                    continue;\n                }\n                // type id missing, value present: try default type\n                if (!extProp.hasDefaultType()) {\n                     // As per [databind#94], must allow use of 'defaultImpl'. But if no default, then error.\n                     ctxt.reportInputMismatch(_beanType,\n                             \"Missing external type id property '%s'\", extProp.getTypePropertyName());\n                     // If error reporting doesn't throw, skip property. Without type id, cannot proceed.\n                     continue;\n                 }\n                 typeId = extProp.getDefaultTypeId();\n                 if (typeId == null) { // default type resulted in null? Should not happen per check above, but defensive.\n                     ctxt.reportInputMismatch(_beanType,\n                         \"Invalid default type id for property '%s': `null`\", extProp.getTypePropertyName());\n                     continue; // skip if default type id is invalid (null)\n                 }\n            } else if (valueTokens == null) { // type id present, value missing\n                // As per [databind#94] / related later changes: skip instead of failing\n                 // SettableBeanProperty prop = extProp.getProperty(); // name only needed for error message\n                 // ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), extProp.getTypePropertyName());\n                 continue; // Skip property\n            }\n\n            // If we reach here, typeId is non-null and valueTokens is non-null\n            deserialized[i] = true; // Mark property as processed\n            values[i] = _deserialize(p, ctxt, i, typeId); // Deserialize the actual value\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            if (prop.getCreatorIndex() >= 0) { // Is it a creator property?\n                // Assign value parameter to buffer\n                buffer.assignParameter(prop, values[i]);\n\n                // Check if the type id itself corresponds to a creator parameter\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    Object actualTypeId;\n                    JavaType typePropType = typeProp.getType();\n\n                    // If target type is String, use typeId directly\n                    if (typePropType.hasRawClass(String.class)) {\n                        actualTypeId = typeId;\n                    } else {\n                        // Otherwise, need to deserialize typeId string into target type\n                        // Use TokenBuffer to wrap the typeId string and feed it to the deserializer\n                        TokenBuffer tb = new TokenBuffer(p, ctxt);\n                        tb.writeString(typeId);\n\n                        JsonParser bufferedParser = tb.asParser();\n                        // Important: must point parser to the first token:\n                        bufferedParser.nextToken();\n\n                        // Find deserializer for the type property\n                        JsonDeserializer<Object> typeDeser = typeProp.getValueDeserializer();\n                        if (typeDeser == null) {\n                             typeDeser = ctxt.findContextualValueDeserializer(typePropType, typeProp);\n                        }\n\n                        // Deserialize if deserializer found\n                        if (typeDeser == null) {\n                            // Cannot find deserializer: report error. Behavior depends on context (may throw).\n                            ctxt.reportBadDefinition(typeProp.getType(), String.format(\n                                \"Cannot find JsonDeserializer for type parameter '%s' (required by type id property '%s')\",\n                                typeProp.getType(), typeProp.getName()));\n                             // What value to assign? Using null is safest if deserialization failed.\n                             actualTypeId = null;\n                        } else {\n                             actualTypeId = typeDeser.deserialize(bufferedParser, ctxt);\n                        }\n                        bufferedParser.close(); // Close parser wrapping TokenBuffer (also closes buffer)\n                    }\n                    // Assign the processed type id value to the buffer\n                    buffer.assignParameter(typeProp, actualTypeId);\n                }\n            }\n        }\n\n        // Build the bean instance using gathered creator properties\n        Object bean = creator.build(ctxt, buffer);\n\n        // Assign non-creator properties that were successfully deserialized\n        for (int i = 0; i < len; ++i) {\n            if (!deserialized[i]) { // Skip if property processing was skipped\n                 continue;\n            }\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) { // Check if it's NOT a creator property\n                prop.set(bean, values[i]); // Set the value on the bean\n            }\n        }\n        return bean;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}