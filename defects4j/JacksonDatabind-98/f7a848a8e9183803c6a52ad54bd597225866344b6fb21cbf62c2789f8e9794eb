{
    "generation": "    /**\n     * Variant called when creation of the POJO involves buffering of creator properties\n     * as well as property-based creator.\n     */\n    public Object complete(JsonParser p, DeserializationContext ctxt,\n            PropertyValueBuffer buffer, PropertyBasedCreator creator)\n        throws IOException\n    {\n        // first things first: deserialize all data buffered:\n        final int len = _properties.length;\n        Object[] values = new Object[len];\n        for (int i = 0; i < len; ++i) {\n            String typeId = _typeIds[i];\n            final ExtTypedProperty extProp = _properties[i];\n            if (typeId == null) {\n                // let's allow missing both type and property (may already have been set, too)\n                if (_tokens[i] == null) {\n                    continue;\n                }\n                // but not just one\n                // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n                if (!extProp.hasDefaultType()) {\n                    ctxt.reportInputMismatch(_beanType,\n                            \"Missing external type id property '%s'\",\n                            extProp.getTypePropertyName());\n                } else {\n                    typeId = extProp.getDefaultTypeId();\n                }\n            } else if (_tokens[i] == null) {\n                SettableBeanProperty prop = extProp.getProperty();\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing property '%s' for external type id '%s'\",\n                        prop.getName(), _properties[i].getTypePropertyName());\n            }\n            values[i] = _deserialize(p, ctxt, i, typeId);\n\n            final SettableBeanProperty prop = extProp.getProperty();\n            // also: if it's creator prop, fill in\n            if (prop.getCreatorIndex() >= 0) {\n                buffer.assignParameter(prop, values[i]);\n\n                // [databind#999] And maybe there's creator property for type id too?\n                SettableBeanProperty typeProp = extProp.getTypeProperty();\n                // for now, should only be needed for creator properties, too\n                if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                    Object actualTypeIdValue = typeId; // Default to the string type id\n                    // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                    //    apply deserializer... fun fun.\n                    // This applies if the type property (e.g., enum, primitive wrapper) expects\n                    // something other than a plain String, so we need to deserialize the\n                    // 'typeId' string into the correct type.\n                    if (typeProp.getType().getRawClass() != String.class) {\n                        JsonDeserializer<Object> typeIdDeser = typeProp.getValueDeserializer();\n                        if (typeIdDeser == null) {\n                            // Fallback to finding a contextual deserializer for the type property\n                            typeIdDeser = ctxt.findContextualValueDeserializer(typeProp.getType(), typeProp);\n                        }\n\n                        if (typeIdDeser != null) {\n                            // Need a JsonParser to feed to the deserializer.\n                            // Create a temporary parser from the typeId string.\n                            // This uses the current parser's codec to ensure proper factory configuration.\n                            JsonParser tempParser = p.getCodec().getFactory().createParser(typeId);\n                            // Advance to the first token; deserializer expects parser to be at start of value.\n                            // For a simple string like \"Dog\" or \"123\", this will be VALUE_STRING or VALUE_NUMBER_INT.\n                            tempParser.nextToken(); \n                            actualTypeIdValue = typeIdDeser.deserialize(tempParser, ctxt);\n                            tempParser.close(); // Close the temporary parser to release resources\n                        } else {\n                            // This case should ideally not be reached for standard types,\n                            // but provides a safety net if no deserializer can be found.\n                            ctxt.reportInputMismatch(_beanType,\n                                    \"Cannot find deserializer for type id property '%s' of type %s\",\n                                    typeProp.getName(), typeProp.getType().toString());\n                        }\n                    }\n                    buffer.assignParameter(typeProp, actualTypeIdValue);\n                }\n            }\n        }\n        Object bean = creator.build(ctxt, buffer);\n        // third: assign non-creator properties\n        for (int i = 0; i < len; ++i) {\n            SettableBeanProperty prop = _properties[i].getProperty();\n            if (prop.getCreatorIndex() < 0) {\n                prop.set(bean, values[i]);\n            }\n        }\n        return bean;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}