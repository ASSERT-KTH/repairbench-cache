{
    "generation": "    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        // The original implementation was:\n        // return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        // This logic makes Double.NaN equal to itself.\n        // However, the Javadoc references `equals(double, double, int)` which explicitly states\n        // \"NaN values are not considered to be equal to any value, not even themselves.\"\n        // Also, the failing test `assertFalse(MathUtils.equals(new double[] { Double.NaN }, new double[] { Double.NaN }));`\n        // implies that `equals(Double.NaN, Double.NaN)` should return `false`.\n        // The standard double comparison `x == y` already correctly handles NaN (i.e., `Double.NaN == Double.NaN` is `false`).\n        // Therefore, removing the explicit NaN check makes the function consistent with its documentation and the failing test case.\n        return x == y;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}