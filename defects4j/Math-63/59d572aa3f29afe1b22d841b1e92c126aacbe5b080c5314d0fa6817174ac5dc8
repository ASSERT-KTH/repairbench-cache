{
    "generation": "    /**\n     * Returns true iff they are equal as defined by\n     * {@link #equals(double,double,int) equals(x, y, 1)}.\n     *\n     * @param x first value\n     * @param y second value\n     * @return {@code true} if the values are equal.\n     */\n    public static boolean equals(double x, double y) {\n        // The original implementation was:\n        // return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        //\n        // This implementation made equals(Double.NaN, Double.NaN) return true.\n        // However, standard IEEE 754 comparison (x == y) specifies that NaN != NaN.\n        //\n        // The Javadoc states that this method returns true if equal as defined by\n        // equals(x, y, 1). Looking at common implementations of equals(x, y, ulps)\n        // in Apache Commons Math, if either x or y is NaN, the comparison often\n        // defaults to x == y, which would result in false for (NaN, NaN).\n        //\n        // The failing test `assertFalse(MathUtils.equals(new double[] { Double.NaN }, new double[] { Double.NaN }));`\n        // implies that when `equals(double[], double[])` performs element-wise comparison,\n        // it expects `equals(NaN, NaN)` to be false.\n        //\n        // Therefore, to align with standard double comparison and the expected behavior\n        // for `testArrayEquals` and consistency with `equals(x, y, 1)`,\n        // the special handling for NaN equality should be removed.\n        return x == y;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}