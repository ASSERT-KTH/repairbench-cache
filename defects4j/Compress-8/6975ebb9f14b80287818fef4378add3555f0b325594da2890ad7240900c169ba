{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    // The field must be at least 2 bytes long.\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Invalid header record: length must be at least 2 bytes\");\n    }\n    int end = offset + length;\n    \n    // If every byte in the field is NUL then this is considered a missing field.\n    boolean allNull = true;\n    for (int i = offset; i < end; i++) {\n        if (buffer[i] != 0) {\n            allNull = false;\n            break;\n        }\n    }\n    if (allNull) {\n        return 0L;\n    }\n    \n    // Skip only leading spaces.\n    int index = offset;\n    while (index < end && buffer[index] == (byte)' ') {\n        index++;\n    }\n    \n    // After skipping spaces there must be at least one digit.\n    // A valid digit is one of '0'..'7'.  If the first non-space byte is NUL or another space,\n    // then the field is inconsistent (it isn\u2019t an all-NUL missing field but contains no digit).\n    if (index >= end || buffer[index] == 0 || buffer[index] == (byte)' ') {\n        throw new IllegalArgumentException(\"Invalid octal encoding: no digits found\");\n    }\n    \n    long result = 0;\n    int digitStart = index;\n    // Parse consecutive octal digits until a trailing delimiter (NUL or space) is encountered.\n    while (index < end && buffer[index] != 0 && buffer[index] != (byte)' ') {\n        byte currentByte = buffer[index];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, digitStart, currentByte)\n            );\n        }\n        result = (result << 3) + (currentByte - '0');\n        index++;\n    }\n    \n    // There MUST be at least one trailing delimiter.\n    if (index >= end) {\n        throw new IllegalArgumentException(\"Invalid octal encoding: missing trailing space or NUL\");\n    }\n    // Any remaining bytes in the field must be either NUL or space.\n    for (int j = index; j < end; j++) {\n        byte ch = buffer[j];\n        if (ch != 0 && ch != (byte)' ') {\n            throw new IllegalArgumentException(\n                \"Invalid octal encoding: invalid trailing character '\" + (char) ch + \"'\"\n            );\n        }\n    }\n    \n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}