{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        // [Fix 1]: Enforce minimum length as per Javadoc\n        if (length < 2) {\n            throw new IllegalArgumentException(\"length must be at least 2 bytes: \" + length);\n        }\n\n        long    result = 0;\n        int     start = offset;\n        int     end = offset + length;\n\n        // Step 1: Skip leading spaces\n        int current = start;\n        while (current < end && buffer[current] == (byte) ' ') {\n            current++;\n        }\n\n        // Step 2: Handle \"all NULs\" special case, or an invalid leading NUL\n        // If the first non-space character is a NUL (byte 0), then the *entire remaining segment* must be NULs.\n        // Otherwise, it's an error because NULs are not valid as leading padding or embedded characters unless it's an \"all NULs\" scenario.\n        if (current < end && buffer[current] == 0) {\n            boolean allNULsFromCurrent = true;\n            for (int i = current; i < end; i++) {\n                if (buffer[i] != 0) {\n                    allNULsFromCurrent = false;\n                    break;\n                }\n            }\n            if (allNULsFromCurrent) {\n                return 0L; // This covers cases like {0,0,0} or { ' ', 0, 0 }\n            } else {\n                // If not all NULs from this point, then this NUL is an invalid embedded character or leading NUL.\n                // This correctly fails byte[]{0,0,' '} and byte[]{' ',0,0,0}\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, current, buffer[current]));\n            }\n        }\n        \n        // At this point, 'current' points to the first non-space, non-NUL character.\n        // Or it points to 'end' if the string was all spaces.\n        // If it was all spaces (e.g. \"   \"), return 0L.\n        if (current == end) {\n            return 0L;\n        }\n\n        // Step 3: Parse octal digits\n        // `parsedActualDigit` flag ensures that \"00\" (no trailer) throws, but \"00 \" returns 0.\n        boolean parsedActualDigit = false; \n        int lastDigitIdx = -1; // Index of the last character that was an octal digit.\n\n        for (int i = current; i < end; i++) {\n            final byte currentByte = buffer[i];\n\n            if (currentByte >= '0' && currentByte <= '7') {\n                result = (result << 3) + (currentByte - '0');\n                parsedActualDigit = true;\n                lastDigitIdx = i; // Keep track of the last digit's index\n            } else if (currentByte == (byte) ' ' || currentByte == 0) {\n                // [Fix 4]: Found a space or NUL. This must be the *start of the trailing terminator sequence*.\n                // All remaining characters in the buffer up to 'end' must also be NUL or space.\n                for (int j = i; j < end; j++) {\n                    final byte trailerByte = buffer[j];\n                    if (trailerByte != 0 && trailerByte != (byte) ' ') {\n                        throw new IllegalArgumentException(\n                                exceptionMessage(buffer, offset, length, j, trailerByte));\n                    }\n                }\n                return result; // Valid terminator sequence found.\n            } else {\n                // [Fix 4]: Invalid character within the number string (not a digit, not a valid terminator at this position).\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, i, currentByte));\n            }\n        }\n\n        // [Fix 3]: If the loop completes, it means no valid terminator (NUL or space) was found.\n        // This implies the entire segment was digits (e.g., \"123\", \"77777777777\", \"000\").\n        // A trailing terminator is required.\n        // '00 ' -> `parsedActualDigit` is true, it finds ' ' and returns 0 correctly.\n        // '000' -> `parsedActualDigit` is true, loop finishes here.\n        if (parsedActualDigit) { // Only throw if actual digits were parsed but no trailer.\n             throw new IllegalArgumentException(\n                 exceptionMessage(buffer, offset, length, lastDigitIdx, buffer[lastDigitIdx]));\n        } else {\n            // This case should be unreachable if 'current == end' check is correct.\n            // But as a fallback for cases like \"00\" (if length is 2 and no space at end), this might return 0.\n            // If parsedActualDigit is false, it means only leading '0's were skipped or there were no digits at all.\n            // This is equivalent to a missing field, which returns 0L.\n            return 0L;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}