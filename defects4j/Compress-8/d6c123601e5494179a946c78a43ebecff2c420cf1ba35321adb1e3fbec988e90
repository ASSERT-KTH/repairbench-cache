{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    // Check for min length\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length must be at least 2 bytes\");\n    }\n    int end = offset + length;\n\n    // Check if all zeros case\n    boolean allNuls = true;\n    for (int i = offset; i < end; i++) {\n        if (buffer[i] != 0) {\n            allNuls = false;\n            break;\n        }\n    }\n    if (allNuls) {\n        return 0L;\n    }\n\n    // If not all NULs, make sure first and second-last bytes are not NUL (to catch cases like {0,0,' '})\n    // But actually: make sure either last or second-last byte is a space or NUL, per trailer requirement.\n    // We'll check the trailer after parsing digits.\n\n    long result = 0;\n    boolean stillPadding = true;\n    int i = offset;\n    int lastDigit = -1;\n    // Skip leading spaces or zeros\n    while (i < end) {\n        byte currentByte = buffer[i];\n        if (currentByte == (byte) ' ' || currentByte == (byte) '0') {\n            if (stillPadding) {\n                i++;\n                continue;\n            }\n        }\n        stillPadding = false;\n        if (currentByte < '0' || currentByte > '7') {\n            break;\n        }\n        result = (result << 3) + (currentByte - '0');\n        lastDigit = i;\n        i++;\n    }\n\n    // Now i is at first non-octal byte or end\n    // There must be at least one ending byte (space or NUL) after digits, and nothing but space/NUL after digits\n    // The rest must be only spaces or NULs\n    boolean foundTrailer = false;\n    for (; i < end; i++) {\n        byte b = buffer[i];\n        if (b == 0 || b == (byte) ' ') {\n            foundTrailer = true;\n        } else {\n            throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, i, b));\n        }\n    }\n    if (!foundTrailer || lastDigit == -1) {\n        throw new IllegalArgumentException(\n            exceptionMessage(buffer, offset, length, offset, buffer[offset]));\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}