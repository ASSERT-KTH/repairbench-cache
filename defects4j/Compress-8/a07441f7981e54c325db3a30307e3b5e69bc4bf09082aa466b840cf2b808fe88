{
    "generation": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        // 1. Check for minimum length as per Javadoc.\n        if (length < 2) {\n            throw new IllegalArgumentException(\"length must be at least 2 bytes\");\n        }\n\n        // 2. Check for \"all NULs\" case. This is a special condition and must be handled strictly.\n        // If every byte in the segment is NUL, return 0L.\n        boolean allNULs = true;\n        for (int i = offset; i < offset + length; i++) {\n            if (buffer[i] != 0) { // If any byte is not NUL, it's not an all-NULs field.\n                allNULs = false;\n                break;\n            }\n        }\n        if (allNULs) {\n            return 0L;\n        }\n\n        long    result = 0;\n        boolean stillPadding = true; // True if we are still skipping leading spaces or ASCII '0's.\n        int     end = offset + length;\n\n        // 3. Rule: The buffer must contain a trailing space or NUL.\n        // This applies to the *very last* byte of the field.\n        if (buffer[end - 1] != 0 && buffer[end - 1] != (byte) ' ') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, end - 1, buffer[end - 1]));\n        }\n\n        // Iterate through the buffer to parse digits and validate characters.\n        for (int i = offset; i < end; i++){\n            final byte currentByte = buffer[i];\n\n            // Handle NUL byte: NUL is only allowed as a trailing character.\n            if (currentByte == 0) {\n                // If a NUL is found, it must be the start of a valid trailing sequence.\n                // All characters from current position `i` to `end-1` must be NUL or space.\n                for (int j = i; j < end; j++) {\n                    if (buffer[j] != 0 && buffer[j] != (byte) ' ') {\n                        throw new IllegalArgumentException(\n                                exceptionMessage(buffer, offset, length, j, buffer[j]));\n                    }\n                }\n                // If all remaining characters are valid trailers, then stop parsing digits.\n                break;\n            }\n\n            // Handle space character:\n            if (currentByte == (byte) ' ') {\n                if (stillPadding) {\n                    continue; // Skip leading spaces.\n                }\n                // If space found after leading padding has finished, it must be the start of a trailing sequence.\n                for (int j = i; j < end; j++) {\n                    if (buffer[j] != 0 && buffer[j] != (byte) ' ') {\n                        throw new IllegalArgumentException(\n                                exceptionMessage(buffer, offset, length, j, buffer[j]));\n                    }\n                }\n                break; // Stop parsing digits.\n            }\n\n            // If we are still in padding mode (only leading spaces or ASCII '0's seen so far)\n            if (stillPadding) {\n                if (currentByte == '0') { // ASCII '0'\n                    continue; // Treat leading ASCII '0's as padding.\n                }\n                // If we reach here, `currentByte` is not ' ', NUL, or '0'. So padding has ended.\n                stillPadding = false;\n            }\n\n            // Now, `stillPadding` is false. We are in the non-padding part of the string.\n            // Current character must be an octal digit.\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, i, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // Convert from ASCII\n        }\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}