{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    // Must be at least 2 bytes long.\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Field length must be at least 2 bytes long\");\n    }\n    int endIndex = offset + length;\n\n    // Special case: if every byte is NUL then this denotes a missing field.\n    boolean allZeros = true;\n    for (int i = offset; i < endIndex; i++) {\n        if (buffer[i] != 0) {\n            allZeros = false;\n            break;\n        }\n    }\n    if (allZeros) {\n        return 0L;\n    }\n\n    // Skip leading spaces.\n    int pos = offset;\n    while (pos < endIndex && buffer[pos] == (byte) ' ') {\n        pos++;\n    }\n    if (pos >= endIndex) {\n        throw new IllegalArgumentException(\"No octal digits found in non-null field\");\n    }\n\n    long result = 0;\n    int digitStart = pos;\n    boolean foundDigit = false;\n    // Parse octal digits until a delimiter (either NUL or space) is encountered.\n    while (pos < endIndex) {\n        byte current = buffer[pos];\n        if (current == 0 || current == (byte) ' ') {\n            // Termination of the number.\n            break;\n        }\n        if (current < '0' || current > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, digitStart, current));\n        }\n        foundDigit = true;\n        result = (result << 3) + (current - '0'); // convert from ASCII octal digit\n        pos++;\n    }\n    if (!foundDigit) {\n        throw new IllegalArgumentException(\"No octal digits found in non-null field\");\n    }\n    // Must have a trailing delimiter.\n    if (pos >= endIndex) {\n        throw new IllegalArgumentException(\"Missing trailing delimiter in octal field\");\n    }\n    byte delimiter = buffer[pos];\n    if (!(delimiter == 0 || delimiter == (byte) ' ')) {\n        throw new IllegalArgumentException(\"Invalid trailing delimiter in octal field\");\n    }\n    // Any remaining bytes must be either NUL or space.\n    pos++;\n    while (pos < endIndex) {\n        byte extra = buffer[pos];\n        if (extra != 0 && extra != (byte) ' ') {\n            throw new IllegalArgumentException(\"Invalid character after trailing delimiter in octal field\");\n        }\n        pos++;\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}