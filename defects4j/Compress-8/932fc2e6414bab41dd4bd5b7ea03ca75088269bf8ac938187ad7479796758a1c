{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    // The numeric field must be at least 2 bytes long.\n    if (length < 2) {\n        throw new IllegalArgumentException(\"A numeric field must be at least 2 bytes long\");\n    }\n    int end = offset + length;\n    \n    // If every byte in the field is NUL, then return 0.\n    boolean allNull = true;\n    for (int i = offset; i < end; i++) {\n        if (buffer[i] != 0) {\n            allNull = false;\n            break;\n        }\n    }\n    if (allNull) {\n        return 0L;\n    }\n    \n    long result = 0L;\n    int index = offset;\n    \n    // Skip any leading spaces.\n    while (index < end && buffer[index] == (byte)' ') {\n        index++;\n    }\n    \n    // There must be at least one octal digit now.\n    int digitStart = index;\n    while (index < end && buffer[index] >= (byte)'0' && buffer[index] <= (byte)'7') {\n        result = (result << 3) + (buffer[index] - (byte)'0');\n        index++;\n    }\n    if (index == digitStart) {\n        throw new IllegalArgumentException(\"No octal digits in numeric field\");\n    }\n    \n    // The next character (the terminator) must be either a space or NUL.\n    if (index >= end) {\n        throw new IllegalArgumentException(\"Missing terminating null or space in numeric field\");\n    }\n    byte term = buffer[index];\n    if (term != 0 && term != (byte)' ') {\n        throw new IllegalArgumentException(\"Invalid terminating character in numeric field: \" + term);\n    }\n    index++; // Skip the terminator.\n    \n    // Any remaining bytes in the field must be either a space or NUL.\n    while (index < end) {\n        byte b = buffer[index];\n        if (b != 0 && b != (byte)' ') {\n            throw new IllegalArgumentException(\"Invalid character in trailer of numeric field: \" + b);\n        }\n        index++;\n    }\n    \n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}