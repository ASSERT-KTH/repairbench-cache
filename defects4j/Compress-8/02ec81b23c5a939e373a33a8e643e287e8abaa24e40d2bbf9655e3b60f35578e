{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        // 1. Length check (as per Javadoc and test failure)\n        if (length < 2) {\n            throw new IllegalArgumentException(\"Length must be at least 2 bytes\");\n        }\n\n        long    result = 0;\n        int     end = offset + length;\n        int     pos = offset;\n\n        // 2. Handle All-NULs case first (as documented)\n        boolean allNuls = true;\n        for (int i = offset; i < end; i++) {\n            // Basic bounds check although offset/length validity is usually assumed by caller\n            if (i >= buffer.length) {\n                 throw new IllegalArgumentException(\"Attempt to parse octal outside buffer boundaries\");\n            }\n            if (buffer[i] != 0) {\n                allNuls = false;\n                break;\n            }\n        }\n        if (allNuls) {\n            return 0L;\n        }\n\n        // 3. Skip leading spaces\n        while (pos < end && buffer[pos] == ' ') {\n            pos++;\n        }\n\n        // 4. Check for early NUL termination if buffer is not all NULs\n        // This handles cases like \"\\0abc\", \" \\0abc\", \"[0,0,' ']\", \"[' ',0,0,0]\" which are invalid\n        // according to the tests implicitly requiring digits if not all NULs.\n        if (pos < end && buffer[pos] == 0) {\n             throw new IllegalArgumentException(\n                     \"Invalid octal entry: Starts with NUL but is not an all-NUL entry. Offset \" + offset + \", length \" + length);\n        }\n\n        // 5. Parse octal digits until the first space or NUL\n        int startOfDigits = pos; // Remember where digits started (or should have)\n        while (pos < end) {\n            final byte currentByte = buffer[pos];\n\n            // NUL or space terminates the octal number\n            if (currentByte == 0 || currentByte == ' ') {\n                break;\n            }\n\n            // Check for invalid characters (must be 0-7)\n            if (currentByte < '0' || currentByte > '7') {\n                 throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, pos, currentByte));\n            }\n\n            result = (result << 3) + (currentByte - '0');\n            pos++;\n        }\n\n        // 6. Post-parsing validation\n\n        // Check if we hit the end without finding a terminator\n        if (pos == end) {\n            throw new IllegalArgumentException(\"Parse octal requires a trailing NUL or space character. Offset \" + offset + \", length \" + length);\n        }\n        \n        // Check the character at termination position is indeed NUL or space (should be true by loop logic)\n        if (buffer[pos] != 0 && buffer[pos] != ' ') {\n             // This indicates a logic error in the parsing loop itself\n             throw new IllegalStateException(\"Internal parse error: terminator mismatch. Offset \" + offset + \", length \" + length);\n        }\n\n\n        // Check that all characters *after* the first terminator (space or NUL)\n        // up to the specified length are also either space or NUL.\n        for (int i = pos + 1; i < end; i++) {\n            if (buffer[i] != ' ' && buffer[i] != 0) {\n                throw new IllegalArgumentException(\n                   \"Invalid byte \" + buffer[i] + \" after NUL/space terminator at offset \" + (pos - offset) +\n                    \" in '\" + new String(buffer, offset, length) + \"'\"); // Using default charset for error message\n            }\n        }\n\n        // If we skipped spaces and immediately found a terminator (e.g., \"  \\0\"),\n        // or if the input was just a terminator (\"\\0\" or \" \"), result is 0, which is correct.\n        // The case where pos == startOfDigits means no digits were parsed.\n\n        return result;\n    }\n\n    /** Helper method to generate exception message */\n    private static String exceptionMessage(byte[] buffer, final int offset, final int length, int idx, byte currentByte) {\n         // Use String constructor that takes range and default charset (sufficient for error message)\n         final String s = new String(buffer, offset, length);\n         final StringBuilder msg = new StringBuilder();\n         msg.append(\"Invalid byte \").append(currentByte).append(\" (\").append((char)currentByte).append(\") \");\n         msg.append(\"at relative offset \").append(idx - offset); // offset relative to start of parsed slice\n         msg.append(\" in '\").append(s).append(\"'. Offset \").append(offset).append(\", length \").append(length).append(\".\");\n         return msg.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}