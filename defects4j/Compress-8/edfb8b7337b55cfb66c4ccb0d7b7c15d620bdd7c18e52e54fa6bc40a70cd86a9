{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected,\n     *         or if NUL bytes are improperly used.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long result = 0;\n        int end = offset + length;\n        int numberEnd = -1; // Index of the terminator NUL/space\n        boolean parsingDigits = false; // Started parsing digits '0'-'7'\n\n        // 1. Basic validation\n        if (length < 2) {\n            throw new IllegalArgumentException(\"Length must be at least 2 bytes.\");\n        }\n\n        // 2. Check for all NULs special case.\n        // Based on tests, this seems to mean the buffer slice *only* contains NULs.\n        boolean allNulsStrict = true;\n        for (int i = offset; i < end; i++) {\n            if (buffer[i] != 0) {\n                allNulsStrict = false;\n                break;\n            }\n        }\n        if (allNulsStrict) {\n            return 0L; // Javadoc: \"input buffer is allowed to contain all NULs... returns 0L\"\n        }\n\n        // 3. Main parsing loop\n        for (int i = offset; i < end; i++) {\n            final byte currentByte = buffer[i];\n\n            if (currentByte == 0) {\n                numberEnd = i; // NUL terminates parsing\n                break;\n            }\n\n            if (currentByte == ' ') {\n                if (parsingDigits) {\n                    numberEnd = i; // Space terminates after digits\n                    break;\n                }\n                // Still in leading space padding - continue\n                continue;\n            }\n\n            // Check for invalid characters (anything not 0-7, space, NUL)\n            if (currentByte < '0' || currentByte > '7') {\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, i, currentByte));\n            }\n\n            // It's a digit '0'-'7'\n            parsingDigits = true;\n            // CheckStyle:MagicNumber OFF\n            result = (result << 3) + (currentByte - '0'); // accumulate octal value\n            // CheckStyle:MagicNumber ON\n        }\n\n        // 4. Post-loop validation\n\n        // Case 1: Loop finished without break (numberEnd == -1)\n        if (numberEnd == -1) {\n            // Reached end. Must have trailing NUL or space.\n            // If we were parsing digits, the last char buffer[end-1] must have been a digit -> Error.\n            // If we only saw spaces, the last char buffer[end-1] must have been a space -> OK.\n            if (!parsingDigits) { // Only leading spaces encountered up to end?\n                 // This implies the buffer was like \"   \". We need buffer[end-1] == ' '.\n                 if (end > offset && buffer[end - 1] == ' ') {\n                     return 0L; // All spaces, ending in space is valid.\n                 }\n                 // Otherwise fall through to throw exception\n            }\n            // If parsingDigits was true, or if !parsingDigits but last char wasn't space.\n            throw new IllegalArgumentException(\"Missing required trailing NUL or space character in octal value.\");\n\n        } else {\n            // Case 2: Loop broke at numberEnd (found NUL or space terminator)\n            // Check bytes AFTER numberEnd up to end for validity.\n            final byte terminator = buffer[numberEnd];\n\n            for (int i = numberEnd + 1; i < end; i++) {\n                final byte followByte = buffer[i];\n                // Apply strict rules derived from tests: after NUL only NUL, after space only NUL or space.\n                if (terminator == 0) { // Terminator NUL requires following NULs\n                    if (followByte != 0) {\n                        throw new IllegalArgumentException(\n                                \"Expected only NUL bytes after NUL terminator at index \" + numberEnd + \", found byte \" + followByte + \" at index \" + i);\n                    }\n                } else { // Terminator space requires following NUL or space\n                    if (followByte != 0 && followByte != ' ') {\n                        throw new IllegalArgumentException(\n                                \"Expected only NUL or space bytes after space terminator at index \" + numberEnd + \", found byte \" + followByte + \" at index \" + i);\n                    }\n                }\n            }\n        }\n\n        // If all validation passed\n        return result;\n    }\n\n    // Helper method to format exception messages (assuming it exists or is added elsewhere)\n    private static String exceptionMessage(byte[] buffer, int offset, int length, int idx, byte currentByte) {\n         // In a real scenario, reuse TarUtils.parseName or format appropriately\n         String contentPreview = TarUtils.parseName(buffer, offset, length); // May truncate at NUL\n         return \"Invalid byte \" + currentByte + \" at offset \" + idx + \" in '\" + contentPreview + \"' len=\" + length;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}