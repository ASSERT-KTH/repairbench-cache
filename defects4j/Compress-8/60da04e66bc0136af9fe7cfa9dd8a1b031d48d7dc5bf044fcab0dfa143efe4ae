{
    "generation": "import java.util.Arrays; // If needed for exception message\n\n/**\n * Helper method to create exception message (assuming definition is available/similar)\n * Using a format inspired by the original code's likely helper.\n */\nprivate static String exceptionMessage(byte[] buffer, int offset, int length, int idx, byte currentByte) {\n    final StringBuilder sb = new StringBuilder();\n    sb.append(\"Invalid byte '\").append((char) currentByte).append(\"' (\").append(currentByte);\n    // The original exceptionMessage likely calculated offset relative to buffer start (idx)\n    // rather than relative to the slice start (idx - offset). Let's use idx.\n    sb.append(\") at offset \").append(idx);\n    sb.append(\" in '\");\n    // Replace NULs for better readability in error messages, similar to original context display\n    // Use replaceAll(\"\\u0000\", \"{NUL}\") as used in the failing test description.\n    sb.append(new String(buffer, offset, length).replaceAll(\"\\u0000\", \"{NUL}\"));\n    sb.append(\"'.\");\n    return sb.toString();\n}\n\n/**\n * Parse an octal string from a buffer.\n * Leading spaces are ignored.\n * The buffer must contain a trailing space or NUL,\n * and may contain an additional trailing space or NUL.\n *\n * The input buffer is allowed to contain all NULs,\n * in which case the method returns 0L\n * (this allows for missing fields).\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal string.\n * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n */\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     start = offset;\n    int     end = offset + length;\n    int     pos = start; // Current position\n    boolean stillPadding = true; // Are we processing leading space or zero?\n\n    // 1. Length Check - Fix for the reported test failure\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    int trailerPos = -1; // Position where the first NUL or space trailer was found\n\n    // Main parsing loop: find digits and first terminator\n    for (; pos < end; pos++) {\n        final byte currentByte = buffer[pos];\n\n        // Check for NUL or space - potential trailer\n        if (currentByte == 0 || currentByte == ' ') {\n            trailerPos = pos; // Found the first NUL/space\n            break; // End digit parsing phase.\n        }\n\n        // Skip leading zeros *after* spaces (if any)\n        if (currentByte == '0' && stillPadding) {\n            continue; // Still padding\n        }\n\n        // Encountered a non-space/NUL/leading-zero byte. No longer padding.\n        stillPadding = false;\n\n        // Check for valid octal digit '0'-'7'\n        // Fix: Moved the check here to catch invalid chars after padding ends\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, pos, currentByte));\n        }\n\n        // Accumulate octal value\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    // --- Post-loop validation ---\n\n    // If no NUL/space trailer was found before loop end\n    if (trailerPos == -1) {\n         // This implies the buffer ended with octal digits (e.g., \"123\") or only invalid chars.\n         // If the loop finished because pos == end, no terminator was found within length.\n         throw new IllegalArgumentException(\"Missing mandatory trailing NUL or space character.\");\n    }\n\n    // Fix: Check characters from the first trailer position to the end.\n    // All characters in the trailer section must be NUL or space.\n    for (int k = trailerPos; k < end; k++) {\n        if (buffer[k] != 0 && buffer[k] != ' ') {\n            throw new IllegalArgumentException(\n                // Use the same exception message helper for consistency\n                exceptionMessage(buffer, offset, length, k, buffer[k]) +\n                \" Character is supposed to be part of the NUL or space trailer.\");\n        }\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}