{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    if (buffer == null) {\n        throw new IllegalArgumentException(\"buffer is null\");\n    }\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length must be at least 2\");\n    }\n    if (offset < 0 || length > buffer.length - offset) {\n        throw new IllegalArgumentException(\"Invalid offset/length\");\n    }\n\n    final int end = offset + length;\n\n    // Check if all NULs (special case: return 0)\n    boolean allNuls = true;\n    for (int i = offset; i < end; i++) {\n        if (buffer[i] != 0) {\n            allNuls = false;\n            break;\n        }\n    }\n    if (allNuls) {\n        return 0L;\n    }\n\n    int start = offset;\n\n    // Skip leading spaces\n    while (start < end && buffer[start] == (byte) ' ') {\n        start++;\n    }\n\n    // Now, must be at least one digit, and up to one or two trailer\n    int pos = start;\n    long result = 0;\n    boolean digitSeen = false;\n    for (; pos < end; pos++) {\n        byte curr = buffer[pos];\n        if (curr >= '0' && curr <= '7') {\n            result = (result << 3) + (curr - '0');\n            digitSeen = true;\n        } else {\n            break;\n        }\n    }\n\n    if (!digitSeen) {\n        throw new IllegalArgumentException(\"No octal digits found: \" + exceptionMessage(buffer, offset, length, start, pos < end ? buffer[pos] : 0));\n    }\n\n    // After digits, must be a trailer: space or NUL\n    // Up to two trailing spaces/NULs are allowed (POSIX)\n    int trailers = 0;\n    for (int i = pos; i < end && trailers < 2; i++) {\n        byte curr = buffer[i];\n        if (curr == (byte) ' ' || curr == 0) {\n            trailers++;\n        } else {\n            // Any other data is illegal\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, i, curr));\n        }\n    }\n    if (trailers == 0) {\n        throw new IllegalArgumentException(\"Missing trailing space or NUL: \" + exceptionMessage(buffer, offset, length, pos, pos < end ? buffer[pos] : 0));\n    }\n    // After (pos+trailers), there must be nothing else than trailers up to end\n    for (int i = pos + trailers; i < end; i++) {\n        byte curr = buffer[i];\n        if (curr != (byte) ' ' && curr != 0) {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, i, curr));\n        }\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}