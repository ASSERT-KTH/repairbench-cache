{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     * Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.\n     *\n     * The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        // Enforce the minimum length requirement\n        if (length < 2) {\n            throw new IllegalArgumentException(\"length must be at least 2 bytes\");\n        }\n\n        // Special case: if the buffer segment contains only NULs, return 0L\n        boolean isAllNuls = true;\n        for (int i = offset; i < offset + length; i++) {\n            if (buffer[i] != 0) {\n                isAllNuls = false;\n                break;\n            }\n        }\n        if (isAllNuls) {\n            return 0L;\n        }\n\n        long result = 0;\n        int end = offset + length;\n        boolean stillSkippingLeadingSpaces = true; // True if we are still skipping leading space characters.\n        boolean foundActualDigit = false; // True if we have encountered at least one valid octal digit (0-7).\n\n        for (int i = offset; i < end; i++){\n            final byte currentByte = buffer[i];\n\n            if (currentByte == (byte) ' ') {\n                if (stillSkippingLeadingSpaces) {\n                    continue; // Skip leading spaces\n                }\n                // If we are not skipping leading spaces, this space must be a trailing terminator.\n                // All subsequent characters must also be space or NUL.\n                for (int j = i; j < end; j++) {\n                    if (buffer[j] != 0 && buffer[j] != (byte) ' ') {\n                        throw new IllegalArgumentException(\n                                exceptionMessage(buffer, offset, length, j, buffer[j]));\n                    }\n                }\n                // Valid trailing space found, stop parsing.\n                break;\n            }\n\n            // Once a non-space character is encountered, we are no longer skipping leading spaces.\n            stillSkippingLeadingSpaces = false;\n\n            if (currentByte == 0) {\n                // NUL is a valid terminator.\n                // If we haven't found any actual digits yet, and it's not an \"all NULs\" field (already handled),\n                // then this NUL byte is an invalid character in this position (e.g., embedded NUL).\n                // Example: `byte[]{0,0,' '}` or `{' ',0,0,0}`.\n                if (!foundActualDigit) {\n                    throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, i, currentByte));\n                }\n\n                // If we have found actual digits, this NUL is a valid trailing terminator.\n                // All subsequent characters must also be NUL or space.\n                for (int j = i; j < end; j++) {\n                    if (buffer[j] != 0 && buffer[j] != (byte) ' ') {\n                        throw new IllegalArgumentException(\n                                exceptionMessage(buffer, offset, length, j, buffer[j]));\n                    }\n                }\n                // Valid trailing NUL found, stop parsing.\n                break;\n            }\n\n            // If we are here, currentByte is not a space or NUL. It must be an octal digit.\n            if (currentByte < '0' || currentByte > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, i, currentByte));\n            }\n            \n            // This is a valid octal digit.\n            foundActualDigit = true; \n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        }\n\n        // If the loop completes (i.e., `i == end`) without hitting a `break` statement:\n        // This means the buffer ended without a required trailing space or NUL.\n        // This is an error if any actual digits were parsed.\n        // If no digits were found (e.g., \"   \" or \"000\"), `result` will be 0, which is correct.\n        if (foundActualDigit) {\n            // No trailing NUL or space found, which is a requirement if actual digits were present.\n            throw new IllegalArgumentException(\n                \"No trailing NUL or space found. Buffer: \" +\n                exceptionMessage(buffer, offset, length)); // Use offset here for general message\n        }\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}