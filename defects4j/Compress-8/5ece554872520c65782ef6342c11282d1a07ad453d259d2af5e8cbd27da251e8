{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    // The length must be at least 2 bytes.\n    if (length < 2) {\n        throw new IllegalArgumentException(\"octal field must be at least 2 bytes long\");\n    }\n    int end = offset + length;\n\n    // If the entire field is NULs then this field represents a missing value.\n    boolean allNul = true;\n    for (int i = offset; i < end; i++) {\n        if (buffer[i] != 0) {\n            allNul = false;\n            break;\n        }\n    }\n    if (allNul) {\n        return 0;\n    }\n\n    // Skip only leading spaces (not zeros \u2013 those are valid digits).\n    int start = offset;\n    while (start < end && buffer[start] == (byte) ' ') {\n        start++;\n    }\n    \n    // Now, the digit sequence starts at 'start'.\n    // There must be at least one octal digit.\n    int digitStart = start;\n    int i = digitStart;\n    while (i < end && buffer[i] != 0 && buffer[i] != (byte) ' ') {\n        if (buffer[i] < '0' || buffer[i] > '7') {\n            throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, digitStart, buffer[i])\n            );\n        }\n        i++;\n    }\n    if (i == digitStart) {\n        // No octal digits were found (for example, the first non-space is a delimiter).\n        throw new IllegalArgumentException(\n            exceptionMessage(buffer, offset, length, digitStart, buffer[digitStart])\n        );\n    }\n\n    // The digit sequence must be immediately terminated by a delimiter (a space or NUL).\n    if (i == end) {\n        throw new IllegalArgumentException(\"No trailing space or NUL found in octal field\");\n    }\n\n    // After the digit sequence, the remaining characters (if any) must all be either space or NUL.\n    for (int j = i; j < end; j++) {\n        if (buffer[j] != 0 && buffer[j] != (byte) ' ') {\n            throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, digitStart, buffer[j])\n            );\n        }\n    }\n\n    // Convert the digit sequence from octal.\n    long result = 0;\n    for (int j = digitStart; j < i; j++) {\n        result = (result << 3) + (buffer[j] - (byte) '0');\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}