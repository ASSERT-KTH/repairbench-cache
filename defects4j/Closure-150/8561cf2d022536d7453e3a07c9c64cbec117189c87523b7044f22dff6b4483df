{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          if (NodeUtil.isNameDeclaration(parent)) {\n            handleNameDeclaration(t, n, parent);\n          } else {\n            defineDeclaredFunction(n, parent);\n          }\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n      }\n    }\n\n    private void handleNameDeclaration(NodeTraversal t, Node n, Node parent) {\n      Node grandparent = parent.getParent();\n      if (grandparent != null && grandparent.getType() == Token.ASSIGN) {\n        // Handle namespaced function stubs\n        if (grandparent.getFirstChild() == parent &&\n            grandparent.getLastChild().getType() == Token.OBJECTLIT) {\n          defineNamespacedFunctionStub(t, n, grandparent);\n        } else {\n          // Handle collected function stubs\n          defineCollectedFunctionStub(t, n, grandparent);\n        }\n      }\n    }\n\n    private void defineNamespacedFunctionStub(NodeTraversal t, Node n, Node assign) {\n      Node objectLit = assign.getLastChild();\n      for (Node key : objectLit.children()) {\n        String propertyName = key.getString();\n        Node value = key.getFirstChild();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(t.getCompiler(), value);\n          if (jsdoc != null) {\n            String namespace = assign.getFirstChild().getQualifiedName();\n            if (namespace != null) {\n              String qualifiedName = namespace + \".\" + propertyName;\n              ObjectType namespaceType = (ObjectType) findNameType(namespace, scope);\n              if (namespaceType != null) {\n                JSType type = getFunctionTypeFromJSDoc(jsdoc, t.getScope());\n                namespaceType.defineDeclaredProperty(propertyName, type, t.getScope());\n                scope.declare(qualifiedName, type, t.getLineno(n), t.getCharno(n), n);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    private void defineCollectedFunctionStub(NodeTraversal t, Node n, Node assign) {\n      JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(t.getCompiler(), n);\n      if (jsdoc != null) {\n        String name = n.getFirstChild().getString();\n        JSType type = getFunctionTypeFromJSDoc(jsdoc, t.getScope());\n        scope.declare(name, type, t.getLineno(n), t.getCharno(n), n);\n      }\n    }\n\n    private JSType getFunctionTypeFromJSDoc(JSDocInfo jsdoc, StaticScope<JSType> scope) {\n      JSTypeRegistry registry = scope.getScope().getJSTypeRegistry();\n      FunctionTypeBuilder builder = new FunctionTypeBuilder(registry);\n      builder.withParamsNode(jsdoc.getParameterCount(), jsdoc.getParameterType(0));\n      builder.withReturnType(jsdoc.getReturnType());\n      return builder.build();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}