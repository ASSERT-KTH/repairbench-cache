{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) {\n        // The first node we visit is the function.\n        // Its parameters are handled in handleFunctionInputs\n        // after the formal parameters have been added to the scope.\n        handleFunctionInputs(n);\n        return;\n      }\n\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // For named function expressions (e.g., var x = function y() {}), the function's own name 'y' is handled in the NAME case.\n          // For other functions (anonymous or named function declarations like function foo() {}), define it here.\n          defineDeclaredFunction(n, parent);\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n        case Token.LP:\n          // This means we are visiting the parameter list of the scope's\n          // root function. We've already processed these.\n          if (parent == scope.getRootNode()) {\n            return;\n          }\n          break;\n        case Token.NAME:\n          // If this is a child of a FUNCTION node, it's a named function\n          // expression. The name needs to be added to the scope.\n          if (parent.getType() == Token.FUNCTION) {\n            defineDeclaredFunction(parent, parent.getParent());\n            return;\n          }\n          // If this is a variable definition, it's handled by defineVar.\n          // If this is a function parameter, it's handled by handleFunctionInputs.\n          // If this is a CATCH parameter, it's handled by defineCatch.\n          // Otherwise, it's a usage of a name or a variable definition.\n          defineName(n, parent);\n          break;\n        case Token.ASSIGN:\n          // For assignments to properties, this is handled by defineAssignedProperty.\n          // For assignments to names, this is handled by defineName.\n          defineAssigned(n, parent);\n          break;\n        case Token.GETPROP:\n        case Token.GETELEM:\n          // If this is a property get with a JSDoc annotation, and it's not\n          // part of an assignment, then it's a stub declaration.\n          if (n.getJSDocInfo() != null &&\n              // i.e., \"foo.bar = ...\" is handled by Token.ASSIGN\n              parent.getType() != Token.ASSIGN) {\n            defineStubByAnnotation(n, parent);\n          }\n          break;\n        case Token.CALL:\n          defineCall(n, parent);\n          break;\n        case Token.RETURN:\n          defineReturn(n, parent);\n          break;\n        case Token.BLOCK:\n          // Only interesting in the global scope where it means it's a script.\n          if (scope.isGlobal() && n.getParent() == null) {\n            defineScript(n, parent);\n          }\n          break;\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}