{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Don't visit the scope root itself.\n      if (n == scope.getRootNode()) {\n        return;\n      }\n\n      // Handle function parameters when visiting the PARAM_LIST node.\n      if (n.isParamList() && parent.isFunction()) {\n        // Ensure the parent function matches the scope root,\n        // as we only handle the inputs for the function defining this scope.\n        if (parent == scope.getRootNode()) {\n            handleFunctionInputs(parent);\n        }\n        // We return here because PARAM_LIST content (NAME nodes for parameters)\n        // are handled by handleFunctionInputs.\n        return;\n      }\n\n      // Assign types to literals like numbers, strings, booleans, null, this, regexes.\n      attachLiteralTypes(n);\n\n      // Handle declarations within the local scope.\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // Handle function declarations (e.g., function f() {}).\n          // Function expressions (e.g., var f = function() {}) are handled\n          // by VAR or ASSIGN nodes.\n          // The check `parent.getType() == Token.NAME` handles named function\n          // expressions (var f = function g() {}) where 'g' is local to the function.\n          if (parent.getType() == Token.NAME) {\n            // This is the name node of a named function expression. e.g. N in\n            // var x = function N() {}; The name N is only visible within the\n            // function scope. Do nothing here.\n            return;\n          }\n          // If it's not a function expression name, define the function in the current scope.\n          defineDeclaredFunction(n, parent);\n          break;\n\n        case Token.CATCH:\n          // Define the catch parameter.\n          defineCatch(n, parent);\n          break;\n\n        case Token.VAR:\n          // Define variables declared with 'var'.\n          defineVar(n, parent);\n          break;\n\n        case Token.EXPR_RESULT:\n          // Handle declarations via expression statements with JSDoc.\n          // Examples:\n          // /** @type {Namespace} */ var ns = {}; // Handled by VAR\n          // /** @type {number} */ ns.property;    // Handled here\n          // /** @param {string} s */ ns.functionStub; // Handled here\n          // /** @return {boolean} */ this.methodStub; // Handled here (inside constructor/method)\n          // /** @enum {T} */ ns.E = {...};           // Handled here\n          // /** @constructor */ ns.C = function() {}; // Handled here\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null) {\n            Node child = n.getFirstChild();\n            // Check for assignment (ns.prop = value) or standalone name (ns.prop;)\n            if (child.isAssign()) {\n              // Handles: /** @enum {T} */ ns.E = {...};\n              // Handles: /** @constructor */ ns.C = function() {};\n              // Handles: /** @interface */ ns.I = function() {};\n              // We declare the name on the left side of the assignment.\n              Node potentialName = child.getFirstChild();\n              // Check if the LHS is a qualified name (a.b.c) or this.prop\n              if (potentialName.isQualifiedName() ||\n                  (potentialName.isGetProp() && potentialName.getFirstChild().isThis())) {\n                 maybeDeclareQualifiedName(t, info, potentialName, n, child);\n              }\n            } else if (child.isQualifiedName() ||\n                       (child.isGetProp() && child.getFirstChild().isThis())) {\n              // Handles: /** @type {T} */ ns.prop;\n              // Handles: /** @param {A} x */ ns.method;\n              // Handles: /** @return {T} */ this.prop;\n              maybeDeclareQualifiedName(t, info, child, n, child);\n            }\n          }\n          break;\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}