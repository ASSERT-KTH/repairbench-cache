{
    "generation": "    /**\n     * Visit a node in a local scope, and add any local variables or catch\n     * parameters into the local symbol table.\n     *\n     * @param t The node traversal.\n     * @param n The node being visited.\n     * @param parent The parent of n\n     */\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      // Handle JSDoc on various nodes that declare types or properties,\n      // especially qualified names.\n      // JSDoc might be on `n` or on its parent (e.g., EXPR_RESULT for `goog.foo;`).\n      JSDocInfo info = n.getJSDocInfo();\n      // If info is null, check parent for EXPR_RESULT which often carries JSDoc for its child expression.\n      if (info == null && parent != null && parent.getType() == Token.EXPR_RESULT) {\n        info = parent.getJSDocInfo();\n      }\n\n      if (info != null) {\n        // If the node is a qualified name (NAME, GETPROP, GETELEM) and has JSDoc\n        // that declares type information (e.g., @type, @const, @param, @return),\n        // define it in the current scope.\n        if (n.isQualifiedName()) {\n          // Check for JSDoc that indicates a type declaration or constant.\n          // This covers cases like `/** @param {number} x */ goog.foo;`\n          // and `/** @return {number} */ this.foo;`.\n          if (info.hasTypeInformation() || info.isConstant()) {\n            defineQualifiedNameInLocalScope(n, parent);\n            // If we've successfully defined a symbol based on JSDoc for a qualified name,\n            // we can return as its scope creation purpose is fulfilled.\n            return;\n          }\n        }\n      }\n\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // The original code had: `if (parent.getType() == Token.NAME) { return; }`\n          // This check is generally incorrect for the AST structure of FUNCTION nodes\n          // and could lead to functions not being properly defined.\n          // Removed to ensure `defineDeclaredFunction` is always called for FUNCTION nodes.\n          defineDeclaredFunction(n, parent);\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}