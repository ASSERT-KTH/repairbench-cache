{
    "generation": "  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT:  // Logical NOT\n      case Token.NEG:  // Unary minus\n      case Token.BITNOT: // Bitwise NOT\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Binary operators are valid if both children are valid.\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.ADD: // Arithmetic ADDITION\n      case Token.SUB: // Arithmetic SUBTRACTION\n      case Token.MUL: // Arithmetic MULTIPLICATION\n      case Token.DIV: // Arithmetic DIVISION\n      case Token.MOD: // Arithmetic MODULO\n      case Token.AND: // Logical AND\n      case Token.OR:  // Logical OR\n      case Token.EQ:  // Equality\n      case Token.NE:  // Inequality\n      case Token.LT:  // Less Than\n      case Token.LE:  // Less Than or Equal\n      case Token.GT:  // Greater Than\n      case Token.GE:  // Greater Than or Equal\n      case Token.SHEQ: // Strict Equality\n      case Token.SHNE: // Strict Inequality\n      case Token.LSH:  // Left Shift\n      case Token.RSH:  // Right Shift\n      case Token.URSH: // Unsigned Right Shift\n        // Binary operators must have exactly two children.\n        if (val.getChildCount() == 2) {\n          return isValidDefineValue(val.getFirstChild(), defines) &&\n                 isValidDefineValue(val.getLastChild(), defines);\n        }\n        return false; // Malformed binary operation (e.g., wrong child count)\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP: // For qualified names like 'FOO.BAR'\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n        // If it's a NAME but not a qualified name (e.g., a simple variable not in defines),\n        // or a GETPROP that isn't a qualified name, it's not a valid define value.\n        break; // Fall through to the default false.\n    }\n    return false; // Default: Any other token type is not a valid define value.\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}