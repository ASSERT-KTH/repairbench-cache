{
    "generation": "  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT:    // Logical NOT (!)\n      case Token.NEG:    // Unary negation (-)\n      case Token.BITNOT: // Bitwise NOT (~)\n        // Ensure the child exists before recursively checking.\n        // A unary operator node should always have at least one child.\n        if (val.hasChildren()) {\n          return isValidDefineValue(val.getFirstChild(), defines);\n        }\n        return false; // Malformed unary op node\n\n      // Binary operators are valid if both children are valid.\n      // This includes arithmetic, bitwise, comparison, and logical operators.\n      case Token.BITAND: // Bitwise AND (&)\n      case Token.BITOR:  // Bitwise OR (|)\n      case Token.BITXOR: // Bitwise XOR (^)\n      case Token.ADD:    // Addition (+)\n      case Token.SUB:    // Subtraction (-)\n      case Token.MUL:    // Multiplication (*)\n      case Token.DIV:    // Division (/)\n      case Token.MOD:    // Modulo (%)\n      case Token.EQ:     // Equality (==)\n      case Token.NE:     // Inequality (!=)\n      case Token.LT:     // Less than (<)\n      case Token.LE:     // Less than or equal to (<=)\n      case Token.GT:     // Greater than (>)\n      case Token.GE:     // Greater than or equal to (>=)\n      case Token.AND:    // Logical AND (&&)\n      case Token.OR:     // Logical OR (||)\n        // Ensure both children exist before recursively checking.\n        // A binary operator node should always have two children.\n        if (val.getChildCount() >= 2) {\n          return isValidDefineValue(val.getFirstChild(), defines) &&\n                 isValidDefineValue(val.getLastChild(), defines);\n        }\n        return false; // Malformed binary op node\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n        // If it's a NAME or GETPROP but not a qualified name (e.g., 'this'),\n        // or if it's a qualified name but not in 'defines', it's not a valid define value.\n        return false;\n\n      // Other types (e.g., NULL, UNDEFINED, function calls, object literals, array literals, etc.)\n      // are not valid define values.\n      default:\n        return false;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}