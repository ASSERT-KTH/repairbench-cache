{
    "generation": "  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Unary operators are valid if the child is valid.\n      // These operators typically only have one child.\n      case Token.NOT:    // !\n      case Token.NEG:    // unary -\n      case Token.BITNOT: // ~\n      case Token.POS:    // unary + (e.g., +1)\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Binary operators are valid if both children are valid.\n      // This includes arithmetic, bitwise, comparison, and logical operators.\n      // These operators typically have two children.\n      case Token.ADD:    // +\n      case Token.SUB:    // -\n      case Token.MUL:    // *\n      case Token.DIV:    // /\n      case Token.MOD:    // %\n      case Token.BITAND: // &\n      case Token.BITOR:  // |\n      case Token.BITXOR: // ^\n      case Token.LSH:    // <<\n      case Token.RSH:    // >>\n      case Token.URSH:   // >>>\n      case Token.EQ:     // ==\n      case Token.NE:     // !=\n      case Token.SHEQ:   // ===\n      case Token.SHNE:   // !==\n      case Token.LT:     // <\n      case Token.LE:     // <=\n      case Token.GT:     // >\n      case Token.GE:     // >=\n      case Token.AND:    // &&\n      case Token.OR:     // ||\n        return isValidDefineValue(val.getFirstChild(), defines) &&\n               isValidDefineValue(val.getSecondChild(), defines);\n\n      // Ternary operator (condition ? true_val : false_val)\n      case Token.HOOK: // ? :\n        return isValidDefineValue(val.getFirstChild(), defines) && // condition\n               isValidDefineValue(val.getSecondChild(), defines) && // true_value\n               isValidDefineValue(val.getLastChild(), defines);     // false_value\n\n      // Names (identifiers) and properties (e.g., foo.bar) are valid\n      // if and only if they represent existing defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n        // Fall through to false if it's not a qualified name (e.g. array access).\n        break;\n    }\n    return false;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}