{
    "generation": "  /**\n   * Determines whether the given value may be assigned to a define.\n   *\n   * @param val The value being assigned.\n   * @param defines The list of names of existing defines.\n   */\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT: // Logical NOT (!)\n      case Token.NEG: // Unary minus (-)\n      case Token.BITNOT: // Bitwise NOT (~)\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Binary operators are valid if all their children are valid.\n      // This includes arithmetic, bitwise, and comparison operators.\n      case Token.ADD: // +\n      case Token.SUB: // -\n      case Token.MUL: // *\n      case Token.DIV: // /\n      case Token.MOD: // %\n      case Token.BITAND: // &\n      case Token.BITOR: // |\n      case Token.BITXOR: // ^\n      case Token.EQ:   // ==\n      case Token.NE:   // !=\n      case Token.SHEQ: // ===\n      case Token.SHNE: // !==\n      case Token.LT:   // <\n      case Token.LE:   // <=\n      case Token.GT:   // >\n      case Token.GE:   // >=\n        for (Node child : val.children()) {\n          if (!isValidDefineValue(child, defines)) {\n            return false;\n          }\n        }\n        return true;\n\n      // Names (simple or qualified) are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n        // Fall through to default if not a qualified name or not found in defines.\n    }\n    return false;\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}