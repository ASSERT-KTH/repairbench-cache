{
    "generation": "public void atan2(final double[] y, final int yOffset,\n                  final double[] x, final int xOffset,\n                  final double[] result, final int resultOffset) {\n    double x0 = x[xOffset];\n    double y0 = y[yOffset];\n    int n = getSize();\n    // NaN propagation\n    if (Double.isNaN(x0) || Double.isNaN(y0)) {\n        result[resultOffset] = Double.NaN;\n        for (int i = 1; i < n; ++i) {\n            result[resultOffset + i] = Double.NaN;\n        }\n        return;\n    }\n    // Special cases when y == 0\n    if (y0 == 0.0) {\n        long yBits = Double.doubleToRawLongBits(y0);\n        boolean yNeg = (yBits < 0);\n        if (x0 == 0.0) {\n            // atan2(\u00b10, \u00b10)\n            long xBits = Double.doubleToRawLongBits(x0);\n            boolean xNeg = (xBits < 0);\n            if (!xNeg) {\n                result[resultOffset] = y0; // \u00b10\n            } else {\n                result[resultOffset] = FastMath.copySign(FastMath.PI, y0);\n            }\n        } else if (x0 < 0.0) {\n            // atan2(\u00b10, x<0)\n            result[resultOffset] = FastMath.copySign(FastMath.PI, y0);\n        } else {\n            // atan2(\u00b10, x>0)\n            result[resultOffset] = y0; // \u00b10\n        }\n        // all derivatives are zero\n        for (int i = 1; i < n; ++i) {\n            result[resultOffset + i] = 0.0;\n        }\n        return;\n    }\n    // Special cases when either argument is infinite\n    boolean xInf = Double.isInfinite(x0);\n    boolean yInf = Double.isInfinite(y0);\n    if (yInf && xInf) {\n        // atan2(\u00b1\u221e, \u00b1\u221e)\n        long xBits = Double.doubleToRawLongBits(x0);\n        long yBits = Double.doubleToRawLongBits(y0);\n        boolean xNeg = (xBits < 0);\n        boolean yNeg = (yBits < 0);\n        double v;\n        if (!yNeg && !xNeg) {\n            v = FastMath.PI / 4;\n        } else if (!yNeg && xNeg) {\n            v = 3 * FastMath.PI / 4;\n        } else if (yNeg && !xNeg) {\n            v = -FastMath.PI / 4;\n        } else {\n            v = -3 * FastMath.PI / 4;\n        }\n        result[resultOffset] = v;\n        for (int i = 1; i < n; ++i) {\n            result[resultOffset + i] = 0.0;\n        }\n        return;\n    }\n    if (yInf) {\n        // atan2(\u00b1\u221e, finite)\n        result[resultOffset] = FastMath.copySign(FastMath.PI / 2, y0);\n        for (int i = 1; i < n; ++i) {\n            result[resultOffset + i] = 0.0;\n        }\n        return;\n    }\n    if (xInf) {\n        // atan2(finite, \u00b1\u221e)\n        long xBits = Double.doubleToRawLongBits(x0);\n        boolean xNeg = (xBits < 0);\n        if (!xNeg) {\n            result[resultOffset] = FastMath.copySign(0.0, y0);\n        } else {\n            result[resultOffset] = FastMath.copySign(FastMath.PI, y0);\n        }\n        for (int i = 1; i < n; ++i) {\n            result[resultOffset + i] = 0.0;\n        }\n        return;\n    }\n    // Generic case: finite y0 != 0 and finite x0\n    double[] tmp1 = new double[n];\n    double[] tmp2 = new double[n];\n    // compute r = sqrt(x^2 + y^2)\n    multiply(x, xOffset, x, xOffset, tmp1, 0);\n    multiply(y, yOffset, y, yOffset, tmp2, 0);\n    add(tmp1, 0, tmp2, 0, tmp2, 0);\n    rootN(tmp2, 0, 2, tmp1, 0);\n    // branch on sign of x0\n    long xb = Double.doubleToRawLongBits(x0);\n    boolean xNeg = (xb < 0);\n    if (!xNeg) {\n        // atan2(y, x) = 2 * atan( y / (r + x) )\n        add(tmp1, 0, x, xOffset, tmp2, 0);\n        divide(y, yOffset, tmp2, 0, tmp1, 0);\n        atan(tmp1, 0, tmp2, 0);\n        for (int i = 0; i < n; ++i) {\n            result[resultOffset + i] = 2 * tmp2[i];\n        }\n    } else {\n        // atan2(y, x) = \u00b1\u03c0 - 2 * atan( y / (r - x) )\n        subtract(tmp1, 0, x, xOffset, tmp2, 0);\n        divide(y, yOffset, tmp2, 0, tmp1, 0);\n        atan(tmp1, 0, tmp2, 0);\n        double v = ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0];\n        result[resultOffset] = v;\n        for (int i = 1; i < n; ++i) {\n            result[resultOffset + i] = -2 * tmp2[i];\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}