{
    "generation": "    private static ZipLong unixTimeToZipLong(long l) {\n        // The X5455 spec uses unsigned 32-bit timestamps (0 to 0xFFFFFFFF).\n        // However, the exception message mentions \"signed 32 bit integer\".\n        // Java's Integer range is [-2^31, 2^31 - 1].\n        // Unix time (seconds since epoch) should not be negative in practice,\n        // but the field could technically store them if treated as signed.\n        // The test expects an exception for a value like 2^32, which is\n        // outside both signed and unsigned 32-bit ranges (if starting from 0).\n        // Let's strictly check against the unsigned 32-bit range [0, 0xFFFFFFFFL]\n        // as specified by PKWARE AppNote 4.5.7 for X5455 fields.\n        // The original check (l >= 0x100000000L) was almost correct for the upper\n        // bound but failed the test, suggesting the test expects the check to trigger\n        // for l == 0x100000000L. The >= comparison should have worked.\n        // Let's use a check that correctly covers the unsigned 32-bit range.\n        final long MAX_UNSIGNED_32_BIT = 0xFFFFFFFFL;\n        if (l < 0 || l > MAX_UNSIGNED_32_BIT) {\n            // Keep the original exception message format for consistency, even if \"signed\" is inaccurate.\n            throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n        }\n        return new ZipLong(l);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}