{
    "generation": "public long readBits(final int count) throws IOException {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0L;\n    }\n    long result = 0L;\n    int bitsRead = 0;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        // 1) consume any leftover bits from the last read\n        if (bitsCachedSize > 0) {\n            int toRead = Math.min(bitsCachedSize, count);\n            long bits = bitsCached & MASKS[toRead];\n            result |= bits << bitsRead;\n            bitsCached >>>= toRead;\n            bitsCachedSize -= toRead;\n            bitsRead += toRead;\n        }\n        // 2) read as many full bytes as we can\n        while (bitsRead + 8 <= count) {\n            int next = in.read();\n            if (next < 0) {\n                return -1L;\n            }\n            result |= ((long) next) << bitsRead;\n            bitsRead += 8;\n        }\n        // 3) read any remaining partial byte\n        if (bitsRead < count) {\n            int rem = count - bitsRead;\n            int next = in.read();\n            if (next < 0) {\n                return -1L;\n            }\n            long bits = next & MASKS[rem];\n            result |= bits << bitsRead;\n            bitsRead += rem;\n            // stash the unused high\u2010order bits for the next call\n            bitsCached = next >>> rem;\n            bitsCachedSize = 8 - rem;\n        }\n    } else {\n        // BIG_ENDIAN\n        // 1) consume any leftover bits from the last read\n        if (bitsCachedSize > 0) {\n            int toRead = Math.min(bitsCachedSize, count);\n            int shift = bitsCachedSize - toRead;\n            long bits = (bitsCached >> shift) & MASKS[toRead];\n            result = bits;\n            bitsCached &= MASKS[shift];\n            bitsCachedSize -= toRead;\n            bitsRead += toRead;\n        }\n        // 2) read as many full bytes as we can\n        while (bitsRead + 8 <= count) {\n            int next = in.read();\n            if (next < 0) {\n                return -1L;\n            }\n            result = (result << 8) | next;\n            bitsRead += 8;\n        }\n        // 3) read any remaining partial byte\n        if (bitsRead < count) {\n            int rem = count - bitsRead;\n            int next = in.read();\n            if (next < 0) {\n                return -1L;\n            }\n            int shift = 8 - rem;\n            long bits = (next >> shift) & MASKS[rem];\n            result = (result << rem) | bits;\n            // stash the unused low\u2010order bits for the next call\n            bitsCached = next & MASKS[shift];\n            bitsCachedSize = shift;\n            bitsRead += rem;\n        }\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}