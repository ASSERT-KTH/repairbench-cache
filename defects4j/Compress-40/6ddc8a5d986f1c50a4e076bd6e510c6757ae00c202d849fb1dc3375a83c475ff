{
    "generation": "    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            // MAXIMUM_CACHE_SIZE is 63 bits\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE + \" (\" + count + \")\");\n        }\n        // Optimization: If count is 0, return 0\n        if (count == 0) {\n            return 0L;\n        }\n\n        while (bitsCachedSize < count) {\n            // Attempt to read the next byte from the input stream.\n            final long nextByte = in.read(); // Reads a byte as an int (0-255), or -1 for EOF. Promoted to long.\n            \n            // Check if EOF was reached.\n            if (nextByte < 0) {\n                // We failed to read enough bits to satisfy the request.\n                // Return -1 to indicate EOF or insufficient data.\n                return -1;\n            }\n\n            // Incorporate the byte into the cache based on the specified byte order.\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                // LITTLE_ENDIAN: New byte's bits are considered more significant.\n                // They are shifted left by the current cache size and ORed.\n                // Example: cache=...c1 c0, byte=B -> new cache = ...B c1 c0\n                // This operation might overflow if (nextByte << bitsCachedSize) exceeds 64 bits,\n                // but Java's << on long handles this by discarding high bits, effectively\n                // calculating the result modulo 2^64, which is correct for the lower 64 bits.\n                bitsCached |= (nextByte << bitsCachedSize);\n            } else { // BIG_ENDIAN\n                // BIG_ENDIAN: New byte's bits are considered less significant.\n                // Existing cache bits are shifted left by 8, and the new byte is ORed in at the LSB position.\n                // Example: cache=c1 c0..., byte=B -> new cache = c1 c0... B\n                // This operation might overflow if bitsCachedSize > 56, causing the most\n                // significant bits of the existing cache to be lost. This is the core bug\n                // for Big Endian overflow cases.\n                bitsCached <<= 8;\n                bitsCached |= nextByte;\n            }\n            // Increment the count of bits available in the cache.\n            bitsCachedSize += 8;\n        }\n            // At this point, bitsCachedSize >= count, meaning we have enough bits in the cache.\n            // Note: The comment below seems misplaced from its original context.\n            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n        \n        final long bitsOut;\n        // Extract the requested number of bits ('count') from the cache.\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            // Extract 'count' bits from the Least Significant Bit (LSB) end.\n            bitsOut = (bitsCached & MASKS[count]); // MASKS[count] likely provides a mask like (1L << count) - 1.\n            // Remove the extracted bits from the cache by shifting right.\n            bitsCached >>>= count; // Use unsigned right shift (>>>) for correctness.\n        } else { // BIG_ENDIAN\n            // Extract 'count' bits from the Most Significant Bit (MSB) end of the logical bit sequence.\n            // The shift amount determines which bits to take from the top.\n            final int shiftAmount = bitsCachedSize - count;\n            \n            // Use logical right shift (>>>) instead of arithmetic right shift (>>)\n            // to prevent potential sign extension issues if bitsCached were negative.\n            // Note: This change addresses potential sign issues but does NOT fix the\n            // underlying data loss caused by the overflow in the Big Endian update logic\n            // (`bitsCached <<= 8;`). A proper fix requires either preventing the data loss\n            // during update or compensating for it during extraction, which is more complex.\n            // However, using >>> is generally safer for bit manipulation.\n            bitsOut = (bitsCached >>> shiftAmount) & MASKS[count];\n        }\n        \n        // Update the number of bits remaining in the cache.\n        bitsCachedSize -= count;\n            \n        return bitsOut;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}