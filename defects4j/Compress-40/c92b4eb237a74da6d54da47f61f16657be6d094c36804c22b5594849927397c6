{
    "generation": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteOrder;\n\n// Assuming the following context within a class:\n// private final InputStream in;\n// private final ByteOrder byteOrder;\n// private long bitsCached = 0;\n// private int bitsCachedSize = 0;\n// private static final int MAXIMUM_CACHE_SIZE = 63;\n// // MASKS[i] = (1L << i) - 1 for i from 0 to MAXIMUM_CACHE_SIZE\n// private static final long[] MASKS = /* initialized somewhere */;\n\n\n    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        // Validate input count\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n        // Handle trivial case: read 0 bits\n        if (count == 0) {\n            return 0L;\n        }\n\n        // Ensure enough bits are cached, reading bytes as needed\n        while (bitsCachedSize < count) {\n            // Try to read the next byte\n            final long nextByte = in.read();\n            // Check for end of stream\n            if (nextByte < 0) {\n                 // If EOF is hit, and we still haven't cached enough bits, return -1.\n                 // If we have enough bits cached already (bitsCachedSize >= count),\n                 // we can proceed to extract them outside the loop.\n                 if (bitsCachedSize < count) {\n                    return -1L; // Indicate EOF before reading required bits\n                 }\n                 break; // EOF hit, but we have enough bits cached. Exit loop.\n            }\n\n            // Promote the byte to a long, treating it as unsigned\n            final long nextByteAsLong = nextByte & 0xffL;\n\n            // Calculate remaining space in the 64-bit cache (long size)\n            final int space = 64 - bitsCachedSize;\n\n            // If cache is full, we cannot add more bits. Break the loop.\n            // This condition should ideally not be strictly necessary if count <= 63,\n            // but acts as a safeguard against unexpected states.\n            if (space <= 0) {\n                 break;\n            }\n\n            // Determine how many bits from the current byte can actually be added\n            // without exceeding the 64-bit cache capacity.\n            final int bitsToAddCount = Math.min(8, space);\n\n            // Add bits based on byte order, carefully handling potential overflow\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                // Get the lowest 'bitsToAddCount' bits from the byte\n                // (these are the bits that will fit into the remaining space)\n                final long bitsToAdd = nextByteAsLong & MASKS[bitsToAddCount];\n                // Shift them into position starting at the current bitsCachedSize\n                bitsCached |= (bitsToAdd << bitsCachedSize);\n            } else { // BIG_ENDIAN\n                // Shift the existing cache left by 'bitsToAddCount' to make space\n                // at the lower end. This prevents losing high bits if bitsCachedSize is large.\n                bitsCached <<= bitsToAddCount;\n                // Get the highest 'bitsToAddCount' bits from the new byte\n                final long bitsToAdd = nextByteAsLong >> (8 - bitsToAddCount);\n                // OR these bits into the space created at the lower end\n                bitsCached |= bitsToAdd;\n            }\n            // Update the cache size, reflecting the added bits\n            bitsCachedSize += bitsToAddCount;\n        } // End while loop: bitsCachedSize >= count OR EOF reached OR cache full\n\n        // After loop, check if we acquired enough bits for the request\n        if (bitsCachedSize < count) {\n             // This can happen if EOF was hit earlier or the cache filled up\n             // before 'count' bits were accumulated.\n             return -1L;\n        }\n\n        // Extract the requested number of bits\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            // Get the lowest 'count' bits from the cache\n            bitsOut = (bitsCached & MASKS[count]);\n            // Remove the extracted bits from the cache using unsigned right shift\n            bitsCached >>>= count;\n        } else { // BIG_ENDIAN\n            // Get the highest 'count' bits from the top 'bitsCachedSize' bits in the cache\n            // Shift right so the desired bits are at the lowest positions, then mask\n            // bitsCachedSize is guaranteed to be >= count here.\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n            // Masking bitsCached after shift is not necessary, the size update handles it.\n            // High bits that were shifted out are implicitly discarded.\n        }\n\n        // Update the cache size by subtracting the number of bits extracted\n        bitsCachedSize -= count;\n\n        return bitsOut;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}