{
    "generation": "    /**\n     * Returns at most 63 bits read from the underlying stream.\n     *\n     * @param count the number of bits to read, must be a positive\n     * number not bigger than 63.\n     * @return the bits concatenated as a long using the stream's byte order.\n     *         -1 if the end of the underlying stream has been reached before reading\n     *         the requested number of bits\n     * @throws IOException on error\n     */\n    public long readBits(final int count) throws IOException {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n        }\n\n        // Use temporary variables to accumulate bits for the current read operation.\n        // This allows 'currentAccumulatedBits' to hold the full 64 bits of a long,\n        // and 'currentAccumulatedBitsSize' to track the conceptual number of bits,\n        // which might temporarily exceed 64 during accumulation.\n        long currentAccumulatedBits = bitsCached;\n        int currentAccumulatedBitsSize = bitsCachedSize;\n\n        // Keep reading bytes until we have enough bits in the temporary cache.\n        while (currentAccumulatedBitsSize < count) {\n            final long nextByte = in.read();\n            if (nextByte < 0) {\n                // End of stream reached before reading the requested number of bits.\n                // Clear the internal cache and return -1.\n                bitsCached = 0;\n                bitsCachedSize = 0;\n                return nextByte;\n            }\n\n            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n                // For LITTLE_ENDIAN, new bytes are added to the most significant positions.\n                // The current bits are at the lower end of currentAccumulatedBits.\n                // Example: currentAccumulatedBitsSize = 0, nextByte = 0xAA. currentAccumulatedBits becomes 0xAA.\n                // currentAccumulatedBitsSize = 8, nextByte = 0xBB. currentAccumulatedBits becomes 0xBB00 + 0xAA = 0xBBAA.\n                // The `long` variable will correctly handle shifts and ORs up to its 64-bit capacity.\n                // The implicit truncation of higher bits of `nextByte` occurs if `currentAccumulatedBitsSize + 8` exceeds 64.\n                // However, this is handled by masking the `currentAccumulatedBits` at the end.\n                currentAccumulatedBits |= (nextByte << currentAccumulatedBitsSize);\n            } else { // BIG_ENDIAN\n                // For BIG_ENDIAN, existing bits are shifted left, and the new byte is added to the least significant positions.\n                // Example: currentAccumulatedBitsSize = 0, nextByte = 0xAA. currentAccumulatedBits becomes 0xAA.\n                // currentAccumulatedBitsSize = 8, nextByte = 0xBB. currentAccumulatedBits becomes 0xAA00 + 0xBB = 0xAABB.\n                currentAccumulatedBits <<= 8;\n                currentAccumulatedBits |= nextByte;\n            }\n            currentAccumulatedBitsSize += 8;\n        }\n\n        // Extract the requested 'count' bits from the accumulated value.\n        final long bitsOut;\n        long remainderValue;\n        int remainderBits;\n\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            // For LITTLE_ENDIAN, the requested bits are at the lower end of `currentAccumulatedBits`.\n            // MASKS[count] correctly extracts `count` bits from the lower positions (bits 0 to count-1).\n            bitsOut = (currentAccumulatedBits & MASKS[count]);\n\n            // The remaining bits are the higher bits after extraction.\n            // These form the new 'bitsCached' for the next call.\n            remainderValue = currentAccumulatedBits >>> count;\n            remainderBits = currentAccumulatedBitsSize - count;\n        } else { // BIG_ENDIAN\n            // For BIG_ENDIAN, the requested bits are at the higher end of `currentAccumulatedBits`.\n            // We shift right to bring them to the lower end, then mask.\n            bitsOut = (currentAccumulatedBits >> (currentAccumulatedBitsSize - count)) & MASKS[count];\n\n            // The remaining bits are the lower `currentAccumulatedBitsSize - count` bits.\n            // We use MASKS to ensure only these remaining bits are kept in `bitsCached`,\n            // effectively clearing any higher bits that might have been part of `bitsOut`\n            // or were \"spillover\" from previous operations and are no longer relevant.\n            remainderValue = currentAccumulatedBits & MASKS[currentAccumulatedBitsSize - count];\n            remainderBits = currentAccumulatedBitsSize - count;\n        }\n\n        // Update the member variables with the remainder bits for the next read.\n        bitsCached = remainderValue;\n        bitsCachedSize = remainderBits;\n\n        return bitsOut;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}