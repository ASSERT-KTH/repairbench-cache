{
    "generation": "public long readBits(final int count) throws IOException {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n    }\n    // Use BigInteger as temporary to avoid overflow on shifts beyond 64 bits\n    java.math.BigInteger buf = java.math.BigInteger.valueOf(bitsCached);\n    int bufSize = bitsCachedSize;\n    // Fill until we have at least 'count' bits\n    while (bufSize < count) {\n        int r = in.read();\n        if (r < 0) {\n            // EOF before filling requested bits\n            return -1;\n        }\n        long nb = r & 0xFFL;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            // Append new byte at low end\n            buf = buf.or(java.math.BigInteger.valueOf(nb).shiftLeft(bufSize));\n        } else {\n            // Append new byte at high end (shift current up 8 bits)\n            buf = buf.shiftLeft(8).or(java.math.BigInteger.valueOf(nb));\n        }\n        bufSize += 8;\n    }\n    // Extract the requested bits\n    long result;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        // lower 'count' bits\n        result = buf.and(java.math.BigInteger.valueOf(MASKS[count])).longValue();\n        // discard those bits\n        buf = buf.shiftRight(count);\n    } else {\n        // upper 'count' bits\n        int shift = bufSize - count;\n        result = buf.shiftRight(shift)\n                    .and(java.math.BigInteger.valueOf(MASKS[count]))\n                    .longValue();\n        // discard the extracted bits, keep the low 'shift' bits\n        if (shift > 0) {\n            buf = buf.and(java.math.BigInteger.valueOf(MASKS[shift]));\n        } else {\n            buf = java.math.BigInteger.ZERO;\n        }\n    }\n    // Update the cache\n    bitsCached = buf.longValue();\n    bitsCachedSize = bufSize - count;\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}