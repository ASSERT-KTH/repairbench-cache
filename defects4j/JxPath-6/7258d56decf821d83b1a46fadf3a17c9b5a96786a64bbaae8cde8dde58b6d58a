{
    "generation": "    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n//        System.err.println(\"COMPARING: \" +\n//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n//            (r == null ? \"null\" : r.getClass().getName()));\n\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        // FIX: Ensure NodePointers are unwrapped to their values for comparison.\n        // XPath equality rules compare values, not object identity for NodePointers.\n        // This is crucial when a NodePointer is compared against a non-NodePointer value.\n        // If 'l' is a single NodePointer and 'r' is not (and not a collection/iterator),\n        // or vice versa, get the underlying value.\n        // Comparisons involving collections/iterators will handle NodePointer unwrapping\n        // within the collection processing logic below.\n        if (l instanceof org.apache.commons.jxpath.ri.model.NodePointer\n                && !(r instanceof org.apache.commons.jxpath.ri.model.NodePointer || r instanceof Collection || r instanceof Iterator)) {\n            l = ((org.apache.commons.jxpath.ri.model.NodePointer)l).getValue();\n        } else if (r instanceof org.apache.commons.jxpath.ri.model.NodePointer\n                && !(l instanceof org.apache.commons.jxpath.ri.model.NodePointer || l instanceof Collection || l instanceof Iterator)) {\n            r = ((org.apache.commons.jxpath.ri.model.NodePointer)r).getValue();\n        }\n\n\n        // Convert Collections to Iterators, and also unwrap NodePointers inside collections.\n        // This ensures that the Iterator contains the actual values for comparison.\n        if (l instanceof Collection) {\n            Collection<?> originalCollection = (Collection<?>) l;\n            java.util.List<Object> unwrappedList = new java.util.ArrayList<>();\n            for (Object item : originalCollection) {\n                if (item instanceof org.apache.commons.jxpath.ri.model.NodePointer) {\n                    // Unwrap NodePointer within the collection to its underlying value\n                    unwrappedList.add(((org.apache.commons.jxpath.ri.model.NodePointer) item).getValue());\n                } else {\n                    unwrappedList.add(item);\n                }\n            }\n            l = unwrappedList.iterator();\n        }\n\n        if (r instanceof Collection) {\n            Collection<?> originalCollection = (Collection<?>) r;\n            java.util.List<Object> unwrappedList = new java.util.ArrayList<>();\n            for (Object item : originalCollection) {\n                if (item instanceof org.apache.commons.jxpath.ri.model.NodePointer) {\n                    // Unwrap NodePointer within the collection to its underlying value\n                    unwrappedList.add(((org.apache.commons.jxpath.ri.model.NodePointer) item).getValue());\n                } else {\n                    unwrappedList.add(item);\n                }\n            }\n            r = unwrappedList.iterator();\n        }\n\n        if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n            // Now, 'l' is an Iterator that contains unwrapped values (if they were NodePointers)\n            // and 'r' is a raw value (potentially unwrapped NodePointer).\n            // `contains` should now correctly compare actual values.\n            return contains((Iterator) l, r);\n        }\n        if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n            return contains((Iterator) r, l);\n        }\n        if (l instanceof Iterator && r instanceof Iterator) {\n            // Both are Iterators containing unwrapped values.\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        // Default comparison for non-collections/non-iterators.\n        // 'l' and 'r' are now atomic values, potentially unwrapped from NodePointers.\n        return equal(l, r);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}