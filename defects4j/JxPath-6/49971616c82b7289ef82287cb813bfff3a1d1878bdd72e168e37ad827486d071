{
    "generation": "import java.util.Collection;\nimport java.util.Iterator;\nimport org.apache.commons.jxpath.NodePointer;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n    /**\n     * Compares two values according to XPath comparison rules.\n     * Handles comparisons involving node-sets (represented as Iterators or Collections)\n     * and atomic values.\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n        // Unwrap special JXPath context types to get the node pointer\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer(); // l becomes NodePointer or null\n        }\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer(); // r becomes NodePointer or null\n        }\n\n        // If the result is a NodePointer, get its value for comparison.\n        // This is important because the pointer might point to a collection\n        // that needs to be treated as a node-set for comparison purposes.\n        Object lValue = l instanceof NodePointer ? ((NodePointer) l).getValue() : l;\n        Object rValue = r instanceof NodePointer ? ((NodePointer) r).getValue() : r;\n\n        // Prepare the values for comparison logic below.\n        // If a value is a Collection, convert it to an Iterator.\n        Object lCompare = lValue;\n        if (lCompare instanceof Collection) {\n            lCompare = ((Collection) lCompare).iterator();\n        }\n\n        Object rCompare = rValue;\n        if (rCompare instanceof Collection) {\n            rCompare = ((Collection) rCompare).iterator();\n        }\n\n        // Now determine the comparison logic based on whether the operands\n        // represent node-sets (Iterators) or atomic values.\n        if (lCompare instanceof Iterator) {\n            Iterator lIter = (Iterator) lCompare;\n            if (rCompare instanceof Iterator) {\n                // Node-set vs Node-set: comparison is true if there is a node\n                // in the first node-set and a node in the second node-set\n                // such that their string-values are equal.\n                return findMatch(lIter, (Iterator) rCompare);\n            }\n            else {\n                // Node-set vs Atomic value: comparison is true if there is\n                // a node in the node-set such that its string-value is\n                // equal to the atomic value.\n                // We pass the original (potentially unwrapped) atomic value 'rValue'.\n                return contains(lIter, rValue);\n            }\n        }\n        else if (rCompare instanceof Iterator) {\n            // Atomic value vs Node-set: similar to the case above.\n            // We pass the original (potentially unwrapped) atomic value 'lValue'.\n            return contains((Iterator) rCompare, lValue);\n        }\n        else {\n            // Atomic value vs Atomic value: perform direct comparison.\n            // We use the potentially unwrapped values 'lValue' and 'rValue'.\n            return equal(lValue, rValue); // Delegates to the base equal(Object, Object)\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}