{
    "generation": "    /**\n     * Compares two values\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n        // Handle context nodes -> NodePointer\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        // Extract underlying value if dealing with NodePointers\n        // This is needed to check if the pointer points to a collection.\n        Object vl = (l instanceof NodePointer) ? ((NodePointer) l).getValue() : l;\n        Object vr = (r instanceof NodePointer) ? ((NodePointer) r).getValue() : r;\n\n        // Convert collections (or NodePointers to collections) to iterators\n        // Check the unwrapped value first, then the original object if it wasn't a pointer.\n        boolean lIsIterator = false;\n        if (vl instanceof Collection) {\n            l = ((Collection) vl).iterator();\n            lIsIterator = true;\n        } else if (l instanceof Collection) { // Handle case where compute returns Collection directly\n            l = ((Collection) l).iterator();\n            lIsIterator = true;\n        }\n\n        boolean rIsIterator = false;\n        if (vr instanceof Collection) {\n            r = ((Collection) vr).iterator();\n            rIsIterator = true;\n        } else if (r instanceof Collection) { // Handle case where compute returns Collection directly\n            r = ((Collection) r).iterator();\n            rIsIterator = true;\n        }\n\n        // Use the boolean flags for clarity, as l/r might now be Iterators\n        if (lIsIterator && rIsIterator) {\n            // Both are iterators (originally collections or pointers to collections)\n            return findMatch((Iterator) l, (Iterator) r);\n        }\n        if (lIsIterator /* && !rIsIterator implied */) {\n            // Left is iterator, right is scalar (or NodePointer to scalar)\n            return contains((Iterator) l, r);\n        }\n        if (rIsIterator /* && !lIsIterator implied */) {\n            // Right is iterator, left is scalar (or NodePointer to scalar)\n            return contains((Iterator) r, l);\n        }\n        \n        // If we reach here, neither operand resulted in an iterator.\n        // They are either scalars or NodePointers to scalars/non-collections.\n        // Call the basic comparison method which handles NodePointer unwrapping\n        // and type conversions according to XPath rules.\n        return equal(l, r);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}