{
    "generation": "protected boolean equal(\n    EvalContext context,\n    Expression left,\n    Expression right) \n{\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n    if (l instanceof InitialContext || l instanceof SelfContext) {\n        l = ((EvalContext) l).getSingleNodePointer();\n    }\n    if (r instanceof InitialContext || r instanceof SelfContext) {\n        r = ((EvalContext) r).getSingleNodePointer();\n    }\n\n    // If a value is an Iterator (but not already a Collection),\n    // copy its contents into a List so that we get a fresh, re\u2010iterable sequence.\n    if (l instanceof Iterator && !(l instanceof Collection)) {\n        List<Object> list = new ArrayList<Object>();\n        Iterator<?> iter = (Iterator<?>) l;\n        while (iter.hasNext()) {\n            list.add(iter.next());\n        }\n        l = list;\n    }\n    if (r instanceof Iterator && !(r instanceof Collection)) {\n        List<Object> list = new ArrayList<Object>();\n        Iterator<?> iter = (Iterator<?>) r;\n        while (iter.hasNext()) {\n            list.add(iter.next());\n        }\n        r = list;\n    }\n\n    boolean lIsCollection = (l instanceof Collection);\n    boolean rIsCollection = (r instanceof Collection);\n\n    if (lIsCollection && !rIsCollection) {\n        // use a fresh iterator from the Collection, so it isn\u2019t consumed permanently\n        return contains(((Collection<?>) l).iterator(), r);\n    }\n    if (!lIsCollection && rIsCollection) {\n        return contains(((Collection<?>) r).iterator(), l);\n    }\n    if (lIsCollection && rIsCollection) {\n        return findMatch(((Collection<?>) l).iterator(), ((Collection<?>) r).iterator());\n    }\n    return equal(l, r);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}