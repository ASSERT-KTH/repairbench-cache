{
    "generation": "    /**\n     * Compares two values according to XPath comparison rules.\n     * Handles comparisons involving node-sets (represented as Iterators or Collections,\n     * potentially wrapped in NodePointers) and atomic values.\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n        // If an expression evaluates to a special context node, get its pointer.\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        // Check if the operands are NodePointers and get their underlying values.\n        // This is crucial because a NodePointer might point to a Collection,\n        // which needs to be treated as a node-set for comparison purposes.\n        // We use these values (vl, vr) to check for Collection/Iterator types.\n        Object vl = (l instanceof NodePointer) ? ((NodePointer) l).getValue() : l;\n        Object vr = (r instanceof NodePointer) ? ((NodePointer) r).getValue() : r;\n\n        // Determine if the underlying values represent iterable sets (Collections or Iterators).\n        Iterator lIter = null;\n        if (vl instanceof Collection) {\n            lIter = ((Collection) vl).iterator();\n        } else if (vl instanceof Iterator) {\n            // If the value itself is already an Iterator, use it directly.\n            lIter = (Iterator) vl;\n        }\n\n        Iterator rIter = null;\n        if (vr instanceof Collection) {\n            rIter = ((Collection) vr).iterator();\n        } else if (vr instanceof Iterator) {\n            // If the value itself is already an Iterator, use it directly.\n            rIter = (Iterator) vr;\n        }\n\n        // Apply XPath comparison logic based on whether operands are sets (iterators) or atomic values:\n        // - set = atomic: true if any node in set equals the atomic value.\n        // - atomic = set: true if any node in set equals the atomic value.\n        // - set = set: true if any node in set1 equals any node in set2.\n\n        if (lIter != null && rIter == null) {\n            // Left is a set, right is atomic/single node.\n            // Compare elements from the left iterator with the original right value (r).\n            // The 'contains' method internally uses static 'equal(Object, Object)'\n            // which handles comparisons between node values and atomic values correctly.\n            return contains(lIter, r);\n        }\n        if (lIter == null && rIter != null) {\n            // Left is atomic/single node, right is a set. Symmetric case.\n            // Compare elements from the right iterator with the original left value (l).\n            return contains(rIter, l);\n        }\n        if (lIter != null && rIter != null) {\n            // Both operands are sets (iterators). Check for any matching pair.\n            // The 'findMatch' method internally uses static 'equal(Object, Object)'.\n            return findMatch(lIter, rIter);\n        }\n\n        // If neither operand resolves to an iterator (meaning both are effectively\n        // atomic values or single NodePointers not pointing to collections),\n        // perform a direct comparison using the static 'equal' helper method.\n        // This method handles various type comparisons, including NodePointer vs NodePointer\n        // and NodePointer vs atomic value, according to XPath rules (often involving string-value).\n        // We use the original 'l' and 'r' here, as the static 'equal' method knows\n        // how to handle NodePointers directly.\n        return equal(l, r); // Delegates to static equal(Object, Object)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}