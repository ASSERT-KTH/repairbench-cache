{
    "generation": "/**\n * Compares two values\n */\nprotected boolean equal(\n    EvalContext context,\n    Expression left,\n    Expression right)\n{\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n    // If either side is itself an EvalContext (a node-set or variable\n    // context), turn it into an Iterator.  But if there's only one\n    // node, we'll compare it as a single pointer.\n    if (l instanceof EvalContext) {\n        EvalContext lc = (EvalContext) l;\n        // getPointerCount() is the number of pointers/nodes under this context\n        int count = lc.getPointerCount();\n        if (count > 1) {\n            l = lc.iteratePointers();    // an Iterator over the node-set\n        } else {\n            l = lc.getSingleNodePointer();\n        }\n    }\n    if (r instanceof EvalContext) {\n        EvalContext rc = (EvalContext) r;\n        int count = rc.getPointerCount();\n        if (count > 1) {\n            r = rc.iteratePointers();\n        } else {\n            r = rc.getSingleNodePointer();\n        }\n    }\n\n    // If it's a plain Collection, iterate it\n    if (l instanceof Collection) {\n        l = ((Collection<?>) l).iterator();\n    }\n    if (r instanceof Collection) {\n        r = ((Collection<?>) r).iterator();\n    }\n\n    // Now apply XPath\u2010style '=' semantics: \n    // node-set = atomic => true if any node equals the atomic\n    if (l instanceof Iterator && !(r instanceof Iterator)) {\n        return contains((Iterator<?>) l, r);\n    }\n    if (!(l instanceof Iterator) && r instanceof Iterator) {\n        return contains((Iterator<?>) r, l);\n    }\n    // node-set = node-set => true if any pair matches\n    if (l instanceof Iterator && r instanceof Iterator) {\n        return findMatch((Iterator<?>) l, (Iterator<?>) r);\n    }\n    // neither is a node-set: compare scalars or pointers directly\n    return equal(l, r);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}