{
    "generation": "protected boolean equal(\n    EvalContext context,\n    Expression left,\n    Expression right) \n{\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n    /*\n     * If either side is an EvalContext (including\n     * InitialContext, SelfContext, or a variable\u2010context),\n     * unwrap it to its single node pointer.\n     */\n    if (l instanceof EvalContext) {\n        l = ((EvalContext) l).getSingleNodePointer();\n    }\n    if (r instanceof EvalContext) {\n        r = ((EvalContext) r).getSingleNodePointer();\n    }\n\n    /*\n     * If either side is a Collection, turn it into an Iterator.\n     */\n    if (l instanceof Collection<?>) {\n        l = ((Collection<?>) l).iterator();\n    }\n    if (r instanceof Collection<?>) {\n        r = ((Collection<?>) r).iterator();\n    }\n\n    /*\n     * XPath \"=\" semantics:\n     *   - If one side is an iterator and the other is not, check containment.\n     *   - If both sides are iterators, check for any matching pair.\n     *   - Otherwise, do a simple atomic comparison.\n     */\n    if (l instanceof Iterator<?> && !(r instanceof Iterator<?>)) {\n        return contains((Iterator<?>) l, r);\n    }\n    if (!(l instanceof Iterator<?>) && (r instanceof Iterator<?>)) {\n        return contains((Iterator<?>) r, l);\n    }\n    if (l instanceof Iterator<?> && r instanceof Iterator<?>) {\n        return findMatch((Iterator<?>) l, (Iterator<?>) r);\n    }\n\n    return equal(l, r);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}