{
    "generation": "protected boolean equal(\n    EvalContext context,\n    Expression left,\n    Expression right) \n{\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n    // Normalize any context objects\n    if (l instanceof InitialContext || l instanceof SelfContext) {\n        l = ((EvalContext) l).getSingleNodePointer();\n    }\n    if (r instanceof InitialContext || r instanceof SelfContext) {\n        r = ((EvalContext) r).getSingleNodePointer();\n    }\n\n    // If an operand is an Iterator, drain it into a List so that it can be iterated repeatedly.\n    if (l instanceof Iterator) {\n        List<Object> list = new ArrayList<>();\n        Iterator<?> iter = (Iterator<?>) l;\n        while (iter.hasNext()) {\n            list.add(iter.next());\n        }\n        l = list;\n    }\n    if (r instanceof Iterator) {\n        List<Object> list = new ArrayList<>();\n        Iterator<?> iter = (Iterator<?>) r;\n        while (iter.hasNext()) {\n            list.add(iter.next());\n        }\n        r = list;\n    }\n\n    // If either operand is a Collection then according to XPath semantics,\n    // the equality is true if any member of the node-set equals the other operand.\n    if (l instanceof Collection) {\n        Collection<?> coll = (Collection<?>) l;\n        // If r is also a Collection, check for any pair of equal members.\n        if (r instanceof Collection) {\n            Collection<?> otherColl = (Collection<?>) r;\n            for (Object o1 : coll) {\n                for (Object o2 : otherColl) {\n                    if (equal(o1, o2)) {\n                        return true;\n                    }\n                }\n            }\n        } else {\n            for (Object o : coll) {\n                if (equal(o, r)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    if (r instanceof Collection) {\n        Collection<?> coll = (Collection<?>) r;\n        for (Object o : coll) {\n            if (equal(l, o)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Otherwise, compare the two atomic values.\n    return equal(l, r);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}