{
    "generation": "protected boolean equal(EvalContext context, Expression left, Expression right) {\n    Object l = left.compute(context);\n    Object r = right.compute(context);\n\n    // If the computed value is an evaluation context, unwrap it.\n    if (l instanceof InitialContext || l instanceof SelfContext) {\n        l = ((EvalContext) l).getSingleNodePointer();\n    }\n    if (r instanceof InitialContext || r instanceof SelfContext) {\n        r = ((EvalContext) r).getSingleNodePointer();\n    }\n\n    // If the value is a Collection (i.e. a node\u2010set),\n    // turn it into an iterator. (A single\u2013node Collection is left as its sole value.)\n    if (l instanceof Collection) {\n        Collection<?> coll = (Collection<?>) l;\n        if (coll.size() == 1) {\n            l = coll.iterator().next();\n        } else {\n            l = coll.iterator();\n        }\n    }\n    if (r instanceof Collection) {\n        Collection<?> coll = (Collection<?>) r;\n        if (coll.size() == 1) {\n            r = coll.iterator().next();\n        } else {\n            r = coll.iterator();\n        }\n    }\n\n    /*\n     * When comparing a node\u2010set (which is represented as an Iterator)\n     * with a scalar (String, Boolean, etc.), XPath requires that the comparison\n     * be made between the \u201catomized\u201d (that is, string\u2010valued) objects.\n     * The bug was that node\u2013set elements (usually NodePointer objects) were\n     * not being converted to their (typically string) values before comparison.\n     * \n     * Here we \u201cwrap\u201d any Iterator so that each time its next()\n     * is called, we return the node\u2019s underlying value.\n     *\n     * (In cases where the value is not a NodePointer the value is returned as\u2013is.)\n     */\n    // Local helper: wrap iterators so that each element is atomized.\n    class AtomizingIterator implements Iterator {\n        private final Iterator<?> it;\n        AtomizingIterator(Iterator<?> it) {\n            this.it = it;\n        }\n        public boolean hasNext() {\n            return it.hasNext();\n        }\n        public Object next() {\n            Object o = it.next();\n            return (o instanceof NodePointer)\n                ? ((NodePointer) o).getValue()\n                : o;\n        }\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    // If our value is not an iterator, \u201catomize\u201d it directly.\n    // (For example, if it is a NodePointer, use its underlying value.)\n    if (!(l instanceof Iterator)) {\n        l = (l instanceof NodePointer) ? ((NodePointer) l).getValue() : l;\n    }\n    if (!(r instanceof Iterator)) {\n        r = (r instanceof NodePointer) ? ((NodePointer) r).getValue() : r;\n    }\n\n    // For iterators, wrap them in an AtomizingIterator before comparing.\n    if (l instanceof Iterator) {\n        l = new AtomizingIterator((Iterator<?>) l);\n    }\n    if (r instanceof Iterator) {\n        r = new AtomizingIterator((Iterator<?>) r);\n    }\n\n    // Now do the equality comparisons as required by XPath:\n    // If one operand is an iterator and the other isn\u2019t, check whether\n    // the iterator contains an element equal to the scalar.\n    if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n        return contains((Iterator<?>) l, r);\n    }\n    if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n        return contains((Iterator<?>) r, l);\n    }\n    if (l instanceof Iterator && r instanceof Iterator) {\n        return findMatch((Iterator<?>) l, (Iterator<?>) r);\n    }\n    return equal(l, r);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}