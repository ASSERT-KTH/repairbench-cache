{
    "generation": "import java.util.Collection;\nimport java.util.Iterator;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\nimport org.apache.commons.jxpath.ri.model.NodePointer;\nimport org.apache.commons.jxpath.util.ValueUtils; // Import ValueUtils\nimport org.apache.commons.jxpath.Pointer; // Import Pointer if needed by ValueUtils or context handling\n\n// Assuming the class structure includes access to helper methods:\n// - protected boolean contains(Iterator iter, Object value)\n// - protected boolean findMatch(Iterator iter1, Iterator iter2)\n// - protected boolean equal(Object o1, Object o2) // The helper method, likely CoreOps.equal\n\n    /**\n     * Compares two values according to XPath '=' semantics.\n     */\n    protected boolean equal(\n        EvalContext context,\n        Expression left,\n        Expression right)\n    {\n        Object l = left.compute(context);\n        Object r = right.compute(context);\n\n        // Context node handling: Convert context nodes (e.g., '.') to their corresponding NodePointer.\n        if (l instanceof InitialContext || l instanceof SelfContext) {\n            l = ((EvalContext) l).getSingleNodePointer();\n        }\n        if (r instanceof InitialContext || r instanceof SelfContext) {\n            r = ((EvalContext) r).getSingleNodePointer();\n        }\n\n        // Use ValueUtils to determine if operands represent multiple values\n        // (e.g., collections, node-sets represented by pointers, iterators).\n        // ValueUtils.isCollection correctly handles various types including NodePointers that represent node sets.\n        boolean lIter = ValueUtils.isCollection(l);\n        boolean rIter = ValueUtils.isCollection(r);\n\n        Iterator lIterator = null;\n        Iterator rIterator = null;\n\n        // Obtain iterators that yield the actual values if the operands represent multiple values.\n        // ValueUtils.iterate handles conversion from Collection, Pointer (node-set), Iterator, etc. to a value iterator.\n        if (lIter) {\n            lIterator = ValueUtils.iterate(l);\n        }\n        if (rIter) {\n            rIterator = ValueUtils.iterate(r);\n        }\n\n        // Perform comparison based on whether operands represent single or multiple values, following XPath rules.\n        if (lIter && rIter) {\n            // Both operands represent multiple values: True if a value from 'l' equals a value from 'r'.\n            return findMatch(lIterator, rIterator);\n        }\n        else if (lIter && !rIter) {\n            // Left has multiple values, Right is scalar: True if any value from 'l' equals 'r'.\n            // The 'contains' method uses the helper 'equal(Object, Object)', which should handle\n            // the case where 'r' might be a single NodePointer by comparing its underlying value.\n            return contains(lIterator, r);\n        }\n        else if (!lIter && rIter) {\n            // Left is scalar, Right has multiple values: True if 'l' equals any value from 'r'.\n            // The 'contains' method uses the helper 'equal(Object, Object)', which should handle\n            // the case where 'l' might be a single NodePointer by comparing its underlying value.\n            return contains(rIterator, l);\n        }\n        else {\n            // Neither operand represents multiple values (both are scalars or potentially single node pointers).\n            // Perform direct comparison using the helper method.\n            // The helper 'equal(Object, Object)' is responsible for comparisons like\n            // scalar=scalar, scalar=pointer, pointer=scalar, pointer=pointer,\n            // and should extract values from single NodePointers as needed according to XPath rules.\n            return equal(l, r); // Calls helper equal(Object, Object)\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}