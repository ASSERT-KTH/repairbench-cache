{
    "generation": "import com.google.common.collect.ImmutableList; // Assuming this import is available in the environment.\n\n  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n      // Get the relevant object types from the inferred type, handling unions.\n      // We restrict by not null or undefined early to focus on the object shapes.\n      ImmutableList<ObjectType> objTypesToInfer = getObjectTypesForPropertyInference(\n          type.restrictByNotNullOrUndefined());\n\n      if (objTypesToInfer.isEmpty()) {\n        return; // No object types to infer properties on or process\n      }\n\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propTypeFromConstraint = constraintObj.getPropertyType(prop);\n\n        // Iterate over each distinct object type found in the 'type' (in case of a union)\n        for (ObjectType objType : objTypesToInfer) {\n          // Check if the property is declared on this specific object type.\n          // This is important for union types where a property might be declared on one\n          // member but not another.\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            // The property is not explicitly declared on this particular object type.\n            // We need to infer it based on the constraint.\n            JSType typeToInfer = propTypeFromConstraint;\n            // If the property doesn't exist at all on this object type (not even inherited),\n            // it implies it's an optional property for this object shape.\n            if (!objType.hasProperty(prop)) {\n              // The inferred type should include 'undefined' to reflect its optional nature.\n              typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propTypeFromConstraint);\n            }\n            // Define the inferred property on this specific object type.\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          } else {\n            // The property is already declared on this object type.\n            // Now, we must check if its current type needs to be widened\n            // to satisfy the constraint.\n            JSType currentPropType = objType.getPropertyType(prop);\n            if (!currentPropType.isSubtypeOf(propTypeFromConstraint)) {\n              // If the current property type is not a subtype of the constraint type,\n              // we need to widen it. The new type should be the least common supertype\n              // that satisfies both the existing type and the constraint type.\n              JSType widenedType = currentPropType.getLeastSupertype(propTypeFromConstraint);\n              // Only update the property if its type has actually changed (i.e., it was widened).\n              if (!widenedType.equals(currentPropType)) {\n                 objType.defineInferredProperty(prop, widenedType, null);\n              }\n            }\n            // If currentPropType IS already a subtype of propTypeFromConstraint,\n            // no widening is necessary, and no action is taken.\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Helper method to extract relevant ObjectTypes from a JSType for property inference.\n   * Handles single object types and union types of object types.\n   * It filters out non-object types after restricting by null/undefined.\n   */\n  private ImmutableList<ObjectType> getObjectTypesForPropertyInference(JSType type) {\n    if (type == null) {\n      return ImmutableList.of();\n    }\n    // If the type is a union, iterate over its members.\n    if (type.isUnionType()) {\n      ImmutableList.Builder<ObjectType> builder = ImmutableList.builder();\n      for (JSType member : type.toUnionType().getMembers()) {\n        // Recursively restrict each union member by null/undefined.\n        JSType restrictedMember = member.restrictByNotNullOrUndefined();\n        // Attempt to cast the restricted member to an ObjectType.\n        // This will add only the actual object shapes to our list.\n        ObjectType objMember = ObjectType.cast(restrictedMember);\n        if (objMember != null) {\n          builder.add(objMember);\n        }\n      }\n      return builder.build();\n    } else {\n      // If it's not a union, just try to cast the type itself to an ObjectType.\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null) {\n        return ImmutableList.of(objType);\n      }\n    }\n    return ImmutableList.of(); // Return empty list if no suitable object types are found.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}