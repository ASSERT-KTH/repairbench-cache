{
    "generation": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n\n  // First strip null/undefined and handle union types by recursing on each member.\n  JSType restrictedType = type.restrictByNotNullOrUndefined();\n  UnionType unionType = UnionType.cast(restrictedType);\n  if (unionType != null) {\n    for (JSType alt : unionType.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(alt, constraint);\n    }\n    return;\n  }\n\n  // Now both `restrictedType` and `constraint` are non\u2010null, non\u2010undefined, non\u2010union.\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj != null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(restrictedType);\n    if (objType != null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          // If the object really has no such property (not even on the prototype),\n          // widen the inferred type to include VOID (i.e. undefined).\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}