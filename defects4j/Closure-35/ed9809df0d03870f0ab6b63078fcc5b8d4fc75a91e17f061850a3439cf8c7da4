{
    "generation": "  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj != null && constraintObj.isRecordType()) {\n      // The original code only handled the case where 'type' itself was\n      // a single ObjectType (or could be cast to one after null/undefined restriction).\n      // However, 'type' can be a UnionType, especially if it represents\n      // an object that could originate from different control flow paths\n      // (e.g., 'results' in testIssue669, which is a union of two different object literals).\n      // In such cases, we need to apply property inference to each object type\n      // within that union.\n\n      JSType nonNullOrUndefinedType = type.restrictByNotNullOrUndefined();\n      \n      // Iterate over all constituent types of the potentially union 'nonNullOrUndefinedType'.\n      // If 'nonNullOrUndefinedType' is not a union, getTypesUnderUnion() returns a set\n      // containing just 'nonNullOrUndefinedType' itself.\n      for (JSType individualType : nonNullOrUndefinedType.getTypesUnderUnion()) {\n        ObjectType objType = ObjectType.cast(individualType);\n        \n        // Only apply inference if the individual type is an object type.\n        if (objType != null) {\n          for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            // We only infer if the property is NOT already declared on the object.\n            // If it's declared, its type is fixed and should not be modified.\n            if (!objType.isPropertyTypeDeclared(prop)) {\n              JSType typeToInfer = propType;\n              // If the object does not have the property at all (i.e., it's not\n              // even inferred), we infer it as a union with VOID (undefined).\n              // This accounts for properties that might be optional or missing\n              // in some branches, but are required by the constraint.\n              if (!objType.hasProperty(prop)) {\n                typeToInfer =\n                    getNativeType(VOID_TYPE).getLeastSupertype(propType);\n              }\n              // Define the inferred property on the object type.\n              // 'null' is passed for the property node, as this is an inferred property.\n              objType.defineInferredProperty(prop, typeToInfer, null);\n            }\n          }\n        }\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}