{
    "generation": "  /**\n   * Suppose X is an object with inferred properties.\n   * Suppose also that X is used in a way where it would only type-check\n   * correctly if some of those properties are widened.\n   * Then we should be polite and automatically widen X's properties for him.\n   *\n   * For a concrete example, consider:\n   * param x {{prop: (number|undefined)}}\n   * function f(x) {}\n   * f({});\n   *\n   * If we give the anonymous object an inferred property of (number|undefined),\n   * then this code will type-check appropriately.\n   */\n  private void inferPropertyTypesToMatchConstraint(\n      JSType type, JSType constraint) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    ObjectType constraintObj =\n        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n    if (constraintObj == null || !constraintObj.isRecordType()) {\n      // The constraint is not an object literal type with properties,\n      // so there's nothing to infer from it.\n      return;\n    }\n\n    // Get the type to potentially modify, stripped of null/undefined.\n    JSType restrictedType = type.restrictByNotNullOrUndefined();\n\n    // If the type to be inferred upon is a union, we need to apply the\n    // widening logic to each object type within the union.\n    if (restrictedType.isUnionType()) {\n      // Iterate over the constituent types of the union.\n      // We assume that the `ObjectType` instances within the union are mutable\n      // and that modifying them here will reflect in the overall union type.\n      for (JSType alternate : restrictedType.toMaybeUnionType().getAlternates()) {\n        ObjectType objAlternate = ObjectType.cast(alternate);\n        if (objAlternate != null && objAlternate.isRecordType()) {\n          // Apply the property inference logic to this specific object alternate.\n          for (String prop : constraintObj.getOwnPropertyNames()) {\n            JSType propType = constraintObj.getPropertyType(prop);\n            // We only want to infer properties that are not explicitly declared.\n            // This is to avoid overwriting user-declared types.\n            if (!objAlternate.isPropertyTypeDeclared(prop)) {\n              JSType typeToInfer;\n              if (!objAlternate.hasProperty(prop)) {\n                // If the property does not exist at all on the inferred object,\n                // infer it as a union of undefined and the constraint property type.\n                // This makes the property optional (undefined) if it's not present.\n                typeToInfer =\n                    getNativeType(VOID_TYPE).getLeastSupertype(propType);\n              } else {\n                // If the property exists but is inferred (not declared),\n                // widen its current inferred type with the constraint property type.\n                // This ensures the inferred property's type is a supertype of both\n                // its current inferred type and the constraint's type.\n                typeToInfer = objAlternate.getPropertyType(prop).getLeastSupertype(propType);\n              }\n              objAlternate.defineInferredProperty(prop, typeToInfer, null);\n            }\n          }\n        }\n      }\n    } else {\n      // If the type to be inferred upon is a single object type (not a union).\n      ObjectType objType = ObjectType.cast(restrictedType);\n      if (objType != null && objType.isRecordType()) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!objType.isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer;\n            if (!objType.hasProperty(prop)) {\n              typeToInfer =\n                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n            } else {\n              typeToInfer = objType.getPropertyType(prop).getLeastSupertype(propType);\n            }\n            objType.defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}