{
    "generation": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n\n  // First strip null/undefined from the type we're inferring on.\n  JSType restrictedType = type.restrictByNotNullOrUndefined();\n\n  // If it's a union, recurse on each alternate.\n  if (restrictedType.isUnionType()) {\n    // Note: UnionType is in com.google.javascript.rhino.jstype\n    UnionType union = (UnionType) restrictedType;\n    for (JSType alt : union.getAlternates()) {\n      inferPropertyTypesToMatchConstraint(alt, constraint);\n    }\n    return;\n  }\n\n  // Now try to widen any missing record\u2010type properties.\n  ObjectType objType = ObjectType.cast(restrictedType);\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n  if (constraintObj != null && constraintObj.isRecordType() && objType != null) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!objType.isPropertyTypeDeclared(prop)) {\n        JSType toInfer = propType;\n        // If the object has no such property at all, include `void` so that\n        // missing\u2010property accesses yield `undefined` rather than an error.\n        if (!objType.hasProperty(prop)) {\n          toInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n        }\n        objType.defineInferredProperty(prop, toInfer, null);\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}