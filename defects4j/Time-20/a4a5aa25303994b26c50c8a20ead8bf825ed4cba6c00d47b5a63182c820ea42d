{
    "generation": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n\n            // The original ALL_IDS (likely from DateTimeZone.getAvailableIDs()) is a Set,\n            // whose iteration order is not guaranteed and can lead to shorter IDs being matched\n            // before longer, more specific ones (e.g., \"America/Dawson\" being matched before\n            // \"America/Dawson_Creek\"). This causes the parser to fail on the remainder.\n            // To fix this, we must ensure that longer, more specific time zone IDs are\n            // attempted first. This is achieved by sorting the IDs by length in descending order.\n            // If lengths are equal, an alphabetical sort is used to ensure deterministic behavior.\n            List<String> sortedIds = new ArrayList<>(ALL_IDS);\n            Collections.sort(sortedIds, new Comparator<String>() {\n                @Override\n                public int compare(String s1, String s2) {\n                    // Sort by length in descending order (longer strings first)\n                    int lenCompare = Integer.compare(s2.length(), s1.length());\n                    if (lenCompare != 0) {\n                        return lenCompare;\n                    }\n                    // If lengths are equal, sort alphabetically (ascending) for deterministic behavior\n                    return s1.compareTo(s2);\n                }\n            });\n\n            for (String id : sortedIds) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}