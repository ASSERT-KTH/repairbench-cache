{
    "generation": "/**\n * Look for a type declaration on a property assignment\n * (in an ASSIGN or an object literal key).\n *\n * @param info The doc info for this property.\n * @param lValue The l-value node.\n * @param rValue The node that {@code n} is being initialized to,\n *     or {@code null} if this is a stub declaration.\n */\nprivate JSType getDeclaredType(\n    String sourceName, JSDocInfo info, Node lValue, @Nullable Node rValue) {\n\n  // 1) If the property itself has an explicit @type, use that.\n  if (info != null && info.hasType()) {\n    return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n  }\n\n  // 2) If the initializer has its own @type (e.g. a cast on the RHS),\n  //    honor that before inferring anything else.\n  if (rValue != null) {\n    JSDocInfo rInfo = rValue.getJSDocInfo();\n    if (rInfo != null && rInfo.hasType()) {\n      return getDeclaredTypeInAnnotation(sourceName, lValue, rInfo);\n    }\n  }\n\n  // 3) If we're assigning a function literal and it makes sense to use its\n  //    literal type, do so.\n  if (rValue != null && rValue.isFunction()\n      && shouldUseFunctionLiteralType(\n            JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n    return rValue.getJSType();\n  }\n\n  // 4) Otherwise, if we have any JSDoc on the property at all, handle\n  //    enums, constructors, interfaces, or constants specially.\n  if (info != null) {\n    if (info.hasEnumParameterType()) {\n      if (rValue != null && rValue.isObjectLit()) {\n        return rValue.getJSType();\n      } else {\n        return createEnumTypeFromNodes(\n            rValue, lValue.getQualifiedName(), info, lValue);\n      }\n    } else if (info.isConstructor() || info.isInterface()) {\n      return createFunctionTypeFromNodes(\n          rValue, lValue.getQualifiedName(), info, lValue);\n    } else if (info.isConstant()) {\n      if (rValue != null) {\n        // If the right-hand side already has a meaningful type, use it.\n        JSType rhsType = rValue.getJSType();\n        if (rhsType != null && !rhsType.isUnknownType()) {\n          return rhsType;\n        }\n        // Special \"x = x || TYPE\" constant initialization idiom.\n        if (rValue.isOr()) {\n          Node first = rValue.getFirstChild();\n          Node second = first.getNext();\n          boolean sameName =\n              first.isName()\n              && lValue.isName()\n              && first.getString().equals(lValue.getString());\n          if (sameName) {\n            JSType secondType = second.getJSType();\n            if (secondType != null && !secondType.isUnknownType()) {\n              return secondType;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 5) Fallback: re-use whatever type annotation (if any) is on the property.\n  return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}