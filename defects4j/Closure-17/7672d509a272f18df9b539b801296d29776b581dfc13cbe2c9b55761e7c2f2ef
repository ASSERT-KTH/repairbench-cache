{
    "generation": "    /**\n     * Look for a type declaration on a property assignment\n     * (in an ASSIGN or an object literal key).\n     *\n     * @param info The doc info for this property.\n     * @param lValue The l-value node.\n     * @param rValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      // 1. Explicit @type on lValue takes precedence\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      }\n\n      // 2. Function literal rValue with specific conditions\n      if (rValue != null && rValue.isFunction() &&\n          shouldUseFunctionLiteralType(\n              JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n        // Function literal defines the type\n        return rValue.getJSType();\n      }\n\n      // 3. Specific lValue markers (@enum, @constructor, @interface)\n      if (info != null) {\n        if (info.hasEnumParameterType()) {\n          // Enum type definition\n          if (rValue != null && rValue.isObjectLit()) {\n             // If assigned an object literal, its type might be the enum value type.\n             // Note: This might be inaccurate if the object literal doesn't match the enum.\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          // Function type definition (constructor/interface)\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        }\n        // Not handled here: @const or other annotations. Proceed below.\n      }\n\n      // 4. Check @const specifically (if info present and isConstant)\n      // This is handled after specific type-defining annotations but before the final fallback.\n      if (info != null && info.isConstant()) {\n          if (rValue != null) {\n            // Check 1: Known type from rValue (CAST, literal, variable ref, etc.)\n            JSType rValueType = rValue.getJSType();\n            if (rValueType != null && !rValueType.isUnknownType()) {\n              // If rValue's type was already computed, use that.\n              // This handles CASTs `/** @type {T} */ (expr)` correctly if the CAST type is populated.\n              return rValueType;\n            }\n            // Check 2: OR idiom (var x = x || TYPE;)\n            else if (rValue.isOr()) {\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                // Check structure: first clause must be a name, lValue must be a name, names must match.\n                boolean namesMatch = lValue.isName()\n                    && firstClause.isName()\n                    && lValue.getString().equals(firstClause.getString());\n                if (namesMatch) {\n                    // If names match, try to use the type of the second clause (the default value).\n                    JSType secondClauseType = secondClause.getJSType();\n                    if (secondClauseType != null && !secondClauseType.isUnknownType()) {\n                        return secondClauseType;\n                    }\n                }\n            }\n            // If rValue type is unknown/null or it's not the specific OR idiom,\n            // we cannot determine the type from rValue here.\n          }\n          // For @const, the type must come from initialization or an explicit @type.\n          // If we are here, it means @const was present, but we couldn't determine\n          // the type from the rValue at this stage. Return null to let\n          // subsequent type inference determine the type (hopefully respecting the rValue/CAST).\n          return null;\n      }\n\n      // 5. Fallback if none of the above determined the type.\n      // This happens if info is null, or info is present but didn't have @type,\n      // wasn't enum/ctor/iface, and wasn't @const.\n      // It essentially means no declaration JSDoc provided usable type info.\n      // We still call getDeclaredTypeInAnnotation as a last resort, though it will likely\n      // return null if info is null or has no type.\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}