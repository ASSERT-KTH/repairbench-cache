{
    "generation": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      // If the type has a reference name (e.g., named type or proxy):\n      if (forAnnotations) {\n        // For annotations, delegate to the referenced type's annotation string.\n        // JSType#toAnnotationString handles nulls and recursion detection (returning \"?\").\n        JSType referenced = getReferencedTypeInternal();\n        return referenced == null ? \"?\" : referenced.toAnnotationString();\n      } else {\n        // For regular toString(), just return the name. This avoids infinite loops\n        // for recursive types by not expanding the definition.\n        return getReferenceName();\n      }\n    }\n\n    // Handle types without a reference name (like anonymous records/objects).\n    if (forAnnotations) {\n      // Annotation strings should be complete and not truncated.\n      // Recursion is handled by JSType#toAnnotationString calls on property types.\n      Set<String> propertyNames = Sets.newTreeSet(); // Sorted properties\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType();\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n        sb.append(property);\n        sb.append(\": \");\n        JSType propType = getPropertyType(property);\n        // Use toAnnotationString for property types.\n        sb.append(propType.toAnnotationString());\n        ++i;\n        // No truncation for annotations.\n      }\n      sb.append(\"}\");\n      return sb.toString();\n\n    } else {\n      // Handle regular toString(). Use prettyPrint flag for recursion detection\n      // and apply truncation limit.\n      if (prettyPrint) {\n        // Set flag to false to detect recursive calls to toString().\n        prettyPrint = false;\n\n        // Use a tree set so that the properties are sorted.\n        Set<String> propertyNames = Sets.newTreeSet();\n        for (ObjectType current = this;\n             current != null && !current.isNativeObjectType();\n             current = current.getImplicitPrototype()) {\n          // Collect all properties to correctly determine if truncation is needed.\n          propertyNames.addAll(current.getOwnPropertyNames());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n\n        int i = 0;\n        boolean truncated = false;\n        for (String property : propertyNames) {\n          // Check limit *before* appending the property.\n          if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n            truncated = true;\n            break; // Stop processing properties\n          }\n\n          if (i > 0) {\n            sb.append(\", \");\n          }\n\n          sb.append(property);\n          sb.append(\": \");\n          JSType propType = getPropertyType(property);\n          // Use toString() for property types (will return \"{...}\" on recursion).\n          sb.append(propType.toString());\n\n          ++i;\n        }\n\n        // Append \"...\" only if we stopped early *and* there were more properties than the limit.\n        if (truncated && propertyNames.size() > MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n        }\n\n        sb.append(\"}\");\n\n        // Restore flag state.\n        prettyPrint = true;\n        return sb.toString();\n      } else {\n        // We are in a recursive toString() call (prettyPrint was false).\n        return \"{...}\";\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}