{
    "generation": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      // If forAnnotations is true, we should use the reference name.\n      // If forAnnotations is false, we might want to use the reference name\n      // or we might want to print the structural type. The old code always\n      // returned the reference name, so we keep that behavior.\n      return getReferenceName();\n    } else if (prettyPrint) { // Check if pretty printing is allowed for this level\n      // Prevent infinite recursion:\n      // Set prettyPrint to false only for the duration of this call.\n      // Use try-finally to ensure it's always restored.\n      prettyPrint = false;\n      try {\n        // Use a tree set so that the properties are sorted.\n        Set<String> propertyNames = Sets.newTreeSet();\n        // Collect properties from this type and its prototypes\n        for (ObjectType current = this;\n             current != null && !current.isNativeObjectType();\n             current = current.getImplicitPrototype()) {\n          propertyNames.addAll(current.getOwnPropertyNames());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n\n        int count = 0;\n        boolean truncated = false;\n        // Iterate through sorted property names\n        for (String property : propertyNames) {\n           // Check if we have already printed the maximum allowed properties.\n           // This limit only applies if forAnnotations is false.\n           if (!forAnnotations && count >= MAX_PRETTY_PRINTED_PROPERTIES) {\n               truncated = true;\n               break; // Stop processing further properties\n           }\n\n           if (count > 0) {\n             sb.append(\", \");\n           }\n\n           sb.append(property);\n           sb.append(\": \");\n           JSType propType = getPropertyType(property);\n           // Recursively get the string representation of the property type,\n           // passing the forAnnotations flag down. Handle null defensively.\n           sb.append(propType == null ? \"null\" : propType.toStringHelper(forAnnotations));\n           count++;\n        }\n\n        if (truncated) {\n            sb.append(\", ...\"); // Append ellipsis if properties were truncated\n        }\n\n        sb.append(\"}\");\n        return sb.toString();\n\n      } finally {\n        // Restore prettyPrint flag regardless of exceptions during property processing\n        prettyPrint = true;\n      }\n    } else { // Not pretty printing (likely due to recursion detected by prettyPrint == false)\n      // Return \"?\" if for annotations (representing recursive type), otherwise \"{...}\"\n      return forAnnotations ? \"?\" : \"{...}\";\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}