{
    "generation": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      // Determine the maximum number of properties to collect from the prototype chain.\n      // If forAnnotations is true, we want to collect all properties without limit.\n      // Otherwise, we limit to MAX_PRETTY_PRINTED_PROPERTIES.\n      int maxPropertiesToCollect = forAnnotations ? Integer.MAX_VALUE : MAX_PRETTY_PRINTED_PROPERTIES;\n\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= maxPropertiesToCollect;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      // Determine the maximum number of properties to print.\n      // If forAnnotations is true, print all collected properties.\n      // Otherwise, limit to MAX_PRETTY_PRINTED_PROPERTIES.\n      int maxPropertiesToPrint = forAnnotations ? Integer.MAX_VALUE : MAX_PRETTY_PRINTED_PROPERTIES;\n\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        // Call toString() on the property type. This will recursively call\n        // toStringHelper(false) for its own string representation.\n        // For annotation strings, the expectation is typically for \"recursive\" types\n        // like ProxyObjectType to print \"?\" or \"{...}\" which is handled by\n        // toStringHelper's 'prettyPrint' flag or specific overrides.\n        // The test failure indicates truncation is the primary issue.\n        sb.append(getPropertyType(property).toString());\n\n        ++i;\n        // Apply truncation logic only if not for annotations and the print limit is reached.\n        if (!forAnnotations && i == maxPropertiesToPrint) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      // This path is taken during recursive calls when prettyPrint is false.\n      // This ensures that deeply nested or recursive types do not cause infinite loops\n      // and are represented concisely (e.g., \"{...}\").\n      // The expectation for '?' in annotation strings for recursive ProxyObjectType\n      // is handled by ProxyObjectType's toString() or toAnnotationString() if overridden,\n      // not by this general toStringHelper path.\n      return \"{...}\";\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}