{
    "generation": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      // Set to false to prevent infinite recursion, and indicate that\n      // this object is currently being pretty-printed.\n      prettyPrint = false;\n\n      // First, collect all unique property names from this object and its prototypes.\n      Set<String> allPropertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType();\n           current = current.getImplicitPrototype()) {\n        allPropertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      // Determine which properties to print and if truncation is needed.\n      Set<String> propertiesToPrint = Sets.newTreeSet();\n      boolean truncated = false;\n\n      if (forAnnotations) {\n        // For annotations, we don't truncate properties.\n        propertiesToPrint = allPropertyNames;\n      } else {\n        // For regular toString(), we apply the MAX_PRETTY_PRINTED_PROPERTIES limit.\n        int count = 0;\n        for (String property : allPropertyNames) {\n          if (count >= MAX_PRETTY_PRINTED_PROPERTIES) {\n            truncated = true;\n            break;\n          }\n          propertiesToPrint.add(property);\n          count++;\n        }\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertiesToPrint) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n\n        // Recursively call the appropriate toString method based on forAnnotations.\n        // This ensures nested types are also formatted correctly (e.g., '?' for recursive types).\n        if (forAnnotations) {\n          sb.append(getPropertyType(property).toAnnotationString());\n        } else {\n          sb.append(getPropertyType(property).toString());\n        }\n\n        ++i;\n      }\n\n      // Append \"...\" if the property list was truncated.\n      if (truncated) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n        sb.append(\"...\");\n      }\n\n      sb.append(\"}\");\n\n      // Restore prettyPrint state.\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      // If prettyPrint is false (either it was initially false, or this is a recursive call\n      // and the outer call set it to false), return a placeholder.\n      // The placeholder depends on whether this is for annotations.\n      if (forAnnotations) {\n        // For annotation strings, recursive types are represented as '?'.\n        return \"?\";\n      } else {\n        // For regular toString(), recursive types are represented as '{...}'.\n        return \"{...}\";\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}