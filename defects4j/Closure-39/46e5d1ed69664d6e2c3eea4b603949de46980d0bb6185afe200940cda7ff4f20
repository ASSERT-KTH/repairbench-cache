{
    "generation": "@Override\nString toStringHelper(boolean forAnnotations) {\n  if (hasReferenceName()) {\n    return getReferenceName();\n  }\n  // If we are already in the middle of pretty printing (i.e. a recursive call),\n  // return the abbreviated form: \"?\" for annotations, \"{...}\" otherwise.\n  if (!prettyPrint) {\n    return forAnnotations ? \"?\" : \"{...}\";\n  }\n\n  // Begin pretty printing for this object.\n  prettyPrint = false;\n\n  // Use a tree set so that the properties are sorted.\n  Set<String> propertyNames = Sets.newTreeSet();\n  for (ObjectType current = this;\n       current != null && !current.isNativeObjectType();\n       current = current.getImplicitPrototype()) {\n    propertyNames.addAll(current.getOwnPropertyNames());\n    // For toString (non-annotation) calls, we only need to collect a few properties.\n    if (!forAnnotations && propertyNames.size() > MAX_PRETTY_PRINTED_PROPERTIES) {\n      break;\n    }\n  }\n\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"{\");\n\n  int count = 0;\n  int totalProperties = propertyNames.size();\n  for (String property : propertyNames) {\n    if (count > 0) {\n      sb.append(\", \");\n    }\n    sb.append(property).append(\": \");\n    sb.append(forAnnotations ? getPropertyType(property).toAnnotationString()\n                             : getPropertyType(property).toString());\n    count++;\n    // For non-annotation printing, if we have reached the limit and there are more\n    // properties, show an ellipsis.\n    if (!forAnnotations && count == MAX_PRETTY_PRINTED_PROPERTIES && count < totalProperties) {\n      sb.append(\", ...\");\n      break;\n    }\n  }\n\n  sb.append(\"}\");\n  prettyPrint = true;\n  return sb.toString();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}