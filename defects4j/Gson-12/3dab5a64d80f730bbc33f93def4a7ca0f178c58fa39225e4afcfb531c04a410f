{
    "generation": "  @Override public void skipValue() throws IOException {\n    if (stackSize == 0) {\n      throw new IllegalStateException(\"JsonReader is closed\");\n    }\n\n    JsonToken token = peek();\n\n    switch (token) {\n      case BEGIN_ARRAY:\n        beginArray(); // Consumes BEGIN_ARRAY, pushes array's iterator\n        while (hasNext()) { // Checks if array has more elements\n          skipValue(); // Recursively skips each element\n        }\n        endArray(); // Consumes END_ARRAY, pops array's iterator\n        break;\n\n      case BEGIN_OBJECT:\n        beginObject(); // Consumes BEGIN_OBJECT, pushes object's iterator\n        while (hasNext()) { // Checks if object has more entries\n          nextName(); // Consumes the name, updates pathNames, pushes value\n          skipValue(); // Recursively skips the value associated with the name\n        }\n        endObject(); // Consumes END_OBJECT, pops object's iterator\n        break;\n\n      case NAME:\n        // When peek() is NAME, it means we are at a key.\n        // nextName() consumes the key and pushes its value onto the stack.\n        // So, after nextName(), the value is at the top of the stack and needs to be skipped.\n        nextName();\n        skipValue(); // Now skip the value that was pushed by nextName()\n        break;\n\n      case STRING:\n      case NUMBER:\n      case BOOLEAN:\n      case NULL:\n        // These are primitive values. Just pop them from the stack.\n        // The pathIndices update for the parent is handled consistently with other nextX() methods.\n        popStack();\n        if (stackSize > 0) {\n          pathIndices[stackSize - 1]++;\n        }\n        break;\n\n      default:\n        // This case should ideally not be reached if peek() correctly covers all states.\n        throw new IllegalStateException(\"Expected a value or object/array, but was \" + token);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}