{
    "generation": "  @Override public void skipValue() throws IOException {\n    // Determine the current token type.\n    // In JsonTreeReader, the peek() method itself might push state onto the stack\n    // (e.g., iterators for JsonObject/JsonArray) to prepare for reading their contents.\n    JsonToken token = peek();\n\n    // Based on the token type, consume the value appropriately.\n    switch (token) {\n      case BEGIN_ARRAY:\n        // For a JSON array, we need to consume the entire array.\n        // beginArray() processes the BEGIN_ARRAY token.\n        beginArray();\n        // Skip all elements within the array until END_ARRAY is encountered.\n        while (peek() != JsonToken.END_ARRAY) {\n          skipValue(); // Recursively skip each element\n        }\n        // endArray() processes the END_ARRAY token and pops the array's state from the stack.\n        endArray();\n        break;\n\n      case BEGIN_OBJECT:\n        // For a JSON object, we need to consume the entire object.\n        // beginObject() processes the BEGIN_OBJECT token.\n        beginObject();\n        // Skip all name-value pairs within the object until END_OBJECT is encountered.\n        while (peek() != JsonToken.END_OBJECT) {\n          // nextName() consumes the property name and sets up the stack to point to its value.\n          nextName();\n          // After consuming the name, recursively skip the associated value.\n          skipValue();\n        }\n        // endObject() processes the END_OBJECT token and pops the object's state from the stack.\n        endObject();\n        break;\n\n      case NAME:\n        // If the current token is a NAME (i.e., we are within an object and about to read a key),\n        // we first consume the name.\n        nextName();\n        // After nextName(), the value corresponding to that name is now at the top of the stack.\n        // We must then skip this value as well.\n        skipValue(); // Recursively skip the value\n        break;\n\n      // For primitive types (STRING, NUMBER, BOOLEAN, NULL),\n      // we simply call the corresponding nextX() method which consumes the value\n      // and handles stack manipulation and path updates internally, including array index bounds checks.\n      case STRING:\n        nextString();\n        break;\n      case NUMBER:\n        nextDouble(); // nextDouble() can consume any number type (int, long, double)\n        break;\n      case BOOLEAN:\n        nextBoolean();\n        break;\n      case NULL:\n        nextNull();\n        break;\n\n      // These tokens signify the end of a structure or document.\n      // If skipValue() is called when the current token is one of these, it usually indicates an error\n      // in the caller's logic or a state where there's nothing more to skip at this level.\n      case END_DOCUMENT:\n      case END_OBJECT:\n      case END_ARRAY:\n        throw new IllegalStateException(\"Unexpected token \" + token + \" when skipping.\");\n    }\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}