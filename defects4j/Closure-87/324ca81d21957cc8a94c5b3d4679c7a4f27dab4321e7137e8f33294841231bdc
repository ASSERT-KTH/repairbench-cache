{
    "generation": "private boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK && n.hasOneChild()) {\n    Node child = n.getFirstChild();\n    if (!NodeUtil.isExpressionNode(child)) {\n      return false;\n    }\n\n    // If the only statement is an expression result, check for calls.\n    if (child.getType() == Token.EXPR_RESULT) {\n      Node expr = child.getFirstChild();\n      if (expr != null && expr.getType() == Token.CALL) {\n        Node callee = expr.getFirstChild();\n        if (callee != null) {\n          // Only allow folding if the call is made through a property-access.\n          if (callee.getType() == Token.GETPROP) {\n            Node prop = callee.getLastChild();\n            if (prop != null && prop.getType() == Token.STRING) {\n              String propName = prop.getString();\n              // If this is a call to an \"on...\" method (an event handler)\n              // then we only want to fold it when the surrounding IF\n              // has a literal condition (so that its return value isn\u2019t used).\n              if (propName.length() > 2 && propName.startsWith(\"on\")) {\n                Node parent = n.getParent();\n                if (parent != null && parent.getType() == Token.IF) {\n                  Node cond = parent.getFirstChild();\n                  if (cond != null) {\n                    int condType = cond.getType();\n                    if (condType == Token.TRUE || condType == Token.FALSE || condType == Token.NUMBER) {\n                      return true;\n                    }\n                  }\n                }\n                return false;\n              }\n            }\n            return true;\n          }\n          // Do not fold if the call isn\u2019t via a property (e.g. computed property access)\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}