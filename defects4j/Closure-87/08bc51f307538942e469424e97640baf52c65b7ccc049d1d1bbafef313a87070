{
    "generation": "private boolean isFoldableExpressBlock(Node n) {\n  // Must be a block with exactly one statement.\n  if (n.getType() != Token.BLOCK || !n.hasOneChild()) {\n    return false;\n  }\n  Node stmt = n.getFirstChild();\n  // In a normal JS AST a lone expression in a block is wrapped in an EXPR_RESULT.\n  // Unwrap that to get the underlying expression.\n  if (stmt.getType() == Token.EXPR_RESULT && stmt.hasOneChild()) {\n    stmt = stmt.getFirstChild();\n  }\n  // Only expression nodes are foldable.\n  if (!NodeUtil.isExpressionNode(stmt)) {\n    return false;\n  }\n  // If the expression is a function call, be extra careful.\n  // The IE bug [issue 291] occurs when a method-call with an implicit \"this\"\n  // is folded into an expression (via the && operator) when the method name\n  // starts with \"on\".\n  if (stmt.getType() == Token.CALL) {\n    Node callee = stmt.getFirstChild();\n    // Only allow a simple property access (i.e. f.foo() not f[\"foo\"]())\n    if (callee == null || callee.getType() != Token.GETPROP || callee.isComputed()) {\n      return false;\n    }\n    Node propNode = callee.getLastChild();\n    if (propNode != null && propNode.getType() == Token.STRING) {\n      String propName = propNode.getString();\n      // If the property name starts with \"on\", then folding into an alternate syntax\n      // (which would change the implicit \"this\" value) is unsafe in IE.\n      if (propName.length() > 2 && propName.startsWith(\"on\")) {\n        return false;\n      }\n    }\n  }\n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}