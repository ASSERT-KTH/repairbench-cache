{
    "generation": "private boolean isFoldableExpressBlock(Node n) {\n  // Only blocks with one child can be folded.\n  if (n.getType() == Token.BLOCK && n.hasOneChild()) {\n    Node stmt = n.getFirstChild();\n    // If the block\u2019s child is an EXPR_RESULT, \u201cunwrap\u201d it.\n    if (stmt.getType() == Token.EXPR_RESULT) {\n      Node expr = stmt.getFirstChild();\n      // If the expression is a call, we must check further.\n      if (expr != null && expr.getType() == Token.CALL) {\n        Node callee = expr.getFirstChild();\n        // Only method calls written in the dot (GETPROP) style are safe.\n        if (callee == null || callee.getType() != Token.GETPROP) {\n          return false;\n        }\n        Node prop = callee.getLastChild();\n        // For calls like f.onchange(), the IE bug prevents us from folding\n        // if the call\u2019s return value would be used (e.g. in an && expression).\n        // However, if the block is the then\u2013branch of an if whose condition \n        // is a literal true, the value isn\u2019t used, so folding is allowed.\n        if (prop != null && prop.getString() != null && prop.getString().startsWith(\"on\")) {\n          Node parent = n.getParent();\n          if (parent == null ||\n              parent.getType() != Token.IF ||\n              !NodeUtil.isLiteralValue(parent.getFirstChild(), true)) {\n            return false;\n          }\n        }\n      }\n      return NodeUtil.isExpressionNode(expr);\n    }\n    return NodeUtil.isExpressionNode(stmt);\n  }\n  return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}