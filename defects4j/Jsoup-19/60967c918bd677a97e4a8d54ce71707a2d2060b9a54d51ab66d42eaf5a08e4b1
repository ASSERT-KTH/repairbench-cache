{
    "generation": "    private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n        // Use the original value for protocol validation.\n        String originalValue = attr.getValue();\n        // Allow empty values (considered safe) - note that absUrl may resolve an empty string to the base URI, so check original first.\n        if (originalValue.isEmpty()) {\n            return true;\n        }\n\n        // Check if the original value starts with an allowed protocol.\n        boolean protocolIsValid = false;\n        for (Protocol protocol : protocols) {\n            String prot = protocol.toString() + \":\";\n            if (originalValue.toLowerCase().startsWith(prot)) {\n                protocolIsValid = true;\n                break;\n            }\n        }\n\n        if (protocolIsValid) {\n            // Original value has a valid protocol (e.g., \"http:\", \"cid:\", \"data:\").\n            // Decide whether to update the attribute value based on preserveRelativeLinks.\n            if (!preserveRelativeLinks) {\n                // Attempt to resolve the URL to an absolute path.\n                String resolvedValue = el.absUrl(attr.getKey());\n\n                // If absUrl returns an empty string for a non-empty original value,\n                // it indicates resolution failure (e.g., for \"cid:\", \"data:\", or relative path without base URI).\n                // In this case, since the original protocol *was* valid, we should *keep* the original value,\n                // as trying to update it with an empty string would be incorrect.\n                if (resolvedValue.isEmpty() && !originalValue.isEmpty()) {\n                    // Keep original value - do nothing here, as attr already holds originalValue.\n                } else {\n                    // Otherwise, resolution likely succeeded or the original value was empty. Update the attribute.\n                    attr.setValue(resolvedValue);\n                }\n            }\n            // If preserveRelativeLinks is true, we don't modify the attribute anyway.\n            return true; // Protocol is valid.\n        } else {\n            // Original value does not start with an allowed protocol.\n            // It might be a relative URL that resolves to an allowed protocol.\n            // Let's check the resolved URL ONLY if the original didn't match.\n            String resolvedValue = el.absUrl(attr.getKey());\n\n            // If resolvedValue is empty OR same as original, then it's not a successfully resolved relative URL\n            // (or absUrl couldn't handle it). Since original failed validation, this case is invalid too.\n            if (resolvedValue.isEmpty() || resolvedValue.equals(originalValue)) {\n                 return false;\n            }\n\n            // Check if the resolved URL (which is different from original) has a valid protocol.\n            boolean resolvedProtocolIsValid = false;\n            for (Protocol protocol : protocols) {\n                String prot = protocol.toString() + \":\";\n                 if (resolvedValue.toLowerCase().startsWith(prot)) {\n                    resolvedProtocolIsValid = true;\n                    break;\n                }\n            }\n\n            if (resolvedProtocolIsValid) {\n                // The resolved relative URL has a valid protocol.\n                 if (!preserveRelativeLinks) {\n                     // Update the attribute to the absolute/resolved value.\n                     attr.setValue(resolvedValue);\n                 }\n                 // If preserveRelativeLinks is true, we keep the original relative URL,\n                 // but the link is considered safe because it resolves to a valid protocol.\n                 return true;\n            } else {\n                // Resolved relative URL also doesn't have a valid protocol.\n                return false;\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}