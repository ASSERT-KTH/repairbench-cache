{
    "generation": "import org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.safety.Whitelist; // Ensure this import points to the correct Protocol definition\n\nimport java.util.Set;\n\n// Assume 'preserveRelativeLinks' is a field in the enclosing class like:\n// private boolean preserveRelativeLinks = false;\n\n    /**\n     * Tests the value of the attribute against the provided protocols. If the value is relative, it is resolved\n     * against the element's base URI. Optionally, if preserveRelativeLinks is false, the attribute value is updated\n     * to the resolved absolute URL.\n     *\n     * @param el        the element holding the attribute\n     * @param attr      the attribute to test\n     * @param protocols allowed protocols (e.g., http, https, cid, data)\n     * @return true if the attribute is allowed according to the protocols, false otherwise\n     */\n    private boolean testValidProtocol(Element el, Attribute attr, Set<Whitelist.Protocol> protocols) {\n        // Get the original attribute value.\n        String origValue = attr.getValue();\n        // Trim whitespace and convert to lower case for case-insensitive protocol checking.\n        String lowerOrigValueTrimmed = origValue.toLowerCase().trim();\n\n        // Allow empty attributes? Current behavior is they fail the startsWith check, considered invalid. Keep this.\n        // If empty value should be allowed, it would require an explicit check here.\n\n        // 1. Check if the original value *already* starts with an allowed protocol.\n        boolean origIsValid = false;\n        for (Whitelist.Protocol protocol : protocols) {\n            String prot = protocol.toString() + \":\";\n            if (lowerOrigValueTrimmed.startsWith(prot)) {\n                origIsValid = true;\n                break;\n            }\n        }\n\n        if (origIsValid) {\n            // The original value uses an allowed protocol (e.g., \"http:\", \"https:\", \"cid:\", \"data:\").\n            // This attribute is potentially valid based on its declared protocol.\n            // Now, optionally resolve to absolute URL if !preserveRelativeLinks.\n            if (!preserveRelativeLinks) {\n                // Attempt to resolve the URL to an absolute form using the element's base URI.\n                String absValue = el.absUrl(attr.getKey());\n                // Update the attribute value only if resolution yielded a non-empty result.\n                // This is crucial: it preserves the original value for schemes like 'cid:' or 'data:'\n                // if absUrl() cannot resolve them meaningfully or returns an empty string for them.\n                if (absValue != null && !absValue.isEmpty()) {\n                    attr.setValue(absValue);\n                }\n                // If absValue is empty or null, the attribute implicitly retains its original value, which is correct.\n            }\n            return true; // Valid based on the protocol found in the original value.\n        } else {\n            // 2. The original value does not start with an allowed protocol.\n            // It could be a relative path (\"foo.jpg\"), an absolute path (\"/img/bar.png\"),\n            // or a protocol-relative URL (\"//example.com/baz.gif\").\n            // We need to resolve it against the base URI to get an absolute URL.\n            String absValue = el.absUrl(attr.getKey());\n\n            // If resolution failed (returned empty or null string), the URL is considered invalid.\n            // This handles cases like invalid relative URLs, or relative URLs when no base URI is available.\n            if (absValue == null || absValue.isEmpty()) {\n                return false;\n            }\n\n            // 3. Check if the *resolved* absolute URL starts with an allowed protocol.\n            String lowerAbsValue = absValue.toLowerCase();\n            boolean resolvedIsValid = false;\n            for (Whitelist.Protocol protocol : protocols) {\n                String prot = protocol.toString() + \":\";\n                if (lowerAbsValue.startsWith(prot)) {\n                    resolvedIsValid = true;\n                    break;\n                }\n            }\n\n            if (resolvedIsValid) {\n                // The resolved URL (which is absolute) uses an allowed protocol (e.g., starts with \"http:\", \"https:\").\n                // The attribute is valid.\n                // Optionally update the attribute to the absolute value if !preserveRelativeLinks.\n                if (!preserveRelativeLinks) {\n                    // Update the attribute to the resolved absolute URL.\n                    // We already know absValue is non-empty and non-null from the check above.\n                    attr.setValue(absValue);\n                }\n                // If preserveRelativeLinks is true, the attribute keeps its original relative value, which is also correct.\n                return true; // Valid based on the protocol of the resolved URL.\n            } else {\n                // The resolved absolute URL's protocol is not in the allowed set (e.g., resolved to 'ftp:' but only 'http' allowed).\n                return false; // Invalid.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}