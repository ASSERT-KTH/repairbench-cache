{
    "generation": "  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match constraints on anonymous types.\n\n    // Handle the case where the constraint object is a record type.\n    // Example:\n    // constraintObj == {prop: (number|undefined)}\n    // function f(constraintObj) {}\n    // f({});\n    // We want to modify the object literal {} ('this') to match the constraint,\n    // making its type {prop: (number|undefined)}.\n    if (constraintObj.isRecordType()) {\n      ObjectType constraintRecord = constraintObj.toObjectType(); // Use ObjectType API\n      for (String prop : constraintRecord.getOwnPropertyNames()) {\n        JSType propType = constraintRecord.getPropertyType(prop);\n        // getPropertyType returns null if the property is not defined on the object type.\n        // Record types obtained from parameter types should always have defined properties.\n        if (propType == null) {\n          // This case should ideally not happen for valid record constraints.\n          continue;\n        }\n\n        // We only modify properties that are not explicitly declared on 'this'.\n        if (!isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = null;\n          // getPropertyType returns the type of the property, or null if it's not present.\n          JSType existingType = getPropertyType(prop);\n          boolean needsUpdate = false;\n\n          if (!hasProperty(prop)) {\n            // Property is missing on 'this'. Define it based on the constraint,\n            // making it optional (union with void).\n            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);\n            needsUpdate = true; // Definitely need to add the property.\n          } else {\n            // Property exists on 'this'. We might need to update its type to match the constraint.\n            typeToInfer = propType; // The target type is the constraint's type.\n\n            // Check if the existing type is already equivalent to the target type.\n            // Avoid redundant updates if the types already match.\n            // Use equals() for type comparison, handle case where existingType might be null.\n            if (existingType == null || !existingType.equals(typeToInfer)) {\n               needsUpdate = true;\n            }\n            // If existingType equals typeToInfer, needsUpdate remains false.\n          }\n\n          // Only call defineInferredProperty if we determined an update is needed.\n          // This avoids unnecessary modifications that might trigger side effects.\n          if (needsUpdate) {\n            defineInferredProperty(prop, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}