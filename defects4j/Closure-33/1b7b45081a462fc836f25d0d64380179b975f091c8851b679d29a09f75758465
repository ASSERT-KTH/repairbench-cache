{
    "generation": "  @Override\n  public void matchConstraint(ObjectType constraintObj) {\n    // We only want to match constraints on anonymous types (like object literals).\n    // This function is called on the anonymous type itself.\n\n    // Handle the case where the constraint object is a record type.\n    //\n    // Example:\n    // /** @param {{prop: (number|undefined)}} constraintObj */\n    // function f(constraintObj) {}\n    // f({}); // 'this' is the type of {}\n    //\n    // The goal is to refine the types of properties *present* on this anonymous type\n    // based on the types expected by the constraint. We do not add properties\n    // that are missing from the anonymous type.\n    if (constraintObj.isRecordType()) {\n      ObjectType constraintRecord = constraintObj.toObjectType(); // Safely cast\n      if (constraintRecord == null) {\n        // Should not happen if isRecordType is true, but defensively check.\n        return;\n      }\n\n      // Iterate through properties defined in the constraint record type.\n      for (String prop : constraintRecord.getOwnPropertyNames()) {\n        JSType propType = constraintRecord.getPropertyType(prop);\n        // Check if 'this' anonymous type has the property, but it hasn't been\n        // explicitly declared (e.g., via @type) or previously inferred with a\n        // conflicting type. We only want to refine initially inferred types.\n        if (hasProperty(prop) && !isPropertyTypeDeclared(prop)) {\n          // Define the property type on 'this' based on the constraint.\n          // This helps in refining the inferred type of the object literal property\n          // to match the context where it's used.\n          // Note: This does not handle potential type conflicts if the property\n          // already has an incompatible inferred type; that's handled elsewhere.\n          defineInferredProperty(prop, propType, /* property node */ null);\n        }\n        // Previous logic incorrectly added properties that were NOT present on 'this':\n        //   if (!hasProperty(prop)) {\n        //     typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n        //         .getLeastSupertype(propType);\n        //     defineInferredProperty(prop, typeToInfer, null);\n        //   }\n        // This could mask 'missing property' errors by implicitly making required\n        // properties optional (T|undefined) on the literal's type.\n        // The corrected logic relies on standard unification to catch missing properties.\n      }\n    }\n    // NOTE: The original code had a TODO here about handling function type constraints.\n    // This fix focuses only on the record type constraint logic.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}