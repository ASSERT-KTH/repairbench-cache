{
    "generation": "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n  // We only want to match contraints on anonymous types.\n  //\n  // If the constraint is a record type (i.e. an object literal type),\n  // then for every property in the constraint we \u201cfill in\u201d the object\n  // literal if it doesn\u2019t already have that property. When a property is\n  // missing, we want to allow it to be missing (i.e. be undefined) by taking\n  // the union of the constraint\u2019s property type with undefined.\n  if (constraintObj.isRecordType()) {\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getPropertyType(prop);\n      if (!isPropertyTypeDeclared(prop)) {\n        JSType typeToInfer = propType;\n        if (!hasProperty(prop)) {\n          // Note: The order is important. We want to \u201cunion\u201d the declared type\n          // with undefined so that if the property is missing, its type is\n          // (T|undefined) rather than just T.\n          typeToInfer = propType.getLeastSupertype(getNativeType(JSTypeNative.VOID_TYPE));\n        }\n        defineInferredProperty(prop, typeToInfer, null);\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}