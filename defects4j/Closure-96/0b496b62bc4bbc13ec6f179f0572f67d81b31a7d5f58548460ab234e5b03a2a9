{
    "generation": "private void visitParameterList(NodeTraversal t, Node call,\n    FunctionType functionType) {\n  // Iterate the actual arguments (skip the first child, which is the callee).\n  Iterator<Node> args = call.children().iterator();\n  args.next();\n\n  // Copy the formal parameters so we can index them.\n  List<Node> params = new ArrayList<Node>();\n  for (Node p : functionType.getParameters()) {\n    params.add(p);\n  }\n  boolean isVarArgs = functionType.isVarArgs();\n  int totalParams = params.size();\n  // If it's var_args, the last parameter is the repeating one.\n  int fixedParams = isVarArgs ? totalParams - 1 : totalParams;\n\n  int ordinal = 0;\n  while (args.hasNext()) {\n    Node arg = args.next();\n    ordinal++;\n    Node paramNode = null;\n\n    if (ordinal <= fixedParams) {\n      // Match against the corresponding fixed parameter.\n      paramNode = params.get(ordinal - 1);\n    } else if (isVarArgs) {\n      // All extra arguments match the var_args parameter.\n      paramNode = params.get(totalParams - 1);\n    } else {\n      // No more formals to match; we'll catch this later as a wrong-arg-count.\n      break;\n    }\n\n    validator.expectArgumentMatchesParameter(\n        t, arg, getJSType(arg), getJSType(paramNode), call, ordinal);\n  }\n\n  // Finally, check overall argument count against min/max.\n  int numArgs = call.getChildCount() - 1;\n  int minArgs = functionType.getMinArguments();\n  int maxArgs = functionType.getMaxArguments();\n  if (numArgs < minArgs || numArgs > maxArgs) {\n    report(t, call, WRONG_ARGUMENT_COUNT,\n        validator.getReadableJSTypeName(call.getFirstChild(), false),\n        String.valueOf(numArgs),\n        String.valueOf(minArgs),\n        maxArgs != Integer.MAX_VALUE\n            ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}