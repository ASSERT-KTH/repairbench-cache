{
    "generation": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n\n          // Fix for testAssignWithCall: If an assignment expression is immediately called\n          // (e.g., (x=f)()) or constructed (e.g., new (x=f)()), the variable 'x' (the LHS)\n          // is assigned a value, and that *value* is then called/constructed, not the variable itself.\n          // Therefore, the LHS variable should not be marked as 'used' by this call/new operation.\n          // 'recordNode' for an ASSIGN node is typically its parent (n.getParent()).\n          // So, if the parent of the ASSIGN node is a CALL or NEW node, and the ASSIGN node\n          // itself is the target expression of that CALL/NEW (i.e., its first child),\n          // then we should not record a dependency scope for the LHS variable.\n          boolean isCallTargetAssignment = false;\n          if ((recordNode.isCall() || recordNode.isNew()) && recordNode.getFirstChild() == n) {\n            isCallTargetAssignment = true;\n          }\n\n          if (!isCallTargetAssignment) {\n            recordDepScope(recordNode, ns);\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}