{
    "generation": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation logic.\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      // If the assignment is directly used as the callee of a call\n      // (for example, in (fun = function(){ x; })(); ), the right-hand\n      // side (i.e. the function literal) is actually the caller. In such cases,\n      // we want to record dependency on the function literal rather than on the\n      // assignment node so that any naming attached to the lhs is not propagated.\n      if (parent != null && parent.isCall() && parent.getFirstChild() == n) {\n        recordDepScope(n.getLastChild(), ns);\n      } else {\n        // In all other cases, record dependency on the provided record node.\n        recordDepScope(recordNode, ns);\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}