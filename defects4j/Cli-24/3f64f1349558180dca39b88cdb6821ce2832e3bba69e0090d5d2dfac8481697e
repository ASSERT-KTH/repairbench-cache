{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line (this is the effective content width, not total line width)\n     * @param nextLineTabStop The position on the next line for the first tab (this is the absolute indent for all wrapped lines)\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        // Create the padding string once based on the absolute indent.\n        // This padding will be applied to every line of the wrapped text.\n        final String padding = createPadding(nextLineTabStop);\n\n        // Trim trailing whitespace from the initial text.\n        // The original method used rtrim here, so we maintain that.\n        text = rtrim(text);\n\n        int pos; // Variable to store the calculated wrap position.\n\n        // Loop until all of the text has been processed and appended to the StringBuffer.\n        while (true)\n        {\n            // Find the position to wrap the current 'text' segment.\n            // 'width' here represents the effective content width available for the text itself\n            // after the fixed 'padding' has been applied externally to the StringBuffer.\n            pos = findWrapPos(text, width, 0);\n\n            // If pos == -1, it means the remaining 'text' segment fits entirely within the 'width'\n            // without needing a wrap. If pos >= text.length(), it means 'text' is exhausted or already\n            // shorter than 'width'.\n            if (pos == -1 || pos >= text.length())\n            {\n                // If there is any remaining text, append it with the calculated padding.\n                if (!text.isEmpty())\n                {\n                    sb.append(padding).append(text);\n                }\n                break; // All text has been rendered, exit the loop.\n            }\n\n            // Append the current line segment to the StringBuffer.\n            // Each segment is prefixed by the determined 'padding'.\n            // The segment itself is the part of 'text' from index 0 up to 'pos'.\n            sb.append(padding).append(text.substring(0, pos)).append(defaultNewLine);\n\n            // Prepare for the next iteration:\n            // Take the remaining part of the text (from 'pos' onwards) and trim any leading/trailing whitespace.\n            // This 'trim()' ensures that subsequent lines don't start with leftover spaces from the previous wrap point.\n            text = text.substring(pos).trim();\n\n            // If the remaining text becomes empty after trimming, it means all content has been processed.\n            if (text.isEmpty())\n            {\n                break; // Exit the loop.\n            }\n        }\n\n        return sb;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}