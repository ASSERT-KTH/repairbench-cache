{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer. This function handles indenting all lines\n     * generated, and wrapping the text within the specified width.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param indent The position on each line for the first character.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int indent, String text)\n    {\n        // Handle empty or null text\n        if (text == null || text.trim().length() == 0) {\n             return sb;\n        }\n\n        // Trim leading/trailing whitespace from the input text\n        text = text.trim();\n\n        // Check if the indent is too large for the width\n        if (indent >= width) {\n             // If indent > width, impossible to print anything\n             if (indent > width) {\n                 // This should ideally be handled by the caller, but throw defensively\n                 throw new IllegalStateException(\"Indent (\" + indent + \") exceeds width (\" + width + \")\");\n             }\n             // Handle the edge case where indent == width.\n             // We can print exactly one character per line at the last column.\n             // Create padding of (width - 1) spaces.\n             String padding = createPadding(width - 1);\n             for (int i = 0; i < text.length(); ++i) {\n                 // Add newline separator only between lines\n                 if (sb.length() > 0 && sb.charAt(sb.length()-1) != '\\n') {\n                     // Check if sb is not empty and does not already end with a newline\n                     // If the caller already added content, we need a newline first\n                     // However, typically sb might be empty or end with newline from previous option.\n                     // A simpler approach might be to always add newline *before* the next line,\n                     // but that leaves a trailing newline. Let's add it *after* each line.\n                 }\n                 sb.append(padding);\n                 sb.append(text.charAt(i));\n                 // Append newline after each line in this mode\n                 sb.append(defaultNewLine);\n             }\n             // Remove the last appended newline if necessary, although HelpFormatter usually consumes it.\n             // For consistency, let's leave the trailing newline, as the previous logic did.\n             return sb;\n        }\n\n        // Normal case: indent < width\n        final String padding = createPadding(indent);\n        final int availableWidth = width - indent; // Width available for the text itself\n\n        while (text.length() > 0) {\n            // Find the wrap position within the available width\n            int pos = findWrapPos(text, availableWidth, 0);\n\n            // Append padding and the current line segment\n            sb.append(padding);\n\n            if (pos == -1) {\n                // Remaining text fits on the current line\n                sb.append(rtrim(text)); // Append the rest of the text\n                text = \"\"; // Mark text as fully processed\n            } else {\n                // Wrap the text at the determined position\n                sb.append(rtrim(text.substring(0, pos))); // Append the wrapped part\n                sb.append(defaultNewLine); // Add a newline character\n                text = text.substring(pos).trim(); // Update text for the next iteration\n            }\n        }\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}