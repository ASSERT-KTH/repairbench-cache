{
    "generation": "    /**\n     * Build a sparse matrix with the supplied row and column dimensions.\n     *\n     * @param rowDimension Number of rows of the matrix.\n     * @param columnDimension Number of columns of the matrix.\n     * @throws org.apache.commons.math.exception.NumberIsTooLargeException\n     *         if the product of {@code rowDimension} and {@code columnDimension}\n     *         exceeds {@link java.lang.Integer#MAX_VALUE}, which is the maximum\n     *         capacity for internal indexing.\n     */\n    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n        super(rowDimension, columnDimension);\n\n        // The internal storage OpenIntToDoubleHashMap uses an int for keys.\n        // These keys are generated by row * columns + column.\n        // This implies that the total number of theoretical elements (rowDimension * columnDimension)\n        // must not exceed Integer.MAX_VALUE, otherwise the indexing will overflow.\n        // The super constructor ensures rowDimension and columnDimension are positive.\n        // We need to check if rowDimension * columnDimension would overflow an int.\n        // A safe check for a * b > MAX_INT without overflow: if (a > MAX_INT / b)\n        if (columnDimension > 0 && rowDimension > Integer.MAX_VALUE / columnDimension) {\n            throw new org.apache.commons.math.exception.NumberIsTooLargeException(\n                (long) rowDimension * columnDimension, // actual product that would be too large\n                Integer.MAX_VALUE,                     // maximum allowed for int indexing\n                false                                  // not inclusive, i.e., MAX_VALUE itself is allowed\n            );\n        }\n\n        this.rows = rowDimension;\n        this.columns = columnDimension;\n        this.entries = new OpenIntToDoubleHashMap(0.0);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}