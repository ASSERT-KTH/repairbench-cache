{
    "generation": "public Fraction parse(String source, ParsePosition pos) {\n    // Save the position before attempting an improper\u2010fraction parse\n    int saveIndex = pos.getIndex();\n    // 1) Try the superclass (improper fraction) parser first\n    Fraction ret = super.parse(source, pos);\n    if (ret != null) {\n        // Verify that any minus sign in the input was only at the very beginning\n        String segment = source.substring(saveIndex, pos.getIndex());\n        String trimmed = segment.trim();\n        int minusCount = 0;\n        for (int i = 0; i < segment.length(); i++) {\n            if (segment.charAt(i) == '-') {\n                minusCount++;\n            }\n        }\n        // If there's more than one '-' or a single '-' not at the front, reject\n        if (minusCount > 1 || (minusCount == 1 && !trimmed.startsWith(\"-\"))) {\n            pos.setIndex(saveIndex);\n            // find the offending '-' position\n            int minusPosInSegment;\n            if (minusCount > 1) {\n                int first = segment.indexOf('-');\n                minusPosInSegment = segment.indexOf('-', first + 1);\n            } else {\n                minusPosInSegment = segment.indexOf('-');\n            }\n            pos.setErrorIndex(saveIndex + minusPosInSegment);\n            return null;\n        }\n        // otherwise accept the improper fraction\n        return ret;\n    }\n\n    // 2) Fall back to parsing a proper fraction form: \"whole numerator/denominator\"\n    int initialIndex = pos.getIndex();\n\n    // skip leading whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse the whole\u2010number part\n    Number whole = getWholeFormat().parse(source, pos);\n    if (whole == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // skip whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse the numerator\n    int numStart = pos.getIndex();\n    Number num = getNumeratorFormat().parse(source, pos);\n    if (num == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // reject a negative numerator (minus must only appear in the whole part)\n    if (num.intValue() < 0) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(numStart);\n        return null;\n    }\n\n    // parse the '/' separator\n    int slashIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    switch (c) {\n    case 0:\n        // no slash => treat as num/1\n        return new Fraction(num.intValue(), 1);\n    case '/':\n        // OK, continue to denominator\n        break;\n    default:\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(slashIndex);\n        return null;\n    }\n\n    // skip whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse the denominator\n    int denStart = pos.getIndex();\n    Number den = getDenominatorFormat().parse(source, pos);\n    if (den == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    // reject a negative denominator\n    if (den.intValue() < 0) {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(denStart);\n        return null;\n    }\n\n    // build the final Fraction\n    int w = whole.intValue();\n    int n = num.intValue();\n    int d = den.intValue();\n    return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}