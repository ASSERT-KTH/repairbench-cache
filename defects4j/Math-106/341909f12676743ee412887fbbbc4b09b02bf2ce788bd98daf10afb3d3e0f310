{
    "generation": "import org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.util.MathUtils; // Assuming this import is present or MathUtils is accessible\nimport java.text.ParsePosition;\nimport java.text.FieldPosition; // Needed for superclass, not directly used here but assumed context\nimport java.text.NumberFormat; // Needed for superclass, not directly used here but assumed context\n\n// Assuming the context of ProperFractionFormat extending FractionFormat\npublic abstract class ProperFractionFormat extends FractionFormat {\n\n    // Assume these abstract methods are implemented elsewhere\n    protected abstract NumberFormat getWholeFormat();\n    // getNumeratorFormat() and getDenominatorFormat() inherited from FractionFormat\n\n    // Helper methods assumed to exist (from FractionFormat or its base)\n    protected abstract void parseAndIgnoreWhitespace(String source, ParsePosition pos);\n    protected abstract char parseNextCharacter(String source, ParsePosition pos);\n\n    /**\n     * Parses a string to produce a {@link Fraction} object.  This method\n     * expects the string to be formatted as a proper fraction.\n     * <p>\n     * Minus signs are only allowed in the whole number part - i.e.,\n     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n     * will result in a <code>ParseException</code>.\n     *\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link Fraction} object.\n     */\n    @Override // Added @Override for clarity, assuming it overrides FractionFormat.parse\n    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse numerator\n        int numeratorStartIndex = pos.getIndex();\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // Check for negative numerator\n        if (num.doubleValue() < 0.0) {\n             // minus signs should be leading, invalid expression\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(numeratorStartIndex);\n            return null;\n        }\n\n        // parse '/'\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 :\n            // Proper fractions must have a '/' unless only the whole number was present.\n            // If we parsed \"whole num\" but reached the end of the string,\n            // it's not a valid proper fraction \"whole num / den\".\n            // It should have been parsed as an integer by super.parse if only \"whole\" was intended.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex); // Error where '/' was expected\n            return null;\n        case '/' :\n            // found '/', continue parsing denominator\n            break;\n        default :\n            // invalid character instead of '/'\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse denominator\n        int denominatorStartIndex = pos.getIndex();\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // Check for negative or zero denominator\n        if (den.doubleValue() < 1.0) { // Denominator must be positive\n             // minus signs must be leading, invalid\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(denominatorStartIndex);\n            return null;\n        }\n\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }\n\n    // Dummy implementations for compilability if needed in isolation\n    // protected NumberFormat getWholeFormat() { return NumberFormat.getIntegerInstance(); }\n    // protected NumberFormat getNumeratorFormat() { return NumberFormat.getIntegerInstance(); }\n    // protected NumberFormat getDenominatorFormat() { return NumberFormat.getIntegerInstance(); }\n    // protected void parseAndIgnoreWhitespace(String source, ParsePosition pos) { /* Skip whitespace */ }\n    // protected char parseNextCharacter(String source, ParsePosition pos) { /* Get next non-whitespace char */ return 0;}\n    // public Fraction parse(String source) throws java.text.ParseException { // Likely exists in base class\n    //     ParsePosition parsePosition = new ParsePosition(0);\n    //     Fraction result = parse(source, parsePosition);\n    //     if (parsePosition.getIndex() == 0) {\n    //         throw new java.text.ParseException(\"Unparseable fraction number: \\\"\" + source + \"\\\"\",\n    //                                   parsePosition.getErrorIndex());\n    //     }\n    //     return result;\n    // }\n    // public StringBuffer format(Fraction fraction, StringBuffer toAppendTo, FieldPosition pos) { return null; } // Likely abstract or implemented in base\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}