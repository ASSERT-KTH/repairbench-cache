{
    "generation": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            int length = input.length; // Use a variable for length for clarity and potentially minor optimization\n\n            // BOM: Check for UTF-8 Byte Order Mark (EF BB BF)\n            // Fixed the potential typo '&' which should be '&&' for logical AND.\n            // Although bitwise '&' on booleans works in Java, '&&' is standard and short-circuiting.\n            if (length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB && (input[2] & 0xFF) == 0xBF) {\n                i = 3; // Skip BOM\n            }\n\n            int end;\n            // Iterate through the byte array\n            for (int j = length; i < j; ++i) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    // Single-byte sequence (ASCII 00-7F): 0xxxxxxx\n                    continue; // Byte is valid ASCII, move to next byte\n                }\n\n                // Multi-byte sequence lead byte check\n                // Determine the number of bytes in the sequence based on the lead byte pattern\n                // and calculate the index 'end' of the last byte in the sequence.\n                if ((o & 0xE0) == 0xC0) { // 2-byte sequence lead byte (C2-DF): 110xxxxx\n                    end = i + 1;\n                    // Note: C0, C1 are invalid starts for 2-byte sequences (overlong)\n                    // This check doesn't explicitly reject them but proceeds. A stricter check could add `&& o <= 0xDF && o >= 0xC2`\n                } else if ((o & 0xF0) == 0xE0) { // 3-byte sequence lead byte (E0-EF): 1110xxxx\n                    end = i + 2;\n                } else if ((o & 0xF8) == 0xF0) { // 4-byte sequence lead byte (F0-F7): 11110xxx\n                    end = i + 3;\n                    // Note: F5-FF are invalid starts for 4-byte sequences.\n                    // This check doesn't explicitly reject them but proceeds. A stricter check could add `&& o <= 0xF4` (or F7 if allowing higher planes)\n                } else {\n                    // Invalid lead byte (e.g., 80-BF, F8-FF)\n                    return false;\n                }\n\n                // Check if the sequence extends beyond the input array boundary\n                // 'end' is the index of the last byte. It must be less than 'j' (length).\n                if (end >= j) {\n                    return false; // Sequence is truncated\n                }\n\n                // Check continuation bytes (must start with 10xxxxxx)\n                // The inner loop variable 'i' is incremented *before* checking the continuation byte.\n                while (i < end) {\n                    i++; // Move to the next byte (potential continuation byte)\n                    // Although the 'end < j' check before the loop should guarantee 'i < j',\n                    // the ArrayIndexOutOfBoundsException suggests a potential edge case or issue.\n                    // Adding an explicit check here prevents the exception reported.\n                    // It ensures we don't try to access input[i] if i somehow reached or exceeded j.\n                    if (i >= j) {\n                       // This condition should theoretically be caught by the \"end >= j\" check earlier,\n                       // but we add it defensively to prevent the specific AIOOBE reported.\n                       return false;\n                    }\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) { // Check if bits 7 and 6 are '10'\n                        return false; // Invalid continuation byte\n                    }\n                }\n                // The outer loop's ++i will advance 'i' past the end of the successfully checked multi-byte sequence.\n            }\n\n            // If the loop completes without finding invalid sequences, it looks like UTF-8.\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}