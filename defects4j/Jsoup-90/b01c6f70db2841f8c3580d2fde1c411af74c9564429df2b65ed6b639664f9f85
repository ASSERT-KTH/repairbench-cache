{
    "generation": "        private static boolean looksLikeUtf8(byte[] input) {\n            int i = 0;\n            // BOM:\n            // Corrected the logical AND operator for the last condition (&& instead of &)\n            if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n                && (input[1] & 0xFF) == 0xBB && (input[2] & 0xFF) == 0xBF) {\n                i = 3;\n            }\n\n            int len = input.length;\n            for (/* i initialized above */; i < len; /* i incremented below */) {\n                int o = input[i];\n                if ((o & 0x80) == 0) {\n                    // ASCII character (0xxxxxxx)\n                    i++;\n                    continue;\n                }\n\n                // Check for valid UTF-8 start byte and determine sequence length\n                int remainingBytes;\n                if ((o & 0xE0) == 0xC0) { // 2-byte sequence start (110xxxxx)\n                    remainingBytes = 1;\n                } else if ((o & 0xF0) == 0xE0) { // 3-byte sequence start (1110xxxx)\n                    remainingBytes = 2;\n                } else if ((o & 0xF8) == 0xF0) { // 4-byte sequence start (11110xxx)\n                    remainingBytes = 3;\n                } else {\n                    // Invalid UTF-8 start byte (must be 0xxxxxxx, 110xxxxx, 1110xxxx, or 11110xxx)\n                    // This handles cases like 10xxxxxx or 11111xxx\n                    return false;\n                }\n\n                // Check if there are enough bytes left for the sequence\n                // Need 'remainingBytes' more bytes, so the last index to check is i + remainingBytes\n                // This index must be less than 'len'. So, i + remainingBytes < len, or i + remainingBytes >= len is an error.\n                if (i + remainingBytes >= len) {\n                    // Sequence is truncated\n                    return false;\n                }\n\n                // Check the validity of the continuation bytes (must be 10xxxxxx)\n                for (int k = 1; k <= remainingBytes; k++) {\n                    int contByte = input[i + k];\n                    if ((contByte & 0xC0) != 0x80) {\n                        // Invalid continuation byte\n                        return false;\n                    }\n                }\n\n                // Move index past the current multi-byte character (start byte + remainingBytes)\n                i += (remainingBytes + 1);\n            }\n\n            // If loop completes without returning false, it looks like UTF-8\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}