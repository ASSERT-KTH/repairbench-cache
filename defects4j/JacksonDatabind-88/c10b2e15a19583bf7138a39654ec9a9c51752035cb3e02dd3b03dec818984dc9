{
    "generation": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n         *    check if any generics info is added; and only then ask factory\n         *    to do translation when necessary\n         */\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            // note: may want to try combining with specialization (esp for EnumMap)?\n            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n            //    compatibility -- needed later anyway, and not doing so may open\n            //    security issues.\n            JavaType t = tf.constructFromCanonical(id);\n                // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n\n            // 02-Apr-2019, tatu: Make sure types are compatible wrt generics constraints\n            //   ... typically `_baseType` is not generic, but may be, and could have bounds etc\n            if (_baseType != null) {\n                // 18-Nov-2019, tatu: Ok, this is bit tricky. We do not want to call\n                //   `constructSpecializedType()` because that assumes `id` is name of subclass,\n                //   but here `id` is the FULL type including generics. So we do need\n                //   a check here.\n                // TODO: Rework `TypeFactory` in 3.0 to have better way?\n                Class<?> raw = t.getRawClass();\n                // TODO: check for generic type compatibility? More work...\n                if (!_baseType.isTypeOrSuperTypeOf(raw)) {\n                    // If not type/supertype, need to check if it's just that `id` is invalid class;\n                    // or if it's attempt to specify type outside allowed limits. Latter seems\n                    // more likely.\n                    // Note: exception message should align with one constructed for the\n                    // other branch.\n                    throw ctxt.invalidTypeIdException(_baseType, id, \"Not a subtype\");\n                }\n            }\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n            //   DeserializationContext, just playing it safe\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                // First: we may have problem handlers that can deal with it?\n                // 12-Jun-2016, tatu: As per [databind#1270] may need DeserializationConfig\n                 //    (and if so, should NOT rely on passing `this` as resolver)\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } catch (Exception e) {\n            throw new IllegalArgumentException(String.format(\"Invalid type id '%s' (for id type 'Id.class'): %s\",\n                    id, e.getMessage()), e);\n        }\n        // 18-Jan-2018, tatu: As per [databind#1870], need to ensure that `cls` is,\n        //    indeed, compatible with `_baseType`. Necessary to prevent certain attack\n        //    vectors, possibly other kinds of \u099d\u09be\u09ae\u09c7\u09b2\u09be (trouble).\n        // Note: may need to be promoted to `TypeResolverBuilder.buildTypeDeserializer()` eventually\n        if ((_baseType != null) && _baseType.isTypeOrSuperTypeOf(cls)) {\n            // Usually we just use the explicit type (`cls`) as is, instead of specifying\n            // vague supertype (`_baseType`)\n            // 26-Oct-2018, tatu: Unless it's for abstract type (interface, abstract class),\n            //   in which case need base type. Fixed via [databind#2119]. Need to uncomment:\n             if (_baseType.isAbstract()) {\n                  JavaType t = tf.constructSpecializedType(_baseType, cls);\n                  // 18-Oct-2019, tatu: Must ensure type parameters are ok...\n                  //    otherwise we might be target of nasty attack\n                  // Wait! `constructSpecializedType` SHOULD do that?!\n                  // JavaType bound = tf.constructType(cls);\n                  // if (!_baseType.isAssignableFrom(bound)) { ... }\n                  return t;\n             }\n        } else {\n            // 01-Oct-2019, tatu: Use `DatatypeContext.invalidTypeIdException()` for more std exceptions\n            throw ctxt.invalidTypeIdException(_baseType, id, \"Not a subtype\");\n        }\n        // a plain subtype specified, should be fine -- just specialize, for generics:\n        return tf.constructSpecializedType(_baseType, cls);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}