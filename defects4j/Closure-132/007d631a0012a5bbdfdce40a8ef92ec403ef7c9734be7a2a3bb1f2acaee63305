{
    "generation": "private Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n\n  Node cond = n.getFirstChild();\n\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        return n;\n      }\n\n      if (cond.isNot()) {\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n          return n;\n        }\n\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild())\n                .srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      }\n\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n          isLowerPrecedenceInExpression(expr.getFirstChild(),\n              AND_PRECEDENCE)) {\n        return n;\n      }\n\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n\n      return newExpr;\n    } else {\n      if (NodeUtil.isStatementBlock(thenBranch) &&\n          thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThenBranch = innerCond.getNext();\n          Node innerElseBranch = innerThenBranch.getNext();\n\n          if (innerElseBranch == null &&\n              !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(\n                    cond,\n                    innerCond.detachFromParent())\n                        .srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n      }\n    }\n\n    return n;\n  }\n\n  tryRemoveRepeatedStatements(n);\n\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n\n    Node returnNode = IR.returnNode(\n        IR.hook(cond, thenExpr, elseExpr)\n            .srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n\n  boolean thenIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n  if (thenIsExpressionBlock && elseIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n\n    if (thenOp.getType() == elseOp.getType()) {\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n            !mayEffectMutableState(lhs)) {\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          Node assign = new Node(thenOp.getType(), assignName, hookNode)\n              .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n\n          return expr;\n        }\n      }\n    }\n\n    if (canConvertToTernaryExpr(thenOp, elseOp)) {\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n  }\n\n  boolean thenIsVar = isVarBlock(thenBranch);\n  boolean elseIsExpression = isFoldableExpressBlock(elseBranch);\n\n  if (thenIsVar && elseIsExpression) {\n    Node thenVar = getBlockVar(thenBranch);\n    Node elseExpr = getBlockExpression(elseBranch);\n    if (canConvertToTernaryVar(thenVar, elseExpr)) {\n      n.removeChild(cond);\n      cond.detachFromParent();\n      Node hook = IR.hook(cond,\n          thenVargetChild(thenVar),\n          elseExpr.getFirstChild())\n              .srcref(n);\n      thenVar.addChild(hook);\n      parent.replaceChild(n, thenVar);\n      reportCodeChange();\n      return thenVar;\n    }\n  }\n\n  elseIsVar = isVarBlock(elseBranch);\n  elseIsExpression = isFoldableExpressBlock(thenBranch);\n\n  if (elseIsVar && elseIsExpression) {\n    Node elseVar = getBlockVar(elseBranch);\n    Node thenExpr = getBlockExpression(thenBranch);\n    if (canConvertToTernaryVar(elseVar, thenExpr)) {\n      n.removeChild(cond);\n      cond.detachFromParent();\n      Node hook = IR.hook(cond,\n          thenExpr.getFirstChild(),\n          elseVar.getChild(0))\n              .srcref(n);\n      elseVar.addChild(hook);\n      parent.replaceChild(n, elseVar);\n      reportCodeChange();\n      return elseVar;\n    }\n  }\n\n  return n;\n}\n\n// Helper method to check if conversion to ternary is safe.\nprivate boolean canConvertToTernaryExpr(Node thenOp, Node elseOp) {\n  return hasNoSideEffects(thenOp) && hasNoSideEffects(elseOp);\n}\n\n// Helper method to check if variable assignment can be converted.\nprivate boolean canConvertToTernaryVar(Node varNode, Node expr) {\n  Node nameNode = varNode.getFirstChild();\n  if (nameNode.isName() && expr.isAssign()) {\n    Node exprName = expr.getFirstChild();\n    if (exprName.isName() && exprName.getString().equals(nameNode.getString())) {\n      return hasNoSideEffects(expr);\n    }\n  }\n  return false;\n}\n\n// Helper method to check for side effects in expressions.\nprivate boolean hasNoSideEffects(Node node) {\n  return !mayEffectMutableState(node);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}