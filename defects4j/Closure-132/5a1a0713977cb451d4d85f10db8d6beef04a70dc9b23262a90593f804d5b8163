{
    "generation": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          // Detach the condition's child before detaching the expression's child.\n          Node condChild = cond.removeFirstChild();\n          Node exprChild = expr.removeFirstChild();\n          Node or = IR.or(condChild, exprChild).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        // Detach the expression's child after detaching the condition node.\n        n.removeChild(cond);\n        Node exprChild = expr.removeFirstChild();\n        Node and = IR.and(cond, exprChild).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              // Use detach to preserve existing node properties.\n              Node currentCond = cond.detachFromParent();\n              Node innerIfCond = innerCond.detachFromParent();\n              Node innerIfThen = innerThenBranch.detachFromParent();\n\n              n.detachChildren(); // Remove original children cleanly\n              n.addChildToBack(\n                  IR.and(currentCond, innerIfCond)\n                      .srcref(currentCond)); // Propagate srcref\n              n.addChildrenToBack(innerIfThen);\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      Node originalCond = cond.removeFirstChild();\n      n.replaceChild(cond, originalCond); // Replace NOT with its child\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch); // Swap branches\n      reportCodeChange();\n      // Condition changed, re-evaluate the node\n      return n; // Let the optimizer re-visit the modified IF\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n\n      // Ensure both returns have values to avoid \"return x?void 0:value;\"\n      if (thenExpr != null && elseExpr != null) {\n        cond.detachFromParent();\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node returnNode = IR.returnNode(hookNode).srcref(n);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n      }\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType() && NodeUtil.isAssignmentOp(thenOp)) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        Node lhs = thenOp.getFirstChild();\n        if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())) {\n\n            boolean canFold = false;\n            // Check if it is safe to fold the assignment.\n            if (thenOp.isAssign()) {\n                // Fold \"if(c) x = a; else x = b;\" into \"x = c ? a : b;\"\n                // only if evaluating the LHS ('x' in this case) has no side effects.\n                // Evaluating 'x' itself has no side effects.\n                // Evaluating 'x[foo()]' has side effects.\n                // We don't need to worry about cond modifying LHS because\n                // the assignment happens after the condition evaluates.\n                // Example: \"x = x++ ? a : b;\" is safe.\n                canFold = !NodeUtil.mayHaveSideEffects(lhs);\n            } else { // Compound assignment (e.g., +=)\n                // Fold \"if(c) x += a; else x += b;\" into \"x += c ? a : b;\"\n                // only if evaluating the LHS ('x') has no side effects AND\n                // the condition ('c') does not modify the LHS ('x').\n                // We use mayEffectMutableState(lhs) as a proxy for the check\n                // \"cond modifies lhs\". This implicitly assumes mayEffectMutableState\n                // considers the context.\n                // Example: \"a += foo() ? 1 : 2\" is safe if foo() doesn't modify a.\n                // Example: \"x += x++ ? 1 : 2\" is NOT safe (we prefer the structure\n                // \"x++ ? (x += 1) : (x += 2)\").\n                canFold = !NodeUtil.mayEffectMutableState(lhs);\n            }\n\n            if (canFold) {\n                // Must clone LHS, as original is shared between thenOp and elseOp\n                Node assignLhs = lhs.cloneTree();\n                Node thenExpr = thenOp.getLastChild().detachFromParent();\n                Node elseExpr = elseOp.getLastChild().detachFromParent();\n                cond.detachFromParent();\n\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                Node assign = new Node(thenOp.getType(), assignLhs, hookNode)\n                                  .srcref(thenOp); // Use the original assignment type\n                Node expr = NodeUtil.newExpr(assign);\n                parent.replaceChild(n, expr);\n                reportCodeChange();\n\n                return expr;\n             }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      // This handles cases like:\n      //   if (a) x[y]=1; else x[y]=2; => a ? (x[y]=1) : (x[y]=2);\n      //   if (x++) a += 1; else a += 2; => x++ ? (a+=1) : (a+=2);\n      // We need to detach the children before creating the hook.\n      cond.detachFromParent();\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild(); // VAR's NAME node\n      Node maybeName2 = elseAssign.getFirstChild(); // Assign's LHS\n\n      // Check:\n      // 1. The var declares exactly one name.\n      // 2. The var declaration has an initializer.\n      // 3. The else branch is an assignment.\n      // 4. The LHS of the else assignment is a NAME node.\n      // 5. The names match.\n      if (var.hasOneChild() && name1.hasChildren() &&\n          maybeName2.isName() &&\n          name1.getString().equals(maybeName2.getString())) {\n\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n); // Use IF's source info for hook\n        // var node is already detached implicitly by replaceChild\n        name1.addChildrenToBack(hookNode); // Add hook as new initializer\n\n        // Replace IF with the modified VAR node\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild(); // Assign's LHS\n      Node name2 = var.getFirstChild(); // VAR's NAME node\n\n      // Symmetric checks as above\n      if (var.hasOneChild() && name2.hasChildren() &&\n          maybeName1.isName() &&\n          maybeName1.getString().equals(name2.getString())) {\n\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                            .srcref(n);\n        // var node is detached implicitly by replaceChild\n        name2.addChildrenToBack(hookNode);\n\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}