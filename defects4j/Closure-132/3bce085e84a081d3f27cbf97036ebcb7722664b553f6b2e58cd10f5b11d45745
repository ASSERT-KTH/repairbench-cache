{
    "generation": "/**\n * Try turning IF nodes into smaller HOOKs\n *\n * Returns the replacement for n or the original if no replacement was\n * necessary.\n */\nprivate Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n\n  // If the condition is a literal, we'll let other\n  // optimizations try to remove useless code.\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  // No ELSE branch: try to fold simple IF into && or ||\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        // Keep opportunities for CollapseProperties until that pass runs.\n        return n;\n      }\n\n      if (cond.isNot()) {\n        // if(!x)bar(); -> x||bar();\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE)\n            && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n          // Avoid double parentheses.\n          return n;\n        }\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n\n      // if(x)foo(); -> x&&foo();\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)\n          && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n        // Avoid extra braces/parens.\n        return n;\n      }\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    } else {\n      // Try to combine nested IF-ELSE into one\n      if (NodeUtil.isStatementBlock(thenBranch)\n          && thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThen = innerCond.getNext();\n          Node innerElse = innerThen.getNext();\n          if (innerElse == null\n              && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)\n                   && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(IR.and(cond, innerCond.detachFromParent())\n                                 .srcref(cond));\n            n.addChildrenToBack(innerThen.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n      }\n    }\n    return n;\n  }\n\n  // With ELSE branch: try other rewrites\n  tryRemoveRepeatedStatements(n);\n\n  // if(!x)foo();else bar(); -> if(x)bar();else foo();\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  // if(x)return 1;else return 2; -> return x?1:2;\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n    Node returnNode = IR.returnNode(\n        IR.hook(cond, thenExpr, elseExpr).srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n\n  boolean thenIsExpr = isFoldableExpressBlock(thenBranch);\n  boolean elseIsExpr = isFoldableExpressBlock(elseBranch);\n\n  // Both branches are single expressions/statements.\n  if (thenIsExpr && elseIsExpr) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n      // Attempt simple-assignment folding: if(x) a = 1; else a = 2;\n      if (NodeUtil.isAssignmentOp(thenOp)) {\n        Node lhs = thenOp.getFirstChild();\n        // Only fold plain \u201c=\u201d to simple name targets (not properties or compound).\n        if (thenOp.getType() == Token.ASSIGN\n            && lhs.isName()\n            && areNodesEqualForInlining(lhs, elseOp.getFirstChild())\n            && !mayEffectMutableState(lhs)) {\n          n.removeChild(cond);\n          Node nameNode = thenOp.removeFirstChild();\n          Node thenRhs = thenOp.removeFirstChild();\n          Node elseRhs = elseOp.getLastChild();\n          elseOp.removeChild(elseRhs);\n\n          Node hookNode = IR.hook(cond, thenRhs, elseRhs).srcref(n);\n          Node assign = new Node(Token.ASSIGN, nameNode, hookNode)\n                            .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n    // Default conditional-expression rewrite:\n    // if(x) foo(); else bar(); -> x ? foo() : bar();\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node hookExpr = IR.hook(cond, thenOp, elseOp).srcref(n);\n    Node exprResult = IR.exprResult(hookExpr);\n    parent.replaceChild(n, exprResult);\n    reportCodeChange();\n    return exprResult;\n  }\n\n  // var/assign combination cases...\n  boolean thenIsVar = isVarBlock(thenBranch);\n  boolean elseIsVar = isVarBlock(elseBranch);\n\n  // if(x)var y=1;else y=2  ->  var y=x?1:2\n  if (thenIsVar && elseIsExpr\n      && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n    Node var = getBlockVar(thenBranch);\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n    Node name1 = var.getFirstChild();\n    Node maybeName2 = elseAssign.getFirstChild();\n    if (name1.hasChildren()\n        && maybeName2.isName()\n        && name1.getString().equals(maybeName2.getString())) {\n      Node thenExpr = name1.removeChildren();\n      Node elseExpr = elseAssign.getLastChild().detachFromParent();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n      var.detachFromParent();\n      name1.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  }\n  // if(x)y=1;else var y=2  ->  var y=x?1:2\n  else if (elseIsVar && thenIsExpr\n           && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n    Node var = getBlockVar(elseBranch);\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n    Node maybeName1 = thenAssign.getFirstChild();\n    Node name2 = var.getFirstChild();\n    if (name2.hasChildren()\n        && maybeName1.isName()\n        && maybeName1.getString().equals(name2.getString())) {\n      Node thenExpr = thenAssign.getLastChild().detachFromParent();\n      Node elseExpr = name2.removeChildren();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n      var.detachFromParent();\n      name2.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  }\n\n  return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}