{
    "generation": "  private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    // Check if condition is a literal\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      // If else is null, handle if statement without else\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Skip conversion to keep opportunities for CollapseProperties\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // Handle if (!cond) expr; conversion to cond || expr\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n            return n;\n          }\n          Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n          return newExpr;\n        }\n\n        // Handle if (cond) expr; conversion to cond && expr\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n          return n;\n        }\n\n        // Check for side effects in condition or expression\n        if (hasSideEffects(cond) || hasSideEffects(expr.getFirstChild())) {\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n\n      // Try combining two IF-ELSE\n      // Existing logic adjusted to handle side effects\n      if (thenBranch.isBlock() && thenBranch.hasOneChild() && thenBranch.getFirstChild().isIf()) {\n        Node innerIf = thenBranch.getFirstChild();\n        Node innerCond = innerIf.getFirstChild();\n        Node innerThenBranch = innerCond.getNext();\n        Node innerElseBranch = innerThenBranch.getNext();\n        if (innerElseBranch == null && \n            !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n          if (!hasSideEffects(cond) && !hasSideEffects(innerCond)) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n      }\n\n      return n;\n    } else {\n      tryRemoveRepeatedStatements(n);\n\n      // Check if condition is a NOT operation\n      if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n        n.replaceChild(cond, cond.removeFirstChild());\n        n.removeChild(thenBranch);\n        n.addChildToBack(thenBranch);\n        reportCodeChange();\n        return n;\n      }\n\n      // Handle conversion of if-else to ternary for return statements\n      if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        // Note: Check side effects before conversion\n        if (hasSideEffects(cond) || hasSideEffects(thenExpr) || hasSideEffects(elseExpr)) {\n          return n;\n        }\n        Node returnNode = IR.returnNode(\n            IR.hook(cond, thenExpr, elseExpr).srcref(n));\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n      }\n\n      boolean thenIsExpression = isFoldableExpressBlock(thenBranch);\n      boolean elseIsExpression = isFoldableExpressBlock(elseBranch);\n\n      // Check for assignment operations\n      if (thenIsExpression && elseIsExpression) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n        if (thenOp.getType() == Token.ASSIGN || thenOp.getType() == Token.ASSIGN_ADD ||\n            thenOp.getType() == Token.ASSIGN_SUB) {\n          if (thenOp.getType() != elseOp.getType()) {\n            return n;\n          }\n          // Check if left-hand sides match and no side effects\n          if (areNodesEqualForInlining(thenOp.getFirstChild(), elseOp.getFirstChild()) &&\n              !mayEffectMutableState(thenOp.getFirstChild())) {\n            if (hasSideEffects(cond) || hasSideEffects(thenOp) || hasSideEffects(elseOp)) {\n              return n;\n            }\n            Node hook = IR.hook(cond, thenOp.getLastChild(), elseOp.getLastChild())\n                .srcref(n);\n            Node assign = new Node(thenOp.getType(), thenOp.getFirstChild(), hook)\n                .srcref(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n            return expr;\n          }\n        }\n      }\n\n      // Handle var declarations\n      if (thenBranch.isVar() && elseBranch.isExpressionBlock() &&\n          getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(thenBranch);\n        Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n        Node name1 = var.getFirstChild();\n        Node name2 = elseAssign.getFirstChild();\n\n        if (name1 != null && name2 != null &&\n            name1.getString().equals(name2.getString())) {\n          Node thenExpr = var.getFirstChild().removeChildren();\n          Node elseExpr = elseAssign.getLastChild();\n          cond.detachFromParent();\n          Node hook = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          var.replaceChild(name1, hook);\n          parent.replaceChild(n, var);\n          reportCodeChange();\n          return var;\n        }\n      } else if (elseBranch.isVar() && thenBranch.isExpressionBlock() &&\n          getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n        Node var = getBlockVar(elseBranch);\n        Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n        Node name1 = thenAssign.getFirstChild();\n        Node name2 = var.getFirstChild();\n\n        if (name1 != null && name2 != null &&\n            name1.getString().equals(name2.getString())) {\n          Node thenExpr = thenAssign.getLastChild();\n          Node elseExpr = var.getFirstChild().removeChildren();\n          cond.detachFromParent();\n          Node hook = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n          var.replaceChild(name2, hook);\n          parent.replaceChild(n, var);\n          reportCodeChange();\n          return var;\n        }\n      }\n\n      // General case for converting to ternary\n      if (thenIsExpression && elseIsExpression) {\n        if (hasSideEffects(cond) || hasSideEffects(thenBranch) || hasSideEffects(elseBranch)) {\n          return n;\n        }\n        cond.detachFromParent();\n        Node thenExpr = getBlockExpression(thenBranch).getFirstChild().detachFromParent();\n        Node elseExpr = getBlockExpression(elseBranch).getFirstChild().detachFromParent();\n        Node hook = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node expr = NodeUtil.newExpr(hook);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n      }\n    }\n    return n;\n  }\n\n  // Helper method to check for side effects\n  private boolean hasSideEffects(Node node) {\n    return node != null &&\n           (node.isIncOrDec() || node.isAssign() ||\n            node.isFunctionCall() || node.isGetProp() || node.isSetProp());\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}