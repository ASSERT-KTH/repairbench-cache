{
    "generation": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n    if (parent == null) {\n        // Cannot replace the top-level node.\n        return n;\n    }\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          // Need to make sure that the expr and condition are compatible\n          // with OR_PRECEDENCE, but only if they would need to be parenthesized.\n          Node condChild = cond.getFirstChild();\n          Node exprChild = expr.getFirstChild();\n          if (isLowerPrecedenceInExpression(condChild, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(exprChild, OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          cond.detachFromParent(); // Should be cond.detachChildren() or condChild.detach()? No, detach the NOT node.\n          expr.detachFromParent(); // Detach the EXPR_RESULT node.\n          Node or = IR.or(\n              condChild.detachFromParent(), // Take the child of NOT\n              exprChild.detachFromParent()) // Take the child of EXPR_RESULT\n              .srcref(n); // Use the IF's source info\n          Node newExpr = NodeUtil.newExpr(or).srcref(n); // Wrap in EXPR_RESULT\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        Node exprChild = expr.getFirstChild();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(exprChild, AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        cond.detachFromParent();\n        expr.detachFromParent(); // Detach the EXPR_RESULT node.\n        Node and = IR.and(cond, exprChild.detachFromParent()).srcref(n); // Take the child of EXPR_RESULT\n        Node newExpr = NodeUtil.newExpr(and).srcref(n); // Wrap in EXPR_RESULT\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            // if(X) { if(Y) { A } } else { B } -> if(X && Y) { A } else { B }\n            // Requires X and Y are ifadmissable.\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren(); // Detach cond and thenBranch\n              n.addChildToBack(\n                  IR.and(\n                      cond.detachFromParent(), // Use original cond\n                      innerCond.detachFromParent()) // Use innerCond\n                      .srcref(cond)); // Use outer cond's source info? Better to use 'n' or innerIf\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              if (elseBranch != null) { // Add the original else branch back if it existed (though this case implies elseBranch == null)\n                 n.addChildrenToBack(elseBranch.detachFromParent());\n              }\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              // Re-evaluate the modified node 'n'. It's already returned.\n              return n; // Return the modified n\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild()); // Replace NOT node with its child\n      n.removeChild(thenBranch); // Remove original then branch\n      n.addChildToBack(elseBranch.detachFromParent()); // Move else to then position\n      n.addChildToBack(thenBranch); // Add original then branch as the new else branch\n      reportCodeChange();\n      // Re-evaluate the modified node 'n'.\n      // return n; // Continue optimizing the modified node by returning it\n      // Let subsequent passes handle further optimization.\n      return n; // Return n to signal modification but possibly allow further opts\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      if (thenExpr != null && elseExpr != null) {\n        n.detachChildren(); // Detach cond, then, else\n        Node hookNode = IR.hook(cond.detachFromParent(),\n                                thenExpr.detachFromParent(),\n                                elseExpr.detachFromParent())\n                              .srcref(n); // Use IF's source info\n        Node returnNode = IR.returnNode(hookNode).srcref(n);\n        parent.replaceChild(n, returnNode);\n        reportCodeChange();\n        return returnNode;\n      }\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenExprResult = getBlockExpression(thenBranch);\n      Node elseExprResult = getBlockExpression(elseBranch);\n      Node thenOp = thenExprResult.getFirstChild();\n      Node elseOp = elseExprResult.getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          // Check LHS equality, lack of side effects in LHS itself, AND lack of side effects in condition\n          // to prevent incorrect transformations like `x = x++ ? 1 : 2` from `if(x++) x=1; else x=2;`\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              !mayEffectMutableState(lhs) &&\n              !mayEffectMutableState(cond)) { // <-- Added check for condition side effects\n\n            cond.detachFromParent();\n            Node assignName = thenOp.removeFirstChild(); // lhs detaches from thenOp\n            Node thenValue = thenOp.removeFirstChild(); // rhs detaches from thenOp\n            Node elseValue = elseOp.getLastChild(); // rhs of elseOp\n            elseValue.detachFromParent(); // Detach elseValue from elseOp\n\n            Node hookNode = IR.hook(cond, thenValue, elseValue).srcref(n);\n            // Create new assignment using the original operator type\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .srcref(thenOp); // Use source info of original assignment\n            Node expr = NodeUtil.newExpr(assign).srcref(n); // Wrap in EXPR_RESULT\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      // This handles the general case, including when the assignment optimization above\n      // was unsafe due to side effects in the condition.\n      cond.detachFromParent();\n      thenOp.detachFromParent(); // Detach the expression itself (e.g., assign, call)\n      elseOp.detachFromParent();\n      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n      Node expr = IR.exprResult(hookNode).srcref(n); // Wrap in EXPR_RESULT\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock) {\n       Node elseExprResult = getBlockExpression(elseBranch);\n       if (elseExprResult.getFirstChild().isAssign()) {\n         Node var = getBlockVar(thenBranch); // VAR node\n         Node elseAssign = elseExprResult.getFirstChild(); // ASSIGN node\n\n         Node name1 = var.getFirstChild(); // NAME node in VAR\n         Node maybeName2 = elseAssign.getFirstChild(); // NAME node in ASSIGN\n\n         if (name1.hasChildren() // var y = 1 (name1 has child 1)\n             && maybeName2.isName()\n             && name1.getString().equals(maybeName2.getString())) {\n\n           cond.detachFromParent();\n           Node thenExpr = name1.removeChildren(); // Value from VAR\n           Node elseExpr = elseAssign.getLastChild().detachFromParent(); // Value from ASSIGN\n\n           Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                               .srcref(n); // Use IF source info\n           var.detachFromParent(); // Detach VAR from its original block\n           name1.addChildrenToBack(hookNode); // Attach HOOK as new initializer for NAME\n           parent.replaceChild(n, var); // Replace IF with VAR\n           reportCodeChange();\n           return var;\n         }\n       }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock) {\n        Node thenExprResult = getBlockExpression(thenBranch);\n        if (thenExprResult.getFirstChild().isAssign()) {\n          Node var = getBlockVar(elseBranch); // VAR node\n          Node thenAssign = thenExprResult.getFirstChild(); // ASSIGN node\n\n          Node maybeName1 = thenAssign.getFirstChild(); // NAME node in ASSIGN\n          Node name2 = var.getFirstChild(); // NAME node in VAR\n\n          if (name2.hasChildren() // var y = 2 (name2 has child 2)\n              && maybeName1.isName()\n              && maybeName1.getString().equals(name2.getString())) {\n\n            cond.detachFromParent();\n            Node thenExpr = thenAssign.getLastChild().detachFromParent(); // Value from ASSIGN\n            Node elseExpr = name2.removeChildren(); // Value from VAR\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n); // Use IF source info\n            var.detachFromParent(); // Detach VAR from its original block\n            name2.addChildrenToBack(hookNode); // Attach HOOK as new initializer for NAME\n            parent.replaceChild(n, var); // Replace IF with VAR\n            reportCodeChange();\n\n            return var;\n         }\n       }\n    }\n\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}