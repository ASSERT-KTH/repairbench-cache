{
    "generation": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          return n;\n        }\n\n        if (cond.isNot()) {\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) {\n            return n;\n          }\n\n          Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) {\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild() && thenBranch.getFirstChild().isIf()) {\n          Node innerIf = thenBranch.getFirstChild();\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThenBranch = innerCond.getNext();\n          Node innerElseBranch = innerThenBranch.getNext();\n\n          if (innerElseBranch == null) {\n            n.detachChildren();\n            n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond));\n            n.addChildrenToBack(innerThenBranch.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n\n        return n;\n      }\n    }\n\n    tryRemoveRepeatedStatements(n);\n\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      Node returnNode = IR.returnNode(\n          IR.hook(cond, thenExpr, elseExpr).srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBlockIsExpr = isFoldableExpressBlock(thenBranch);\n    boolean elseBlockIsExpr = isFoldableExpressBlock(elseBranch);\n    if (thenBlockIsExpr && elseBlockIsExpr) {\n      Node thenExpr = getBlockExpression(thenBranch);\n      Node elseExpr = getBlockExpression(elseBranch);\n      if (thenExpr != null && elseExpr != null) {\n        Node condExpr = cond.removeFirstChild();\n        Node hookNode = IR.hook(condExpr, thenExpr, elseExpr).srcref(n);\n        Node expr = NodeUtil.newExpr(hookNode);\n        parent.replaceChild(n, expr);\n        reportCodeChange();\n        return expr;\n      }\n    }\n\n    boolean thenBlockIsVar = isVarBlock(thenBranch);\n    boolean elseBlockIsVar = isVarBlock(elseBranch);\n\n    // if(x) var a = 1; else var a = 2 \u2192 var a = x ? 1 : 2;\n    if (thenBlockIsVar || elseBlockIsVar) {\n      Node varBlock = thenBlockIsVar ? thenBranch : elseBranch;\n      Node assignBlock = thenBlockIsVar ? elseBranch : thenBranch;\n\n      Node varDecl = getBlockVar(varBlock);\n      if (varDecl != null) {\n        String varName = varDecl.getFirstChild().getString();\n        Node assignExpr = getBlockExpression(assignBlock);\n        if (assignExpr != null && assignExpr.isAssign() &&\n            assignExpr.getFirstChild().getString().equals(varName)) {\n          Node condExpr = cond.detachFromParent();\n          Node thenExpr = getBlockExpression(thenBranch).detachFromParent();\n          Node elseExpr = getBlockExpression(elseBranch).detachFromParent();\n\n          Node hookNode = IR.hook(condExpr, thenExpr, elseExpr).srcref(n);\n          Node newVar = new Node(Node.VAR)\n              .addChildToBack(varDecl.detachFromParent())\n              .addChildToBack(hookNode)\n              .srcref(n);\n          parent.replaceChild(n, newVar);\n          reportCodeChange();\n          return newVar;\n        }\n      }\n    }\n\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}