{
    "generation": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          return n;\n        }\n\n        if (cond.isNot()) {\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n          return newExpr;\n        }\n\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      } else {\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              return n;\n            }\n          }\n        }\n      }\n      return n;\n    }\n\n    tryRemoveRepeatedStatements(n);\n\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenExpr = getBlockExpression(thenBranch).getFirstChild();\n      Node elseExpr = getBlockExpression(elseBranch).getFirstChild();\n\n      // Handle cases where the LHS of assignment expressions match\n      if (NodeUtil.isAssignmentOp(thenExpr) && NodeUtil.isAssignmentOp(elseExpr)) {\n        Node lhsThen = thenExpr.getFirstChild();\n        Node lhsElse = elseExpr.getFirstChild();\n        if (areNodesEqualForInlining(lhsThen, lhsElse) &&\n            !mayEffectMutableState(lhsThen)) {\n          n.removeChild(cond);\n          Node assignName = lhsThen.detachFromParent();\n          Node thenVal = thenExpr.removeFirstChild();\n          Node elseVal = elseExpr.removeFirstChild();\n          Node hookNode = IR.hook(cond, thenVal, elseVal).srcref(n);\n          Node assign = thenExpr.copy();\n          assign.addChildToFront(assignName);\n          assign.removeChildren(1, assign.getChildCount());\n          assign.addChildToBack(hookNode);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n\n      // if(x)a=1;else a=2; -> a=x?1:2;\n      if (NodeUtil.isAssignmentOp(thenExpr) && elseExpr.isAssign()) {\n        Node lhsThen = thenExpr.getFirstChild();\n        Node lhsElse = elseExpr.getFirstChild();\n        if (areNodesEqualForInlining(lhsThen, lhsElse) &&\n            !mayEffectMutableState(lhsThen)) {\n          n.removeChild(cond);\n          Node assignName = lhsThen.detachFromParent();\n          Node thenVal = thenExpr.removeFirstChild();\n          Node elseVal = elseExpr.getLastChild().detachFromParent();\n          Node hookNode = IR.hook(cond, thenVal, elseVal).srcref(n);\n          Node assign = new Node(thenExpr.getType(), assignName, hookNode)\n                            .srcref(thenExpr);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n\n      // Handle the generic case for if(x)foo();else bar(); -> x?foo():bar()\n      if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n\n        if (!mayHaveSideEffects(cond) ||\n            (isSimpleExpression(thenOp) && isSimpleExpression(elseOp))) {\n          n.removeChild(cond);\n          thenOp.detachFromParent();\n          elseOp.detachFromParent();\n          Node newThenOp = NodeUtil.newExpr(thenOp).removeFirstChild();\n          Node newElseOp = NodeUtil.newExpr(elseOp).removeFirstChild();\n          Node expr = IR.exprResult(\n              IR.hook(cond, newThenOp, newElseOp).srcref(n));\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren() &&\n          maybeName2.isName() &&\n          name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren() &&\n          maybeName1.isName() &&\n          maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n    }\n\n    return n;\n  }\n\n  private boolean mayHaveSideEffects(Node node) {\n    return node.hasChildren() &&\n           NodeUtil.mayHaveSideEffects(node, compiler);\n  }\n\n  private boolean isSimpleExpression(Node node) {\n    // Simple expressions are those that don't have complex side effects\n    // or don't rely on evaluation order as much\n    if (node.isName() || node.isNumber() || node.isString()) {\n      return true;\n    }\n    if (node.isPostfix() || node.isPrefix()) {\n      return true;\n    }\n    if (node.isBinaryOp()) {\n      return isSimpleExpression(node.getFirstChild()) &&\n             isSimpleExpression(node.getLastChild());\n    }\n    return false;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}