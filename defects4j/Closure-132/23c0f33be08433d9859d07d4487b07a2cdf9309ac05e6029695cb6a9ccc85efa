{
    "generation": "private Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n\n  /* If the condition is a literal, we'll let other\n   * optimizations try to remove useless code.\n   */\n  if (NodeUtil.isLiteralValue(cond, true)) {\n    return n;\n  }\n\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      Node expr = getBlockExpression(thenBranch);\n      if (!late && isPropertyAssignmentInExpression(expr)) {\n        // Keep opportunities for CollapseProperties...\n        return n;\n      }\n\n      if (cond.isNot()) {\n        // if(!x)bar(); -> x||bar();\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                                         OR_PRECEDENCE)) {\n          return n;\n        }\n        Node or = IR.or(\n            cond.removeFirstChild(),\n            expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n\n      // if(x)foo(); -> x&&foo();\n      if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n          isLowerPrecedenceInExpression(expr.getFirstChild(),\n                                       AND_PRECEDENCE)) {\n        return n;\n      }\n\n      n.removeChild(cond);\n      Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n      Node newExpr = NodeUtil.newExpr(and);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    } else {\n      // Try to combine two IF-ELSE into a single &&\n      if (NodeUtil.isStatementBlock(thenBranch) &&\n          thenBranch.hasOneChild()) {\n        Node innerIf = thenBranch.getFirstChild();\n        if (innerIf.isIf()) {\n          Node innerCond = innerIf.getFirstChild();\n          Node innerThen = innerCond.getNext();\n          Node innerElse = innerThen.getNext();\n          if (innerElse == null &&\n              !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n            n.detachChildren();\n            n.addChildToBack(\n                IR.and(\n                    cond,\n                    innerCond.detachFromParent())\n                    .srcref(cond));\n            n.addChildrenToBack(innerThen.detachFromParent());\n            reportCodeChange();\n            return n;\n          }\n        }\n      }\n    }\n    return n;\n  }\n\n  tryRemoveRepeatedStatements(n);\n\n  // if(!x)foo();else bar(); -> if(x)bar();else foo();\n  if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n    n.replaceChild(cond, cond.removeFirstChild());\n    n.removeChild(thenBranch);\n    n.addChildToBack(thenBranch);\n    reportCodeChange();\n    return n;\n  }\n\n  // if(x)return A;else return B; -> return x?A:B;\n  if (isReturnExpressBlock(thenBranch) &&\n      isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    n.removeChild(cond);\n    thenExpr.detachFromParent();\n    elseExpr.detachFromParent();\n    Node returnNode = IR.returnNode(\n        IR.hook(cond, thenExpr, elseExpr)\n          .srcref(n));\n    parent.replaceChild(n, returnNode);\n    reportCodeChange();\n    return returnNode;\n  }\n\n  boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n  boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n  if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n\n    if (thenOp.getType() == elseOp.getType()) {\n      // if(x)a=1;else a=2; -> a=x?1:2;\n      // ONLY collapse simple `=` to a NAME; skip GETPROP/GETELEM and skip compound ops.\n      if (thenOp.getType() == Token.ASSIGN) {\n        Node lhs = thenOp.getFirstChild();\n        if (lhs.isName()\n            && areNodesEqualForInlining(lhs, elseOp.getFirstChild())\n            && !mayEffectMutableState(lhs)) {\n          n.removeChild(cond);\n          Node assignName = thenOp.removeFirstChild();\n          Node thenExpr = thenOp.removeFirstChild();\n          Node elseExpr = elseOp.getLastChild();\n          elseOp.removeChild(elseExpr);\n\n          Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                             .srcref(n);\n          Node assign = new Node(thenOp.getType(),\n                                 assignName,\n                                 hookNode)\n                            .srcref(thenOp);\n          Node expr = NodeUtil.newExpr(assign);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n          return expr;\n        }\n      }\n    }\n\n    // fallback: if(x)foo();else bar(); -> x?foo():bar();\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(\n        IR.hook(cond, thenOp, elseOp)\n          .srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n  }\n\n  // handle var-vs-assign cases...\n  boolean thenBranchIsVar = isVarBlock(thenBranch);\n  boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n  if (thenBranchIsVar &&\n      elseBranchIsExpressionBlock &&\n      getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n    Node var = getBlockVar(thenBranch);\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n    Node name1 = var.getFirstChild();\n    Node maybeName2 = elseAssign.getFirstChild();\n\n    if (name1.hasChildren()\n        && maybeName2.isName()\n        && name1.getString().equals(maybeName2.getString())) {\n      Node thenExpr = name1.removeChildren();\n      Node elseExpr = elseAssign.getLastChild().detachFromParent();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                         .srcref(n);\n      var.detachFromParent();\n      name1.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n\n  } else if (elseBranchIsVar &&\n             thenBranchIsExpressionBlock &&\n             getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n    Node var = getBlockVar(elseBranch);\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n    Node maybeName1 = thenAssign.getFirstChild();\n    Node name2 = var.getFirstChild();\n\n    if (name2.hasChildren()\n        && maybeName1.isName()\n        && maybeName1.getString().equals(name2.getString())) {\n      Node thenExpr = thenAssign.getLastChild().detachFromParent();\n      Node elseExpr = name2.removeChildren();\n      cond.detachFromParent();\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                         .srcref(n);\n      var.detachFromParent();\n      name2.addChildrenToBack(hookNode);\n      parent.replaceChild(n, var);\n      reportCodeChange();\n      return var;\n    }\n  }\n\n  return n;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}