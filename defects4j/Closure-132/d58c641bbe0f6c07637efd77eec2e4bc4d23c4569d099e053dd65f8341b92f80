{
    "generation": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.jscomp.NodeUtil;\nimport static com.google.javascript.jscomp.AstValidator.validateCodeChange;\nimport static com.google.javascript.jscomp.NodeUtil.isAssignmentOp;\nimport static com.google.javascript.jscomp.NodeUtil.isExpressionNode;\nimport static com.google.javascript.jscomp.NodeUtil.isForIn;\nimport static com.google.javascript.jscomp.NodeUtil.isTryFinallyNode;\nimport static com.google.javascript.jscomp.NodeUtil.newExpr;\nimport static com.google.javascript.jscomp.parsing.JsDocInfoParser.getConsistentEOL;\nimport com.google.javascript.rhino.Token;\n\n// Dummy classes and methods to allow compilation\nabstract class AbstractPeepholeOptimization {\n    abstract protected Node optimizeSubtree(Node subtree);\n    protected void reportCodeChange() {}\n    boolean late = false; // Added field to match original code context\n    static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND); // Added constant\n    static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR); // Added constant\n    boolean isASTNormalized() { return true; } // Dummy implementation\n    boolean nodeTypeMayHaveSideEffects(Node n) { return NodeUtil.nodeTypeMayHaveSideEffects(n); } // Dummy implementation\n    boolean mayEffectMutableState(Node n) { return NodeUtil.mayHaveSideEffects(n); } // Dummy implementation\n    boolean areNodesEqualForInlining(Node n1, Node n2) { return n1.isEquivalentToTyped(n2); } // Dummy implementation\n\n  /**\n   * Returns true if the node may represent a Generator function. The FUNCTION node passed in must\n   * be the root of a function.\n   */\n  protected static boolean isGeneratorFunction(Node n) {\n    return n.isGeneratorFunction();\n  }\n\n  /** @return Whether the node is a call to {@code goog.reflect.objectProperty}. */\n  static boolean isGoogReflectObjectProperty(Node n) {\n      return false; // Dummy\n  }\n\n\n    protected boolean consumesDanglingElse(Node n) { return false; } // Dummy\n\n    protected boolean isLowerPrecedenceInExpression(Node n, int p) { return false; } // Dummy\n\n    protected boolean isPropertyAssignmentInExpression(Node n) { return false; } // Dummy\n\n    protected void tryRemoveRepeatedStatements(Node n) {} // Dummy\n\n    /**\n     * @return Whether the node is a block with a single statement that\n     * is an expression.\n     */\n    protected static boolean isFoldableExpressBlock(Node n) {\n      if (n.isBlock()) {\n        if (n.hasOneChild()) {\n          Node first = n.getFirstChild();\n          return isExpressionNode(first);\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @return The expression node.\n     * @see #isFoldableExpressBlock\n     */\n    protected static Node getBlockExpression(Node n) {\n      return n.getFirstChild();\n    }\n\n    /**\n     * @return Whether the node is a block with a single statement that\n     * is an return.\n     */\n    protected static boolean isReturnExpressBlock(Node n) {\n      if (n.isBlock()) {\n        if (n.hasOneChild()) {\n          Node first = n.getFirstChild();\n          if (first.isReturn()) {\n            return first.hasOneChild();\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @return The expression node.\n     * @see #isReturnExpressBlock\n     */\n    protected static Node getBlockReturnExpression(Node n) {\n      return n.getFirstChild().getFirstChild();\n    }\n\n\n    /**\n     * @return Whether the node is a block with a single var statement.\n     */\n    private static boolean isVarBlock(Node n) {\n      if (n.isBlock()) {\n        if (n.hasOneChild()) {\n          Node first = n.getFirstChild();\n          return first.isVar();\n        }\n      }\n      return false;\n    }\n\n    /**\n     * @return The var node.\n     * @see #isVarBlock\n     */\n    private static Node getBlockVar(Node n) {\n      return n.getFirstChild();\n    }\n}\n\n\nclass PeepholeSubstituteAlternateSyntax extends AbstractPeepholeOptimization {\n  @Override\n  protected Node optimizeSubtree(Node node) {\n    // Required implementation, but not relevant for the fix.\n    return node;\n  }\n  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        // This optimization is only valid if the assignment doesn't have side effects\n        // and is a simple assignment. Compound assignments (like +=) are NOT handled here.\n        // We check for side effects on the LHS because the assignment will be hoisted\n        // outside the condition: a = x ? 1 : 2 evaluates 'a' first.\n        if (thenOp.isAssign()) { // <<< FIX: Changed from NodeUtil.isAssignmentOp(thenOp) to thenOp.isAssign()\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              !mayEffectMutableState(lhs)) {\n\n            // Transform: a = cond ? thenExpr : elseExpr;\n            n.removeChild(cond); // Detach condition 'x'\n            Node assignName = thenOp.removeFirstChild(); // Get LHS 'a' from 'a=1'\n            Node thenExpr = thenOp.removeFirstChild();   // Get RHS '1' from 'a=1'\n            Node elseExpr = elseOp.getLastChild();       // Get RHS '2' from 'a=2'\n            elseOp.removeChild(elseExpr); // Detach '2' from 'a=2'\n\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); // Create hook 'x?1:2'\n            Node assign = IR.assign(assignName, hookNode) // Create 'a = (x?1:2)'\n                              .srcref(thenOp); // Use srcref from original assignment 'a=1'\n            Node expr = NodeUtil.newExpr(assign); // Create EXPR_RESULT node\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        }\n      }\n      // Fallback: if(x)foo();else bar(); -> x?foo():bar()\n      // This applies if the a=x?1:2 optimization above wasn't possible (e.g., because of\n      // side effects, compound assignment, or different LHS).\n      n.removeChild(cond); // Detach condition 'x'\n      thenOp.detachFromParent(); // Detach the entire 'then' expression (e.g., 'a=1', 'x+=2')\n      elseOp.detachFromParent(); // Detach the entire 'else' expression (e.g., 'a=2', 'x+=3')\n      Node expr = IR.exprResult( // Create EXPR_RESULT\n          IR.hook(cond, thenOp, elseOp).srcref(n)); // Create hook 'x ? (a=1) : (a=2)'\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild(); // VAR name node\n      Node maybeName2 = elseAssign.getFirstChild(); // LHS of assignment\n\n      if (name1.hasChildren() // var y = 1; (has initializer)\n          && maybeName2.isName()\n          && name1.getString().equals(maybeName2.getString())) { // names match\n        Node thenExpr = name1.removeChildren(); // Get initializer '1'\n        Node elseExpr = elseAssign.getLastChild().detachFromParent(); // Get RHS '2'\n        cond.detachFromParent(); // Detach condition 'x'\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr) // Create hook 'x?1:2'\n                            .srcref(n);\n        var.detachFromParent(); // Detach 'var y=1' from original block\n        name1.addChildrenToBack(hookNode); // Make it 'var y=(x?1:2)'\n        parent.replaceChild(n, var); // Replace 'if' with 'var'\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n\n      Node var = getBlockVar(elseBranch); // Get 'var y=2'\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); // Get 'y=1'\n\n      Node maybeName1 = thenAssign.getFirstChild(); // LHS 'y' from 'y=1'\n      Node name2 = var.getFirstChild(); // VAR name node 'y' from 'var y=2'\n\n      if (name2.hasChildren() // var y = 2; (has initializer)\n          && maybeName1.isName()\n          && maybeName1.getString().equals(name2.getString())) { // names match\n        Node thenExpr = thenAssign.getLastChild().detachFromParent(); // Get RHS '1'\n        Node elseExpr = name2.removeChildren(); // Get initializer '2'\n        cond.detachFromParent(); // Detach condition 'x'\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr) // Create hook 'x?1:2'\n                            .srcref(n);\n        var.detachFromParent(); // Detach 'var y=2' from original block\n        name2.addChildrenToBack(hookNode); // Make it 'var y=(x?1:2)'\n        parent.replaceChild(n, var); // Replace 'if' with 'var'\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}