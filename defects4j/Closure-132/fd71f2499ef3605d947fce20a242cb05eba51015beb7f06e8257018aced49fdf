{
    "generation": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      // Single IF statement (no ELSE)\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        // Use the expression within the EXPR_RESULT node for analysis\n        Node innerExpr = expr.getFirstChild();\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(innerExpr, OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(), // operand of NOT\n              innerExpr.detachFromParent()).srcref(n); // Use detachFromParent\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(innerExpr, AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        cond.detachFromParent(); // Use detachFromParent\n        Node and = IR.and(cond, innerExpr.detachFromParent()).srcref(n); // Use detachFromParent\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n        // Try to combine two IF statements: if(a) { if(b) { foo } } -> if(a && b) { foo }\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            // Only applies if the inner IF has no ELSE branch.\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              // Create the AND condition\n              Node andCond = IR.and(cond.detachFromParent(),\n                                   innerCond.detachFromParent())\n                                   .srcref(cond); // Use srcref from original cond\n              // Detach the inner then branch\n              innerThenBranch.detachFromParent();\n\n              // Rebuild the IF node\n              n.detachChildren(); // Remove original children (cond, thenBranch)\n              n.addChildToBack(andCond);\n              n.addChildToBack(innerThenBranch);\n              reportCodeChange();\n              // Return the modified n, allowing further optimizations\n              return n;\n            }\n          }\n        }\n      }\n\n      // No transformation applied for single IF\n      return n;\n    }\n\n    // IF statement with an ELSE branch\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      Node operand = cond.removeFirstChild();\n      n.replaceChild(cond, operand); // Replace !x with x\n      // Swap then and else branches\n      thenBranch.detachFromParent();\n      elseBranch.detachFromParent();\n      n.addChildToBack(elseBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      // Return the modified n, as its structure changed\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenReturnExpr = getBlockReturnExpression(thenBranch);\n      Node elseReturnExpr = getBlockReturnExpression(elseBranch);\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      if (thenReturnExpr != null && elseReturnExpr != null) {\n          cond.detachFromParent();\n          thenReturnExpr.detachFromParent();\n          elseReturnExpr.detachFromParent();\n\n          Node hookNode = IR.hook(cond, thenReturnExpr, elseReturnExpr).srcref(n);\n          Node returnNode = IR.returnNode(hookNode).srcref(n); // Use srcref from original IF\n\n          parent.replaceChild(n, returnNode);\n          reportCodeChange();\n          return returnNode;\n      }\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenExprResult = getBlockExpression(thenBranch);\n      Node elseExprResult = getBlockExpression(elseBranch);\n      Node thenOp = thenExprResult.getFirstChild();\n      Node elseOp = elseExprResult.getFirstChild();\n\n      // Try to convert: if(x) a=1; else a=2; ==> a = x?1:2;\n      // This optimization is only applied for simple assignments (=).\n      // It is not applied to compound assignments (+=, *=, etc.) because\n      // the transformation \"lhs op= (cond ? rhs1 : rhs2)\" is not equivalent to\n      // \"cond ? (lhs op= rhs1) : (lhs op= rhs2)\".\n      if (thenOp.isAssign() && elseOp.isAssign()) {\n        Node lhs = thenOp.getFirstChild();\n        Node lhs2 = elseOp.getFirstChild();\n\n        if (areNodesEqualForInlining(lhs, lhs2) &&\n            // Check if evaluating the LHS has side effects itself (e.g., function call).\n            // This prevents changing the number of times side effects occur.\n            // Example: if(c) next().foo = 1; else next().foo = 2;\n            // should not become next().foo = c ? 1 : 2; if next() has side effects.\n            !mayEffectMutableState(lhs)) {\n\n          cond.detachFromParent();\n          // Detach the LHS and RHS from both original assignments\n          Node assignLhs = thenOp.getFirstChild().detachFromParent();\n          Node thenRhs = thenOp.getLastChild().detachFromParent();\n          Node elseRhs = elseOp.getLastChild().detachFromParent();\n\n          // Create the HOOK node: cond ? thenRhs : elseRhs\n          Node hookNode = IR.hook(cond, thenRhs, elseRhs)\n                              .srcref(n); // Use srcref from IF for HOOK\n\n          // Create the new ASSIGN node: assignLhs = hookNode\n          Node assign = IR.assign(assignLhs, hookNode)\n                            .srcref(thenOp); // Use srcref from original assign\n\n          // Create the new EXPR_RESULT node\n          Node newExpr = IR.exprResult(assign)\n                             .srcref(n); // Use srcref from original IF\n\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n          return newExpr;\n        }\n      }\n\n      // Fallback for foldable expressions that were not converted above:\n      // if(x) foo(); else bar(); ==> x ? foo() : bar();\n      // This handles cases like:\n      // - Assignments where LHS differs or has side effects (e.g., if(c)a=1;else b=2;)\n      // - Compound assignments (e.g., if(c)x+=1;else x+=2;) which become c?x+=1:x+=2\n      // - Other expressions (e.g., if(c)foo();else bar();)\n      cond.detachFromParent();\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n      Node newExpr = IR.exprResult(hookNode).srcref(n); // Use srcref from original IF\n\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    }\n\n    // Handling VAR declarations mixed with assignments\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock) {\n        Node elseExpr = getBlockExpression(elseBranch);\n        if (elseExpr.getFirstChild().isAssign()) {\n            Node var = getBlockVar(thenBranch); // VAR node\n            Node name1 = var.getFirstChild(); // NAME node in VAR\n            Node elseAssign = elseExpr.getFirstChild(); // ASSIGN node\n            Node maybeName2 = elseAssign.getFirstChild(); // NAME node in ASSIGN\n\n            // Check: var name = <val1>; ... name = <val2>;\n            // Ensure the var has an initializer and the names match.\n            if (name1.hasChildren() && maybeName2.isName() &&\n                name1.getString().equals(maybeName2.getString())) {\n\n              cond.detachFromParent();\n              Node thenExpr = name1.removeChildren(); // Initializer from VAR\n              Node elseRhs = elseAssign.getLastChild().detachFromParent(); // RHS from ASSIGN\n\n              Node hookNode = IR.hook(cond, thenExpr, elseRhs).srcref(n);\n              // Attach the hook as the new initializer for the var's name node\n              name1.addChildToBack(hookNode);\n\n              // Replace the IF with the VAR node (already detached from its block)\n              parent.replaceChild(n, var.detachFromParent());\n              reportCodeChange();\n              return var;\n            }\n        }\n    }\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    else if (elseBranchIsVar && thenBranchIsExpressionBlock) {\n        Node thenExpr = getBlockExpression(thenBranch);\n        if (thenExpr.getFirstChild().isAssign()) {\n            Node var = getBlockVar(elseBranch); // VAR node\n            Node name2 = var.getFirstChild(); // NAME node in VAR\n            Node thenAssign = thenExpr.getFirstChild(); // ASSIGN node\n            Node maybeName1 = thenAssign.getFirstChild(); // NAME node in ASSIGN\n\n            // Check: name = <val1>; ... var name = <val2>;\n            // Ensure the var has an initializer and the names match.\n            if (name2.hasChildren() && maybeName1.isName() &&\n                maybeName1.getString().equals(name2.getString())) {\n\n              cond.detachFromParent();\n              Node thenRhs = thenAssign.getLastChild().detachFromParent(); // RHS from ASSIGN\n              Node elseExpr = name2.removeChildren(); // Initializer from VAR\n\n              Node hookNode = IR.hook(cond, thenRhs, elseExpr).srcref(n);\n              // Attach the hook as the new initializer for the var's name node\n              name2.addChildToBack(hookNode);\n\n              // Replace the IF with the VAR node (already detached from its block)\n              parent.replaceChild(n, var.detachFromParent());\n              reportCodeChange();\n              return var;\n            }\n        }\n    }\n\n    // No transformation applied for IF-ELSE\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}