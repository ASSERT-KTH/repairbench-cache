{
    "generation": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n\n        boolean ldIsNan = Double.isNaN(ld);\n        boolean rdIsNan = Double.isNaN(rd);\n\n        // Constants representing the operation types (e.g., from org.apache.commons.jxpath.ri.compiler.CoreOperation)\n        // Assuming these are accessible via this.getOperation() or a field.\n        // For demonstration, using placeholder integers. In JXPath, these are typically constants like CoreOperation.EQUAL.\n        final int OP_EQUAL = 0;         // Placeholder for the \"equal\" operation code\n        final int OP_NOT_EQUAL = 1;     // Placeholder for the \"not equal\" operation code\n        // Other operation codes like GREATER_THAN, LESS_THAN would be different integers.\n\n        // Get the current operation type. This method is assumed to exist in the class or a superclass.\n        // In JXPath, CoreOperation has `getOperation()` which returns the operation type.\n        int currentOperation = getOperation(); // Assumes getOperation() is available\n\n        if (ldIsNan || rdIsNan) {\n            // Handle NaN comparisons according to JXPath test expectations (XPath 1.0 rules where NaN=NaN is false, are overridden by test)\n            if (currentOperation == OP_EQUAL) {\n                // XPath test expects NaN = NaN to be TRUE, NaN = X (X not NaN) to be FALSE\n                return ldIsNan && rdIsNan;\n            } else if (currentOperation == OP_NOT_EQUAL) {\n                // XPath test expects NaN != NaN to be FALSE, NaN != X (X not NaN) to be TRUE\n                return !(ldIsNan && rdIsNan);\n            } else {\n                // For all other comparison operators (>, <, >=, <=), any comparison involving NaN is FALSE\n                return false;\n            }\n        }\n\n        // Standard numeric comparison for non-NaN values\n        int compareResult = (ld == rd) ? 0 : (ld < rd ? -1 : 1);\n        return evaluateCompare(compareResult);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}