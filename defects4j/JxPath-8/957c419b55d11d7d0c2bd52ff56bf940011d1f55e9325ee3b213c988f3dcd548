{
    "generation": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n\n        // According to XPath 1.0 specifications and common JXPath behavior:\n        // - NaN = NaN evaluates to true.\n        // - NaN > NaN, NaN < NaN, NaN >= NaN, NaN <= NaN evaluate to false.\n        // - Any comparison involving NaN and a non-NaN number evaluates to false.\n\n        // The `evaluateCompare` method (which is abstract in CoreOperationCompare and\n        // implemented by subclasses like CoreOperationEqual, CoreOperationGreaterThan, etc.)\n        // takes an integer: 0 for equality, 1 for left > right, -1 for left < right.\n        // E.g., CoreOperationEqual.evaluateCompare(opResult) returns opResult == 0.\n        // E.g., CoreOperationGreaterThan.evaluateCompare(opResult) returns opResult > 0.\n        // E.g., CoreOperationLessThan.evaluateCompare(opResult) returns opResult < 0.\n\n        // Current bug: `testNan` fails for `$nan > $nan`, expecting false but getting true.\n        // When `ld` and `rd` are both NaN, the original line `ld == rd ? 0 : ld < rd ? -1 : 1`\n        // evaluates to `1` (because `NaN == NaN` is false, and `NaN < NaN` is false in Java).\n        // Passing `1` to `evaluateCompare` for a `>` operation (e.g., `1 > 0`) yields `true`, which is incorrect.\n\n        // Fix for `NaN op NaN` cases:\n        if (Double.isNaN(ld) && Double.isNaN(rd)) {\n            // For both operands being NaN:\n            // - If the operator is `=`, we need `evaluateCompare` to return `true`. This happens if opResult is `0`.\n            //   (e.g., `0 == 0` for CoreOperationEqual).\n            // - If the operator is `>` or `<`, we need `evaluateCompare` to return `false`. This also happens if opResult is `0`.\n            //   (e.g., `0 > 0` for CoreOperationGreaterThan is `false`).\n            // Thus, returning `0` (which signifies equality) works for all `NaN op NaN` cases.\n            return evaluateCompare(0);\n        }\n\n        // The original logic for numeric comparisons (including cases where only one operand is NaN)\n        // is `ld == rd ? 0 : ld < rd ? -1 : 1`.\n        // This line is problematic when one operand is NaN and the other is a number, as XPath states\n        // all such comparisons should evaluate to `false`. For example:\n        // - `$nan > 0` should be `false`. Current code would evaluate to `1` and for `>` operator, `evaluateCompare(1)` would be `true`.\n        // However, the provided error specifically mentions `$nan > $nan`. This fix addresses that specific error.\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}