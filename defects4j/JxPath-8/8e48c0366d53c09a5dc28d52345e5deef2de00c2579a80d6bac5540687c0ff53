{
    "generation": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n\n        int cmpResult;\n        if (Double.isNaN(ld) && Double.isNaN(rd)) {\n            // XPath: NaN = NaN is TRUE; NaN < NaN, NaN > NaN are FALSE.\n            // Returning 0 ensures evaluateCompare works correctly for \"=\" (true)\n            // and for \"<\", \">\" (false, as 0 != -1 and 0 != 1).\n            cmpResult = 0;\n        } else if (Double.isNaN(ld) || Double.isNaN(rd)) {\n            // XPath: If one operand is NaN and the other is not, all comparisons are FALSE.\n            // Returning 2 (or any other value not 0, -1, 1) ensures evaluateCompare\n            // returns false for all standard relational operations.\n            cmpResult = 2;\n        } else {\n            // Both are normal numbers; use standard Java comparison.\n            cmpResult = (ld == rd ? 0 : (ld < rd ? -1 : 1));\n        }\n        return evaluateCompare(cmpResult);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}