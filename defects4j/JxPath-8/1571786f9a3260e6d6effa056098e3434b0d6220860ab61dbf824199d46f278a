{
    "generation": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n\n        // Handle NaN comparison rules as per XPath 1.0 specification\n        // XPath NaN rules:\n        // - NaN = NaN  -> true\n        // - NaN = X    -> false (if X is not NaN)\n        // - NaN > X    -> false\n        // - NaN < X    -> false\n        // - X > NaN    -> false\n        // - X < NaN    -> false\n        if (Double.isNaN(ld) || Double.isNaN(rd)) {\n            if (Double.isNaN(ld) && Double.isNaN(rd)) {\n                // If both are NaN, XPath specifies they are equal.\n                // Returning 0 (for equality) will make CoreOperationEqual.evaluateCompare(0) return true.\n                // For CoreOperationGreaterThan and CoreOperationLessThan, evaluateCompare(0) will correctly return false.\n                return evaluateCompare(0);\n            } else {\n                // If only one is NaN, any comparison (=, >, <) should result in false.\n                // We return a value (e.g., 2) that is not 0, 1, or -1.\n                // This ensures that CoreOperationEqual, CoreOperationGreaterThan, and CoreOperationLessThan\n                // will all return false when checking evaluateCompare(2).\n                return evaluateCompare(2);\n            }\n        }\n        \n        // Original logic for non-NaN doubles\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}