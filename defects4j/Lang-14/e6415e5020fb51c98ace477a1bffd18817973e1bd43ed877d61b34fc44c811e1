{
    "generation": "    /**\n     * <p>Compares two CharSequences, returning {@code true} if they represent\n     * equal sequences of characters.</p>\n     *\n     * <p>{@code null}s are handled without exceptions. Two {@code null}\n     * references are considered to be equal. The comparison is case sensitive.</p>\n     *\n     * <pre>\n     * StringUtils.equals(null, null)   = true\n     * StringUtils.equals(null, \"abc\")  = false\n     * StringUtils.equals(\"abc\", null)  = false\n     * StringUtils.equals(\"abc\", \"abc\") = true\n     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * @see java.lang.CharSequence#equals(Object)\n     * @param cs1  the first CharSequence, may be {@code null}\n     * @param cs2  the second CharSequence, may be {@code null}\n     * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n     * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n     */\n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n\n        // At this point, both cs1 and cs2 are non-null and not the same object reference.\n        // The original problem was that cs1.equals(cs2) might not perform\n        // content comparison for different CharSequence implementations.\n        // For example, String.equals(Object) only returns true if the object\n        // is another String, and StringBuilder.equals(Object) performs\n        // only reference equality.\n\n        // If one of the CharSequences is a String, use its contentEquals method,\n        // which correctly compares content with any CharSequence.\n        if (cs1 instanceof String) {\n            return ((String) cs1).contentEquals(cs2);\n        }\n        if (cs2 instanceof String) {\n            // If cs1 is not a String but cs2 is, compare from cs2's perspective.\n            return ((String) cs2).contentEquals(cs1);\n        }\n\n        // If neither is a String (e.g., StringBuilder vs StringBuilder, or\n        // StringBuilder vs CustomCharSequence), perform character-by-character comparison.\n        if (cs1.length() != cs2.length()) {\n            return false;\n        }\n        for (int i = 0; i < cs1.length(); i++) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}