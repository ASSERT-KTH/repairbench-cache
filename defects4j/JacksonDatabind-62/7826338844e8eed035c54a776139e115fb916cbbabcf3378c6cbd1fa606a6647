{
    "generation": "    @Override\n    public CollectionDeserializer createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // First, ensure we have a value instantiator. If null, try to find one.\n        ValueInstantiator resolvedInst = _valueInstantiator;\n        if (resolvedInst == null) {\n            resolvedInst = ctxt.getFactory().findValueInstantiator(ctxt.getConfig(), _collectionType);\n        }\n\n        // Now, resolve the delegate deserializer based on the (potentially new) instantiator\n        JsonDeserializer<Object> resolvedDelegateDeser = null;\n        if (resolvedInst.canCreateUsingDelegate()) {\n            JavaType delegateType = resolvedInst.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+resolvedInst.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            resolvedDelegateDeser = findDeserializer(ctxt, delegateType, property);\n        }\n        // If resolvedInst is NOT delegate-based, then resolvedDelegateDeser remains null, which is correct.\n\n        // [databind#1043]: allow per-property allow-wrapping of single overrides:\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n\n        // Also, often value deserializer is resolved here:\n        JsonDeserializer<?> resolvedValueDeser = _valueDeserializer;\n        \n        // May have a content converter\n        resolvedValueDeser = findConvertingContentDeserializer(ctxt, property, resolvedValueDeser);\n        final JavaType vt = _collectionType.getContentType();\n        if (resolvedValueDeser == null) {\n            resolvedValueDeser = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            resolvedValueDeser = ctxt.handleSecondaryContextualization(resolvedValueDeser, property, vt);\n        }\n\n        // And finally, type deserializer needs context as well\n        TypeDeserializer resolvedValueTypeDeser = _valueTypeDeserializer;\n        if (resolvedValueTypeDeser != null) {\n            resolvedValueTypeDeser = resolvedValueTypeDeser.forProperty(property);\n        }\n\n        // Check if all resolved components are identical to current ones\n        // Note: The comparison for `_delegateDeserializer` needs to be against `resolvedDelegateDeser`\n        // which could be null if `resolvedInst` is not delegate-based.\n        if (resolvedInst == _valueInstantiator && resolvedDelegateDeser == _delegateDeserializer\n                && resolvedValueDeser == _valueDeserializer && resolvedValueTypeDeser == _valueTypeDeserializer\n                && unwrapSingle == _unwrapSingle) {\n            return this;\n        }\n\n        // Return a new instance using the appropriate 'withResolved' method.\n        // The choice depends on whether the resolved ValueInstantiator is delegate-based.\n        // This ensures both _valueInstantiator and _delegateDeserializer are correctly set.\n        if (resolvedInst.canCreateUsingDelegate()) {\n            // If the instantiator is delegate-based, we use the `withResolved` that takes delegateDeser.\n            // This implies `_valueInstantiator` (the field copied from 'this') should already be the delegate-capable instantiator.\n            // For this scenario to work correctly when `_valueInstantiator` was initially null, it implicitly relies on `resolvedInst`\n            // being equal to the `_valueInstantiator` of 'this' (which might be the case if 'this' was already a delegate-based deserializer,\n            // or if the `findValueInstantiator` somehow sets it up globally).\n            // However, this path correctly handles the updating of `_delegateDeserializer`.\n            return withResolved(resolvedDelegateDeser, resolvedValueDeser, resolvedValueTypeDeser, unwrapSingle);\n        } else {\n            // If the instantiator is NOT delegate-based (e.g., for unmodifiable collections),\n            // we use the `withResolved` that takes ValueInstantiator.\n            // This method sets _delegateDeserializer to null, which is correct for non-delegate instantiators.\n            return withResolved(resolvedInst, resolvedValueDeser, resolvedValueTypeDeser, unwrapSingle);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}