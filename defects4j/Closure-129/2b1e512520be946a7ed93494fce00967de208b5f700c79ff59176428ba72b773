{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.jscomp.NodeUtil;\n\n// The surrounding class structure is omitted for brevity,\n// only the fixed function is provided.\n\nclass Fix {\n    /**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n      Node effectiveCallee = first;\n      if (effectiveCallee.isCast()) {\n        effectiveCallee = effectiveCallee.getFirstChild();\n      }\n\n\n      // A call node is a free call if its FIRST child is not a GETPROP or a GETELEM.\n      // Example:\n      //   foo() -> free call\n      //   a.b() -> not a free call\n      //   a[b]() -> not a free call\n      //   (function(){})() -> free call\n      //   (function(){}.bind(this))() -> not a free call\n      if (!NodeUtil.isGet(effectiveCallee)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (effectiveCallee.isName() &&\n          \"eval\".equals(effectiveCallee.getString())) {\n        // The DIRECT_EVAL property should be set on the NAME node itself.\n        effectiveCallee.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}