{
    "generation": "    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n\n        // Start with a period of zero for the target type.\n        // This ensures the result period has the correct PeriodType and all fields are initialized to 0.\n        Period result = new Period(0, type, ISOChronology.getInstanceUTC());\n\n        // Handle years and months specially, as they don't have fixed millisecond equivalents.\n        int currentYears = getYears();\n        int currentMonths = getMonths();\n\n        if (currentYears != 0 || currentMonths != 0) {\n            // Combine years and months into a total month count for internal processing.\n            int totalCurrentMonths = FieldUtils.safeAdd(currentMonths, FieldUtils.safeMultiply(currentYears, 12));\n\n            if (type.isSupported(DurationFieldType.years())) {\n                // If years field is supported, normalize months into 0-11 and adjust years.\n                // Add to existing years/months in result (initially 0, but good practice).\n                result = result.withYears(FieldUtils.safeAdd(totalCurrentMonths / 12, result.getYears()));\n                result = result.withMonths(FieldUtils.safeAdd(totalCurrentMonths % 12, result.getMonths()));\n            } else if (type.isSupported(DurationFieldType.months())) {\n                // If only months field is supported (but not years), convert all to months.\n                result = result.withMonths(FieldUtils.safeAdd(totalCurrentMonths, result.getMonths()));\n            } else {\n                // Neither years nor months are supported by the PeriodType, but the source period has them.\n                // Throw an exception as per the Javadoc contract.\n                throw new UnsupportedOperationException(\"Field is not supported\");\n            }\n        }\n\n        // Handle other time-based fields (weeks, days, hours, minutes, seconds, milliseconds).\n        // These are converted into total milliseconds using standard fixed rules.\n        long lowerMillis = getMillis();\n        lowerMillis = FieldUtils.safeAdd(lowerMillis, ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND);\n        lowerMillis = FieldUtils.safeAdd(lowerMillis, ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE);\n        lowerMillis = FieldUtils.safeAdd(lowerMillis, ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR);\n        lowerMillis = FieldUtils.safeAdd(lowerMillis, ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY);\n        lowerMillis = FieldUtils.safeAdd(lowerMillis, ((long) getWeeks()) * DateTimeConstants.MILLIS_PER_WEEK);\n\n        if (lowerMillis != 0) {\n            // Create a temporary Period from these lower milliseconds.\n            // This constructor will automatically distribute `lowerMillis` into fields\n            // supported by `type` (e.g., if type supports weeks, it will extract weeks from millis).\n            Period lowerPeriod = new Period(lowerMillis, type, ISOChronology.getInstanceUTC());\n            // Add this temporary period to the result. The `plus` method ensures\n            // fields are combined according to the `result`'s PeriodType.\n            result = result.plus(lowerPeriod);\n        }\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}