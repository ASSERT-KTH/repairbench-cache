{
    "generation": "    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n\n        // 1. Get initial years and months from 'this' period\n        int years = getYears();\n        int months = getMonths();\n\n        // 2. Combine years and months into a single total month count.\n        //    Use long to prevent overflow if years/months are very large.\n        long totalMonths = (long) years * 12 + months;\n\n        // 3. Calculate total milliseconds from all standard time-based fields.\n        //    These fields are normalized relative to each other (e.g., 61 seconds becomes 1 minute 1 second)\n        //    and then converted to milliseconds.\n        long totalMillis = getMillis();\n        totalMillis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        totalMillis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        totalMillis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        totalMillis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n        totalMillis += ((long) getWeeks()) * DateTimeConstants.MILLIS_PER_WEEK;\n\n        // 4. Determine the new years and months based on whether the target PeriodType supports years.\n        int newYears;\n        int newMonths;\n        if (type.isSupported(DurationFieldType.years())) {\n            // If the PeriodType supports years, normalize totalMonths into years and months\n            // (months will be in the range [0, 11] for positive totalMonths, or [-11, 0] for negative totalMonths).\n            newYears = FieldUtils.safeToInt(totalMonths / 12);\n            newMonths = FieldUtils.safeToInt(totalMonths % 12);\n        } else {\n            // If the PeriodType does not support years, all totalMonths are collapsed into the months field.\n            // newYears is set to 0.\n            newYears = 0;\n            newMonths = FieldUtils.safeToInt(totalMonths);\n        }\n\n        // 5. Construct the new Period.\n        //    The constructor with all fields will correctly distribute totalMillis\n        //    among weeks, days, hours, minutes, seconds, and milliseconds\n        //    according to the specified PeriodType and Chronology.\n        return new Period(newYears, newMonths, 0, 0, 0, 0, 0, totalMillis, type, ISOChronology.getInstanceUTC());\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}