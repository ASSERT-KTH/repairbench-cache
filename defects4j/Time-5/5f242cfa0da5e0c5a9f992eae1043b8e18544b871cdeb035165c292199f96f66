{
    "generation": "    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n\n        int years = getYears();\n        int months = getMonths();\n\n        // Step 1: Normalize years and months based on the \"1 year 15 months -> 2 years 3 months\" rule.\n        // This normalization ensures months are between 0-11, by overflowing into years.\n        // This step happens *before* considering the PeriodType's supported fields for years/months.\n        // The PeriodType's rules (e.g., converting years to months if years field is not supported)\n        // will be applied by the Period constructor in Step 2.\n        if (years != 0 || months != 0) {\n            // Apply normalization for months overflowing into years\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            \n            // Adjust sign to ensure months is consistent with years,\n            // e.g., 1 year -5 months should normalize to 0 years 7 months.\n            if (years > 0 && months < 0) {\n                years--;\n                months += 12;\n            } else if (years < 0 && months > 0) {\n                years++;\n                months -= 12;\n            }\n        }\n\n        // Step 2: Create the new Period using the normalized years and months,\n        // and all other fields directly from the original period.\n        // The Period constructor will then apply the PeriodType rules:\n        // - If a field is not supported by the PeriodType, its value is added\n        //   to the next largest supported field (e.g., years to months, weeks to days).\n        // - Fields are otherwise kept as they are.\n        return new Period(\n            years,\n            months,\n            getWeeks(),\n            getDays(),\n            getHours(),\n            getMinutes(),\n            getSeconds(),\n            getMillis(),\n            type,\n            ISOChronology.getInstanceUTC()\n        );\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}