{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    // Normalize the target PeriodType\n    type = DateTimeUtils.getPeriodType(type);\n\n    // Extract original fields\n    int years = getYears();\n    int months = getMonths();\n    int weeks = getWeeks();\n    int days = getDays();\n    int hours = getHours();\n    int minutes = getMinutes();\n    int seconds = getSeconds();\n    int millis = getMillis();\n\n    // Check that if there is any year/month content, the type supports at least one\n    boolean canYear = type.isSupported(DurationFieldType.years());\n    boolean canMonth = type.isSupported(DurationFieldType.months());\n    if ((years != 0 || months != 0) && !canYear && !canMonth) {\n        throw new UnsupportedOperationException(\n            \"Period does not support years or months: \" + type);\n    }\n\n    // Normalize years/months\n    int normYears = 0;\n    int normMonths = 0;\n    if (canYear) {\n        // overflow months into years\n        int carry = months / 12;\n        normYears  = FieldUtils.safeAdd(years, carry);\n        normMonths = months % 12;\n    } else {\n        // collapse years into months\n        // we know canMonth must be true here\n        int ym = FieldUtils.safeMultiply(years, 12);\n        normMonths = FieldUtils.safeAdd(ym, months);\n    }\n\n    // Convert all time\u2010based fields into a single millisecond total\n    long total = millis;\n    total = FieldUtils.safeAdd(total,\n        FieldUtils.safeMultiply((long) seconds, DateTimeConstants.MILLIS_PER_SECOND));\n    total = FieldUtils.safeAdd(total,\n        FieldUtils.safeMultiply((long) minutes, DateTimeConstants.MILLIS_PER_MINUTE));\n    total = FieldUtils.safeAdd(total,\n        FieldUtils.safeMultiply((long) hours,   DateTimeConstants.MILLIS_PER_HOUR));\n    total = FieldUtils.safeAdd(total,\n        FieldUtils.safeMultiply((long) days,    DateTimeConstants.MILLIS_PER_DAY));\n    total = FieldUtils.safeAdd(total,\n        FieldUtils.safeMultiply((long) weeks,   DateTimeConstants.MILLIS_PER_WEEK));\n\n    // Split that millisecond total back into the time\u2010fields that the type supports\n    int normWeeks   = 0;\n    int normDays    = 0;\n    int normHours   = 0;\n    int normMinutes = 0;\n    int normSeconds = 0;\n    int normMillis  = 0;\n    long rem = total;\n\n    if (type.isSupported(DurationFieldType.weeks())) {\n        long w = rem / DateTimeConstants.MILLIS_PER_WEEK;\n        if (w < Integer.MIN_VALUE || w > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Week value too large: \" + w);\n        }\n        normWeeks = (int) w;\n        rem -= w * DateTimeConstants.MILLIS_PER_WEEK;\n    }\n    if (type.isSupported(DurationFieldType.days())) {\n        long d = rem / DateTimeConstants.MILLIS_PER_DAY;\n        if (d < Integer.MIN_VALUE || d > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Day value too large: \" + d);\n        }\n        normDays = (int) d;\n        rem -= d * DateTimeConstants.MILLIS_PER_DAY;\n    }\n    if (type.isSupported(DurationFieldType.hours())) {\n        long h = rem / DateTimeConstants.MILLIS_PER_HOUR;\n        if (h < Integer.MIN_VALUE || h > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Hour value too large: \" + h);\n        }\n        normHours = (int) h;\n        rem -= h * DateTimeConstants.MILLIS_PER_HOUR;\n    }\n    if (type.isSupported(DurationFieldType.minutes())) {\n        long m = rem / DateTimeConstants.MILLIS_PER_MINUTE;\n        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Minute value too large: \" + m);\n        }\n        normMinutes = (int) m;\n        rem -= m * DateTimeConstants.MILLIS_PER_MINUTE;\n    }\n    if (type.isSupported(DurationFieldType.seconds())) {\n        long s = rem / DateTimeConstants.MILLIS_PER_SECOND;\n        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Second value too large: \" + s);\n        }\n        normSeconds = (int) s;\n        rem -= s * DateTimeConstants.MILLIS_PER_SECOND;\n    }\n    if (type.isSupported(DurationFieldType.millis())) {\n        if (rem < Integer.MIN_VALUE || rem > Integer.MAX_VALUE) {\n            throw new ArithmeticException(\"Millisecond value too large: \" + rem);\n        }\n        normMillis = (int) rem;\n    }\n\n    // Construct the normalized period\n    return new Period(\n        normYears,\n        normMonths,\n        normWeeks,\n        normDays,\n        normHours,\n        normMinutes,\n        normSeconds,\n        normMillis,\n        type\n    );\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}