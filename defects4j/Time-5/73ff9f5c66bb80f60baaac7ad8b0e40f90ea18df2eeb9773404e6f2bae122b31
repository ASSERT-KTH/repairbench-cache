{
    "generation": "    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     * \n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n\n        // Calculate total milliseconds from time-based fields\n        // No overflow can happen for totalMillis as the sum of all int fields converted to millis\n        // will fit within a long.\n        long totalMillis = getMillis();\n        totalMillis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n        totalMillis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n        totalMillis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n        totalMillis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n        totalMillis += ((long) getWeeks()) * DateTimeConstants.MILLIS_PER_WEEK;\n\n        // Handle years and months based on the target PeriodType\n        int years = getYears();\n        int months = getMonths();\n\n        // Calculate total months by converting years to months and adding them\n        // Use FieldUtils.safeMultiply and safeAdd to prevent int overflow during intermediate calculations\n        int totalMonths = FieldUtils.safeAdd(FieldUtils.safeMultiply(years, 12), months);\n\n        int resultYears = 0;\n        int resultMonths = 0;\n\n        if (type.isSupported(DurationFieldType.years())) {\n            // If the target PeriodType supports years, normalize months to be between 0-11\n            // and keep years and months as separate fields.\n            resultYears = totalMonths / 12;\n            resultMonths = totalMonths % 12;\n        } else if (type.isSupported(DurationFieldType.months())) {\n            // If the target PeriodType supports months but not years (or both,\n            // but we prioritize years if supported, so this path is only if years not supported),\n            // then convert all years into months and combine into the months field.\n            resultMonths = totalMonths;\n        }\n        // If the target PeriodType supports neither years nor months,\n        // resultYears and resultMonths will remain 0, effectively discarding\n        // the years/months component from the original period, which is consistent\n        // with how PeriodType restricts the presence of fields.\n\n        // Construct the new Period. The constructor with explicit field arguments\n        // will take the determined years, months, and the combined totalMillis.\n        // It will then distribute the `totalMillis` into the appropriate\n        // time-based fields (weeks, days, hours, minutes, seconds, milliseconds)\n        // according to the specified `PeriodType`.\n        return new Period(\n            resultYears,\n            resultMonths,\n            0, // weeks field value is handled by totalMillis\n            0, // days field value is handled by totalMillis\n            0, // hours field value is handled by totalMillis\n            0, // minutes field value is handled by totalMillis\n            0, // seconds field value is handled by totalMillis\n            totalMillis, // the remaining milliseconds from time-based fields\n            type,\n            ISOChronology.getInstanceUTC()\n        );\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}