{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n\n    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n\n    int years = getYears();\n    int months = getMonths();\n\n    // normalize years/months always, regardless of whether years/months are supported by the target type\n    int totalMonths = FieldUtils.safeAdd(FieldUtils.safeMultiply(years, 12), months);\n\n    years = 0; months = 0;\n    // If input had years or months, then recompute split according to presence of support\n    if (totalMonths != 0) {\n        boolean supportsYears = type.isSupported(DurationFieldType.years());\n        boolean supportsMonths = type.isSupported(DurationFieldType.months());\n        if (supportsYears && supportsMonths) {\n            years = totalMonths / 12;\n            months = totalMonths % 12;\n        } else if (supportsYears && !supportsMonths) {\n            years = totalMonths / 12;\n            months = totalMonths % 12;\n            // fold leftover months into years as fractional years, or ignore?\n            // But since months not supported, fold all months into years\n            // Actually, since months not supported, treat all as years\n            // treat as totalMonths / 12 years, with remainder months unsupported, so included in years as fraction\n            // but since period fields are int, better to fold everything to years\n            years = totalMonths / 12;\n            // possible fractional? probably safest to fold residual months into years as integer division only\n            // but since months unsupported, better to convert everything to months or years+months swapped above\n            // For now, fold all into years\n            // months will remain zero\n            months = 0;\n        } else if (!supportsYears && supportsMonths) {\n            // fold all into months only\n            years = 0;\n            months = totalMonths;\n        } else { // neither supported\n            if (totalMonths != 0) {\n                throw new UnsupportedOperationException(\"PeriodType does not support years or months\");\n            }\n        }\n        if (years != 0) {\n            result = result.withYears(years);\n        }\n        if (months != 0) {\n            result = result.withMonths(months);\n        }\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}