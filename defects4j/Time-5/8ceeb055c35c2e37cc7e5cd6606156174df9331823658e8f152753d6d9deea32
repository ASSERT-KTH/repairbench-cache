{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n    // Capture the original years and months\n    int years = getYears();\n    int months = getMonths();\n    // Sum up all the \"lower\" fields into milliseconds\n    long totalMillis = getMillis();\n    totalMillis += (long)getSeconds() * DateTimeConstants.MILLIS_PER_SECOND;\n    totalMillis += (long)getMinutes() * DateTimeConstants.MILLIS_PER_MINUTE;\n    totalMillis += (long)getHours()   * DateTimeConstants.MILLIS_PER_HOUR;\n    totalMillis += (long)getDays()    * DateTimeConstants.MILLIS_PER_DAY;\n    totalMillis += (long)getWeeks()   * DateTimeConstants.MILLIS_PER_WEEK;\n    // Determine what the target type supports\n    boolean supportY = type.isSupported(DurationFieldType.years());\n    boolean supportM = type.isSupported(DurationFieldType.months());\n    // Normalize or merge years/months according to support\n    if (years != 0 || months != 0) {\n        if (supportY && supportM) {\n            // split months into years + remainder\n            int normYears  = FieldUtils.safeAdd(years, months / 12);\n            int normMonths = months % 12;\n            years  = normYears;\n            months = normMonths;\n        } else if (supportY) {\n            // convert all months into years (must divide evenly)\n            int extra = months / 12;\n            int rem   = months % 12;\n            int normYears = FieldUtils.safeAdd(years, extra);\n            if (rem != 0) {\n                throw new UnsupportedOperationException(\n                    \"Cannot normalize months into years for type \" + type);\n            }\n            years  = normYears;\n            months = 0;\n        } else if (supportM) {\n            // convert all years into months\n            int normMonths = FieldUtils.safeAdd(\n                FieldUtils.safeMultiply(years, 12), months);\n            years  = 0;\n            months = normMonths;\n        } else {\n            // neither years nor months supported\n            throw new UnsupportedOperationException(\n                \"Fields 'years' and 'months' not supported by PeriodType \" + type);\n        }\n    }\n    // Decompose the remaining milliseconds into the lower fields\n    long rem = totalMillis;\n    int w = 0, d = 0, h = 0, mi = 0, s = 0, ms = 0;\n    if (type.isSupported(DurationFieldType.weeks())) {\n        w   = (int)(rem / DateTimeConstants.MILLIS_PER_WEEK);\n        rem = rem - (long)w * DateTimeConstants.MILLIS_PER_WEEK;\n    }\n    if (type.isSupported(DurationFieldType.days())) {\n        d   = (int)(rem / DateTimeConstants.MILLIS_PER_DAY);\n        rem = rem - (long)d * DateTimeConstants.MILLIS_PER_DAY;\n    }\n    if (type.isSupported(DurationFieldType.hours())) {\n        h   = (int)(rem / DateTimeConstants.MILLIS_PER_HOUR);\n        rem = rem - (long)h * DateTimeConstants.MILLIS_PER_HOUR;\n    }\n    if (type.isSupported(DurationFieldType.minutes())) {\n        mi  = (int)(rem / DateTimeConstants.MILLIS_PER_MINUTE);\n        rem = rem - (long)mi * DateTimeConstants.MILLIS_PER_MINUTE;\n    }\n    if (type.isSupported(DurationFieldType.seconds())) {\n        s   = (int)(rem / DateTimeConstants.MILLIS_PER_SECOND);\n        rem = rem - (long)s * DateTimeConstants.MILLIS_PER_SECOND;\n    }\n    if (type.isSupported(DurationFieldType.millis())) {\n        ms = (int) rem;\n        rem = 0;\n    }\n    // Build and return the normalized period\n    return new Period(years, months, w, d, h, mi, s, ms, type);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}