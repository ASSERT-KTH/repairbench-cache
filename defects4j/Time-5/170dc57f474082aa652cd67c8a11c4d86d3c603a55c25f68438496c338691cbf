{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n\n    // If years or months are present and not supported by the PeriodType,\n    // they must be converted to months and added together.\n    int years = getYears();\n    int months = getMonths();\n    int totalMonths = FieldUtils.safeAdd(months, FieldUtils.safeMultiply(years, 12));\n    int weeks = getWeeks();\n    int days = getDays();\n    int hours = getHours();\n    int minutes = getMinutes();\n    int seconds = getSeconds();\n    int millis = getMillis();\n\n    // Now, collapse all time fields into millis\n    long totalMillis = millis;\n    totalMillis += ((long) seconds) * DateTimeConstants.MILLIS_PER_SECOND;\n    totalMillis += ((long) minutes) * DateTimeConstants.MILLIS_PER_MINUTE;\n    totalMillis += ((long) hours) * DateTimeConstants.MILLIS_PER_HOUR;\n    totalMillis += ((long) days) * DateTimeConstants.MILLIS_PER_DAY;\n    totalMillis += ((long) weeks) * DateTimeConstants.MILLIS_PER_WEEK;\n\n    // Now, re-expand fields according to 'type'\n    int[] values = new int[type.size()];\n\n    // months and higher handled specially\n    int idx;\n    if (type.isSupported(DurationFieldType.years())) {\n        int newYears = totalMonths / 12;\n        values[type.indexOf(DurationFieldType.years())] = newYears;\n        totalMonths = totalMonths % 12;\n    } else if (totalMonths != 0 && type.isSupported(DurationFieldType.months())) {\n        // Just pass all as months\n        // do nothing here, handled below\n    } else if (totalMonths != 0) {\n        // Type does not support years or months, throw\n        throw new UnsupportedOperationException(\"Field is not supported\");\n    }\n\n    if (type.isSupported(DurationFieldType.months())) {\n        idx = type.indexOf(DurationFieldType.months());\n        values[idx] = totalMonths;\n    } else if (totalMonths != 0) {\n        // If we have months, but not supported, throw\n        throw new UnsupportedOperationException(\"Field is not supported\");\n    }\n\n    // Now assign the rest, from weeks downward, using the period\n    long remMillis = totalMillis;\n    if (type.isSupported(DurationFieldType.weeks())) {\n        idx = type.indexOf(DurationFieldType.weeks());\n        values[idx] = (int) (remMillis / DateTimeConstants.MILLIS_PER_WEEK);\n        remMillis = remMillis % DateTimeConstants.MILLIS_PER_WEEK;\n    }\n    if (type.isSupported(DurationFieldType.days())) {\n        idx = type.indexOf(DurationFieldType.days());\n        values[idx] = (int) (remMillis / DateTimeConstants.MILLIS_PER_DAY);\n        remMillis = remMillis % DateTimeConstants.MILLIS_PER_DAY;\n    }\n    if (type.isSupported(DurationFieldType.hours())) {\n        idx = type.indexOf(DurationFieldType.hours());\n        values[idx] = (int) (remMillis / DateTimeConstants.MILLIS_PER_HOUR);\n        remMillis = remMillis % DateTimeConstants.MILLIS_PER_HOUR;\n    }\n    if (type.isSupported(DurationFieldType.minutes())) {\n        idx = type.indexOf(DurationFieldType.minutes());\n        values[idx] = (int) (remMillis / DateTimeConstants.MILLIS_PER_MINUTE);\n        remMillis = remMillis % DateTimeConstants.MILLIS_PER_MINUTE;\n    }\n    if (type.isSupported(DurationFieldType.seconds())) {\n        idx = type.indexOf(DurationFieldType.seconds());\n        values[idx] = (int) (remMillis / DateTimeConstants.MILLIS_PER_SECOND);\n        remMillis = remMillis % DateTimeConstants.MILLIS_PER_SECOND;\n    }\n    if (type.isSupported(DurationFieldType.millis())) {\n        idx = type.indexOf(DurationFieldType.millis());\n        values[idx] = (int) remMillis;\n    } else if (remMillis != 0) {\n        throw new UnsupportedOperationException(\"Field is not supported\");\n    }\n\n    return new Period(values, type);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}