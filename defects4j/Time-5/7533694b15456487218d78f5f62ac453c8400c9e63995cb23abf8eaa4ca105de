{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n    int years = getYears();\n    int months = getMonths();\n    \n    // Handle periods with only months and/or years specially for types without years.\n    if ((years != 0 || months != 0) && type.isSupported(DurationFieldType.months()) && !type.isSupported(DurationFieldType.years())) {\n        // Collapse years to months and create a new period in specified period type.\n        int totalMonths = FieldUtils.safeAdd(months, FieldUtils.safeMultiply(years, 12));\n        // Build array of 8 values for all supported fields (years, months, weeks, days, hours, minutes, seconds, millis)\n        int[] values = new int[8];\n        values[1] = totalMonths; // months\n        values[2] = getWeeks();\n        values[3] = getDays();\n        values[4] = getHours();\n        values[5] = getMinutes();\n        values[6] = getSeconds();\n        values[7] = getMillis();\n        // Only use the fields supported in the input period type\n        int[] resultValues = new int[type.size()];\n        for (int i = 0; i < type.size(); i++) {\n            DurationFieldType t = type.getFieldType(i);\n            int idx = ISOChronology.getInstanceUTC().period().indexOf(t);\n            if (idx >= 0) {\n                resultValues[i] = values[idx];\n            } else {\n                // Shouldn't reach here per construction\n                resultValues[i] = 0;\n            }\n        }\n        return new Period(resultValues, type);\n    }\n\n    // Fallback to standard normalization\n    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n    if (years != 0 || months != 0) {\n        if (!type.isSupported(DurationFieldType.years()) && !type.isSupported(DurationFieldType.months())) {\n            // we cannot store years/months in this period type\n            if (years != 0 || months != 0) {\n                throw new UnsupportedOperationException(\"Field is not supported\");\n            }\n        }\n        int normYears = years;\n        int normMonths = months;\n        if (type.isSupported(DurationFieldType.years()) && type.isSupported(DurationFieldType.months())) {\n            normYears = FieldUtils.safeAdd(normYears, normMonths / 12);\n            normMonths = normMonths % 12;\n            if (normYears != 0) {\n                result = result.withYears(normYears);\n            }\n            if (normMonths != 0) {\n                result = result.withMonths(normMonths);\n            }\n        } else if (type.isSupported(DurationFieldType.years())) {\n            normYears = FieldUtils.safeAdd(normYears, normMonths / 12);\n            if (normYears != 0) {\n                result = result.withYears(normYears);\n            }\n            if ((normMonths % 12) != 0) {\n                throw new UnsupportedOperationException(\"Field is not supported\");\n            }\n        } else if (type.isSupported(DurationFieldType.months())) {\n            int totalMonths = FieldUtils.safeAdd(normMonths, FieldUtils.safeMultiply(normYears, 12));\n            if (totalMonths != 0) {\n                result = result.withMonths(totalMonths);\n            }\n        } else {\n            if (normYears != 0 || normMonths != 0) {\n                throw new UnsupportedOperationException(\"Field is not supported\");\n            }\n        }\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}