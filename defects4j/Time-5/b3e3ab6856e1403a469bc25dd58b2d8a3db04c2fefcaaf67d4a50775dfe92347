{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n\n    int years = getYears();\n    int months = getMonths();\n    int weeks = getWeeks();\n    int days = getDays();\n    int hours = getHours();\n    int minutes = getMinutes();\n    int seconds = getSeconds();\n    int millis = getMillis();\n\n    // If Years and Months fields are not supported, but are non-zero, collapse them into months\n    if ((years != 0 || months != 0) &&\n        (!type.isSupported(DurationFieldType.years()) || !type.isSupported(DurationFieldType.months()))) {\n\n        // If years field is supported but months is not, or neither is supported\n        if (!type.isSupported(DurationFieldType.years()) && type.isSupported(DurationFieldType.months())) {\n            // All in months\n            months = FieldUtils.safeAdd(months, FieldUtils.safeMultiply(years, 12));\n            years = 0;\n        } else if (!type.isSupported(DurationFieldType.years()) && !type.isSupported(DurationFieldType.months())) {\n            // Months cannot be represented at all, fall through to collapsing into lower fields\n            throw new UnsupportedOperationException(\"Field is not supported\");\n        } else if (type.isSupported(DurationFieldType.years()) && !type.isSupported(DurationFieldType.months())) {\n            // months cannot be represented but years can\n            throw new UnsupportedOperationException(\"Field is not supported\");\n        }\n        // else: both supported, handled below\n    }\n\n    // If weeks are not supported, collapse to days\n    if (weeks != 0 && !type.isSupported(DurationFieldType.weeks())) {\n        days = FieldUtils.safeAdd(days, FieldUtils.safeMultiply(weeks, 7));\n        weeks = 0;\n    }\n\n    // Compose all smaller than days to millis, use this for 'timed' part\n    long totalMillis = millis\n        + ((long) seconds) * DateTimeConstants.MILLIS_PER_SECOND\n        + ((long) minutes) * DateTimeConstants.MILLIS_PER_MINUTE\n        + ((long) hours) * DateTimeConstants.MILLIS_PER_HOUR\n        + ((long) days) * DateTimeConstants.MILLIS_PER_DAY\n        + ((long) weeks) * DateTimeConstants.MILLIS_PER_WEEK;\n\n    Period result = new Period(totalMillis, type, ISOChronology.getInstanceUTC());\n\n    // Normalize months into years if both types are supported\n    if (type.isSupported(DurationFieldType.years()) && type.isSupported(DurationFieldType.months())) {\n        years = FieldUtils.safeAdd(years, months / 12);\n        months = months % 12;\n        // Java modulus can return negative, fix for negative months\n        if (months < 0) {\n            months += 12;\n            years = FieldUtils.safeAdd(years, -1);\n        }\n        result = result.withYears(years).withMonths(months);\n    } else if (type.isSupported(DurationFieldType.months()) && !type.isSupported(DurationFieldType.years())) {\n        // Only months supported, collapse all to months\n        months = FieldUtils.safeAdd(months, FieldUtils.safeMultiply(years, 12));\n        result = result.withMonths(months);\n    } else if (years != 0 || months != 0) {\n        // period type doesn't support months or years, or only supports years but not months (irregular)\n        throw new UnsupportedOperationException(\"Field is not supported\");\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}