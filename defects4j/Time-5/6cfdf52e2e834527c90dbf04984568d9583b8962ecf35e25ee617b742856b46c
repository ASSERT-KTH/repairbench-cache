{
    "generation": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n\n    // Special handling if years or months exist, and the type does not support them.\n    int years = getYears();\n    int months = getMonths();\n\n    boolean typeHasYears = type.isSupported(DurationFieldType.years());\n    boolean typeHasMonths = type.isSupported(DurationFieldType.months());\n\n    // When years or months are present, but PeriodType doesn't support years/months,\n    // sum them together as months, or throw if not even months are supported.\n    if ((years != 0 || months != 0) && (!typeHasYears || !typeHasMonths)) {\n        if (!typeHasMonths) {\n            throw new UnsupportedOperationException(\"Field is not supported\");\n        }\n        // Convert all years to months.\n        long totalMonths = (long) years * 12 + (long) months;\n        // Compose other fields into a period\n        int weeks = getWeeks();\n        int days = getDays();\n        int hours = getHours();\n        int minutes = getMinutes();\n        int seconds = getSeconds();\n        int millis = getMillis();\n        int[] values = new int[type.size()];\n\n        for (int i = 0; i < type.size(); i++) {\n            DurationFieldType fieldType = type.getFieldType(i);\n            if (fieldType == DurationFieldType.months()) {\n                // To avoid overflow, check limits\n                if (totalMonths > Integer.MAX_VALUE || totalMonths < Integer.MIN_VALUE) {\n                    throw new ArithmeticException(\"Period months too large to be represented\");\n                }\n                values[i] = (int) totalMonths;\n            } else if (fieldType == DurationFieldType.weeks()) {\n                values[i] = weeks;\n            } else if (fieldType == DurationFieldType.days()) {\n                values[i] = days;\n            } else if (fieldType == DurationFieldType.hours()) {\n                values[i] = hours;\n            } else if (fieldType == DurationFieldType.minutes()) {\n                values[i] = minutes;\n            } else if (fieldType == DurationFieldType.seconds()) {\n                values[i] = seconds;\n            } else if (fieldType == DurationFieldType.millis()) {\n                values[i] = millis;\n            } // years are not supported\n        }\n        return new Period(values, type);\n    }\n\n    // Proceed as normal if years/months are both supported or not present\n    long millis = getMillis(); // No overflow can happen, even with Integer.MAX_VALUEs\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n    if (years != 0 || months != 0) {\n        years = FieldUtils.safeAdd(years, months / 12);\n        months = months % 12;\n        if (years != 0) {\n            result = result.withYears(years);\n        }\n        if (months != 0) {\n            result = result.withMonths(months);\n        }\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}