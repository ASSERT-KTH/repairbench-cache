{
    "generation": "import org.joda.time.DateTimeConstants;\nimport org.joda.time.DateTimeUtils;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.PeriodType;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.field.FieldUtils;\n\n    /**\n     * Normalizes this period using standard rules, assuming a 12 month year,\n     * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n     * providing control over how the result is split into fields.\n     * <p>\n     * This method allows you to normalize a period.\n     * However to achieve this it makes the assumption that all years are\n     * 12 months, all weeks are 7 days, all days are 24 hours,\n     * all hours are 60 minutes and all minutes are 60 seconds. This is not\n     * true when daylight savings time is considered, and may also not be true\n     * for some chronologies. However, it is included as it is a useful operation\n     * for many applications and business rules.\n     * <p>\n     * If the period contains years or months, then the months will be\n     * normalized to be between 0 and 11. The days field and below will be\n     * normalized as necessary, however this will not overflow into the months\n     * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n     * But a period of 1 month 40 days will remain as 1 month 40 days.\n     * <p>\n     * The PeriodType parameter controls how the result is created. It allows\n     * you to omit certain fields from the result if desired. For example,\n     * you may not want the result to include weeks, in which case you pass\n     * in <code>PeriodType.yearMonthDayTime()</code>.\n     *\n     * @param type  the period type of the new period, null means standard type\n     * @return a normalized period equivalent to this period\n     * @throws ArithmeticException if any field is too large to be represented\n     * @throws UnsupportedOperationException if this period contains non-zero\n     *  years or months but the specified period type does not support them\n     * @since 1.5\n     */\n    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n\n        // Capture original values\n        int iYears = getYears();\n        int iMonths = getMonths();\n        int iWeeks = getWeeks();\n        int iDays = getDays();\n        int iHours = getHours();\n        int iMinutes = getMinutes();\n        int iSeconds = getSeconds();\n        int iMillis = getMillis();\n\n        // Calculate total millis from lower fields (weeks to millis) using safe arithmetic\n        long totalMillis = iMillis;\n        // FieldUtils potentially throws ArithmeticException, which is declared\n        totalMillis = FieldUtils.safeAdd(totalMillis, FieldUtils.safeMultiply((long) iSeconds, DateTimeConstants.MILLIS_PER_SECOND));\n        totalMillis = FieldUtils.safeAdd(totalMillis, FieldUtils.safeMultiply((long) iMinutes, DateTimeConstants.MILLIS_PER_MINUTE));\n        totalMillis = FieldUtils.safeAdd(totalMillis, FieldUtils.safeMultiply((long) iHours, DateTimeConstants.MILLIS_PER_HOUR));\n        totalMillis = FieldUtils.safeAdd(totalMillis, FieldUtils.safeMultiply((long) iDays, DateTimeConstants.MILLIS_PER_DAY));\n        totalMillis = FieldUtils.safeAdd(totalMillis, FieldUtils.safeMultiply((long) iWeeks, DateTimeConstants.MILLIS_PER_WEEK));\n\n        // Create intermediate period with normalized time fields based on type and totalMillis\n        // This constructor distributes totalMillis across supported time fields (weeks down to millis)\n        // according to ISOChronology UTC rules.\n        Period result = new Period(totalMillis, type, ISOChronology.getInstanceUTC());\n\n        // Normalize and add year/month fields if present in the original period\n        // and supported by the target type\n        if (iYears != 0 || iMonths != 0) {\n            // FieldUtils potentially throws ArithmeticException, which is declared\n            long totalMonths = FieldUtils.safeAdd(iMonths, FieldUtils.safeMultiply(iYears, 12));\n            boolean yearSupported = type.isSupported(DurationFieldType.years());\n            boolean monthSupported = type.isSupported(DurationFieldType.months());\n\n            if (yearSupported) {\n                // FieldUtils potentially throws ArithmeticException, which is declared\n                int finalYears = FieldUtils.safeToInt(totalMonths / 12);\n                result = result.withYears(finalYears); // Safe: year field is supported by type\n                \n                // If months are also supported, set the remainder months field\n                if (monthSupported) {\n                    // FieldUtils potentially throws ArithmeticException, which is declared\n                    int finalMonths = FieldUtils.safeToInt(totalMonths % 12);\n                    result = result.withMonths(finalMonths); // Safe: month field is supported by type\n                } else {\n                    // If months not supported, the remainder (totalMonths % 12) is effectively discarded\n                    // as per the PeriodType contract (omitting unsupported fields).\n                    // We must check if this discard operation is valid according to the spec.\n                    // The spec says \"throws UnsupportedOperationException if this period contains non-zero\n                    // years or months but the specified period type does not support them\".\n                    // Here, years are supported, so we don't throw, even if months have a remainder.\n                }\n            } else if (monthSupported) { // Years not supported, but months is\n                // FieldUtils potentially throws ArithmeticException, which is declared\n                int finalMonths = FieldUtils.safeToInt(totalMonths);\n                result = result.withMonths(finalMonths); // Safe: month field is supported by type\n            } else { // Neither years nor months supported by the type\n                // As per Javadoc, throw if original period had non-zero years/months\n                // (resulting in non-zero totalMonths) but type doesn't support them.\n                if (totalMonths != 0) {\n                    throw new UnsupportedOperationException(\n                        \"Cannot normalize years or months because period type does not support either field\");\n                }\n                // If totalMonths is 0, nothing to do, result already has 0 years/months (or fields are absent)\n            }\n        }\n        // result now contains normalized weeks down to millis based on totalMillis,\n        // and normalized years/months based on totalMonths, respecting the PeriodType.\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}