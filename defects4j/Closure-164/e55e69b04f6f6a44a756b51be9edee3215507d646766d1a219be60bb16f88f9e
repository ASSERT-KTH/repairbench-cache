{
    "generation": "@Override\npublic boolean isSubtype(JSType other) {\n  if (!(other instanceof ArrowType)) {\n    return false;\n  }\n\n  ArrowType that = (ArrowType) other;\n\n  // this.returnType <: that.returnType (covariant)\n  if (!this.returnType.isSubtype(that.returnType)) {\n    return false;\n  }\n\n  // Parameter contravariance:\n  //\n  // For function subtyping, the subtype must require strictly fewer or equal parameters.\n  // For example:\n  //   function f(x) {/*...*/}\n  //   function g(x, y) {/*...*/}\n  //   f can be used where g is expected, but not vice versa.\n  // Therefore, the subtype can have >= number of required parameters,\n  // and for each parameter present in the supertype, the subtype's parameter type must be *supertype* of the required type,\n  // i.e., parameter types are contravariant.\n\n  Node thisParam = parameters.getFirstChild();\n  Node thatParam = that.parameters.getFirstChild();\n\n  // Count the number of non-optional/non-varargs parameters for both signatures\n  int thisRequired = 0, thatRequired = 0;\n  for (Node n = thisParam; n != null; n = n.getNext()) {\n    if (!n.isOptionalArg() && !n.isVarArgs()) {\n      thisRequired++;\n    }\n  }\n  for (Node n = thatParam; n != null; n = n.getNext()) {\n    if (!n.isOptionalArg() && !n.isVarArgs()) {\n      thatRequired++;\n    }\n  }\n\n  // If the subtype (this) expects more required parameters than the supertype (that), not a subtype.\n  if (thisRequired > thatRequired) {\n    return false;\n  }\n\n  thisParam = parameters.getFirstChild();\n  thatParam = that.parameters.getFirstChild();\n\n  while (thatParam != null) {\n    // If we run out of subtype params, supertype must allow var_args or optional\n    if (thisParam == null) {\n      if (!thatParam.isOptionalArg() && !thatParam.isVarArgs()) {\n        // 'that' requires a param that 'this' does not supply\n        return false;\n      }\n      // Otherwise, skip missing subtype param: thisParam stays null, thatParam advances\n      thatParam = thatParam.getNext();\n      continue;\n    }\n\n    JSType thisParamType = thisParam.getJSType();\n    JSType thatParamType = thatParam.getJSType();\n\n    // Contravariant: thatParamType (of supertype) <= thisParamType (of subtype)\n    if (thisParamType != null && thatParamType != null &&\n        !thatParamType.isSubtype(thisParamType)) {\n      return false;\n    }\n\n    boolean thisIsVarArgs = thisParam.isVarArgs();\n    boolean thatIsVarArgs = thatParam.isVarArgs();\n\n    // If both are varargs, done\n    if (thisIsVarArgs && thatIsVarArgs) {\n      break;\n    }\n\n    // Only advance if not varargs, otherwise, one remains at varargs param\n    if (!thisIsVarArgs) {\n      thisParam = thisParam.getNext();\n    }\n    if (!thatIsVarArgs) {\n      thatParam = thatParam.getNext();\n    }\n  }\n\n  // If the 'this' type has more required params than 'that', we already checked above.\n  // So, trailing params in 'this' must be optional or varargs.\n  while (thisParam != null) {\n    if (!thisParam.isOptionalArg() && !thisParam.isVarArgs()) {\n      return false;\n    }\n    thisParam = thisParam.getNext();\n  }\n\n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}