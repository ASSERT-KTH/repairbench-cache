{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        // Check for invalid inputs or impossible search conditions\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        // Handle empty string search\n        if (strLen == 0) {\n            // Per JDK String.indexOf behavior, empty string is found at startIndex if valid\n            return startIndex <= size ? startIndex : size; // Adjusted to match JDK behavior slightly more closely if needed, original was just return startIndex;\n                                                            // Sticking to original behavior for minimal change:\n            // return startIndex; // Original line - let's keep it if tests pass\n            // Let's re-evaluate based on String.indexOf(\"\", idx): it returns idx if idx <= length, else length.\n            // Our StrBuilder size is analogous to length. So, if startIndex > size, we should return size.\n            // The check 'startIndex >= size' above handles cases where startIndex is too large initially.\n            // If startIndex == size, returning startIndex (which is size) is correct.\n            return startIndex; // Let's stick to this for minimal change, seems logically sound within the method's context.\n        }\n        // Handle single character search using optimized method\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        // Check if the search string is longer than the remaining content\n        if (strLen > size - startIndex) { // More precise check than just strLen > size\n             return -1;\n        }\n        // Check if the search string is longer than the total content size (already somewhat covered, but explicit)\n        if (strLen > size) { // This check seems redundant given the one above, but harmless\n             return -1;\n        }\n\n        char[] thisBuf = buffer;\n        // Calculate the maximum possible starting index for the search string\n        // The last possible start index is size - strLen\n        int loopEnd = size - strLen; \n        \n        outer:\n        // Iterate through possible start indices from startIndex up to loopEnd\n        for (int i = startIndex; i <= loopEnd; i++) {\n            // Compare the characters of str with the characters in buffer starting at index i\n            for (int j = 0; j < strLen; j++) {\n                // If any character doesn't match, continue to the next potential start index\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            // If the inner loop completed without mismatch, we found the string\n            return i;\n        }\n        \n        // String not found\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}