{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index clamped to 0, \n     *                    or to size if searching for an empty string past the end.\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        // Clamp startIndex to 0, as negative start indices are treated as 0\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n\n        if (str == null) {\n            return -1;\n        }\n\n        int strLen = str.length();\n\n        // Handle empty string search.\n        // An empty string is always found at any valid startIndex.\n        // If startIndex is beyond the current content (size), it's found at 'size'.\n        if (strLen == 0) {\n            return (startIndex > size ? size : startIndex);\n        }\n\n        // For non-empty string search:\n        // If startIndex is at or beyond the current content (size), no match is possible.\n        if (startIndex >= size) {\n            return -1;\n        }\n\n        // If the string to find is longer than the StrBuilder's current content, no match is possible.\n        if (strLen > size) {\n            return -1;\n        }\n\n        // Optimization for single character search\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        \n        char[] thisBuf = buffer;\n        // The maximum possible starting index for a match.\n        // If a match starts at this index, its last character is at (size - strLen) + strLen - 1 = size - 1,\n        // which is the last valid character in the StrBuilder's content.\n        int maxSearchIndex = size - strLen;\n\n        outer:\n        // Iterate from startIndex up to and including maxSearchIndex\n        for (int i = startIndex; i <= maxSearchIndex; i++) {\n            // Check if the substring of thisBuf starting at i matches str\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer; // Mismatch, try next starting position\n                }\n            }\n            return i; // Full match found\n        }\n        return -1; // No match found\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}