{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        // Validate startIndex\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n\n        // Check arguments\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n\n        int strLen = str.length();\n\n        // Empty string is always found at startIndex\n        if (strLen == 0) {\n            // Following JDK String.indexOf semantics\n            return startIndex;\n        }\n\n        // Cannot find string if it's longer than the remaining buffer\n        if (strLen > size) {\n             return -1;\n        }\n\n        // Single character search can be delegated to indexOf(char, int)\n        // which might be optimized\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n\n        // Calculate the maximum possible starting index for the search string\n        // The loop should go up to (size - strLen) inclusive\n        int loopEnd = size - strLen;\n\n        // If startIndex is already past the maximum possible starting index,\n        // the string cannot be found.\n        if (startIndex > loopEnd) {\n            return -1;\n        }\n\n        char[] thisBuf = buffer; // Use local variable for potential performance improvement\n\n        // Naive string search (could be optimized with KMP or Boyer-Moore)\n        outer:\n        for (int i = startIndex; i <= loopEnd; i++) {\n            for (int j = 0; j < strLen; j++) {\n                // Check characters. Accessing thisBuf[i + j] is safe because:\n                // max(i) = loopEnd = size - strLen\n                // max(j) = strLen - 1\n                // max(i + j) = (size - strLen) + (strLen - 1) = size - 1\n                // which is the last valid index in the logical buffer content [0, size - 1]\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    // Mismatch found, continue search from the next possible starting index i\n                    continue outer;\n                }\n            }\n            // Inner loop completed without mismatch, pattern found.\n            return i;\n        }\n\n        // String not found in the specified range\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}