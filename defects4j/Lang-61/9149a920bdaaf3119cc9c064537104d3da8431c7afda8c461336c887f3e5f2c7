{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (str == null || startIndex >= size) {\n            return -1;\n        }\n        int strLen = str.length();\n        if (strLen == 1) {\n            // Rely on correct indexOf(char, int) implementation\n            return indexOf(str.charAt(0), startIndex);\n        }\n        if (strLen == 0) {\n            // Empty string search: returns startIndex if startIndex < size (due to earlier check)\n            return startIndex;\n        }\n        // Check if the substring is longer than the remaining builder content\n        // This also implicitly handles strLen > size when startIndex is 0.\n        if (strLen > size - startIndex) {\n             // We check against size - startIndex because we only care about the part\n             // of the buffer from startIndex onwards.\n             // Note: if strLen > size, this condition will also be true for startIndex=0.\n            return -1;\n        }\n        // If we got here: str != null, strLen > 1, 0 <= startIndex < size, strLen <= size - startIndex\n\n        char[] thisBuf = buffer;\n        // The maximum index in the outer loop is 'size - strLen'\n        // This ensures that the inner loop access 'thisBuf[i + j]' does not go\n        // beyond 'thisBuf[size - 1]', as max(i) = size - strLen and max(j) = strLen - 1,\n        // so max(i + j) = (size - strLen) + (strLen - 1) = size - 1.\n        int loopLimit = size - strLen; \n        outer:\n        for (int i = startIndex; i <= loopLimit; i++) {\n            for (int j = 0; j < strLen; j++) {\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer; // Mismatch, advance the starting position 'i'\n                }\n            }\n            // If the inner loop completes, we found a match\n            return i;\n        }\n        // Substring not found\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}