{
    "generation": "    /**\n     * Searches the string builder to find the first reference to the specified\n     * string starting searching from the given index.\n     * <p>\n     * Note that a null input string will return -1, whereas the JDK throws an exception.\n     * \n     * @param str  the string to find, null returns -1\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the string, or -1 if not found\n     */\n    public int indexOf(String str, int startIndex) {\n        // Adjust startIndex to be non-negative.\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n\n        // Handle null search string.\n        if (str == null) {\n            return -1;\n        }\n\n        int strLen = str.length();\n\n        // Handle empty search string.\n        // An empty string is always found at startIndex, even if startIndex is beyond the current content size.\n        // This matches JDK String.indexOf(\"\", x) behavior which returns x.\n        if (strLen == 0) {\n            return startIndex;\n        }\n\n        // At this point, str is not null and strLen > 0.\n\n        // If startIndex is beyond the current actual content size, no match is possible for a non-empty string.\n        if (startIndex >= size) {\n            return -1;\n        }\n        \n        // Optimization for single character search.\n        // Delegates to the existing indexOf(char, int) method, which is assumed to be correct.\n        if (strLen == 1) {\n            return indexOf(str.charAt(0), startIndex);\n        }\n        \n        // Calculate the maximum possible starting index within the StrBuilder's current content\n        // where 'str' could begin.\n        // If `size - strLen` is negative, it means 'str' is longer than the StrBuilder's content,\n        // so no match is possible.\n        int limit = size - strLen;\n\n        // If the calculated limit is negative (meaning strLen > size),\n        // or if the startIndex is already beyond this limit (meaning not enough characters remaining\n        // from startIndex to form 'str'), then 'str' cannot be found.\n        if (limit < 0 || startIndex > limit) {\n             return -1;\n        }\n\n        char[] thisBuf = buffer; // Get a reference to the internal character array.\n        \n        // Outer loop: Iterate through all possible starting positions 'i' for a match.\n        // 'i' ranges from 'startIndex' up to 'limit' (inclusive).\n        outer:\n        for (int i = startIndex; i <= limit; i++) {\n            // Inner loop: Compare characters of 'str' with the corresponding characters in 'thisBuf'\n            // starting from the current 'i'.\n            for (int j = 0; j < strLen; j++) {\n                // If a character mismatch is found, this 'i' is not a match.\n                // Continue to the next possible starting position 'i' (using 'outer' label).\n                // The access thisBuf[i + j] is safe because:\n                // Max value of i is 'limit' which is 'size - strLen'.\n                // Max value of j is 'strLen - 1'.\n                // So, max index accessed is (size - strLen) + (strLen - 1) = size - 1.\n                // This index is always within the bounds of the active content [0, size-1],\n                // preventing ArrayIndexOutOfBoundsException.\n                if (str.charAt(j) != thisBuf[i + j]) {\n                    continue outer;\n                }\n            }\n            // If the inner loop completes, it means all characters of 'str' matched.\n            // Return the current starting index 'i'.\n            return i;\n        }\n        // If the outer loop completes without finding any match, return -1.\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}