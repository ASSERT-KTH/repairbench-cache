{
    "generation": "/**\n * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n * \n * @param binaryData\n *            Array containing binary data to encode.\n * @param isChunked\n *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n * @param urlSafe\n *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n * @param maxResultSize\n *            The maximum result size to accept.\n * @return Base64-encoded data.\n * @throws IllegalArgumentException\n *             Thrown when the input array needs an output array bigger than maxResultSize\n * @since 1.4\n */\npublic static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n\n    // Only apply CHUNK_SEPARATOR if actually chunking, otherwise we get incorrect length calculation\n    long len = isChunked ? \n               getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR) : \n               (binaryData.length * 4L) / 3 + 3 & ~3;  // Simple Base64 length without chunking\n               \n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            len +\n            \") than the specified maxium size of \" +\n            maxResultSize);\n    }\n            \n    Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}