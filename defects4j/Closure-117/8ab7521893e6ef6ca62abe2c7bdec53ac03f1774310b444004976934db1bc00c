{
    "generation": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n    // 1. Get the JSType of the node n.\n    JSType type = getJSType(n);\n\n    // Apply dereferencing if requested and type is known.\n    if (type != null && dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    // If type information is available, try to get the best name based on it.\n    if (type != null) {\n      // 2. If the type itself has a clear, readable name (instance of a constructor,\n      //    or a function prototype), use that first. This is often the most\n      //    intuitive name for the programmer.\n      ObjectType typeObj = type.toObjectType();\n      if (type.isFunctionPrototypeType() ||\n          (typeObj != null && typeObj.getConstructor() != null)) {\n        // This correctly returns \"C2\" for the node this.c2_ in testIssue1047.\n        return type.toString();\n      }\n    }\n\n    // 3. If the node represents a property access (GETPROP),\n    //    and the property was *inherited*, provide the qualified name\n    //    showing where it was inherited from (e.g., \"Super.prototype.prop\").\n    //    This provides more context but should only be used if step 2 didn't apply\n    //    (e.g., for primitive types or function types resulting from the GETPROP).\n    if (n.isGetProp()) {\n      JSType ownerNodeType = getJSType(n.getFirstChild());\n      if (ownerNodeType != null) {\n        ObjectType objectType = ownerNodeType.dereference(); // Type of the object being accessed\n        if (objectType != null) {\n          String propName = n.getLastChild().getString();\n          ObjectType definingType = null; // Type where propName is defined\n          boolean isInherited = false; // Was propName inherited?\n\n          if (objectType.getConstructor() != null &&\n              objectType.getConstructor().isInterface()) {\n            // Interface case: find defining interface\n            definingType = FunctionType.getTopDefiningInterface(objectType, propName);\n            // Check if the property was defined on a *different* interface than the object's direct type.\n            isInherited = definingType != null && !objectType.equals(definingType);\n          } else {\n            // Class/Object case: check instance, then prototype chain\n            ObjectType currentType = objectType;\n            if (currentType.hasOwnProperty(propName)) {\n              // Property found directly on the object's type. Not considered inherited for this purpose.\n              definingType = currentType;\n              isInherited = false;\n            } else {\n              // Look on prototypes\n              ObjectType proto = currentType.getImplicitPrototype();\n              while (proto != null) {\n                if (proto.hasOwnProperty(propName)) {\n                  isInherited = true; // Found on a prototype\n                  definingType = proto;\n                  break;\n                }\n                proto = proto.getImplicitPrototype();\n              }\n            }\n          }\n\n          // Return \"DefiningType.propName\" only if the property was inherited\n          // and the defining type has a readable name (constructor or prototype).\n          if (isInherited && definingType != null &&\n              (definingType.getConstructor() != null ||\n               definingType.isFunctionPrototypeType())) {\n            return definingType.toString() + \".\" + propName;\n          }\n        }\n      }\n    }\n\n    // 4. Fallback: Try the node's qualified name if it has one.\n    //    Useful for names like goog.ui.Component. Also handles cases where type is null.\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    }\n\n    // 5. Further fallbacks based on the type kind (if type is known).\n    if (type != null) {\n      if (type.isFunctionType()) {\n        // Avoid long signatures for unnamed function types.\n        return \"function\";\n      } else {\n        // Final fallback: the basic toString() of the type from step 1.\n        // This might be \"Object\", \"{prop: string}\", \"unknown\", etc.\n        return type.toString();\n      }\n    }\n\n    // Absolute fallback if type is null and qualified name is null.\n    return \"unknown\";\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}