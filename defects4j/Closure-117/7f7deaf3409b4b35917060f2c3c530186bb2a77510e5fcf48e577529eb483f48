{
    "generation": "  /**\n   * Given a node, get a human-readable name for the type of that node so\n   * that will be easy for the programmer to find the original declaration.\n   *\n   * For example, if SubFoo's property \"bar\" might have the human-readable\n   * name \"Foo.prototype.bar\".\n   *\n   * @param n The node.\n   * @param dereference If true, the type of the node will be dereferenced\n   *     to an Object type, if possible.\n   */\n  String getReadableJSTypeName(Node n, boolean dereference) {\n    // Get the type of the node, attempt to dereference if requested.\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n\n    // Try to get a good name from the type first.\n    // Order matters: Constructors/interfaces first, then prototypes, then nominal instances.\n    if (type.isNominalConstructorOrInterface()) {\n        // For constructor/interface types, use their reference name (e.g., \"MyClass\").\n        ObjectType objType = type.toObjectType();\n        if (objType != null && objType.hasReferenceName()) {\n            return objType.getReferenceName();\n        }\n        // Fall back to toString() if no reference name (less likely)\n        return type.toString();\n    } else if (type.isFunctionPrototypeType()) {\n        // For prototype types, toString() usually gives a good name (e.g., \"MyClass.prototype\").\n        return type.toString();\n    } else if (type.isNominalType()) {\n        // For nominal instance types (e.g., an instance of MyClass), use the reference name.\n         ObjectType objType = type.toObjectType();\n         // Check it's not a constructor/interface (already handled) and has a name.\n         if (objType != null && !objType.isConstructorOrInterface() && objType.hasReferenceName() && !objType.isUnknownType()) {\n              return objType.getReferenceName(); // e.g., \"MyClass\" for the instance type\n         }\n    } else if (type.isEnumElementType()) {\n        // For enum elements, toString() is usually best (e.g., \"MyEnum.VALUE\").\n        return type.toString();\n    }\n\n    // If the type didn't provide a good name, and we're analyzing a GETPROP,\n    // try climbing the prototype chain to find where the property was originally defined.\n    // This gives names like \"Foo.prototype.bar\".\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          // interfaces\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // If we found the object type, use its name + the property name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          // Use toString() for the object type's name (e.g., \"Foo.prototype\" or \"Foo\")\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n\n    // If we still don't have a name, fall back to the qualified name of the node, if available.\n    // This can be useful for complex expressions. (e.g., \"a.b.c\")\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    }\n\n    // If it's a function type not handled earlier (e.g., anonymous function literal),\n    // return a generic \"function\".\n    if (type.isFunctionType()) {\n      return \"function\";\n    }\n\n    // Otherwise, fall back to the default type toString(). This handles unknowns,\n    // structural types (like \"{prop: string}\"), etc.\n    return type.toString();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}