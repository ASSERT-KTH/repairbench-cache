{
    "generation": "String getReadableJSTypeName(Node n, boolean dereference) {\n\n  if (n.isGetProp()) {\n    JSType leftType = getJSType(n.getFirstChild());\n    ObjectType leftObj = leftType == null ? null : leftType.dereference();\n    if (leftObj != null) {\n      String propName = n.getLastChild().getString();\n      ObjectType definingType = null;\n      if (leftObj.getConstructor() != null &&\n          leftObj.getConstructor().isInterface()) {\n        definingType = FunctionType.getTopDefiningInterface(leftObj, propName);\n      } else {\n        ObjectType current = leftObj;\n        while (current != null && !current.hasOwnProperty(propName)) {\n          current = current.getImplicitPrototype();\n        }\n        definingType = current;\n      }\n      if (definingType != null &&\n          (definingType.getConstructor() != null ||\n           definingType.isFunctionPrototypeType())) {\n        return definingType.toString() + \".\" + propName;\n      } else {\n        // When the property is never defined, return the left expression\u2019s type.\n        // This ensures that we report \"C2\" (the declared type of this.c2_) rather than \"C3.c2_.prop\".\n        return leftObj.toString();\n      }\n    }\n  }\n\n  JSType type = getJSType(n);\n  if (dereference) {\n    ObjectType dereferenced = type.dereference();\n    if (dereferenced != null) {\n      type = dereferenced;\n    }\n  }\n  if (type.isFunctionPrototypeType() ||\n      (type.toObjectType() != null &&\n       type.toObjectType().getConstructor() != null)) {\n    return type.toString();\n  }\n  String qualifiedName = n.getQualifiedName();\n  if (qualifiedName != null) {\n    return qualifiedName;\n  } else if (type.isFunctionType()) {\n    return \"function\";\n  } else {\n    return type.toString();\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}