{
    "generation": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null\n        && rhsValue.isFunction()\n        && (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  ObjectType ownerType = getObjectSlot(ownerName);\n  if (!inferred && ownerType != null) {\n    // Only declare this as an official property if it has not been\n    // declared yet.\n    boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n    if ((!ownerType.hasOwnProperty(propName) ||\n         ownerType.isPropertyTypeInferred(propName)) &&\n        ((isExtern && !ownerType.isNativeObjectType()) ||\n         !ownerType.isInstanceType())) {\n      // If the property is undeclared or inferred, declare it now.\n      ownerType.defineDeclaredProperty(propName, valueType, n);\n    }\n  }\n\n  if (!inferred\n      || rhsValue != null && rhsValue.isFunction()) {\n    // Always declare function literal assignments to preserve function arity.\n    // Function subtyping cares about argument count, and we check\n    // that the type of the overriding function has the same argument\n    // count as the overridden function. This is especially important\n    // for inheritance patterns like\n    // Sub.prototype.method = function(arg1, arg2) {};\n    // since there is no explicit declaration of 'method', only an\n    // implicit one.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType fnOwnerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (fnOwnerType != null) {\n      JSType ownerTypeOfThis = fnOwnerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}