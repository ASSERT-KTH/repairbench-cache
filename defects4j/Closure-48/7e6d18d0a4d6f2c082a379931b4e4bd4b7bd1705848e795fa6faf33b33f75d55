{
    "generation": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n\n      // Determining type\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (rhsValue != null && rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(rhsValue.getJSType(), qVar.getType().getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType() \n            || info.hasEnumParameterType() \n            || (info.isConstant() && valueType != null && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null \n            && rhsValue.isFunction() \n            && (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) \n              && ((isExtern(ownerNode) && !ownerType.isNativeObjectType())\n                  || !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isFunction()) {\n        defineSlot(n, parent, getValueTypeForFunction(rhsValue, ownerName), true);\n      }\n    }\n\n    private boolean isExtern(Node ownerNode) {\n      return ownerNode.getJSDocInfo() != null && ownerNode.getJSDocInfo().isExtern();\n    }\n\n    private JSType getValueTypeForFunction(Node functionNode, String ownerName) {\n      JSDocInfo info = functionNode.getJSDocInfo();\n      if (info != null) {\n        return FunctionTypeBuilder.buildFunctionType(info, null, null, null);\n      }\n      FunctionType type = FunctionTypeBuilderuggestion ownersType = getObjectSlot(ownerName);\n      if (ownersType == null) {\n        return null;\n      }\n      FunctionType ownerFunctionType = ownersType.getConstructor();\n      if (ownerFunctionType != null) {\n        return ownerFunctionType;\n      }\n      return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}