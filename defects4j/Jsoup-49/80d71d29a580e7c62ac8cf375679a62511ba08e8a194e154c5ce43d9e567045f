{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        \n        // The original method doesn't handle index == -1 (for append).\n        // If append functionality was intended via index -1, uncomment the following line:\n        // if (index == -1) index = childNodes.size();\n\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            \n            // If the node is already a child of this element, we are performing a move operation.\n            if (in.parent() == this) {\n                // Get the current actual index of the node in the childNodes list.\n                // This is crucial because in.siblingIndex() might be stale if other\n                // children have been moved/inserted in previous loop iterations.\n                int oldIdx = childNodes.indexOf(in);\n                \n                // If the node was not found (e.g., already removed or an error), skip it.\n                if (oldIdx == -1) continue; \n\n                // If the node's original position was before the new insertion index,\n                // the new index effectively becomes one less after its removal.\n                // This compensates for the list shifting when the node is removed.\n                if (oldIdx < index) { \n                    index--; \n                }\n                \n                // Remove the node from its current position in this element's childNodes list.\n                childNodes.remove(oldIdx);\n                // The node is now temporarily parent-less.\n                in.parent = null; \n                \n                // Re-index remaining children from the old position onwards.\n                // This is necessary because `childNodes.remove` (for ArrayList) doesn't automatically update\n                // `siblingIndex` properties of affected Node objects.\n                reindexChildren(oldIdx); \n\n            } else if (in.parent() != null) {\n                // The node has a different parent. Remove it from there.\n                // This method (Node.removeChild) typically handles unsetting parent\n                // and re-indexing children for the *other* parent.\n                in.parent().removeChild(in);\n            }\n            \n            // Add the node to this element's childNodes list at the calculated index.\n            childNodes.add(index, in);\n            // Set the parent of the node to this element.\n            in.parent = this; \n            // Set the sibling index for the node at its new position.\n            in.siblingIndex = index; \n        }\n        \n        // After all nodes have been added/moved, re-index all children from the\n        // insertion point onwards to ensure all sibling indices are correct.\n        reindexChildren(index);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}