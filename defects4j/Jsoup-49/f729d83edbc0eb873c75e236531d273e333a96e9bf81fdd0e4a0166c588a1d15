{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n\n        // Separate children that are already in this element from those that are external or new.\n        // This is necessary because removing children that are already\n        // part of *this* element using `removeChild` (which relies on `siblingIndex`)\n        // can lead to incorrect removals if the `childNodes` list is being modified\n        // and `siblingIndex` becomes stale.\n        List<Node> childrenToMoveInternally = new ArrayList<>();\n\n        for (Node in : children) {\n            if (in.parent() != null && in.parent() != this) {\n                // If the child is from another parent, use reparentChild.\n                // This will remove it from its old parent and set its parent to 'this'.\n                // This is safe as the old parent's childNodes list is not being concurrently modified by this method.\n                reparentChild(in);\n            } else if (in.parent() == this) {\n                // If the child is already a child of 'this' element,\n                // mark it for internal movement. Its parent is already correct.\n                childrenToMoveInternally.add(in);\n            } else {\n                // If the child has no parent, simply set its parent to 'this'.\n                in.parent = this;\n            }\n        }\n\n        // Before adding the children, safely remove any children that are being moved\n        // *within* this element from their current positions.\n        // Use `remove(Object o)` from ArrayList, which iterates to find the object,\n        // thus avoiding issues with stale `siblingIndex` that `removeChild` might encounter\n        // when operating on the same list being modified.\n        for (Node child : childrenToMoveInternally) {\n            childNodes.remove(child);\n        }\n\n        // Now, add all children (both internally moved and externally sourced/new)\n        // at the specified index.\n        // Iterate backwards over the original 'children' array to ensure the correct\n        // order when inserting at a fixed index (e.g., add(0, B), then add(0, A) results in [A, B, ...]).\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n            childNodes.add(index, in);\n        }\n\n        // Finally, reindex all children from the insertion point onwards to update their siblingIndex.\n        reindexChildren(index);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}