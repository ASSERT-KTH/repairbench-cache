{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n\n        // Iterate in reverse to ensure that adding at a fixed 'index' works correctly\n        // (i.e., new children are added at the beginning of the insertion block).\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n\n            // If the node is already a child of this element,\n            // we remove it directly from the childNodes list.\n            // This prevents Node.reparentChild from calling Node.removeChild,\n            // which would trigger multiple, potentially conflicting, reindexChildren calls\n            // on 'this' element due to setParentNode(null) and removeChild's own reindexing.\n            if (in.parent() == this) {\n                childNodes.remove(in); // Remove by object, no internal reindexing from ArrayList\n                // Parent relationship already is 'this', no need to set.\n            } else {\n                // For nodes coming from other parents or new nodes,\n                // reparentChild correctly handles detaching from old parent and setting new parent.\n                // Any reindexChildren calls triggered by reparentChild/setParentNode\n                // on other parents will not affect this Element's childNodes list's indices directly.\n                reparentChild(in);\n            }\n            // Add the node at the specified index.\n            childNodes.add(index, in);\n        }\n        // After all children are added, reindex them all from the insertion point.\n        // This ensures all siblingIndexes are correct and consistent.\n        reindexChildren(index);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}