{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n\n            // If the node 'in' is already a child of 'this' (the current element),\n            // it needs to be removed from its current position before being re-added at 'index'.\n            // This prevents duplicates and correctly moves the node.\n            if (in.parent() == this) {\n                int currentPos = in.siblingIndex();\n                // Ensure the node is actually in the list at the reported siblingIndex.\n                // This check protects against potential inconsistencies, though siblingIndex should be reliable.\n                if (currentPos >= 0 && currentPos < childNodes.size() && childNodes.get(currentPos) == in) {\n                    childNodes.remove(currentPos);\n                    // If the node was removed from a position *before* the target insertion index,\n                    // the target index effectively shifts left by one. Adjust 'index' accordingly.\n                    if (currentPos < index) {\n                        index--;\n                    }\n                }\n            }\n            // Reparent the child (sets its parent reference).\n            // This method does not remove the child from its old parent if the old parent is 'this',\n            // which is why the explicit removal logic above is necessary for 'move' operations.\n            reparentChild(in);\n            // Add the child at the specified (and potentially adjusted) index.\n            childNodes.add(index, in);\n        }\n        // Reindex children from the insertion point to update siblingIndex for all affected nodes.\n        reindexChildren(index);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}