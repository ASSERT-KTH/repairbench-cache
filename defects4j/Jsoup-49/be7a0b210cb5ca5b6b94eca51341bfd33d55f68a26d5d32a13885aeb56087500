{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes(); // Ensures childNodes is not null\n\n        // Iterate backwards through the children to add, to maintain order at insertion point 'index'\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n\n            // 1. Remove the node 'in' from its current parent (if any)\n            if (in.parentNode != null) {\n                // Optimization: if the node is already a child of this node,\n                // we can remove it directly by physical index rather than relying on\n                // removeChild(node) which uses sibling index (which might be stale or incorrect\n                // due to prior additions or removals in this loop).\n                if (in.parentNode == this) {\n                    int currentPhysicalIndex = childNodes.indexOf(in); // Find by identity\n                    if (currentPhysicalIndex != -1) { // If found (should be, if parentNode == this), remove it\n                        childNodes.remove(currentPhysicalIndex);\n                    }\n                    // Note: No need to reindex children after removal here, will be done once at the end.\n                } else {\n                    // If node has a different parent, use standard removeChild\n                    in.parentNode.removeChild(in);\n                }\n            }\n\n            // 2. Add the node 'in' to this node's children at the specified index\n            // Ensure the parent node is correctly set (or updated)\n            in.setParentNode(this); // This also nulls the sibling index\n            childNodes.add(index, in);\n        }\n\n        // 3. Reindex children starting from the insertion index, only once after all nodes are added/moved.\n        reindexChildren(index);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}