{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        List<Node> currentChildren = ensureChildNodes(); // Get the modifiable list, ensure initialized\n\n        // First, detach all children from their existing parents.\n        for (Node child : children) {\n            // If child is already present in this node's children, remove it first.\n            // This handles the move-within-same-parent case correctly by finding the current index.\n            if (child.parentNode == this) {\n                // Find its *current* index using indexOf on the actual list, not the potentially stale siblingIndex.\n                int currentIdx = currentChildren.indexOf(child);\n                if (currentIdx != -1)\n                    currentChildren.remove(currentIdx); // Remove using current index, NO reindex/parentNode=null yet.\n            }\n            else if (child.parentNode != null) {\n                // If in another parent, use standard remove() which calls parent.removeChild() correctly.\n                child.remove(); // Detaches node from its old parent.\n            }\n            // else: child has no parent, nothing to do for detachment.\n        }\n\n        // Add all children at the specified index. Iterate backwards through the input\n        // array to insert them in the original order at the specified index.\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node child = children[i];\n            // We removed the child previously if it was already in currentChildren. Now add it back.\n            // Set parent field directly to avoid setParentNode's removeChild call, which could cause issues.\n            // Direct field access parentNode is assumed valid within Node/subclasses.\n            child.parentNode = this;\n            currentChildren.add(index, child); // Add to the list at the correct spot\n        }\n\n        // Finally, reindex all children starting from the insertion point.\n        // Reindexing from 0 is safest because removals might have happened anywhere\n        // in the list before the insertion, affecting subsequent indices.\n        reindexChildren(0);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}