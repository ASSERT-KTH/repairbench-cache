{
    "generation": "    protected void addChildren(int index, Node... children) {\n        Validate.noNullElements(children);\n        ensureChildNodes();\n\n        // 1. Identify nodes that are already children of this element and will be moved.\n        // These need to be removed from their current positions first.\n        // Use a Set for efficient lookup.\n        Set<Node> childrenBeingMoved = new java.util.HashSet<>(children.length);\n        for (Node child : children) {\n            if (child.parent == this) {\n                childrenBeingMoved.add(child);\n            }\n        }\n\n        // 2. Remove identified nodes from their current positions in this.childNodes.\n        // Iterate backward to avoid issues with shifting indices during removal.\n        for (int i = childNodes.size() - 1; i >= 0; i--) {\n            Node child = childNodes.get(i);\n            if (childrenBeingMoved.contains(child)) {\n                // Remove from the list. Crucially, do NOT call child.parent.removeChild(child) here,\n                // as that would set child.parent = null and child.siblingIndex = 0,\n                // which is not desired for a \"move within same parent\".\n                childNodes.remove(i);\n                // The Node's parent and siblingIndex are not affected by ArrayList.remove,\n                // which is good as they are still logically children of 'this'.\n            }\n        }\n\n        // 3. Add all children (both new ones and those previously removed for moving)\n        // at the target index. Iterate backward over the input 'children' array\n        // to maintain the correct insertion order at 'index'.\n        for (int i = children.length - 1; i >= 0; i--) {\n            Node in = children[i];\n\n            // If the node has a different parent, remove it from that parent.\n            if (in.parent != null && in.parent != this) {\n                in.parent.removeChild(in);\n            }\n\n            // Set the parent of the node to this element.\n            // For nodes that were already children of 'this' and were removed in the first pass,\n            // their parent was never set to null, so this is safe and confirms the parent.\n            in.parent = this;\n\n            // Add the node at the specified index.\n            childNodes.add(index, in);\n        }\n\n        // 4. Re-index all children from the insertion point onwards.\n        // This ensures correct siblingIndex values after all insertions and removals.\n        reindexChildren(index);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}