{
    "generation": "protected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MathIllegalStateException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n        resetOccurred = false;\n\n        // initialize the events states if needed\n        if (!statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            }\n        });\n\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                occuringEvents.add(state);\n            }\n        }\n\n        boolean loopAgain;\n        do {\n            loopAgain = false;\n\n            while (!occuringEvents.isEmpty()) {\n\n                // process the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState();\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the step up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                if (currentEvent.reset(eventT, eventY)) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n\n                    // after this reset, reinitialize events location detection for the remaining part of the step\n                    previousT = eventT;\n                    interpolator.setSoftPreviousTime(eventT);\n                    interpolator.setSoftCurrentTime(currentT);\n\n                    // recompute all event detection for the remaining step from scratch\n                    occuringEvents.clear();\n                    for (final EventState state : eventsStates) {\n                        if (state.evaluateStep(interpolator)) {\n                            occuringEvents.add(state);\n                        }\n                    }\n\n                    // ensure that this outer loop restarts scanning the new occuringEvents set\n                    loopAgain = true;\n                    break; // restart the outer do-loop\n                }\n\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occuringEvents.add(currentEvent);\n                }\n            }\n\n        } while (loopAgain);\n\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}