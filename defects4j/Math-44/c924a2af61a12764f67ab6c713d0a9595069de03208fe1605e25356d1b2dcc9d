{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MathIllegalStateException {\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            boolean isLastStep = false;\n            for (EventState state : eventsStates) {\n                isLastStep = isLastStep || state.stop();\n            }\n            if (isLastStep) {\n                for (StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                return currentT;\n            }\n            final List<EventState> occuringEvents = new ArrayList<EventState>();\n            for (EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occuringEvents.add(state);\n                }\n            }\n            if (occuringEvents.isEmpty()) {\n                for (StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                return currentT;\n            }\n            while (!occuringEvents.isEmpty()) {\n                final EventState currentEvent = occuringEvents.remove(0);\n                final double eventT = currentEvent.getEventTime();\n                for (EventState state : eventsStates) {\n                    state.eventOccurred(eventT);\n                }\n                for (StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n                if (currentEvent.stop()) {\n                    return eventT;\n                }\n                // prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n                // check if the same event occurs again in the remaining part of the step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(currentEvent);\n                }\n            }\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n            return currentT;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}