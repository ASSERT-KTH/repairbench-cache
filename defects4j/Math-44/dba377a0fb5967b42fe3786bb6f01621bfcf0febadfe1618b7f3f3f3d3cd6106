{
    "generation": "/** Accept a step, triggering events and step handlers.\n * @param interpolator step interpolator\n * @param y state vector at step end time, must be reset if an event\n * asks for resetting or if an events stops integration during the step\n * @param yDot placeholder array where to put the time derivative of the state vector\n * @param tEnd final integration time\n * @return time at end of step\n * @exception MathIllegalStateException if the value of one event state cannot be evaluated\n * @since 2.2\n */\nprotected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MathIllegalStateException {\n\n        double previousT = interpolator.getGlobalPreviousTime();\n        final double currentT = interpolator.getGlobalCurrentTime();\n        resetOccurred = false;\n\n        // initialize the events states if needed\n        if (! statesInitialized) {\n            for (EventState state : eventsStates) {\n                state.reinitializeBegin(interpolator);\n            }\n            statesInitialized = true;\n        }\n\n        // search for next events that may occur during the step\n        final int orderingSign = interpolator.isForward() ? +1 : -1;\n        SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n            /** {@inheritDoc} */\n            public int compare(EventState es0, EventState es1) {\n                int cmp = orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                if (cmp == 0) {\n                    // ensure no compareTo equals (TreeSet contract)\n                    // No two EventState objects are considered equal\n                    // unless they are the same object\n                    return System.identityHashCode(es0) - System.identityHashCode(es1);\n                }\n                return cmp;\n            }\n\n        });\n\n        // This list holds events that are due for evaluation in the current step\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n        }\n\n        double stepEnd = currentT;\n        AbstractStepInterpolator restricted = interpolator;\n\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n\n            // create a secondary interpolator (possibly a copy if needed) restricted to [previousT, eventT]\n            restricted = interpolator.copy();\n            restricted.setSoftPreviousTime(previousT);\n            restricted.setSoftCurrentTime(eventT);\n\n            // trigger the event\n            restricted.setInterpolatedTime(eventT);\n            final double[] eventY = restricted.getInterpolatedState();\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(restricted, isLastStep);\n            }\n\n            if (isLastStep) {\n                // the event asked to stop integration\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                return eventT;\n            }\n\n            if (currentEvent.reset(eventT, eventY)) {\n                // some event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute them\n                System.arraycopy(eventY, 0, y, 0, y.length);\n                computeDerivatives(eventT, y, yDot);\n                resetOccurred = true;\n                // The documentation promises that in case of a reset,\n                // the rest of the step is not taken. We bail out as soon as reset is triggered.\n                // NOTE: stepEnd is eventT, not currentT!\n                return eventT;\n            }\n\n            // prepare handling of the remaining part of the step\n            previousT = eventT;\n            // Don't \"skip\" events due to round-off\n            // reset the occuringEvents for the remaining interval in the step\n            occuringEvents.clear();\n            restricted = interpolator.copy();\n            restricted.setSoftPreviousTime(eventT);\n            restricted.setSoftCurrentTime(currentT);\n\n            // recheck for all remaining events which may happen in [eventT, currentT]\n            for (final EventState state : eventsStates) {\n                // Re-run ONLY if event has not already occurred at eventT\n                // (Don't go back in time!)\n                if (state.evaluateStep(restricted)) {\n                    occuringEvents.add(state);\n                }\n            }\n\n        }\n\n        interpolator.setInterpolatedTime(currentT);\n        final double[] currentY = interpolator.getInterpolatedState();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(currentT, currentY);\n            isLastStep = isLastStep || state.stop();\n        }\n        isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n        // handle the remaining part of the step, after all events if any\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        return currentT;\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}