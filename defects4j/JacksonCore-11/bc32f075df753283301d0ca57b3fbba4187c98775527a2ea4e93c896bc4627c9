{
    "generation": "    private void _verifySharing()\n    {\n        if (_hashShared) {\n            // Unshare current arrays by copying them\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            \n            // After copying, we are no longer shared\n            _hashShared = false;\n            \n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent.\n            //    The exception suggests that the 'need rehash' state is sometimes\n            //    inconsistent with the actual array state after copying.\n            //    To ensure consistency, re-calculate internal indices based on the\n            //    newly copied array lengths before potential rehash.\n            \n            // Re-align _hashSize with the actual copied _hashArea length (assuming no spillover in base size)\n            // This is crucial for BytesToNameCanonicalizer as _hashSize is half of primary _hashArea length\n            // This ensures _hashSize correctly reflects the physical capacity of the copied array.\n            _hashSize = _hashArea.length >> 1; // Divide by 2\n            _hashThreshold = _hashSize - (_hashSize >> 2); // ~75% of _hashSize\n\n            // Reset spillover-related indices to be consistent with the new base _hashSize\n            // These would normally be reset during rehash, but re-aligning them here\n            // ensures rehash (if called) starts from a consistent state.\n            _spilloverStart = _hashSize << 1; // _hashSize * 2\n            _longNameOffset = _hashSize;\n            \n            // Rehash if needed; _needRehash flag should now be accurate based on re-aligned state\n            if (_needRehash) {\n                rehash();\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}