{
    "generation": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        // FIX: Reset the min/max Y values because they are copied from the original\n        // series but need to be re-calculated based on the subset of data added.\n        // The add() method relies on these being initialized appropriately (e.g., to\n        // positive/negative infinity) to correctly track the new min/max values.\n        copy.minY = Double.POSITIVE_INFINITY;\n        copy.maxY = Double.NEGATIVE_INFINITY;\n        // If there are similar fields for min/max X values, they should also be reset here.\n        // For example:\n        // copy.minX = Double.POSITIVE_INFINITY;\n        // copy.maxX = Double.NEGATIVE_INFINITY;\n\n\n        copy.data = new java.util.ArrayList(); // Clear the data list of the copied object\n\n        // Only proceed if there is data in the original series and the start index is valid\n        if (this.data.size() > 0 && start < this.data.size()) {\n            // Adjust the 'end' index to not exceed the actual bounds of the data\n            // This prevents IndexOutOfBoundsException if 'end' is greater than (data.size() - 1)\n            int adjustedEnd = Math.min(end, this.data.size() - 1);\n\n            for (int index = start; index <= adjustedEnd; index++) {\n                TimeSeriesDataItem item\n                        = (TimeSeriesDataItem) this.data.get(index);\n                TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                try {\n                    // This add() method will now correctly update the min/max Y\n                    // values for the 'copy' object from scratch due to the reset above.\n                    copy.add(clone);\n                }\n                catch (SeriesException e) {\n                    e.printStackTrace(); // Log the error, consistent with original behavior.\n                }\n            }\n        }\n        return copy;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}