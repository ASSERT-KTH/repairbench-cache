{
    "generation": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the index of the first time period to copy.\n     * @param end  the index of the last time period to copy.\n     *\n     * @return A series containing a copy of this times series from start until\n     *         end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(int start, int end)\n            throws CloneNotSupportedException {\n\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Requires start >= 0.\");\n        }\n        if (end < start) {\n            throw new IllegalArgumentException(\"Requires start <= end.\");\n        }\n\n        TimeSeries copy = (TimeSeries) super.clone();\n\n        // The clone operation potentially shallow copies the data list and\n        // the min/max values. We need to create a new list and ensure\n        // the min/max values are recalculated based *only* on the subset\n        // of items being copied.\n        // The clear() method resets the data list AND the min/max values to NaN.\n        // However, clear() also resets timePeriodClass, so we preserve and restore it.\n        copy.data = new java.util.ArrayList(); // Use new list, avoid clear() side effect on timePeriodClass\n        copy.minY = Double.NaN; // Explicitly reset min/max values\n        copy.maxY = Double.NaN;\n\n        if (this.data.size() > 0) {\n            // Ensure indices are within the bounds of the original data list\n            int actualStart = Math.max(start, 0); // Ensure start is not negative (already checked, but safer)\n            int actualEnd = Math.min(end, this.data.size() - 1);\n\n            // Check if the adjusted range is valid\n            if (actualStart <= actualEnd) {\n                for (int index = actualStart; index <= actualEnd; index++) {\n                    // Check index again? Not strictly necessary due to actualEnd logic,\n                    // but protects against potential off-by-one errors if logic changes.\n                    if (index >= this.data.size()) {\n                        // Should not happen with current logic, but defensive check.\n                        break;\n                    }\n                    TimeSeriesDataItem item\n                            = (TimeSeriesDataItem) this.data.get(index);\n                    TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n                    try {\n                        // The add method should now correctly update minY and maxY\n                        // starting from NaN, based on the items actually added.\n                        copy.add(clone);\n                    }\n                    catch (SeriesException e) {\n                        // This should not happen if cloning from a valid series\n                        System.err.println(\"Unable to add cloned item.\");\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        // If no items are copied (original empty, or start > end),\n        // the copy will be empty and minY/maxY will remain NaN, which is correct.\n        return copy;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}