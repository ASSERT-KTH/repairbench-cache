{
    "generation": "public List getValues(final Option option, List defaultValues) {\n    // First, try to get user\u2010supplied values.\n    List userValues = (List) values.get(option);\n    \n    // Determine the \u201ccomplete\u201d default list in order.\n    // If the caller passed a non\u2010empty defaultValues list, use it;\n    // otherwise, try our internal defaults map.\n    List defaults = (defaultValues != null && !defaultValues.isEmpty())\n            ? defaultValues\n            : (List) this.defaultValues.get(option);\n    \n    // If no user\u2010supplied values exist, simply return a copy of the defaults (or empty list).\n    if (userValues == null || userValues.isEmpty()) {\n        return defaults == null ? Collections.EMPTY_LIST : new ArrayList(defaults);\n    }\n    \n    // When some values were supplied, we want to \u201cfill in\u201d the missing ones\n    // from the complete set of default values.\n    // That is, we take the full default list then override the initial entries\n    // with the user\u2010supplied values.\n    List finalList = new ArrayList();\n    if (defaults != null) {\n        finalList.addAll(defaults);\n    } else {\n        // No defaults available; just use the user values.\n        finalList.addAll(userValues);\n    }\n    \n    // Replace the beginning entries with the user\u2013supplied ones.\n    for (int i = 0; i < userValues.size(); i++) {\n        if (i < finalList.size()) {\n            finalList.set(i, userValues.get(i));\n        } else {\n            finalList.add(userValues.get(i));\n        }\n    }\n    \n    return finalList;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}