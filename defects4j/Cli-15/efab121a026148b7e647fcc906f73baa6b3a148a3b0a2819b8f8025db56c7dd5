{
    "generation": "public List getValues(final Option option, List defaultValues) {\n    // initialize the return list\n    List valueList = (List) values.get(option);\n\n    // grab the correct default values\n    if ((valueList == null) || valueList.isEmpty()) {\n        valueList = defaultValues;\n    }\n\n    // If valueList is still null or empty, try to get defaults from this.defaultValues map\n    if ((valueList == null) || valueList.isEmpty()) {\n        valueList = (List) this.defaultValues.get(option);\n    }\n\n    // If we have some user-provided values, but fewer than the required minimum or maximum,\n    // augment with remaining default values\n    Argument argument = null;\n    if (option instanceof DefaultOption) {\n        argument = ((DefaultOption) option).getArgument();\n    }\n    if (argument != null) {\n        int maximum = argument.getMaximum();\n        if (maximum < 0) {\n            maximum = Integer.MAX_VALUE; // treat unlimited as max int\n        }\n        // Get all possible default values\n        List fullDefaults = argument.getDefaultValues();\n        // Determine current count (of values provided explicitly)\n        int currentSize = valueList == null ? 0 : valueList.size();\n        // If valueList is null, create new list to combine values\n        if (valueList == null) {\n            valueList = new ArrayList();\n        } else {\n            valueList = new ArrayList(valueList); // copy to modifiable list\n        }\n        // Add default values as needed to reach minimum or fill up to maximum\n        if (fullDefaults != null && !fullDefaults.isEmpty() && currentSize < maximum) {\n            for (int i = currentSize; i < fullDefaults.size() && valueList.size() < maximum; i++) {\n                valueList.add(fullDefaults.get(i));\n            }\n        }\n    }\n\n    return valueList == null ? Collections.EMPTY_LIST : valueList;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}