{
    "generation": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?' | '*'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    // Store the original token for type checking and marking\n    JsDocToken originalToken = token;\n    // Capture line number before consuming\n    int lineno = stream.getLineno();\n    // Capture charno (start position) before consuming\n    int startCharno = stream.getCharno();\n\n    Node node;\n    if (originalToken == JsDocToken.QMARK) {\n      // Consume '?'\n      token = next();\n      // Create a StringNode representing the unknown type '?'\n      node = newStringNode(\"?\");\n      node.setStaticSourceFile(file);\n      node.setLineno(lineno);\n      node.setCharno(startCharno);\n      // Mark the node with the corresponding JsDocToken\n      markTypeNode(node, originalToken);\n    } else if (originalToken == JsDocToken.STAR) {\n      // Consume '*'\n      token = next();\n      // Create a StringNode representing the all type '*'\n      node = newStringNode(\"*\");\n      node.setStaticSourceFile(file);\n      node.setLineno(lineno);\n      node.setCharno(startCharno);\n      // Mark the node with the corresponding JsDocToken\n      markTypeNode(node, originalToken);\n    } else {\n      // If the token is not '?' or '*', assume it's a BasicTypeExpression\n      // and delegate to parseTypeName. parseTypeName handles token consumption\n      // and node creation internally.\n      return parseTypeName(originalToken);\n    }\n\n    // Return the created node for '?' or '*'\n    return node;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}