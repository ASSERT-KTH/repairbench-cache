{
    "generation": "    /**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        printMethod(); // XXX\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension();\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n        final int np = n + 1;\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n            for (int k = 0; k < npt; k++) {\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * np / 2; i < max; i++) {\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        for (int k = 0; k < npt; k++) {\n            modelSecondDerivativesParameters.setEntry(k, ZERO);\n            for (int j = 0, max = npt - np; j < max; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n        int ipt = 0;\n        int jpt = 0;\n        double fbeg = Double.NaN;\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 &&\n                    nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == ZERO) {\n                        stepa = -stepa;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (upperDifference.getEntry(nfxm) == ZERO) {\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n                }\n                stepa = interpolationPoints.getEntry(ipt, jpt);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(jpt) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(jpt));\n                    throw new PathIsExploredException(); // XXX\n                }\n                if (upperDifference.getEntry(jpt) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(jpt));\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(nfm, jpt, stepb);\n            }\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, originShift.getEntry(j) + stepa * interpolationPoints.getEntry(nfm, j));\n            }\n            final double fval = calculateFunctionValue(currentBest);\n            if (Double.isNaN(fbeg)) {\n                fbeg = fval;\n            }\n            upperDifference.setEntry(nfmm, fval - fbeg);\n            lowerDifference.setEntry(nfxm, fval - fbeg);\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, originShift.getEntry(j) + stepb * interpolationPoints.getEntry(nfm, j));\n            }\n            fval = calculateFunctionValue(currentBest);\n            upperDifference.setEntry(nfxm, fval - fbeg);\n            lowerDifference.setEntry(nfmm, fval - fbeg);\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j));\n            }\n            }\n        } while (getEvaluations() < npt);\n    } // prelim\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}