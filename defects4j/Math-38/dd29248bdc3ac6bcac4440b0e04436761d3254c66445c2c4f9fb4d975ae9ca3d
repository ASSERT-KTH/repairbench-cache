{
    "generation": "/**\n *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n *     BMAT and ZMAT for the first iteration, and it maintains the values of\n *     NF and KOPT. The vector X is also changed by PRELIM.\n *\n *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n *       are the same as the corresponding arguments in BOBYQB, the elements\n *       of SL and SU being set in BOBYQA.\n *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n *     NF is maintaned as the number of calls of CALFUN so far.\n *     KOPT will be such that the least calculated value of F so far is at\n *     the point XPT(KOPT,.)+XBASE in the space of the variables.\n *\n * @param lowerBound Lower bounds.\n * @param upperBound Upper bounds.\n */\nprivate void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod(); // XXX\n\n    final int n    = currentBest.getDimension();\n    final int npt  = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np       = n + 1;\n\n    // Set XBASE and zero XPT, BMAT, HQ, PQ and ZMAT\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    // Begin initialization\n    int    ipt  = 0;\n    int    jpt  = 0;\n    double fbeg = Double.NaN;\n    do {\n        final int nfm   = getEvaluations();\n        final int nfx   = nfm - n;\n        final int nfmm  = nfm - 1;\n        final int nfxm  = nfx - 1;\n        double    stepa = 0;\n        double    stepb = 0;\n\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else { // n < nfm <= 2*n\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius,\n                                     upperDifference.getEntry(nfxm));\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius,\n                                     lowerDifference.getEntry(nfxm));\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            // Compute i,j for the next interpolation point\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n            }\n            interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));\n            interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));\n        }\n\n        // Evaluate the objective at the new point\n        for (int j = 0; j < n; j++) {\n            double x = originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j);\n            x = Math.min(Math.max(x, lowerBound[j]), upperBound[j]);\n            currentBest.setEntry(j, x);\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n        final double fx = computeObjectiveValue(currentBest.toArray());\n        final double f  = isMinimize ? fx : -fx;\n        final int    numEval = getEvaluations(); // should be nfm+1\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        // Track the best among the initial points\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Update BMAT, gradient and model Hessian for initial phases\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm, nfmm,  oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                }\n            } else { // numEval >= n+2 && numEval <= 2*n+1\n                final int ih   = nfx * (nfx + 1) / 2 - 1;\n                final double tmp  = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih,\n                    TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm,\n                    (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm,     fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm,     nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0,    nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm,  nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm,\n                    -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0,    nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm,  nfxm, Math.sqrt(HALF) / rhosq);\n                zMatrix.setEntry(nfm - n, nfxm,\n                    -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n            }\n        } else {\n            // Off-diagonal terms for the later initial points\n            zMatrix.setEntry(0,    nfxm,  recip);\n            zMatrix.setEntry(nfm,  nfxm,  recip);\n            zMatrix.setEntry(ipt,  nfxm, -recip);\n            zMatrix.setEntry(jpt,  nfxm, -recip);\n\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp =\n                interpolationPoints.getEntry(nfm, ipt - 1) *\n                interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih,\n                (fbeg\n                 - fAtInterpolationPoints.getEntry(ipt)\n                 - fAtInterpolationPoints.getEntry(jpt)\n                 + f) / tmp);\n        }\n    } while (getEvaluations() < npt);\n} // prelim",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}