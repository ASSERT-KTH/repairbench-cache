{
    "generation": "/**\n *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n *     BMAT and ZMAT for the first iteration, and it maintains the values of\n *     NF and KOPT. The vector X is also changed by PRELIM.\n *\n *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT and ZMAT, NDIM, SL and SU\n *       are the same as the corresponding arguments in BOBYQB, the elements\n *       of SL and SU being set in BOBYQA.\n *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n *     NF is maintaned as the number of calls of CALFUN so far.\n *     KOPT will be such that the least calculated value of F so far is at\n *     the point XPT(KOPT,.)+XBASE in the space of the variables.\n *\n * @param lowerBound Lower bounds.\n * @param upperBound Upper bounds.\n */\nprivate void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod(); // XXX\n\n    final int n    = currentBest.getDimension();\n    final int npt  = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np       = n + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    // Begin the initialization procedure.\n    int    ipt   = 0;\n    int    jpt   = 0;\n    double fbeg  = Double.NaN;\n    do {\n        final int nfm  = getEvaluations();\n        final int nfx  = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n\n        // Define the next interpolation point displacement\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else { // n < nfm <= 2*n\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius,\n                                     upperDifference.getEntry(nfxm));\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius,\n                                     lowerDifference.getEntry(nfxm));\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            // Off-diagonal combination points for npt > 2*n + 1\n            final int tmp1 = (nfm - np) / n;\n            jpt    = nfm - tmp1 * n - n;\n            ipt    = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n            }\n            final int ipt_1 = ipt;\n            final int jpt_1 = jpt;\n            interpolationPoints.setEntry(nfm,   ipt_1,\n                                         interpolationPoints.getEntry(ipt,   ipt_1));\n            interpolationPoints.setEntry(nfm,   jpt_1,\n                                         interpolationPoints.getEntry(jpt,   jpt_1));\n        }\n\n        // Evaluate the objective at the new point\n        for (int j = 0; j < n; j++) {\n            double xj = originShift.getEntry(j)\n                      + interpolationPoints.getEntry(nfm, j);\n            xj = Math.min(Math.max(lowerBound[j], xj),\n                          upperBound[j]);\n            currentBest.setEntry(j, xj);\n            if (interpolationPoints.getEntry(nfm, j)\n                == lowerDifference.getEntry(j)) {\n                currentBest.setEntry(j, lowerBound[j]);\n            }\n            if (interpolationPoints.getEntry(nfm, j)\n                == upperDifference.getEntry(j)) {\n                currentBest.setEntry(j, upperBound[j]);\n            }\n        }\n\n        double objectiveValue = computeObjectiveValue(currentBest.toArray());\n        double f = isMinimize ? objectiveValue : -objectiveValue;\n        int numEval = getEvaluations(); // should be nfm + 1\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(\n                            trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Build BMAT, GOPT, HQ, ZMAT as required\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                // First n off-diagonal Hessian columns => gradient\n                gradientAtTrustRegionCenter.setEntry(nfmm,\n                                (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0,      nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm,    nfmm,  oneOverStepA);\n                    bMatrix.setEntry(npt+nfmm, nfmm, -HALF * rhosq);\n                }\n            } else {\n                // Diagonal second derivatives\n                final int ih   = nfx * (nfx + 1) / 2 - 1;\n                final double tmp  = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(ih,\n                      TWO * (tmp - gradientAtTrustRegionCenter\n                                     .getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(nfxm,\n                      (gradientAtTrustRegionCenter\n                          .getEntry(nfxm) * stepb\n                       - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm,\n                                fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm,     nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0,   nfxm,\n                                 -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm, nfxm,\n                                -HALF / interpolationPoints\n                                        .getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm,\n                               -bMatrix.getEntry(0, nfxm)\n                               - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0,     nfxm,\n                                Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm,   nfxm,\n                                Math.sqrt(HALF) / rhosq);\n                zMatrix.setEntry(nfm - n, nfxm,\n                               -zMatrix.getEntry(0, nfxm)\n                               - zMatrix.getEntry(nfm, nfxm));\n            }\n        } else {\n            // Off-diagonal second derivatives for extra points\n            zMatrix.setEntry(0,    nfxm,  recip);\n            zMatrix.setEntry(nfm,  nfxm,  recip);\n            zMatrix.setEntry(ipt,  nfxm, -recip);\n            zMatrix.setEntry(jpt,  nfxm, -recip);\n\n            final int ih  = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1)\n                             * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(ih,\n               (fbeg\n                - fAtInterpolationPoints.getEntry(ipt)\n                - fAtInterpolationPoints.getEntry(jpt)\n                + f) / tmp);\n        }\n\n    } while (getEvaluations() < npt);\n} // prelim",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}