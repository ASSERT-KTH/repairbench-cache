{
    "generation": "/**\n *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n *     BMAT and ZMAT for the first iteration, and it maintains the values of\n *     NF and KOPT. The vector X is also changed by PRELIM.\n *\n *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n *       are the same as the corresponding arguments in BOBYQB, the elements\n *       of SL and SU being set in BOBYQA.\n *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n *     NF is maintaned as the number of calls of CALFUN so far.\n *     KOPT will be such that the least calculated value of F so far is at\n *     the point XPT(KOPT,.)+XBASE in the space of the variables.\n *\n * @param lowerBound Lower bounds.\n * @param upperBound Upper bounds.\n */\nprivate void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod(); // XXX\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Zero out XBASE, XPT, BMAT, HQ, PQ and ZMAT.\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    // Initialization loop: set up the first npt interpolation points.\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n    do {\n        final int nfm  = getEvaluations();\n        final int nfx  = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n\n        // Determine the new interpolation point displacements.\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else { // nfm > n\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius,\n                                     upperDifference.getEntry(nfxm));\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius,\n                                     lowerDifference.getEntry(nfxm));\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            // nfm > 2*n : compute a pair swap for off-diagonal second derivatives\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n            }\n            final int iptMinus1 = ipt;\n            final int jptMinus1 = jpt;\n            interpolationPoints.setEntry(nfm, iptMinus1,\n                                         interpolationPoints.getEntry(ipt, iptMinus1));\n            interpolationPoints.setEntry(nfm, jptMinus1,\n                                         interpolationPoints.getEntry(jpt, jptMinus1));\n        }\n\n        // Evaluate the objective at the new interpolation point.\n        for (int j = 0; j < n; j++) {\n            double xj = originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j);\n            xj = Math.min(Math.max(lowerBound[j], xj), upperBound[j]);\n            // Correct for binding constraints exactly at the bound.\n            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                xj = lowerBound[j];\n            }\n            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                xj = upperBound[j];\n            }\n            currentBest.setEntry(j, xj);\n        }\n        final double val = computeObjectiveValue(currentBest.toArray());\n        final double f   = isMinimize ? val : -val;\n        final int numEval = getEvaluations(); // should be nfm+1\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(\n                         trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Update BMAT, ZMAT and the quadratic model for up to 2*n+1 points.\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                // First n off-diagonals\n                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0,      nfmm, -oneOverStepA);\n                    bMatrix.setEntry(nfm,    nfmm,  oneOverStepA);\n                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n                }\n            } else { // numEval >= n + 2\n                final int ih   = nfx * (nfx + 1) / 2 - 1;\n                final double tmp  = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(\n                    ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(\n                    nfxm,\n                    (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO) {\n                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                        fAtInterpolationPoints.setEntry(nfm,\n                            fAtInterpolationPoints.getEntry(nfm - n));\n                        fAtInterpolationPoints.setEntry(nfm - n, f);\n                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                        }\n                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                        interpolationPoints.setEntry(nfm,     nfxm, stepa);\n                    }\n                }\n                bMatrix.setEntry(0,      nfxm, -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm,    nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n,nfxm,\n                                 -bMatrix.getEntry(0, nfxm)\n                                 - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0,      nfxm, Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm,    nfxm, Math.sqrt(HALF) / rhosq);\n                zMatrix.setEntry(nfm - n,nfxm,\n                                 -zMatrix.getEntry(0,      nfxm)\n                                 - zMatrix.getEntry(nfm,    nfxm));\n            }\n        } else {\n            // Off-diagonal second derivatives beyond 2*n+1 points\n            zMatrix.setEntry(0,   nfxm,  recip);\n            zMatrix.setEntry(nfm, nfxm,  recip);\n            zMatrix.setEntry(ipt, nfxm, -recip);\n            zMatrix.setEntry(jpt, nfxm, -recip);\n\n            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1)\n                             * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(\n                ih,\n                (fbeg\n                 - fAtInterpolationPoints.getEntry(ipt)\n                 - fAtInterpolationPoints.getEntry(jpt)\n                 + f) / tmp);\n        }\n    } while (getEvaluations() < npt);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}