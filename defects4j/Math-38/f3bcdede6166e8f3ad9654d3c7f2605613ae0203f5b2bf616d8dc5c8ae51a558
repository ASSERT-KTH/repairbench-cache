{
    "generation": "/**\n *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n *     BMAT and ZMAT for the first iteration, and it maintains the values of\n *     NF and KOPT. The vector X is also changed by PRELIM.\n *\n *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n *       are the same as the corresponding arguments in BOBYQB, the elements\n *       of SL and SU being set in BOBYQA.\n *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n *     NF is maintaned as the number of calls of CALFUN so far.\n *     KOPT will be such that the least calculated value of F so far is at\n *     the point XPT(KOPT,.)+XBASE in the space of the variables.\n *\n * @param lowerBound Lower bounds.\n * @param upperBound Upper bounds.\n */\nprivate void prelim(double[] lowerBound,\n                    double[] upperBound) {\n    printMethod(); // XXX\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Zero\u2010out XBASE, XPT, BMAT, HQ, PQ and ZMAT\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n\n    do {\n        final int nfm  = getEvaluations();\n        final int nfx  = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n\n        // Choose new interpolation\u2010point displacement\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                stepa = initialTrustRegionRadius;\n                if (upperDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else {\n                stepa = interpolationPoints.getEntry(nfx, nfxm);\n                stepb = -initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.min(TWO * initialTrustRegionRadius,\n                                     upperDifference.getEntry(nfxm));\n                }\n                if (upperDifference.getEntry(nfxm) == ZERO) {\n                    stepb = Math.max(-TWO * initialTrustRegionRadius,\n                                     lowerDifference.getEntry(nfxm));\n                }\n                interpolationPoints.setEntry(nfm, nfxm, stepb);\n            }\n        } else {\n            final int tmp1 = (nfm - np) / n;\n            jpt = nfm - tmp1 * n - n;\n            ipt = jpt + tmp1;\n            if (ipt > n) {\n                final int tmp2 = jpt;\n                jpt = ipt - n;\n                ipt = tmp2;\n            }\n            final int iptM1 = ipt;\n            final int jptM1 = jpt;\n            interpolationPoints.setEntry(nfm, iptM1,\n                                         interpolationPoints.getEntry(ipt, iptM1));\n            interpolationPoints.setEntry(nfm, jptM1,\n                                         interpolationPoints.getEntry(jpt, jptM1));\n        }\n\n        // Evaluate the objective at the new point\n        for (int j = 0; j < n; j++) {\n            double xj = originShift.getEntry(j)\n                      + interpolationPoints.getEntry(nfm, j);\n            xj = Math.min(Math.max(lowerBound[j], xj), upperBound[j]);\n            if (interpolationPoints.getEntry(nfm, j) ==\n                lowerDifference.getEntry(j)) {\n                xj = lowerBound[j];\n            }\n            if (interpolationPoints.getEntry(nfm, j) ==\n                upperDifference.getEntry(j)) {\n                xj = upperBound[j];\n            }\n            currentBest.setEntry(j, xj);\n        }\n        final double obj = computeObjectiveValue(currentBest.toArray());\n        final double f   = isMinimize ? obj : -obj;\n        final int numEval = getEvaluations(); // = nfm+1\n        fAtInterpolationPoints.setEntry(nfm, f);\n\n        if (numEval == 1) {\n            fbeg = f;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (f < fAtInterpolationPoints.getEntry(\n                         trustRegionCenterInterpolationPointIndex)) {\n            trustRegionCenterInterpolationPointIndex = nfm;\n        }\n\n        // Build up BMAT, GOPT and the quadratic model\n        if (numEval <= 2 * n + 1) {\n            if (numEval >= 2 && numEval <= n + 1) {\n                gradientAtTrustRegionCenter.setEntry(nfmm,\n                                       (f - fbeg) / stepa);\n                if (npt < numEval + n) {\n                    final double invA = ONE / stepa;\n                    bMatrix.setEntry(0,   nfmm, -invA);\n                    bMatrix.setEntry(nfm, nfmm,  invA);\n                    bMatrix.setEntry(npt + nfmm,\n                                    nfmm, -HALF * rhosq);\n                }\n            } else {\n                final int ih   = nfx * (nfx + 1) / 2 - 1;\n                final double tmp  = (f - fbeg) / stepb;\n                final double diff = stepb - stepa;\n                modelSecondDerivativesValues.setEntry(\n                    ih,\n                    TWO * (tmp - gradientAtTrustRegionCenter\n                                     .getEntry(nfxm)) / diff);\n                gradientAtTrustRegionCenter.setEntry(\n                    nfxm,\n                    (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb\n                     - tmp * stepa) / diff);\n                if (stepa * stepb < ZERO &&\n                    f < fAtInterpolationPoints.getEntry(nfm - n)) {\n                    double fe = fAtInterpolationPoints\n                                    .getEntry(nfm - n);\n                    fAtInterpolationPoints.setEntry(nfm - n, f);\n                    fAtInterpolationPoints.setEntry(nfm, fe);\n                    if (trustRegionCenterInterpolationPointIndex == nfm) {\n                        trustRegionCenterInterpolationPointIndex = nfm - n;\n                    }\n                    interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n                    interpolationPoints.setEntry(nfm,     nfxm, stepa);\n                }\n                bMatrix.setEntry(0,    nfxm,\n                                 -(stepa + stepb) / (stepa * stepb));\n                bMatrix.setEntry(nfm, nfxm,\n                                 -HALF / interpolationPoints\n                                             .getEntry(nfm - n, nfxm));\n                bMatrix.setEntry(nfm - n, nfxm,\n                                 -bMatrix.getEntry(0,    nfxm)\n                                 - bMatrix.getEntry(nfm, nfxm));\n                zMatrix.setEntry(0,    nfxm,\n                                 Math.sqrt(TWO) / (stepa * stepb));\n                zMatrix.setEntry(nfm, nfxm,\n                                 Math.sqrt(HALF) / rhosq);\n                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip);\n                zMatrix.setEntry(nfm - n, nfxm,\n                                 -zMatrix.getEntry(0,    nfxm)\n                                 - zMatrix.getEntry(nfm, nfxm));\n            }\n        } else {\n            zMatrix.setEntry(0,    nfxm,  recip);\n            zMatrix.setEntry(nfm, nfxm,  recip);\n            zMatrix.setEntry(ipt, nfxm, -recip);\n            zMatrix.setEntry(jpt, nfxm, -recip);\n\n            final int ih  = ipt * (ipt - 1) / 2 + jpt - 1;\n            final double tmp =\n                interpolationPoints.getEntry(nfm, ipt - 1)\n              * interpolationPoints.getEntry(nfm, jpt - 1);\n            modelSecondDerivativesValues.setEntry(\n                ih,\n                (fbeg\n                 - fAtInterpolationPoints.getEntry(ipt)\n                 - fAtInterpolationPoints.getEntry(jpt)\n                 + f) / tmp);\n        }\n    } while (getEvaluations() < npt);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}