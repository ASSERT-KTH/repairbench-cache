{
    "generation": "import org.apache.commons.math.linear.RealMatrix;\nimport org.apache.commons.math.linear.RealVector;\n\n// Define ZERO, ONE, TWO, HALF or import them if they are constants elsewhere\n// For example:\n// import static org.apache.commons.math.util.FastMath.sqrt; // If using FastMath\n// Assuming ZERO=0.0, ONE=1.0, TWO=2.0, HALF=0.5 are accessible constants.\n\n/**\n * Helper class to provide context for the prelim method.\n * Replace with actual class structure.\n */\nabstract class PrelimContextHelper {\n    // Define constants if not available globally\n    protected static final double ZERO = 0.0;\n    protected static final double ONE = 1.0;\n    protected static final double TWO = 2.0;\n    protected static final double HALF = 0.5;\n\n    // Fields assumed to be available in the actual class\n    protected RealVector currentBest;\n    protected RealVector originShift;\n    protected RealMatrix interpolationPoints; // Assuming size npt x n (rows 0..npt-1 for points 1..npt)\n    protected RealVector fAtInterpolationPoints; // Assuming size npt+1 (index 0 for XBASE, 1..npt for points 1..npt)\n    protected RealVector lowerDifference;\n    protected RealVector upperDifference;\n    protected RealVector gradientAtTrustRegionCenter; // size n\n    protected RealVector modelSecondDerivativesParameters; // size npt ? Or npt+1? Check usage/allocation.\n    protected RealVector modelSecondDerivativesValues; // size n*(n+1)/2\n    protected RealMatrix bMatrix; // size ndim x n, where ndim = npt + n\n    protected RealMatrix zMatrix; // size npt x (npt-np)? Or npt+1 x (npt-np)? Check allocation. Assuming npt+1 rows.\n    protected int numberOfInterpolationPoints;\n    protected double initialTrustRegionRadius;\n    protected boolean isMinimize;\n    protected int trustRegionCenterInterpolationPointIndex; // kopt\n    protected abstract double computeObjectiveValue(double[] point);\n    protected abstract int getEvaluations(); // Assuming this returns total evaluations so far\n    // Helper method (remove if not needed)\n    protected void printMethod() {}\n\n    /**\n     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n     *     NF and KOPT. The vector X is also changed by PRELIM.\n     *\n     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n     *       are the same as the corresponding arguments in BOBYQB, the elements\n     *       of SL and SU being set in BOBYQA.\n     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n     *     NF is maintaned as the number of calls of CALFUN so far.\n     *     KOPT will be such that the least calculated value of F so far is at\n     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     */\n    private void prelim(double[] lowerBound,\n                        double[] upperBound) {\n        // printMethod(); // Removed debugging print\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int ndim = bMatrix.getRowDimension(); // Should be npt + n\n        final int np = n + 1;\n\n        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double recip = 1d / rhosq;\n\n        // Set originShift (XBASE) from the initial point\n        for (int j = 0; j < n; j++) {\n            originShift.setEntry(j, currentBest.getEntry(j));\n        }\n\n        // Initialize interpolationPoints (XPT displacements), BMAT, HQ, PQ, ZMAT\n        // Assuming index conventions based on careful review:\n        // interpolationPoints: npt x n (row k stores displacement for point k+1)\n        // fAtInterpolationPoints: npt+1 (index 0 for XBASE, index k for point k)\n        // bMatrix: ndim x n (ndim = npt + n)\n        // zMatrix: npt+1 x (npt-np) ? Check dimensions carefully. Fortran implies rows 1..NPT+1. Assume npt+1 rows (0..npt).\n\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k < npt; k++) { // Initialize rows 0..npt-1 (for points 1..npt)\n                interpolationPoints.setEntry(k, j, ZERO);\n            }\n            for (int i = 0; i < ndim; i++) {\n                bMatrix.setEntry(i, j, ZERO);\n            }\n        }\n        for (int i = 0, max = n * (n + 1) / 2; i < max; i++) { // HQ Hessian elements\n            modelSecondDerivativesValues.setEntry(i, ZERO);\n        }\n        // Initialize PQ (modelSecondDerivativesParameters). Check its required size. Assume allocated correctly.\n        for (int k = 0; k < modelSecondDerivativesParameters.getDimension(); k++) {\n             modelSecondDerivativesParameters.setEntry(k, ZERO);\n        }\n         // Initialize ZMAT. Assuming zMatrix has npt+1 rows (0..npt) and npt-np columns.\n        final int zMatRows = zMatrix.getRowDimension();\n        final int zMatCols = zMatrix.getColumnDimension();\n        for (int k = 0; k < zMatRows; k++) {\n            for (int j = 0; j < zMatCols; j++) {\n                zMatrix.setEntry(k, j, ZERO);\n            }\n        }\n\n        // Get the function value at the starting point (XBASE)\n        // This value should have been computed by the optimize method before calling prelim.\n        final double fbeg = isMinimize ? currentBest.getValue() : -currentBest.getValue();\n        if (fAtInterpolationPoints.getDimension() < npt + 1) {\n             // This indicates an internal setup error\n             throw new IllegalStateException(\"fAtInterpolationPoints array size is \" + fAtInterpolationPoints.getDimension() + \", needs at least \" + (npt + 1));\n        }\n        fAtInterpolationPoints.setEntry(0, fbeg); // Store f(XBASE) at index 0\n        trustRegionCenterInterpolationPointIndex = 0; // Point 0 (XBASE) is initially the best point found\n\n        // Begin the initialization procedure: generate NPT more points\n        int ipt = 0;\n        int jpt = 0;\n        for (int nfm = 0; nfm < npt; ++nfm) { // Loop npt times to generate points 1..npt. nfm is row index (0..npt-1) in interpolationPoints.\n            final int nf = nfm + 1; // Corresponds to Fortran NF loop index (1..npt)\n            final int nfPointIndex = nf; // Point index (1..npt) being generated\n\n            // Calculate displacement vector for point nf (stored in row nfm of interpolationPoints)\n            double stepa = 0;\n            double stepb = 0;\n            int varIndex = -1; // 0-based variable index for displacement calculation\n\n            // Logic based on Fortran NF (nf in Java) determines which variable(s) to change\n            if (nf <= 2 * n) { // Points 1..2n have simple displacements\n                if (nf >= 1 && nf <= n) { // Points 1..n: Step along axis nf-1\n                    varIndex = nf - 1; // Variable index 0..n-1\n                    stepa = initialTrustRegionRadius;\n                    // If already at upper bound for this variable, step negatively\n                    if (upperDifference.getEntry(varIndex) == ZERO) {\n                        stepa = -stepa;\n                    }\n                    interpolationPoints.setEntry(nfm, varIndex, stepa); // Set displacement for point nf (row nfm)\n                } else { // Points n+1..2n: Step along axis nf-n-1 based on point nf-n\n                    final int nfx = nf - n; // NFX = 1..n\n                    varIndex = nfx - 1; // Variable index 0..n-1\n                    // Get displacement of point nf-n (row nfx-1) along this axis\n                    stepa = interpolationPoints.getEntry(nfx - 1, varIndex);\n                    stepb = -initialTrustRegionRadius; // Try negative step first\n                    // Adjust step if already at a bound\n                    if (lowerDifference.getEntry(varIndex) == ZERO) {\n                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(varIndex));\n                    } else if (upperDifference.getEntry(varIndex) == ZERO) { // Check upper bound only if lower not hit\n                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(varIndex));\n                    }\n                    interpolationPoints.setEntry(nfm, varIndex, stepb); // Set displacement for point nf (row nfm)\n                }\n            } else { // Points 2n+1..npt: Displacement combines steps from two previous points\n                // Calculate 1-based variable indices ipt, jpt based on nf\n                ipt = (nf - np) % n + 1; // Fortran: IPT = MOD(NF-NP,N)+1\n                jpt = (nf - np) / n + ipt; // Fortran: JPT = (NF-NP)/N+IPT\n\n                // Ensure indices are valid and potentially swap to match Fortran convention (though ipt<=jpt assumed for HQ calc)\n                if (jpt > n) {\n                    final int tempj = ipt;\n                    ipt = jpt - n;\n                    jpt = tempj;\n                }\n                // ipt, jpt are 1-based variable indices. Assuming calculation yields ipt <= jpt.\n                final int iptIndex = ipt - 1; // 0-based variable index\n                final int jptIndex = jpt - 1; // 0-based variable index\n\n                // Set displacement for point nf (row nfm) using displacements of points ipt+1 (row ipt) and jpt+1 (row jpt)\n                interpolationPoints.setEntry(nfm, iptIndex, interpolationPoints.getEntry(ipt, iptIndex));\n                interpolationPoints.setEntry(nfm, jptIndex, interpolationPoints.getEntry(jpt, jptIndex));\n            }\n\n            // Calculate current point's coordinates in original space (point nf = xbase + xpt[row nfm])\n            // Ensure the point stays within bounds [lowerBound, upperBound]\n            for (int j = 0; j < n; j++) {\n                final double displacement = interpolationPoints.getEntry(nfm, j);\n                final double coordinate = originShift.getEntry(j) + displacement;\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], coordinate), upperBound[j]));\n                // If the displacement exactly matches the distance to a bound, ensure the coordinate is exactly the bound\n                if (displacement == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                } else if (displacement == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            // Evaluate objective function at the new point\n            final double objectiveValue = computeObjectiveValue(currentBest.toArray()); // This call should increment the evaluation counter\n            final double f = isMinimize ? objectiveValue : -objectiveValue; // Use negative value if maximizing\n            fAtInterpolationPoints.setEntry(nfPointIndex, f); // Store function value for point nf at index nf\n\n            // Update the index of the best point found so far (KOPT)\n            if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfPointIndex;\n            }\n\n            // Update model parameters (Gradient GOPT, Hessian approx HQ, matrices BMAT, ZMAT)\n            // Logic branches based on which point (nf) is being processed\n\n            if (nf <= 2 * n) { // Updates for points 1..2n\n                if (nf >= 1 && nf <= n) { // Points 1..n: Update GOPT and BMAT\n                    varIndex = nf - 1; // 0-based variable index\n                    // Estimate gradient component GOPT(varIndex) using forward difference\n                    gradientAtTrustRegionCenter.setEntry(varIndex, (f - fbeg) / stepa);\n\n                    // Update BMAT column associated with varIndex\n                    final double oneOverStepA = ONE / stepa;\n                    bMatrix.setEntry(0, varIndex, -oneOverStepA); // Row 0 (related to XBASE)\n                    bMatrix.setEntry(nf, varIndex, oneOverStepA); // Row nf (related to point nf)\n                    final int bmatRowIndexNptNf = npt + nf - 1; // Row index for NPT+NF term (related to Lagrange functions)\n                    if (bmatRowIndexNptNf < ndim) { // Check if row index is valid\n                       if (npt < nf + n) { // Condition from Fortran for smaller NPT case\n                           bMatrix.setEntry(bmatRowIndexNptNf, varIndex, ZERO);\n                       } else {\n                           bMatrix.setEntry(bmatRowIndexNptNf, varIndex, -HALF * rhosq);\n                       }\n                    } // else: Should not happen if ndim is correctly npt+n\n\n                } else { // Points n+1..2n: Update HQ, GOPT, BMAT, ZMAT\n                    final int nfx = nf - n; // NFX = 1..n\n                    varIndex = nfx - 1; // 0-based variable index\n                    // Calculate index for diagonal Hessian element H(varIndex, varIndex) in packed storage\n                    final int ih = varIndex * (varIndex + 1) / 2 + varIndex;\n\n                    final double tmp = (f - fbeg) / stepb; // Helper value for quadratic model update\n                    final double diff = stepb - stepa; // Difference in steps\n\n                    // Update Hessian diagonal H(varIndex, varIndex)\n                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(varIndex)) / diff);\n                    // Update Gradient GOPT(varIndex) using the new Hessian estimate\n                    gradientAtTrustRegionCenter.setEntry(varIndex, (gradientAtTrustRegionCenter.getEntry(varIndex) * stepb - tmp * stepa) / diff);\n\n                    // If steps were in opposite directions (stepa*stepb < 0) and new point is better, swap points\n                    final int pointIndexNfMinusN = nf - n; // Index of the previous point along this axis\n                    if (stepa * stepb < ZERO) {\n                        if (f < fAtInterpolationPoints.getEntry(pointIndexNfMinusN)) {\n                            // Swap function values\n                            final double fprev = fAtInterpolationPoints.getEntry(pointIndexNfMinusN);\n                            fAtInterpolationPoints.setEntry(pointIndexNfMinusN, f);\n                            fAtInterpolationPoints.setEntry(nfPointIndex, fprev);\n\n                            // Update best point index if it was the point just swapped out\n                            if (trustRegionCenterInterpolationPointIndex == nfPointIndex) {\n                                trustRegionCenterInterpolationPointIndex = pointIndexNfMinusN;\n                            }\n                            // Swap displacements in interpolationPoints matrix for this variable\n                            interpolationPoints.setEntry(pointIndexNfMinusN - 1, varIndex, stepb); // Point nf-n (row index nf-n-1) gets stepb\n                            interpolationPoints.setEntry(nfm, varIndex, stepa); // Point nf (row index nfm) gets stepa\n                        }\n                    }\n                    // Update BMAT column varIndex based on points nf and nf-n\n                    bMatrix.setEntry(0, varIndex, -(stepa + stepb) / (stepa * stepb));\n                    // Denominator uses stepa (displacement of point nf-n before potential swap)\n                    bMatrix.setEntry(nfPointIndex, varIndex, -HALF / stepa);\n                    bMatrix.setEntry(pointIndexNfMinusN, varIndex,\n                                  -bMatrix.getEntry(0, varIndex) - bMatrix.getEntry(nfPointIndex, varIndex));\n\n                    // Update ZMAT column varIndex based on points nf and nf-n\n                    // Check column index validity\n                    if (varIndex >= 0 && varIndex < zMatrix.getColumnDimension()) {\n                       // Check row indices validity (0, nf, nf-n)\n                       if (nfPointIndex < zMatrix.getRowDimension() && pointIndexNfMinusN >= 0 && pointIndexNfMinusN < zMatrix.getRowDimension()) {\n                           zMatrix.setEntry(0, varIndex, Math.sqrt(TWO) / (stepa * stepb));\n                           zMatrix.setEntry(nfPointIndex, varIndex, Math.sqrt(HALF) / rhosq);\n                           zMatrix.setEntry(pointIndexNfMinusN, varIndex,\n                                         -zMatrix.getEntry(0, varIndex) - zMatrix.getEntry(nfPointIndex, varIndex));\n                       }\n                    }\n                }\n            } else { // Updates for points 2n+1..npt\n                 // Variables ipt, jpt (1-based), iptIndex, jptIndex (0-based) were calculated earlier\n                 final int iptIndex = ipt - 1;\n                 final int jptIndex = jpt - 1;\n\n                 // Update ZMAT column nf-n-1 based on points 0, nf, ipt, jpt\n                 final int zcol = nf - n - 1; // Column index NFXM = NF - N - 1\n                 if (zcol >= 0 && zcol < zMatrix.getColumnDimension()) { // Check column index validity\n                    // Check row indices validity (0, nf, ipt, jpt)\n                    if (nfPointIndex < zMatrix.getRowDimension() && ipt >= 0 && ipt < zMatrix.getRowDimension() && jpt >= 0 && jpt < zMatrix.getRowDimension()) {\n                        zMatrix.setEntry(0, zcol, recip);            // Row 0 (related to XBASE)\n                        zMatrix.setEntry(nfPointIndex, zcol, recip); // Row nf (related to point nf)\n                        zMatrix.setEntry(ipt, zcol, -recip);         // Row ipt (related to point ipt)\n                        zMatrix.setEntry(jpt, zcol, -recip);         // Row jpt (related to point jpt)\n                    }\n                 }\n\n                 // Update off-diagonal Hessian element H(jptIndex, iptIndex)\n                 // Assuming ipt <= jpt from calculation earlier\n                 final int i0 = iptIndex;\n                 final int j0 = jptIndex;\n                 // Calculate index in packed storage (assuming lower triangle column-wise or upper triangle row-wise)\n                 // Formula for index(j,i) where j>=i is j*(j+1)/2 + i\n                 final int ih = j0 * (j0 + 1) / 2 + i0;\n\n                 // Get required values for the update formula\n                 final double xipt = interpolationPoints.getEntry(nfm, iptIndex); // Displacement of point nf along axis ipt\n                 final double xjpt = interpolationPoints.getEntry(nfm, jptIndex); // Displacement of point nf along axis jpt\n                 final double tmp = xipt * xjpt;\n                 final double fipt = fAtInterpolationPoints.getEntry(ipt); // Value at point ipt\n                 final double fjpt = fAtInterpolationPoints.getEntry(jpt); // Value at point jpt\n\n                 if (tmp == ZERO) {\n                    // Avoid division by zero; set second derivative estimate to zero\n                    modelSecondDerivativesValues.setEntry(ih, ZERO);\n                    // Optionally, log a warning that a second derivative could not be estimated due to zero step product.\n                 } else {\n                    // Update Hessian element H(jptIndex, iptIndex)\n                    modelSecondDerivativesValues.setEntry(ih, (fbeg - fipt - fjpt + f) / tmp);\n                 }\n            } // End model updates block\n\n        } // End loop over nfm (generating points 1..npt)\n\n    } // end prelim method\n} // end helper class definition\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}