{
    "generation": "    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     * @since 1.2\n     */\n    public static long safeMultiply(long val1, int val2) {\n        switch (val2) {\n            case -1:\n                // Special case for Long.MIN_VALUE * -1, as it overflows but the standard check below calculates incorrectly\n                if (val1 == Long.MIN_VALUE) {\n                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n                }\n                return -val1;\n            case 0:\n                return 0L;\n            case 1:\n                return val1;\n        }\n        // Catch the Integer.MIN_VALUE case that won't be caught by the check below\n        if (val2 == Integer.MIN_VALUE) {\n             if (val1 == -1) {\n                // This case is OK, -1 * Integer.MIN_VALUE fits in a long (2^31). Handled by standard path.\n             } else {\n                 // Any other multiplication with Integer.MIN_VALUE (except 0 or 1 which are handled above)\n                 // will overflow or be Long.MIN_VALUE.\n                 // We need to check this case explicitly because multiplication might result in Long.MIN_VALUE\n                 // which would make the division check fail. Example: Long.MIN_VALUE/2 * Integer.MIN_VALUE overflows,\n                 // but the standard check might pass incorrectly.\n                 // However, the simplest path is to delegate to the long * long multiplication,\n                 // as that handles the MIN_VALUE cases correctly.\n                 return safeMultiply(val1, (long)val2);\n             }\n        }\n        // Standard check works for non-MIN_VALUE integers and the -1 * Integer.MIN_VALUE case\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n          throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        return total;\n    }\n\n    /**\n     * Multiply two values throwing an exception if overflow occurs.\n     * \n     * @param val1  the first value\n     * @param val2  the second value\n     * @return the new total\n     * @throws ArithmeticException if the value is too big or too small\n     */\n    public static long safeMultiply(long val1, long val2) {\n        if (val2 == 1) {\n            return val1;\n        }\n        if (val2 == 0) {\n            return 0L;\n        }\n        if (val2 == -1) {\n            if (val1 == Long.MIN_VALUE) {\n                 throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n            }\n            return -val1;\n        }\n        long total = val1 * val2;\n        if (total / val2 != val1) {\n            throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        // Long.MIN_VALUE * -1 is checked above, Long.MIN_VALUE / -1 needed here\n        // If val1 is Long.MIN_VALUE and val2 is -1, the previous check fails because\n        // total / val2 overflows. Handled above.\n        // If val1 is Long.MIN_VALUE and val2 is not -1, the check works correctly.\n        // Special check for Long.MIN_VALUE / -1 which returns Long.MIN_VALUE\n        if (val1 == Long.MIN_VALUE && val2 == -1) {\n             // Should have been caught above, but safeguard\n             throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n        }\n        // Check for the other edge case: Long.MIN_VALUE / Long.MIN_VALUE = 1\n        // Handled by the main check total / val2 != val1 -> (val1*val2)/val2 != val1\n        return total;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}