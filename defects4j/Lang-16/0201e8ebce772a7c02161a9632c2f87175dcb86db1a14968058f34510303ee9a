{
    "generation": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (lower or upper case), it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // LANG-1006 protect against poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value. See LANG-1006.\n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        // Handle hex numbers, including upper case 'X' for LANG-1139\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n            // Check length to avoid NumberFormatException from Integer.decode(\"\")\n            final int hexDigits = str.length() - (str.startsWith(\"-\") ? 3 : 2); // 0x or -0x\n            if (hexDigits == 0) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            // If the leading character is a minus sign, createInteger() handles it correctly\n            return createInteger(str);\n        }\n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        // Correctly find the exponent character 'e' or 'E'\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        // Detect if the input is potentionaly valid floating point number:\n        // - Number must contain either a decimal point or an exponent\n        //   character, or be suffixed with 'f', 'F', 'd', or 'D'.\n        // - Only numbers containing 'e' or 'E' may have an exponent part.\n        // - A number may not have exponent part without a preceding mantissa.\n        // - Exponent part may be empty, have a sign ('+' or '-'), and digits.\n\n        // Scientific notation specific validation:\n        if (expPos > -1) {\n            // Must not be the first character:\n            if (expPos == 0) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            // Must be preceded by digits:\n            if (!Character.isDigit(str.charAt(expPos - 1)) && str.charAt(expPos -1) != '.') {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            // Check exponent sign:\n            if (expPos < str.length() - 1 && (str.charAt(expPos + 1) == '+' || str.charAt(expPos + 1) == '-')) {\n                // Check digit follows sign:\n                if (expPos + 2 == str.length()) { // No digits after sign\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            }\n            // Check exponent position relative to decimal:\n            if (decPos != -1 && expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n        // Split the string into parts based on decimal and exponent positions\n        if (decPos > -1) {\n            if (expPos > -1) {\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n\n        // Check for type suffixes (L, F, D)\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            // Extract exponent part if present, excluding the suffix\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null; // No exponent part or format issue handled later\n            }\n            String numeric = str.substring(0, str.length() - 1); // Number part without suffix\n            // Note: allZeros check uses mantissa from original string and potentially null exp here\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // Check if the format is valid for Long/BigInteger (no decimal, no exponent)\n                    if (dec == null && exp == null) {\n                         // Check if the numeric part (without L) consists of digits (optional sign)\n                         boolean isNeg = numeric.charAt(0) == '-';\n                         boolean isDigitString = isDigits(isNeg ? numeric.substring(1) : numeric);\n                         if (isDigitString && (!isNeg || numeric.length() > 1)) { // Ensure '-' is not the only char\n                             try {\n                                 return createLong(numeric);\n                             } catch (NumberFormatException nfe) { // NOPMD\n                                 // Fall through to BigInteger below\n                             }\n                             return createBigInteger(numeric);\n                         }\n                    }\n                    // If format is invalid for L/l suffix\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        // Check for loss of precision (infinite or zero for non-zero input)\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number and fall through to Double/BigDecimal\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        // Check for loss of precision (infinite or zero for non-zero input)\n                        // Use doubleValue() for comparison\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) { // NOPMD\n                        // ignore the bad number and fall through to BigDecimal\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) { // NOPMD\n                        // ignore the bad number, fall through to default error\n                    }\n                    //$FALL-THROUGH$\n                default : // Handles invalid suffix or previous fallthroughs\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            // No type suffix, last char is digit or '.'\n            // Extract exponent part if present\n            if (expPos > -1 && expPos < str.length()) {\n                 // Handle case like \"1e\", \"1.2e\" which are invalid because exponent is empty\n                 if (expPos == str.length() - 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                exp = str.substring(expPos + 1);\n            } else {\n                exp = null;\n            }\n\n            if (dec == null && exp == null) {\n                // Must be Integer, Long, or BigInteger\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n            } else {\n                // Must be Float, Double, or BigDecimal\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    // Use doubleValue() for comparison\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { // NOPMD\n                    // ignore the bad number\n                }\n                return createBigDecimal(str);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}