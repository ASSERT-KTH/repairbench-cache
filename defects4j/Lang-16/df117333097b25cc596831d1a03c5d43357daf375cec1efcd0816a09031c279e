{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport org.apache.commons.lang3.StringUtils;\n\n// Assuming NumberUtils class structure and availability of StringUtils\n// Assuming existence of a suitable isAllZeros helper method defined elsewhere in the class\npublic class NumberUtils {\n\n    // Helper method assumed to exist elsewhere in the class\n    // A simple possible implementation for illustration:\n    private static boolean isAllZeros(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return true; // Treat empty as all zeros\n        }\n        // Basic implementation: check if all characters are '0' after optional sign\n        int start = 0;\n        if (str.charAt(0) == '-' || str.charAt(0) == '+') {\n            start = 1;\n        }\n        if (start >= str.length()) return true; // Only sign present\n\n        for (int i = start; i < str.length(); i++) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        // Check if the string had at least one digit (or was just a sign)\n        return str.length() > start;\n    }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code>, <code>0X</code>, <code>-0x</code>, or <code>-0X</code>,\n     * it will be interpreted as a hexadecimal integer. Values with leading\n     * <code>0</code>'s will **not** be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Hexadecimal check (case-insensitive)\n        if (str.startsWith(\"0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0x\") || str.startsWith(\"-0X\")) {\n             // Reject L/l suffix for hex, as Java Integer/Long/BigInteger hex parsing doesn't support it\n             final char lastCharHex = str.charAt(str.length() - 1);\n             if (lastCharHex == 'l' || lastCharHex == 'L') {\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             try {\n                 // Integer.decode handles \"0x\", \"0X\", \"#\" prefixes and sign\n                 return Integer.decode(str);\n             } catch (final NumberFormatException nfe) { // NOPMD - Fallthrough intended\n                 try {\n                     // Long.decode handles \"0x\", \"0X\", \"#\" prefixes and sign\n                     return Long.decode(str);\n                 } catch (final NumberFormatException nfe2) { // NOPMD - Fallthrough intended\n                     // BigInteger constructor needs prefix/sign handled manually\n                     int sign = 1;\n                     // Determine start index after prefix and optional sign\n                     int startIndex = (str.charAt(0) == '-') ? 3 : 2;\n                     if (str.charAt(0) == '-') {\n                         sign = -1;\n                     }\n                     // Check if startIndex is valid (string might be just \"-0x\")\n                     if (startIndex >= str.length()) {\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n                     final String numericPart = str.substring(startIndex);\n                     // Check for empty numeric part after prefix\n                     if (numericPart.isEmpty()) {\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n                     try {\n                         return new BigInteger(numericPart, 16).multiply(BigInteger.valueOf(sign));\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // Rethrowing original exception might be less informative\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n                 }\n             }\n        }\n\n        // Protection against \"--\" (standard parsers might handle differently or throw NFE; ensure consistent NFE)\n        if (str.startsWith(\"--\")) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant; // Mantissa part for allZeros check\n        String exp; // Exponent part for allZeros check\n\n        final int decPos = str.indexOf('.');\n        // Use indexOfAny to find the first occurrence of 'e' or 'E'\n        final int expPos = StringUtils.indexOfAny(str, \"eE\");\n\n\n        // Validate relative positions of '.' and 'e'/'E'\n        if (expPos > -1 && decPos > -1 && expPos < decPos) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // Check for empty exponent string like \"1.2e\" or \"123e\"\n        if (expPos > -1 && expPos == str.length() - 1) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        // Simple parsing for mantissa/exponent parts for the 'allZeros' check ONLY.\n        // It does not need to be perfect, just good enough for isAllZeros.\n        // Actual number conversion uses standard Java methods.\n        if (expPos > -1) {\n            if (decPos > -1) { mant = str.substring(0, decPos); }\n            else { mant = str.substring(0, expPos); }\n            exp = str.substring(expPos + 1);\n        } else {\n            if (decPos > -1) { mant = str.substring(0, decPos); }\n            else { mant = str; }\n            exp = null;\n        }\n\n\n        if (!Character.isDigit(lastChar) && lastChar != '.') { // Check for type qualifier (L, F, D)\n            // Extract the part before the qualifier\n            final String numeric = str.substring(0, str.length() - 1);\n\n            // Use indexOfAny for 'e' or 'E' in numeric part\n            final int numericExpPos = StringUtils.indexOfAny(numeric, \"eE\");\n\n            // Check for empty exponent part in 'numeric', e.g. \"1.2eF\" -> numeric=\"1.2e\" -> invalid\n            if (numericExpPos > -1 && numericExpPos == numeric.length() - 1) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n\n            // Re-parse 'numeric' for 'allZeros' check specific to qualifier cases.\n            String qualMant, qualExp; // Parts of 'numeric' string\n            final int qualDecPos = numeric.indexOf('.');\n\n            if (numericExpPos > -1) {\n                if (qualDecPos > -1) { qualMant = numeric.substring(0, qualDecPos); }\n                else { qualMant = numeric.substring(0, numericExpPos); }\n                qualExp = numeric.substring(numericExpPos + 1);\n            } else {\n                if (qualDecPos > -1) { qualMant = numeric.substring(0, qualDecPos); }\n                else { qualMant = numeric; }\n                qualExp = null;\n            }\n\n            // Assuming isAllZeros is available and handles sign/empty strings appropriately\n            final boolean allZeros = isAllZeros(qualMant) && isAllZeros(qualExp);\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // L/l suffix requires integer format (no decimal, no exponent within numeric)\n                    if (qualDecPos == -1 && numericExpPos == -1) {\n                         try {\n                             // Use Long.valueOf - handles sign, throws NFE if invalid format\n                             return Long.valueOf(numeric);\n                         } catch (final NumberFormatException nfe) { // NOPMD\n                             // Fallback to BigInteger if Long fails (too big or invalid format)\n                             try {\n                                 return new BigInteger(numeric); // Handles sign, throws NFE if invalid\n                             } catch (final NumberFormatException nfe2) { // NOPMD\n                                 // If BigInteger also fails, the format was fundamentally wrong\n                                 throw new NumberFormatException(str + \" is not a valid number.\");\n                             }\n                         }\n                    }\n                    // If format has dec or exp (e.g., \"1.2L\", \"1e2L\"), it's invalid for L/l.\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = Float.valueOf(numeric);\n                        // Check for infinity or zero loss (mantissa/exp non-zero but result is 0)\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                        // Fall through to BigDecimal if Float is Inf or imprecise Zero (as per test case expectation)\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // If Float format itself is invalid, throw NFE - do not fall through\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                     try {\n                         // Try BigDecimal as Float was infinite or zero\n                         return new BigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // If BigDecimal also fails, something is wrong\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = Double.valueOf(numeric);\n                        // Corrected check: d.doubleValue()\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                        // Fall through to BigDecimal if Double is Inf or imprecise Zero\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // If Double format itself is invalid, throw NFE - do not fall through\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                    // Fall through to BigDecimal if Double insufficient\n                    try {\n                        return new BigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                         // If BigDecimal also fails, something is wrong\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n                default :\n                    // Qualifiers other than L, F, D are invalid\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else { // No type qualifier (or last char is '.' which Character.isDigit handles)\n            // String ends in digit or '.'\n\n            // Determine type based on structure (presence of '.', 'e', 'E')\n            if (decPos == -1 && expPos == -1) { // Potential Integer/Long/BigInteger\n                 try {\n                     return Integer.valueOf(str);\n                 } catch (final NumberFormatException nfe) { // NOPMD\n                     try {\n                         return Long.valueOf(str);\n                     } catch (final NumberFormatException nfe2) { // NOPMD\n                         try {\n                            return new BigInteger(str);\n                         } catch (final NumberFormatException nfe3) { // NOPMD\n                            // If all fail, the original string is not a valid integer format\n                            throw new NumberFormatException(str + \" is not a valid number.\");\n                         }\n                     }\n                 }\n            } else { // Potential Float/Double/BigDecimal\n                // Assuming isAllZeros is available and handles sign/empty strings appropriately\n                final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n                try {\n                    final Float f = Float.valueOf(str);\n                    // LANG-521 \"2.\" is handled correctly by Float.valueOf(\"2.\") -> 2.0f\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) { /* NOPMD */ // Ignore Float failure (format or range), try Double\n                }\n                try {\n                    final Double d = Double.valueOf(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { /* NOPMD */ // Ignore Double failure (format or range), try BigDecimal\n                }\n                // Fallback to BigDecimal\n                try {\n                    return new BigDecimal(str);\n                } catch (final NumberFormatException e) { // NOPMD\n                    // If all fail (including BigDecimal), the string is definitely invalid\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}