{
    "generation": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.utils.CharsetNames;\n\n// Assuming other necessary imports and the surrounding class structure exist.\n// The fix is applied only within the writePaxHeaders function.\n\nclass TarArchiveOutputStream { // Keep original class name context if needed\n\n    // Dummy fields/methods assumed to exist for context\n    protected void putArchiveEntry(TarArchiveEntry entry) throws IOException { /* underlying implementation */ }\n    protected void write(byte[] b) throws IOException { /* underlying implementation */ }\n    protected void closeArchiveEntry() throws IOException { /* underlying implementation */ }\n    protected String stripTo7Bits(String name) { /* underlying implementation */ return name; } // Placeholder\n\n\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        // PAX header names should correspond to the entries they describe,\n        // but the header entry itself is a file, not a directory.\n        // Ensure the generated PAX header name does not end with a slash,\n        // even if the original entry name did (was a directory).\n        String name = entryName;\n        if (name.endsWith(\"/\")) {\n            // Remove trailing slash for directory entries to form the base name\n            name = name.substring(0, name.length() - 1);\n        }\n        // Sanitize the base name for the PAX header file name structure\n        name = \"./PaxHeaders.X/\" + stripTo7Bits(name);\n\n        // Truncate name if needed, similar to regular entries\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n\n        // Create the PAX header entry as a file ('x' type)\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            // Calculate initial length guess for the PAX record line\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            // Get the actual byte length in UTF-8\n            int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            // Adjust the length field (`len`) until it matches the actual byte length\n            while (len != actualLength) {\n                // Recalculate the line with the updated length field\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                actualLength = line.getBytes(CharsetNames.UTF_8).length;\n            }\n            // Write the correctly formatted line to the StringWriter\n            w.write(line);\n        }\n        // Get the complete PAX header content as bytes\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n        // Set the size of the PAX header entry based on its content length\n        pex.setSize(data.length);\n        // Write the PAX header entry's metadata (including size)\n        putArchiveEntry(pex);\n        // Write the PAX header entry's content\n        write(data);\n        // Close the PAX header entry\n        closeArchiveEntry();\n    }\n} // End of class context",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}