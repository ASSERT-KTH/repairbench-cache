{
    "generation": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.StandardCharsets; // Assuming usage of StandardCharsets if available\nimport java.util.Map;\n// Assuming existence of these classes/constants based on context\n// import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n// import org.apache.commons.compress.archivers.tar.TarConstants;\n// import org.apache.commons.compress.utils.CharsetNames;\n// Assuming stripTo7Bits is accessible (e.g., static import or via TarUtils)\n// Assuming putArchiveEntry, write, closeArchiveEntry are methods of the enclosing class\n\n// Placeholder definitions for missing types to allow compilation check\nclass TarArchiveEntry {\n    private String name;\n    private byte linkFlag;\n    private long size;\n    public TarArchiveEntry(String name, byte linkflag) { this.name = name; this.linkFlag = linkflag; this.size = 0;}\n    public void setSize(long size) { this.size = size; }\n    public long getSize() { return this.size; }\n    public String getName() { return this.name; }\n    public boolean isDirectory() { return name.endsWith(\"/\"); }\n}\nclass TarConstants {\n    public static final int NAMELEN = 100;\n    public static final byte LF_PAX_EXTENDED_HEADER_LC = 'x';\n    public static final byte LF_DIR = '5';\n}\nclass CharsetNames {\n    public static final String UTF_8 = StandardCharsets.UTF_8.name(); // Use standard Charset name\n}\n// Dummy methods assumed to be part of the enclosing class\nabstract class DummyTarOutputStream {\n    abstract void putArchiveEntry(TarArchiveEntry pex) throws IOException;\n    abstract void write(byte[] data) throws IOException;\n    abstract void closeArchiveEntry() throws IOException;\n    String stripTo7Bits(String name) {\n        final StringBuilder sb = new StringBuilder(name.length());\n        for (int i = 0; i < name.length(); i++) {\n            char c = name.charAt(i);\n            if (c > 127) {\n                // The error message showed 'v' instead of '?',\n                // but the standard stripTo7Bits replaces with '?'.\n                // Let's stick to '?' for correctness unless 'v' is intentional.\n                 sb.append('?');\n                // If 'v' is indeed the expected behavior:\n                // sb.append('v');\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n        // If the original entry name ended with '/', the PAX header name\n        // might too. This causes the TarArchiveEntry constructor to mark it\n        // as a directory, which leads to problems as PAX headers should\n        // have data and size != 0.\n        // Remove trailing '/' to prevent this.\n        while (name.endsWith(\"/\")) {\n            name = name.substring(0, name.length() - 1);\n        }\n\n        // TarEntry's constructor would think this is a directory\n        // and not allow any data to be written\n        // (Comment moved down as the fix addresses this)\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter w = new StringWriter();\n        // Use StandardCharsets.UTF_8 for clarity and correctness\n        java.nio.charset.Charset utf8 = StandardCharsets.UTF_8;\n\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n            // Ensure the length calculation uses byte length in UTF-8\n            byte[] lineBytes = line.getBytes(utf8);\n            int actualLength = lineBytes.length;\n            while (len != actualLength) {\n                // Adjust for cases where length < 10 or > 100\n                // or where UTF-8 encoding isn't a single octet\n                // per character.\n                // Must be in loop as size may go from 99 to 100 in\n                // first pass so we'd need a second.\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                lineBytes = line.getBytes(utf8);\n                actualLength = lineBytes.length;\n            }\n            w.write(line);\n        }\n        byte[] data = w.toString().getBytes(utf8);\n        pex.setSize(data.length);\n        putArchiveEntry(pex);\n        write(data);\n        closeArchiveEntry();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}