{
    "generation": "void writePaxHeaders(String entryName, Map<String, String> headers)\n    throws IOException {\n    // First, use the 7-bit conversion of the entry name.\n    // If the original entry name ends with a '/', remove it so that\n    // the pax header entry will not be interpreted as a directory.\n    String paxEntryNameCore = stripTo7Bits(entryName);\n    if (paxEntryNameCore.endsWith(\"/\")) {\n        paxEntryNameCore = paxEntryNameCore.substring(0, paxEntryNameCore.length() - 1);\n    }\n    String name = \"./PaxHeaders.X/\" + paxEntryNameCore;\n    if (name.length() >= TarConstants.NAMELEN) {\n        name = name.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry pex = new TarArchiveEntry(name, TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n    StringWriter w = new StringWriter();\n    for (Map.Entry<String, String> h : headers.entrySet()) {\n        String key = h.getKey();\n        String value = h.getValue();\n        int len = key.length() + value.length()\n            + 3 /* blank, equals and newline */\n            + 2 /* guess 9 < actual length < 100 */;\n        String line = len + \" \" + key + \"=\" + value + \"\\n\";\n        int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        while (len != actualLength) {\n            // Adjust for cases where length < 10, > 100 or the UTF-8 encoding requires more than one byte per character.\n            len = actualLength;\n            line = len + \" \" + key + \"=\" + value + \"\\n\";\n            actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        }\n        w.write(line);\n    }\n    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n    pex.setSize(data.length);\n    putArchiveEntry(pex);\n    write(data);\n    closeArchiveEntry();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}