{
    "generation": "import java.io.IOException;\nimport java.io.StringWriter;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarConstants;\nimport org.apache.commons.compress.utils.CharsetNames;\n\n// The user requested only the fixed function. Other necessary imports and class structure are assumed.\n// This code should replace the buggy version within its original class (likely TarArchiveOutputStream).\n\n    /**\n     * Writes a PAX extended header with the given map as contents.\n     * @param entryName The name of the entry the PAX header describes. Used to generate the PAX header name.\n     * @param headers The map of key-value pairs for the header.\n     * @throws IOException on error\n     * @since 1.4\n     */\n    void writePaxHeaders(String entryName,\n                         Map<String, String> headers) throws IOException {\n        // Construct name for the PAX header entry, e.g., \"./PaxHeaders.X/entryName\"\n        String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n\n        // PAX specification requires header names not to end with a slash.\n        // Furthermore, the TarArchiveEntry constructor treats names ending with '/'\n        // as directories, overwriting the link flag and mode, which breaks PAX headers.\n        // Remove trailing slash if present to prevent this. Fixes COMPRESS-199 / related test failure.\n        if (name.endsWith(\"/\")) {\n            name = name.substring(0, name.length() - 1);\n        }\n\n        // Ensure the generated name fits within the TAR header's name field limit.\n        // Check length *after* potentially removing the slash.\n        // Truncate if necessary, leaving space for potential null terminator handling by underlying methods.\n        if (name.length() >= TarConstants.NAMELEN) {\n            name = name.substring(0, TarConstants.NAMELEN - 1);\n        }\n\n        // Create the TarArchiveEntry for the PAX header.\n        // Use the constructor specifying the name and the PAX header type flag.\n        // Since 'name' no longer ends with '/', the constructor will correctly use the\n        // provided LF_PAX_EXTENDED_HEADER_LC ('x') flag and not misinterpret it as a directory.\n        TarArchiveEntry pex = new TarArchiveEntry(name,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        // Use StringWriter to efficiently build the header lines in memory.\n        StringWriter w = new StringWriter();\n        for (Map.Entry<String, String> h : headers.entrySet()) {\n            String key = h.getKey();\n            String value = h.getValue();\n\n            // Format the PAX header line according to specification: \"length key=value\\n\"\n            // The 'length' field is the decimal length of the entire record including the length field itself.\n            // We must calculate this length accurately, considering UTF-8 encoding.\n            // Start with an initial guess for the total length.\n            int len = key.length() + value.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* initial guess for length field size, e.g., \"NN \" */;\n            String line = len + \" \" + key + \"=\" + value + \"\\n\";\n\n            // PAX headers MUST be encoded in UTF-8. Calculate the actual byte length.\n            byte[] lineBytes = line.getBytes(CharsetNames.UTF_8);\n            int actualLength = lineBytes.length;\n\n            // Iteratively refine the length calculation. If the actual byte length\n            // requires a different number of digits for the 'length' field than initially guessed,\n            // recalculate until the 'len' value matches the 'actualLength' of the UTF-8 encoded string.\n            // This loop handles adjustments for length field size changes (e.g., 9->10, 99->100)\n            // and multi-byte UTF-8 characters.\n            while (len != actualLength) {\n                len = actualLength;\n                line = len + \" \" + key + \"=\" + value + \"\\n\";\n                lineBytes = line.getBytes(CharsetNames.UTF_8);\n                actualLength = lineBytes.length;\n            }\n            // Append the correctly formatted line to the writer.\n            w.write(line);\n        }\n\n        // Get the complete PAX header content as a byte array, encoded in UTF-8.\n        byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n\n        // Set the size field of the TarArchiveEntry for the PAX header. This is critical.\n        // If not set, it defaults to 0, leading to errors when writing the data.\n        pex.setSize(data.length);\n\n        // Write the TAR header for the PAX entry ('pex') to the output stream.\n        // This writes the metadata (name, size, type flag 'x', etc.) to the archive.\n        // The stream's internal state (currEntry, currBytesRemaining) is updated.\n        // Because 'pex' is correctly identified as a non-directory, currBytesRemaining\n        // will be set to pex.getSize() (i.e., data.length).\n        putArchiveEntry(pex);\n\n        // Write the actual PAX header content (the collected lines) to the output stream.\n        // This write operation will succeed because the number of bytes 'data.length'\n        // matches the expected size stored in currBytesRemaining.\n        write(data);\n\n        // Finalize the PAX header entry in the TAR archive.\n        closeArchiveEntry();\n    }\n\n    // Assume stripTo7Bits is defined elsewhere in the class or is accessible.\n    // Example placeholder:\n    private String stripTo7Bits(String name) {\n        // Placeholder: Replace non-7-bit ASCII characters.\n        // The actual implementation might be more sophisticated.\n        StringBuilder sb = new StringBuilder();\n        for (char ch : name.toCharArray()) {\n            if (ch > 0 && ch < 128) {\n                sb.append(ch);\n            } else {\n                sb.append(\"?\"); // Replace with placeholder\n            }\n        }\n        return sb.toString();\n    }\n\n    // Assume putArchiveEntry, write, closeArchiveEntry are methods of the surrounding class.\n    // Example placeholders:\n    // abstract void putArchiveEntry(TarArchiveEntry entry) throws IOException;\n    // abstract void write(byte[] b) throws IOException;\n    // abstract void closeArchiveEntry() throws IOException;\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}