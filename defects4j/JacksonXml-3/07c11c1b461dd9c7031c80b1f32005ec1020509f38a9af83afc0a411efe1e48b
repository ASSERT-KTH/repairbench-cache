{
    "generation": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        // Modified slightly from Jackson core base class: may already have token\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                // Jackson-core returns \"_textBuffer.contentsAsString()\";\n                // we have slightly different storage so:\n                return _currText;\n            }\n            // otherwise null; fall through\n            _updateState(t);\n            return null;\n        }\n\n        // Ok: no queued token, need to fetch one...\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought it might be leaf, we were wrong\n            if (_mayBeLeaf) {\n                // Ok, need to change state but NOT current token...\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                // and START_OBJECT is the current token... except we won't return it now\n                _currToken = JsonToken.START_OBJECT;\n                return null; // not a text value for sure\n            }\n            // Otherwise, if we are in array, need to skip\n            if (_parsingContext.inArray()) {\n                // skip\n                token = _xmlTokens.next();\n                _mayBeLeaf = true; // yup, could be leaf\n                continue;\n            }\n            // In object, need to find FIELD_NAME first\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            // note: this will also clear \"_mayBeLeaf\"\n            // But: may need to recurse, if name is wrapper...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                // If so, loop; this will skip current START_ELEMENT, return FIELD_NAME\n                _xmlTokens.repeatStartElement();\n                // and reset state\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null; // Field name, not text value\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // If we thought we might get leaf, we basically got <tag/>, which is empty String\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            // Otherwise, just need to close open scope etc\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            // And what is the text value? null\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                // an attribute means we have virtual FIELD_NAME, START_OBJECT first...\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText(); // should be same as getLocalName, but just in case\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT; // won't be returned tho\n            } else {\n                // regular attribute name, matches FIELD_NAME\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            // either way, we point to FIELD_NAME, return null text value\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            // Gotcha! This is the textual value, return\n            return _currText; // FIX: Return the text value found\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                // and this is the value, return\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            // And the value becomes the NEXT token...\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME; // current token is field name\n            // which means we return null for text value\n            break;\n        case XmlTokenStream.XML_END: // Added [dataformat-xml#17]\n             // Actually, should be fine to just return null here\n             // _currToken = null;\n             _currToken = null; // just to be safe\n             _parsingContext = _parsingContext.getParent(); // and [dataformat-xml#19]\n        }\n        // If we fall here, no VALUE_STRING found (or reached EOF), return null\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}