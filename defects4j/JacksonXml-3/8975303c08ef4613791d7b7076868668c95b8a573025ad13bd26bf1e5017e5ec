{
    "generation": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                // Since _currText was null'd in nextToken(), need to get text:\n                // (note: this differs from nextIntValue() etc where value is fine)\n                if (_currText == null) { // sanity check\n                    throw new IllegalStateException(\"nextTextValue() called when current token is \"+_currToken+\"; but text is null\");\n                }\n                return _currText;\n            }\n            // Nope; non-text value\n            _updateState(t); // to ensure state updated (caller may miss call to nextToken())\n            return null;\n        }\n\n        // otherwise need to read the next token\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                // Error: FIELD_NAME must be followed by a value; but what would\n                // this mean here? Punt, must be object/array\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                // note: no text value to return\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                // another element; unless we hit END_ELEMENT should be START_OBJECT?\n                // or, maybe we are in non-wrapped List, getting non-first element?\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            // Nope, field name\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                 // If name is in names to wrap list, we need to repeat the START_ELEMENT\n                 // and handle things as if it was an array to ensure we get wrapping\n                 // (otherwise handling differs between single-element-arrays and others)\n                _xmlTokens.repeatStartElement();\n                // fall through to array case handled below\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            // can not return String value, need value but have FIELD_NAME\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // If we thought we might get leaf, we are basically done with\n            // element; empty text element.\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            // Otherwise, closing element means closing scope; either array or object\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more... attributes means object\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // and we need to push back FIELD_NAME, return START_OBJECT\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                // otherwise regular field name:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            // Voil\u00e0: got the text value!\n            return _currText;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n\n                // Got text!\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property... standard handling?\n            // 10-Mar-2011, tatu: Looks like we must assume Structure value,\n            //   i.e. FIELD_NAME + VALUE_STRING (created from text)\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            // fall through; no textual value to return (got FIELD_NAME)\n            break;\n\n        case XmlTokenStream.XML_END: // end-of-input? Shouldn't really happen but...\n            _currToken = null;\n        }\n        // We get here if we did not get text value; have other artifacts\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}