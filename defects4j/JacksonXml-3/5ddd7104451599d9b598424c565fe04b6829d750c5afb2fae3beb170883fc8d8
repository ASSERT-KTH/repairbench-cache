{
    "generation": "@Override\npublic String nextTextValue() throws IOException\n{\n    _binaryValue = null;\n    // If a next\u2010token was already pre\u2010set, use that:\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n        if (t == JsonToken.VALUE_STRING) {\n            // fast\u2010path: we already have the text\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // handle start\u2010element (FIELD_NAME / START_OBJECT) cases\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // handle all other XML events\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        if (_mayBeLeaf) {\n            // empty leaf: return empty String, not null\n            _mayBeLeaf = false;\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = \"\");\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        break;\n\n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n        } else {\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        break;\n\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        // BUGFIX: attribute\u2010values are String\u2010valued; return immediately\n        _currText = _xmlTokens.getText();\n        _currToken = JsonToken.VALUE_STRING;\n        return _currText;\n\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            // skip the matching end\u2010element\n            _xmlTokens.skipEndElement();\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        }\n        // non\u2010leaf text turns into a named String property\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        _currToken = JsonToken.FIELD_NAME;\n        break;\n\n    case XmlTokenStream.XML_END:\n        _currToken = null;\n    }\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}