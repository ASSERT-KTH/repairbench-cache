{
    "generation": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                // 23-Nov-2016, tatu: As per [dataformat-xml#211], need similar handling\n                //    as in nextToken() for empty element... although not sure if this\n                //    can actually be hit. But added for completeness\n                if (_currText == null) {\n                     _currText = \"\";\n                }\n                return _currText;\n            }\n            // Nope; structural. Any pending text to output?\n            // (Ugly check, but seems necessary for now)\n            if (_currToken == JsonToken.END_OBJECT && _currText != null && _currText.length() > 0) {\n                 String result = _currText;\n                _currText = \"\";\n                 return result;\n            }\n\n            // If not, fall through, need to advance\n            _updateState(t);\n            // note: if we get START_OBJECT, we might have recognized empty element\n            // and need to return \"\"\n            if (t == JsonToken.START_OBJECT || t == JsonToken.START_ARRAY) {\n                 if (_mayBeLeaf) { // yes, looks like it was an empty element\n                     return \"\";\n                 }\n            }\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might be encountering leaf node, we were wrong...\n            if (_mayBeLeaf) {\n                // If so, need to change state; START_OBJECT, FIELD_NAME pending\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null; // no text value\n            }\n            if (_parsingContext.inArray()) {\n                // If in array, need to skip -- caller may perhaps want to skip?\n                // Let's assume that for now\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            // otherwise regular element, must be FIELD_NAME\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            // Ok: virtual wrapping?\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                // If so, need to skip the virtual END_OBJECT, START_ARRAY, START_OBJECT, FIELD_NAME\n                // Need to repeat START_ELEMENT now; but achieve END_OBJECT, START_ARRAY first\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null; // no text value yet\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // If we were thinking this might be a leaf node, we know it is; empty String value\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            // otherwise, closing results in END_ARRAY or END_OBJECT\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                // 09-Jan-2019, tatu: related to [dataformat-xml#328], need this for nextToken()\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                // otherwise regular attribute name: is FIELD_NAME\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            // Need to return the value, not fall through\n            return _currText; // FIX: Added return statement\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            // And leave value available for next call (as field value)\n            break;\n        case XmlTokenStream.XML_END: // end-of-input?\n            _currToken = null;\n            close();\n            break;\n        case XmlTokenStream.XML_CDATA:\n             // TODO: handle CDATA\n             // Fall through for now\n        default: // other events that can't be mapped; error, comment, PI\n            _currText = _xmlTokens.getText();\n            // What should we return? PIs, comments, DOCTYPE? Error?\n            _currToken = JsonToken.VALUE_EMBEDDED_OBJECT;\n        }\n        // Should not get here usually, but if we do, return null:\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}