{
    "generation": "    /**\n     * Method overridden to support more reliable deserialization of\n     * String collections.\n     */\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                // 23-Jun-2017, tatu: Originally we returned `_currText` here but that seems\n                //    problematic wrt state; specifically, seems to skip START_OBJECT for\n                //    attributes section. So let's try this:\n                 _updateState(t);\n                 return _currText;\n//                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                // Ok: encountering a new VALUE_STRING requires generating FIELD_NAME first...\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                // May or may not have name; did we have one pending? Check this first\n                if (_pendingName != null) {\n                     String name = _pendingName;\n                     _pendingName = null;\n                     _parsingContext.setCurrentName(name);\n                } else { // otherwise, need to expose current element name\n                     _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                }\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                // If we are in array, need to repeat current element name:\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            // 23-Jun-2017, tatu: Need to make sure we DON'T consume the START_ELEMENT yet\n            //    ... this is tricky...\n            _pendingName = name;\n\n            _xmlTokens.skipEndElement();\n\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            // Ok: end element means empty String, but only if text segment was possible\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText(); // Is this correct? Or local name? Should be Name.\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                // 23-Jun-2017, tatu: Attributes only possible when we are in Object,\n                //   so this should be fine...\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            // Need to return value to be considered text value\n            return _currText; // Fix applied here\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END: // Added this case to avoid return null without setting _currToken\n            _currToken = null;\n            _parsingContext = null; // Make sure we are not pointing to something invalid\n            break; // Just break, will return null at the end\n\n        // What about comments, processing instructions?\n        case XmlTokenStream.XML_COMMENT:\n        case XmlTokenStream.XML_PROCESSING_INSTRUCTION:\n            // TODO: implement if skipping disabled; for now, always skip\n            break;\n        default:\n            throw _constructError(\"Internal error: unexpected token \"+token);\n        }\n        // fall-through; except for the few cases that return text value, return null:\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}