{
    "generation": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * <p>\n     * Special cases:\n     * <ul>\n     *  <li>The invocations {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n     *      {@code gcd(Integer.MIN_VALUE, 0)} and {@code gcd(0, Integer.MIN_VALUE)}\n     *      throw an {@code ArithmeticException}, because the result would be\n     *      2^31, which is too large for an int value.</li>\n     *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n     *      {@code gcd(x, 0)} is the absolute value of {@code x}, except\n     *      for the special cases above.</li>\n     *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n     *      {@code 0}.</li>\n     * </ul>\n     * </p>\n     *\n     * @param u a number\n     * @param v a number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException if the result cannot be represented as a\n     * non-negative int value.\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        // Handle gcd(0,v) == |v|, gcd(u,0) == |u|, gcd(0,0) == 0\n        if (u == 0) {\n             if (v == Integer.MIN_VALUE) {\n                 // Result is 2^31, which overflows int. Upstream code checks for this.\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n             }\n             return Math.abs(v);\n        }\n        if (v == 0) {\n            if (u == Integer.MIN_VALUE) {\n                // Result is 2^31, which overflows int. Upstream code checks for this.\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u);\n        }\n\n        // Now u != 0 and v != 0.\n        // Handle special case gcd(MIN_VALUE, MIN_VALUE) -> 2^31\n        if (u == Integer.MIN_VALUE && v == Integer.MIN_VALUE) {\n             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        // Handling MIN_VALUE from here is safe since we handle the cases\n        // where the result would be 2^31 above. Other MIN_VALUE cases\n        // like gcd(MIN_VALUE, x) where x != 0 and x != MIN_VALUE are handled\n        // correctly by the algorithm due to use of negative numbers.\n        long uLong = u;\n        long vLong = v;\n        boolean uMin = (u == Integer.MIN_VALUE);\n        boolean vMin = (v == Integer.MIN_VALUE);\n\n        if (!uMin && u > 0) {\n            u = -u;\n        } // make u negative\n        if (!vMin && v > 0) {\n            v = -v;\n        } // make v negative\n\n        // B1. [Find power of 2]\n        int k = 0;\n        // Use long comparison for MIN_VALUE case potential early exit\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        // If k = 31, the gcd is 2^31, handled initially.\n        if (k == 31) {\n           throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                 // Avoid division by 2 of MIN_VALUE / 2 = MIN_VALUE / 2\n                 // It should be MIN_VALUE >> 1 = MAX_VALUE / 2 + 1\n                 // But this case is unlikely given prior checks & logic\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            // Compute (v - u) / 2, replacing t\n            // Check for potential overflow in (v-u) - should not happen bc u,v negative\n            t = (v - u) / 2;\n        } while (t != 0);\n\n        // gcd is -u*2^k\n        // Check for MIN_VALUE before potentially calculating 1 << 31\n        if (u == Integer.MIN_VALUE) { // This can happen if original inputs had gcd = 2^31\n             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // Final result is -u * (1 << k).\n        // -u is positive since u is negative.\n        // If -u * (1 << k) = 2^31, it should have been caught by k == 31 check?\n        // Let's check: if gcd = 2^31, then k must be 31, or k<31 and -u is power of 2.\n        // If k=31, exception thrown. If k<31 and -u=2^(31-k), then u= -2^(31-k).\n        // The result calculation itself could overflow if the result is 2^31.\n        // The check 'if (k == 31)' handles the main overflow case.\n        // Are there other cases? gcd(MIN_VALUE, MIN_VALUE/2)? -> k=0, u=MIN_VALUE, v=MIN_VALUE/2 ...\n        // The initial checks for MIN_VALUE cases cover the results of 2^31.\n        return -u * (1 << k);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}