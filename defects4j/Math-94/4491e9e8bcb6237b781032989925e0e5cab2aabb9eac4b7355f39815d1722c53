{
    "generation": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     *\n     * @param u an integer\n     * @param v an integer\n     * @return the greatest common divisor, never negative. {@code gcd(0,0) = 0}.\n     * @throws ArithmeticException if the gcd is {@code Integer.MIN_VALUE},\n     * which occurs for {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n     * {@code gcd(Integer.MIN_VALUE, 0)} and {@code gcd(0, Integer.MIN_VALUE)}\n     * @since 1.1\n     */\n    public static int gcd(int u, int v) {\n        // Handle 0 inputs correctly\n        // gcd(x, 0) == gcd(0, x) == |x|\n        if (u == 0) {\n            // gcd(0, v) == |v|\n            // Handle potential overflow at Integer.MIN_VALUE\n            if (v == Integer.MIN_VALUE) {\n                 // Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE, which is negative\n                 // The gcd should be 2^31, which does not fit in an int.\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(v);\n        }\n        if (v == 0) {\n            // gcd(u, 0) == |u|\n            // Handle potential overflow at Integer.MIN_VALUE\n             if (u == Integer.MIN_VALUE) {\n                 // Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE, which is negative\n                 // The gcd should be 2^31, which does not fit in an int.\n                 throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            return Math.abs(u);\n        }\n\n        // Ensure u and v are negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without overflow)\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n\n        // B1. [Find power of 2]\n        int k = 0;\n        // The loop condition ensures k < 31, preventing overflow issues with (1 << k)\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n         // Handle overflow condition: gcd is 2^31\n         // This can happen if u == Integer.MIN_VALUE and v == Integer.MIN_VALUE\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n\n        // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n        // Use the variant initialization from the original code:\n        // if u is odd, t = v; if u is even, t = -u/2 = |u|/2\n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n\n        do {\n            /* assert u<0 && v<0; */ // u and v should remain negative\n            // B3/B4: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n\n            // B5 [reset max(u,v)]\n            // If t is positive, replace u with -t (making u negative and odd).\n            // If t is negative, replace v with t (making v negative and odd).\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n\n            // B6/B3. At this point both u and v should be odd and negative.\n            // Calculate new t = (v - u) / 2; v-u is even.\n            t = (v - u) / 2;\n            // If |u| > |v|, u = -max(|u|,|v|), v = -min(|u|,|v|). Then v-u = -min - (-max) = max - min > 0. t > 0.\n            // If |v| > |u|, u = -min(|u|,|v|), v = -max(|u|,|v|). Then v-u = -max - (-min) = min - max < 0. t < 0.\n            // So: t positive implies |u| was larger. Next B5 replaces u.\n            //     t negative implies |v| was larger. Next B5 replaces v.\n        } while (t != 0);\n\n        // The gcd is |u| * 2^k; since u is negative, this is -u * 2^k\n        // The result is guaranteed not to overflow if k<31, because gcd(|a|,|b|) <= min(|a|,|b|)\n        // and the potential overflow cases (gcd=2^31) were handled earlier.\n        return -u * (1 << k); // gcd is |u|*2^k where u is the negative odd component\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}