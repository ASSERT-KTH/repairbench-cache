{
    "generation": "    /**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     *  <li>The invocations {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n     *      {@code gcd(Integer.MIN_VALUE, 0)} and {@code gcd(0, Integer.MIN_VALUE)}\n     *      throw an {@code ArithmeticException}, because the result would be 2^31, which\n     *      is too large for an int value.</li>\n     *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the\n     *      absolute value of {@code x}, except for the special cases above.</li>\n     *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n     *      {@code 0}.</li>\n     * </ul>\n     *\n     * @param p a number\n     * @param q a number\n     * @return the greatest common divisor, never negative\n     * @throws ArithmeticException if the result cannot be represented as a non-negative int value.\n     * @since 1.1 (modified in 3.?)\n     */\n    public static int gcd(int p, int q) throws ArithmeticException {\n        int u = p;\n        int v = q;\n        // Handle special cases involving 0 or Integer.MIN_VALUE\n        if (u == 0 || v == 0) {\n            if (u == Integer.MIN_VALUE || v == Integer.MIN_VALUE) {\n                // GCD(MIN_VALUE, 0) or GCD(0, MIN_VALUE) is 2^31, which overflows int.\n                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n            }\n            // If neither is MIN_VALUE, Math.abs is safe and returns the non-zero value or 0.\n            return (Math.abs(u) + Math.abs(v));\n        }\n\n        // From here, u != 0 and v != 0\n        // Keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n\n        // B1. [Find power of 2]\n        int k = 0;\n        // The loop condition k < 31 is necessary because handling MIN_VALUE can lead to k = 31\n        // if u = v = MIN_VALUE. If k = 31, the gcd is 2^31 which overflows.\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            // Occurs only if u = v = Integer.MIN_VALUE\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        // u and v are negative here.\n        int t = ((u & 1) == 1) ? v : -(u / 2); // B3: t<-u/2 if u is even.\n        // t negative: u was odd, v may be even (t replaces v later in B5)\n        // t positive: u was even, v is odd (t replaces u later in B5)\n        do {\n            /* assert u<0 && v<0; */ // At start of loop, u and v are negative.\n            // B4/B3: cast out twos from t.\n            // While t is even.. This is equivalent to Knuth's B3 and B4 steps combined.\n            while ((t & 1) == 0) { \n                t /= 2; // cast out twos\n            }\n\n            // B5 [reset max(u,v)]\n            // Now t is odd. If t>0, replace u with -t (negative odd). If t<0, replace v with t (negative odd).\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            \n            // B6/B3. At this point both u and v should be odd and negative.\n            // Calculate t = (v - u) / 2; which corresponds to Knuth's B6 (u-v) -> B3 (/2).\n            // Since u and v are both odd, v-u is even, so division by 2 is exact.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u in next B5)\n            // |v| larger: t negative (replace v in next B5)\n        } while (t != 0);\n        \n        // gcd is |u| * 2^k. Since u is negative, this is -u * 2^k.\n        // The result must be non-negative.\n        // -u is positive, as the loop terminates when u == v, and u is negative.\n        // The case u = Integer.MIN_VALUE requires k=31 and is handled above.\n        // The final multiplication -u * (1 << k) will not overflow if k < 31.\n        return -u * (1 << k);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}