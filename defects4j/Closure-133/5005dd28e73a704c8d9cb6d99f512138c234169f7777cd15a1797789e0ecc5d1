{
    "generation": "  /**\n   * Returns the remainder of the line, excluding the trailing newline.\n   */\n  private String getRemainingJSDocLine() {\n    // Get the raw remaining line from the stream.\n    // We assume this might include the trailing newline characters based on the\n    // test failure suggesting position information inconsistency.\n    String result = stream.getRemainingJSDocLine();\n\n    // Check if the entire result is just newline characters.\n    // This could happen if called on an empty line or right at the end of content\n    // before the newline.\n    if (\"\\n\".equals(result) || \"\\r\".equals(result) || \"\\r\\n\".equals(result)) {\n        // If so, the actual remaining content on the line (before the newline) is empty.\n        return \"\";\n    }\n\n    // If the result is not solely EOL characters, strip any trailing EOL sequence.\n    // Check for \\n first, as \\r\\n ends with \\n.\n    if (result.endsWith(\"\\n\")) {\n        // Strip \\n\n        result = result.substring(0, result.length() - 1);\n        // Check if it was preceded by \\r (CRLF case: \\r\\n)\n        if (result.endsWith(\"\\r\")) {\n            // Strip \\r as well\n            result = result.substring(0, result.length() - 1);\n        }\n    } else if (result.endsWith(\"\\r\")) {\n        // Handle standalone CR case (\\r)\n        result = result.substring(0, result.length() - 1);\n    }\n\n    // Return the potentially modified string, guaranteed to not have a trailing newline.\n    // This might be necessary if downstream position calculations rely on the\n    // length of this string representing content strictly *before* the newline,\n    // while the stream itself advances past the newline.\n    return result;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}