{
    "generation": "    /**\n     * Compares this object to another based on size.\n     * @param object the object to compare to\n     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n     *         than <tt>object</tt>, 0 if they are equal.\n     */\n    public int compareTo(Fraction object) {\n        // otherwise, just compare the two double values\n        // this avoids problems with overflow or underflow when the two fractions\n        // have very different magnitudes\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        if (Double.isNaN(nOd) || Double.isNaN(dOn)) {\n            throw new IllegalArgumentException(\"Comparison of NaN is illegal\");\n        }\n        if (nOd < dOn) {\n            return -1;\n        } else if (nOd > dOn) {\n            return 1;\n        } else {\n            // the double representations are equal, but that doesn't mean\n            // the fractions are actually equal, so check that the representations\n            // are the same when reduced to lowest terms.\n            Fraction f1 = this.reduce();\n            Fraction f2 = object.reduce();\n            if (f1.getNumerator() != f2.getNumerator() || f1.getDenominator() != f2.getDenominator()) {\n                // check overflow\n                long f1Num = (long) f1.getNumerator() * f2.getDenominator();\n                long f2Num = (long) f1.getDenominator() * f2.getNumerator();\n                if (f1Num > f2Num) {\n                    return 1;\n                } else if (f1Num < f2Num) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            } else {\n                return 0;\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}