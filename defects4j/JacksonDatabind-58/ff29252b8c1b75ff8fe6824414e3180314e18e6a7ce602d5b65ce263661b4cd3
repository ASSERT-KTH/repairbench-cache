{
    "generation": "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n        JavaType propType0)\n    throws JsonMappingException\n{\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n    // [databind#2410]: Very likely a false positive (access already forced by JDK) but\n    //   let's try to work around JDK issue with Throwable.cause\n    if (\"cause\".equals(propDef.getName()) && mutator instanceof AnnotatedMethod) {\n        AnnotatedMethod am = (AnnotatedMethod) mutator;\n        // 16-Oct-2019, tatu: As per [databind#2410], looks like access to `Throwable.cause`\n        //    is problematic; see if this is the problem (and if so work around)\n        Class<?> rawBase = am.getDeclaringClass();\n        if (Throwable.class.isAssignableFrom(rawBase)) {\n            // Let's try to recognize JDK internals that forcibly define \"cause\" as final\n            // (IBM JDK being one such example); if final, can't force access, so give up\n            if (_isSetterMethodFinal(am)) {\n                return null;\n            }\n        }\n    }\n    if (ctxt.canOverrideAccessModifiers()) {\n        mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n    }\n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n            propType0, propDef.getWrapperName(),\n            beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n    // did type change?\n    if (type != propType0) {\n        property = property.withType(type);\n    }\n\n    // First: does the Method specify the deserializer to use? If so, let's use it.\n    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n    type = modifyTypeByAnnotation(ctxt, mutator, type);\n    TypeDeserializer typeDeser = type.getTypeHandler();\n    SettableBeanProperty prop;\n    if (mutator instanceof AnnotatedMethod) {\n        prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n    } else {\n        prop = new FieldProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n    }\n    if (propDeser != null) {\n        prop = prop.withValueDeserializer(propDeser);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n    if (ref != null && ref.isManagedReference()) {\n        prop.setManagedReferenceName(ref.getName());\n    }\n    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n    if(objectIdInfo != null){\n        prop.setObjectIdInfo(objectIdInfo);\n    }\n    return prop;\n}\n\n// @since 2.11\nprotected boolean _isSetterMethodFinal(AnnotatedMethod am) {\n    // [databind#2410]: with JDK we could do this, but not with JDK 8, 9...\n    /*\n    try {\n        Method m = am.getAnnotated();\n        return Modifier.isFinal(m.getModifiers());\n    } catch (SecurityException e) { }\n    */\n    return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}