{
    "generation": "    /**\n     * Method that will construct a regular bean property setter using\n     * the given setter method.\n     *\n     * @return Property constructed, if any; or null to indicate that\n     *   there should be no property based on given definitions.\n     */\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // [databind#877, #1025]: Explicitly prevent forced access to `cause` of `Throwable`;\n            // never needed and attempts may cause problems on some platforms.\n            // !!! NOTE: should be handled better for 2.8 and later\n            if (isIgnorableThrowableCause(ctxt, mutator)) {\n                return null;\n            }\n            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    private boolean isIgnorableThrowableCause(DeserializationContext ctxt, AnnotatedMember mutator) {\n        if (mutator instanceof AnnotatedMethod) {\n            AnnotatedMethod am = (AnnotatedMethod) mutator;\n            // [databind#1025]: add special handling for `Throwable.cause`/`Throwable.initCause`\n            //    (since actual method is private, not even visible on `Throwable`)\n            if (\"initCause\".equals(am.getName()) \n                    && am.getParameterCount() == 1) {\n                return true;\n            }\n            return _isIgnorableThrowableCtor(ctxt, am);\n        } else if (mutator instanceof AnnotatedField) {\n            return _isIgnorableThrowableField(mutator);\n        }\n        return false;\n    }\n\n    private boolean _isIgnorableThrowableField(AnnotatedMember mutator) {\n        return \"cause\".equals(mutator.getName());\n    }\n\n    private boolean _isIgnorableThrowableCtor(DeserializationContext ctxt,\n            AnnotatedMethod am) {\n        // First: only interested in 1-arg ctors (others aren't\n        // relevant)\n        if (am.getParameterCount() != 1) {\n            return false;\n        }\n        // Second: check name (not strictly necessary, but nice)\n        if (!\"Throwable\".equals(am.getDeclaringClass().getSimpleName())) {\n            return false;\n        }\n        // And third: check parameter type (also not strictly necessary)\n        JavaType type = am.getParameterType(0);\n        // wrt [databind#3811]: minor improvement, but helps with GraalVM native-image\n        // (also a practical problem with JDK 16+)\n        if (type == null) {\n            try {\n                type = ctxt.getTypeFactory().constructType(Class.forName(\"java.lang.Throwable\"));\n            } catch (ClassNotFoundException e) {\n                // 20-Oct-2021, tatu: Not sure how this could happen but let's be defensive\n            }\n        }\n        return ((type != null) && \"java.lang.Throwable\".equals(type.getRawClass().getName()));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}