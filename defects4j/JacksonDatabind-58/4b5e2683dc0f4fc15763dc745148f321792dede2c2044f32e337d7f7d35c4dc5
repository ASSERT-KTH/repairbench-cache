{
    "generation": "    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // Early exit for special cases where we should not create a property\n        if (isThrowableCause(propDef, beanDesc)) {\n            return null;\n        }\n\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // Prevent forced access to `cause` of `Throwable` to avoid issues\n            // as it is never needed and can cause problems on some platforms\n            if (!(isThrowableCause(propDef, beanDesc)) {\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null) {\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n    private boolean isThrowableCause(BeanPropertyDefinition propDef, BeanDescription beanDesc) {\n        // Check if the class is Throwable and the property is \"cause\"\n        return beanDesc.getBeanClass() != null &&\n               Throwable.class.isAssignableFrom(beanDesc.getBeanClass()) &&\n               propDef.getName().equals(\"cause\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}