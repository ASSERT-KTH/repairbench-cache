{
    "generation": "/**\n * Method that will construct a regular bean property setter using\n * the given setter method.\n *\n * @return Property constructed, if any; or null to indicate that\n *   there should be no property based on given definitions.\n */\nprotected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n        JavaType propType0)\n    throws JsonMappingException\n{\n    // need to ensure method/field is callable (for non-public)\n    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n    if (ctxt.canOverrideAccessModifiers()) {\n        // [databind#877]: explicitly prevent forced access to `cause` of Throwable;\n        // never needed (always call initCause()) and attempts may fail under certain SecurityManagers\n        if (!(mutator.getDeclaringClass() == Throwable.class\n              && \"cause\".equals(propDef.getName()))) {\n            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n\n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std property = new BeanProperty.Std(\n            propDef.getFullName(),\n            propType0, propDef.getWrapperName(),\n            beanDesc.getClassAnnotations(),\n            mutator, propDef.getMetadata());\n\n    // resolve generic types, annotations, etc\n    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n    if (type != propType0) {\n        property = property.withType(type);\n    }\n\n    // allow annotation-based override of deserializer\n    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n    type = modifyTypeByAnnotation(ctxt, mutator, type);\n    TypeDeserializer typeDeser = type.getTypeHandler();\n\n    // construct the actual SettableBeanProperty\n    SettableBeanProperty prop;\n    if (mutator instanceof AnnotatedMethod) {\n        prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n    } else {\n        prop = new FieldProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n    }\n\n    if (propDeser != null) {\n        prop = prop.withValueDeserializer(propDeser);\n    }\n\n    // handle managed forward references\n    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n    if (ref != null && ref.isManagedReference()) {\n        prop.setManagedReferenceName(ref.getName());\n    }\n    // handle Object Id\n    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n    if (objectIdInfo != null) {\n        prop.setObjectIdInfo(objectIdInfo);\n    }\n    return prop;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}