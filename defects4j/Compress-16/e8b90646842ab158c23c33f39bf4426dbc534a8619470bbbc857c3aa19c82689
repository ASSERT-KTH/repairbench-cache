{
    "generation": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n\n// Assuming the class context is ArchiveStreamFactory\npublic class ArchiveStreamFactory {\n    //... other methods ...\n\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     *\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known or the stream doesn't contain a recognized archive\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        // Buffer size needs to be large enough for TAR header (512 bytes)\n        // Other formats require less buffer size.\n        final byte[] signature = new byte[512];\n        in.mark(signature.length); // Mark the current position before reading signature\n        int signatureLength = 0;\n\n        try {\n            // Read up to signature.length bytes into the buffer\n            int bytesRead;\n            while (signatureLength < signature.length) {\n                bytesRead = in.read(signature, signatureLength, signature.length - signatureLength);\n                if (bytesRead < 0) { // Reached EOF\n                    break;\n                }\n                signatureLength += bytesRead;\n            }\n\n            in.reset(); // Reset the stream to the marked position\n\n            // Check known archive signatures in a sensible order\n\n            // Zip and Jar Check (common)\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            }\n            if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            }\n\n            // Ar Check\n            if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            }\n\n            // Cpio Check - matches() is basic, constructor does more validation.\n            if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                // Attempt to create the CPIO stream; it might fail if the header is invalid.\n                // The stream 'in' is already reset, so CpioArchiveInputStream starts from the beginning.\n                try {\n                    return new CpioArchiveInputStream(in);\n                } catch (IOException e) {\n                    // If constructor fails, it wasn't a valid CPIO stream start. Ignore and continue detection.\n                }\n            }\n\n            // Dump Check (needs at least 32 bytes)\n            if (signatureLength >= 32) {\n                if (DumpArchiveInputStream.matches(signature, signatureLength)) {\n                    return new DumpArchiveInputStream(in);\n                }\n            }\n\n            // Tar Check using standard magic bytes (e.g., \"ustar\")\n            // matches() checks specific offsets, ensure enough bytes were read\n            if (TarArchiveInputStream.matches(signature, signatureLength)) {\n                 return new TarArchiveInputStream(in);\n            }\n\n            // Fallback Tar check (COMPRESS-117, COMPRESS-191) for TARs without standard magic\n            // Requires 512 bytes to check the header structure and checksum.\n            if (signatureLength >= 512) {\n                TarArchiveInputStream tais = null;\n                try {\n                    // Use a temporary stream on the read buffer to avoid consuming 'in'\n                    tais = new TarArchiveInputStream(new ByteArrayInputStream(signature));\n                    // Try to read the first entry. This validates the header and checksum.\n                    // Crucially, check if it actually found an entry (non-null).\n                    // This prevents matching zero blocks or other non-standard tar formats\n                    // that might accidentally pass the checksum validation.\n                    if (tais.getNextEntry() != null) {\n                        // If an entry is found, assume it's a TAR file.\n                        // Return a new Tar stream based on the original input stream 'in'.\n                        return new TarArchiveInputStream(in);\n                    }\n                    // else: getNextEntry() returned null (e.g., empty TAR, zero block) or threw an exception.\n                    // Treat these cases as \"not a TAR\" for the purpose of this fallback detection.\n                } catch (Exception e) { // NOPMD - Catches IOException, IllegalArgumentException etc. from parsing\n                    // Header validation failed (e.g., bad checksum, invalid format). Ignore.\n                } finally {\n                    // Ensure temporary stream is closed\n                    if (tais != null) {\n                        try {\n                            tais.close();\n                        } catch (IOException ignored) { // NOSONAR\n                            // Ignore exception from closing ByteArrayInputStream\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            // Catch I/O errors during the initial read/mark/reset operations\n            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n        }\n\n        // If none of the above checks identified an archive format\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}