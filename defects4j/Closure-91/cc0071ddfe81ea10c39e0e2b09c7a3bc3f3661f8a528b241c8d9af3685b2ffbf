{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    // Rule 1: Don't traverse functions with JSDoc indicating bound 'this'.\n    if (n.isFunction()) {\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n); // Use NodeUtil helper to get comprehensive JSDoc\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Rule 2: Don't traverse functions inside @lends object literals.\n      // Check if n is a function value inside an object literal.\n      if (parent != null) {\n          Node grandparent = parent.getParent();\n          // Check grandparent is OBJECTLIT and n is a function value within it.\n          if (grandparent != null && grandparent.isObjectLit()) {\n              boolean isFunctionValueInObjectLit = false;\n              // Check for { 'key': function() { ... } }\n              if (parent.isStringKey() && parent.hasChildren() && parent.getSecondChild() == n) {\n                  isFunctionValueInObjectLit = true;\n              // Check for ES6 methods, getters, setters: { method() {...}, get prop(){...}, set prop(...){...} }\n              } else if ((parent.isMemberFunctionDef() ||\n                          parent.isGetterDef() ||\n                          parent.isSetterDef()) &&\n                         parent.hasChildren() && parent.getFirstChild() == n) {\n                  isFunctionValueInObjectLit = true;\n              }\n\n              if (isFunctionValueInObjectLit) {\n                  // Check the OBJECTLIT for @lends annotation\n                  JSDocInfo objectLitJsDoc = grandparent.getJSDocInfo();\n                  // getLendsName() is preferred check over hasLendsName() in some compiler contexts\n                  if (objectLitJsDoc != null && objectLitJsDoc.getLendsName() != null) {\n                      return false; // Don't traverse functions in @lends objlit\n                  }\n                  // Note: We don't need a specific check here for object literals assigned\n                  // to prototypes, as Rule 3 below will handle it by preventing traversal\n                  // into the OBJECTLIT node when it's the RHS of a prototype assignment.\n              }\n          }\n      }\n    } // End of function-specific checks\n\n    // Rule 3: Don't traverse the RHS of a prototype assignment.\n    // This check prevents traversal into nodes like object literals or functions\n    // when they are assigned to a prototype, as 'this' will be bound correctly.\n    if (parent != null && parent.isAssign()) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      // If n is the RHS of an assignment to a prototype property, stop traversal.\n      if (n == rhs) {\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n          return false; // Don't traverse this node or its children\n        }\n      } else if (n == lhs) {\n         // Original logic for handling LHS of assignment (e.g., nested assignments).\n         // Assuming 'assignLhsChild' is a member variable managed by the CheckGlobalThis class.\n         if (assignLhsChild == null) {\n           assignLhsChild = lhs;\n         }\n      }\n    }\n\n    // Default: Traverse the node if none of the rules above applied.\n    return true;\n  }\n\n  // Assume 'assignLhsChild' is a member variable of the surrounding class:\n  // private Node assignLhsChild;\n  // It should be reset by the traversal framework (e.g., in enterScope).\n  // Also assumes NodeUtil.getBestJSDocInfo and NodeUtil.isPrototypeProperty are available.",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}