{
    "generation": "import com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeUtil;\n// Other necessary imports assumed to be present\n\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are known to have a 'this' type\n      // based on their JSDoc info (@constructor, @interface, @this, @override).\n      // Use getBestJSDocInfo to find JSDoc potentially attached to a parent node.\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions inside an object literal that has @lends JSDoc.\n      // The 'this' is bound to the object being lent to.\n      // NodeUtil.isObjectLitKey checks if 'n' is the value in a key-value pair,\n      // where 'parent' is the key node (STRING_KEY, GETTER_DEF, etc.).\n      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n        Node objectLit = parent.getParent();\n        // Ensure the grandparent is indeed an OBJECTLIT node.\n        if (objectLit != null && objectLit.getType() == Token.OBJECTLIT) {\n           // Look for JSDoc associated with the object literal itself.\n           // NodeUtil.getBestJSDocInfo handles cases where JSDoc is on an assignment\n           // or variable declaration containing the object literal.\n           JSDocInfo objectLitJsDoc = NodeUtil.getBestJSDocInfo(objectLit);\n           if (objectLitJsDoc != null && objectLitJsDoc.getLendsName() != null) {\n               return false; // Found @lends, so 'this' is not global.\n           }\n        }\n      }\n    }\n\n    // Don't traverse functions that are assigned to prototype properties.\n    // This handles cases like Foo.prototype.bar = function() { ... };\n    // or Foo.prototype = { bar: function() { ... } }; (though the latter\n    // might be better handled by the @lends check if annotated).\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      // Check if 'n' is the function expression on the RHS of an assignment\n      // to a prototype property (e.g., Class.prototype.method = n; or Class.prototype = n;).\n      if (n == rhs && NodeUtil.isPrototypePropertyAssignment(parent)) {\n          // The 'this' context is the instance or the prototype, not global.\n          return false;\n      }\n      // Note: We always traverse the LHS of an assignment in case of nested\n      // assignments or other structures where 'this' might appear.\n    }\n\n    // Otherwise, traverse the node.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}