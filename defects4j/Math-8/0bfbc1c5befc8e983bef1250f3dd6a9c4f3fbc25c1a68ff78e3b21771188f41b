{
    "generation": "    /**\n     * Generate a random sample from the distribution.\n     *\n     * @param sampleSize the number of random values to generate.\n     * @return an array representing the random sample.\n     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n     * positive.\n     */\n    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        // singletons is guaranteed by the constructor to be non-empty.\n        final Class<?> firstClass = singletons.get(0).getClass();\n        boolean allSameClass = true;\n        // Check if all singletons are of the same exact class.\n        // Using getClass() comparison is intentional here to detect cases like the\n        // bug report where different anonymous classes implementing the same interface\n        // or extending the same class are used.\n        for (int j = 1; j < singletons.size(); j++) {\n            if (singletons.get(j).getClass() != firstClass) {\n                allSameClass = false;\n                break;\n            }\n        }\n\n        final T[] out;\n\n        if (allSameClass) {\n            // All singletons have the same class C. Create an array of type C[]\n            // and cast it to T[]. This cast is safe because C must be assignable to T.\n            // The ArrayStoreException is avoided because all samples will be instances\n            // of C (or subclasses), which are assignable to the array component type C.\n            out = (T[]) java.lang.reflect.Array.newInstance(firstClass, sampleSize);\n        } else {\n            // Singletons have different concrete classes (e.g., Integer and Double for T=Number,\n            // or different anonymous classes for T=Object).\n            // Creating an array based on the first element's class (like the original code)\n            // would lead to ArrayStoreException when storing an element of a different class.\n            // The only common array type that can safely hold *all* potential samples\n            // without ArrayStoreExceptions during filling is Object[].\n            // Create Object[], fill it, and then cast to T[].\n            // Note: This final cast (T[]) objOut will only succeed if T is Object.\n            // If T is a more specific type (e.g., Number), this cast will throw a\n            // ClassCastException at runtime. This reflects the inherent difficulty of\n            // creating generic arrays in Java when the component type T is not known\n            // or when the actual elements have diverse runtime types inconsistent with T[].\n            final Object[] objOut = new Object[sampleSize];\n            for (int i = 0; i < sampleSize; i++) {\n                objOut[i] = sample(); // sample() returns T, assignable to Object.\n            }\n            // This cast allows the method to fulfill the T[] return type contract,\n            // albeit with a potential ClassCastException if T isn't Object,\n            // shifting the error from a potential ArrayStoreException during filling\n            // to a ClassCastException at the end in heterogeneous non-Object cases.\n            return (T[]) objOut;\n        }\n\n        // Fill the array (only reached if allSameClass was true).\n        for (int i = 0; i < sampleSize; i++) {\n            // sample() returns T. The actual object will be one of the singletons.\n            // Since all singletons are of type firstClass (C), sample() returns\n            // an instance of C (or potentially a subclass if singletons could hold subclasses,\n            // though typically they hold the exact items).\n            // Assigning an instance of C (or subclass) to an array of C[] is safe.\n            out[i] = sample();\n        }\n\n        return out;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}