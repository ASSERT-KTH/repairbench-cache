{
    "generation": "    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class. \n     * \n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic instanceof ParameterizedType) {\n            // This is a generic type, e.g., List<String>, Map<K, V>\n            // We assume the first actual type argument is the one we're interested in.\n            // This is common for types like List<E>, Set<E>, ArgumentCaptor<T>.\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            \n            if (actual instanceof Class) {\n                // The generic type is a direct Class, e.g., List<String> -> String.class\n                return (Class) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // The generic type is itself a ParameterizedType (nested generic), \n                // e.g., List<Set<String>>. 'actual' would be 'Set<String>'.\n                // We need its raw type, which is 'Set.class'.\n                // The comment \"in case of nested generics we don't go deep\" implies we stop here.\n                return (Class) ((ParameterizedType) actual).getRawType();\n            } else if (actual instanceof TypeVariable) {\n                // The generic type is a TypeVariable (e.g., T in List<T>).\n                // We return its upper bound, which defaults to Object.class if not specified.\n                Type[] bounds = ((TypeVariable) actual).getBounds();\n                if (bounds.length > 0 && bounds[0] instanceof Class) {\n                    return (Class) bounds[0];\n                }\n            } else if (actual instanceof WildcardType) {\n                // The generic type is a WildcardType (e.g., ? or ? extends Number in List<?> or List<? extends Number>).\n                // We return its upper bound, which defaults to Object.class.\n                Type[] upperBounds = ((WildcardType) actual).getUpperBounds();\n                if (upperBounds.length > 0 && upperBounds[0] instanceof Class) {\n                    return (Class) upperBounds[0];\n                }\n            }\n            // For any other unexpected Type or if bounds could not be resolved to a Class, fall through.\n        }\n        \n        // This handles cases where:\n        // 1. The field's type is not a ParameterizedType (i.e., it's a non-generic field like String or int).\n        // 2. 'generic' is null (though field.getGenericType() rarely returns null for real fields).\n        // 3. For ParameterizedType fields, if the actual type argument couldn't be resolved to a specific Class\n        //    through the above conditions (e.g., complex bounds, other Type implementations).\n        return Object.class;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}