{
    "generation": "import java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Set; // Import needed for the test case example\n\n// Class definition added for context, but only the method should be returned\nclass GenericMaster {\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     * If the field has multiple generic types, it returns the first one.\n     * If the first generic type is nested (e.g. {@code List<Set<String>>}), it returns the raw type of the nested generic type (e.g. {@code Set.class}).\n     *\n     * @param field the field to inspect\n     * @return the first generic type, or the raw type of the first nested generic type, or Object.class if not applicable.\n     */\n    public Class<?> getGenericType(Field field) {\n        Type genericType = field.getGenericType();\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) genericType;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n            // Check if there are any type arguments\n            if (actualTypeArguments.length > 0) {\n                Type firstTypeArgument = actualTypeArguments[0];\n\n                if (firstTypeArgument instanceof Class) {\n                    // Case: Argument is a simple class (e.g., List<String>)\n                    return (Class<?>) firstTypeArgument;\n                } else if (firstTypeArgument instanceof ParameterizedType) {\n                    // Case: Argument is also parameterized (e.g., List<Set<String>>)\n                    // Return the raw type of the nested parameterized type (e.g., Set.class)\n                    Type rawType = ((ParameterizedType) firstTypeArgument).getRawType();\n                    if (rawType instanceof Class) {\n                         return (Class<?>) rawType;\n                    }\n                }\n                // Handle other types like TypeVariable, WildcardType, GenericArrayType?\n                // The original code's intent seems to fallback to Object.class if it's not easily resolvable to a Class.\n            }\n        }\n\n        // Fallback if the field is not a ParameterizedType, has no type arguments,\n        // or the first type argument is not a Class or a ParameterizedType with a Class raw type.\n        return Object.class;\n    }\n\n    // Dummy fields for context if needed, based on test names\n    java.util.List<Set<String>> nested;\n    java.util.List<Set<java.util.List<String>>> multiNested;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}