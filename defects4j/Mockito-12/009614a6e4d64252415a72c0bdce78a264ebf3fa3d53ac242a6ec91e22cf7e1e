{
    "generation": "    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field\n     * @return\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        if (generic instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) generic;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            // We only care about the first type argument\n            if (actualTypeArguments.length > 0) {\n                Type actualTypeArgument = actualTypeArguments[0];\n                if (actualTypeArgument instanceof Class) {\n                    return (Class<?>) actualTypeArgument;\n                } else if (actualTypeArgument instanceof ParameterizedType) {\n                    // Handle nested generics like List<Set<String>> by returning the raw type, e.g. Set.class\n                    return (Class<?>) ((ParameterizedType) actualTypeArgument).getRawType();\n                }\n                // else: The actual type argument is not a Class or ParameterizedType\n                // (e.g., TypeVariable, WildcardType, GenericArrayType).\n                // The original behavior was to return Object.class in complex cases,\n                // and the ClassCastException occurred because we tried to cast these complex types directly to Class.\n                // Returning Object.class here maintains consistency with the original intent for unhandled cases.\n            }\n        }\n\n        return Object.class;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}