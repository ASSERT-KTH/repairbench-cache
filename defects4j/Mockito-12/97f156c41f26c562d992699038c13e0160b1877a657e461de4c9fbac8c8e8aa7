{
    "generation": "import java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\n// Assume necessary imports and class structure exist\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field\n     * @return\n     */\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        if (generic instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) generic;\n            Type[] actualTypeArguments = pt.getActualTypeArguments();\n            // Need to check if we have any actual type arguments\n            if (actualTypeArguments.length > 0) {\n                Type firstActualType = actualTypeArguments[0];\n                if (firstActualType instanceof Class) {\n                    return (Class<?>) firstActualType;\n                } else if (firstActualType instanceof ParameterizedType) {\n                    // Handle nested generics like List<Set<String>> - return the raw type (Set.class)\n                    // Cast Raw Type to Class is safe\n                    return (Class<?>) ((ParameterizedType) firstActualType).getRawType();\n                }\n                // else: other types like TypeVariable, WildcardType, GenericArrayType are not handled explicitly -> return Object.class\n                // This case covers types like Capture<T> where T is a TypeVariable.\n                // It might also cover cases like Capture<? extends Number> where the argument is a WildcardType.\n                // Returning Object.class seems like a reasonable default according to the original logic's fallback.\n            }\n        }\n\n        return Object.class;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}