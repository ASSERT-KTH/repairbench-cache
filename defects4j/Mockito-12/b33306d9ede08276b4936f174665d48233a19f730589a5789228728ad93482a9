{
    "generation": "import java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\nclass GenericMaster { // Assuming the original class name was GenericMaster\n\n    /**\n     * Finds the generic type (parametrized type) of the field. If the field is not generic it returns Object.class.\n     *\n     * @param field\n     * @return\n     */\n    public Class getGenericType(Field field) {\n        Type currentType = field.getGenericType();\n\n        // Loop to traverse through nested generic types, specifically for collections and maps,\n        // until a concrete class is found or a specific rule applies (like for Set).\n        while (currentType instanceof ParameterizedType) {\n            ParameterizedType pType = (ParameterizedType) currentType;\n            Class<?> rawType = getRawClass(pType.getRawType()); // Get the raw class of the current parameterized type\n\n            // If the raw type is a Collection\n            if (Collection.class.isAssignableFrom(rawType)) {\n                // If it's a Set, we stop and return its raw type (e.g., Set.class)\n                // This handles List<Set<String>> -> Set.class and List<Map<..., Set<...>>> -> Set.class\n                if (Set.class.isAssignableFrom(rawType)) {\n                    return rawType;\n                }\n\n                // For other Collections (like List<E>), try to go deeper into the element type (first argument)\n                Type[] actualTypeArguments = pType.getActualTypeArguments();\n                if (actualTypeArguments.length > 0) {\n                    currentType = actualTypeArguments[0];\n                } else {\n                    // If it's a raw Collection type (e.g., List, not List<String>),\n                    // or if it has no type arguments, return its raw type as the \"most specific\" generic type.\n                    return rawType;\n                }\n            } else if (Map.class.isAssignableFrom(rawType)) {\n                // For Map<K, V>, go deeper into the value type (second argument)\n                Type[] actualTypeArguments = pType.getActualTypeArguments();\n                if (actualTypeArguments.length > 1) {\n                    currentType = actualTypeArguments[1]; // Value type\n                } else {\n                    // If it's a raw Map type (e.g., Map, not Map<K,V>),\n                    // return its raw type.\n                    return rawType;\n                }\n            } else {\n                // If the ParameterizedType's raw type is neither a Collection nor a Map\n                // (e.g., MyCustomGenericClass<T>), then we've reached the desired generic type.\n                // We return its raw type.\n                return rawType;\n            }\n        }\n\n        // If the loop finished (currentType is no longer a ParameterizedType)\n        // or if the initial field type was not a ParameterizedType.\n        // Attempt to convert the final `currentType` to a `Class`, or default to `Object.class`.\n        return getRawClass(currentType);\n    }\n\n    /**\n     * Helper method to convert a Type to its raw Class representation.\n     * Handles Class, ParameterizedType, TypeVariable, and WildcardType.\n     * Defaults to Object.class for unhandled or unresolved types.\n     * @param type The Type to convert.\n     * @return The raw Class corresponding to the Type.\n     */\n    private Class<?> getRawClass(Type type) {\n        if (type instanceof Class) {\n            return (Class<?>) type;\n        } else if (type instanceof ParameterizedType) {\n            // For ParameterizedType (e.g., List<String>), return List.class\n            return (Class<?>) ((ParameterizedType) type).getRawType();\n        } else if (type instanceof TypeVariable) {\n            // For TypeVariable (e.g., <T>), try to resolve to its upper bound.\n            // If T extends List<String>, this will return List.class.\n            Type[] bounds = ((TypeVariable) type).getBounds();\n            if (bounds.length > 0) {\n                return getRawClass(bounds[0]); // Recursively resolve the bound\n            }\n            return Object.class; // Unbounded type variable, default to Object.class\n        } else if (type instanceof WildcardType) {\n            // For WildcardType (e.g., ? extends SomeClass), take the upper bound.\n            Type[] upperBounds = ((WildcardType) type).getUpperBounds();\n            if (upperBounds.length > 0) {\n                return getRawClass(upperBounds[0]); // Recursively resolve the upper bound\n            }\n            return Object.class; // Unbounded wildcard '?', default to Object.class\n        }\n        // For other Type implementations (e.g., GenericArrayType), or if nothing else matches\n        return Object.class;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}