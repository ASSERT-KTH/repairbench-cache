{
    "generation": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Initialize roots\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // == Pre-parse all JS inputs ==\n      // Ensure all ASTs are parsed and cached before dependency management\n      // or other processing that might rely on them implicitly.\n      for (CompilerInput input : inputs) {\n        input.getAstRoot(this); // Trigger parse & cache\n        if (hasErrors()) { // Check for parse errors\n          return null;\n        }\n      }\n      // == ASTs should now be cached in CompilerInput objects ==\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        // Forward-declare all provided types before sorting.\n        for (CompilerInput input : inputs) {\n          // getProvides() should use the pre-parsed AST.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          // manageDependencies should now use the pre-parsed ASTs.\n          // It returns a new list assigned to this.inputs and updates modules internally.\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true; // Mark inputs as stale due to reordering.\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      // Check JSDoc (@externs/@nocompile) after potential reordering.\n      // Iterate the potentially-reordered 'inputs' list.\n      // Modifications inside the loop target the module structure, not the 'inputs' list directly.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this); // Get cached AST\n\n        // Inputs might have null AST if parsing failed and wasn't caught, though pre-parsing should prevent this.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file,\n            // move it to the externs list and update module state.\n            externsRoot.addChildToBack(n); // Move the AST node\n            input.setIsExtern(true);\n            input.getModule().remove(input); // Remove from its current module\n            externs.add(input); // Add to Compiler's list of extern inputs\n            staleInputs = true; // Mark inputs as stale, requiring rebuild\n          } else if (info.isNoCompile()) {\n            // If marked as @nocompile, just remove from module.\n            input.getModule().remove(input); // Remove from its current module\n            staleInputs = true; // Mark inputs as stale, requiring rebuild\n          }\n        }\n      }\n\n      // If dependency management ran OR JSDoc modifications occurred,\n      // rebuild the main 'inputs' list from the final state of the modules.\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules(); // Rebuilds 'this.inputs' based on current module contents\n      }\n\n      // Build the main AST (jsRoot).\n      for (CompilerInput input : inputs) { // Iterate the final 'inputs' list\n        Node n = input.getAstRoot(this); // Get cached AST\n        if (n == null) {\n          // Should not happen normally if pre-parsing succeeded and input wasn't removed.\n          continue;\n        }\n\n        // Run sanity check before adding the node.\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        // Annotate source info if required.\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        // Add the input's AST to the main JS root.\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}