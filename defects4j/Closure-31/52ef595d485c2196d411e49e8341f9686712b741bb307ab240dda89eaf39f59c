{
    "generation": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Create new roots.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        // Input can be null if loading failed.\n        if (n != null) {\n           externsRoot.addChildToBack(n);\n        }\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n        // If inputs are modified, module graph might be messed up.\n        // TODO(b/117854131): Rebuilding might be necessary, but order preservation is key.\n      }\n\n      // Check if inputs need to be rebuilt from modules due to module changes.\n      boolean staleInputs = false; // True if modules are changed (@externs/@nocompile)\n\n      // Check if the sources need to be re-ordered. This typically happens\n      // when closurePass is true, but dependency management might be requested\n      // externally (e.g., via CommandLineRunner). The list 'inputs' should\n      // already be sorted in that case. If sorting happens here, it respects\n      // that order.\n      if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) { // Check closurePass to ensure this Compiler instance manages deps\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs = // Sort happens here, updates compiler's list\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          // Do NOT set staleInputs = true here. Sorting alone doesn't make modules stale\n          // unless inputs were actually moved between modules, which manageDependencies handles internally.\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          // If in IDE mode, errors might be ignored, otherwise return null.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          // If in IDE mode, errors might be ignored, otherwise return null.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n      // The 'inputs' list is now assumed to be in the correct dependency order,\n      // either from the runner or from the internal sort above.\n\n      // Check for misplaced inputs marked @externs or @nocompile.\n      // Use a temporary list to avoid issues if module structure changes during iteration.\n      List<CompilerInput> inputsToProcess = new ArrayList<>(inputs);\n      for (CompilerInput input : inputsToProcess) {\n        // If an input was removed from its module in a previous iteration (e.g. moved to externs)\n        // it might still be in inputsToProcess but input.getModule() would be null. Skip it.\n        if (input.getModule() == null && !input.isExtern()) {\n            continue;\n        }\n\n        Node n = input.getAstRoot(this);\n        // Inputs can have a null AST if parsing failed earlier e.g. IOException\n        if (n == null) {\n          if (hasErrors()) { // Check if the null AST was due to a reported error\n              return null;\n          }\n          continue; // Otherwise, just skip this input.\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // Handle case where an input file is marked @externs.\n            // It needs to be moved from the JS inputs list/modules to the externs list.\n            if (!input.isExtern()) { // Only move if not already classified as extern\n                 externsRoot.addChildToBack(n); // Add AST to externs root\n                 input.setIsExtern(true); // Mark input as extern\n\n                 // Remove from its current module, if it has one.\n                 JSModule module = input.getModule();\n                 if (module != null) {\n                     module.remove(input);\n                 }\n\n                 // Add to the compiler's list of extern inputs.\n                 if (!externs.contains(input)) {\n                      externs.add(input);\n                 }\n                 staleInputs = true; // Mark that module structure changed\n            }\n          } else if (info.isNoCompile()) {\n            // Handle @nocompile: remove the input from its module.\n            JSModule module = input.getModule();\n            if (module != null) { // Check if it's actually in a module\n                 module.remove(input);\n                 staleInputs = true; // Mark that module structure changed\n            }\n          }\n        }\n      }\n\n      // If module structure changed (@externs/@nocompile found), we need to update\n      // the compiler's 'inputs' list to reflect these changes, while preserving order.\n      if (staleInputs) {\n        List<CompilerInput> finalInputs = new ArrayList<>();\n        // Iterate through the original 'inputs' list (which has the correct order)\n        for (CompilerInput input : inputs) {\n            // Keep the input if it still belongs to a module and is not extern\n            // (i.e., it wasn't moved or removed)\n            if (input.getModule() != null && !input.isExtern()) {\n                 finalInputs.add(input);\n            }\n        }\n        inputs = finalInputs; // Update compiler's list with filtered, ordered inputs\n        // Update the map used for quick lookups\n        inputsById = MjsModuleUtil.getInputsById(inputs);\n        // Modules might be empty now, fill them if needed by later passes.\n        fillEmptyModules(modules);\n        // Do NOT call rebuildInputsFromModules() as it likely destroys dependency order.\n      }\n\n      // Build the AST from the final, ordered 'inputs' list.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          // This might happen if the input failed parsing and error was ignored, or @nocompile.\n          continue;\n        }\n\n        if (devMode) {\n          // Sanity checks should ideally run on the complete AST, but running\n          // per-input might catch early issues. Consider implications.\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          // Annotate the nodes in the tree with source file information.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n); // Add the script node to the main JS root block\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}