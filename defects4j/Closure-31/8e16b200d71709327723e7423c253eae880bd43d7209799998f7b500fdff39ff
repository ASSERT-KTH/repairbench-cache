{
    "generation": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Initialize roots\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // 1. Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // 2. Process AMD/CommonJS modules (may update 'modules' and 'inputs')\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // 3. Ensure ASTs are parsed for all inputs before potential reordering\n      //    or modification checks. The AST is cached in the CompilerInput.\n      for (CompilerInput input : inputs) {\n        input.getAstRoot(this); // Populate AST cache\n        if (hasErrors()) {\n          return null;\n        }\n      }\n\n      // 4. Dependency management\n      // Create a list to hold the potentially sorted inputs. Start with the current inputs.\n      List<CompilerInput> sortedInputs = Lists.newArrayList(inputs);\n      boolean orderChanged = false;\n      if (options.dependencyOptions.needsManagement() &&\n          !options.skipAllPasses &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          JSModuleGraph graph =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph);\n          // manageDependencies returns a new sorted list.\n          List<CompilerInput> newSortedInputs =\n              graph.manageDependencies(options.dependencyOptions, inputs);\n          if (!sortedInputs.equals(newSortedInputs)) {\n              orderChanged = true;\n              sortedInputs = newSortedInputs;\n          }\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          if (hasErrors()) return null; // Check errors, potentially return null\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          if (hasErrors()) return null; // Check errors, potentially return null\n        }\n      }\n\n      // 5. Check for @externs/@nocompile inputs and mark them for removal/moving.\n      //    Iterate the original list ('inputs') to ensure all initial inputs are checked.\n      Set<CompilerInput> inputsToRemove = Sets.newHashSet();\n      boolean modulesModified = false;\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this); // AST is cached\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n); // Add AST to externs\n            input.setIsExtern(true);\n            if (input.getModule() != null) {\n                input.getModule().remove(input); // Remove from module\n            }\n            externs.add(input); // Add Input object to externs list\n            inputsToRemove.add(input); // Mark for removal from main inputs\n            modulesModified = true;\n          } else if (info.isNoCompile()) {\n            if (input.getModule() != null) {\n                input.getModule().remove(input); // Remove from module\n            }\n            inputsToRemove.add(input); // Mark for removal from main inputs\n            modulesModified = true;\n          }\n        }\n      }\n\n      // 6. Finalize the list of inputs to be included in the build.\n      //    Start with the potentially sorted list.\n      List<CompilerInput> finalInputs;\n      if (modulesModified) {\n        fillEmptyModules(modules); // Update modules if some became empty\n        // Filter the sorted list to remove marked inputs\n        finalInputs = Lists.newArrayList();\n        for(CompilerInput input : sortedInputs) {\n            if (!inputsToRemove.contains(input)) {\n                finalInputs.add(input);\n            }\n        }\n      } else {\n        // No modules modified, use the sorted list directly.\n        finalInputs = sortedInputs;\n      }\n\n      // Update the compiler's main 'inputs' list for subsequent passes.\n      this.inputs = finalInputs;\n\n      // 7. Build the AST for jsRoot using the final, ordered list.\n      for (CompilerInput input : finalInputs) {\n        Node n = input.getAstRoot(this); // AST should be cached\n        if (n == null) {\n          continue; // Should not happen normally\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}