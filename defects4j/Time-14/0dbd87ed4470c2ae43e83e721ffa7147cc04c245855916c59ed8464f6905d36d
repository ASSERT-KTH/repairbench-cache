{
    "generation": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // Use the partial logic if the partial is contiguous, like MonthDay.\n        // This ensures that the fields are sensible to represent on a timeline.\n        if (DateTimeUtils.isContiguous(partial)) {\n            // Use a known leap year (e.g., 2004) as a base instant for calculations.\n            // This ensures that operations involving Feb 29 are handled correctly,\n            // regardless of the chronology's default reference year (often 1970).\n            // Get the millis for 2004-01-01T00:00:00.000 in the specific chronology.\n            // Note: Joda-Time uses 1-based month (1=Jan).\n            long instant = iChronology.getDateTimeMillis(2004, 1, 1, 0, 0, 0, 0);\n            \n            // Set the month and day from the partial onto the base instant.\n            // This creates an instant like 2004-MM-DD. Using set(ReadablePartial)\n            // handles chronology-specific field setting, including potential validation\n            // if the partial itself was invalid (though values[] are assumed valid here).\n            // This step effectively places the MonthDay into a leap year context.\n            instant = iChronology.set(partial, instant);\n            \n            // Add the specified value (months or days) to the instant.\n            // This delegates to the specific DateTimeField's add logic,\n            // which handles calendar rules like month lengths and leap years based\n            // on the instant's context (e.g., 2004 +/- valueToAdd).\n            instant = add(instant, valueToAdd);\n            \n            // Extract the resulting field values (month, day) from the final instant.\n            // This gives the MonthDay component of the resulting date.\n            return iChronology.get(partial, instant);\n        } else {\n            // Fallback to the superclass implementation for non-contiguous partials\n            // or potentially other partial types where this logic might not apply.\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}