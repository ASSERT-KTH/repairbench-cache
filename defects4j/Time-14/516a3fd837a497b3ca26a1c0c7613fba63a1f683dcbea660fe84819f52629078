{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        // Use the 2000-01-01 as a \"leap-year\" base for computation\n        // (since for MonthDay, year is not present -- using a leap year avoids 2/29 trouble)\n        int baseYear = 2000;\n        Chronology chrono = iChronology.withUTC();\n        // Gather month and day indices\n        int month = 1;\n        int day = 1;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            if (\"monthOfYear\".equals(partial.getFieldType(i).getName())) {\n                month = values[i];\n            } else if (\"dayOfMonth\".equals(partial.getFieldType(i).getName())) {\n                day = values[i];\n            }\n        }\n        try {\n            instant = chrono.getDateTimeMillis(baseYear, month, day, 0, 0, 0, 0);\n        } catch (org.joda.time.IllegalFieldValueException ex) {\n            // Fallback, best effort if day out of range (shouldn't happen with valid MonthDay)\n            // Clamp day to 28 (minimum for February)\n            if (day == 29 && month == 2) {\n                day = 28;\n                instant = chrono.getDateTimeMillis(baseYear, month, day, 0, 0, 0, 0);\n            } else {\n                throw ex;\n            }\n        }\n        DurationField field = partial.getField(fieldIndex).getDurationField();\n        instant = field.add(instant, valueToAdd);\n        // extract back month and day\n        int[] newValues = new int[partial.size()];\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            DateTimeField f = partial.getFieldType(i).getField(chrono);\n            newValues[i] = f.get(instant);\n        }\n        return newValues;\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}