{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    if (valueToAdd == 0) {\n        return values;\n    }\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        // set starting instant\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n        }\n        // save original dayOfMonth if available\n        int originalDom = -1;\n        DurationFieldType dayOfMonthType = DateTimeFieldType.dayOfMonth();\n        DateTimeField dayField = null;\n        // Check if partial includes dayOfMonth\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            if (partial.getFieldType(i).equals(dayOfMonthType)) {\n                dayField = partial.getFieldType(i).getField(iChronology);\n                originalDom = values[i];\n                break;\n            }\n        }\n        // apply addition\n        instant = partial.getFieldType(fieldIndex).getField(iChronology).add(instant, valueToAdd);\n        // fix day-of-month if needed\n        if (dayField != null && originalDom > 0) {\n            int dom = dayField.get(instant);\n            int maxDom = dayField.getMaximumValue(instant);\n            if (dom < originalDom) {\n                if (originalDom <= maxDom) {\n                    try {\n                        instant = dayField.set(instant, originalDom);\n                    } catch (IllegalArgumentException ex) {\n                        // ignore, keep as-is if still invalid\n                    }\n                }\n            }\n        }\n        return iChronology.get(partial, instant);\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}