{
    "generation": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // month-day calculations properly, especially around leap years\n        // The strategy is to map the partial to a full instant in a leap year,\n        // perform the addition, and map back.\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // This optimization is specific to contiguous partials\n        if (DateTimeUtils.isContiguous(partial)) {\n            // Use a representative instant in a leap year to perform calculations.\n            // Choose year 2004 as it is a leap year. Using a leap year ensures\n            // that February 29th can be represented during the calculation.\n            // Using 1st day of year avoids potential month length issues.\n            long instant = iChronology.getDateTimeMillis(2004, 1, 1, 0);\n            // Set the partial fields onto this base instant.\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            // Add the value using the chronology's field addition logic for instants.\n            // This assumes the 'add(long, int)' method correctly delegates\n            // to the appropriate DurationField based on the context (e.g., month or day).\n            instant = add(instant, valueToAdd);\n            // Convert the resulting instant back to the partial's field values.\n            return iChronology.get(partial, instant);\n        } else {\n            // Fallback for non-contiguous partials.\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}