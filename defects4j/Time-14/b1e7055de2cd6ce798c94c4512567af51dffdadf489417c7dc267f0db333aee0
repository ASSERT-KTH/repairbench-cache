{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n\n    if (DateTimeUtils.isContiguous(partial)) {\n        int size = partial.size();\n        // Specifically handle cases like MonthDay (month-day)\n        // Assume the fields are ordered from largest to smallest (month, day)\n        // Only apply special logic if partial has exactly 2 fields and is month and day\n        if (size == 2 &&\n            (partial.getFieldType(0) == DateTimeFieldType.monthOfYear() || partial.getFieldType(0).toString().equals(\"monthOfYear\")) &&\n            (partial.getFieldType(1) == DateTimeFieldType.dayOfMonth() || partial.getFieldType(1).toString().equals(\"dayOfMonth\"))) {\n\n            int origMonth = values[0];\n            int origDay = values[1];\n            // Compute new month and day values as if a variable-length month calendar\n            int newMonth = origMonth;\n            int newDay = origDay;\n\n            if (fieldIndex == 0) { // add to month\n                int months = origMonth + valueToAdd - 1; // 0-based\n                int modMonths = ((months % 12) + 12) % 12;\n                int years = (months / 12);\n                if (months < 0 && modMonths != 0) {\n                    years -= 1;\n                    modMonths = ((modMonths) + 12) % 12;\n                }\n\n                newMonth = modMonths + 1;\n\n                // Determine correct year for leap calculation\n                // Use a leap year if original day is 29 and moving to Feb\n                int leapYear = 2000; // known leap year\n\n                int year = leapYear + years;\n                int maxDay = iChronology.monthOfYear().getMaximumValue(new long[] {\n                        0L, 0L  // Only need month, but API needs an array\n                }, newMonth);\n                // However, we need to query the correct maxDay for (year, newMonth)\n                // Use chronology to get max day for that month in that year\n                // But since we have no year in fields, simulate via LocalDate\n                try {\n                    org.joda.time.LocalDate d = new org.joda.time.LocalDate(year, newMonth, 1, iChronology);\n                    maxDay = d.dayOfMonth().getMaximumValue();\n                } catch (Exception e) {\n                    // Fallback\n                    maxDay = iChronology.dayOfMonth().getMaximumValue();\n                }\n\n                if (origDay > maxDay) {\n                    newDay = maxDay;\n                } else {\n                    newDay = origDay;\n                }\n                return new int[] { newMonth, newDay };\n            } else if (fieldIndex == 1) { // add to day - simple day addition as on a fixed year\n                int leapYear = 2000; // Leap year\n                org.joda.time.LocalDate dt = new org.joda.time.LocalDate(leapYear, origMonth, origDay, iChronology);\n                dt = dt.plusDays(valueToAdd);\n                return new int[] { dt.getMonthOfYear(), dt.getDayOfMonth() };\n            }\n        }\n\n        // fallback to original logic for other partials\n        long instant = 0L;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n        }\n        instant = add(instant, valueToAdd);\n        return iChronology.get(partial, instant);\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}