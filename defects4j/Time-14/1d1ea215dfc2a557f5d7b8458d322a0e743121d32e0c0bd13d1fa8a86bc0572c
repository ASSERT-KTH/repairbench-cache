{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        // Use a reference year that is a leap year to allow 2/29 and 3/31, etc.\n        // 2008 is a leap year\n        int leapYear = 2008;\n        org.joda.time.chrono.BaseChronology chrono = (org.joda.time.chrono.BaseChronology) iChronology.withUTC();\n\n        // Fill array with extended fields (year + fields of partial)\n        org.joda.time.field.FieldUtils.verifyValueBounds(org.joda.time.DateTimeFieldType.year().getField(chrono), leapYear, leapYear, leapYear);\n        int[] newValues = new int[partial.size() + 1];\n        newValues[0] = leapYear;\n        System.arraycopy(values, 0, newValues, 1, values.length);\n\n        // Create a LocalDate using the leapYear + month/day (e.g., Feb 29 is valid in 2008)\n        org.joda.time.LocalDate tempDate = new org.joda.time.LocalDate(\n            leapYear,\n            (partial.size() > 0 ? values[0] : 1),                        // monthOfYear\n            (partial.size() > 1 ? values[1] : 1),                        // dayOfMonth\n            chrono\n        );\n\n        // Add using the correct field\n        org.joda.time.LocalDate added;\n        if (partial.getFieldType(fieldIndex) == org.joda.time.DateTimeFieldType.monthOfYear()) {\n            added = tempDate.plusMonths(valueToAdd);\n        } else if (partial.getFieldType(fieldIndex) == org.joda.time.DateTimeFieldType.dayOfMonth()) {\n            added = tempDate.plusDays(valueToAdd);\n        } else {\n            // fallback to instant-based calculation\n            instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        }\n\n        // Extract just the partial fields (ignore the year)\n        int[] result = new int[partial.size()];\n        for (int i = 0; i < partial.size(); i++) {\n            org.joda.time.DateTimeFieldType type = partial.getFieldType(i);\n            result[i] = added.get(type);\n        }\n        return result;\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}