{
    "generation": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n\n        // The problem for MonthDay (which is contiguous) is that converting to\n        // a long instant and back can lose the desired 'leap day' behavior.\n        // The MonthDayChronology uses year 2000 (a leap year) internally,\n        // but the add(long, int) operation sometimes adjusts Feb 29 to Feb 28.\n        if (DateTimeUtils.isContiguous(partial)) {\n            // First, perform the standard addition using the superclass's logic.\n            // This covers most cases, including month wrapping and general clamping.\n            int[] newValues = super.add(partial, fieldIndex, values, valueToAdd);\n\n            // Special handling for MonthDay's leap year/end-of-month adjustment\n            // This applies when adding to the month field and the day needs adjustment\n            // (e.g., March 31 minus 1 month should be Feb 29, not Feb 28).\n            if (fieldIndex == partial.indexOf(DateTimeFieldType.monthOfYear())) {\n                int originalDay = values[partial.indexOf(DateTimeFieldType.dayOfMonth())];\n                int newMonth = newValues[partial.indexOf(DateTimeFieldType.monthOfYear())];\n                int newDay = newValues[partial.indexOf(DateTimeFieldType.dayOfMonth())];\n\n                // If the new month is February and the original day implies a leap day (29 or greater),\n                // and the calculated new day was clamped to 28 (non-leap February),\n                // then adjust it to 29 (as MonthDay's February 29 implies a leap year context).\n                if (newMonth == 2) { // Target month is February\n                    // Check if the original day was 29, or would have been clamped to 29 (e.g., March 31 -> Feb)\n                    if (originalDay == 29 || originalDay > 29) {\n                        // If the result was clamped to 28 (meaning it incorrectly treated Feb as non-leap)\n                        if (newDay == 28) {\n                            newValues[partial.indexOf(DateTimeFieldType.dayOfMonth())] = 29;\n                        }\n                    }\n                }\n            }\n            return newValues;\n        } else {\n            // For non-contiguous partials, delegate to the superclass which handles them generically.\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}