{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        // Determine if we're incrementing a month or day-based partial\n        // so we can handle leap years/end-of-month correctly\n        // Construct a base date in a leap year with a safe day (e.g. 2000-02-29)\n        // Use the maximum possible day for given (month + delta) in the leap year\n        // e.g. MonthDay(2,29).plusMonths(1) => MonthDay(3,29) (March 29 exists)\n        // for day overflow, correct day as necessary\n\n        // Set base year as 2000 (leap year)\n        int baseYear = 2000;\n        int[] newValues = values.clone();\n\n        // Recreate date with year\n        int month = 0, day = 0;\n        for (int i = 0; i < partial.size(); i++) {\n            if (\"monthOfYear\".equals(partial.getFieldType(i).getName())) {\n                month = values[i];\n            }\n            if (\"dayOfMonth\".equals(partial.getFieldType(i).getName())) {\n                day = values[i];\n            }\n        }\n        org.joda.time.Chronology chrono = iChronology.withUTC();\n\n        // If both month and day exist, use LocalDate for easy manipulation\n        if (month != 0 && day != 0 && partial.size() == 2) {\n            // Create base date\n            org.joda.time.LocalDate base = new org.joda.time.LocalDate(baseYear, month, 1, chrono);\n            int maxDay = base.dayOfMonth().getMaximumValue();\n            int realDay = Math.min(day, maxDay);\n            base = base.withDayOfMonth(realDay);\n\n            // Use the field being added to\n            if (\"monthOfYear\".equals(partial.getFieldType(fieldIndex).getName())) {\n                base = base.plusMonths(valueToAdd);\n                // Adjust to keep day if possible, or the last day of new month otherwise\n                int newMaxDay = base.dayOfMonth().getMaximumValue();\n                if (day > newMaxDay) {\n                    base = base.withDayOfMonth(newMaxDay);\n                } else {\n                    base = base.withDayOfMonth(day);\n                }\n            } else if (\"dayOfMonth\".equals(partial.getFieldType(fieldIndex).getName())) {\n                base = base.plusDays(valueToAdd);\n            } else {\n                // fallback to general algorithm\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return iChronology.get(partial, instant);\n            }\n\n            // <partial order: [month, day]>\n            for (int i = 0; i < partial.size(); i++) {\n                if (\"monthOfYear\".equals(partial.getFieldType(i).getName())) {\n                    newValues[i] = base.getMonthOfYear();\n                }\n                if (\"dayOfMonth\".equals(partial.getFieldType(i).getName())) {\n                    newValues[i] = base.getDayOfMonth();\n                }\n            }\n            return newValues;\n        } else {\n            // fallback to original algorithm for other partials\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        }\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}