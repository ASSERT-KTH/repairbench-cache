{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        // Find a leap year to use as the reference instant to allow for e.g. day=29 in February\n        int year = 2000; // 2000 is a leap year\n        long instant;\n        if (partial instanceof org.joda.time.MonthDay) {\n            // For MonthDay: fields are [monthOfYear, dayOfMonth]\n            org.joda.time.chrono.BaseChronology chrono = (org.joda.time.chrono.BaseChronology) iChronology.withUTC();\n            // set year, then month, then day\n            instant = chrono.year().set(0L, year);\n            instant = chrono.monthOfYear().set(instant, values[0]);\n            instant = chrono.dayOfMonth().set(instant, values[1]);\n        } else if (partial instanceof org.joda.time.Partial && partial.size() == 2 &&\n                partial.getFieldType(0).equals(org.joda.time.DateTimeFieldType.monthOfYear()) &&\n                partial.getFieldType(1).equals(org.joda.time.DateTimeFieldType.dayOfMonth())) {\n            // Defensive: behaves similar to MonthDay\n            org.joda.time.chrono.BaseChronology chrono = (org.joda.time.chrono.BaseChronology) iChronology.withUTC();\n            instant = chrono.year().set(0L, year);\n            instant = chrono.monthOfYear().set(instant, values[0]);\n            instant = chrono.dayOfMonth().set(instant, values[1]);\n        } else {\n            // Fallback to previous behavior\n            instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n        }\n        instant = add(instant, valueToAdd);\n        // Extract back out year-agnostic fields (remove year offset)\n        int[] newValues = iChronology.get(partial, instant);\n\n        // If a \"MonthDay\" or a [monthOfYear, dayOfMonth] Partial, ensure leap day is preserved if possible\n        if ((partial instanceof org.joda.time.MonthDay) ||\n            (partial instanceof org.joda.time.Partial && partial.size() == 2 &&\n             partial.getFieldType(0).equals(org.joda.time.DateTimeFieldType.monthOfYear()) &&\n             partial.getFieldType(1).equals(org.joda.time.DateTimeFieldType.dayOfMonth()))) {\n            // If original dayOfMonth was 29 Feb and new month is 2 and day is 28,\n            // but possible to set 29, do so\n            if (values[0] == 2 && values[1] == 29 && newValues[0] == 2 && newValues[1] == 28) {\n                org.joda.time.chrono.BaseChronology chrono = (org.joda.time.chrono.BaseChronology) iChronology.withUTC();\n                // Try to set day 29 in February in base leap year\n                try {\n                    long tmp = chrono.year().set(0L, year);\n                    tmp = chrono.monthOfYear().set(tmp, 2);\n                    tmp = chrono.dayOfMonth().set(tmp, 29);\n                    int[] candidate = new int[] {2, 29};\n                    // If successful, update newValues\n                    newValues[1] = 29;\n                } catch (org.joda.time.IllegalFieldValueException ex) {\n                    // ignore, keep day 28 fallback\n                }\n            } else if (values[0] == 3 && values[1] == 31 && newValues[0] == 2 && newValues[1] == 28) {\n                // March 31 - 1 month => February, try for Feb 29 if possible (if in leap)\n                org.joda.time.chrono.BaseChronology chrono = (org.joda.time.chrono.BaseChronology) iChronology.withUTC();\n                try {\n                    long tmp = chrono.year().set(0L, year);\n                    tmp = chrono.monthOfYear().set(tmp, 2);\n                    tmp = chrono.dayOfMonth().set(tmp, 29);\n                    int[] candidate = new int[] {2, 29};\n                    newValues[1] = 29;\n                } catch (org.joda.time.IllegalFieldValueException ex) {\n                    // ignore, use 28th\n                }\n            }\n        }\n        return newValues;\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}