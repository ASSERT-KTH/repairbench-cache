{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        // -- Special adjust: \"MonthDay\" (and similar) require day adjustment for month add --\n        // Only applies adding to month or dayOfMonth field\n        // Only run logic if fields are month + day (eg. MonthDay), but compatible for more fields too\n        Chronology chrono = iChronology;\n        int size = partial.size();\n        // Detect if we have month + day (common for MonthDay)\n        boolean hasMonth = false, hasDay = false;\n        int monthFieldIndex = -1;\n        int dayFieldIndex = -1;\n\n        for (int i = 0; i < size; i++) {\n            DateTimeFieldType type = partial.getFieldType(i);\n            if (type == DateTimeFieldType.monthOfYear()) {\n                hasMonth = true;\n                monthFieldIndex = i;\n            }\n            if (type == DateTimeFieldType.dayOfMonth()) {\n                hasDay = true;\n                dayFieldIndex = i;\n            }\n        }\n\n        if (hasMonth && hasDay && (fieldIndex == monthFieldIndex || fieldIndex == dayFieldIndex)) {\n            // assemble reference date, use year = 2000 (leap year) so Feb 29 is possible \n            int year = 2000;\n            int month = monthFieldIndex >= 0 ? values[monthFieldIndex] : 1;\n            int day = dayFieldIndex >= 0 ? values[dayFieldIndex] : 1;\n\n            // Use chronology to construct the instant\n            long instant = chrono.year().set(0L, year);\n            instant = chrono.monthOfYear().set(instant, month);\n            instant = chrono.dayOfMonth().set(instant, day);\n\n            if (fieldIndex == monthFieldIndex) {\n                // Add valueToAdd to monthOfYear, adjust dayOfMonth as necessary\n                instant = chrono.monthOfYear().add(instant, valueToAdd);\n            } else if (fieldIndex == dayFieldIndex) {\n                instant = chrono.dayOfMonth().add(instant, valueToAdd);\n            }\n            // After adding, get resulting month and day\n            int[] newValues = new int[size];\n            for (int i = 0; i < size; i++) {\n                DateTimeFieldType type = partial.getFieldType(i);\n                if (type == DateTimeFieldType.monthOfYear()) {\n                    newValues[i] = chrono.monthOfYear().get(instant);\n                } else if (type == DateTimeFieldType.dayOfMonth()) {\n                    newValues[i] = chrono.dayOfMonth().get(instant);\n                } else {\n                    newValues[i] = partial.getFieldType(i).getField(chrono).get(instant);\n                }\n            }\n            return newValues;\n        } else {\n            // Fallback to original \"contiguous\" logic for \"plain\" cases (e.g. pure days)\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        }\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}