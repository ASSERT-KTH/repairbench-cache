{
    "generation": "    //-----------------------------------------------------------------------\n    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            int[] result = iChronology.get(partial, instant);\n            // Check if the day of month is valid for the result month/year\n            // If not, return the last day of the month\n            if (partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) &&\n                iChronology.getFieldType(DateTimeFieldType.dayOfMonth()).isValid(result[0], result[1]) == false) {\n                // If the day is invalid, set it to the last day of the month\n                int year = 2004; // Starting with a leap year to handle Feb 29\n                int month = result[0];\n                // Find a matching month/year where the day is valid\n                // For Feb 29, we need to ensure we're in a leap year\n                int day = values[1]; // Keep original day value to try to preserve\n                while (!iChronology.dayOfMonth().isValid(year, month, day)) {\n                    if (month == 2 && day == 29) {\n                        // Leap day issue, try to find a valid leap year\n                        int maxDay = iChronology.getChronology().getMaximumValueForFieldType(DateTimeFieldType.dayOfMonth(), month, year);\n                        return new int[] {month, maxDay};\n                    }\n                    // Try to move to a different month or year that might work\n                    year++;\n                }\n            }\n            return result;\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}