{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // no change if nothing to add\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // Special\u2010case MonthDay (no year) so that Feb-29 is handled on a leap\u2010year baseline\n    if (partial instanceof MonthDay) {\n        // pick a constant leap\u2010year so Feb-29 can be represented\n        final int BASE_LEAP_YEAR = 2000;\n        // build a full instant at midnight of BASE_LEAP_YEAR\u2010MM\u2010DD\n        long instant = iChronology.getDateTimeMillis(\n            BASE_LEAP_YEAR,\n            values[0],  // monthOfYear\n            values[1],  // dayOfMonth\n            0           // millisOfDay\n        );\n        // add the requested amount of the correct unit (months or days)\n        DurationFieldType durType = partial.getFieldType(fieldIndex).getDurationType();\n        instant = durType.getField(iChronology).add(instant, valueToAdd);\n        // extract back just the MonthDay fields\n        return iChronology.get(partial, instant);\n    }\n    // Original \u201ccontiguous\u201d algorithm for all other partials\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i)\n                             .getField(iChronology)\n                             .set(instant, values[i]);\n        }\n        instant = add(instant, valueToAdd);\n        return iChronology.get(partial, instant);\n    }\n    // Fallback for non\u2010contiguous partials\n    return super.add(partial, fieldIndex, values, valueToAdd);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}