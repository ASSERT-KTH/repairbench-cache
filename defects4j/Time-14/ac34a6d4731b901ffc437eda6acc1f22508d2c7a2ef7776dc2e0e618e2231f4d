{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        // In order to get proper end-of-month adjustments for day/month calculations,\n        // we need a base date with a legal year (e.g., a leap year for Feb 29).\n        // We use 2004 as the base (a leap year).\n        // We adjust fields in partial to build a 'synthetic' instant, perform the add, then\n        // extract the fields we care about.\n        long instant;\n        int year = 2004; // leap year\n\n        // Find the positions of month and day, if present\n        int monthFieldIndex = -1;\n        int dayFieldIndex = -1;\n        for (int i = 0; i < partial.size(); i++) {\n            if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) {\n                monthFieldIndex = i;\n            } else if (partial.getFieldType(i) == DateTimeFieldType.dayOfMonth()) {\n                dayFieldIndex = i;\n            }\n        }\n\n        // Build the synthetic instant\n        Chronology chrono = iChronology.withUTC();\n        // Set the base time to 2004-01-01\n        instant = chrono.getDateTimeMillis(year, 1, 1, 0, 0, 0, 0);\n        // Set month and day fields if present, otherwise set all fields\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            DateTimeFieldType type = partial.getFieldType(i);\n            int value = values[i];\n            if (type == DateTimeFieldType.year()) {\n                // skip, use base year\n                continue;\n            }\n            instant = type.getField(chrono).set(instant, value);\n        }\n\n        // Add to the target field\n        instant = partial.getFieldType(fieldIndex).getField(chrono).add(instant, valueToAdd);\n\n        // Extract results\n        int[] newValues = new int[partial.size()];\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            DateTimeFieldType type = partial.getFieldType(i);\n            newValues[i] = type.getField(chrono).get(instant);\n        }\n        return newValues;\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}