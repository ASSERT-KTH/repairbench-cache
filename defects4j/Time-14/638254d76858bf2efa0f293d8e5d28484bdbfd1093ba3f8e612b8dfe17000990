{
    "generation": "//-----------------------------------------------------------------------\npublic int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    if (DateTimeUtils.isContiguous(partial)) {\n        // MonthDay and other partials might use a \"dummy year\", so use leap year (e.g. 2000) to allow Feb 29, and handle result mapping\n        long instant = 0L;\n        // Use a known leap year to construct reference instant\n        int[] calcValues = values.clone();\n        int year = 2000;\n        boolean hasYear = false;\n        // Find if the partial has year field\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            if (\"year\".equals(partial.getFieldType(i).getName())) {\n                hasYear = true;\n                break;\n            }\n        }\n        // If no year, prepend year 2000 for calc\n        ReadablePartial calcPartial = partial;\n        if (!hasYear) {\n            // Create a LocalDate-like ReadablePartial with year\n            org.joda.time.Chronology chrono = iChronology.withUTC();\n            org.joda.time.field.FieldUtils.verifyValueBounds(values, 0, 1, partial.size() - 1);\n            org.joda.time.Partial temp = new org.joda.time.Partial(partial, values);\n            // Insert year at index 0, for calculations\n            org.joda.time.DateTimeFieldType[] newFieldTypes = new org.joda.time.DateTimeFieldType[partial.size() + 1];\n            int[] newValues = new int[partial.size() + 1];\n            newFieldTypes[0] = org.joda.time.DateTimeFieldType.year();\n            newValues[0] = year;\n            for (int i = 0; i < partial.size(); i++) {\n                newFieldTypes[i + 1] = partial.getFieldType(i);\n                newValues[i + 1] = values[i];\n            }\n            temp = temp.with(newFieldTypes[0], newValues[0]);\n            for (int i = 1; i < newFieldTypes.length; i++) {\n                temp = temp.with(newFieldTypes[i], newValues[i]);\n            }\n            calcPartial = temp;\n            calcValues = temp.getValues();\n        }\n        // Now, calcPartial has year, month, day, etc\n        // Build millis instant\n        instant = iChronology.set(calcPartial, calcValues);\n        // Add\n        instant = add(instant, valueToAdd);\n        // Extract values back (year, month, day, etc)\n        int[] resultValues;\n        resultValues = iChronology.get(calcPartial, instant);\n        if (!hasYear) {\n            // Remove 'year' value at index 0\n            int[] ret = new int[resultValues.length - 1];\n            System.arraycopy(resultValues, 1, ret, 0, ret.length);\n            return ret;\n        } else {\n            return resultValues;\n        }\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}