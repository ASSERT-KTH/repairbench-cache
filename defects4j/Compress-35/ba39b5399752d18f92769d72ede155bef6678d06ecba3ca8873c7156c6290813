{
    "generation": "    /**\n     * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n     * <blockquote>\n     * The checksum is calculated by taking the sum of the unsigned byte values\n     * of the header block with the eight checksum bytes taken to be ascii\n     * spaces (decimal value 32). It is stored as a six digit octal number with\n     * leading zeroes followed by a NUL and then a space. Various\n     * implementations do not adhere to this format. For better compatibility,\n     * ignore leading and trailing whitespace, and get the first six digits. In\n     * addition, some historic tar implementations treated bytes as signed.\n     * Implementations typically calculate the checksum both ways, and treat it\n     * as good if either the signed or unsigned sum matches the included\n     * checksum.\n     * </blockquote>\n     * <p>\n     * Some TAR archives, particularly those produced by GNU tar, may contain\n     * negative values in the checksum field (using binary numbers) as used by\n     * the GNU tar {@code --incremental} option. This is documented in the\n     * <a href=\"https://www.gnu.org/software/tar/manual/html_node/Standard.html\">GNU Tar Standard</a>.\n     * Such archives are expected to have the high bit set in the first byte of\n     * the checksum field (byte 148). Handling such archives requires parsing\n     * the checksum field as a binary number, which this method does not currently\n     * do. As a workaround for COMPRESS-335, we accept headers with the high bit\n     * set in the first checksum byte, assuming they are valid GNU incremental\n     * headers, without actually verifying the checksum. A more complete solution\n     * would involve parsing the binary checksum.\n     * </p>\n     * <p>\n     * The return value of this method should be treated as a best-effort\n     * heuristic rather than an absolute and final truth. The checksum\n     * verification logic may well evolve over time as more special cases\n     * are encountered.\n     *\n     * @param header tar header\n     * @return whether the checksum is reasonably good\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n     * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-335\">COMPRESS-335</a>\n     * @since 1.5\n     */\n    public static boolean verifyCheckSum(byte[] header) {\n        // COMPRESS-335 - Need to handle binary checksums (GNU incremental archives)\n        // Header byte 148 (CHKSUM_OFFSET) has the high bit set for binary checksums.\n        // For now, assume valid if the binary marker is found. A more robust\n        // solution would parse the binary checksum.\n        if ((header[TarConstants.CHKSUM_OFFSET] & 0x80) != 0) {\n            return true; // Assume binary checksum is valid\n        }\n\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        for (int i = 0; i < header.length; i++) {\n            byte b = header[i];\n            if (TarConstants.CHKSUM_OFFSET  <= i && i < TarConstants.CHKSUM_OFFSET + TarConstants.CHKSUMLEN) {\n                // Parse octal checksum digits, ignoring leading spaces/NULs,\n                // stopping at the first non-octal digit after a digit has been seen,\n                // or after 6 digits.\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + b - '0';\n                } else if (digits > 0) {\n                    // Stop parsing if non-octal or > 6 digits encountered after first digit\n                    // Setting digits = 6 ensures we don't parse any more digits\n                    digits = 6;\n                }\n                 // NUL (0) and Space (' ') are not octal digits '0'-'7'.\n                 // If encountered after digits started (digits > 0), parsing stops via the 'else if'.\n                 // If encountered before digits started (digits = 0), they are skipped (no change to storedSum).\n                b = ' '; // Replace checksum byte with space for checksum calculation\n            }\n            unsignedSum += 0xff & b;\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}