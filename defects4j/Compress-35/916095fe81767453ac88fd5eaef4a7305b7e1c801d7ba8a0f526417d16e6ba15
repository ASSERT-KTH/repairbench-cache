{
    "generation": "public static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    int offset = CHKSUM_OFFSET;\n    int len = CHKSUMLEN;\n    int idx = offset;\n    int end = offset + len;\n\n    // 1) parse the stored checksum: skip leading NULs/spaces, read up to 6 octal digits\n    while (idx < end && (header[idx] == 0 || header[idx] == ' ')) {\n        idx++;\n    }\n    int digitCount = 0;\n    while (idx < end && digitCount < 6) {\n        byte b = header[idx];\n        if (b >= '0' && b <= '7') {\n            storedSum = (storedSum << 3) + (b - '0');\n            digitCount++;\n            idx++;\n        } else {\n            break;\n        }\n    }\n\n    // 2) compute the two sums over the header, treating the checksum field as ASCII spaces\n    long unsignedSum = 0;\n    long signedSum   = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= offset && i < offset + len) {\n            b = ' ';\n        }\n        unsignedSum += (b & 0xFF);\n        signedSum   += b;\n    }\n\n    // 3) for some historic tars the checksum\u2010field was zeroed (NULs) not filled with spaces.\n    //    That would make the computed\u2010as\u2010space sum higher by 32*len.\n    long adjust = (' ' & 0xFF) * len;\n    long unsignedNullSum = unsignedSum - adjust;\n    long signedNullSum   = signedSum   - adjust;\n\n    return storedSum == unsignedSum\n        || storedSum == signedSum\n        || storedSum == unsignedNullSum\n        || storedSum == signedNullSum;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}