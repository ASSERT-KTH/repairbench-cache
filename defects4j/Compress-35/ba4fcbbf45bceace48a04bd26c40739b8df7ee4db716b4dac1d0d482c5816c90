{
    "generation": "/**\n * Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n * <blockquote>\n * The checksum is calculated by taking the sum of the unsigned byte values\n * of the header block with the eight checksum bytes taken to be ascii\n * spaces (decimal value 32). It is stored as a six digit octal number with\n * leading zeroes followed by a NUL and then a space. Various\n * implementations do not adhere to this format. For better compatibility,\n * ignore leading and trailing whitespace, and get the first six digits. In\n * addition, some historic tar implementations treated bytes as signed.\n * Implementations typically calculate the checksum both ways, and treat it\n * as good if either the signed or unsigned sum matches the included\n * checksum.\n * </blockquote>\n * <p>\n * The return value of this method should be treated as a best\u2010effort\n * heuristic rather than an absolute and final truth. The checksum\n * verification logic may well evolve over time as more special cases\n * are encountered.\n *\n * @param header tar header\n * @return whether the checksum is reasonably good\n * @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n * @since 1.5\n */\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    // 1) Parse the stored checksum field in the header.\n    //    Support both ASCII\u2010octal and base\u2010256 (binary) formats.\n    if ((header[CHKSUM_OFFSET] & 0x80) != 0) {\n        // Base-256: big-endian two's\u2010complement integer in the entire field.\n        for (int i = 0; i < CHKSUMLEN; i++) {\n            storedSum = (storedSum << 8) | (header[CHKSUM_OFFSET + i] & 0xFF);\n        }\n    } else {\n        // ASCII octal: ignore leading/trailing whitespace, read up to 6 octal digits.\n        int count = 0;\n        for (int i = CHKSUM_OFFSET; i < CHKSUM_OFFSET + CHKSUMLEN; i++) {\n            byte b = header[i];\n            if (b >= '0' && b <= '7') {\n                storedSum = (storedSum << 3) + (b - '0');\n                count++;\n                if (count == 6) {\n                    break;\n                }\n            } else if (count > 0) {\n                // once we've seen digits, stop at first non-octal\n                break;\n            }\n            // otherwise skip any leading NULs or spaces\n        }\n    }\n\n    // 2) Recompute the checksum over the entire header block,\n    //    treating the checksum field itself as if it were filled with spaces.\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            b = ' ';\n        }\n        unsignedSum += (b & 0xFF);\n        signedSum += b;\n    }\n\n    // 3) Accept if either the unsigned or signed sum matches the stored value.\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}