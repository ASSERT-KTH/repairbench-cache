{
    "generation": "public static boolean verifyCheckSum(byte[] header) {\n    // First, extract the checksum field as an ASCII string and trim any surrounding whitespace.\n    String csField;\n    try {\n        csField = new String(header, CHKSUM_OFFSET, CHKSUMLEN, \"US-ASCII\").trim();\n    } catch (java.io.UnsupportedEncodingException uee) {\n        csField = new String(header, CHKSUM_OFFSET, CHKSUMLEN).trim();\n    }\n    // Extract the first contiguous run of octal digits (max 6) from the trimmed field.\n    StringBuilder digitsSb = new StringBuilder();\n    for (int i = 0; i < csField.length() && digitsSb.length() < 6; i++) {\n        char c = csField.charAt(i);\n        if (c >= '0' && c <= '7') {\n            digitsSb.append(c);\n        } else if (digitsSb.length() > 0) {\n            // Once we\u2019ve started reading digits, stop at the first non-octal.\n            break;\n        }\n    }\n\n    long storedSum = 0;\n    if (digitsSb.length() > 0) {\n        try {\n            storedSum = Long.parseLong(digitsSb.toString(), 8);\n        } catch (NumberFormatException nfe) {\n            storedSum = -1;\n        }\n    }\n\n    long unsignedSum = 0;\n    long signedSum = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        // For checksum calculation, treat the checksum field as if it were all spaces.\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            b = ' ';\n        }\n        unsignedSum += (b & 0xff);\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}