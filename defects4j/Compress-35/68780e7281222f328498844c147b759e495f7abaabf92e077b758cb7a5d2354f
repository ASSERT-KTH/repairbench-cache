{
    "generation": "public static boolean verifyCheckSum(byte[] header) {\n    // First, extract the stored checksum from the header\u2019s checksum field.\n    // According to the spec, the checksum is stored as an octal number,\n    // possibly padded with spaces and/or a NUL. We\u2019ll extract the field as a string,\n    // trim off whitespace and any trailing NUL, and then parse out the first group of octal digits.\n    String s = new String(header, CHKSUM_OFFSET, CHKSUMLEN, java.nio.charset.StandardCharsets.US_ASCII).trim();\n    int nullPos = s.indexOf('\\0');\n    if (nullPos != -1) {\n        s = s.substring(0, nullPos).trim();\n    }\n    int start = 0;\n    while (start < s.length() && Character.isWhitespace(s.charAt(start))) {\n        start++;\n    }\n    int end = start;\n    while (end < s.length() && s.charAt(end) >= '0' && s.charAt(end) <= '7') {\n        end++;\n    }\n    long storedSum = 0;\n    if (start < end) {\n        try {\n            storedSum = Long.parseLong(s.substring(start, end), 8);\n        } catch (NumberFormatException e) {\n            storedSum = -1;\n        }\n    }\n\n    // Now calculate the checksum over the header,\n    // but treat the entire checksum field (CHKSUM_OFFSET ... CHKSUM_OFFSET+CHKSUMLEN-1)\n    // as if it were all ASCII spaces.\n    long unsignedSum = 0;\n    long signedSum = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            b = ' ';\n        }\n        unsignedSum += (b & 0xff);\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}