{
    "generation": "public static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    // Special\u2010case: if the entire header is zero (empty or end\u2010of\u2010archive block), treat as valid\n    boolean allZero = true;\n    for (byte b : header) {\n        if (b != 0) {\n            allZero = false;\n            break;\n        }\n    }\n    if (allZero) {\n        return true;\n    }\n\n    // Detect base\u2010256 (binary) checksum: high bit set in first checksum byte\n    if ((header[CHKSUM_OFFSET] & 0x80) != 0) {\n        // Decode two's\u2010complement big\u2010endian\n        byte[] chk = new byte[CHKSUMLEN];\n        System.arraycopy(header, CHKSUM_OFFSET, chk, 0, CHKSUMLEN);\n        java.math.BigInteger bi = new java.math.BigInteger(chk);\n        storedSum = bi.longValue();\n    } else {\n        // ASCII octal: ignore leading/trailing whitespace, read up to 6 octal digits\n        int end = CHKSUM_OFFSET + CHKSUMLEN;\n        int digits = 0;\n        for (int i = CHKSUM_OFFSET; i < end; i++) {\n            byte b = header[i];\n            if (b >= '0' && b <= '7') {\n                if (digits < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                    digits++;\n                }\n            } else if (digits > 0) {\n                // end of the octal number\n                break;\n            }\n        }\n    }\n\n    // Compute the real checksum, treating the checksum field bytes as ASCII spaces (0x20)\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (i >= CHKSUM_OFFSET && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            b = ' ';\n        }\n        unsignedSum += (b & 0xFF);\n        signedSum += b;\n    }\n\n    // Accept if either the unsigned or signed sum matches the stored value\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}