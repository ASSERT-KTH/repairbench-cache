{
    "generation": "    public static boolean verifyCheckSum(byte[] header) {\n        long storedSum = 0;\n        long unsignedSum = 0;\n        long signedSum = 0;\n\n        int digits = 0;\n        // The checksum is calculated over the full 512-byte header block.\n        // If the provided 'header' array is shorter, missing bytes are treated as NUL (0).\n        // The checksum field itself (8 bytes) is treated as spaces for the sum calculation.\n        for (int i = 0; i < TarConstants.HEADER_SIZE; i++) {\n            byte b;\n            if (i < header.length) {\n                b = header[i];\n            } else {\n                // Treat bytes beyond the provided header length as NUL (0) for checksum calculation.\n                b = 0;\n            }\n\n            if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n                // When parsing the stored checksum, only consider digits from the available header bytes.\n                // The byte 'b' here is the original byte from the header (or 0 if missing).\n                if ('0' <= b && b <= '7' && digits++ < 6) {\n                    storedSum = storedSum * 8 + (b - '0');\n                } else if (digits > 0) {\n                    // If a non-octal digit is encountered after some digits have been read,\n                    // or if 6 digits have already been parsed, stop further digit parsing.\n                    digits = 6;\n                }\n                // For the sum calculation (unsignedSum/signedSum), replace the checksum bytes with spaces.\n                b = ' ';\n            }\n            unsignedSum += (0xff & b);\n            signedSum += b;\n        }\n        return storedSum == unsignedSum || storedSum == signedSum;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}