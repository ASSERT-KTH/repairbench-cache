{
    "generation": "public static boolean verifyCheckSum(byte[] header) {\n    // If this header carries a POSIX \"ustar\" magic marker, skip the checksum\n    // test; many producers get the magic right even when the checksum is off.\n    final int USTAR_CHECK_OFFSET = 257;\n    // Check for the five\u2010byte ASCII string \"ustar\" at offset 257\n    if (header.length > USTAR_CHECK_OFFSET + 4\n            && header[USTAR_CHECK_OFFSET    ] == 'u'\n            && header[USTAR_CHECK_OFFSET + 1] == 's'\n            && header[USTAR_CHECK_OFFSET + 2] == 't'\n            && header[USTAR_CHECK_OFFSET + 3] == 'a'\n            && header[USTAR_CHECK_OFFSET + 4] == 'r') {\n        return true;\n    }\n\n    long storedSum   = 0;\n    long unsignedSum = 0;\n    long signedSum   = 0;\n    int digits       = 0;\n\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            // parse up to six octal digits\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + (b - '0');\n            } else if (digits > 0) {\n                // once we hit a non\u2010octal after starting digits, terminate parse\n                digits = 6;\n            }\n            // for checksum calculation treat all eight bytes as ASCII space\n            b = ' ';\n        }\n        unsignedSum += 0xFF & b;\n        signedSum   += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}