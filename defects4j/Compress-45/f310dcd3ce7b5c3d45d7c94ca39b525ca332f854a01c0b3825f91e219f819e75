{
    "generation": "    /**\n     * Write an long integer into a buffer as an octal string if this\n     * will fit, or as a binary number otherwise.\n     *\n     * Uses {@link #formatLongOctalBytes} to format\n     * the value as an octal string with leading zeros.\n     * The converted number is followed by a space.\n     * <p>\n     * If the value does not fit as an octal string, it will be written\n     * as a binary number (base-256) according to the POSIX pax standard.\n     * This format uses the highest bit of the first byte as a marker\n     * and encodes the value in the remaining bits using two's complement\n     * representation over the entire field length.\n     * </p>\n     *\n     * @param value The value to write into the buffer.\n     * @param buf The destination buffer.\n     * @param offset The starting offset into the buffer.\n     * @param length The length of the buffer field. Must be at least 2.\n     * @return The updated offset.\n     * @throws IllegalArgumentException if the value (and trailer)\n     * will not fit in the buffer, or if length is less than 2.\n     * @since 1.4\n     */\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field for octal limits\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        // Try to format as octal if positive and within octal limits\n        if (!negative && value <= maxAsOctalChar) {\n            try {\n                // formatLongOctalBytes should handle padding and termination\n                return formatLongOctalBytes(value, buf, offset, length);\n            } catch (IllegalArgumentException e) {\n                // This happens if the value, despite being <= maxAsOctalChar,\n                // doesn't fit with the required padding/termination in formatLongOctalBytes.\n                // Fall-through to binary formatting is the correct behavior.\n            }\n        }\n\n        // POSIX pax base-256 binary format requires a minimum length\n        if (length < 2) {\n             // Ensures we have at least one bit for the marker and one for the value.\n             throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n        }\n\n        // Check if the value fits in the binary representation.\n        // The range is [-2^(L*8-1), 2^(L*8-1)-1]\n        // This check is only strictly necessary if length < 8, as for length >= 8\n        // the range covers all possible long values.\n        if (length < 8) {\n            final int signBitIndex = length * 8 - 1;\n            // Calculate the power of 2 safely. 1L << signBitIndex is 2^signBitIndex.\n            final long limit = 1L << signBitIndex;\n            final long maxPositive = limit - 1; // 2^(signBitIndex) - 1\n            final long minNegative = -limit;    // -2^(signBitIndex)\n            if (value > maxPositive || value < minNegative) {\n                 throw new IllegalArgumentException(\"Value \" + value + \" is too large for \" + length + \" byte field.\");\n            }\n        }\n        // No check needed for length >= 8 as any long fits within 64 bits or more.\n\n        // Write the value as two's complement bytes (Big Endian) into the buffer\n        long val = value;\n        for (int i = offset + length - 1; i >= offset; i--) {\n            buf[i] = (byte) val;\n            val >>= 8; // Use signed right shift for correct two's complement propagation\n        }\n\n        // Set the marker bit (high bit of the first byte) according to POSIX pax standard\n        buf[offset] |= (byte) 0x80;\n\n        return offset + length;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}