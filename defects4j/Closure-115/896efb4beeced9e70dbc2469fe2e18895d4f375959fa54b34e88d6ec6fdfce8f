{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects or are not idempotent,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++); // 'i++' has side effects\n   *     y = foo(new Bar()); // 'new Bar()' is not idempotent\n   * </pre>\n   * 2) The function does not reference the 'arguments' object.\n   * 3) The function does not reference 'this'. (Handled by isDirectCallNodeReplacementPossible)\n   * 4) The function is not recursive. (Handled elsewhere)\n   * 5) The function is not defined using JS Doc 'noinline'. (Handled by isDirectCallNodeReplacementPossible)\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // Don't inline functions that reference the arguments object. Inlining\n    // changes the arguments object.\n    if (NodeUtil.referencesArguments(block)) {\n      return CanInlineResult.NO;\n    }\n\n    // CALL NODE: [ NAME/GETPROP, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Handle the \".call(thisObj, arg1, ...)\" pattern specifically.\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // The first argument is the 'this' value.\n        // Direct inlining requires 'this' to be passed literally, as complex\n        // 'this' values are not substituted by this pass.\n        if (cArg == null || !cArg.isThis()) {\n            // TODO(johnlenz): Support replacing 'this' with a value.\n            return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext(); // Skip the 'this' argument.\n    } else if (!callNode.getFirstChild().isName()) {\n        // Allow direct calls (NAME) or the handled .call pattern.\n        // Disallow .apply or other indirect calls (e.g., obj[method]()).\n        // .apply is handled by another pass.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n        return CanInlineResult.NO;\n    }\n\n    // FUNCTION NODE -> LP NODE: [ NAME ARG1, NAME ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // Check each parameter that is referenced in the function body.\n      if (fnParam != null) {\n        String paramName = fnParam.getString();\n        // Only check parameters that are referenced.\n        if (NodeUtil.isNameReferenced(block, paramName)) {\n          int refCount = NodeUtil.getNameReferenceCount(block, paramName);\n\n          // If a parameter is referenced more than once...\n          if (refCount > 1) {\n            if (cArg != null) {\n              // ... the corresponding argument must be safe to duplicate.\n              // An argument is safe to duplicate if it has no side effects and\n              // is idempotent (evaluating it multiple times yields the same result\n              // without further side effects).\n              if (NodeUtil.mayHaveSideEffects(cArg, compiler) ||\n                  !NodeUtil.isIdempotentExpression(cArg)) {\n                // Unsafe to duplicate the argument expression.\n                return CanInlineResult.NO;\n              }\n            } else {\n              // Parameter is referenced multiple times, but no argument provided (undefined).\n              // This is safe, as 'undefined' is idempotent and has no side effects.\n              // No action needed.\n            }\n          }\n          // If refCount is 0 or 1, argument properties (side effects, idempotency)\n          // don't matter for duplication safety.\n        }\n        fnParam = fnParam.getNext();\n      }\n\n      // Move to the next call argument. Arguments without corresponding parameters\n      // are evaluated for their side effects but otherwise ignored unless\n      // 'arguments' is used (which we disallowed earlier).\n      if (cArg != null) {\n        cArg = cArg.getNext();\n      }\n    }\n\n    // If all checks pass, the function can be inlined directly.\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}