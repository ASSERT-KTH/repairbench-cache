{
    "generation": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasReturnWithSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasReturnWithSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n\n    // Function parameters\n    Node fnParams = NodeUtil.getFunctionParameters(fnNode);\n    int paramCount = fnParams.getChildCount();\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Check special cases like apply and call\n    if (!callNode.getFirstChild().isName() &&\n        NodeUtil.isFunctionObjectCall(callNode)) {\n      if (!cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n\n    int argIndex = 0;\n    for (int paramIndex = 0; paramIndex < paramCount; paramIndex++) {\n      Node fnParam = fnParams.getChild(paramIndex);\n      String paramName = fnParam.getString();\n\n      // Check if this parameter can be inlined\n      if (!canParameterBeInlined(block, paramName)) {\n        return CanInlineResult.NO;\n      }\n\n      // Move to next argument\n      while (cArg != null && cArg.isArgList()) {\n        cArg = cArg.getFirstChild();\n      }\n      if (argIndex >= cArg.getChildCount()) {\n        return CanInlineResult.NO;\n      }\n      Node arg = cArg.getChild(argIndex);\n      argIndex++;\n\n      // Check argument side effects\n      if (NodeUtil.mayHaveSideEffects(arg, compiler)) {\n        return CanInlineResult.NO;\n      }\n\n      // Additional checks for argument effects\n      if (NodeUtil.mayEffectMutableState(arg, compiler) &&\n          NodeUtil.getNameReferenceCount(block, paramName) > 1) {\n        return CanInlineResult.NO;\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n\n  private boolean canParameterBeInlined(Node block, String paramName) {\n    if (block == null) {\n      return false;\n    }\n\n    for (Node node = block.getFirstChild(); node != null; node = node.getNext()) {\n      if (node.isName() && node.getString().equals(paramName)) {\n        // Check if the parameter is on the left-hand side of an assignment\n        if (node.getParent().isAssign()) {\n          return false;\n        }\n        // Within a function call as an argument that can cause side effects\n        // (like params of a function that is called where the param may be modified)\n        if (node.getParent().isCall() &&\n            NodeUtil.mayEffectMutableState(node.getParent(), compiler)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}