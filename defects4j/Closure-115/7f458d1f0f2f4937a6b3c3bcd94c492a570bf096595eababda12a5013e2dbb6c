{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // The 'hasSideEffects' variable (originally named 'hasSideEffects') checks if the\n    // *return expression* of the function being inlined has side effects.\n    // This variable was previously used in a check that was causing incorrect\n    // rejections for inlining (e.g., when an argument's properties were modified).\n    // This variable is not used in the corrected logic, as the Javadoc's rule 1\n    // specifically refers to the *call's arguments* having side effects.\n    // boolean hasReturnSideEffects = false;\n    // if (block.hasChildren()) {\n    //   Preconditions.checkState(block.hasOneChild());\n    //   Node stmt = block.getFirstChild();\n    //   if (stmt.isReturn()) {\n    //     hasReturnSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n    //   }\n    // }\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        // This check prevents inlining if the 'this' argument is not explicitly\n        // the `this` keyword, or if it's omitted. This is a conservative approach\n        // given the complexities of 'this' binding.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) { // We have a formal parameter.\n        if (cArg != null) { // We have a corresponding call argument.\n          // Rule 1: If a call's arguments have side effects,\n          // the corresponding argument in the function must only be referenced once.\n          // Example: function foo(a) { return a + a } ; x = foo(i++);\n          // Here, cArg is i++ (has side effects), fnParam 'a' is referenced twice.\n          // This should prevent inlining.\n          if (NodeUtil.mayHaveSideEffects(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n\n          // Removed the following problematic checks:\n          // The previous check `if (hasSideEffects && NodeUtil.canBeSideEffected(cArg))`\n          // incorrectly returned NO if the function's return value had side effects\n          // and the argument could itself be side-effected (e.g., an object). This is too broad.\n          //\n          // The previous check `if (NodeUtil.mayEffectMutableState(cArg, compiler) && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1)`\n          // also incorrectly returned NO for cases like `function f(a){return a.x=2}f(o)`.\n          // `o` is a mutable object, and `a` is referenced twice. However, `o` itself\n          // does not have side effects as an expression. The side effect (`a.x=2`)\n          // happens *inside* the function, and modifying properties of an object\n          // argument is generally permissible for direct inlining.\n        }\n\n        // Move to the next parameter name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects.\n      // This applies to arguments that do not have a corresponding formal parameter\n      // (too many arguments passed to the function), or if the argument itself\n      // has side effects.\n      if (cArg != null) {\n        // If an argument does not correspond to a parameter (fnParam == null)\n        // AND the argument expression has side effects (e.g., `i++`),\n        // then we cannot inline because the side effect would be lost.\n        // Example: `function f() {} f(i++);` -> `f()` would drop `i++`. This is wrong.\n        if (fnParam == null && NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}