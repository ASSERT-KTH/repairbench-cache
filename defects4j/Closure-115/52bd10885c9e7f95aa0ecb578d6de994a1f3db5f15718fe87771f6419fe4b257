{
    "generation": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects, the corresponding argument in\n * the function must only be referenced once.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\nprivate CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  // Determine if the function\u2019s return expression has side effects.\n  boolean hasSideEffects = false;\n  if (block.hasChildren()) {\n    // Only a single statement is allowed for direct inlining.\n    Preconditions.checkState(block.hasOneChild());\n    Node stmt = block.getFirstChild();\n    if (stmt.isReturn()) {\n      hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n    }\n  }\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // For functions called via 'call' and 'apply', the receiver (this-object)\n  // appears as the first argument but is not part of the callee\u2019s parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replacing the receiver with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" calls should be filtered out before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> parameter list node: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n  // Process paired parameters and call arguments.\n  while (fnParam != null && cArg != null) {\n    // If the argument might be affected by side effects and the corresponding\n    // parameter is referenced more than once, then inlining may duplicate the effect.\n    if (((hasSideEffects && NodeUtil.canBeSideEffected(cArg))\n         || NodeUtil.mayEffectMutableState(cArg, compiler))\n         && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n      return CanInlineResult.NO;\n    }\n    fnParam = fnParam.getNext();\n    cArg = cArg.getNext();\n  }\n\n  // Any leftover arguments (those not paired with a formal parameter) must be free of side effects.\n  while (cArg != null) {\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}