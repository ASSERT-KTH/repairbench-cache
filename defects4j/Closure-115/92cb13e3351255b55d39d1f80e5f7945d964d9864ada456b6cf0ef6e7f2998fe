{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects or may modify state,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   * 2) If a function uses the 'arguments' object, it cannot be inlined if the\n   *    number of arguments at the call site does not match the number of formal\n   *    parameters.\n   * 3) If the function has arguments that are not named (e.g. var_args) and\n   *    these arguments have side-effects, the function cannot be inlined directly.\n   * 4) The function must have a simple body (a single return statement).\n   * 5) The function must not reference 'this'.\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    // Check for simple function structure (e.g., return statement only, no 'this')\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // Function body must be a single return statement, possibly in a label.\n    // isDirectCallNodeReplacementPossible checks this structure. If the block\n    // has children, the first must be a return or a label containing a return.\n    if (block.hasChildren()) {\n        Node stmt = block.getFirstChild();\n        // Allow RETURN or LABEL -> RETURN\n        boolean isReturn = stmt.isReturn();\n        boolean isLabeledReturn = stmt.isLabel() && stmt.hasOneChild() && stmt.getLastChild().isReturn();\n        if (!isReturn && !isLabeledReturn) {\n            // This case should theoretically be caught by isDirectCallNodeReplacementPossible,\n            // but we double-check here.\n             return CanInlineResult.NO;\n        }\n    }\n    // Empty functions (no block children) are not handled by direct replacement currently.\n    // isDirectCallNodeReplacementPossible should return false for them.\n\n    boolean usesArguments = NodeUtil.usesArguments(fnNode);\n\n    // CALL NODE: [ NAME/GETPROP, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Handle \".call\". Adjust cArg to skip the 'this' value.\n    if (!callNode.getFirstChild().isName()) { // e.g. GETPROP\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // Require 'this' preservation for now. Direct inlining doesn't handle\n        // 'this' explicitly, so we rely on isDirectCallNodeReplacementPossible\n        // rejecting functions that use 'this'. If the call uses .call(this,...),\n        // it preserves the 'this' context, but we still don't inline functions\n        // that *use* 'this' directly.\n        // TODO(johnlenz): Support replacing 'this' with values other than 'this'.\n        if (cArg == null || !cArg.isThis()) {\n          // We only allow inlining '.call' if the first arg is 'this',\n          // assuming the inlined function doesn't reference 'this' itself.\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext(); // Skip 'this' argument.\n      } else {\n        // '.apply' call should be filtered before this function is called.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode),\n            \"Apply call should not be directly inlined.\");\n      }\n    }\n\n    // FUNCTION NODE -> PARAM_LIST: [ PARAM1, PARAM2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n    while (cArg != null || fnParam != null) {\n      // If the function uses 'arguments', the number of arguments at the call\n      // site must exactly match the number of formal parameters.\n      if (usesArguments) {\n        // If the counts mismatch (one is null while the other isn't)\n        if ((cArg == null) != (fnParam == null)) {\n          return CanInlineResult.NO;\n        }\n      }\n\n      // Check arguments corresponding to function parameters.\n      if (fnParam != null) {\n        if (cArg != null) {\n          // Check for parameters referenced multiple times.\n          int refCount = NodeUtil.getNameReferenceCount(block, fnParam.getString());\n          if (refCount > 1) {\n            // If the parameter is referenced multiple times, the corresponding\n            // argument must not change state or have side-effects.\n            if (NodeUtil.mayEffectMutableState(cArg, compiler)\n                || NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n              return CanInlineResult.NO;\n            }\n          }\n        }\n        // else: cArg is null (missing argument). This is fine unless usesArguments (checked above).\n\n        // Move to the next parameter.\n        fnParam = fnParam.getNext();\n      }\n\n      // Check arguments that do not correspond to function parameters (extra args).\n      if (cArg != null) {\n        // If this argument has no corresponding parameter (fnParam is null)...\n        if (fnParam == null) {\n           // ...it must not have side-effects, as they would be dropped.\n           // (This case is implicitly covered by the 'usesArguments' check above\n           // if 'usesArguments' is true, because the counts would mismatch.\n           // If 'usesArguments' is false, we must still check for side effects here.)\n           if (!usesArguments && NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n             return CanInlineResult.NO;\n           }\n        }\n        // Move to the next argument.\n        cArg = cArg.getNext();\n      }\n    }\n\n    // All checks passed.\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}