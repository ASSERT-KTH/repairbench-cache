{
    "generation": "/**\n * Determines whether a function can be inlined at a particular call site.\n * Inlining is disallowed when an argument that may have side effects\n * (or may be mutated) is substituted for a parameter that is referenced\n * more than once in the function body. Also, any extra call arguments (those\n * not matching a named parameter) must be side\u2010effect free since inlining\n * would remove their evaluation.\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  // The function body is expected to be the last child.\n  Node block = fnNode.getLastChild();\n\n  // CALL NODE structure: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Handle cases like foo.call(..):\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // For .call calls the first argument is the \"this\" value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // Calls via .apply should be filtered out earlier.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // Iterate over each formal parameter and the corresponding call argument.\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (fnParam != null && cArg != null) {\n    int refCount = NodeUtil.getNameReferenceCount(block, fnParam.getString());\n    // If the call argument might have side effects (or be mutated)\n    // and the parameter is referenced more than once, inlining would\n    // cause the argument to be evaluated multiple times.\n    if (refCount > 1 &&\n        (NodeUtil.mayHaveSideEffects(cArg, compiler) ||\n         NodeUtil.mayEffectMutableState(cArg, compiler))) {\n      return CanInlineResult.NO;\n    }\n    fnParam = fnParam.getNext();\n    cArg = cArg.getNext();\n  }\n\n  // For any leftover call arguments not matched to a parameter,\n  // they are normally evaluated even if unused. After inlining they might vanish.\n  // Thus, if any such extra argument could have side effects, we cannot inline.\n  while (cArg != null) {\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}