{
    "generation": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n    // safeguard against a zero initial value\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n    int n = 1;\n    // these variables hold, respectively, p[-1], p[0] and q[-1], q[0] so that the recurrence\n    //   p[n] = b\u2099 * p[n \u2013 1] + a\u2099 * p[n \u2013 2]\n    //   q[n] = b\u2099 * q[n \u2013 1] + a\u2099 * q[n \u2013 2]\n    // reproduces the standard continued fraction approximants f[n] = p[n] / q[n].\n    // In our implementation, getA(0, x) returns b\u2080, and for n>=1 one should have:\n    //   b\u2099 = getA(n, x)    and    a\u2099 = getB(n, x)\n    double dPrev = 0.0; // q[-1]\n    double p0    = 1.0; // p[-1]\n    double q1    = 1.0; // q[0]\n    double cPrev = hPrev; // f\u2080 = p[0]/q[0]\n    double hN    = hPrev;\n    \n    while (n < maxIterations) {\n        // For n>=1, b\u2099 = getA(n, x) and a\u2099 = getB(n, x)\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n        \n        // Compute the next numerator and denominator by the recurrence:\n        //   p[n] = b\u2099 * p[n\u20131]   +   a\u2099 * p[n\u20132]\n        //   q[n] = b\u2099 * q[n\u20131]   +   a\u2099 * q[n\u20132]\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1   + b * dPrev;\n        \n        // If overflow has occurred, try to rescale following the modified Lentz algorithm.\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0.0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n        \n        // To prevent division by zero (or an extremely small number) in later steps,\n        // force cN and q2 to be at least 'small' if they are too tiny.\n        if (FastMath.abs(cN) < small) {\n            cN = small;\n        }\n        if (FastMath.abs(q2) < small) {\n            q2 = small;\n        }\n        \n        // Rescale the intermediate values (p and q recurrences) if they are too large or too small.\n        // Such scaling does not affect the ratio p[n]/q[n] but greatly improves numerical stability.\n        double extremeScale = FastMath.max(FastMath.abs(cN), FastMath.abs(q2));\n        if (extremeScale > 1e300 || (extremeScale != 0.0 && extremeScale < 1e-300)) {\n            cN    /= extremeScale;\n            hPrev /= extremeScale;\n            p0    /= extremeScale;\n            q1    /= extremeScale;\n            dPrev /= extremeScale;\n            q2    /= extremeScale;\n        }\n        \n        // Compute the relative change of the successive convergents:\n        // deltaN = (f[n] / f[n-1])  where f[n] = p[n]/q[n].\n        final double deltaN = (cN / q2) / cPrev;\n        hN = cPrev * deltaN; // hN now equals the new f[n] = p[n]/q[n].\n        \n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        \n        // Check for convergence.\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n        \n        // Update recurrence parameters for next iteration.\n        dPrev = q1;\n        cPrev = cN / q2;  // f[n] becomes the new previous approximant.\n        p0    = hPrev;\n        hPrev = cN;\n        q1    = q2;\n        n++;\n    }\n    \n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n    \n    return hN;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}