{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * The fraction implemented is of the form:\n     * <pre>\n     *           a1\n     * b0 + ---------------\n     *      b1 +      a2\n     *           ----------\n     *           b2 +    a3\n     *                -----\n     *                b3 + ...\n     * </pre>\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     * @throws ConvergenceException if the algorithm detects divergence.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        // Modified Lentz algorithm (Numerical Recipes section 5.2)\n        // This implementation evaluates the fraction b_0 + K_{n=1}^\\infty (a_n / b_n)\n        // It is assumed that getA(0, x) returns b_0\n        // getA(n, x) returns a_n for n >= 1\n        // getB(n, x) returns b_n for n >= 1\n\n        final double small = 1e-50; // A small number to avoid division by zero\n\n        double b0 = getA(0, x);\n        // Handle the case b0 = 0 by setting it to a small value.\n        if (Precision.equals(b0, 0.0, small)) {\n            b0 = small;\n        }\n\n        double h_n = b0;    // Current convergent value f_n (starts with f_0 = b_0)\n        double C_n = h_n;   // C_n value needed for next iteration's C calculation (C_0 = f_0)\n        double D_n = 0.0;   // D_n value needed for next iteration's D calculation (D_0 = 0)\n\n        int n = 1;\n        while (n <= maxIterations) {\n            final double a_n = getA(n, x);\n            final double b_n = getB(n, x);\n\n            // Compute D_curr = b_n + a_n * D_{n-1}\n            // (D_n from the previous iteration, which is the inverted D_curr_inverted)\n            // This is D'_n in NR notation before inversion\n            double D_curr = b_n + a_n * D_n;\n            if (Precision.equals(D_curr, 0.0, small)) {\n                D_curr = small;\n            }\n            // Compute C_curr = b_n + a_n / C_{n-1}\n            // (C_n from the previous iteration)\n            // This is C_n in NR notation\n            double C_curr = b_n + a_n / C_n;\n             if (Precision.equals(C_curr, 0.0, small)) {\n                 C_curr = small;\n            }\n\n            // D_curr now becomes 1 / D'_n\n            D_curr = 1.0 / D_curr;\n\n            // delta_n = C_n * (1 / D'_n) = C_n / D'_n\n            double delta_n = C_curr * D_curr;\n\n            // h_n = h_{n-1} * delta_n\n            h_n = h_n * delta_n;\n\n            // Check for NaN or Infinity, which indicate divergence\n            if (Double.isInfinite(h_n)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(h_n)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check convergence: |delta_n - 1| < epsilon\n            if (FastMath.abs(delta_n - 1.0) < epsilon) {\n                break;\n            }\n\n            // Prepare for next iteration:\n            // D_n stores the inverted D_curr for the next D calculation\n            D_n = D_curr;\n            // C_n stores C_curr for the next C calculation\n            C_n = C_curr;\n\n            n++;\n        }\n\n        if (n > maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return h_n;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}