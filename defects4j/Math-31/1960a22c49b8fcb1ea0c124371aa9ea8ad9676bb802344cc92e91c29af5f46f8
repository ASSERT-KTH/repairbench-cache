{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50; // A small number to prevent division by zero or underflow\n\n        // Thompson & Barnett, page 19, \"Modified Lentz's Method for Real Continued Fractions\"\n        // Initialization for k = 0:\n        // f_0 = a_0 (current convergent)\n        // C_0 = a_0 (forward recurrence for C terms)\n        // D_0 = 0   (forward recurrence for D terms)\n\n        // In the code:\n        // hPrev holds f_k (current convergent)\n        // cPrev holds C_{k-1}\n        // dPrev holds D_{k-1}\n\n        double hPrev = getA(0, x); // f_0\n        double cPrev = hPrev;      // C_0\n        double dPrev = 0.0;        // D_0\n\n        // If the initial a_0 (which is f_0 and C_0) is zero or very small,\n        // replace it with 'small' to prevent division by zero later.\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n            cPrev = small;\n        }\n\n        int n = 1; // Start iteration from k=1\n        while (n < maxIterations) {\n            final double a = getA(n, x); // a_n (A_k in Thompson & Barnett notation)\n            final double b = getB(n, x); // b_n (B_k in Thompson & Barnett notation)\n\n            // Calculate D_k = B_k + A_k / D_{k-1}\n            // If D_{k-1} is effectively zero, replace it with 'small' to prevent infinite terms.\n            if (Precision.equals(dPrev, 0.0, small)) {\n                dPrev = small;\n            }\n            double dN = b + (a / dPrev); // D_k\n\n            // If D_k is effectively zero, replace it with 'small'.\n            if (Precision.equals(dN, 0.0, small)) {\n                dN = small;\n            }\n\n            // Calculate C_k = B_k + A_k / C_{k-1}\n            // If C_{k-1} is effectively zero, replace it with 'small'.\n            if (Precision.equals(cPrev, 0.0, small)) {\n                cPrev = small;\n            }\n            double cN = b + (a / cPrev); // C_k\n\n            // If C_k is effectively zero, replace it with 'small'.\n            if (Precision.equals(cN, 0.0, small)) {\n                cN = small;\n            }\n\n            // Calculate delta_k = C_k / D_k\n            final double deltaN = cN / dN;\n\n            // Update f_k = f_{k-1} * delta_k\n            hPrev *= deltaN;\n\n            // Check for divergence (infinite or NaN results)\n            if (Double.isInfinite(hPrev)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(hPrev)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence: |delta_k - 1.0| < epsilon\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            // Prepare for next iteration: update C_{k-1} and D_{k-1}\n            cPrev = cN;\n            dPrev = dN;\n\n            n++;\n        }\n\n        // If maxIterations reached without convergence\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hPrev; // The converged value of the continued fraction\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}