{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        // A tiny value used to avoid division by zero or underflow\n        final double small = 1e-50; \n\n        // Initialisation for n=0 according to Thompson & Barnett, page 18:\n        // f_0 = b_0\n        // C_0 = f_0\n        // D_0 = 0\n        // (Where b_0 is getA(0, x) in this implementation's mapping)\n\n        // hPrev stores the current convergent f_n. Initially f_0.\n        double hPrev = getA(0, x);\n\n        // If f_0 is zero, set it to a small value to avoid division by zero in later steps.\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        // cPrev stores C_n. Initially C_0 = f_0.\n        double cPrev = hPrev; \n        // dPrev stores D_n. Initially D_0 = 0.0.\n        // It will be effectively 'small' when used in a division if zero.\n        double dPrev = 0.0;   \n        \n        // hN stores the convergent for the current iteration, updated at each step.\n        double hN = hPrev;    \n\n        int n = 1;\n        while (n < maxIterations) {\n            // For n >= 1:\n            // 'a' = getA(n, x) maps to b_n in Thompson & Barnett (the constant term in the denominator)\n            // 'b' = getB(n, x) maps to a_n in Thompson & Barnett (the numerator term)\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            // Calculate D_n = b_n + a_n / D_{n-1}\n            // If D_{n-1} (dPrev) is effectively zero, use 'small' to avoid division by zero or large numbers.\n            double dCurr = a + b / dPrev;\n            if (Precision.equals(dPrev, 0.0, small)) {\n                dCurr = a + b / small;\n            }\n            // If the calculated D_n is effectively zero, set it to 'small' for the next iteration's division.\n            if (Precision.equals(dCurr, 0.0, small)) {\n                dCurr = small;\n            }\n\n            // Calculate C_n = b_n + a_n / C_{n-1}\n            // If C_{n-1} (cPrev) is effectively zero, use 'small'.\n            double cCurr = a + b / cPrev;\n            if (Precision.equals(cPrev, 0.0, small)) {\n                cCurr = a + b / small;\n            }\n            // If the calculated C_n is effectively zero, set it to 'small'.\n            if (Precision.equals(cCurr, 0.0, small)) {\n                cCurr = small;\n            }\n\n            // Numerical stability: Scale cCurr, dCurr, and hPrev if they become excessively large.\n            // This prevents overflow, preserving the ratio cCurr/dCurr and the overall fraction value.\n            // Using 1.0e100 as a threshold is a common practice in robust Lentz implementations (e.g., Numerical Recipes).\n            final double big = 1.0e100;\n            if (FastMath.abs(cCurr) > big || FastMath.abs(dCurr) > big) {\n                // If either C_n or D_n is too large, scale all relevant terms by the larger of the two.\n                double scale = FastMath.max(FastMath.abs(cCurr), FastMath.abs(dCurr));\n                cCurr /= scale;\n                dCurr /= scale;\n                hPrev /= scale; // The previous convergent must also be scaled to maintain correct proportionality.\n            }\n            \n            // Calculate delta_n = C_n / D_n\n            final double deltaN = cCurr / dCurr;\n            \n            // Calculate f_n = f_{n-1} * delta_n\n            hN = hPrev * deltaN;\n\n            // Check for divergence (result is infinite or NaN)\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence based on delta_n approaching 1.0\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            // Update variables for the next iteration:\n            // dPrev becomes D_n (dCurr) for the next step (it will be D_{n-1})\n            // cPrev becomes C_n (cCurr) for the next step (it will be C_{n-1})\n            // hPrev becomes f_n (hN) for the next step (it will be f_{n-1})\n            dPrev = dCurr;\n            cPrev = cCurr;\n            hPrev = hN;\n            n++;\n        }\n\n        // If the loop finished without converging within maxIterations, throw an exception.\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}