{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = getA(0, x);\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n        int n = 1;\n        double dPrev = 0.0;\n        double hN = hPrev;\n        while (n < maxIterations) {\n            double a = getA(n, x);\n            if (Precision.equals(a, 0.0, small)) {\n                a = small;\n            }\n            double b = getB(n, x);\n            if (Precision.equals(b, 0.0, small)) {\n                b = small;\n            }\n            double h = a + b * hPrev;\n            if (Precision.equals(h, 0.0, small)) {\n                h = small;\n            }\n            double d = b + a / dPrev;\n            if (Precision.equals(d, 0.0, small)) {\n                d = small;\n            }\n            double delta = Math.abs(hN - h) / h;\n            if (delta < epsilon) {\n                break;\n            }\n            hN = h;\n            dPrev = d;\n            hPrev = h;\n            n++;\n        }\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n        return hN;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}