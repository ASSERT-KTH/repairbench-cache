{
    "generation": "    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        final double small = 1e-50;\n\n        // The continued fraction is b_0 + a_1/(b_1 + a_2/(b_2 + ...))\n        // According to MathWorld and typical Lentz algorithm implementations,\n        // the first term is b_0.\n        // The original code uses getA(0, x) which is inconsistent with getA for a_n and getB for b_n.\n        // It should be getB(0, x) for b_0.\n        double hPrev = getB(0, x);\n\n        // use the value of small as epsilon criteria for zero checks\n        if (Precision.equals(hPrev, 0.0, small)) {\n            hPrev = small;\n        }\n\n        // Initialize c_0 = f_0 and d_0 = 0 (Thompson & Barnett, Algorithm 3)\n        // hPrev is f_{n-1}\n        // cPrev is c_{n-1}\n        // dPrev is d_{n-1}\n        double cPrev = hPrev;\n        double dPrev = 0.0;\n\n        double hN = hPrev; // Current approximation of the continued fraction\n        int n = 1;\n\n        while (n < maxIterations) {\n            // Get a_n and b_n for the current iteration.\n            // getA(n, x) corresponds to a_n (numerator)\n            // getB(n, x) corresponds to b_n (denominator)\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n\n            // Lentz algorithm update for c_n: c_n = b_n + a_n / c_{n-1}\n            double cN = b + a / cPrev;\n            // If cN is zero, replace with 'small' to prevent division by zero in subsequent steps\n            if (Precision.equals(cN, 0.0, small)) {\n                cN = small;\n            }\n\n            // Lentz algorithm update for d_n: d_n = 1 / (b_n + a_n * d_{n-1})\n            double q2 = b + a * dPrev;\n            // If q2 (denominator before inversion) is zero, replace with 'small'\n            if (Precision.equals(q2, 0.0, small)) {\n                q2 = small;\n            }\n            q2 = 1.0 / q2; // Invert to get d_n\n\n            // The original scaling block for infinite values (if Double.isInfinite(cN) || Double.isInfinite(q2))\n            // is based on P_n, Q_n recurrences and is not compatible with the Lentz algorithm's c_n, d_n updates.\n            // The Lentz algorithm is designed to avoid overflow/underflow for c_n and d_n values.\n            // Divergence due to infinite values is typically caught by the final hN check.\n            // This block is removed as it likely causes numerical instability or incorrect behavior.\n\n            // Calculate delta_n: delta_n = c_n * d_n\n            final double deltaN = cN * q2;\n\n            // Update the continued fraction approximation: f_n = f_{n-1} * delta_n\n            hN = hPrev * deltaN;\n\n            if (Double.isInfinite(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                               x);\n            }\n            if (Double.isNaN(hN)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                               x);\n            }\n\n            // Check for convergence: |delta_n - 1.0| < epsilon\n            if (FastMath.abs(deltaN - 1.0) < epsilon) {\n                break;\n            }\n\n            // Update variables for the next iteration\n            // cPrev becomes cN (c_{n-1} becomes c_n)\n            // dPrev becomes q2 (d_{n-1} becomes d_n)\n            // hPrev becomes hN (f_{n-1} becomes f_n)\n            cPrev = cN;\n            dPrev = q2;\n            hPrev = hN;\n\n            n++;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                                maxIterations, x);\n        }\n\n        return hN;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}