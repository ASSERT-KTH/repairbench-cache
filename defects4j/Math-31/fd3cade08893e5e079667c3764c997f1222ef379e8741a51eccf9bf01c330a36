{
    "generation": "import org.apache.commons.math3.exception.ConvergenceException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Precision;\n\n// Define the abstract class structure for context\nabstract class ContinuedFraction {\n    /**\n     * Access the n-th numerator `a_n` of the continued fraction.\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * `a_0` is the first term of the fraction.\n     * @param n index of the numerator term to retrieve.\n     * @param x the evaluation point.\n     * @return the numerator `a_n`.\n     */\n    protected abstract double getA(int n, double x);\n\n    /**\n     * Access the n-th denominator `b_n` of the continued fraction.\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n     * @param n index of the denominator term to retrieve.\n     * @param x the evaluation point.\n     * @return the denominator `b_n`.\n     */\n    protected abstract double getB(int n, double x);\n// } // End of dummy class structure\n\n    /**\n     * <p>\n     * Evaluates the continued fraction at the value x.\n     * </p>\n     *\n     * <p>\n     * The implementation of this method is based on the modified Lentz algorithm as described\n     * on page 18 ff. in:\n     * <ul>\n     * <li>\n     *   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n     *   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n     *   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n     * </li>\n     * </ul>\n     * Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>\n     * (formula 9), which evaluates the fraction a\u2080 + b\u2081 / (a\u2081 + b\u2082 / (a\u2082 + ...)).\n     * The Lentz algorithm itself is typically described for fractions like b\u2080 + a\u2081 / (b\u2081 + a\u2082 / ...)\n     * or a\u2081 / (b\u2081 + a\u2082 / ...). This implementation adapts the algorithm for the formula 9 form.\n     * </p>\n     *\n     * @param x the evaluation point.\n     * @param epsilon maximum error allowed.\n     * @param maxIterations maximum number of convergents\n     * @return the value of the continued fraction evaluated at x.\n     * @throws ConvergenceException if the algorithm fails to converge or encounters\n     * numerical problems (NaN or Infinite results).\n     * @throws MaxCountExceededException if the maximum number of iterations is reached\n     * before convergence.\n     */\n    public double evaluate(double x, double epsilon, int maxIterations) throws ConvergenceException, MaxCountExceededException {\n        final double small = 1e-50; // A small number to avoid division by zero\n\n        // Initialize f_n = a_0 (term from MathWorld formula 9 notation)\n        double f = getA(0, x);\n        if (Precision.equals(f, 0.0, small)) {\n            // If a0 is zero, initialize with a small value instead.\n            // This happens for fractions starting b1 / (a1 + ...), where a0 = 0.\n            f = small;\n        }\n\n        // Initialize C_n = f_n, D_n = 0 for the Lentz algorithm adapted to\n        // f = a0 + b1 / (a1 + b2 / (a2 + ...))\n        // C_k = a_k + b_k / C_{k-1}\n        // D_k = a_k + b_k * D_{k-1}\n        // delta_k = C_k * (1 / D_k)\n        // f_k = f_{k-1} * delta_k\n        double C = f;\n        double D = 0.0; // D_0 = 0\n\n        for (int n = 1; n <= maxIterations; n++) {\n            final double a = getA(n, x); // a_n\n            final double b = getB(n, x); // b_n\n\n            // Update D_n = a_n + b_n * D_{n-1}\n            // Store D_{n-1} temporarily for calculating C_n if needed, but seems ok\n            D = a + b * D;\n            if (Precision.equals(D, 0.0, small)) {\n                // Avoid division by zero recurrence D = 1/D\n                D = small;\n            }\n\n            // Update C_n = a_n + b_n / C_{n-1}\n            C = a + b / C;\n            if (Precision.equals(C, 0.0, small)) {\n                // Avoid division by zero C = b/C in next iteration\n                C = small;\n            }\n\n            // Compute the ratio D_n = 1 / D_n (Note: D has been updated with D_n's value)\n            D = 1.0 / D;\n\n            // Calculate the factor delta_n = C_n * D_n\n            double delta = C * D;\n\n            // Update the current estimate f_n = f_{n-1} * delta_n\n            f = f * delta;\n\n            // Check for NaN or Infinite intermediate results.\n            // These indicate potential numerical instability or divergence.\n            if (Double.isInfinite(f)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(f)) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n\n            // Check for convergence: |delta_n - 1| < epsilon\n            if (FastMath.abs(delta - 1.0) < epsilon) {\n                return f; // Converged\n            }\n        }\n\n        // Maximum number of iterations reached without convergence\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}