{
    "generation": "    @Override\n    public double evaluate(double x, double epsilon, int maxIterations) {\n        // based on the modified Lentz algorithm\n        final double tiny = 1e-50;\n        // f will hold the value of the continued fraction\n        double f = getA(0, x);\n        // if the first term is zero, replace it by a tiny number\n        if (Precision.equals(f, 0.0, tiny)) {\n            f = tiny;\n        }\n        // C and D are the \u201cmodified denominators\u201d in Lentz\u2019s method\n        double C = f;\n        double D = 0.0;\n        double delta;\n        for (int n = 1; n < maxIterations; n++) {\n            final double a = getA(n, x);\n            final double b = getB(n, x);\n            // update D\n            D = b + a * D;\n            if (Precision.equals(D, 0.0, tiny)) {\n                D = tiny;\n            }\n            // update C\n            C = b + a / C;\n            if (Precision.equals(C, 0.0, tiny)) {\n                C = tiny;\n            }\n            // invert D\n            D = 1.0 / D;\n            // the factor by which f is multiplied\n            delta = C * D;\n            f *= delta;\n            // test for divergence\n            if (Double.isInfinite(f)) {\n                throw new ConvergenceException(\n                    LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            if (Double.isNaN(f)) {\n                throw new ConvergenceException(\n                    LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n            }\n            // test for convergence\n            if (FastMath.abs(delta - 1.0) < epsilon) {\n                return f;\n            }\n        }\n        // if we get here, we failed to converge in the allotted iterations\n        throw new MaxCountExceededException(\n            LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}