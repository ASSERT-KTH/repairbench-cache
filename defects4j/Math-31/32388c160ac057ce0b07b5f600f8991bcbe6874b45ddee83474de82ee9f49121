{
    "generation": "public double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    // getA(0,x) returns b\u2080 (the \u201cinitial\u201d denominator term)\n    double hPrev = getA(0, x);\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    // For the recurrence we use:\n    //   P\u208b\u2081 = 1,   P\u2080 = b\u2080, and for n \u2265 1: P\u2099 = b\u2099 * P\u2099\u208b\u2081 + a\u2099 * P\u2099\u208b\u2082,\n    //   Q\u208b\u2081 = 0,   Q\u2080 = 1, and for n \u2265 1: Q\u2099 = b\u2099 * Q\u2099\u208b\u2081 + a\u2099 * Q\u2099\u208b\u2082.\n    // The continued fraction value is f\u2099 = P\u2099 / Q\u2099.\n    // In our implementation getA(0,x) provides b\u2080.\n    // For n >= 1, we must use getA(n,x) as b\u2099 (the denominator part)\n    // and getB(n,x) as a\u2099 (the numerator part). (This \u201cswap\u201d fixes the bug.)\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        // Swap the coefficients for n>=1 so that:\n        //   b = getA(n, x) is the continued fraction denominator term b\u2099,\n        //   a = getB(n, x) is the numerator term a\u2099.\n        final double b = getA(n, x);\n        final double a = getB(n, x);\n\n        // Compute the new numerator and denominator of the convergents:\n        //   P\u2099 = b\u2099 * P\u2099\u208b\u2081 + a\u2099 * P\u2099\u208b\u2082\n        //   Q\u2099 = b\u2099 * Q\u2099\u208b\u2081 + a\u2099 * Q\u2099\u208b\u2082\n        double cN = b * hPrev + a * p0;\n        double q2 = b * q1 + a * dPrev;\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (b != 0.0 && b > a) {\n                    // Factor b (the dominant term) out of the first term.\n                    cN = hPrev / lastScaleFactor + (a / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (a / scaleFactor * dPrev);\n                } else if (a != 0) {\n                    // Otherwise, factor a out.\n                    cN = (b / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (b / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        // deltaN is the factor by which the convergent changes:\n        // (P\u2099/Q\u2099) / (P\u2099\u208b\u2081/Q\u2099\u208b\u2081) = (cN/q2) / cPrev.\n        final double deltaN = (cN / q2) / cPrev;\n        // hN becomes the new convergent P\u2099/Q\u2099.\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        // shift the recurrence: update the old values\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}