{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) { // yyyy-MM-dd\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // Normalize: ensure seconds and milliseconds are present and 3 digits\n            // Target format: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\n            int tIndex = dateStr.lastIndexOf('T');\n            if (tIndex > 0) { // Must have a 'T' for time part\n                StringBuilder sb = new StringBuilder(dateStr);\n                int dotIndex = dateStr.lastIndexOf('.', len - 2); // Search for dot before 'Z'\n\n                if (dotIndex > tIndex) { // Has a dot after T (e.g., \"...T12:34:56.7Z\")\n                    // Pad milliseconds to 3 digits\n                    int currentMillisDigits = (len - 1) - (dotIndex + 1); // length of digits between '.' and 'Z'\n                    if (currentMillisDigits < 3) {\n                        for (int i = 0; i < (3 - currentMillisDigits); ++i) {\n                            sb.insert(len - 1, '0'); // Insert '0' before 'Z'\n                        }\n                    }\n                } else { // No dot (e.g., \"...T12:34:56Z\" or \"...T12:34Z\")\n                    // Check if seconds are missing:\n                    int colonCount = 0;\n                    for (int i = tIndex + 1; i < len - 1; ++i) { // Check between 'T' and 'Z'\n                        if (dateStr.charAt(i) == ':') {\n                            colonCount++;\n                        }\n                    }\n                    if (colonCount == 1) { // Only HH:mm, missing ss (e.g., \"...T12:34Z\")\n                        sb.insert(len - 1, \":00.000\"); // Add seconds and milliseconds before 'Z'\n                    } else { // Has HH:mm:ss, missing .SSS (e.g., \"...T12:34:56Z\")\n                        sb.insert(len - 1, \".000\"); // Add milliseconds before 'Z'\n                    }\n                }\n                dateStr = sb.toString();\n            }\n        } else { // Has timezone indicator (+/-) or no timezone indicator at all.\n            int timezoneIndex = -1; // index of '+' or '-'\n            for (int i = len - 1; i >= 0; --i) {\n                char ch = dateStr.charAt(i);\n                if (ch == '+' || ch == '-') {\n                    timezoneIndex = i;\n                    break;\n                }\n            }\n\n            if (timezoneIndex != -1) { // Has timezone indicator (+/-)\n                df = _formatISO8601;\n                if (df == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n\n                StringBuilder sb = new StringBuilder(dateStr);\n\n                // 1. Normalize timezone offset: from \"+HH:MM\" to \"+HHMM\" or \"+HH\" to \"+HH00\"\n                int tzLen = len - timezoneIndex;\n                if (tzLen == 3) { // e.g., \"+01\" or \"-05\"\n                    sb.append(\"00\"); // Add minutes\n                } else if (tzLen == 6 && sb.charAt(timezoneIndex + 3) == ':') { // e.g., \"+01:00\"\n                    sb.deleteCharAt(timezoneIndex + 3); // Remove colon\n                }\n                dateStr = sb.toString();\n                len = dateStr.length(); // Update length after modification\n\n                // 2. Normalize seconds and milliseconds part\n                // Recalculate timezoneIndex as string length might have changed\n                timezoneIndex = -1;\n                for (int i = len -1 ; i >= 0; --i) {\n                    char ch = dateStr.charAt(i);\n                    if (ch == '+' || ch == '-') {\n                        timezoneIndex = i;\n                        break;\n                    }\n                }\n                \n                int tIndex = dateStr.lastIndexOf('T');\n                if (tIndex > 0) { // Must have a 'T' for time part\n                    int dotIndex = dateStr.lastIndexOf('.', timezoneIndex - 1); // Search for dot before timezone\n\n                    sb = new StringBuilder(dateStr); // Re-initialize StringBuilder with current dateStr\n\n                    if (dotIndex > tIndex) { // Has partial milliseconds (e.g., \"...T12:34:56.7+/-HHMM\")\n                        // Pad milliseconds to 3 digits\n                        int currentMillisDigits = timezoneIndex - (dotIndex + 1);\n                        if (currentMillisDigits < 3) {\n                            for (int i = 0; i < (3 - currentMillisDigits); ++i) {\n                                sb.insert(timezoneIndex, '0'); // Insert '0' before timezone offset\n                            }\n                        }\n                    } else { // No dot (e.g., \"...T12:34:56+/-HHMM\" or \"...T12:34+/-HHMM\")\n                        // Check if seconds are missing:\n                        int colonCount = 0;\n                        for (int i = tIndex + 1; i < timezoneIndex; ++i) { // Check between 'T' and timezone start\n                            if (sb.charAt(i) == ':') {\n                                colonCount++;\n                            }\n                        }\n                        if (colonCount == 1) { // Only HH:mm, missing ss (e.g., \"1997-07-16T19:20+01:00\")\n                            sb.insert(timezoneIndex, \":00.000\"); // Add seconds and milliseconds before timezone\n                        } else if (colonCount == 2) { // Has HH:mm:ss, missing .SSS (e.g., \"...T12:34:56+...\")\n                            sb.insert(timezoneIndex, \".000\"); // Add milliseconds before timezone\n                        }\n                    }\n                    dateStr = sb.toString();\n                }\n            } else { // No timezone offset or 'Z' suffix, but has time part (e.g., \"yyyy-MM-ddTHH:mm:ss\")\n                // Treat as UTC/GMT and append 'Z' after normalization\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n\n                StringBuilder sb = new StringBuilder(dateStr);\n                int tIndex = dateStr.lastIndexOf('T');\n                if (tIndex > 0) { // Has time part\n                    int dotIndex = dateStr.lastIndexOf('.');\n                    if (dotIndex > tIndex) { // Has partial milliseconds (e.g., \"...T12:34:56.7\")\n                        // Pad milliseconds to 3 digits\n                        int currentMillisDigits = dateStr.length() - (dotIndex + 1);\n                        if (currentMillisDigits < 3) {\n                            for (int i = 0; i < (3 - currentMillisDigits); ++i) {\n                                sb.append('0'); // Append '0's to pad\n                            }\n                        }\n                    } else { // No dot (e.g., \"...T12:34:56\" or \"...T12:34\")\n                        // Check if seconds are missing:\n                        int colonCount = 0;\n                        for (int i = tIndex + 1; i < dateStr.length(); ++i) {\n                            if (dateStr.charAt(i) == ':') {\n                                colonCount++;\n                            }\n                        }\n                        if (colonCount == 1) { // Only HH:mm, missing ss\n                            sb.append(\":00.000\"); // Add seconds and milliseconds\n                        } else { // Has HH:mm:ss, missing .SSS\n                            sb.append(\".000\"); // Add milliseconds\n                        }\n                    }\n                }\n                sb.append('Z'); // Always append 'Z' for this case\n                dateStr = sb.toString();\n            }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}