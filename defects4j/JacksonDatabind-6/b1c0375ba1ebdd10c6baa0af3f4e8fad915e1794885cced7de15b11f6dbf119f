{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of timezone\n         * modifiers for ISO-8601. So we need to do some scrubbing.\n         * [databind#570]: Handle optional seconds/milliseconds\n         * [databind#1084]: Need to handle missing seconds/minutes in timezone specification\n         */\n        int len = dateStr.length();\n        final char Z = 'Z'; // For clarity\n        String originalDateStr = dateStr; // Keep original for potential plain date fallback\n\n        // If timezone is specified, it must be offset (+/-HH:mm or +/-HHmm) or 'Z'\n        boolean hasTimeZone = false;\n        int tzIndex = -1; // Index where timezone starts (+,- or Z)\n\n        // First check for 'Z'\n        if (len > 0 && dateStr.charAt(len - 1) == Z) {\n            hasTimeZone = true;\n            tzIndex = len -1;\n        } else {\n            // Check for '+/-' followed by digits near the end\n            int signIdx = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n            // Sign must be close to end; and cannot be at the beginning\n            if (signIdx > 0 && signIdx >= len - 6) {\n                 // Check structure after sign: HH, HHMM, HH:MM\n                 int offsetLen = len - signIdx;\n                 if (offsetLen == 3 || offsetLen == 5 || offsetLen == 6) {\n                     // Heuristic: If preceded by a digit or 'T' or '.', assume it's TZ\n                     // (This avoids matching negative years etc.)\n                     char prevC = dateStr.charAt(signIdx - 1);\n                     if (Character.isDigit(prevC) || prevC == 'T' || prevC == '.') {\n                         hasTimeZone = true;\n                         tzIndex = signIdx;\n                     }\n                 }\n            }\n        }\n\n        DateFormat df;\n        TimeZone tz = _timezone; // Use configured TZ by default\n\n        if (hasTimeZone) {\n            char last = dateStr.charAt(len - 1);\n            if (last == Z) {\n                df = _formatISO8601_z;\n                // For 'Z', always use UTC timezone\n                tz = PLAIN_DATE_UTC_TIMEZONE; \n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, tz, _locale);\n                }\n\n                // Normalize time part before 'Z'\n                int tIndex = dateStr.lastIndexOf('T');\n                if (tIndex < 0) { // Malformed\n                     pos.setErrorIndex(len); return null;\n                }\n                // time part is between 'T' and 'Z'\n                String timePartStr = dateStr.substring(tIndex + 1, tzIndex); \n                StringBuilder timePart = new StringBuilder(timePartStr);\n\n                // Inline _fixupTime logic: Normalize to HH:MM:SS.sss\n                {\n                    int timeLen = timePart.length();\n                    int dotIndex = -1;\n                    for (int i = 0; i < timeLen; ++i) { if (timePart.charAt(i) == '.') { dotIndex = i; break; } }\n                    int lastColonIndex = -1;\n                    int firstColonIndex = -1;\n                    for (int i = 0; i < timeLen; ++i) { if (timePart.charAt(i) == ':') { if (firstColonIndex < 0) firstColonIndex = i; lastColonIndex = i; } }\n\n                    if (dotIndex < 0) { // No fraction\n                        if (lastColonIndex == firstColonIndex) timePart.append(\":00.000\"); // HH:MM -> HH:MM:00.000\n                        else timePart.append(\".000\"); // HH:MM:SS -> HH:MM:SS.000\n                    } else { // Fraction present\n                         // Check if seconds were missing before dot: HH:MM.sss -> insert :00\n                         if (lastColonIndex == firstColonIndex && lastColonIndex < dotIndex) {\n                             timePart.insert(dotIndex, \":00\");\n                             dotIndex += 3; // Adjust dot index after insertion\n                             timeLen += 3;\n                         }\n                         // Pad/truncate milliseconds\n                         int msLen = timeLen - dotIndex - 1;\n                         if (msLen < 3) for (int i = msLen; i < 3; ++i) timePart.append('0'); // Pad\n                         else if (msLen > 3) timePart.setLength(dotIndex + 1 + 3); // Truncate\n                    }\n                }\n                dateStr = dateStr.substring(0, tIndex + 1) + timePart.toString() + Z;\n\n            } else { // Timezone offset like +01:00\n                df = _formatISO8601;\n                // tz remains _timezone (configured TZ)\n                if (df == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, _locale);\n                }\n\n                // Normalize timezone offset first (remove colon)\n                String offsetStr = dateStr.substring(tzIndex);\n                if (offsetStr.length() == 6 && offsetStr.charAt(3) == ':') { // +/-HH:MM -> +/-HHMM\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.deleteCharAt(tzIndex + 3);\n                    dateStr = sb.toString();\n                    len -= 1; // Update length\n                }\n                // Note: We don't pad +/-HH to +/-HH00 as SimpleDateFormat 'Z' expects HHMM\n\n                // Now normalize time part before offset\n                int tIndex = dateStr.lastIndexOf('T', tzIndex -1); // Look for T before timezone index\n                if (tIndex < 0) { // Malformed\n                     pos.setErrorIndex(len); return null;\n                }\n                // time part is between 'T' and timezone index\n                String timePartStr = dateStr.substring(tIndex + 1, tzIndex); \n                StringBuilder timePart = new StringBuilder(timePartStr);\n\n                // Inline _fixupTime logic: Normalize to HH:MM:SS.sss\n                {\n                    int timeLen = timePart.length();\n                    int dotIndex = -1;\n                    for (int i = 0; i < timeLen; ++i) { if (timePart.charAt(i) == '.') { dotIndex = i; break; } }\n                    int lastColonIndex = -1;\n                    int firstColonIndex = -1;\n                    for (int i = 0; i < timeLen; ++i) { if (timePart.charAt(i) == ':') { if (firstColonIndex < 0) firstColonIndex = i; lastColonIndex = i; } }\n\n                    if (dotIndex < 0) { // No fraction\n                        if (lastColonIndex == firstColonIndex) timePart.append(\":00.000\"); // HH:MM -> HH:MM:00.000\n                        else timePart.append(\".000\"); // HH:MM:SS -> HH:MM:SS.000\n                    } else { // Fraction present\n                         // Check if seconds were missing before dot: HH:MM.sss -> insert :00\n                         if (lastColonIndex == firstColonIndex && lastColonIndex < dotIndex) {\n                             timePart.insert(dotIndex, \":00\");\n                             dotIndex += 3; // Adjust dot index after insertion\n                             timeLen += 3;\n                         }\n                         // Pad/truncate milliseconds\n                         int msLen = timeLen - dotIndex - 1;\n                         if (msLen < 3) for (int i = msLen; i < 3; ++i) timePart.append('0'); // Pad\n                         else if (msLen > 3) timePart.setLength(dotIndex + 1 + 3); // Truncate\n                    }\n                }\n                // Reconstruct string: date part + 'T' + normalized time + normalized offset\n                dateStr = dateStr.substring(0, tIndex + 1) + timePart.toString() + dateStr.substring(tzIndex);\n            }\n        } else {\n            // No explicit timezone ('Z' or offset)\n\n            // Handle plain date first (YYYY-MM-DD)\n            // [databind#904]: Only consider YYYY-MM-DD if length matches exactly\n            boolean checkPlain = (len == DATE_FORMAT_STR_PLAIN.length() && len > 0 && Character.isDigit(dateStr.charAt(len - 1)));\n            if (checkPlain) {\n                 df = _formatPlain;\n                 tz = PLAIN_DATE_UTC_TIMEZONE; // Use UTC\n                 if (df == null) {\n                     df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, tz, _locale);\n                 }\n                 // Try parsing plain date directly\n                 Date dt = df.parse(originalDateStr, pos); // Use original string\n                 if (dt != null) { return dt; }\n                 // If parse fails, fall through to treat as datetime without TZ (could be YYYY-MM-DDTHH...)\n            }\n\n            // Assume datetime without TZ -> Append 'Z' and use UTC\n            df = _formatISO8601_z;\n            tz = PLAIN_DATE_UTC_TIMEZONE; // Use UTC\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, tz, _locale);\n            }\n\n            // Normalize time part, append 'Z'\n            int tIndex = dateStr.lastIndexOf('T');\n            if (tIndex < 0) { // Not datetime? (Maybe plain date that failed parsing?)\n                 // Let subsequent parse fail on the original string.\n                 dateStr = originalDateStr;\n                 // It will likely fail because format requires T and Z.\n            } else {\n                // time part is from T to end\n                String timePartStr = dateStr.substring(tIndex + 1);\n                StringBuilder timePart = new StringBuilder(timePartStr);\n                \n                // Inline _fixupTime logic: Normalize to HH:MM:SS.sss\n                {\n                    int timeLen = timePart.length();\n                    int dotIndex = -1;\n                    for (int i = 0; i < timeLen; ++i) { if (timePart.charAt(i) == '.') { dotIndex = i; break; } }\n                    int lastColonIndex = -1;\n                    int firstColonIndex = -1;\n                    for (int i = 0; i < timeLen; ++i) { if (timePart.charAt(i) == ':') { if (firstColonIndex < 0) firstColonIndex = i; lastColonIndex = i; } }\n\n                    if (dotIndex < 0) { // No fraction\n                        if (lastColonIndex == firstColonIndex) timePart.append(\":00.000\"); // HH:MM -> HH:MM:00.000\n                        else timePart.append(\".000\"); // HH:MM:SS -> HH:MM:SS.000\n                    } else { // Fraction present\n                         // Check if seconds were missing before dot: HH:MM.sss -> insert :00\n                         if (lastColonIndex == firstColonIndex && lastColonIndex < dotIndex) {\n                             timePart.insert(dotIndex, \":00\");\n                             dotIndex += 3; // Adjust dot index after insertion\n                             timeLen += 3;\n                         }\n                         // Pad/truncate milliseconds\n                         int msLen = timeLen - dotIndex - 1;\n                         if (msLen < 3) for (int i = msLen; i < 3; ++i) timePart.append('0'); // Pad\n                         else if (msLen > 3) timePart.setLength(dotIndex + 1 + 3); // Truncate\n                    }\n                }\n                dateStr = dateStr.substring(0, tIndex + 1) + timePart.toString() + Z;\n            }\n        }\n\n        // Final parse attempt with selected formatter and normalized string\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}