{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        int len = dateStr.length();\n        char lastChar = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date... (YYYY-MM-DD)\n        if (len <= 10 && Character.isDigit(lastChar)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n            return df.parse(dateStr, pos);\n        }\n\n        // All other formats are ISO-8601 based with time components.\n        // We will normalize the date string into a consistent format (e.g., yyyy-MM-dd'T'HH:mm:ss.SSSZ or yyyy-MM-dd'T'HH:mm:ss.SSS+HHmm)\n        StringBuilder sb = new StringBuilder(dateStr);\n        int currentLen = len;\n\n        // Determine if there's an explicit timezone offset or 'Z'\n        int tZOffset = -1; // Index of 'Z' or '+' or '-' for timezone\n        if (lastChar == 'Z') {\n            tZOffset = currentLen - 1; // 'Z' is always at the very end\n        } else {\n            // Find explicit timezone offset sign (+ or -)\n            int signIdx = dateStr.lastIndexOf('+');\n            if (signIdx < 0) {\n                signIdx = dateStr.lastIndexOf('-');\n            }\n            // A timezone offset must be at the end, and its length is typically 3, 5, or 6 chars\n            if (signIdx > 0 && (currentLen - signIdx >= 3) && (currentLen - signIdx <= 6)) {\n                tZOffset = signIdx;\n            }\n        }\n\n        boolean hasExplicitTimezoneOffset = (tZOffset != -1 && tZOffset != currentLen - 1); // True if it's +HHmm or +HH:mm, false if Z or no TZ\n\n        // Step 1: Normalize explicit timezone offset format (e.g., +HH:mm -> +HHmm, +HH -> +HH00)\n        if (hasExplicitTimezoneOffset) {\n            int tzLen = currentLen - tZOffset;\n            if (tzLen == 6 && sb.charAt(tZOffset + 3) == ':') { // \"+HH:mm\" format\n                sb.deleteCharAt(tZOffset + 3); // Remove colon\n                currentLen--;\n            } else if (tzLen == 3) { // \"+HH\" format\n                sb.append(\"00\"); // Append \"00\" to make it \"+HH00\"\n                currentLen += 2;\n            }\n            // No need to handle \"+HHmm\" (tzLen == 5) as it's already in the desired format\n        }\n\n        // Step 2: Handle time part: ensure seconds and milliseconds are present and properly padded\n        // Find the 'T' separator which marks the beginning of the time component\n        int tIndex = sb.lastIndexOf(\"T\");\n        if (tIndex > 0) { // If 'T' separator is found\n            int timeEndIndex = hasExplicitTimezoneOffset ? tZOffset : currentLen; // End of time component (before TZ or end of string)\n\n            // Check if seconds are missing (e.g., YYYY-MM-DDTHH:mm) and insert :00\n            // The time component is from tIndex + 1 to timeEndIndex\n            String timeComponent = sb.substring(tIndex + 1, timeEndIndex);\n            int lastColonInTime = timeComponent.lastIndexOf(':');\n\n            // If timeComponent is \"HH:mm\" (length 5), then last colon is at index 2.\n            // This implies seconds are missing based on common ISO 8601 patterns.\n            if (timeComponent.length() == 5 && lastColonInTime == 2) {\n                 sb.insert(tIndex + 6, \":00\"); // Insert \":00\" after \"HH:mm\" (tIndex + 1 + 5 = tIndex + 6)\n                 currentLen += 3;\n                 // If an explicit timezone was present, its start index needs to be shifted\n                 if (hasExplicitTimezoneOffset) {\n                    tZOffset += 3;\n                 }\n            }\n\n            // Pad milliseconds: ensure .SSS format (e.g., .S -> .S00, .SS -> .SS0)\n            // Re-determine timeEndIndex as it might have shifted due to previous insertions\n            timeEndIndex = hasExplicitTimezoneOffset ? tZOffset : currentLen;\n            int dotIndex = sb.lastIndexOf('.', timeEndIndex - 1); // Search for dot before TZ or end of string\n\n            if (dotIndex == -1) { // No dot, milliseconds part is completely missing (e.g., ...:ss+TZ or ...:ss)\n                sb.insert(timeEndIndex, \".000\"); // Insert \".000\"\n                currentLen += 4;\n            } else { // Has a dot, potentially partial milliseconds (e.g., .S, .SS)\n                int numDigits = timeEndIndex - (dotIndex + 1); // Number of digits after the dot\n                if (numDigits < 3) {\n                    for (int i = 0; i < (3 - numDigits); ++i) {\n                        sb.insert(timeEndIndex, '0'); // Pad with '0's\n                        currentLen++;\n                    }\n                }\n            }\n        } else {\n            // This case implies YYYY-MM-DD (already handled at top), or other non-standard formats\n            // If it reached here and doesn't have a 'T', it's likely malformed for ISO8601\n            // Let's assume for standard ISO8601, 'T' is present for time values.\n            // If it's a date-only string like \"YYYY-MM-DD\", it should have been caught by the first `if` block.\n            // If it's something like \"HH:mm:ss\", it lacks date part and will fail.\n            // This block is implicitly skipped for valid time-based ISO8601 that *do* have 'T'.\n        }\n\n        // Step 3: If no timezone was specified initially, append 'Z' to make it a UTC date\n        if (!hasExplicitTimezoneOffset && tZOffset == -1) { // -1 means no 'Z' and no explicit offset initially\n            sb.append('Z');\n            currentLen++;\n        }\n\n        dateStr = sb.toString();\n\n        // Step 4: Select the correct DateFormat based on the normalized string's timezone type\n        if (lastChar == 'Z' || (!hasExplicitTimezoneOffset && tZOffset == -1)) { // If original had 'Z' or we appended 'Z'\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        } else { // Original had an explicit timezone offset (e.g., +HHmm)\n            df = _formatISO8601;\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}