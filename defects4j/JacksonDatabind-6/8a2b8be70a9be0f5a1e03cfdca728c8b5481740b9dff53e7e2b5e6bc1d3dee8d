{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    char lastChar = dateStr.charAt(len - 1);\n    DateFormat df;\n\n    // If we got a plain date (only date, no time), use plain-date formatter\n    if (len <= 10 && Character.isDigit(lastChar)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    // Check if a timezone indicator is present (e.g. \"+01:00\" or \"-05:00\")\n    boolean hasTZ = hasTimeZone(dateStr);\n\n    // Normalize timezone offset: if not 'Z' and a timezone is found, then remove the optional colon\n    if (lastChar != 'Z' && hasTZ) {\n        int tzPos = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n        if (tzPos != -1 && tzPos + 3 < dateStr.length() && dateStr.charAt(tzPos + 3) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.deleteCharAt(tzPos + 3);\n            dateStr = sb.toString();\n            len = dateStr.length();\n        } else if (tzPos != -1 && tzPos + 3 == dateStr.length()) {\n            // When timezone minutes are missing, append \"00\"\n            dateStr += \"00\";\n            len = dateStr.length();\n        }\n    }\n    // Refresh lastChar after possible modifications.\n    lastChar = dateStr.charAt(dateStr.length() - 1);\n\n    // Normalize the time portion.\n    int tPos = dateStr.indexOf('T');\n    if (tPos < 0) { // not in expected ISO-8601 format; fallback to plain\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n    // Determine the end of the time-part; if a timezone is present, that's where it starts.\n    int endOfTime = dateStr.length();\n    if (lastChar != 'Z' && hasTZ) {\n        int plusPos = dateStr.indexOf('+', tPos);\n        int minusPos = dateStr.indexOf('-', tPos);\n        if (plusPos > 0 && minusPos > 0) {\n            endOfTime = Math.min(plusPos, minusPos);\n        } else if (plusPos > 0) {\n            endOfTime = plusPos;\n        } else if (minusPos > 0) {\n            endOfTime = minusPos;\n        }\n    } else if (lastChar == 'Z') {\n        endOfTime = dateStr.length() - 1;\n    }\n    // Extract the time part (after 'T' and before the timezone)\n    String timePortion = dateStr.substring(tPos + 1, endOfTime);\n    String newTimePortion = timePortion;\n\n    // If only one colon is present in the time-part, seconds are missing.\n    if (timePortion.indexOf(':') == timePortion.lastIndexOf(':')) {\n        newTimePortion = timePortion + \":00\";\n    }\n\n    // Look for fractional seconds. If missing, add \".000\" after seconds.\n    int dotIndex = newTimePortion.indexOf('.');\n    if (dotIndex < 0) {\n        // Expecting HH:mm:ss to be exactly 8 characters; if so, append fractional milliseconds.\n        if (newTimePortion.length() == 8) {\n            newTimePortion = newTimePortion + \".000\";\n        }\n    } else {\n        // There is a fractional part; normalize it to exactly three digits.\n        int fracStart = dotIndex + 1;\n        int fracEnd = fracStart;\n        while (fracEnd < newTimePortion.length() && Character.isDigit(newTimePortion.charAt(fracEnd))) {\n            fracEnd++;\n        }\n        String fraction = newTimePortion.substring(fracStart, fracEnd);\n        if (fraction.length() < 3) {\n            StringBuilder fracBuilder = new StringBuilder(fraction);\n            while (fracBuilder.length() < 3) {\n                fracBuilder.append('0');\n            }\n            newTimePortion = newTimePortion.substring(0, fracStart)\n                    + fracBuilder.toString()\n                    + newTimePortion.substring(fracEnd);\n        } else if (fraction.length() > 3) {\n            newTimePortion = newTimePortion.substring(0, fracStart)\n                    + fraction.substring(0, 3)\n                    + newTimePortion.substring(fracEnd);\n        }\n    }\n\n    // Rebuild the normalized date string.\n    String normalizedDateStr;\n    if (lastChar == 'Z') {\n        normalizedDateStr = dateStr.substring(0, tPos + 1) + newTimePortion + \"Z\";\n    } else if (hasTZ) {\n        String tzPart = dateStr.substring(endOfTime);\n        normalizedDateStr = dateStr.substring(0, tPos + 1) + newTimePortion + tzPart;\n    } else {\n        normalizedDateStr = dateStr.substring(0, tPos + 1) + newTimePortion;\n    }\n    dateStr = normalizedDateStr;\n\n    // Choose appropriate date format based on the timezone designator.\n    if (dateStr.charAt(dateStr.length() - 1) == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z,\n                    DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n    } else {\n        df = _formatISO8601;\n        if (_formatISO8601 == null) {\n            df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601,\n                    DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n    }\n    return df.parse(dateStr, pos);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}