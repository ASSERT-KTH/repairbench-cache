{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n{\n    DateFormat df;\n\n    // Check if we can directly use _formatISO8601\n    if (_formatISO8601 != null) {\n        try {\n            return _formatISO8601.parse(dateStr, pos);\n        } catch (Exception e) {\n            // Fallback to more lenient parsing\n        }\n    }\n\n    int len = dateStr.length();\n\n    // Check for presence of 'Z' indicating UTC with colon removed from timezone\n    if (dateStr.endsWith(\"Z\")) {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        dateStr = dateStr.substring(0, len - 1) + \"+00:00\";\n    } else if (dateStr.length() > 3 && Character.isLetter(dateStr.charAt(len - 3)) ||\n               (len > 1 && Character.isLetter(dateStr.charAt(len - 1)))){\n        // Timezone present but not in 'Z' form, reformat\n        int index = dateStr.lastIndexOf(':');\n        if (index != -1 && dateStr.substring(index).length() > 3) {\n            index = dateStr.length() - 3;\n        }\n        if (index == -1) {\n            index = dateStr.length() - 2;\n        }\n        String tzPart = dateStr.substring(index);\n        dateStr = dateStr.substring(0, index) + \"GMT\" + tzPart.substring(0, 3);\n    }\n\n    try {\n        df = DateFormat.getDateTimeInstance(DateFormat.ISO_8601, Calendar.LONG, _locale);\n        df.setTimeZone(_timezone);\n        return df.parse(dateStr, pos);\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Failed to parse ISO-8601 date: \" + dateStr, e);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}