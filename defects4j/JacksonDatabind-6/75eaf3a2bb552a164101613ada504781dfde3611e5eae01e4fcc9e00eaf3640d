{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         * Applied further fixes for [databind#204] (missing seconds),\n         * [databind#570] (microseconds, partial), [databind#1084] (timezone handling).\n         */\n        int len = dateStr.length();\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        // Let's separate date-only case first (\"yyyy-MM-dd\")\n        if (len <= 10 && Character.isDigit(dateStr.charAt(len-1))) {\n             // Assuming \"yyyy-MM-dd\"\n            df = _formatPlain;\n            if (df == null) {\n                // note: non-static simple date formats are not thread-safe:\n                // need to be cloned for each use\n                // Also: [databind#11] MUST specify Locale as well as TimeZone for some cases\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n             return df.parse(dateStr, pos);\n        }\n\n        // If not plain date, must have time, might have timezone. Does it end with 'Z'?\n        if (len > 0 && dateStr.charAt(len - 1) == 'Z') {\n            df = _formatISO8601_z; // Format: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        DEFAULT_TIMEZONE /* GMT */, _locale);\n            }\n            // Need to handle missing/partial seconds/milliseconds before the 'Z'\n            int dotIndex = dateStr.lastIndexOf('.', len - 2); // Look before 'Z'\n            int lastColonIndex = dateStr.lastIndexOf(':', len - 2); // Look before 'Z'\n            StringBuilder sb = null; // Lazily created if modification needed\n\n            if (dotIndex < 0 && lastColonIndex < 0) { // Neither '.' nor ':' found before Z?\n                 // Might be yyyy-MM-ddTHHZ. Add missing parts.\n                 int tIndex = dateStr.lastIndexOf('T', len - 2);\n                 if (tIndex >= 0) { // Ensure there is a 'T' separating date and time part\n                    // Check if the part after 'T' and before 'Z' looks like just HH\n                     if ((len - 1 - (tIndex + 1)) == 2 && Character.isDigit(dateStr.charAt(tIndex+1)) && Character.isDigit(dateStr.charAt(tIndex+2))) {\n                        sb = new StringBuilder(dateStr);\n                        // Insert :00:00.000 before 'Z'\n                        sb.insert(len - 1, \":00:00.000\");\n                     }\n                 }\n                 // If no 'T' or format is unexpected, let parser fail\n            } else if (dotIndex < 0) { // No milliseconds '.', check seconds based on colon\n                // Is 'Z' right after HH:mm? (e.g., \"...:15Z\", len-1 is 'Z', lastColon is ':', difference 3)\n                 if ((len - 1) - lastColonIndex == 3) {\n                     sb = new StringBuilder(dateStr);\n                     sb.insert(len - 1, \":00.000\"); // Insert :ss.SSS before Z\n                 } else { // Assume seconds are present (HH:mm:ssZ), insert missing \".000\"\n                     sb = new StringBuilder(dateStr);\n                     sb.insert(len - 1, \".000\"); // Insert .SSS before Z\n                 }\n            } else { // Milliseconds separator '.' found\n                // Pad fractional part if needed (e.g., \".1Z\" -> \".100Z\")\n                int fractionLen = (len - 1) - dotIndex - 1; // Number of chars between '.' and 'Z'\n                if (fractionLen < 3) {\n                     sb = new StringBuilder(dateStr);\n                     for (int i = fractionLen; i < 3; ++i) {\n                         sb.insert(len - 1, '0'); // Insert padding '0's before 'Z'\n                     }\n                }\n            }\n            if (sb != null) {\n                dateStr = sb.toString();\n            }\n            // Use the 'Z' formatter\n        } else if (hasTimeZone(dateStr)) { // Timezone offset like +HH:mm or +HHmm\n            // 1. Normalize timezone: remove colon -> +HHmm\n            int signIndex = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n            // Heuristic: sign must appear after 'T' and after the last ':'\n            int lastColonIndexPreTz = dateStr.lastIndexOf(':', signIndex -1);\n            if (signIndex > 0 && lastColonIndexPreTz >= 0 && signIndex > lastColonIndexPreTz ) {\n                 // Check for colon like \"+01:00\" at signIndex+3\n                 if ((signIndex + 3) < len && dateStr.charAt(signIndex + 3) == ':') {\n                     StringBuilder sb = new StringBuilder(dateStr);\n                     sb.delete(signIndex + 3, signIndex + 4);\n                     dateStr = sb.toString();\n                     len = dateStr.length(); // Update length\n                 }\n            } else {\n                 // Sign not found where expected for timezone. Let parser handle/fail.\n            }\n\n            // 2. Handle missing/partial seconds/milliseconds before the offset\n            // Re-fetch sign index as string might have changed\n            signIndex = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n            int dotIndex = dateStr.lastIndexOf('.', signIndex - 1); // Look before sign\n            lastColonIndexPreTz = dateStr.lastIndexOf(':', signIndex - 1); // Look before sign\n            StringBuilder sb = null; // Lazily created\n\n            if (dotIndex < 0 && lastColonIndexPreTz < 0) {\n                // Neither '.' nor ':' found before timezone? Unlikely ISO format. Let parser fail.\n            } else if (dotIndex < 0) { // No milliseconds '.', check seconds based on colon\n                // Is offset right after HH:mm? (e.g., \"...:15+0100\", signIndex-lastColon == 3)\n                 if (signIndex - lastColonIndexPreTz == 3) {\n                    sb = new StringBuilder(dateStr);\n                    sb.insert(signIndex, \":00.000\"); // Insert \":ss.SSS\" before sign\n                 } else { // Assume seconds are present (HH:mm:ss+HHmm), insert missing \".000\"\n                    sb = new StringBuilder(dateStr);\n                    sb.insert(signIndex, \".000\"); // Insert \".SSS\" before sign\n                 }\n            } else { // Milliseconds separator '.' found\n                 // Pad fractional part if needed (e.g., \".1+0100\" -> \".100+0100\")\n                 int fractionLen = signIndex - dotIndex - 1; // Chars between '.' and sign\n                 if (fractionLen < 3) {\n                     sb = new StringBuilder(dateStr);\n                     for (int i = fractionLen; i < 3; ++i) {\n                         sb.insert(signIndex, '0'); // Insert padding '0's before sign\n                     }\n                 }\n            }\n            if (sb != null) {\n               dateStr = sb.toString();\n            }\n            // Use the standard ISO8601 format with offset\n            df = _formatISO8601; // Format: yyyy-MM-dd'T'HH:mm:ss.SSSZ\n            if (df == null) {\n               df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // No timezone indicator ('Z' or offset). Append 'Z' to assume GMT/UTC.\n            // Need to scrub for missing/partial seconds/milliseconds first.\n            StringBuilder sb = new StringBuilder(dateStr);\n            int dotIndex = dateStr.lastIndexOf('.');\n            int lastColonIndex = dateStr.lastIndexOf(':');\n\n            if (dotIndex < 0 && lastColonIndex < 0) {\n                 // Neither '.' nor ':' found? If 'T' exists, assume time part is just HH.\n                 int tIndex = dateStr.lastIndexOf('T');\n                 if (tIndex >= 0) {\n                     // Check if part after T is just HH (e.g., \"T19\")\n                     if ((len - (tIndex + 1)) == 2 && Character.isDigit(dateStr.charAt(tIndex+1)) && Character.isDigit(dateStr.charAt(tIndex+2))) {\n                        sb.append(\":00:00.000\"); // Append missing parts\n                     }\n                 }\n                 // If no T, or format doesn't look like T+HH, assume plain date \"yyyy-MM-dd\".\n                 // Should have been handled earlier, but if not, appending Z might be wrong.\n                 // Let parser fail if format is truly ambiguous here.\n                 // For now, just append Z.\n            } else if (dotIndex < 0) { // No milliseconds '.', check seconds based on colon\n                 // Check if string ends with HH:mm (e.g., \"...T19:20\", len-lastColon == 3)\n                 if (len - lastColonIndex == 3) {\n                     sb.append(\":00.000\"); // Append :ss.SSS\n                 } else { // Assume ends with HH:mm:ss, append missing \".000\"\n                     sb.append(\".000\"); // Append .SSS\n                 }\n            } else { // Milliseconds separator '.' found\n                 // Pad fractional part if needed (e.g., \"...T19:20:30.1\" -> \"...T19:20:30.100\")\n                 int fractionLen = len - dotIndex - 1; // Chars after '.'\n                 if (fractionLen < 3) {\n                     for (int i = fractionLen; i < 3; ++i) {\n                        sb.append('0'); // Append padding '0's\n                     }\n                 }\n            }\n\n            sb.append('Z'); // Append 'Z' assuming GMT interpretation for missing timezone\n            dateStr = sb.toString();\n            // Use the 'Z' formatter\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        DEFAULT_TIMEZONE /* GMT */, _locale);\n            }\n        }\n\n        // Sanity check: df should be assigned unless plain date case returned early\n        if (df == null) {\n             // Should not happen with the above logic\n             throw new IllegalStateException(\"DateFormat could not be determined for date string: \" + dateStr);\n        }\n\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}