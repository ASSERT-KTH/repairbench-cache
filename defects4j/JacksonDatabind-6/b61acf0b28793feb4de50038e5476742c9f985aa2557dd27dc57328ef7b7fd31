{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n{\n    int len = dateStr.length();\n    char c = dateStr.charAt(len-1);\n    DateFormat df;\n\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (dateStr.charAt(len-4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len-1, \".000\");\n            dateStr = sb.toString();\n        }\n        // Patch in missing or partial milliseconds (e.g. .6 -> .600 or .61 -> .610)\n        dateStr = _fixupMilliseconds(dateStr, len - 1);\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            // Find start of timezone part (last + or -)\n            int tzIndex = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n            if (tzIndex > 0) {\n                // Colon in timezone, remove it\n                if (dateStr.length() > tzIndex + 2 && dateStr.charAt(tzIndex + 3) == ':') {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(tzIndex + 3, tzIndex + 4);\n                    dateStr = sb.toString();\n                } else if (dateStr.length() == tzIndex + 3) {\n                    // Only hour in offset, e.g. +01, add minutes\n                    dateStr += \"00\";\n                }\n            }\n            // Now, look for milliseconds fraction\n            // Find the '.' in the seconds component (if present, before timezone)\n            int millisStart = -1;\n            int tIndex = dateStr.lastIndexOf('T');\n            int cut = (tzIndex > -1) ? tzIndex : dateStr.length();\n            for (int i = tIndex; i < cut; ++i) {\n                if (dateStr.charAt(i) == '.') {\n                    millisStart = i;\n                    break;\n                }\n            }\n            // Add missing seconds, if needed (\"yyyy-MM-ddTHH:mm+01:00\")\n            if (tIndex >= 0) {\n                int afterT = tIndex + 1;\n                // count ':' after 'T'\n                int colonCount = 0;\n                for (int i = afterT; i < dateStr.length(); ++i) {\n                    c = dateStr.charAt(i);\n                    if (c == ':') {\n                        colonCount++;\n                    } else if (c == '+' || c == '-') {\n                        break;\n                    }\n                }\n                if (colonCount == 1) {\n                    // after hour, so missing seconds, insert \":00\" before offset or end\n                    int insertAt = (tzIndex > -1) ? tzIndex : dateStr.length();\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(insertAt, \":00\");\n                    dateStr = sb.toString();\n                    // push tzIndex for later\n                    tzIndex = Math.max(dateStr.lastIndexOf('+'), dateStr.lastIndexOf('-'));\n                    // recompute cut\n                    cut = (tzIndex > -1) ? tzIndex : dateStr.length();\n                }\n            }\n            // Patch in missing or partial milliseconds\n            if (millisStart < 0) {\n                // No '.', so insert \".000\" before offset or end\n                int insertAt = (tzIndex > -1) ? tzIndex : dateStr.length();\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(insertAt, \".000\");\n                dateStr = sb.toString();\n            } else {\n                // Fix number of digits after '.'\n                dateStr = _fixupMilliseconds(dateStr, millisStart);\n            }\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder sb = new StringBuilder(dateStr);\n            // And possible also millisecond part if missing\n            int ti = dateStr.lastIndexOf('T');\n            if (ti >= 0) {\n                int timeLen = len - ti - 1;\n                boolean hasSecs = (timeLen >= 5);\n                boolean hasMillis = false;\n                for (int i = ti + 1; i < len; ++i) {\n                    if (dateStr.charAt(i) == '.') {\n                        hasMillis = true;\n                        int fracLen = len - i - 1;\n                        if (fracLen < 3) {\n                            // fix partial milliseconds\n                            StringBuilder millisSb = new StringBuilder(dateStr);\n                            for (int j = fracLen; j < 3; ++j) {\n                                millisSb.append('0');\n                            }\n                            dateStr = millisSb.toString();\n                            sb = new StringBuilder(dateStr); // refresh\n                        }\n                        break;\n                    }\n                }\n                if (!hasMillis && hasSecs) {\n                    sb.append(\".000\");\n                }\n                else if (!hasMillis && !hasSecs) {\n                    sb.append(\":00.000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}\n\n/**\n * Utility method to fix (make sure there are exactly three digits) the milliseconds\n * part of an ISO8601 timestamp. Expects the '.' position.\n */\nprivate String _fixupMilliseconds(String dateStr, int millisStart) {\n    int len = dateStr.length();\n    int millisEnd = millisStart + 1;\n    while (millisEnd < len) {\n        char ch = dateStr.charAt(millisEnd);\n        if (!Character.isDigit(ch)) {\n            break;\n        }\n        ++millisEnd;\n    }\n    int digits = millisEnd - (millisStart + 1);\n    if (digits == 0) {\n        StringBuilder sb = new StringBuilder(dateStr);\n        sb.insert(millisEnd, \"000\");\n        return sb.toString();\n    } else if (digits < 3) {\n        StringBuilder sb = new StringBuilder(dateStr);\n        for (int i = 0; i < 3 - digits; ++i) {\n            sb.insert(millisEnd, '0');\n        }\n        return sb.toString();\n    } else if (digits > 3) {\n        // truncate extra digits\n        StringBuilder sb = new StringBuilder(dateStr);\n        sb.delete(millisStart + 4, millisEnd);\n        return sb.toString();\n    }\n    return dateStr;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}