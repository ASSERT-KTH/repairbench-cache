{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n         * quite simple because we already set date format timezone to be\n         * GMT, and hence can just strip out 'Z' altogether\n         */\n        int len = dateStr.length();\n        char lastChar = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date... (yyyy-MM-dd)\n        if (len <= 10 && Character.isDigit(lastChar)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (lastChar == 'Z') {\n            // This block handles strings like \"yyyy-MM-ddTHH:mm:ssZ\", \"yyyy-MM-ddTHH:mmZ\", \"yyyy-MM-ddTHH:mm:ss.SZ\"\n            // We need to ensure the time part is HH:mm:ss.SSS before appending 'Z' back.\n            int tPos = dateStr.lastIndexOf('T');\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.setLength(len - 1); // Temporarily remove 'Z' for processing time part\n\n            if (tPos > 0) { // Has time part (e.g., \"yyyy-MM-ddTHH:mm\")\n                String timePart = sb.substring(tPos + 1);\n                StringBuilder newTimePart = new StringBuilder(timePart);\n\n                int firstColon = newTimePart.indexOf(\":\");\n                int secondColon = -1;\n                if (firstColon != -1) {\n                    secondColon = newTimePart.indexOf(\":\", firstColon + 1);\n                }\n                int dot = newTimePart.indexOf(\".\");\n\n                // Ensure seconds part exists\n                if (secondColon == -1) { // Missing seconds (e.g., \"HH:mm\" or \"HH\")\n                    if (firstColon == -1) { // Only HH present (e.g. \"12\")\n                        newTimePart.append(\":00:00\"); // Becomes \"12:00:00\"\n                    } else { // HH:mm present (e.g. \"12:30\")\n                        newTimePart.append(\":00\"); // Becomes \"12:30:00\"\n                    }\n                    dot = newTimePart.indexOf(\".\"); // Re-calculate dot position as time part changed\n                }\n                // Now, seconds are guaranteed to be present (HH:mm:ss or HH:mm:ss.SSS)\n\n                // Ensure milliseconds part exists and is 3 digits\n                if (dot == -1) { // Missing milliseconds (e.g., \"HH:mm:ss\")\n                    newTimePart.append(\".000\");\n                } else { // Has milliseconds, check if less than 3 digits\n                    String existingMs = newTimePart.substring(dot + 1);\n                    int msLen = existingMs.length();\n                    if (msLen < 3) {\n                        for (int i = 0; i < 3 - msLen; ++i) {\n                            newTimePart.append('0'); // Pad with zeros\n                        }\n                    }\n                    // If msLen > 3, SimpleDateFormat with .SSS will generally consume first 3 digits. No truncation needed here.\n                }\n                // Replace the old time part with the new one\n                sb.replace(tPos + 1, sb.length(), newTimePart.toString());\n\n            } else { // No 'T' found, just date part + 'Z' (e.g. \"yyyy-MM-ddZ\") -- unlikely but handle\n                sb.append(\"T00:00:00.000\");\n            }\n            sb.append('Z'); // Add 'Z' back\n            dateStr = sb.toString();\n\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        } else { // Not 'Z' (Zulu), check for other timezone or plain date\n            if (hasTimeZone(dateStr)) {\n                // This branch handles dates like \"1997-07-16T19:20+01:00\" or \"2014-10-03T18:00:00.6-05:00\"\n                // Format to target: yyyy-MM-dd'T'HH:mm:ss.SSSZ\n                int tPos = dateStr.lastIndexOf('T');\n                int tzStart = -1; // Index where timezone part starts (+ or -)\n\n                // Find timezone start (last + or - after 'T')\n                for (int i = len - 1; i > tPos; --i) {\n                    char ch = dateStr.charAt(i);\n                    if (ch == '+' || ch == '-') {\n                        tzStart = i;\n                        break;\n                    }\n                }\n\n                if (tzStart != -1) { // Found a timezone marker +/-\n                    String timePart = dateStr.substring(tPos + 1, tzStart);\n                    String timezonePart = dateStr.substring(tzStart);\n\n                    StringBuilder newTimePart = new StringBuilder(timePart);\n\n                    int firstColon = newTimePart.indexOf(\":\");\n                    int secondColon = -1;\n                    if (firstColon != -1) {\n                        secondColon = newTimePart.indexOf(\":\", firstColon + 1);\n                    }\n                    int dot = newTimePart.indexOf(\".\");\n\n                    // Ensure seconds part exists\n                    if (secondColon == -1) { // Missing seconds (e.g., \"HH:mm\" or \"HH\")\n                        if (firstColon == -1) { // Only HH present (e.g. \"12\")\n                            newTimePart.append(\":00:00\"); // Becomes \"12:00:00\"\n                        } else { // HH:mm present (e.g. \"12:30\")\n                            newTimePart.append(\":00\"); // Becomes \"12:30:00\"\n                        }\n                        dot = newTimePart.indexOf(\".\");\n                    }\n\n                    // Ensure milliseconds part exists and is 3 digits\n                    if (dot == -1) { // Missing milliseconds (e.g., \"HH:mm:ss\")\n                        newTimePart.append(\".000\");\n                    } else { // Has milliseconds, check if less than 3 digits\n                        String existingMs = newTimePart.substring(dot + 1);\n                        int msLen = existingMs.length();\n                        if (msLen < 3) {\n                            for (int i = 0; i < 3 - msLen; ++i) {\n                                newTimePart.append('0'); // Pad with zeros\n                            }\n                        }\n                    }\n                    // Reassemble the full date string\n                    dateStr = dateStr.substring(0, tPos + 1) + newTimePart.toString() + timezonePart;\n                }\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else { // If not, plain date with time, add 'Z'\n                // This covers \"yyyy-MM-ddTHH:mm:ss\" or \"yyyy-MM-ddTHH:mm\" without a timezone\n                // Patch it to \"yyyy-MM-ddTHH:mm:ss.SSSZ\"\n                int tPos = dateStr.lastIndexOf('T');\n                StringBuilder sb = new StringBuilder(dateStr);\n\n                if (tPos > 0) { // Has time part\n                    String timePart = sb.substring(tPos + 1);\n                    StringBuilder newTimePart = new StringBuilder(timePart);\n\n                    int firstColon = newTimePart.indexOf(\":\");\n                    int secondColon = -1;\n                    if (firstColon != -1) {\n                        secondColon = newTimePart.indexOf(\":\", firstColon + 1);\n                    }\n                    int dot = newTimePart.indexOf(\".\");\n\n                    // Ensure seconds part exists\n                    if (secondColon == -1) { // Missing seconds (e.g., \"HH:mm\" or \"HH\")\n                        if (firstColon == -1) { // Only HH present (e.g. \"12\")\n                            newTimePart.append(\":00:00\"); // Becomes \"12:00:00\"\n                        } else { // HH:mm present (e.g. \"12:30\")\n                            newTimePart.append(\":00\"); // Becomes \"12:30:00\"\n                        }\n                        dot = newTimePart.indexOf(\".\");\n                    }\n\n                    // Ensure milliseconds part exists and is 3 digits\n                    if (dot == -1) { // Missing milliseconds (e.g., \"HH:mm:ss\")\n                        newTimePart.append(\".000\");\n                    } else { // Has milliseconds, check if less than 3 digits\n                        String existingMs = newTimePart.substring(dot + 1);\n                        int msLen = existingMs.length();\n                        if (msLen < 3) {\n                            for (int i = 0; i < 3 - msLen; ++i) {\n                                newTimePart.append('0');\n                            }\n                        }\n                    }\n                    sb.replace(tPos + 1, sb.length(), newTimePart.toString());\n                } else { // No 'T' found. This implies it's a date string like \"2023-01-01\" that somehow skipped the `_formatPlain` path.\n                         // For robustness, if 'T' is missing, assume it's a date only and append default time.\n                    sb.append(\"T00:00:00.000\");\n                }\n                sb.append('Z'); // Append Zulu timezone as default\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}