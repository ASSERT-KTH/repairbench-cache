{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    StringBuilder normalized = new StringBuilder(dateStr);\n    int len = dateStr.length();\n    char c;\n\n    // Handle simple date case (YYYY-MM-DD)\n    if (len <= 10 && Character.isDigit(dateStr.charAt(len-1))) {\n        DateFormat df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    // Handle 'Z' timezone case\n    c = dateStr.charAt(len-1);\n    if (c == 'Z') {\n        DateFormat df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // Handle case where milliseconds might be missing but seconds are present\n        if (len >= 20 && dateStr.charAt(len-4) == ':' && dateStr.charAt(len-2) == '0' && dateStr.charAt(len-3) == '0') {\n            // Case where we have HH:MM:00Z (missing seconds)\n            normalized.insert(len-2, \".000\");\n            dateStr = normalized.toString();\n        } else if (dateStr.charAt(len-4) == ':') {\n            // Original case for potentially missing milliseconds\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len-1, \".000\");\n            dateStr = sb.toString();\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    // Handle other cases with timezone information\n    boolean hasTZ = hasTimeZone(dateStr);\n    boolean hasColonInTZ = false;\n    boolean hasMilliseconds = false;\n\n    // Check for timezone colon and missing parts\n    if (hasTZ) {\n        // Check for colon in timezone offset (e.g., +05:00)\n        int tzPos = dateStr.lastIndexOf('+');\n        if (tzPos < 0) {\n            tzPos = dateStr.lastIndexOf('-');\n            if (tzPos >= 0) {\n                // Check if there's a colon in the timezone part (e.g., -05:00)\n                if (tzPos + 3 < len && dateStr.charAt(tzPos + 3) == ':') {\n                    hasColonInTZ = true;\n                }\n            }\n        } else {\n            if (tzPos + 3 < len && dateStr.charAt(tzPos + 3) == ':') {\n                hasColonInTZ = true;\n            }\n        }\n\n        // Handle colon in timezone (remove it)\n        if (hasColonInTZ) {\n            int colonPos = dateStr.lastIndexOf(':');\n            if (colonPos > dateStr.lastIndexOf('+') && colonPos > dateStr.lastIndexOf('-')) {\n                normalized.deleteCharAt(colonPos);\n                dateStr = normalized.toString();\n                len = dateStr.length(); // update length after modification\n            }\n        }\n\n        // Check for missing seconds component\n        int tPos = dateStr.indexOf('T');\n        if (tPos >= 0) {\n            int timePartLen = len - tPos - 1;\n            if (timePartLen < 5) { // At least HH:MM\n                // Not enough time components\n            } else {\n                // Check for milliseconds part which could be partial (.6, .61, etc.)\n                int dotPos = dateStr.indexOf('.', tPos);\n                if (dotPos >= 0) {\n                    hasMilliseconds = true;\n                    // Check if milliseconds is partial and pad it to 3 digits\n                    int afterDot = len - dotPos - 1;\n                    if (afterDot < 3) {\n                        // Need to pad milliseconds to 3 digits\n                        int milliseconds = Integer.parseInt(dateStr.substring(dotPos + 1));\n                        int paddedLength = (int)(Math.log10(milliseconds) + 1); // length of current milliseconds\n                        if (paddedLength < 3) {\n                            normalized = new StringBuilder(dateStr);\n                            for (int i = paddedLength; i < 3; i++) {\n                                normalized.insert(dotPos + 1 + paddedLength, '0');\n                            }\n                            dateStr = normalized.toString();\n                            len = dateStr.length();\n                        }\n                    } else if (afterDot > 3) {\n                        // Timezone is likely following milliseconds\n                        // Ensure milliseconds is exactly 3 digits\n                        int timezonePos = findTimezonePos(dateStr, tPos);\n                        if (timezonePos > 0) {\n                            if (timezonePos - dotPos - 1 > 3) {\n                                // Truncate extra milliseconds digits\n                                normalized = new StringBuilder(dateStr);\n                                normalized.delete(dotPos + 4, timezonePos);\n                                dateStr = normalized.toString();\n                                len = dateStr.length();\n                            }\n                        }\n                    }\n                }\n\n                // Check for missing seconds component (format like HH:MM+ZZZZ)\n                if (!hasMilliseconds) {\n                    // Check if time part ends with timezone (e.g., \"19:20+01:00\")\n                    int lastColonInTime = dateStr.lastIndexOf(':', tPos + 6); // Look for colon after T and before potential timezone\n                    int lastColon = dateStr.lastIndexOf(':');\n\n                    if (lastColonInTime >= tPos && (lastColonInTime + 3 >= dateStr.length() || !Character.isDigit(dateStr.charAt(lastColonInTime + 3)))) {\n                        // We have HH:MM+Z format (missing seconds)\n                        normalized.append(\"00\");\n                        dateStr = normalized.toString();\n                        len = dateStr.length();\n                    } else if ((lastColonInTime == tPos + 2 || lastColonInTime == tPos + 3) &&\n                              (Character.isDigit(dateStr.charAt(lastColonInTime+1)))) {\n                        // Case where we have HH:MM but might be missing seconds\n                        if (len - lastColonInTime - 1 == 2) { // Just minutes (e.g., HH:MM)\n                            normalized.insert(lastColonInTime + 3, \":00\");\n                        }\n                        dateStr = normalized.toString();\n                        len = dateStr.length();\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle timezone or missing timezone cases\n    if (hasTimeZone(dateStr)) {\n        // Handle format with timezone\n        DateFormat df = _formatISO8601;\n        if (df == null) {\n            df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n\n        // Final cleanup for timezone format\n        len = dateStr.length();\n        if (len > 0) {\n            c = dateStr.charAt(len-1);\n            if (c == '+' || c == '-') {\n                // Handle case where timezone might be missing minutes\n                dateStr += \"00\";\n            }\n            // Handle case where timezone is +HH:MM format\n            int colonPos = dateStr.indexOf(':', len - 6); // Look for colon in last 5 chars\n            if (colonPos > 0 && colonPos == len - 3) {\n                normalized = new StringBuilder(dateStr);\n                normalized.deleteCharAt(colonPos);\n                dateStr = normalized.toString();\n            }\n        }\n        return df.parse(dateStr, pos);\n    } else {\n        // No timezone specified, append 'Z' (UTC)\n        StringBuilder sb = new StringBuilder(dateStr);\n        // Check time part length and add missing seconds/milliseconds if needed\n        int tPos = dateStr.indexOf('T');\n        if (tPos >= 0) {\n            int timePartLength = dateStr.length() - tPos - 1;\n            if (timePartLength <= 5) { // Just HH:MM\n                sb.insert(tPos + 6, \":00\"); // Add seconds\n                sb.append(\".000Z\"); // Add milliseconds and timezone\n            } else if (timePartLength == 8) { // HH:MM:SS\n                sb.append(\".000Z\");\n            } else if (timePartLength > 8 && timePartLength < 12) { // HH:MM:SS.xxx (partial millis)\n                int dotPos = dateStr.lastIndexOf('.');\n                if (dotPos >= 0) {\n                    // Count digits after dot\n                    int millisLength = dateStr.length() - dotPos - 1;\n                    if (millisLength < 3) {\n                        for (int i = millisLength; i < 3; i++) {\n                            sb.append('0');\n                        }\n                    } else if (millisLength > 3) {\n                        // Truncate extra digits\n                        sb.setLength(dotPos + 4); // Keep first 3 digits after dot\n                    }\n                }\n                sb.append('Z');\n            } else {\n                // Already has milliseconds (or malformed)\n                if (dateStr.charAt(dateStr.length()-1) != 'Z') {\n                    sb.append('Z');\n                }\n            }\n        } else {\n            // Just date without time\n            sb.append(\"T00:00:00.000Z\");\n        }\n        dateStr = sb.toString();\n        DateFormat df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n}\n\nprivate boolean hasTimeZone(String dateStr) {\n    int len = dateStr.length();\n    if (len < 5) return false;\n    char c = dateStr.charAt(len-1);\n    if (c == 'Z') return true;\n    // Look for timezone offset pattern (+/-HHMM or +/-HH:MM)\n    int lastColon = dateStr.lastIndexOf(':');\n    int plus = dateStr.lastIndexOf('+');\n    int minus = dateStr.lastIndexOf('-');\n    int lastTZIndicator = Math.max(plus, minus);\n\n    if (lastTZIndicator > 0 && lastTZIndicator < len - 1) {\n        // Check format after the + or -\n        int digitsAfter = len - lastTZIndicator - 1;\n        // Validate that the characters after are digits (possibly with colon)\n        boolean hasValidDigits = true;\n        for (int i = lastTZIndicator + 1; i < len; i++) {\n            char ch = dateStr.charAt(i);\n            if (!Character.isDigit(ch) && ch != ':') {\n                hasValidDigits = false;\n                break;\n            }\n        }\n        if (hasValidDigits) {\n            // Check if we have a colon in the timezone part\n            int colonInTZ = dateStr.indexOf(':', lastTZIndicator);\n            if (colonInTZ > 0) {\n                // Validate that there's exactly one colon and it's in the right position\n                int digitsAfterColon = len - colonInTZ - 1;\n                if (digitsAfterColon == 2 && (colonInTZ - lastTZIndicator - 1 == 2)) {\n                    return true;\n                }\n            } else {\n                // Check if we have 4 digits after +/-\n                if (digitsAfter == 4 || digitsAfter == 2) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nprivate int findTimezonePos(String dateStr, int afterTPos) {\n    int len = dateStr.length();\n    for (int i = afterTPos; i < len; i++) {\n        char c = dateStr.charAt(i);\n        if (c == '+' || c == '-' || c == 'Z') {\n            return i;\n        }\n    }\n    return -1;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}