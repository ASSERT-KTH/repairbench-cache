{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        \n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) { // Likely yyyy-MM-dd format\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') { // Zulu timezone (GMT)\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // [JACKSON-334]: may be missing milliseconds... if so, add\n            // This condition checks for '...:SSZ' and appends '.000' to make it '...:SS.000Z'\n            // It does not handle '...:MMZ' (missing seconds) or partial milliseconds,\n            // but for 'Z' format, SimpleDateFormat is often more forgiving or strict formats\n            // don't include those cases. The original logic here seems specific to one transformation.\n            if (dateStr.charAt(len-4) == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len-1, \".000\"); // Insert before 'Z'\n                dateStr = sb.toString();\n            }\n        } else { // Has explicit timezone offset (+/-HH:MM) or no timezone indicator\n            int tzOffsetStart = -1;\n            // Iterate from end of string to find first '+' or '-' which indicates start of timezone offset\n            for (int i = len - 1; i >= 0; --i) {\n                char ch = dateStr.charAt(i);\n                if (ch == '+' || ch == '-') {\n                    tzOffsetStart = i;\n                    break;\n                }\n            }\n\n            if (tzOffsetStart > 0) { // Found timezone offset (+/-HH:MM or +/-HHMM)\n                // Split date string into date/time part and timezone part\n                String dtPart = dateStr.substring(0, tzOffsetStart); // Date and Time part (e.g., \"1997-07-16T19:20\")\n                String tzPart = dateStr.substring(tzOffsetStart);    // Timezone part (e.g., \"+01:00\")\n\n                // 1. Normalize timezone part (remove colon, pad minutes if needed)\n                // Example: \"+01:00\" -> \"+0100\", \"+01\" -> \"+0100\"\n                if (tzPart.length() >= 6 && tzPart.charAt(3) == ':') { // If format is \"+HH:MM\"\n                    tzPart = tzPart.substring(0, 3) + tzPart.substring(4); // Remove colon\n                }\n                if (tzPart.length() == 3) { // If format is \"+HH\" or \"-HH\"\n                    tzPart += \"00\"; // Pad with \"00\" for minutes\n                }\n\n                // 2. Process Date/Time part to ensure seconds and milliseconds are in format SSS\n                int lastT = dtPart.lastIndexOf('T');\n                if (lastT > 0) { // Has time component (after 'T')\n                    int dotIndex = dtPart.lastIndexOf('.');\n                    if (dotIndex == -1) { // No milliseconds part found\n                        // Check if seconds are missing (e.g., T19:20 vs T19:20:30)\n                        String timeComponent = dtPart.substring(lastT + 1); // e.g., \"19:20\" or \"19:20:30\"\n                        if (timeComponent.length() == 5) { // HH:mm format (missing seconds and milliseconds)\n                            dtPart += \":00.000\";\n                        } else if (timeComponent.length() == 8) { // HH:mm:ss format (missing milliseconds)\n                            dtPart += \".000\";\n                        }\n                        // If timeComponent.length() is not 5 or 8 (e.g. malformed or already has fractional seconds),\n                        // leave as is, SimpleDateFormat will try to parse it.\n                    } else { // Milliseconds part exists, check if partial (e.g., .6, .61)\n                        String msStr = dtPart.substring(dotIndex + 1); // e.g., \"6\" or \"61\"\n                        int msLen = msStr.length();\n                        if (msLen < 3) {\n                            // Pad with trailing zeros to make it 3 digits (e.g., .6 -> .600, .61 -> .610)\n                            for (int i = 0; i < (3 - msLen); ++i) {\n                                dtPart += '0'; \n                            }\n                        }\n                        // If msLen > 3 (e.g., .1234), SimpleDateFormat will truncate.\n                    }\n                }\n                \n                dateStr = dtPart + tzPart; // Reconstruct the date string\n                \n                df = _formatISO8601; // Use ISO8601 format for +/- timezone\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else { // No timezone indicator found (neither 'Z', nor '+', nor '-')\n                // If it's a plain date/time string, patch 'Z' at the end.\n                StringBuilder sb = new StringBuilder(dateStr);\n                \n                int lastT = dateStr.lastIndexOf('T');\n                if (lastT > 0) { // Has time component (after 'T')\n                    int dotIndex = dateStr.lastIndexOf('.');\n                    if (dotIndex == -1) { // No milliseconds part found\n                        // Check if seconds are missing or present before adding .000\n                        int timeLenFromT = len - lastT - 1;\n                        if (timeLenFromT == 5) { // HH:mm format\n                            sb.append(\":00.000\");\n                        } else if (timeLenFromT == 8) { // HH:mm:ss format\n                            sb.append(\".000\");\n                        }\n                    } else { // Milliseconds part exists, check if partial\n                        int msLen = len - dotIndex - 1;\n                        if (msLen < 3) {\n                            for (int i = 0; i < (3 - msLen); ++i) {\n                                sb.append('0');\n                            }\n                        }\n                    }\n                }\n                sb.append('Z'); // Append 'Z' as it's a plain date without timezone\n                dateStr = sb.toString();\n                df = _formatISO8601_z; // Use Z-specific ISO8601 format\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}