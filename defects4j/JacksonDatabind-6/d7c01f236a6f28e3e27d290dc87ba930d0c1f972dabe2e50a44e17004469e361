{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         * Applied specifically to parsing, not formatting.\n         *\n         *  Logic updated in 2.4.0 -> 2.8 to handle more cases; specifically:\n         *  - Missing seconds and/or milliseconds\n         *  - Partially missing milliseconds (zero-padding)\n         *  - Timezone offset without colon separator\n         *  - Z/Zulu indicator handled now\n         */\n        int len = dateStr.length();\n        char lastChar = dateStr.charAt(len - 1);\n        DateFormat df;\n        String formatString = dateStr; // String to be potentially modified\n\n        // 1. Handle plain date \"yyyy-MM-dd\"\n        // Original check: len <= 10 and last char is digit.\n        // Also ensure no 'T' appears, otherwise it's some form of date/time\n        if (len <= 10 && Character.isDigit(lastChar)) {\n             if (dateStr.indexOf('T') < 0) {\n                 df = _formatPlain;\n                 if (df == null) {\n                    // If not previously constructed, must explicitly force timezone to default\n                    df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n                 }\n                 // Let parse fail if format is actually incorrect (e.g. \"12345\")\n                 return df.parse(formatString, pos);\n             }\n             // If 'T' is present, fall through to date/time handling\n        }\n\n        // Use StringBuilder for potential modifications\n        StringBuilder sb = new StringBuilder(dateStr);\n        int currentLen = len; // Track length within StringBuilder\n\n        // 2. Determine Timezone and choose appropriate formatter, modify StringBuilder if needed\n        int tzIndex; // Index where timezone starts *in the StringBuilder*\n\n        if (lastChar == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // We need '.SSS' for the format. If millis are missing, add them.\n            tzIndex = currentLen - 1;\n        }\n        // Else, see if we have +/-HH:mm, +/-HHmm, or +/-HH timezone offset\n        // NOTE: offsets like \"+0000\" are problematic on Macs (JDK bug?), need to use \"GMT+00:00\"\n        // ... also, format requires 'Z' notation for SimpleDateFormat (i.e. standard),\n        // does not accept \"+HHmm\" etc. Need to pre-process.\n        else if (currentLen >= 6 && (sb.charAt(currentLen-6) == '+' || sb.charAt(currentLen-6) == '-') // Check for +/-hh:mm\n                   || (currentLen >= 5 && (sb.charAt(currentLen-5) == '+' || sb.charAt(currentLen-5) == '-')) // Check for +/-hhmm\n                   || (currentLen >= 3 && (sb.charAt(currentLen-3) == '+' || sb.charAt(currentLen-3) == '-'))) { // Check for +/-hh\n\n            df = _formatISO8601;\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n\n            // Check for '+/-HH:mm' first\n            if (currentLen >= 6 && sb.charAt(currentLen-3) == ':' && (sb.charAt(currentLen-6) == '+' || sb.charAt(currentLen-6) == '-')) {\n                 // Remove colon for formatter 'Z' pattern which expects '+/-HHmm'\n                 sb.delete(currentLen - 3, currentLen - 2);\n                 currentLen--; // Reflect deletion\n                 tzIndex = currentLen - 5;\n            } else if (currentLen >= 5 && (sb.charAt(currentLen-5) == '+' || sb.charAt(currentLen-5) == '-')) { // Check for '+/-HHmm'\n                 tzIndex = currentLen - 5;\n                 // Format is already correct for the 'Z' pattern formatter\n            } else if (currentLen >= 3 && (sb.charAt(currentLen-3) == '+' || sb.charAt(currentLen-3) == '-')) { // Check for '+/-HH'\n                  // Append \"00\" for minutes, non-standard but supported by original code\n                  sb.append(\"00\");\n                  currentLen += 2; // Reflect addition\n                  tzIndex = currentLen - 5; // Update tzIndex after modification\n            } else {\n                 // Should not happen based on initial 'if' condition, but defensively:\n                  throw new java.text.ParseException(\n                      String.format(\"Cannot parse date \\\"%s\\\": Invalid timezone specification\", dateStr),\n                      len > 0 ? len -1 : 0);\n             }\n        } else {\n            // No timezone recognized? Assume 'Z' (UTC) like original code did.\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            sb.append('Z');\n            currentLen++; // Reflect addition\n            tzIndex = currentLen - 1; // Correct tzIndex for appended Z\n        }\n\n        // 3. Normalize time part (before tzIndex in the StringBuilder)\n        //    ISO8601 formatters require seconds and milliseconds (.SSS)\n        int tIndex = sb.indexOf(\"T\");\n        if (tIndex >= 0) { // Ensure 'T' separator is present\n             int timePartEndIndex = tzIndex; // Where the time part (before timezone) ends\n             int timePartStartIndex = tIndex + 1;\n             // Find the decimal point for milliseconds, if any\n             int dotIndex = -1;\n             for (int i = timePartStartIndex; i < timePartEndIndex; ++i) {\n                 if (sb.charAt(i) == '.') {\n                     dotIndex = i;\n                     break;\n                 }\n             }\n\n             if (dotIndex < 0) { // No fractional seconds found\n                 // Check if seconds are present based on colon count\n                 int colonCount = 0;\n                 for (int i = timePartStartIndex; i < timePartEndIndex; ++i) {\n                     if (sb.charAt(i) == ':') {\n                         colonCount++;\n                     }\n                 }\n                 // Insert milliseconds; also seconds if missing\n                 if (colonCount == 1) { // Only HH:mm -> need to add \":00.000\"\n                     sb.insert(timePartEndIndex, \":00.000\");\n                     currentLen += 7;\n                 } else { // Assume HH:mm:ss or HHmmss -> need to add \".000\"\n                     // We need seconds present (2 colons or no colons after T) to add millis\n                     // Check length for HHmmss case (should be 6 digits)\n                     if (colonCount == 2 || (colonCount == 0 && timePartEndIndex - timePartStartIndex == 6)) {\n                          sb.insert(timePartEndIndex, \".000\");\n                          currentLen += 4;\n                     }\n                     // Otherwise, format is unexpected, let parser fail later\n                 }\n             } else { // Fractional seconds found, ensure 3 digits (pad/truncate)\n                 int fractionLen = timePartEndIndex - (dotIndex + 1);\n                 if (fractionLen < 3) { // Pad with zeros\n                     for (int i = fractionLen; i < 3; ++i) {\n                         sb.insert(timePartEndIndex, '0');\n                         currentLen++;\n                     }\n                 } else if (fractionLen > 3) { // Truncate\n                     sb.delete(dotIndex + 1 + 3, timePartEndIndex);\n                     currentLen -= (fractionLen - 3);\n                 }\n                 // else fractionLen == 3, nothing to do\n             }\n        }\n        // Else: No 'T', or invalid format. Let parser decide.\n\n        return df.parse(sb.toString(), pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}