{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date (yyyy-MM-dd)\n        if (len <= 10 && Character.isDigit(c)) { \n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') { // Handle 'Z' (Zulu) timezone explicitly\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            \n            StringBuilder sb = new StringBuilder(dateStr);\n            int tPos = sb.lastIndexOf(\"T\");\n            \n            // Should have a 'T' for time components with 'Z'. If not, append default time.\n            if (tPos > 0) {\n                int endOfTimePart = sb.length() - 1; // Position before 'Z'\n\n                // Check for missing seconds (e.g. HH:mmZ)\n                String timeSectionBeforeZ = sb.substring(tPos + 1, endOfTimePart);\n                if (timeSectionBeforeZ.length() == 5 && timeSectionBeforeZ.charAt(2) == ':') { // HH:mm\n                    sb.insert(endOfTimePart, \":00\");\n                    endOfTimePart += 3; // Shift insertion point as string grew\n                }\n                \n                // Check for milliseconds\n                int dotPos = sb.indexOf(\".\", tPos);\n                if (dotPos < 0 || dotPos >= endOfTimePart) { // No dot for milliseconds, add \".000\"\n                    sb.insert(endOfTimePart, \".000\");\n                } else { // Dot exists, but partial milliseconds (.S, .SS)\n                    String currentMillis = sb.substring(dotPos + 1, endOfTimePart);\n                    int numMillisDigits = currentMillis.length();\n                    if (numMillisDigits > 0 && numMillisDigits < 3) {\n                        int millisInsertPoint = dotPos + 1 + numMillisDigits;\n                        for (int i = 0; i < (3 - numMillisDigits); ++i) {\n                            sb.insert(millisInsertPoint, '0');\n                        }\n                    }\n                }\n            } else { // No 'T', e.g. \"1997-07-16Z\". Append default time.\n                sb.insert(len - 1, \"T00:00:00.000\");\n            }\n            dateStr = sb.toString(); // Update dateStr for parsing\n        } else {\n            // This is the branch for non-'Z' timezones (+/-HH:MM, +/-HH) or no explicit timezone.\n            if (hasTimeZone(dateStr)) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                \n                // 1. Normalize timezone offset: \"+HH:MM\" -> \"+HHMM\", \"+HH\" -> \"+HH00\"\n                int tzStart = -1;\n                for (int i = sb.length() - 1; i >= 0; --i) {\n                    char ch = sb.charAt(i);\n                    if (ch == '+' || ch == '-') {\n                        tzStart = i;\n                        break;\n                    }\n                }\n                \n                if (tzStart > 0) { // Found a timezone offset\n                    // Check if colon exists in TZ offset (+01:00)\n                    if (sb.length() > tzStart + 3 && sb.charAt(tzStart + 3) == ':') {\n                        sb.delete(tzStart + 3, tzStart + 4); // Remove the colon\n                    } else if (sb.length() == tzStart + 3) { // Missing minutes (+01)\n                        sb.append(\"00\");\n                    }\n                    // Update dateStr so subsequent index lookups are correct\n                    dateStr = sb.toString();\n                    len = dateStr.length(); // Update len after modifications\n                    // Recalculate tzStart after possible string length change\n                    tzStart = -1; // reset and find again based on new dateStr\n                    for (int i = len - 1; i >= 0; --i) {\n                        char ch = dateStr.charAt(i);\n                        if (ch == '+' || ch == '-') {\n                            tzStart = i;\n                            break;\n                        }\n                    }\n                    sb = new StringBuilder(dateStr); // Re-initialize sb with current state\n                }\n\n                // 2. Handle missing seconds and partial milliseconds before the timezone offset\n                int tPos = sb.lastIndexOf(\"T\");\n                int endOfTimePart = (tzStart > 0) ? tzStart : sb.length(); // Position before timezone offset or end of string\n\n                if (tPos > 0) { // Has time part (T present)\n                    // Check for missing seconds (e.g., HH:mm -> HH:mm:00)\n                    int dotPos = sb.indexOf(\".\", tPos);\n                    if (dotPos < 0 || dotPos >= endOfTimePart) { // No dot for milliseconds part\n                        String timeSection = sb.substring(tPos + 1, endOfTimePart);\n                        if (timeSection.length() == 5 && timeSection.charAt(2) == ':') { // HH:mm\n                            sb.insert(endOfTimePart, \":00\");\n                            endOfTimePart += 3; // Shift insertion point\n                        }\n                        // Now, regardless if seconds were missing or present, if no millis dot, add \".000\"\n                        sb.insert(endOfTimePart, \".000\");\n                    } else { // Dot exists, but partial milliseconds (.S, .SS)\n                        String currentMillis = sb.substring(dotPos + 1, endOfTimePart);\n                        int numMillisDigits = currentMillis.length();\n                        if (numMillisDigits > 0 && numMillisDigits < 3) {\n                            int millisInsertPoint = dotPos + 1 + numMillisDigits;\n                            for (int i = 0; i < (3 - numMillisDigits); ++i) {\n                                sb.insert(millisInsertPoint, '0');\n                            }\n                        }\n                    }\n                } else { // No 'T' in string but has timezone, e.g., \"yyyy-MM-dd+HHMM\"\n                         // Append T00:00:00.000\n                    sb.insert(endOfTimePart, \"T00:00:00.000\");\n                }\n                dateStr = sb.toString(); // Final string after all modifications\n                \n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else { // No explicit timezone (nor 'Z')\n                // This means date like \"2014-10-03T18:00:00\" or \"2014-10-03T18:00\"\n                // It should be converted to ISO8601_Z (i.e. 'Z' appended and \".000\" if missing/partial)\n                StringBuilder sb = new StringBuilder(dateStr);\n                int tPos = sb.lastIndexOf(\"T\");\n\n                if (tPos > 0) { // Has time part\n                    int endOfTimePart = sb.length(); // Current end of string (before appending Z)\n                    // Check for missing seconds (e.g. HH:mm)\n                    String timeSection = sb.substring(tPos + 1, endOfTimePart);\n                    if (timeSection.length() == 5 && timeSection.charAt(2) == ':') { // HH:mm\n                        sb.insert(tPos + 6, \":00\"); // Insert :00 after minutes\n                        endOfTimePart += 3; // Shift end position as string grew\n                    }\n                    \n                    // Check for milliseconds\n                    int dotPos = sb.indexOf(\".\", tPos);\n                    if (dotPos < 0 || dotPos >= endOfTimePart) { // No dot for milliseconds\n                        sb.append(\".000\");\n                    } else { // Dot exists, but partial milliseconds\n                        String currentMillis = sb.substring(dotPos + 1, endOfTimePart);\n                        int numMillisDigits = currentMillis.length();\n                        if (numMillisDigits > 0 && numMillisDigits < 3) {\n                            int millisInsertPoint = dotPos + 1 + numMillisDigits;\n                            for (int i = 0; i < (3 - numMillisDigits); ++i) {\n                                sb.insert(millisInsertPoint, '0');\n                            }\n                        }\n                    }\n                } else { // No 'T' and no timezone. Assume `yyyy-MM-dd` and append default time.\n                         // This is typically handled by `len <= 10` branch but might be longer, e.g. \"2014-10-03\"\n                         // if it was not caught by the plain date condition, append default time.\n                    sb.append(\"T00:00:00.000\");\n                }\n                sb.append('Z'); // Always append 'Z' for this case\n                dateStr = sb.toString();\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}