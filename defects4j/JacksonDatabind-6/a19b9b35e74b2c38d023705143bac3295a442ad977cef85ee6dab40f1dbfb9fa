{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         *    [databind#570]: Make handling of missing seconds, milliseconds robust\n         */\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // 1. Plain date? \"yyyy-MM-dd\"\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        // 2. Zulu format? \"...Z\"\n        } else if (c == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // If it ends with 'Z', it's UTC. Check if seconds/milliseconds need to be added or padded.\n            // Z timezone marker is at len-1. Check char before it.\n            int dotIndex = dateStr.lastIndexOf('.');\n            int tIndex = dateStr.lastIndexOf('T'); // Required part of ISO-8601 date/time\n\n            // If no dot, milliseconds are missing. Check if seconds are also missing.\n            if (dotIndex < 0) {\n                 // Check for index of last colon; if it's before 'T', seconds are missing\n                 if (tIndex >= 0) {\n                     int lastColon = dateStr.lastIndexOf(':');\n                     if (lastColon > tIndex) { // Check colon only appears after T\n                         // Check if there's only one colon after T (HH:mm'Z')\n                         int firstColon = dateStr.indexOf(':', tIndex+1);\n                         if (lastColon == firstColon) { // Only one colon means HH:mmZ format\n                            StringBuilder sb = new StringBuilder(dateStr);\n                            // insert \":00.000\" before the Z\n                            sb.insert(len-1, \":00.000\");\n                            dateStr = sb.toString();\n                         } else { // Two colons means HH:mm:ssZ format, just need millis\n                            StringBuilder sb = new StringBuilder(dateStr);\n                            // insert \".000\" before the Z\n                            sb.insert(len-1, \".000\");\n                            dateStr = sb.toString();\n                         }\n                     }\n                     // If T exists but no colon after T, this is an invalid format for time; let parser fail\n                 }\n            } else { // Dot found, means partial or full milliseconds exist. Pad if needed.\n                 // Calculate number of millisecond digits: Z is at len-1, dot is at dotIndex\n                 int millisLen = (len - 1) - (dotIndex + 1);\n                 if (millisLen < 3) { // Need padding\n                     StringBuilder sb = new StringBuilder(dateStr);\n                     for (int i = millisLen; i < 3; ++i) {\n                         sb.insert(len-1, '0'); // Insert '0' before Z\n                     }\n                     dateStr = sb.toString();\n                 }\n            }\n        // 3. Timezone offset format? \"...+HH:mm\", \"...+HHmm\", \"...-HH:mm\", \"...-HHmm\" etc\n        } else if (hasTimeZone(dateStr)) {\n            // First, normalize the timezone indicator\n            c = dateStr.charAt(len-3);\n            int originalLen = len; // Keep original length for calculations before modification\n\n            if (c == ':') { // Includes colon, like \"+01:00\". Remove colon.\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len-3, len-2);\n                dateStr = sb.toString();\n                len -= 1; // Adjust length\n            } else if (c == '+' || c == '-') { // Might be \"+01\" or \"-03\"\n                // Check if the sign is indeed at len-3 (meaning '+HH' or '-HH')\n                if (dateStr.lastIndexOf(c) == len - 3) {\n                    // Append \"00\" for minutes\n                    dateStr += \"00\";\n                    len += 2; // Adjust length\n                }\n            }\n            // Now, timezone should be in \"+HHMM\" or \"-HHMM\" format (5 chars)\n\n            // Check and normalize seconds / milliseconds part before the timezone offset\n            int tzIndex = len - 5; // Index where timezone starts (+/-HHMM)\n            int dotIndex = -1;\n            // Find the last dot before the timezone marker\n             for (int i = tzIndex - 1; i > 0; --i) {\n                 char d = dateStr.charAt(i);\n                 if (d == '.') {\n                     dotIndex = i;\n                     break;\n                 }\n                 // Optimization: stop scan if non-digit found before dot\n                 if (d < '0' || d > '9') {\n                     // Allow T and : but break otherwise\n                     if (d != 'T' && d != ':') break;\n                 }\n             }\n\n            int tIndex = dateStr.lastIndexOf('T');\n\n            if (dotIndex > tIndex) { // Dot found between 'T' and timezone offset\n                // Milliseconds exist, check length: \".1+HHMM\", \".12+HHMM\"\n                int millisLen = tzIndex - dotIndex - 1; // Number of digits after dot, before timezone\n                if (millisLen < 3) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    for (int i = millisLen; i < 3; ++i) {\n                        sb.insert(tzIndex, '0'); // Pad with 0s before timezone offset\n                    }\n                    dateStr = sb.toString();\n                }\n            } else { // No dot found between T and timezone marker\n                // Check if seconds are missing: count colons between T and timezone marker\n                int colons = 0;\n                if (tIndex >= 0) {\n                    for (int i = tIndex + 1; i < tzIndex; ++i) {\n                        if (dateStr.charAt(i) == ':') {\n                            colons++;\n                        }\n                    }\n                }\n\n                if (colons == 2) { // Format like \"HH:mm:ss\", missing milliseconds\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(tzIndex, \".000\");\n                    dateStr = sb.toString();\n                } else if (colons == 1) { // Format like \"HH:mm\", missing seconds and milliseconds\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(tzIndex, \":00.000\");\n                    dateStr = sb.toString();\n                }\n                // If colons == 0 (like \"yyyy-MM-ddTHH+HHMM\"), or other unexpected format, let parser fail.\n            }\n\n             df = _formatISO8601;\n             if (df == null) {\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n             }\n        // 4. Default: Treat string without explicit timezone as Zulu time (per ISO-8601)\n        } else {\n            // Append 'Z' and normalize seconds/milliseconds.\n            StringBuilder sb = new StringBuilder(dateStr);\n            int tIndex = dateStr.lastIndexOf('T');\n            int originalLen = len; // Length before modification\n            int dotIndex = -1;\n             // Find the last dot after 'T'\n            for (int i = originalLen - 1; i > tIndex; --i) {\n                 if (dateStr.charAt(i) == '.') {\n                     dotIndex = i;\n                     break;\n                 }\n            }\n\n             if (dotIndex > tIndex) { // dot found after T\n                 int millisLen = originalLen - dotIndex - 1; // Digits after dot\n                 if (millisLen < 3) {\n                     for (int i = millisLen; i < 3; ++i) {\n                         sb.append('0'); // Append missing zeros for milliseconds\n                     }\n                 }\n             } else { // No dot found after T\n                 // Count colons after T to determine if seconds are present\n                 int colons = 0;\n                 if (tIndex >= 0) { // Only count if T exists\n                     for (int i = tIndex + 1; i < originalLen; ++i) {\n                         if (dateStr.charAt(i) == ':') {\n                             colons++;\n                         }\n                     }\n                 }\n                 if (colons == 2) { // HH:mm:ss format\n                     sb.append(\".000\"); // Add milliseconds\n                 } else if (colons == 1) { // HH:mm format\n                     sb.append(\":00.000\"); // Add seconds and milliseconds\n                 }\n                 // else: unexpected format (e.g., \"yyyy-MM-ddTHH\"), let parser fail later\n             }\n\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        _timezone, _locale);\n            }\n        }\n        // If we reach here, `dateStr` should be normalized for the chosen format, try parsing\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}