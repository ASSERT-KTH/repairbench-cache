{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         * Applied fix from [databind#117], allowing for dates without\n         * time and plain dates too.\n         * And [databind#570] fix for partial milliseconds.\n         * And [databind#178] fix for missing seconds.\n         */\n        int len = dateStr.length();\n        // All ISO8601 variants need minimal length \"yyyy-MM-dd\" which is 10\n        // Let SimpleDateFormat fail on too short strings later.\n\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n        final String formatStr;\n\n        // 1. Handle plain date \"yyyy-MM-dd\"\n        // This is not exactly ISO-8601 format but is often used\n        if (len == 10 && Character.isDigit(c)) {\n             boolean isPlain = true;\n             for (int i = 0; i < len; ++i) {\n                 char ch = dateStr.charAt(i);\n                 if (i == 4 || i == 7) {\n                     if (ch != '-') { isPlain = false; break; }\n                 } else {\n                     if (!Character.isDigit(ch)) { isPlain = false; break; }\n                 }\n             }\n             if (isPlain) {\n                df = _formatPlain;\n                formatStr = DATE_FORMAT_STR_PLAIN; // yyyy-MM-dd\n                if (df == null) {\n                    df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale);\n                }\n                return df.parse(dateStr, pos);\n             }\n             // If not plain format, fall through to ISO handling\n        }\n\n        // ISO-8601 variants: 'Z' or +/-nn:nn or +/-nnnn\n        // These formats require seconds and 3-digit milliseconds for our standard formatters.\n        // We need to normalize the input string if they are missing or partial.\n        String normDateStr = dateStr; // Start with original, modify if needed\n\n        // 2. Handle 'Z' variant (UTC)\n        if (c == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z; // yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, GMT, _locale);\n            }\n            // Ensure GMT is used because DateFormats are stateful and not thread-safe\n            if (!GMT.equals(df.getTimeZone())) {\n                 // Must create a new instance because DateFormat instances are not thread-safe\n                 df = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, GMT, _locale);\n            }\n\n            // Normalize for seconds and milliseconds if necessary\n            int zIndex = len - 1;\n            int timeSepIndex = normDateStr.indexOf('T');\n\n            // Must have 'T' and time part for Z variant usually\n            if (timeSepIndex > 0) {\n                int dotIndex = normDateStr.lastIndexOf('.', zIndex - 1);\n                int secondColonIndex = -1;\n                int firstColonIndex = normDateStr.indexOf(':', timeSepIndex + 1);\n\n                 if (firstColonIndex > 0) {\n                      secondColonIndex = normDateStr.indexOf(':', firstColonIndex + 1);\n                      // Check if colon is part of time, not something weird before Z\n                      if (secondColonIndex > 0 && ( (dotIndex > 0 && secondColonIndex > dotIndex) || secondColonIndex > zIndex ) ) {\n                          secondColonIndex = -1; // Invalid colon position\n                      }\n                 }\n\n                 // Check if we have at least HH:mm\n                 if (firstColonIndex > 0) {\n                     StringBuilder sb = null; // Create lazily if needed\n                     int V = (dotIndex > 0) ? (zIndex - (dotIndex + 1)) : 0; // Millisecond digits count\n\n                     if (dotIndex < 0 && secondColonIndex < 0) { // Format like HH:mmZ\n                         sb = new StringBuilder(normDateStr);\n                         sb.insert(zIndex, \":00.000\");\n                     } else if (dotIndex < 0) { // Format like HH:mm:ssZ\n                         sb = new StringBuilder(normDateStr);\n                         sb.insert(zIndex, \".000\");\n                     } else if (V < 3) { // Format like HH:mm:ss.SZ or HH:mm:ss.SSZ\n                         sb = new StringBuilder(normDateStr);\n                         for (; V < 3; ++V) {\n                             // Insert '0' *before* 'Z'\n                             sb.insert(zIndex, '0');\n                         }\n                     }\n                     // else: Format HH:mm:ss.SSSZ - no change needed\n\n                     if (sb != null) {\n                         normDateStr = sb.toString();\n                     }\n                 }\n                 // else: 'T' without HH:mm? Let SDF parse fail on original string.\n            }\n            // else: No 'T'? Let SDF parse fail on original string.\n\n        }\n        // 3. Handle offset variant (+/-HH:mm, +/-HHmm, +/-HH)\n        else if (hasTimeZone(normDateStr)) {\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601; // yyyy-MM-dd'T'HH:mm:ss.SSSZ\n            if (df == null) {\n                // TZ here is default, SDF will override based on parsed offset using 'Z' pattern char\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale);\n            }\n\n            // Normalize timezone first to +/-HHmm required by 'Z' pattern char\n            int signPos = Math.max(normDateStr.lastIndexOf('+'), normDateStr.lastIndexOf('-'));\n            // Heuristic check: timezone sign should appear after 'T' and some time digits\n            int timeSepIndex = normDateStr.indexOf('T');\n            if (signPos > 0 && timeSepIndex > 0 && signPos > timeSepIndex + 4) { // Check sign is after T HH:m\n                String P1 = normDateStr.substring(0, signPos); // Date/time part\n                String P2 = normDateStr.substring(signPos); // Timezone part (+/-...)\n\n                int tzLen = P2.length();\n                boolean tzNormalized = false;\n                if (tzLen == 6 && P2.charAt(3) == ':') { // Format +/-HH:mm -> +/-HHmm\n                     P2 = P2.substring(0, 3) + P2.substring(4);\n                     tzNormalized = true;\n                } else if (tzLen == 3) { // Format +/-HH -> +/-HH00\n                     P2 = P2 + \"00\";\n                     tzNormalized = true;\n                } else if (tzLen == 5) { // Format +/-HHmm - already ok\n                     tzNormalized = true;\n                }\n\n                if (tzNormalized) { // Only proceed if timezone looks valid and normalized\n                    // Now normalize seconds/milliseconds in P1\n                    int timePartEndIndex = P1.length();\n                    int dotIndex = P1.lastIndexOf('.');\n                    int secondColonIndex = -1;\n                    int firstColonIndex = P1.indexOf(':', timeSepIndex + 1);\n\n                    if (firstColonIndex > 0) { // Must have at least T HH:mm\n                         secondColonIndex = P1.indexOf(':', firstColonIndex + 1);\n                         if (secondColonIndex > 0 && dotIndex > 0 && secondColonIndex > dotIndex) {\n                            secondColonIndex = -1; // Invalid colon position\n                         }\n\n                         StringBuilder sb = null; // Create lazily\n                         int V = (dotIndex > 0) ? (timePartEndIndex - (dotIndex + 1)) : 0;\n\n                         if (dotIndex < 0 && secondColonIndex < 0) { // HH:mm -> HH:mm:00.000\n                             P1 = P1 + \":00.000\";\n                         } else if (dotIndex < 0) { // HH:mm:ss -> HH:mm:ss.000\n                             P1 = P1 + \".000\";\n                         } else if (V < 3) { // HH:mm:ss.S or HH:mm:ss.SS -> pad to SSS\n                             sb = new StringBuilder(P1);\n                             for (; V < 3; ++V) {\n                                 sb.append('0'); // Append to end of P1\n                             }\n                             P1 = sb.toString();\n                         }\n                         // else: HH:mm:ss.SSS - no change needed\n\n                         normDateStr = P1 + P2; // Reassemble final string\n                    }\n                    // else: T without HH:mm? Let SDF parse fail on original string.\n                }\n                // else: Timezone didn't look like standard offset format. Pass original string.\n            }\n            // else: Sign not found or in unexpected place. Pass original string.\n        }\n        // 4. No timezone ('Z' or offset): Treat as local time? UTC?\n        // Jackson's default is typically UTC for dates without offset. Let's append 'Z'.\n        else {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z; // yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, GMT, _locale);\n            }\n            // Ensure GMT is used\n            if (!GMT.equals(df.getTimeZone())) {\n                  // Must create a new instance because DateFormat instances are not thread-safe\n                  df = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, GMT, _locale);\n            }\n\n            // Normalize seconds/milliseconds and append 'Z'\n            int timeSepIndex = normDateStr.indexOf('T');\n            if (timeSepIndex > 0) { // Must have 'T'\n                int dotIndex = normDateStr.lastIndexOf('.');\n                int secondColonIndex = -1;\n                int firstColonIndex = normDateStr.indexOf(':', timeSepIndex + 1);\n\n                if (firstColonIndex > 0) { // Must have T HH:mm\n                     secondColonIndex = normDateStr.indexOf(':', firstColonIndex + 1);\n                     if (secondColonIndex > 0 && dotIndex > 0 && secondColonIndex > dotIndex) {\n                         secondColonIndex = -1; // Invalid colon position\n                     }\n\n                     StringBuilder sb = new StringBuilder(normDateStr);\n                     int V = (dotIndex > 0) ? (len - (dotIndex + 1)) : 0; // Millisecond digits count from original len\n\n                     if (dotIndex < 0 && secondColonIndex < 0) { // HH:mm -> HH:mm:00.000\n                         sb.append(\":00.000\");\n                     } else if (dotIndex < 0) { // HH:mm:ss -> HH:mm:ss.000\n                         sb.append(\".000\");\n                     } else if (V < 3) { // HH:mm:ss.S or HH:mm:ss.SS -> pad to SSS\n                         for (; V < 3; ++V) {\n                             sb.append('0');\n                         }\n                     }\n                     // else: HH:mm:ss.SSS - no change needed\n\n                     sb.append('Z'); // Append 'Z'\n                     normDateStr = sb.toString();\n                 }\n                 // else: T without HH:mm? Let SDF parse fail on original string.\n             }\n             // else: No 'T'? Let SDF parse fail on original string.\n        }\n\n        // Use the selected formatter on the (potentially normalized) string\n        return df.parse(normDateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}