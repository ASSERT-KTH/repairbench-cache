{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone modifiers for ISO-8601. So we need to do some scrubbing.\n         * 14-Nov-2014, tatu: Revised radically to handle more variations,\n         * specifically, missing components and partial milliseconds.\n         */\n        int len = dateStr.length();\n        DateFormat df;\n        String timezoneStr; // Normalized timezone: Z, +HHmm or -HHmm\n        int timePartEndIndex; // Index where the time part (HH:mm:ss.SSS) ends, before timezone\n\n        // First, handle the potential plain date case: \"yyyy-MM-dd\"\n        // Needs to be pattern yyyy-MM-dd\n        if (len == 10 && Character.isDigit(dateStr.charAt(len - 1)) && dateStr.charAt(4) == '-' && dateStr.charAt(7) == '-') {\n            df = _formatPlain;\n            if (df == null) {\n                // Use shared clone method directly\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n            // NOTE: No scrubbing needed, should match format directly\n            return df.parse(dateStr, pos);\n        }\n\n        // Determine timezone format and select the appropriate DateFormat\n        char lastChar = dateStr.charAt(len - 1);\n\n        if (lastChar == 'Z') { // Zulu timezone \"Z\"\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            timezoneStr = \"Z\";\n            timePartEndIndex = len - 1;\n        } else if (len >= 6 && dateStr.charAt(len - 3) == ':' && (dateStr.charAt(len - 6) == '+' || dateStr.charAt(len - 6) == '-')) {\n            // Timezone \"+/-HH:mm\"\n            df = _formatISO8601;\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n            // Normalize timezone to +/-HHmm\n            timezoneStr = dateStr.substring(len - 6, len - 3) + dateStr.substring(len - 2);\n            timePartEndIndex = len - 6;\n        } else if (len >= 5 && Character.isDigit(lastChar) && (dateStr.charAt(len - 5) == '+' || dateStr.charAt(len - 5) == '-')) {\n            // Timezone \"+/-HHmm\"\n            df = _formatISO8601;\n             if (df == null) {\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n             }\n             timezoneStr = dateStr.substring(len - 5);\n             timePartEndIndex = len - 5;\n        // Let's be specific: timezone \"+/-HH\" (implicit :00)\n        // Len must be at least 3 for \"+HH\"; last char must be digit; char at len-3 must be sign\n        } else if (len >= 3 && Character.isDigit(lastChar) && (dateStr.charAt(len - 3) == '+' || dateStr.charAt(len - 3) == '-')) {\n             // Heuristic: is the char before +/- expected (T, digit, dot)? This distinguishes\n             // \"+HH\" offset from end of seconds/millis like \"...3+...\"\n             char charBeforeSign = dateStr.charAt(len-4);\n             // Character before sign must be end of date/time part (digit, 'T', '.')\n             // Or beginning of string if date part is short (unlikely for ISO8601)\n             if (Character.isDigit(charBeforeSign) || charBeforeSign == 'T' || charBeforeSign == '.') {\n                 df = _formatISO8601;\n                 if (df == null) {\n                     df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                 }\n                 timezoneStr = dateStr.substring(len - 3) + \"00\"; // Normalize to +/-HH00\n                 timePartEndIndex = len - 3;\n             } else { // Does not look like timezone, assume implicit Z\n                 df = _formatISO8601_z;\n                 if (df == null) {\n                     df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n                 }\n                 timezoneStr = \"Z\";\n                 timePartEndIndex = len; // Time part includes up to the end\n             }\n        } else {\n            // No recognizable timezone indicator at the end, treat as Implicit Z\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            timezoneStr = \"Z\";\n            timePartEndIndex = len;\n        }\n\n        // ISO8601 requires 'T' separator for time component\n        int tIndex = dateStr.indexOf('T');\n        // If no 'T', it should have been handled by plain date case or is invalid\n        if (tIndex == -1) {\n            pos.setErrorIndex(len); // Indicate error at end, T missing\n            return null;\n        }\n\n        // Normalize the time part: yyyy-MM-dd'T'HH:mm:ss.SSS\n        String datePart = dateStr.substring(0, tIndex);\n        // Extract time part safely, can be empty if timezone immediately follows T\n        String timePart = (timePartEndIndex > tIndex + 1) ? dateStr.substring(tIndex + 1, timePartEndIndex) : \"\";\n\n        String hhmmPart;\n        String ssPart = \":00\"; // Default seconds\n        String SSSPart = \".000\"; // Default milliseconds\n\n        int timeColon1 = timePart.indexOf(':');\n        int timeColon2 = (timeColon1 == -1) ? -1 : timePart.indexOf(':', timeColon1 + 1);\n        // Look for dot AFTER the seconds field (i.e., after second colon, or after first if no second colon)\n        int timeDot = timePart.indexOf('.', (timeColon2 > timeColon1) ? timeColon2 + 1 : (timeColon1 > -1 ? timeColon1 + 1 : 0));\n\n        if (timePart.isEmpty()) { // Case like \"yyyy-MM-ddTZ\" or \"yyyy-MM-ddT+HH:mm\" -> use default 00:00:00.000\n            hhmmPart = \"00:00\";\n        } else if (timeColon1 == -1) { // No colons: Not HH:mm(:ss)? format. Invalid.\n             // ISO 8601 allows basic format (no colons), but SimpleDateFormat needs them.\n             pos.setErrorIndex(tIndex + 1); // Error in time part structure\n             return null;\n        } else if (timeColon2 == -1) { // Only one colon: HH:mm\n             // Check for dot: If dot exists, it's HH:mm.SSS which is invalid format\n             if (timeDot != -1) {\n                 pos.setErrorIndex(timeDot); // Invalid format HH:mm.SSS\n                 return null;\n             }\n             hhmmPart = timePart; // Format is HH:mm\n             // ssPart and SSSPart remain default \":00\" and \".000\"\n        } else { // Two colons: HH:mm:ss[.SSS]\n            hhmmPart = timePart.substring(0, timeColon2); // HH:mm part\n            if (timeDot == -1) { // HH:mm:ss (no dot)\n                ssPart = timePart.substring(timeColon2); // :ss part\n                // Ensure ssPart is valid \":ss\" format (length 3)\n                if (ssPart.length() != 3 || !Character.isDigit(ssPart.charAt(1)) || !Character.isDigit(ssPart.charAt(2))) {\n                     pos.setErrorIndex(timeColon2+1); return null;\n                }\n                SSSPart = \".000\"; // Add default millis\n            } else { // HH:mm:ss.SSS... (dot found)\n                ssPart = timePart.substring(timeColon2, timeDot); // :ss part\n                // Ensure ssPart is valid \":ss\" format (length 3)\n                if (ssPart.length() != 3 || !Character.isDigit(ssPart.charAt(1)) || !Character.isDigit(ssPart.charAt(2))) {\n                     pos.setErrorIndex(timeColon2+1); return null;\n                }\n                SSSPart = timePart.substring(timeDot); // .SSS... part\n            }\n        }\n\n        // Normalize SSSPart (milliseconds) to .SSS format\n        if (SSSPart.startsWith(\".\")) {\n            int millisLen = SSSPart.length() - 1; // Number of digits after dot\n            if (millisLen == 0) SSSPart = \".000\"; // \".\" -> \".000\"\n            else if (millisLen == 1) SSSPart += \"00\"; // \".S\" -> \".S00\"\n            else if (millisLen == 2) SSSPart += \"0\"; // \".SS\" -> \".SS0\"\n            else if (millisLen > 3) SSSPart = SSSPart.substring(0, 4); // \".SSS...\" -> \".SSS\"\n            // else millisLen == 3 (\".SSS\"), do nothing\n        } else if (!SSSPart.equals(\".000\")) { // If not default and not starting with '.', it's invalid\n             pos.setErrorIndex(timeDot > -1 ? timeDot : timePartEndIndex);\n             return null;\n        }\n        // else SSSPart is already \".000\" (default) or correctly formatted \".SSS\"\n\n\n        // Reconstruct the date string in the target format (yyyy-MM-dd'T'HH:mm:ss.SSS + timezone)\n        String rebuiltDateStr = datePart + \"T\" + hhmmPart + ssPart + SSSPart;\n\n        if (df == _formatISO8601_z) { // Target format needs 'Z' literal\n             rebuiltDateStr += \"Z\";\n        } else { // Target format needs Z pattern (+/-HHmm)\n             if (\"Z\".equals(timezoneStr)) { // Input was Z, but target needs offset\n                 timezoneStr = \"+0000\"; // Convert Z to offset\n             }\n             rebuiltDateStr += timezoneStr;\n        }\n\n        return df.parse(rebuiltDateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}