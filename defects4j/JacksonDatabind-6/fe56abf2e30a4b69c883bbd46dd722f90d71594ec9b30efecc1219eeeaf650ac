{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        // This branch handles \"yyyy-MM-dd\" format explicitly.\n        if (len <= 10 && Character.isDigit(c)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n            return df.parse(dateStr, pos);\n        }\n\n        // All other cases are expected to have a time component and potentially a timezone\n        StringBuilder sb = new StringBuilder(dateStr);\n        int tPos = sb.lastIndexOf(\"T\"); // Find 'T' separator for time component\n\n        if (c == 'Z') { // Zulu timezone ('Z' == \"GMT\")\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n            // Ensure time component is 'HH:mm:ss.SSS' before 'Z'\n            if (tPos > 0) {\n                int timePartEndIndex = len - 1; // Index where 'Z' is. Insert/append before it.\n                // timePartLength is the length of \"HH:mm\", \"HH:mm:ss\", \"HH:mm:ss.S\" etc.\n                int timePartLength = timePartEndIndex - (tPos + 1);\n\n                // Case 1: Missing seconds and milliseconds (e.g., \"HH:mm\")\n                if (timePartLength == 5) { // \"HH:mm\" (length 5)\n                    sb.insert(timePartEndIndex, \":00.000\");\n                }\n                // Case 2: Missing milliseconds (e.g., \"HH:mm:ss\")\n                else if (timePartLength == 8) { // \"HH:mm:ss\" (length 8)\n                    sb.insert(timePartEndIndex, \".000\");\n                }\n                // Case 3: Partial milliseconds (e.g., \"HH:mm:ss.S\", \"HH:mm:ss.SS\")\n                else if (timePartLength > 8) { // Potentially \"HH:mm:ss.S\" or \"HH:mm:ss.SS\"\n                    // Check if a dot for milliseconds exists and pad if needed\n                    // Find the dot in the string up to 'Z'\n                    int dotPos = sb.lastIndexOf('.', timePartEndIndex); \n                    if (dotPos > tPos) { // Dot found within the time part\n                        int fractionLength = timePartEndIndex - (dotPos + 1); // Number of digits after dot\n                        if (fractionLength < 3) {\n                            for (int i = 0; i < (3 - fractionLength); ++i) {\n                                sb.insert(timePartEndIndex, '0'); // Pad with '0's\n                            }\n                        }\n                    } else { // No dot found, means milliseconds are completely missing\n                        sb.insert(timePartEndIndex, \".000\");\n                    }\n                }\n                dateStr = sb.toString(); // Update dateStr with modified content\n            }\n        } else { // Does not end with 'Z'. Could have +/-HH:MM or +/-HHMM or no timezone at all.\n            // Check if it has a timezone offset (e.g., \"+01:00\", \"-0500\")\n            if (hasTimeZone(dateStr)) {\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n                \n                // Find the start of the timezone offset ('+' or '-')\n                int tzStart = dateStr.lastIndexOf('+');\n                if (tzStart < 0) {\n                    tzStart = dateStr.lastIndexOf('-');\n                }\n                \n                // Ensure 'T' and a timezone offset are both present\n                if (tPos > 0 && tzStart > 0) {\n                    // timePartEndIndex is the index of the timezone sign ('+' or '-').\n                    // We insert/append before this index.\n                    int timePartEndIndex = tzStart; \n                    // timePartLength is the length of \"HH:mm\", \"HH:mm:ss\", \"HH:mm:ss.S\" etc.\n                    int timePartLength = timePartEndIndex - (tPos + 1);\n\n                    // Apply the same logic as for 'Z' dates to pad seconds and milliseconds\n                    if (timePartLength == 5) { // \"HH:mm\"\n                        sb.insert(timePartEndIndex, \":00.000\");\n                    } else if (timePartLength == 8) { // \"HH:mm:ss\"\n                        sb.insert(timePartEndIndex, \".000\");\n                    } else if (timePartLength > 8) { \n                        int dotPos = sb.lastIndexOf('.', timePartEndIndex);\n                        if (dotPos > tPos) { // Dot found within the time part\n                            int fractionLength = timePartEndIndex - (dotPos + 1);\n                            if (fractionLength < 3) {\n                                for (int i = 0; i < (3 - fractionLength); ++i) {\n                                    sb.insert(timePartEndIndex, '0');\n                                }\n                            }\n                        } else { // No dot for milliseconds, but timePartLength > 8 implies 'HH:mm:ss' without dot\n                            sb.insert(timePartEndIndex, \".000\");\n                        }\n                    }\n                    dateStr = sb.toString(); // Update dateStr with modified content\n                }\n            } else { // No explicit timezone: assume UTC/GMT ('Z')\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n                \n                // Handle missing seconds/milliseconds, then append 'Z'\n                if (tPos > 0) { // If there's a time component\n                    int timePartEndIndex = len; // Append before 'Z' is added\n                    int timePartLength = timePartEndIndex - (tPos + 1);\n                    \n                    if (timePartLength == 5) { // \"HH:mm\"\n                        sb.append(\":00.000\");\n                    } else if (timePartLength == 8) { // \"HH:mm:ss\"\n                        sb.append(\".000\");\n                    } else if (timePartLength > 8) {\n                        int dotPos = sb.lastIndexOf('.', timePartEndIndex);\n                        if (dotPos > tPos) {\n                            int fractionLength = timePartEndIndex - (dotPos + 1);\n                            if (fractionLength < 3) {\n                                for (int i = 0; i < (3 - fractionLength); ++i) {\n                                    sb.append('0');\n                                }\n                            }\n                        } else { // No dot for milliseconds\n                            sb.append(\".000\");\n                        }\n                    }\n                } else { // No 'T' in string, e.g. \"yyyy-MM-dd\"\n                         // This path should ideally be caught by the first `if (len <= 10 ...)`\n                         // If it gets here, it means a date-only string that didn't match the plain format.\n                         // Best effort is to append a default time and 'Z'.\n                    sb.append(\"T00:00:00.000\");\n                }\n                sb.append('Z'); // Always append 'Z' as fallback timezone\n                dateStr = sb.toString();\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}