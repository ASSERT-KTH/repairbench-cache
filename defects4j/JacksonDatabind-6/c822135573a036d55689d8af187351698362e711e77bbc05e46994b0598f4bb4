{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        int len = dateStr.length();\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        // This handles \"yyyy-MM-dd\" format where len is 10 and last char is a digit.\n        if (len <= 10 && Character.isDigit(dateStr.charAt(len-1))) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n            return df.parse(dateStr, pos);\n        }\n\n        StringBuilder sb = new StringBuilder(dateStr);\n        int tzSuffixLen = 0; // Length of timezone suffix (0: none, 1: 'Z', 5: '+/-HHmm')\n        boolean zuluFormat = false; // Flag to decide between _formatISO8601_z and _formatISO8601\n\n        char lastChar = dateStr.charAt(len-1);\n\n        // 1. Determine and normalize the timezone suffix\n        if (lastChar == 'Z') {\n            zuluFormat = true;\n            tzSuffixLen = 1;\n        } else if (hasTimeZone(dateStr)) {\n            // Check for and remove optional colon in timezone offset (+HH:mm -> +HHmm)\n            // Example: \"1997-07-16T19:20+01:00\" -> \"1997-07-16T19:20+0100\"\n            // Original length is used for charAt, as sb might not be modified yet.\n            char c = dateStr.charAt(len-3);\n            if (c == ':') { // Colon is present\n                sb.delete(len-3, len-2);\n            } else if (c == '+' || c == '-') { // Missing minutes in timezone offset (+HH -> +HH00)\n                sb.append(\"00\");\n            }\n            // Update current working length of the StringBuilder after potential modification\n            len = sb.length(); \n            tzSuffixLen = 5; // Format will be \"+/-HHmm\"\n        } else { // No timezone or 'Z' detected, implies we should add 'Z' later\n            zuluFormat = true; // Will use 'Z' format\n            // tzSuffixLen remains 0 here, will be effectively 1 after 'Z' is appended.\n        }\n\n        // 2. Pad the datetime part (before the determined/final TZ suffix)\n        // Target format for this part: yyyy-MM-dd'T'HH:mm:ss.SSS\n        int tIndex = sb.lastIndexOf('T');\n        if (tIndex > 0) { // 'T' must be present for time components (e.g. \"yyyy-MM-ddTHH:mm...\")\n            // datetimePartEndIndex is the position where the timezone suffix starts (exclusive)\n            // It's `len` (current sb length) minus the already-processed/expected `tzSuffixLen`.\n            int datetimePartEndIndex = len - tzSuffixLen;\n            \n            String timePart = sb.substring(tIndex + 1, datetimePartEndIndex);\n            int dotIndex = timePart.lastIndexOf('.');\n\n            if (dotIndex != -1) { // Milliseconds part is explicitly present (e.g., \".6\", \".61\")\n                String ms = timePart.substring(dotIndex + 1); // Get milliseconds part after the dot\n                if (ms.length() < 3) {\n                    // Pad with trailing zeros to make it three digits (.6 -> .600, .61 -> .610)\n                    for (int i = 0; i < 3 - ms.length(); ++i) {\n                        sb.insert(datetimePartEndIndex, '0');\n                    }\n                }\n            } else { // No milliseconds (or dot is part of date, like 1.23 for day.month, which is not handled here)\n                // Check if seconds are missing (e.g., \"HH:mm\" vs \"HH:mm:ss\")\n                if (timePart.length() == 5) { // If format is \"HH:mm\", insert \":00\" for seconds\n                    sb.insert(tIndex + 1 + 5, \":00\"); // Insert \":00\" after 'mm'\n                }\n                // Add \".000\" for milliseconds, regardless of whether seconds were just added or already present\n                sb.insert(datetimePartEndIndex, \".000\"); // Insert \".000\" after seconds (or minutes if :00 was added)\n            }\n        } else {\n             // If 'T' is not found (tIndex <= 0) and it's not the plain date format,\n             // it likely means a date like \"yyyy-MM-dd+0100\" or similar that implies midnight.\n             // The original code implicitly relied on `hasTimeZone` to handle this by looking at `len-9`\n             // (which implicitly expects 'T').\n             // To handle \"yyyy-MM-dd\" with timezone but no time, default to midnight:\n             // We check if it's a date-only string that slipped past the _formatPlain check but has timezone.\n             // datetimePartEndIndex needs to be derived from the current sb length to insert time properly.\n             int currentSbLen = sb.length();\n             if (currentSbLen >= 10 && sb.charAt(4) == '-' && sb.charAt(7) == '-') { // Looks like \"yyyy-MM-dd\"\n                 sb.insert(currentSbLen - tzSuffixLen, \"T00:00:00.000\");\n             }\n        }\n\n        // 3. If no timezone was originally present (tzSuffixLen is still 0), append 'Z'\n        if (tzSuffixLen == 0) {\n            sb.append('Z');\n        }\n        dateStr = sb.toString(); // Finalize the modified date string\n\n        // 4. Select the correct DateFormat based on the final format of the string\n        if (zuluFormat) { // If it was 'Z' originally, or we appended 'Z'\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        } else { // It has a +/-HHmm timezone offset\n            df = _formatISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        }\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}