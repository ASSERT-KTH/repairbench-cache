{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         * 14-Mar-2014, tatu: And modifications to support variations like\n         *   missing seconds, milliseconds; partial milliseconds\n         */\n        int len = dateStr.length();\n        char last = dateStr.charAt(len - 1);\n        DateFormat df;\n\n        // 1. Handle plain date \"yyyy-MM-dd\"\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(last)) {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n            // No normalization needed for plain date format matching\n            return df.parse(dateStr, pos);\n        }\n\n        // Use StringBuilder for efficient manipulations\n        StringBuilder sb = new StringBuilder(dateStr);\n        int currentLength = len; // Track length as we modify sb\n\n        // 2. Handle 'Z' suffix (UTC)\n        if (last == 'Z') {\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n\n            // Format requires \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\"\n            // Need to ensure seconds and milliseconds are present and formatted correctly\n\n            int zIndex = currentLength - 1; // Current index of Z\n            int tIndex = sb.lastIndexOf(\"T\", zIndex - 1);\n            if (tIndex >= 0) {\n                int dotIndex = sb.lastIndexOf(\".\", zIndex - 1);\n                if (dotIndex < tIndex) dotIndex = -1; // Dot must be after T\n\n                int firstColon = sb.indexOf(\":\", tIndex + 1);\n                int secondColon = (firstColon > 0) ? sb.indexOf(\":\", firstColon + 1) : -1;\n                // Ensure second colon is before dot and before Z\n                if (secondColon > 0 && (dotIndex > 0 && secondColon > dotIndex)) secondColon = -1;\n                if (secondColon >= zIndex) secondColon = -1;\n\n                // Insert missing seconds \":00\" if only HH:mm is present\n                if (secondColon < 0 && firstColon > 0) { // Check firstColon ensures time part like HH:mm exists\n                    int insertPos = (dotIndex > 0) ? dotIndex : zIndex; // Insert before dot or Z\n                    if (insertPos >= firstColon + 3) { // Ensure insert happens after HH:mm\n                        sb.insert(insertPos, \":00\");\n                        currentLength += 3; // Update length\n                        zIndex += 3; // Update Z index\n                        if (dotIndex > 0) dotIndex += 3; // Adjust dot index if insertion was before it\n                    }\n                }\n\n                // Add/Pad milliseconds\n                // Re-check dot index on the potentially modified string builder\n                dotIndex = sb.lastIndexOf(\".\", zIndex - 1);\n                 if (dotIndex < tIndex) dotIndex = -1; // Check again if dot is after T\n\n                if (dotIndex < 0) { // Milliseconds part completely missing\n                    // Insert \".000\" before Z, but only if seconds are actually present now\n                    secondColon = sb.lastIndexOf(\":\", zIndex - 1); // Find last colon before Z\n                    firstColon = sb.indexOf(\":\", tIndex + 1);\n                    if (secondColon > firstColon) { // Check if HH:mm:ss structure exists\n                        sb.insert(zIndex, \".000\");\n                        currentLength += 4;\n                        // zIndex remains the same relative to end of string (sb length changes)\n                    }\n                } else { // Milliseconds part exists (.S, .SS, or .SSS...)\n                    // Pad partial milliseconds to exactly SSS\n                    int msLen = zIndex - (dotIndex + 1);\n                    if (msLen < 3) {\n                        for (int i = msLen; i < 3; ++i) {\n                             sb.insert(zIndex, '0'); // Insert '0's just before 'Z'\n                             currentLength++;\n                             // zIndex remains the same relative to end\n                        }\n                    } else if (msLen > 3) {\n                        // If more than 3 MS digits, truncate (SimpleDateFormat behavior varies, explicit truncate is safer)\n                        sb.delete(dotIndex + 4, zIndex);\n                        currentLength -= (msLen - 3);\n                        // zIndex needs update if we delete chars before it\n                        // It's easier to just recalculate zIndex = dotIndex + 4\n                        // But since we are inserting/deleting relative to zIndex, keeping it relative to end is okay.\n                    }\n                }\n            } // End if (tIndex >= 0) for time part normalization\n        }\n        // 3. Handle \"+/-hh:mm\" or \"+/-hhmm\" or \"+/-hh\" timezone\n        else if (hasTimeZone(dateStr)) {\n            df = _formatISO8601;\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n\n            // Format requires \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\" (Z is parsed timezone)\n\n            int tzSignPos = Math.max(sb.lastIndexOf(\"+\"), sb.lastIndexOf(\"-\"));\n            // Normalize timezone suffix first: remove colon, ensure 'mm' are present\n            if (tzSignPos > 0 && tzSignPos < currentLength - 1) { // Ensure sign is not the last char\n                int tzColonPos = sb.lastIndexOf(\":\", currentLength-1);\n                // Check if colon is exactly at hh:mm position\n                if (tzColonPos > tzSignPos && tzColonPos == currentLength - 3) {\n                    sb.deleteCharAt(tzColonPos);\n                    currentLength--; // Adjust length\n                }\n                // Check if minutes are missing, e.g. \"+01\" -> \"+0100\"\n                // After colon removal, \"+hh\" would have length 3 from sign pos. Need 5 for \"+hhmm\".\n                if (currentLength - tzSignPos == 3) {\n                     sb.append(\"00\");\n                     currentLength += 2;\n                }\n            }\n\n            // Normalize the time part (before the timezone offset)\n            // Target: HH:mm:ss.SSS\n             int tIndex = sb.lastIndexOf(\"T\", tzSignPos - 1);\n             if (tIndex >= 0) {\n                 int dotIndex = sb.lastIndexOf(\".\", tzSignPos - 1);\n                 if (dotIndex < tIndex) dotIndex = -1; // Dot must be after T\n\n                 int firstColon = sb.indexOf(\":\", tIndex + 1);\n                 int secondColon = (firstColon > 0) ? sb.indexOf(\":\", firstColon + 1) : -1;\n                  // Ensure second colon is before dot and before timezone sign\n                  if (secondColon > 0 && (dotIndex > 0 && secondColon > dotIndex)) secondColon = -1;\n                  if (secondColon >= tzSignPos) secondColon = -1;\n\n                 // Insert missing seconds \":00\"\n                 if (secondColon < 0 && firstColon > 0) { // Check firstColon ensures HH:mm exists\n                     int insertPos = (dotIndex > 0) ? dotIndex : tzSignPos; // Insert before dot or before timezone\n                     if (insertPos >= firstColon + 3) { // Ensure insert happens after HH:mm\n                         sb.insert(insertPos, \":00\");\n                         currentLength += 3; // Update length\n                         tzSignPos += 3; // Update timezone position relative to start\n                         if (dotIndex > 0) dotIndex += 3; // Adjust dot index if insertion was before it\n                     }\n                 }\n\n                 // Add/Pad milliseconds\n                 // Re-check dot index on potentially modified string builder\n                 dotIndex = sb.lastIndexOf(\".\", tzSignPos - 1);\n                 if (dotIndex < tIndex) dotIndex = -1; // Check again if dot is after T\n\n                 if (dotIndex < 0) { // Milliseconds part completely missing\n                     // Insert \".000\" before timezone, but only if seconds are present\n                     secondColon = sb.lastIndexOf(\":\", tzSignPos - 1); // Find last colon before timezone\n                     firstColon = sb.indexOf(\":\", tIndex + 1);\n                     if (secondColon > firstColon) { // Check if HH:mm:ss structure exists\n                         sb.insert(tzSignPos, \".000\"); // Insert before timezone sign\n                         currentLength += 4;\n                         // tzSignPos remains the same relative to end\n                     }\n                 } else { // Milliseconds part exists (.S, .SS, or .SSS...)\n                    // Pad partial milliseconds to exactly SSS\n                    int msLen = tzSignPos - (dotIndex + 1);\n                    if (msLen < 3) {\n                        for (int i = msLen; i < 3; ++i) {\n                             sb.insert(tzSignPos, '0'); // Insert '0's just before timezone sign\n                             currentLength++;\n                             // tzSignPos remains the same relative to end\n                        }\n                    } else if (msLen > 3) {\n                        // Truncate extra MS digits\n                        sb.delete(dotIndex + 4, tzSignPos);\n                        currentLength -= (msLen - 3);\n                        // tzSignPos needs update if we delete chars before it\n                        tzSignPos = dotIndex + 4; // New position for timezone sign\n                    }\n                 }\n             } // End if (tIndex >= 0) for time part normalization\n        }\n        // 4. Handle no explicit timezone suffix (treat as UTC -> add 'Z')\n        else {\n            // Original code behavior: treat as UTC, append 'Z' and use Z format\n            df = _formatISO8601_z; // Use the Z format\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n\n            // Normalize time part first, then append 'Z'\n            int endIndex = currentLength; // End of string before potentially appending Z\n            int tIndex = sb.lastIndexOf(\"T\", endIndex - 1);\n            boolean timePartExists = (tIndex >= 0);\n\n            if (timePartExists) {\n                int dotIndex = sb.lastIndexOf(\".\", endIndex - 1);\n                if (dotIndex < tIndex) dotIndex = -1; // Dot must be after T\n\n                int firstColon = sb.indexOf(\":\", tIndex + 1);\n                int secondColon = (firstColon > 0) ? sb.indexOf(\":\", firstColon + 1) : -1;\n                // Ensure second colon is before dot and before end of string\n                if (secondColon > 0 && (dotIndex > 0 && secondColon > dotIndex)) secondColon = -1;\n                if (secondColon >= endIndex) secondColon = -1;\n\n                // Insert missing seconds \":00\"\n                if (secondColon < 0 && firstColon > 0) { // Check firstColon ensures HH:mm exists\n                    int insertPos = (dotIndex > 0) ? dotIndex : endIndex; // Insert before dot or end\n                    if (insertPos >= firstColon + 3) { // Ensure insert happens after HH:mm\n                        sb.insert(insertPos, \":00\");\n                        currentLength += 3; // Update length\n                        endIndex += 3; // Update effective end index\n                        if (dotIndex > 0) dotIndex += 3; // Adjust dot index if insertion was before it\n                    }\n                }\n\n                // Add/Pad milliseconds\n                // Re-check dot index on potentially modified string builder\n                dotIndex = sb.lastIndexOf(\".\", endIndex - 1);\n                if (dotIndex < tIndex) dotIndex = -1; // Check again if dot is after T\n\n                if (dotIndex < 0) { // Milliseconds part completely missing\n                    // Insert \".000\" at the end, but only if seconds are present\n                    secondColon = sb.lastIndexOf(\":\", endIndex - 1); // Find last colon before end\n                    firstColon = sb.indexOf(\":\", tIndex + 1);\n                    if (secondColon > firstColon) { // Check if HH:mm:ss structure exists\n                        sb.insert(endIndex, \".000\");\n                        currentLength += 4;\n                    }\n                } else { // Milliseconds part exists (.S, .SS, or .SSS...)\n                     // Pad partial milliseconds to exactly SSS\n                    int msLen = endIndex - (dotIndex + 1);\n                     if (msLen < 3) {\n                        for (int i = msLen; i < 3; ++i) {\n                            sb.insert(endIndex, '0'); // Insert '0's at the end of time part\n                            currentLength++;\n                        }\n                    } else if (msLen > 3) {\n                        // Truncate extra MS digits\n                        sb.delete(dotIndex + 4, endIndex);\n                        currentLength -= (msLen - 3);\n                    }\n                }\n            } // End if (timePartExists)\n\n            // Append 'Z' if a time part existed, otherwise let parse fail on date-only string\n            if (timePartExists) {\n                 sb.append('Z');\n                 currentLength++;\n            } else {\n                // If no 'T', it should have been handled by plain date.\n                // If it wasn't (e.g. \"1997-07-16 \"), let the Z format fail parsing.\n            }\n        } // End else (no explicit timezone)\n\n        dateStr = sb.toString();\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}