{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* Jackson issue #148: accept variations, specifically, trailing\n         * timezone offset (+hh:mm)\n         * Jackson issue #334: also skip trailing chars if needed\n         * Jackson issue #570: support for missing/partial seconds, milliseconds\n         */\n        \n        int len = dateStr.length();\n        // Assumes _timezone, _locale, GMT, various DATE_FORMAT_* constants and\n        // _format* fields are available as in the original code.\n        TimeZone tz = _timezone; // tz defaults to configured TZ\n        DateFormat df;\n        String formatStr;\n        String possibleSuffix; // For Z or zone offset +hh:mm / +hhmm / +hh\n\n        // 0. Special case: plain date? (\"yyyy-MM-dd\")\n        // Let's also check that T isn't present, to be safer\n        if ((len <= 10 && Character.isDigit(dateStr.charAt(len-1))) && dateStr.indexOf('T') < 0) {\n            df = _formatPlain;\n            formatStr = DATE_FORMAT_STR_PLAIN;\n            if (df == null) {\n                // Use configured timezone for plain date by default\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, tz, _locale);\n            }\n            // Ensure timezone matches, although generally not critical for date-only\n             if (!df.getTimeZone().equals(tz)) {\n                 df = _cloneFormat(df, formatStr, tz, _locale);\n             }\n             // No manipulation needed, should parse directly\n            return df.parse(dateStr, pos);\n        }\n\n        // 1. Determine possible suffix ('Z', or timezone offset)\n        int timePartEnd = len; // Index AFTER the time part (exclusive)\n        boolean needsZConversion = false; // Does the target format use literal 'Z'?\n\n        char lastChar = dateStr.charAt(len-1);\n        if (lastChar == 'Z') {\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z; // yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, GMT, _locale);\n            }\n            // If parsing with 'Z', must use GMT timezone.\n            if (!df.getTimeZone().equals(GMT)) {\n                 // create new instance with GMT, needs cloning\n                 df = _cloneFormat(df, formatStr, GMT, _locale);\n             }\n            tz = GMT; // Use GMT for parsing Z suffix\n            timePartEnd--; // Skip 'Z' from the time part\n            needsZConversion = true; // Parsing using literal 'Z' format\n        } else if (hasTimeZone(dateStr)) {\n            // It has '+/-HH:mm', '+/-HHmm', or '+/-HH'\n            // Need to normalize the timezone offset part for parsing: remove colon, add missing minutes.\n            // Target format requires \"+HHmm\" or \"-HHmm\" (pattern char 'Z').\n            possibleSuffix = dateStr.substring(len - 6); // Try \"+/-HH:mm\" first\n            char sign = possibleSuffix.charAt(0);\n            // Check for \"+/-HH:mm\" format\n            if ((sign == '+' || sign == '-') && possibleSuffix.charAt(3) == ':') { \n                 // Remove colon:\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n                 len -= 1; // Shorter now\n                 timePartEnd = len - 5; // Recalculate end based on \"+/-HHmm\"\n            } else {\n                // Try \"+/-HHmm\" (length 5) or \"+/-HH\" (length 3)\n                possibleSuffix = dateStr.substring(len - 5); // Try \"+/-HHmm\"\n                sign = possibleSuffix.charAt(0);\n                 if ((sign == '+' || sign == '-') && Character.isDigit(possibleSuffix.charAt(1)) && Character.isDigit(possibleSuffix.charAt(2)) &&\n                        Character.isDigit(possibleSuffix.charAt(3)) && Character.isDigit(possibleSuffix.charAt(4))) {\n                      // Looks like \"+/-HHmm\", ok\n                      timePartEnd = len - 5;\n                 } else {\n                     // Assume \"+/-HH\" (length 3)\n                     possibleSuffix = dateStr.substring(len - 3); // \"+/-HH\"\n                     sign = possibleSuffix.charAt(0);\n                     if ((sign == '+' || sign == '-') && Character.isDigit(possibleSuffix.charAt(1)) && Character.isDigit(possibleSuffix.charAt(2))) {\n                         // Append \"00\" for minutes\n                         dateStr += \"00\";\n                         len += 2;\n                         timePartEnd = len - 5; // End index before the newly formed \"+/-HH00\"\n                     } else {\n                         // Invalid timezone, parser will fail later. Let's not modify structure.\n                         // timePartEnd remains 'len', assuming no recognizable suffix.\n                         timePartEnd = len;\n                     }\n                 }\n            }\n\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601; // yyyy-MM-dd'T'HH:mm:ss.SSSZ\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, tz, _locale); // Use configured timezone\n            }\n            // Ensure the formatter uses the configured timezone\n            if (!df.getTimeZone().equals(tz)) {\n                 df = _cloneFormat(df, formatStr, tz, _locale);\n            }\n            // tz remains the configured _timezone\n            // needsZConversion remains false (using offset Z pattern, not literal 'Z')\n        } else {\n             // Does not end in 'Z', does not have timezone offset (+/-....)\n             // Must be local date-time; append 'Z' and treat as UTC (per ISO-8601)\n             needsZConversion = true; // Append 'Z' and parse as UTC\n             \n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, GMT, _locale);\n             }\n             if (!df.getTimeZone().equals(GMT)) {\n                 df = _cloneFormat(df, formatStr, GMT, _locale);\n             }\n             tz = GMT; // Use GMT for parsing implicitly added Z suffix\n             // timePartEnd is already 'len'\n        }\n\n        // 2. Normalize the time part: add missing seconds, milliseconds\n        // Safety check: if timePartEnd is too small or negative, could indicate malformed string\n        if (timePartEnd <= 0) {\n             // Let subsequent parse fail with original string if structure is unexpected\n             return df.parse(dateStr, pos);\n        }\n        String timePart = dateStr.substring(0, timePartEnd);\n        int tIndex = timePart.indexOf('T');\n        // If T is missing, parsing will fail later, but avoid index errors here\n        if (tIndex < 0) {\n             // Let subsequent parse fail with original string\n             return df.parse(dateStr, pos); \n        }\n\n        // Find last colon and dot AFTER 'T'\n        int lastColon = timePart.lastIndexOf(':');\n        int dot = -1;\n        // Search for dot specifically in the presumed seconds/milliseconds part\n        // Start searching from end back towards T\n        for (int i = timePartEnd - 1; i > tIndex; --i) { \n            char d = timePart.charAt(i);\n            if (d == '.') {\n                dot = i;\n                break;\n            }\n            // Stop search if we hit non-digit (like ':') before finding dot\n            if (d < '0' || d > '9') break;\n        }\n\n        StringBuilder b = new StringBuilder(timePart);\n        // Check if seconds are missing (only one colon after T)\n        // Example: \"2023-01-01T10:15Z\", lastColon=15, tIndex=10. timePart.lastIndexOf(':', 14) = -1 (< tIndex). Add seconds.\n        if (lastColon > tIndex && timePart.lastIndexOf(':', lastColon - 1) < tIndex) {\n             // Only one colon found after 'T', means format is \"HH:mm\". Add \":00\"\n             b.append(\":00\"); // Append seconds\n             // If dot was also missing, add default milliseconds too\n             if (dot < 0) {\n                 b.append(\".000\");\n             }\n             // We fall through to millisecond check below, which handles the 'dot >= 0' case now\n        }\n        // Check milliseconds whether seconds were originally present or added\n        // Need to update dot position if we just added \".000\"\n        if (dot < 0 && b.length() > 4 && b.charAt(b.length()-4) == '.') {\n            dot = b.length() - 4;\n        }\n\n        if (dot >= 0) {\n            // Milliseconds exist (or were just added), ensure 3 digits\n            int millisEnd = b.length(); // Current end of the time part in builder\n            int millisLen = millisEnd - (dot + 1);\n            if (millisLen < 3) {\n                for (int i = millisLen; i < 3; ++i) {\n                    b.append('0'); // Pad with zeros\n                }\n            } else if (millisLen > 3) {\n                // Truncate to 3 digits for SSS pattern compatibility\n                b.setLength(dot + 1 + 3);\n            }\n        } else {\n            // Milliseconds still missing (means seconds were present, but no dot found). Add \".000\"\n             // This check ensures seconds structure exists:\n             if (lastColon > tIndex && timePart.lastIndexOf(':', lastColon - 1) > tIndex) {\n                 b.append(\".000\");\n             }\n        }\n        \n        // 3. Reconstruct and Parse\n        timePart = b.toString();\n        if (needsZConversion) {\n            // If original had Z or we added it implicitly\n            dateStr = timePart + 'Z';\n        } else {\n            // Append the original (but possibly normalized colon/minutes) timezone suffix\n            // dateStr currently holds the potentially modified version (colon removed, minutes added)\n             dateStr = timePart + dateStr.substring(timePartEnd);\n        }\n\n        return df.parse(dateStr, pos);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}