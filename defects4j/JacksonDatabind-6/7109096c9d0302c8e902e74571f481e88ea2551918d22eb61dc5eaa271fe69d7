{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n{\n    int len = dateStr.length();\n    DateFormat df;\n\n    // If it looks like a \"plain\" date (yyyy-MM-dd), use plain format:\n    if (len <= 10 && Character.isDigit(dateStr.charAt(len - 1))) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    // ---- Normalize the ISO-8601 string so that it always has hours, minutes,\n    // seconds and milliseconds. The expected pattern is:\n    // \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\"\n    // We'll break the string into three parts: date part (up to and including 'T'),\n    // time part (between 'T' and the start of the timezone), and timezone part.\n    String normalized;\n    int tPos = dateStr.indexOf('T');\n    if (tPos < 0) {\n        // Fallback: treat it as a plain date.\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n    String datePart = dateStr.substring(0, tPos + 1); // includes the 'T'\n    String timePart;\n    String tzPart = \"\";\n\n    // Determine if there is an explicit timezone indicator.\n    // We assume hasTimeZone(String) correctly detects a timezone.\n    if (hasTimeZone(dateStr)) {\n        // Check for terminal 'Z'\n        if (dateStr.charAt(len - 1) == 'Z') {\n            tzPart = \"Z\";\n            timePart = dateStr.substring(tPos + 1, len - 1);\n        } else {\n            // Look for '+' or '-' after the 'T'\n            int plusIndex = dateStr.indexOf('+', tPos);\n            int minusIndex = dateStr.indexOf('-', tPos);\n            int tzIndex;\n            if (plusIndex < 0) {\n                tzIndex = minusIndex;\n            } else if (minusIndex < 0) {\n                tzIndex = plusIndex;\n            } else {\n                tzIndex = Math.min(plusIndex, minusIndex);\n            }\n            // In case no explicit sign is found, default to entire remainder.\n            if (tzIndex < 0) {\n                tzIndex = len;\n            }\n            timePart = dateStr.substring(tPos + 1, tzIndex);\n            tzPart = dateStr.substring(tzIndex);\n            // Remove optional colon in timezone offset (e.g., \"+01:00\" -> \"+0100\")\n            if (tzPart.length() == 6 && tzPart.charAt(3) == ':') {\n                tzPart = tzPart.substring(0, 3) + tzPart.substring(4);\n            }\n        }\n    } else {\n        // No timezone provided. We'll treat it as GMT.\n        timePart = dateStr.substring(tPos + 1);\n        tzPart = \"Z\";\n    }\n\n    // ---- Normalize the time part.\n    // The allowed time parts are:\n    // \"HH:mm\" (missing seconds), \"HH:mm:ss\", or with fractional seconds.\n    // First, if the seconds field is missing, append \":00\".\n    int firstColon = timePart.indexOf(':');\n    int lastColon = timePart.lastIndexOf(':');\n    if (firstColon >= 0 && firstColon == lastColon) {\n        // Only one colon found, so we have \"HH:mm\" -> add missing seconds.\n        timePart = timePart + \":00\";\n    }\n\n    // Next, ensure there is a fractional part.\n    int dotIndex = timePart.indexOf('.');\n    if (dotIndex < 0) {\n        // No fraction: append \".000\"\n        timePart = timePart + \".000\";\n    } else {\n        // There is a fraction; pad or trim it to exactly 3 digits.\n        String frac = timePart.substring(dotIndex + 1);\n        if (frac.length() == 0) {\n            frac = \"000\";\n        } else if (frac.length() == 1) {\n            frac = frac + \"00\";\n        } else if (frac.length() == 2) {\n            frac = frac + \"0\";\n        } else if (frac.length() > 3) {\n            frac = frac.substring(0, 3);\n        }\n        timePart = timePart.substring(0, dotIndex + 1) + frac;\n    }\n\n    normalized = datePart + timePart + tzPart;\n\n    // ---- Choose the appropriate DateFormat\n    if (\"Z\".equals(tzPart)) {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n    } else {\n        df = _formatISO8601;\n        if (df == null) {\n            df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n    }\n    return df.parse(normalized, pos);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}