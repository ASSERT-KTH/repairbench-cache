{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    int len = dateStr.length();\n    DateFormat df;\n\n    // Short \"plain\" date (e.g. \"1997-07-16\")\n    if (len <= 10 && Character.isDigit(dateStr.charAt(len - 1))) {\n        df = _formatPlain;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    // First choose format based on timezone indicator.\n    if (dateStr.charAt(len - 1) == 'Z') {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n    } else if (hasTimeZone(dateStr)) {\n        // Remove the optional colon in timezone offset if present:\n        char tzChar = dateStr.charAt(len - 3);\n        if (tzChar == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.delete(len - 3, len - 2);\n            dateStr = sb.toString();\n        } else if (tzChar == '+' || tzChar == '-') {\n            // Missing minute information: pad with \"00\"\n            dateStr += \"00\";\n        }\n        df = _formatISO8601;\n        if (df == null) {\n            df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n        }\n    } else {\n        // No timezone indicator: assume local time, so append missing parts and default 'Z'\n        StringBuilder sb = new StringBuilder(dateStr);\n        int tIdx = dateStr.indexOf('T');\n        if (tIdx != -1) {\n            int timeLen = len - tIdx - 1;\n            // If only hours and minutes (e.g. \"19:20\"), then append seconds.\n            if (timeLen == 5) {\n                sb.append(\":00\");\n            }\n            sb.append(\".000\");\n        }\n        sb.append('Z');\n        dateStr = sb.toString();\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n    }\n\n    // Normalize the time portion to always be in \"HH:mm:ss.SSS\" form.\n    int tIndex = dateStr.indexOf('T');\n    if (tIndex != -1) {\n        int tzPos;\n        if (dateStr.endsWith(\"Z\")) {\n            tzPos = dateStr.length() - 1;\n        } else {\n            int plusIndex = dateStr.indexOf('+', tIndex);\n            int minusIndex = dateStr.indexOf('-', tIndex);\n            tzPos = (plusIndex != -1) ? plusIndex : (minusIndex != -1 ? minusIndex : dateStr.length());\n        }\n        // Extract the time part between the 'T' and the start of the timezone.\n        String timePart = dateStr.substring(tIndex + 1, tzPos);\n        // If only hours and minutes are present (e.g. \"19:20\"), add seconds.\n        int colonCount = 0;\n        for (int i = 0; i < timePart.length(); i++) {\n            if (timePart.charAt(i) == ':') {\n                colonCount++;\n            }\n        }\n        if (colonCount == 1) {\n            timePart = timePart + \":00\";\n        }\n        // Normalize (or insert) the fractional (millisecond) part.\n        int dotIndex = timePart.indexOf('.');\n        if (dotIndex >= 0) {\n            String secsPart = timePart.substring(0, dotIndex);\n            String fraction = timePart.substring(dotIndex + 1);\n            if (fraction.length() < 3) {\n                StringBuilder fracSB = new StringBuilder(fraction);\n                while (fracSB.length() < 3) {\n                    fracSB.append('0');\n                }\n                fraction = fracSB.toString();\n            } else if (fraction.length() > 3) {\n                fraction = fraction.substring(0, 3);\n            }\n            timePart = secsPart + \".\" + fraction;\n        } else {\n            // No fractional part: if timePart has exactly \"HH:mm:ss\", append \".000\"\n            if (timePart.length() == 8) {\n                timePart = timePart + \".000\";\n            }\n        }\n        // Reassemble the full date string with the normalized time part.\n        dateStr = dateStr.substring(0, tIndex + 1) + timePart + dateStr.substring(tzPos);\n    }\n    return df.parse(dateStr, pos);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}