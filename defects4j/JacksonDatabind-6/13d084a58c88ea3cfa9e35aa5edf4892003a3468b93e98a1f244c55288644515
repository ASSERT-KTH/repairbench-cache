{
    "generation": "    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n    {\n        /* 21-May-2009, tatu: DateFormat has very strict handling of\n         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n         */\n\n        int len = dateStr.length();\n        char c = dateStr.charAt(len-1);\n        DateFormat df;\n\n        // [JACKSON-200]: need to support \"plain\" date...\n        if (len <= 10 && Character.isDigit(c)) { // Date only, e.g. \"YYYY-MM-DD\"\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        } else if (c == 'Z') { // Zulu timezone\n            // [JACKSON-334]: may be missing milliseconds or seconds...\n            int t_idx = dateStr.lastIndexOf('T');\n            if (t_idx > 0) { // Has time part (e.g., \"YYYY-MM-DDTHH:MMZ\", \"YYYY-MM-DDTHH:MM:SSZ\")\n                // 'Z' is the last character, so insertion point is before 'Z'.\n                dateStr = patchTimePart(dateStr, t_idx, len - 1);\n            }\n            df = _formatISO8601_z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n            }\n        } else {\n            // Let's see if we have timezone indicator or not...\n            if (hasTimeZone(dateStr)) {\n                // First, normalize timezone part to `+/-HHMM`\n                // Current string length, can change.\n                int currentLen = dateStr.length();\n                char c3 = dateStr.charAt(currentLen - 3); // Char at ...MM_ (or ...HH_)\n                // Handle `+HH:MM` -> `+HHMM`\n                if (c3 == ':') {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.delete(currentLen - 3, currentLen - 2); // remove ':'\n                    dateStr = sb.toString();\n                } else if (c3 == '+' || c3 == '-') { // Handle `+HH` -> `+HH00`\n                    // If it is `+/-HH`, append `00`.\n                    dateStr += \"00\";\n                }\n                \n                // Now, `dateStr` has timezone in `+/-HHMM` format (5 chars long).\n                int t_idx = dateStr.lastIndexOf('T');\n                if (t_idx > 0) { // Has time part\n                    // Insertion point for patching is before the timezone offset\n                    dateStr = patchTimePart(dateStr, t_idx, dateStr.length() - 5);\n                }\n\n                df = _formatISO8601;\n                if (_formatISO8601 == null) {\n                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                }\n            } else { // No explicit timezone indicator (e.g., \"YYYY-MM-DDTHH:MM:SS\")\n                // Needs to be patched and then 'Z' appended as a default timezone.\n                int t_idx = dateStr.lastIndexOf('T');\n                if (t_idx > 0) { // Has time part\n                    // Insertion point is the end of the current string.\n                    dateStr = patchTimePart(dateStr, t_idx, dateStr.length());\n                }\n                // Finally, append 'Z'\n                dateStr += 'Z';\n                df = _formatISO8601_z;\n                if (df == null) {\n                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                            _timezone, _locale);\n                }\n            }\n        }\n        return df.parse(dateStr, pos);\n    }\n\n    // Helper method to patch missing seconds or milliseconds to match 'ss.SSS' format\n    // `t_idx`: index of 'T' in the date string.\n    // `insertionPoint`: The index where new characters should be inserted (e.g., start of TZ or end of string).\n    private String patchTimePart(String dateStr, int t_idx, int insertionPoint) {\n        StringBuilder sb = new StringBuilder(dateStr);\n        int originalSbLen = sb.length(); // Original length before any modifications in this method\n\n        // Get the time part string (from 'T' + 1 up to `insertionPoint`)\n        // This is `HH:MM`, `HH:MM:SS`, `HH:MM:SS.S`, etc.\n        String timeString = sb.substring(t_idx + 1, insertionPoint);\n        \n        // Check for milliseconds: find '.' within the time part\n        int dotIdxInTime = timeString.indexOf('.');\n        \n        if (dotIdxInTime >= 0) { // Has a milliseconds part (e.g., \".S\", \".SS\")\n            // `dotIdxInTime + 1` is the start of the milliseconds digits within `timeString`.\n            // `timeString.length() - (dotIdxInTime + 1)` is the actual number of milliseconds digits.\n            int actualMsLen = timeString.length() - (dotIdxInTime + 1);\n            if (actualMsLen < 3) {\n                // Pad with '0's to make it 3 digits (e.g., \".6\" -> \".600\")\n                for (int i = 0; i < (3 - actualMsLen); ++i) {\n                    sb.insert(insertionPoint, '0');\n                }\n            }\n        } else { // No milliseconds part (e.g., \"HH:MM\", \"HH:MM:SS\")\n            // Check if seconds are missing (e.g., \"HH:MM\" instead of \"HH:MM:SS\")\n            int lastColonIdxInTime = timeString.lastIndexOf(':');\n            if (lastColonIdxInTime >= 0) { // Found a colon in time part (e.g., in \"HH:MM\" or \"HH:MM:SS\")\n                // Length of characters after last colon in `timeString`:\n                // If it's \"HH:MM\", this length is 2 (for \"MM\").\n                // If it's \"HH:MM:SS\", this length is 2 (for \"SS\").\n                // If it's \"HH:MM:SS.SSS\", this length is > 2 (handled by dotIdxInTime).\n                if (timeString.length() - (lastColonIdxInTime + 1) == 2) { // Indicates format like \"HH:MM\"\n                    sb.insert(insertionPoint, \":00\"); // Insert missing seconds (`:00`)\n                }\n            }\n            // Always add milliseconds part if not present.\n            // Adjust insertion point if seconds were just added.\n            int currentInsertionPoint = insertionPoint + (sb.length() - originalSbLen);\n            sb.insert(currentInsertionPoint, \".000\"); // Insert \".000\"\n        }\n        return sb.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}