{
    "generation": "protected Date parseAsISO8601(String dateStr, ParsePosition pos) {\n    /* DateFormat has very strict handling of timezone modifiers for ISO-8601.\n     * So we need to do some scrubbing.\n     */\n\n    /* Check if milliseconds are present and need padding */\n    boolean hasMillis = dateStr.contains(\".0\");\n    if (hasMillis) {\n        int dotIndex = dateStr.indexOf('.');\n        int millisPartLength = dateStr.length() - dotIndex - 1;\n        switch (millisPartLength) {\n            case 1:\n                dateStr = dateStr.substring(0, dotIndex + 2) + \"00\";\n                break;\n            case 2:\n                dateStr = dateStr.substring(0, dotIndex + 3) + \"0\";\n                break;\n        }\n    }\n\n    DateFormat df;\n    if (dateStr.endsWith(\"Z\")) {\n        df = _formatISO8601_z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n    } else {\n        if (hasTimeZone(dateStr)) {\n            df = _formatISO8601;\n            if (df == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            df = _formatPlain;\n            if (df == null) {\n                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n            }\n        }\n    }\n    return df.parse(dateStr, pos);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}