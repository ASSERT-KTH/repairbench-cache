{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            // No vertices were found, the region is either empty or full.\n            // Check a point to determine which case it is.\n            // We use the checkPoint method which is robust regarding the underlying BSP tree structure.\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            // PolygonsSet source code implies checkPoint is available via 'this'\n            // Use Vector2D.ZERO as the test point\n            if (checkPoint(Vector2D.ZERO) == Location.INSIDE) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                // the instance is empty\n                setSize(0);\n                setBarycenter(Vector2D.NaN); // Barycenter is undefined for an empty set\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape using Green's theorem\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                // The loop vertices are oriented counter-clockwise for the exterior boundary,\n                // and clockwise for the holes. The Green's theorem formulas below compute\n                // the signed area and moments assuming counter-clockwise orientation contributes positively.\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    // Formula based on Green's theorem for area and moments\n                    // 2 * Area = sum(x0 * y1 - y0 * x1)\n                    // 6 * Area * x_barycenter = sum((x0 * y1 - y0 * x1) * (x0 + x1))\n                    // 6 * Area * y_barycenter = sum((x0 * y1 - y0 * x1) * (y0 + y1))\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            // The signed area is sum / 2.\n            // A positive area corresponds to a finite region defined counter-clockwise.\n            // A negative area indicates the vertices effectively define the exterior region\n            // (e.g., clockwise outer boundary or inconsistent hole orientation).\n            if (sum < 0) {\n                // The polygon orientation is clockwise for the exterior boundary,\n                // or the total area calculation resulted negative (e.g., hole larger than outer loop).\n                // This indicates the finite area part is \"outside\" the region definition.\n                // The region defined by the BSP tree is infinite.\n                // See http://mathworld.wolfram.com/PolygonArea.html about signed area.\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                // The polygon has a finite, non-negative size.\n                setSize(sum / 2.0);\n                // Avoid division by zero if sum is zero (degenerate polygon like a line or point).\n                if (sum == 0) {\n                    // Handle degenerate case: size is 0. Barycenter is undefined.\n                    setBarycenter(Vector2D.NaN);\n                } else {\n                    // Barycenter coordinates: x_b = sumX / (3 * sum), y_b = sumY / (3 * sum)\n                    setBarycenter(new Vector2D(sumX / (3.0 * sum), sumY / (3.0 * sum)));\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}