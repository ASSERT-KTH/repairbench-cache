{
    "generation": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    String data = c.getData();\n\n                    // Handle the spec rule: \"If the next token is a U+000A LINE FEED (LF) character token,\n                    // then ignore that token and move on to the next one.\" for <pre> and <listing> start tags.\n                    // This check is placed here as a workaround, assuming this Character token is the \"next token\".\n                    // It checks if the current element is <pre> or <listing> and if it's the very first\n                    // content being added (childNodeSize == 0). This might be inaccurate if whitespace nodes\n                    // are inserted before the newline token.\n                    Element current = tb.currentElement(); // The element nodes are being inserted into.\n                    // Check current != null to avoid NullPointerException in fragment parsing scenarios.\n                    if (current != null && data.length() > 0 && data.charAt(0) == '\\n' && current.childNodeSize() == 0) {\n                        // Check if the node receiving content is <pre> or <listing>.\n                        if (current.nodeName().equals(\"pre\") || current.nodeName().equals(\"listing\")) {\n                            // If the entire token is just the newline, ignore the token.\n                            if (data.length() == 1) {\n                                return true; // Token ignored.\n                            } else {\n                                // If the token starts with a newline but contains other characters,\n                                // remove the leading newline from the token's data.\n                                // Assumes the Token object's data can be modified (Token.Character#data(String)).\n                                c.data(data.substring(1));\n                                // Update local variable 'data' for subsequent checks, as token's data has changed.\n                                data = c.getData();\n                            }\n                        }\n                        // Note: A similar rule applies to <textarea>. However, <textarea> transitions to the Text state upon insertion.\n                        // That state has different character handling. The correct fix requires a flag in HtmlTreeBuilder\n                        // set during <pre>/<listing>/<textarea> start tag processing and checked at the beginning of character token processing\n                        // across relevant states (InBody, Text). This workaround only fixes it for <pre>/<listing>.\n                    }\n\n                    // Original character handling, now using the potentially modified 'data' / 'c'\n                    if (data.equals(nullString)) {\n                        // todo confirm that check - null character detection\n                        tb.error(this);\n                        return false; // ignore char\n                    } else if (tb.framesetOk() && isWhitespace(data)) { // Use isWhitespace(String) as data may have changed\n                        tb.reconstructFormattingElements();\n                        tb.insert(c); // Insert the potentially modified token\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c); // Insert the potentially modified token\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    // todo - refactor to a switch statement\n                    String name = startTag.normalName();\n                    if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.processEndTag(\"a\");\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"span\")) {\n                        // same as final else, but short circuits lots of checks\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.processEndTag(\"li\");\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        if (tb.getStack().isEmpty()) return false; // Ignore if stack is empty (fragment case?)\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        // ** The correct fix would involve setting a flag here for the Character case to check **\n                        // ** e.g., tb.setSkipNextNewline(true);                                             **\n                        // The workaround is implemented in the Character case for now.\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) { // Allow nested forms in fragments\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true); // Insert and set form element pointer\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            // Stop search if semantic block element found, unless it's a <p> inside dd/dt scope? Spec is specific here.\n                            // Spec: \"special category\" elements break; <p> does not if not in \"li breakers\" constants? Check constants.\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers)) // Using LiBreakers here seems potentially wrong, should be DdDt context. Check spec.\n                                break; // Correct check: stop if special and not 'address', 'div', 'p'. This seems ok.\n                        }\n                        if (tb.inButtonScope(\"p\")) { // Close P if in button scope\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.processEndTag(\"button\");\n                            return tb.process(startTag); // Reprocess the start tag\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.processEndTag(\"nobr\"); // Run adoption agency algorithm for nobr\n                            // Need to reconstruct again after potential changes by AAA?\n                            tb.reconstructFormattingElements(); // Redundant? Maybe not if AAA modified stack significantly. Let's keep it.\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                        // Self-closing acknowledged by insertEmpty implicitly? Check tb.insertEmpty. Assume yes.\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                        // Acknowledge self-closing flag? These tags are void elements. insertEmpty should handle.\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        if (tb.getFromStack(\"svg\") == null)\n                            return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n                        else\n                            tb.insert(startTag); // Treat as SVG <image> element\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) // Check fragment parsing context\n                            return false; // Ignore if form already open (unless fragment parsing)\n\n                        // Acknowledge self-closing flag? Spec doesn't mention. Assume not needed.\n                        tb.tokeniser.acknowledgeSelfClosingFlag(); // It IS often self-closed, acknowledge it.\n\n                        tb.processStartTag(\"form\");\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            if (form != null) // Should exist unless fragment parsing form error occurred\n                                form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.processStartTag(\"hr\");\n                        tb.processStartTag(\"label\");\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character().data(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs)) // Filter attributes\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\"); // Add name attribute\n                        tb.processStartTag(\"input\", inputAttribs); // Process <input>\n                        tb.processEndTag(\"label\"); // Process </label>\n                        tb.processStartTag(\"hr\"); // Process second <hr>\n                        tb.processEndTag(\"form\"); // Process </form>\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // ** The correct fix would involve setting a flag here for the Text state to check **\n                        // ** e.g., tb.setSkipNextNewline(true);                                            **\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) { // optgroup, option\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.processEndTag(\"option\"); // Close previous option if current is option\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) { // rp, rt\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include ruby\n                            }\n                            tb.insert(startTag);\n                        } else {\n                            // Treat as normal tag if not in ruby scope? Seems underspecified, assume generic handler.\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // Adjust attributes, insert element, switch to foreign content mode.\n                        // TODO: Full MathML foreign content handling. Basic insertion for now.\n                        tb.insert(startTag);\n                        if (startTag.isSelfClosing()) tb.tokeniser.acknowledgeSelfClosingFlag(); // Acknowledge but doesn't auto-pop in HTML content model. Need foreign content logic.\n                        // tb.pop(); // Don't pop, wait for end tag or implied close.\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // Adjust attributes, insert element, switch to foreign content mode.\n                        // TODO: Full SVG foreign content handling. Basic insertion for now.\n                        tb.insert(startTag);\n                         if (startTag.isSelfClosing()) tb.tokeniser.acknowledgeSelfClosingFlag(); // Acknowledge but doesn't auto-pop in HTML content model. Need foreign content logic.\n                        // tb.pop(); // Don't pop, wait for end tag or implied close.\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) { // caption, col, colgroup, frame, head, tbody, td, tfoot, th, thead, tr\n                        tb.error(this);\n                        return false; // Ignore these tags in body\n                    } else { // Any other start tag\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        // Acknowledge self-closing flag for unknown tags? Seems reasonable.\n                         if (startTag.isSelfClosing()) tb.tokeniser.acknowledgeSelfClosingFlag();\n                    }\n                    break; // End StartTag\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName();\n                    if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                         // Loop limit prevents runaway in deeply nested cases.\n                         for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null) // Element not in AFE list\n                                return anyOtherEndTag(t, tb); // Process as generic end tag\n                            else if (!tb.onStack(formatEl)) { // In AFE list but not on stack\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true; // Handled (by removing from AFE)\n                            } else if (!tb.inScope(formatEl.nodeName())) { // Not in scope\n                                tb.error(this);\n                                return false; // Ignore token\n                            }\n                            // Element is in AFE, on stack, and in scope. Proceed with AAA.\n                            else if (tb.currentElement() != formatEl) {\n                                // Error if current node isn't the formatting element itself?\n                                // Spec doesn't mandate error *here*. AAA handles mismatches.\n                                // tb.error(this); // Let's omit this specific error check.\n                            }\n\n                            // Find furthest block and common ancestor (node below formatEl)\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            // Search downwards from top of stack (index size-1) to find formatEl, then continue down to find furthestBlock.\n                            boolean seenFormattingElement = false;\n                            ArrayList<Element> stack = tb.getStack();\n                            final int stackSize = stack.size();\n                            Element formatElPredecessor = null; // Element immediately below formatEl on stack\n                            for (int si = stackSize - 1; si >= 0; si--) { // Iterate stack from top down\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    if ((si - 1) >= 0) formatElPredecessor = stack.get(si - 1);\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el; // Found furthest block below formatEl\n                                    break;\n                                }\n                            }\n                            commonAncestor = formatElPredecessor; // The node below formatEl is the common ancestor for append later\n\n                            if (furthestBlock == null) { // No block node found below formatEl in stack\n                                // Pop up to and including formatEl, remove from AFE.\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true; // Handled\n                            }\n\n                            // Check if furthest block is still on stack (paranoia check, should be true)\n                            if (!tb.onStack(furthestBlock)) {\n                                tb.error(this); // Should not happen if stack search is correct\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true; // Abort and remove AFE entry\n                            }\n\n                            // Inner loop: Re-parent nodes between furthest block and format element.\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            // The loop limit (3) is somewhat arbitrary, check spec basis. It prevents excessive reconstruction.\n                            for (int j = 0; j < 3; j++) {\n                                // Node above node in stack (lower index in ArrayList)\n                                int nodeIndex = tb.getStack().indexOf(node);\n                                if (nodeIndex <= 0) break; // Should not happen if formatEl was found above root\n                                Element nextNode = tb.getStack().get(nodeIndex - 1);\n                                node = nextNode; // Move up the stack (down in index)\n\n                                if (!tb.isInActiveFormattingElements(node)) { // If node isn't in AFE, remove from stack and skip\n                                    tb.removeFromStack(node);\n                                    // 'node' reference remains pointing to the element *above* the removed one for the next iteration.\n                                    continue;\n                                } else if (node == formatEl) { // Reached the formatting element itself\n                                     break; // Exit inner loop\n                                }\n\n                                // Replace node with a clone in AFE and stack\n                                Element replacement = new Element(tb.settings.normalizeTag(node.nodeName()), tb.getBaseUri()); // Use settings for case\n                                replacement.attributes().addAll(node.attributes()); // Copy attributes\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement; // Work with the replacement\n\n                                // Reparent last node under the new node\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node; // Update for next iteration\n                            } // End inner loop\n\n                            // Insert the reconstructed chain (lastNode)\n                            if (commonAncestor == null) { // Should only happen if formatEl was root or just below? Error condition.\n                                tb.error(this); // Or handle fragment case?\n                                // Fallback: append to current root? Seems wrong. Abort?\n                                // Let's assume commonAncestor is valid based on checks.\n                            }\n                            // Foster parent if common ancestor requires it\n                            else if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else { // Append to common ancestor otherwise\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            // Create adopter element (clone of formatEl)\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n\n                            // Move children of furthest block under adopter\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[0]); // Clone for safe iteration\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // Reparents child\n                            }\n                            furthestBlock.appendChild(adopter); // Append adopter to furthest block\n\n                            // Cleanup AFE and stack\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            tb.removeFromStack(formatEl);\n                            // Insert adopter into stack below furthest block (higher index)\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n\n                        } // End outer loop (AAA)\n\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close for this element name in scope\n                            tb.error(this);\n                            return false; // ignore the token\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this); // Current element mismatch after implied tags\n                            tb.popStackToClose(name); // Pop up to and including name\n                        }\n                    } else if (name.equals(\"span\")) {\n                        // Spec treats span like any other end tag for closing purposes.\n                        return anyOtherEndTag(t, tb); // Delegate to generic end tag handler\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) { // Use list item scope\n                            tb.error(this);\n                            return false; // ignore\n                        } else {\n                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at <li>\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name); // Close the <li>\n                        }\n                    } else if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false; // ignore\n                        } else {\n                            // Check stack contents below body for disallowed elements\n                            boolean ok = true;\n                            ArrayList<Element> stack = tb.getStack();\n                             // Iterate from element above body upwards to root\n                             for (int i = stack.indexOf(tb.getStackBodyElement()) - 1; i >=0; i--) { // Find body index, check above it\n                                 if (i < 0) break; // Should find body if inScope passed\n                                 Element el = stack.get(i);\n                                 if (el.nodeName().equals(\"html\")) break; // Stop at html root\n                                 if (!StringUtil.inSorted(el.nodeName(), Constants.InBodyEndBodyStack)) {\n                                      ok = false; break;\n                                  }\n                              }\n                             if (!ok) {\n                                 tb.error(this);\n                                 // Continue processing anyway\n                             }\n                             tb.transition(AfterBody);\n                         }\n                    } else if (name.equals(\"html\")) {\n                        // Process as if </body> was seen, then reprocess </html> if </body> wasn't ignored.\n                        boolean bodyProcessed = tb.processEndTag(\"body\"); // Try processing </body>\n                        if (bodyProcessed)\n                            return tb.process(endTag); // Reprocess </html> in the new state (AfterBody)\n                        else\n                            return false; // If </body> was ignored, ignore </html> too.\n                    } else if (name.equals(\"form\")) {\n                        if (!tb.isFragmentParsing()) { // Only apply form element logic if not fragment parsing\n                            Element currentForm = tb.getFormElement();\n                            tb.setFormElement(null); // Always clear the pointer\n\n                            if (currentForm == null || !tb.inScope(name)) {\n                                tb.error(this);\n                                return false; // Ignore token if no form element context or not in scope\n                            } else {\n                                tb.generateImpliedEndTags();\n                                if (!tb.currentElement().nodeName().equals(name))\n                                    tb.error(this);\n                                // Remove the specific currentForm element instance from stack.\n                                if (tb.removeFromStack(currentForm)) { // Ensure removal happened\n                                    // If form is removed, need to check if template element needs popping? No, spec for </template> handles that.\n                                } else {\n                                    // Error: currentForm was not on stack? Should not happen if inScope passed.\n                                    tb.error(this);\n                                }\n                            }\n                        } else { // Fragment parsing: treat like any other end tag?\n                             return anyOtherEndTag(t, tb); // Or specific scope check + close? Let's use generic close for fragments.\n                         }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) { // Use button scope\n                            tb.error(this);\n                            tb.processStartTag(name); // Insert an empty <p>\n                            return tb.process(endTag); // Reprocess the </p> tag\n                        } else {\n                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at <p>\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name); // Close the <p>\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) { // Use standard scope\n                            tb.error(this);\n                            return false; // ignore\n                        } else {\n                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at dd/dt\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name); // Close the dd/dt\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) { // Check if *any* heading is in scope\n                            tb.error(this);\n                            return false; // ignore\n                        } else {\n                            tb.generateImpliedEndTags(name); // Generate implied tags stopping at the specific heading level\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings); // Pop up to and including *any* heading element.\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // Spec doesn't define sarcasm tag. Treat as \"any other end tag\".\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) { // End tags: </applet>, </embed>, </object>, </marquee>\n                         // Corrected logic:\n                         if (!tb.inScope(name)) { // Check if the specific tag is in scope\n                             tb.error(this);\n                             return false; // Ignore the token\n                         } else {\n                             // Element is in scope\n                             tb.generateImpliedEndTags(); // Generate implied end tags generally\n                             if (!tb.currentElement().nodeName().equals(name)) {\n                                 tb.error(this);\n                             }\n                             tb.popStackToClose(name); // Pop up to and including the element\n                             tb.clearFormattingElementsToLastMarker(); // Clear AFE list back to the last marker\n                         }\n                    } else if (name.equals(\"br\")) { // Specific handler for </br>\n                        tb.error(this);\n                        tb.processStartTag(\"br\"); // Process as <br> start tag\n                        return false; // Ignore the </br> end tag token itself.\n                    } else { // Any other end tag not explicitly handled above\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break; // End EndTag case\n                case EOF:\n                    // Check stack for disallowed elements\n                    ArrayList<Element> stack = tb.getStack();\n                     for (int i = stack.size() - 1; i >= 0; i--) { // Iterate from top down\n                         Element el = stack.get(i);\n                         if (el.nodeName().equals(\"html\")) break; // Stop at root (html is allowed)\n                         if (el.nodeName().equals(\"body\")) continue; // body is allowed, check above it\n                         if (el.nodeName().equals(\"template\")) continue; // template is allowed\n                         // Check if element is one of the allowed types at EOF\n                         if (!StringUtil.inSorted(el.nodeName(), Constants.InBodyEndEofStack)) {\n                              tb.error(this);\n                              // Don't break check, report all errors? Spec implies just report error.\n                              // Let's break after first error found.\n                              break;\n                          }\n                      }\n                    // Stop parsing handled by main loop detecting EOF.\n                    break; // End EOF case\n            } // End switch\n            return true; // Indicate token was handled (unless false returned explicitly)\n        }\n\n        // Helper method to check if string is whitespace (assuming it exists in context or StringUtil)\n        // Added here for completeness if it wasn't implicitly available.\n        private boolean isWhitespace(String data) {\n             return StringUtil.isBlank(data);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}