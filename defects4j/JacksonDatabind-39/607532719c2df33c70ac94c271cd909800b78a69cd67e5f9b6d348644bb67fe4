{
    "generation": "    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n        //    special unfortunately\n        //\n        // This deserializer is called for the *value* of a polymorphic type.\n        // Normally, `p` should be at `START_OBJECT`.\n        // However, if the type ID property has already been consumed\n        // (e.g., {\"type\":\"unknown\", \"prop\":\"value\"}), the parser may be\n        // at the next field name (`prop`) or even `END_OBJECT`.\n        // We need to consume the remaining tokens of the unknown object until `END_OBJECT`.\n\n        JsonToken t = p.currentToken();\n\n        // If the current token is the start of an object or array, skip the whole thing.\n        // This is the most common and ideal scenario for a value deserializer.\n        if (t == JsonToken.START_OBJECT || t == JsonToken.START_ARRAY) {\n            p.skipChildren(); // Skips the entire structure and moves parser to END_OBJECT/END_ARRAY\n        } else {\n            // If the parser is not at START_OBJECT/ARRAY, it means we are already\n            // inside the object, likely after the type ID field has been processed,\n            // or the value itself is a scalar. We need to consume remaining tokens.\n            \n            // Loop until we find the end of the current object (the polymorphic value)\n            // or the end of the stream.\n            while (t != JsonToken.END_OBJECT && t != null) {\n                if (t == JsonToken.FIELD_NAME) {\n                    // If it's a FIELD_NAME, we need to advance to its value\n                    // and then skip that value.\n                    t = p.nextToken(); // Advance to the value token\n                    \n                    // After nextToken(), `t` is now the token for the VALUE.\n                    // If the value is a structured type (object or array), skip its children.\n                    if (t == JsonToken.START_OBJECT || t == JsonToken.START_ARRAY) {\n                        p.skipChildren(); // Skips the whole structure and moves parser to END_OBJECT/END_ARRAY\n                    } else if (t != null) { // For scalar values (String, Number, Boolean, Null)\n                        // Consume the scalar value token. `skipChildren()` does not do this for scalars.\n                        // After this `nextToken()`, `p` will be at the next token (e.g., next FIELD_NAME or END_OBJECT).\n                        p.nextToken();\n                    }\n                } else if (t != null) {\n                    // This handles scalar values if the *initial* token was a scalar,\n                    // or if it's an unexpected token in the loop that wasn't a FIELD_NAME or START_STRUCT.\n                    p.nextToken(); // Consume current scalar token and advance\n                }\n                t = p.currentToken(); // Get next token for loop condition\n            }\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}