{
    "generation": "    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n        //    special unfortunately\n        // The original code `p.skipChildren()` is problematic if the parser is currently\n        // at a FIELD_NAME token when this deserializer is called.\n        // JsonParser.skipChildren() skips only the FIELD_NAME token itself, not its associated value.\n        // In the context of `AsPropertyTypeDeserializer`, after the type property\n        // (e.g., 'type':'xevent') is consumed, the parser is left at the next FIELD_NAME\n        // (e.g., 'location').\n        // To correctly skip the entire value associated with the unknown type, we must\n        // first advance the parser past the FIELD_NAME to its value, and then skip that value.\n\n        JsonToken t = p.getCurrentToken();\n\n        // If the current token is a FIELD_NAME, it means the type property has been consumed\n        // by the TypeDeserializer, and 'p' is now positioned at the next field name within\n        // the object of the unknown type. We must advance past this field name to its value.\n        if (t == JsonToken.FIELD_NAME) {\n            // Advance to the value token associated with this FIELD_NAME\n            t = p.nextToken();\n        }\n\n        // Now 'p' should be at the actual start of the value to be skipped\n        // (e.g., START_OBJECT, START_ARRAY, or a scalar value).\n        // JsonParser.skipChildren() correctly handles skipping the entire value from this point.\n        p.skipChildren();\n\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}