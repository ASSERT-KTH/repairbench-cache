{
    "generation": "/**\n * Computes the follow() node of a given node and its parent. There is a side\n * effect when calling this function. If this function computed an edge that\n * exits a FINALLY, it'll attempt to connect the fromNode to the outer FINALLY\n * according to the finallyMap.\n *\n * <p>The idea is that almost every node\u2019s \u201cfall\u2010through\u201d is simply its immediate\n * sibling but when control escapes constructs (if, try/catch/finally, loops, etc)\n * we have to \u201cclimb\u201d the AST. In the case of a try, if there is a finally block, then\n * control always goes to that finally block (or, if we are already in the finally,\n * then to any \u201couter\u201d finally handlers).</p>\n *\n * @param fromNode The original source node since {@code node} is changed\n *        during recursion.\n * @param node The node that follow() should compute.\n */\nprivate static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  Node parent = node.getParent();\n  // When the parent is null, a function node, or we have reached the root,\n  // then control returns to a symbolic return node (represented by null).\n  if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  switch (parent.getType()) {\n    case Token.IF:\n      // For if-statements, the follow of any branch is what follows the if.\n      return computeFollowNode(fromNode, parent, cfa);\n\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      // For case/default blocks, if there is a next case then its first executable\n      // statement is the follow; otherwise, climb up the AST.\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n      // Unreachable but required by the language.\n      // break;\n\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        // For a standard FOR loop, the condition/expression part follows.\n        return parent.getFirstChild().getNext().getNext();\n      }\n\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n\n    case Token.TRY:\n      // If the try statement has a finally clause, then regardless of whether\n      // we are leaving the try block or the catch block, control must flow to the\n      // finally block. Furthermore, when leaving the finally block itself we need\n      // to add cross edges to any outer FINALLY handlers.\n      if (NodeUtil.hasFinally(parent)) {\n        if (node != parent.getLastChild()) {\n          // We are exiting either the try or the catch part.\n          // Create an edge from the abrupt node (fromNode) into the finally block.\n          // For a throw (or for some conditions in a finally), we want the branch\n          // to be exceptional.\n          Branch branchType = (fromNode.getType() == Token.THROW || fromNode.getType() == Token.IF)\n              ? Branch.ON_EX : Branch.UNCOND;\n          if (cfa != null) {\n            cfa.createEdge(fromNode, branchType, parent.getLastChild());\n          }\n          // The immediate follow is the finally block.\n          return computeFallThrough(parent.getLastChild());\n        } else {\n          // We are exiting from the finally block.\n          // Regardless of the type of fromNode, once leaving a finally we want to\n          // connect to any outer FINALLY handlers via an exceptional (ON_EX) edge.\n          Branch branchType = Branch.ON_EX;\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, branchType, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else {\n        // No finally clause present; simply climb the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  // For most constructs the follow node is just the next sibling,\n  // unless that sibling is a function (control does not fall into functions).\n  Node nextSibling = node.getNext();\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    // If there are no more siblings, then control escapes the current block.\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}