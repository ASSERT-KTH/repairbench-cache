{
    "generation": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  // If the current node abruptly completes, then do not try to compute a normal\n  // follow node. Instead, add (cross\u2010)edges to all enclosing try\u2013nodes that have finally blocks.\n  int type = node.getType();\n  if (type == Token.RETURN || type == Token.THROW ||\n      type == Token.BREAK || type == Token.CONTINUE) {\n    for (Node cur = node.getParent(); cur != null; cur = cur.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        // Only add the finally\u2013edge if the current abrupt node is not already within\n        // the try's finally block.\n        Node finallyBlock = cur.getLastChild();\n        if (!NodeUtil.contains(finallyBlock, node)) {\n          // For THROW and RETURN the control flows as an exceptional (ON_EX) edge;\n          // for BREAK/CONTINUE use UNCOND.\n          int branch = (type == Token.THROW || type == Token.RETURN) ? Branch.ON_EX : Branch.UNCOND;\n          if (cfa != null && cfa.finallyMap.containsKey(cur)) {\n            for (Node finallyNode : cfa.finallyMap.get(cur)) {\n              cfa.createEdge(fromNode, branch, finallyNode);\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  Node parent = node.getParent();\n  if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n    return null;\n  }\n\n  switch (parent.getType()) {\n    case Token.IF:\n      return computeFollowNode(fromNode, parent, cfa);\n\n    case Token.CASE:\n    case Token.DEFAULT_CASE:\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n\n    case Token.FOR:\n      if (NodeUtil.isForIn(parent)) {\n        return parent;\n      } else {\n        return parent.getFirstChild().getNext().getNext();\n      }\n\n    case Token.WHILE:\n    case Token.DO:\n      return parent;\n\n    case Token.TRY:\n      // When leaving the try block (the first child) or leaving the catch block,\n      // if a finally exists we delegate control to that finally.\n      if (parent.getFirstChild() == node) {\n        if (NodeUtil.hasFinally(parent)) {\n          return computeFallThrough(parent.getLastChild());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (NodeUtil.getCatchBlock(parent) == node) {\n        if (NodeUtil.hasFinally(parent)) {\n          return computeFallThrough(node.getNext());\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      } else if (parent.getLastChild() == node) {\n        // When finishing a finally block, add cross edges to any outer finally nodes.\n        if (cfa != null && cfa.finallyMap.containsKey(parent)) {\n          for (Node finallyNode : cfa.finallyMap.get(parent)) {\n            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n        }\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n  }\n\n  Node nextSibling = node.getNext();\n  while (nextSibling != null && nextSibling.isFunction()) {\n    nextSibling = nextSibling.getNext();\n  }\n  if (nextSibling != null) {\n    return computeFallThrough(nextSibling);\n  } else {\n    return computeFollowNode(fromNode, parent, cfa);\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}