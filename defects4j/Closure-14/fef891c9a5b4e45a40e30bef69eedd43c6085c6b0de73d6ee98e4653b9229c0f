{
    "generation": "  /**\n   * Computes the follow() node of a given node and its parent.\n   * This function computes the normal fall-through successor.\n   * Handling of abrupt completions through finally blocks must be\n   * managed elsewhere (e.g., when processing the abrupt statement itself,\n   * or when processing the last instruction of the finally block).\n   *\n   * @param fromNode The original source node (used for context, e.g. loop analysis).\n   * @param node The node that follow() should compute.\n   * @param cfa The current ControlFlowAnalysis instance, or null.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n\n    // Determine the parent node.\n    Node parent = node.getParent();\n\n    // If the parent is null, we're at the top level (SCRIPT). Reaching the end\n    // of the script means control flow stops (represented by null).\n    // If the parent is a FUNCTION, completing the block means returning from\n    // the function (represented by null).\n    // If the node is the root of the CFG, we've reached the end of the analyzed\n    // section (represented by null).\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n      // A return/throw statement represents an abrupt completion. Its successor\n      // in the normal flow graph is null. The actual control transfer (e.g., to\n      // a finally block or function exit) is handled explicitly when visiting\n      // the return/throw node.\n      if (node.isReturn() || node.isThrow()) {\n        return null;\n      }\n      // Reaching the end of a function, script, or the CFG root represents an\n      // implicit return or termination.\n      return null;\n    }\n\n    // Handle control flow structures explicitly.\n    switch (parent.getType()) {\n      case Token.IF:\n        // The follow of either branch of an IF is the node following the IF.\n        return computeFollowNode(fromNode, parent, cfa);\n\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE/DEFAULT_CASE, control normally goes to the\n        // *next* CASE/DEFAULT_CASE's body or falls out of the switch.\n        Node switchNode = parent.getParent();\n        Node nextCase = parent.getNext();\n        // Find the next CASE or DEFAULT_CASE sibling.\n        while (nextCase != null) {\n          if (nextCase.isCase()) {\n            // Fall through to the next case's statement block.\n            return computeFallThrough(nextCase.getFirstChild().getNext());\n          } else if (nextCase.isDefaultCase()) {\n            // Fall through to the default case's statement block.\n            return computeFallThrough(nextCase.getFirstChild());\n          }\n          // Skip non-case/default siblings (e.g., comments, empty statements)\n          nextCase = nextCase.getNext();\n        }\n        // No next case/default found, control falls out of the switch.\n        // The follow is the node after the SWITCH statement.\n        return computeFollowNode(fromNode, switchNode, cfa);\n\n      case Token.FOR:\n        // For-in loops behave like while loops for follow computation.\n        if (NodeUtil.isForIn(parent)) {\n          return parent; // The loop body/condition follows itself.\n        } else {\n          // Standard FOR(init; cond; incr) body\n          Node init = parent.getFirstChild();\n          Node cond = init.getNext();\n          Node incr = cond.getNext().getNext();\n          if (node == init) return computeFallThrough(cond); // init -> cond\n          if (node == cond.getNext()) return computeFallThrough(incr); // body -> incr\n          if (node == incr) return computeFallThrough(cond); // incr -> cond\n          // Note: Follow of 'cond' depends on true/false branch, handled elsewhere.\n          // If 'node' is 'cond', something is wrong.\n          // If 'node' is the FOR node itself, fall through to sibling logic.\n        }\n        break; // Break from FOR case to handle general sibling logic if needed.\n\n      case Token.WHILE:\n      case Token.DO:\n        // The follow of the body of a WHILE/DO loop is the loop itself (condition).\n        return parent;\n\n      case Token.TRY:\n        Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n\n        // Exiting the main TRY block:\n        if (node == parent.getFirstChild()) {\n          if (finallyBlock != null) {\n            return computeFallThrough(finallyBlock); // Normal exit goes to finally.\n          } else {\n            // No finally, normal exit falls through after the TRY statement.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        }\n        // Exiting a CATCH block:\n        Node catchBlock = NodeUtil.getCatchBlock(parent);\n        if (catchBlock != null && node == catchBlock) {\n           if (finallyBlock != null) {\n             return computeFallThrough(finallyBlock); // Normal exit goes to finally.\n           } else {\n             // No finally, normal exit falls through after the TRY statement.\n             return computeFollowNode(fromNode, parent, cfa);\n           }\n        }\n        // Exiting a FINALLY block:\n        if (finallyBlock != null && node == finallyBlock) {\n           // Normal fall-through from a finally block goes to whatever follows\n           // the entire TRY statement. Edges for abrupt completions that entered\n           // the finally are handled elsewhere (e.g., in visitReturn/visitBreak\n           // or exception handling logic).\n           return computeFollowNode(fromNode, parent, cfa);\n        }\n        // If node is the TRY node itself, or an inner node not covered above,\n        // fall through to the general sibling logic.\n        break; // Break from TRY case.\n    }\n\n    // General case: If not handled by a specific control structure parent,\n    // the follow is usually the next sibling.\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations as they are not executed in normal flow.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      // If a next sibling exists, fall through to it.\n      return computeFallThrough(nextSibling);\n    } else {\n      // No more siblings. Control transfers up the AST. The follow is the\n      // follow of the parent block/node.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}