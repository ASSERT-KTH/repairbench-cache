{
    "generation": "  /**\n   * Computes the follow() node of a given node and its parent.\n   * This function computes the target of a normal control flow transfer.\n   * Branching control flow (including exceptions and jumps like break,\n   * continue, return) is handled by the main ControlFlowAnalysis logic creating\n   * specific edges.\n   *\n   * @param fromNode The original source node (unused in this revised logic,\n   *                 kept for compatibility).\n   * @param node The node whose successor is being computed.\n   * @param cfa The ControlFlowAnalysis instance (used for accessing root). Can be null.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, @Nullable ControlFlowAnalysis cfa) {\n\n    Node parent = node.getParent();\n\n    // 1. Exit Function/Script/Return: If the parent is null (end of script),\n    //    or the parent is a FUNCTION (return from function), or the node is a\n    //    RETURN statement, or the node is the CFG root, then control flow exits.\n    if (parent == null || parent.isFunction() || node.isReturn() ||\n        (cfa != null && node == cfa.root)) {\n      return null; // Represents CFG exit\n    }\n\n    // 2. Control Flow Structures:\n    switch (parent.getType()) {\n      case Token.IF:\n        // Fall-through from an IF branch goes to the node after the IF.\n        return computeFollowNode(fromNode, parent, cfa);\n\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After a CASE/DEFAULT_CASE block, control normally falls through\n        // to the next CASE/DEFAULT_CASE's body.\n        Node nextCase = parent.getNext();\n        if (nextCase != null) {\n          if (nextCase.isCase()) {\n            // CASE expr: BLOCK <- return the block\n            return nextCase.getFirstChild().getNext();\n          } else {\n            // DEFAULT_CASE: BLOCK <- return the block\n            Preconditions.checkState(nextCase.isDefaultCase());\n            return nextCase.getFirstChild();\n          }\n        } else {\n          // Last case/default block, control exits the SWITCH.\n          // The parent of CASE/DEFAULT_CASE is SWITCH.\n          return computeFollowNode(fromNode, parent.getParent(), cfa);\n        }\n\n      case Token.FOR:\n        // After the body of FOR, FOR..IN, control loops back.\n        // Specific edges (body -> increment, increment -> condition) are\n        // handled by the main CFA logic. The follow node in a general\n        // sense is the loop itself.\n        return parent;\n\n      case Token.WHILE:\n      case Token.DO:\n        // After the body of WHILE/DO, control loops back to the condition.\n        return parent; // Represents the loop itself\n\n      case Token.TRY:\n        Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n        Node catchBlock = NodeUtil.getCatchBlock(parent);\n\n        // Exiting the main TRY block (node == parent.getFirstChild()):\n        if (node == parent.getFirstChild()) {\n          if (finallyBlock != null) {\n            return computeFallThrough(finallyBlock); // Go to FINALLY\n          } else {\n            // No FINALLY, exit the TRY structure.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        }\n        // Exiting a CATCH block (node == catchBlock):\n        else if (catchBlock != null && node == catchBlock) {\n           if (finallyBlock != null) {\n             return computeFallThrough(finallyBlock); // Go to FINALLY\n           } else {\n             // No FINALLY, exit the TRY structure.\n             return computeFollowNode(fromNode, parent, cfa);\n           }\n        }\n        // Exiting a FINALLY block (node == finallyBlock):\n        else if (finallyBlock != null && node == finallyBlock) {\n          // After FINALLY, control resumes after the entire TRY structure.\n          // Jumps handled by handleFinally are separate edges.\n          // The problematic side-effect loop creating edges based on\n          // finallyMap has been removed.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        // If node is not try/catch/finally block (e.g. the CATCH structure itself),\n        // fall through to sibling logic.\n        break;\n    }\n\n    // 3. Default: Sequential Execution - Go to the next sibling.\n    Node nextSibling = node.getNext();\n\n    // Skip sibling FUNCTION declarations as control doesn't flow into them sequentially.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      // Found a subsequent statement/expression. Compute its entry point.\n      return computeFallThrough(nextSibling);\n    } else {\n      // No more siblings; control flow transfers up to the parent's context.\n      // Example: end of a block statement, follow is determined by parent's type (handled above)\n      // or the parent's sibling (handled by recursion).\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n  /**\n   * Computes the fallthrough node of the given node.\n   * In ControlFlowAnalysis, this is often the node itself, as it assumes\n   * the CFA graph traversal handles entering complex structures correctly.\n   * If `n` represents a block or structure, the actual first executed node\n   * inside it would be the target, but computeFollowNode usually points\n   * to the start of the next logical statement/structure.\n   *\n   * @param n The node to compute fall through from.\n   * @return The node itself, acting as the entry point for the fall through.\n   */\n  private static Node computeFallThrough(Node n) {\n    // This helper might have more complex logic in the actual ControlFlowAnalysis,\n    // but often it just returns the node itself, assuming the graph builder connects\n    // to the correct entry point. For the purpose of fixing computeFollowNode,\n    // assuming it returns the target node is sufficient.\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}