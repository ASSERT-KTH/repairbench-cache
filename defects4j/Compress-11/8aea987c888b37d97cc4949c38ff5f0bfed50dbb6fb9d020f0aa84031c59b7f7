{
    "generation": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n// NOTE: The following imports are assumed based on the original code context.\n// They might need adjustment based on the actual project structure.\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ar.ArArchiveInputStream;\nimport org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream;\nimport org.apache.commons.compress.archivers.dump.DumpArchiveInputStream;\nimport org.apache.commons.compress.archivers.jar.JarArchiveInputStream;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;\n\n    /**\n     * Create an archive input stream from an input stream, autodetecting\n     * the archive type from the first few bytes of the stream. The InputStream\n     * must support marks, like BufferedInputStream.\n     *\n     * @param in the input stream\n     * @return the archive input stream\n     * @throws ArchiveException if the archiver name is not known or an error occurs reading the stream\n     * @throws IllegalArgumentException if the stream is null or does not support mark\n     */\n    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n            throws ArchiveException {\n        if (in == null) {\n            throw new IllegalArgumentException(\"Stream must not be null.\");\n        }\n\n        if (!in.markSupported()) {\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        int signatureLength = -1;\n        try {\n            signatureLength = in.read(signature);\n            in.reset();\n\n            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n                return new ZipArchiveInputStream(in);\n            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n                return new JarArchiveInputStream(in);\n            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n                return new ArArchiveInputStream(in);\n            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n                return new CpioArchiveInputStream(in);\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            int dumpSigLength = in.read(dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, dumpSigLength)) {\n                return new DumpArchiveInputStream(in);\n            }\n\n            // Tar needs an even bigger buffer (512 bytes); read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            int tarHeaderLength = in.read(tarheader);\n            in.reset();\n\n            // First check using the standard TarArchiveInputStream.matches method\n            if (TarArchiveInputStream.matches(tarheader, tarHeaderLength)) {\n                return new TarArchiveInputStream(in);\n            }\n\n            // COMPRESS-117 fallback: If TarArchiveInputStream.matches failed,\n            // try to parse the header to see if it's a TAR format that\n            // TarArchiveInputStream can handle anyway (e.g., with variations).\n            // Only attempt if we read enough bytes for a TAR header.\n            // A valid TAR header is 512 bytes.\n            if (tarHeaderLength >= 512) {\n                 TarArchiveInputStream tais = null;\n                 try {\n                     // Use a temporary input stream based on the header bytes read\n                     tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader, 0, tarHeaderLength));\n                     // Try to read the first entry. If it succeeds and returns a non-null entry,\n                     // then it's likely a TAR archive we can process.\n                     // This differentiates from the previous logic which only checked for absence of Exception.\n                     if (tais.getNextEntry() != null) {\n                         // It seems to be a TAR archive based on parsing, return a new stream for the original input\n                         return new TarArchiveInputStream(in);\n                     }\n                     // If getNextEntry() returned null, it implies an empty archive or an invalid header\n                     // that wasn't detected as an exception. Since matches() failed, we treat it as non-TAR.\n                 } catch (Exception e) { // NOPMD\n                     // Catch IOException, IllegalArgumentException, etc. These indicate parsing failure.\n                     // If parsing fails, it's not a TAR according to this fallback check.\n                     // Ignore the exception and proceed to the final failure case.\n                 } finally {\n                     // Ensure the temporary stream used for checking is closed.\n                     if (tais != null) {\n                         try {\n                             tais.close();\n                         } catch (IOException ignored) { // NOPMD\n                             // Exception on closing the temporary stream can be ignored.\n                         }\n                     }\n                 }\n            }\n            // If we reach here, none of the checks identified the stream as a known archive type.\n\n        } catch (IOException e) {\n            // This exception implies an issue with the input stream itself (e.g., mark/reset error, read error).\n            throw new ArchiveException(\"Could not use reset and mark operations, or read failed.\", e);\n        }\n\n        // If stream is not null and supports mark, but no archive format matched.\n        throw new ArchiveException(\"No Archiver found for the stream signature\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}