{
    "generation": "    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            // Seek to the position of filename length and extra field length\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b); // Read filename length\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b); // Read extra field length\n            int extraFieldLen = ZipShort.getValue(b);\n\n            // Calculate the data offset required to stream the entry data\n            // This is based on the LFH structure:\n            // LFH Signature (4) + Version (2) + GP Bit Flag (2) + Method (2) + Time (2) + Date (2)\n            // + CRC32 (4) + Compressed Size (4) + Uncompressed Size (4)\n            // + Filename Length (2) + Extra Field Length (2) == 30 bytes total fixed size\n            // + Filename Length (variable) + Extra Field Length (variable)\n            // = Start of data\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT\n                + fileNameLen + extraFieldLen;\n\n            // The extra data from the LFH is not needed here; we have the authoritative version\n            // from the central directory already stored in ze. We MUST NOT overwrite it,\n            // as the LFH extra data might be different or incomplete (e.g., missing Unicode Path).\n            // cf. https://issues.apache.org/jira/browse/COMPRESS-180\n            // cf. https://issues.apache.org/jira/browse/COMPRESS-206\n\n            // If the entry lacked the UTF8 general purpose bit flag in the central directory,\n            // we might need to re-evaluate the name and comment based on the presence of\n            // Unicode extra fields (which should be the ones from the central directory).\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // This uses the extra fields already parsed from the central directory\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    // If the name changed (e.g., corrected via Unicode Path Extra Field),\n                    // update the name mapping.\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}