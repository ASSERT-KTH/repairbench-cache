{
    "generation": "    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order.\n        //\n        // If a ZipArchiveEntry's name changes, its hashCode and equals behavior also change.\n        // If this entry is a key in a HashMap (like 'entries'), the map's internal\n        // structure for that key becomes corrupted. Subsequent lookups (e.g., in\n        // ZipFile.getInputStream) might fail because the entry cannot be found.\n        // To fix this, we need to rebuild the 'entries' map.\n\n        // 1. Create a copy of the keys to iterate over to avoid ConcurrentModificationException\n        //    if we modify the 'entries' map directly within the loop (which we will by clearing/repopulating).\n        //    Also, to ensure the order is preserved for LinkedHashMap.\n        List<ZipArchiveEntry> entriesInOrder = new ArrayList<>(entries.keySet());\n\n        // 2. Create a temporary map to build the corrected set of entries.\n        //    Using LinkedHashMap ensures that the original central directory order is preserved.\n        Map<ZipArchiveEntry, OffsetEntry> tmpEntries = new LinkedHashMap<>(entries.size());\n\n        for (ZipArchiveEntry ze : entriesInOrder) {\n            // Retrieve the OffsetEntry associated with the current ZipArchiveEntry.\n            // This works because 'ze' is the exact instance from the original 'entries.keySet()'.\n            OffsetEntry offsetEntry = entries.get(ze);\n\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            // Setting extra fields modifies the ZipArchiveEntry object in place.\n            ze.setExtra(localExtraData);\n\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            // Store the original name before potential modification\n            String origName = ze.getName();\n\n            // If the entry was identified as potentially having UTF-8 name/comment in extra fields\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // This call might change the name of 'ze' if UTF-8 encoding is found and preferred.\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n            }\n\n            // If the name of the entry changed, update the nameMap accordingly.\n            if (!origName.equals(ze.getName())) {\n                nameMap.remove(origName);\n                nameMap.put(ze.getName(), ze);\n            }\n\n            // Add the (potentially modified) ZipArchiveEntry and its OffsetEntry to the temporary map.\n            // This ensures that the key in the new map correctly reflects the current state of 'ze'\n            // (including its potentially new name and thus new hashCode).\n            tmpEntries.put(ze, offsetEntry);\n        }\n\n        // 3. Reconstruct the 'entries' map by clearing the old one and populating it\n        //    with the entries from the temporary map. This corrects any hash-related\n        //    corruption caused by in-place key modification while preserving order.\n        entries.clear();\n        entries.putAll(tmpEntries);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}