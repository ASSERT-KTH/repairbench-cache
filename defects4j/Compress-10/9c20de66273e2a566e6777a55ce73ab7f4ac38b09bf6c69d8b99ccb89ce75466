{
    "generation": "import java.io.IOException;\nimport java.util.Map;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipShort;\nimport org.apache.commons.compress.archivers.zip.ZipUtil;\n// Assuming the context of the ZipFile class where necessary fields and constants like\n// entries, nameMap, archive, OffsetEntry, NameAndComment, LFH_OFFSET_FOR_FILENAME_LENGTH, SHORT\n// are defined.\n\n    /**\n     * Walks through all recorded entries and resolves differences between\n     * LFH and central directory data.\n     *\n     * <p>Specifically, it calculates the data offset based on the LFH\n     * structure and potentially updates entry names and comments if\n     * Unicode extra fields are present in the central directory but the\n     * general purpose UTF-8 flag was not set.</p>\n     *\n     * @param entriesWithoutUTF8Flag Map of entries that lacked the UTF-8\n     *                               flag in the central directory but had\n     *                               potential Unicode names/comments in\n     *                               CD extra fields.\n     * @throws IOException if an I/O error occurs reading the archive.\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // The ZipFile constructor handles map reconstruction if names change.\n        for (ZipArchiveEntry ze : entries.keySet()) { // Iterating over keys, value lookup is fine.\n            OffsetEntry offsetEntry = entries.get(ze);\n            // offsetEntry should not be null if ze comes from entries.keySet()\n            if (offsetEntry == null) {\n                // This indicates an internal inconsistency.\n                // While unlikely, handle defensively or throw.\n                // For now, matching original behavior's lack of check here.\n                 continue;\n            }\n\n            long offset = offsetEntry.headerOffset; // Start of LFH\n            // Position calculation needs constants defined in ZipFile/ZipConstants\n            // static final int LFH_OFFSET_FOR_FILENAME_LENGTH = 26;\n            // static final int SHORT = 2;\n\n            // Seek to the position of filename length field in LFH\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] shortBuf = new byte[SHORT]; // Use a buffer for short reads\n\n            // Read filename length (n) from LFH\n            archive.readFully(shortBuf);\n            int fileNameLen = ZipShort.getValue(shortBuf);\n\n            // Read extra field length (m) from LFH\n            archive.readFully(shortBuf);\n            int extraFieldLen = ZipShort.getValue(shortBuf);\n\n            // Skip the filename field in the LFH\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    // Use IOException for I/O related failures\n                    throw new IOException(\"Failed to skip file name in local file header\"\n                                          + \" for entry \" + ze.getName());\n                }\n                lenToSkip -= skipped;\n            }\n\n            // Read the local extra field data.\n            // We need the LFH extra field *length* (extraFieldLen) to calculate\n            // the data offset correctly.\n            // We read the *data* itself but DO NOT store it back into the\n            // ZipArchiveEntry (ze.setExtra()), because the Central Directory\n            // extra data is often more complete (e.g., Unicode path fields)\n            // and should be preserved on the main entry object for name correction.\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            // ze.setExtra(localExtraData); // DO NOT DO THIS - It overwrites CDH extra data needed for name correction\n\n            // Calculate the offset where the actual compressed data starts.\n            // This depends on the LFH structure: offset + fixed_header_part + filename_len + extra_field_len\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            // Handle entries where the UTF-8 flag was missing in the general\n            // purpose flags but Unicode path/comment extra fields were found\n            // in the *Central Directory*.\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // Update name/comment using the extra fields *already stored in ze*\n                // (which are the CD extra fields). This is crucial for cases like WinZip\n                // archives where Unicode info is only in CD extra fields.\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                // If the name was updated (e.g., from raw bytes to proper Unicode),\n                // we need to update the nameMap for lookups by name.\n                // The main `entries` map might also need rebuilding due to\n                // hashcode changes, which is handled by the ZipFile constructor.\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            // Any other LFH data needed? Potentially LFH specific extra fields\n            // could be stored in OffsetEntry if required later, e.g.\n            // offsetEntry.localExtraData = localExtraData;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}