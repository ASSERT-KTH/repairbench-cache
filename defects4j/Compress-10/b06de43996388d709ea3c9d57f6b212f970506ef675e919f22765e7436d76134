{
    "generation": "/**\n * Walks through all recorded entries and adds the data available\n * from the local file header.\n *\n * <p>Also records the offsets for the data to read from the\n * entries.</p>\n */\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        // Position at the two-byte filename-length field in the local header\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] buf = new byte[SHORT];\n        archive.readFully(buf);\n        int fileNameLen = ZipShort.getValue(buf);\n        archive.readFully(buf);\n        int extraFieldLen = ZipShort.getValue(buf);\n        // Skip over the file-name bytes\n        int toSkip = fileNameLen;\n        while (toSkip > 0) {\n            int skipped = archive.skipBytes(toSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\n                    \"failed to skip file name in local file header\");\n            }\n            toSkip -= skipped;\n        }\n        // Read the local\u2010header extra data, but do NOT discard the central\u2010directory\n        // extra fields \u2013 instead merge the new ones in\n        byte[] localExtra = new byte[extraFieldLen];\n        archive.readFully(localExtra);\n        if (extraFieldLen > 0) {\n            // parse the local extra fields and add them to the entry\n            ZipExtraField[] lfs = ExtraFieldUtils.parse(localExtra, false);\n            for (ZipExtraField f : lfs) {\n                ze.addExtraField(f);\n            }\n        }\n        // Compute where the file data actually starts\n        offsetEntry.dataOffset = offset\n            + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT\n            + fileNameLen + extraFieldLen;\n\n        // For entries recorded without the UTF-8 flag, apply the\n        // NameAndComment extracted from the central directory extra.\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}