{
    "generation": "    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n\n        // The name of a ZipArchiveEntry can change if Unicode Path Extra Fields\n        // are processed. Since ZipArchiveEntry's hashCode and equals depend on the name,\n        // modifying the name of an entry while it's a key in a HashMap (like 'entries')\n        // can corrupt the map's internal structure.\n        // To fix this, we reconstruct 'entries' and 'nameMap' after processing\n        // all local file headers. This ensures that the keys (ZipArchiveEntry objects)\n        // are correctly hashed in the new maps based on their final names.\n\n        // Create new maps to store the processed entries and maintain central directory order.\n        // The capacity is initialized to avoid rehashes if possible.\n        LinkedHashMap<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>(entries.size());\n        LinkedHashMap<String, ZipArchiveEntry> newNameMap = new LinkedHashMap<>(entries.size());\n\n        // Iterate over the original entries map to preserve the central directory order\n        for (Map.Entry<ZipArchiveEntry, OffsetEntry> mapEntry : entries.entrySet()) {\n            // Get the ZipArchiveEntry and its associated offset information.\n            // The 'ze' object here is the same instance that was a key in 'entries',\n            // and it will be modified in place.\n            ZipArchiveEntry ze = mapEntry.getKey();\n            OffsetEntry offsetEntry = mapEntry.getValue();\n\n            // Seek to the position in the archive where filename length and extra field length are stored.\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n\n            // Read filename length\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n\n            // Read extra field length\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n\n            // Skip the file name bytes in the local file header\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    // This indicates an unexpected end of stream or inability to skip.\n                    // This is a rare case but indicates a corrupt or truncated file.\n                    throw new RuntimeException(\"failed to skip file name in\"\n                                               + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n\n            // Read the local extra data\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData); // Set the extra field data on the ZipArchiveEntry\n\n            // Calculate the data offset (where the compressed data starts)\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            // Store the original name before potentially updating it from Unicode extra fields.\n            String originalName = ze.getName();\n\n            // If the entry was identified as needing UTF-8 processing (usually because of a flag\n            // or if a general purpose bit indicated no UTF-8, but extra fields might provide it)\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // Attempt to set name and comment from extra fields (e.g., Unicode Path Extra Field)\n                // This call can change 'ze.name' and 'ze.comment'.\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\n            }\n\n            // Add the (potentially modified) ZipArchiveEntry and its OffsetEntry to the new maps.\n            // If ze.getName() changed, 'ze' now has a new hashCode and equals behavior based on the new name.\n            // Adding it to 'newEntries' and 'newNameMap' ensures it's correctly placed based on its final state.\n            newEntries.put(ze, offsetEntry);\n            newNameMap.put(ze.getName(), ze);\n        }\n\n        // Replace the old maps with the newly constructed ones.\n        // This effectively \"rebuilds\" the maps with correct hash codes for the entries\n        // that may have had their names (and thus hash codes) changed.\n        this.entries = newEntries;\n        this.nameMap = newNameMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}