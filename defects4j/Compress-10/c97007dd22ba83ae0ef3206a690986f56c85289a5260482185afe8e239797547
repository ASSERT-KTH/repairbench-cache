{
    "generation": "import java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n// Assuming necessary imports for ZipArchiveEntry, NameAndComment, OffsetEntry,\n// RandomAccessData, ZipShort, ZipUtil are present.\n// Define constants if they are not imported/available.\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.LFH_OFFSET_FOR_FILENAME_LENGTH;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n\n// Class structure provided for context, replace with actual imports/context\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipUtil;\nimport org.apache.commons.compress.archivers.zip.ZipShort;\nimport org.apache.commons.compress.parallel.InputStreamSupplier; // Implicit dependency via NameAndComment? No.\n// Define dummy classes/interfaces if needed for compilation standalone\ninterface RandomAccessData { void seek(long pos) throws IOException; void readFully(byte[] b) throws IOException; int skipBytes(int n) throws IOException; }\nclass OffsetEntry { long headerOffset; long dataOffset; }\nclass NameAndComment { byte[] name; byte[] comment; }\n\n\n    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     *\n     * @param entries Map of ZipArchiveEntry to OffsetEntry (presumably instance member).\n     * @param archive RandomAccessData representing the archive file (presumably instance member).\n     * @param entriesWithoutUTF8Flag Map containing entries whose names might need decoding.\n     * @throws IOException If an I/O error occurs reading the archive.\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        // nameMap is used temporarily to resolve name changes\n        Map<String, ZipArchiveEntry> nameMap = new HashMap<>();\n        // Populate nameMap based on current entry names\n        for (ZipArchiveEntry ze : entries.keySet()) {\n             nameMap.put(ze.getName(), ze);\n        }\n\n        for (ZipArchiveEntry ze : entries.keySet()) { // Iterate over the original set of entries\n            OffsetEntry offsetEntry = entries.get(ze); // Get offset data for the current entry\n            if (offsetEntry == null) {\n                 // This case should ideally not happen if 'entries' is consistent\n                 continue; // Or throw an exception\n            }\n            long offset = offsetEntry.headerOffset; // Start offset of the LFH\n\n            // Seek to the position of filename length and extra field length in LFH\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n\n            byte[] b = new byte[SHORT]; // Buffer for reading 2-byte lengths\n            // Read filename length from LFH\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            // Read extra field length from LFH\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n\n            // Skip the filename field in the LFH\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    // Use IOException for IO related failures\n                    throw new IOException(\"Failed to skip file name in local file header for entry \"\n                                               + ze.getName());\n                }\n                lenToSkip -= skipped;\n            }\n\n            // Read the LFH extra data, but do not assign it to the ZipArchiveEntry\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n\n            // Fix: Do not overwrite the ZipArchiveEntry's extra data field (ze.setExtra)\n            // with data from the local file header (localExtraData).\n            // The entry's metadata should primarily reflect the central directory header.\n            // Overwriting with local data can discard important information\n            // (like Zip64 extensions or Unicode path fields) present only\n            // in the central directory, leading to errors later when\n            // accessing the entry's data stream (like returning null InputStream).\n            // ze.setExtra(localExtraData); // REMOVED\n\n            // Calculate the offset where the actual file data starts.\n            // This is calculated based on the LFH structure:\n            // LFH start + fixed LFH size (30 bytes) + LFH filename length + LFH extra field length\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            // If the central directory entry didn't have the UTF8 flag set,\n            // attempt to potentially update the name/comment using extra fields info.\n            // This uses the extra fields already parsed from the central directory header\n            // and stored in 'ze', because we no longer overwrite them with localExtraData.\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // Update name/comment based on CDH extra fields (if applicable)\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                // If the name was updated (e.g., by Unicode path extra field\n                // found in CDH), update the temporary nameMap.\n                // Note: This doesn't modify the main 'entries' map keys/structure\n                // during iteration. The COMPRESS-164 comment might imply\n                // post-processing or reconstruction of 'entries' is needed elsewhere\n                // if entry hashCodes changed.\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }\n\n    // Dummy declarations to make the code snippet compilable for analysis tools\n    // Replace with actual instance members in the real class\n    private Map<ZipArchiveEntry, OffsetEntry> entries = new HashMap<>();\n    private RandomAccessData archive;",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}