{
    "generation": "    /**\n     * Walks through all recorded entries and adds the data available\n     * from the local file header.\n     *\n     * <p>Also records the offsets for the data to read from the\n     * entries.</p>\n     */\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        // Note: Iterating over keySet() and modifying the entry potentially\n        // referenced by the key might be problematic if the modification changes\n        // the key's hash code (like changing the name). Consider iterating over\n        // a copy or using entrySet() if issues arise.\n        for (ZipArchiveEntry ze : entries.keySet()) {\n            OffsetEntry offsetEntry = entries.get(ze);\n            long offset = offsetEntry.headerOffset;\n            // Seek to the position of filename length and extra field length in LFH\n            // LFH_OFFSET_FOR_FILENAME_LENGTH = 26\n            // SHORT = 2\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b); // Read filename length (2 bytes)\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b); // Read extra field length (2 bytes)\n            int extraFieldLen = ZipShort.getValue(b);\n\n            // Calculate the data offset using the lengths from LFH.\n            // Data offset = LFH start offset + fixed LFH header size (30)\n            //               + filename length + extra field length\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH + SHORT + SHORT\n                                     + fileNameLen + extraFieldLen;\n\n            // DONT'T read the LFH's extra data field or overwrite the entry's extra data.\n            // The entry 'ze' was populated from the central directory and we should keep\n            // the central directory's extra data which is generally more reliable\n            // and might contain information (like Unicode Path Extra Fields) not present\n            // in the LFH. Overwriting it here can lead to data access issues later.\n            // archive.skipBytes(fileNameLen); // No longer needed as we don't read extra data after this\n            // byte[] localExtraData = new byte[extraFieldLen]; // No longer needed\n            // archive.readFully(localExtraData); // No longer needed\n            // ze.setExtra(localExtraData); // DO NOT DO THIS - this was the likely bug\n\n            // If the entry might need name/comment correction based on central directory extra fields:\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                // Attempt to set name and comment using the extra fields *already in ze*\n                // (which are the ones from the central directory).\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\n                // If the name was changed (hopefully correctly using CD extra fields), update the nameMap.\n                if (!orig.equals(ze.getName())) {\n                    // Note: modifying the map while iterating over keyset can be risky.\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}