{
    "generation": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n        final int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n        int r = 0;\n        boolean loop = true;\n        while (loop) {\n            final int ii = index[r];\n            b[r][r] = Math.sqrt(c[ii][ii]);\n            for (int j = r + 1; j < order; ++j) {\n                final int jj = index[j];\n                b[j][r] = c[ii][jj] / b[r][r];\n            }\n            for (int i = r + 1; i < order; ++i) {\n                final int ii = index[i];\n                for (int j = r + 1; j < i; ++j) {\n                    final int jj = index[j];\n                    c[ii][jj] -= b[i][r] * b[j][r];\n                }\n            }\n            for (int i = r + 1; i < order; ++i) {\n                final int ii = index[i];\n                if (Math.abs(c[ii][ii]) > small) {\n                    final double e = Math.sqrt(c[ii][ii]);\n                    b[i][r] = e;\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j];\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f;\n                    }\n                }\n                // prepare next iteration\n                loop = ++r < order;\n            }\n        }\n        // build the root matrix\n        rank = r;\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}