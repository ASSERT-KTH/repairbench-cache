{
    "generation": "import org.apache.commons.math3.exception.NonPositiveDefiniteMatrixException;\nimport org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.util.FastMath;\n\n// Assume RectangularCholeskyDecomposition class members and constructor signature are:\n// public class RectangularCholeskyDecomposition {\n// private RealMatrix root;\n// private int rank;\n\n// public RectangularCholeskyDecomposition(RealMatrix matrix, double small) throws NonPositiveDefiniteMatrixException {\n// ...\n// }\n\n// public RealMatrix getRootMatrix() {\n// return root;\n// }\n\n// public int getRank() {\n// return rank;\n// }\n\n// }\n\n    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        // Create a deep copy of the matrix data to work on\n        final double[][] c = new double[order][order];\n        for (int i = 0; i < order; ++i) {\n            System.arraycopy(matrix.getData()[i], 0, c[i], 0, order);\n        }\n        final double[][] b = new double[order][order]; // This matrix will hold the Cholesky factor L in permuted form\n\n        int[] swap  = new int[order]; // Temporary array for pivoting\n        int[] index = new int[order]; // Permutation array (maps logical index to original index)\n        for (int i = 0; i < order; ++i) {\n            index[i] = i; // Initialize with identity permutation\n        }\n\n        int currentRank = 0;    // Number of independent columns found so far (actual rank)\n        int currentOrder = order; // Effective size of the submatrix currently being processed\n\n        // Main loop for decomposition. Loop until all 'currentOrder' elements are processed or discarded.\n        for (int r = 0; r < currentOrder; /* r is incremented conditionally */) {\n\n            // Find maximal diagonal element in the remaining submatrix (from logical row/col r to currentOrder-1)\n            swap[r] = r; // Assume current logical position r has the max\n            for (int i = r + 1; i < currentOrder; ++i) { // Iterate from next logical position within active submatrix\n                int ii  = index[i];     // Original row index of current candidate diagonal element\n                int isi = index[swap[r]]; // Original row index of current max diagonal element\n                if (c[ii][ii] > c[isi][isi]) { // Compare diagonal elements using their original indices in c\n                    swap[r] = i; // Store the logical position (i) that holds the new max\n                }\n            }\n\n            // Swap elements in the index array to bring the column with maximal diagonal to the current logical position 'r'\n            if (swap[r] != r) {\n                int tmp = index[r];\n                index[r] = index[swap[r]];\n                index[swap[r]] = tmp;\n            }\n\n            // Get the original index corresponding to the current logical position 'r'\n            int ir = index[r];\n\n            // Check the diagonal element at the pivoted position\n            if (c[ir][ir] < small) {\n                // If the diagonal element is below the threshold, this column is considered dependent/zero.\n                // We discard this column (it doesn't contribute to the rank).\n\n                // Before discarding, check for any sufficiently negative diagonal elements among the remaining active ones.\n                // If found, the matrix is not positive semidefinite.\n                for (int i = r; i < currentOrder; ++i) {\n                    if (c[index[i]][index[i]] < -small) {\n                        // Pass the original index (index[i]) of the problematic element.\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], index[i], small);\n                    }\n                }\n\n                // Discard this column: effectively move it to the end of the 'active' part of the index array.\n                // Swap the current logical position 'r' with the last active logical position 'currentOrder - 1'.\n                int tmp = index[r];\n                index[r] = index[currentOrder - 1];\n                index[currentOrder - 1] = tmp;\n\n                // Reduce the effective size of the matrix to process for the next iteration.\n                // This effectively removes the discarded column from the active set.\n                --currentOrder;\n                // 'r' is not incremented here. The loop will re-evaluate the element now at 'index[r]'\n                // (which was swapped in from 'currentOrder - 1'). This ensures we try to find a valid\n                // pivot for the current logical 'r' position from the remaining columns.\n\n            } else { // c[ir][ir] >= small. This column is independent and can be decomposed.\n\n                // Perform the Cholesky transformation for the current column 'r'\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt; // Store the diagonal element of the Cholesky factor L\n\n                final double inverse  = 1 / sqrt;\n                // Update elements in the current column 'r' and remaining submatrix\n                for (int i = r + 1; i < currentOrder; ++i) { // Iterate through subsequent logical rows\n                    final int ii = index[i]; // Original row index for logical row 'i'\n                    final double e = inverse * c[ii][ir]; // Compute L_ii,r\n                    b[i][r] = e; // Store in b at logical position (i, r)\n\n                    // Update the remaining part of the current row and symmetric elements\n                    c[ii][ii] -= e * e; // Update diagonal element\n                    for (int j = r + 1; j < i; ++j) { // Iterate through previous logical columns for cross-terms\n                        final int ij = index[j]; // Original column index for logical column 'j'\n                        final double f = c[ii][ij] - e * b[j][r]; // Compute C_ii,ij - L_ii,r * L_ij,r\n                        c[ii][ij] = f; // Update C_ii,ij\n                        c[ij][ii] = f; // Update symmetric C_ij,ii (since C is symmetric)\n                    }\n                }\n                currentRank++; // Increment rank as a successful independent column was found\n                r++; // Move to the next logical column for the next iteration\n            }\n        }\n\n        // Set the final rank of the matrix\n        rank = currentRank;\n\n        // Build the root matrix (L) from 'b' using the permutation information\n        // The root matrix will have 'order' rows and 'rank' columns.\n        root = MatrixUtils.createRealMatrix(order, rank);\n        for (int i = 0; i < order; ++i) { // Iterate through all rows of the output root matrix (N original rows)\n            for (int j = 0; j < rank; ++j) { // Iterate through all columns of the output root matrix (rank columns)\n                // The element b[i][j] contains the L_ij component where 'i' is the logical row index\n                // and 'j' is the logical column index from the decomposition process.\n                // We need to set root[original_row_index][j] = b[logical_row_index][j].\n                // The original row index for the current logical row 'i' is given by index[i].\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}