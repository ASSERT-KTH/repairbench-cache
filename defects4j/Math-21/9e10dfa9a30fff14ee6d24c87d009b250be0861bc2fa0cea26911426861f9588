{
    "generation": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        // The matrix data is modified in place during the decomposition.\n        // If the original matrix needs to remain unchanged, a copy should be made here.\n        // For this fix, we assume it's acceptable for the internal data array 'c' to be a reference.\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n\n        // The index array stores the permutation of original column/row indices.\n        // index[k] gives the original matrix's row/column index that is currently at pivot position k.\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i; // Initialize to identity permutation\n        }\n\n        int r = 0; // Current rank / number of non-discarded columns processed so far\n        for (boolean loop = true; loop;) {\n\n            // find maximal diagonal element among the remaining (unprocessed) diagonal elements\n            // 'best' stores the index within the 'index' array (from 'r' to 'order-1')\n            // that points to the largest diagonal element in the current working matrix 'c'.\n            int best = r;\n            for (int i = r + 1; i < order; ++i) {\n                // Compare c[original_idx_i][original_idx_i] with c[original_idx_best][original_idx_best]\n                if (c[index[i]][index[i]] > c[index[best]][index[best]]) {\n                    best = i;\n                }\n            }\n\n            // swap elements in the 'index' array if the maximal element is not at the current pivot position 'r'\n            if (best != r) {\n                int tmp = index[r];\n                index[r] = index[best];\n                index[best] = tmp;\n            }\n\n            // check diagonal element at the current pivot position (which is now index[r])\n            int ir = index[r]; // ir is the original matrix index for the current pivot\n            if (c[ir][ir] < small) { // If diagonal element is too small (close to zero)\n\n                if (r == 0) {\n                    // If the very first diagonal element after pivoting is too small,\n                    // the matrix is considered non-positive semidefinite unless it's a zero matrix.\n                    // However, in this specific case, it's flagged as an error if it's strictly less than 'small'.\n                    throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n                }\n\n                // check remaining diagonal elements for significantly negative values\n                // If any remaining diagonal element is sufficiently negative, the matrix is not PSD.\n                // The loop iterates over indices in the 'index' array from 'r' to 'order-1'.\n                for (int i = r; i < order; ++i) {\n                    // c[index[i]][index[i]] is the diagonal element in the original matrix's\n                    // coordinate system corresponding to the i-th pivoted position.\n                    if (c[index[i]][index[i]] < -small) {\n                        // There is at least one sufficiently negative diagonal element,\n                        // indicating the symmetric positive semidefinite matrix assumption is violated.\n                        // The exception should report the original matrix index.\n                        throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], index[i], small);\n                    }\n                }\n\n                // All remaining diagonal elements are close to zero (between -small and small).\n                // We consider the rank of the matrix to be 'r', and stop the decomposition.\n                ++r; // Increment r to reflect the actual rank (number of non-discarded columns)\n                loop = false; // Exit the main decomposition loop\n            } else { // Diagonal element at c[ir][ir] is large enough (>= small)\n\n                // Perform the Cholesky transformation step\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt; // Store the diagonal element of the Cholesky factor L\n                final double inverse  = 1 / sqrt;\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original index corresponding to row 'i' in the current pivot order\n                    final double e = inverse * c[ii][ir]; // Calculate L_ir (current column 'r' element of L)\n                    b[i][r] = e; // Store in 'b' matrix\n                    c[ii][ii] -= e * e; // Update diagonal element for the next iteration\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j]; // Original index corresponding to column 'j'\n                        // Update off-diagonal elements: c_ij - L_ir * L_jr\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f; // Maintain symmetry in 'c' working matrix\n                    }\n                }\n\n                // Prepare for the next iteration\n                loop = ++r < order; // Increment r, and continue if r is still less than order\n            }\n        }\n\n        // build the root matrix (L such that M = L * L^T)\n        // The 'rank' is the number of non-zero (or non-small) diagonal elements found.\n        rank = r;\n        // The root matrix 'root' has 'order' rows and 'rank' columns.\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                // The 'b' matrix stores the Cholesky factor elements based on the pivoted order.\n                // b[i][j] corresponds to the L_k,j where 'k' is the 'i'-th row in the *permuted* system.\n                // 'index[i]' gives the original row index that was mapped to the 'i'-th pivoted row.\n                // So, root.setEntry(original_row_index, column_index, value)\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}