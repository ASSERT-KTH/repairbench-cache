{
    "generation": "    /**\n     * Decompose a symmetric positive semidefinite matrix.\n     *\n     * @param matrix Symmetric positive semidefinite matrix.\n     * @param small Diagonal elements threshold under which  column are\n     * considered to be dependent on previous ones and are discarded.\n     * @exception NonPositiveDefiniteMatrixException if the matrix is not\n     * positive semidefinite.\n     */\n    public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n        throws NonPositiveDefiniteMatrixException {\n\n        final int order = matrix.getRowDimension();\n        final double[][] c = matrix.getData();\n        final double[][] b = new double[order][order];\n\n        // The 'index' array maintains the current permutation of original column indices.\n        // index[k] stores the original column index that is currently at position k in the\n        // permuted matrix.\n        int[] index = new int[order];\n        for (int i = 0; i < order; ++i) {\n            index[i] = i;\n        }\n\n        int r = 0; // 'r' represents the current column being processed for the Cholesky factor.\n        for (boolean loop = true; loop;) {\n\n            // Find maximal diagonal element among the remaining unprocessed columns\n            // (from the current pivot position 'r' to 'order-1').\n            // 'bestIdx' will store the index (within the 'index' array) of the column\n            // that has the maximum diagonal element.\n            int bestIdx = r;\n            for (int i = r + 1; i < order; ++i) {\n                // Compare c[index[i]][index[i]] (diagonal of permuted column i)\n                // with c[index[bestIdx]][index[bestIdx]] (diagonal of current best candidate).\n                if (c[index[i]][index[i]] > c[index[bestIdx]][index[bestIdx]]) {\n                    bestIdx = i;\n                }\n            }\n\n            // Swap elements in the 'index' array to bring the column with the maximal\n            // diagonal element to the current pivot position 'r'.\n            if (bestIdx != r) {\n                int tmp = index[r];\n                index[r] = index[bestIdx];\n                index[bestIdx] = tmp;\n            }\n\n            // 'ir' is the original column index of the current pivot.\n            int ir = index[r];\n            if (c[ir][ir] < small) {\n                // If the current pivot's diagonal element is below the threshold 'small',\n                // it implies this column is linearly dependent on previous ones, or the matrix is singular.\n                // We must check if any of the *remaining* diagonal elements (from 'r' to 'order-1')\n                // are significantly negative. If so, the matrix is not positive semidefinite.\n\n                for (int i = r; i < order; ++i) { // Loop from the current 'r' to the end of the matrix.\n                    int currentDiagOriginalIndex = index[i]; // Original column index for current diagonal element.\n                    if (c[currentDiagOriginalIndex][currentDiagOriginalIndex] < -small) {\n                        // Found a sufficiently negative diagonal element. This indicates\n                        // the matrix is not positive semidefinite.\n                        throw new NonPositiveDefiniteMatrixException(c[currentDiagOriginalIndex][currentDiagOriginalIndex],\n                                                                     currentDiagOriginalIndex, small);\n                    }\n                }\n\n                // If we reach here, it means all remaining diagonal elements (from r to order-1)\n                // are non-negative and below the 'small' threshold. This is consistent with a\n                // positive semidefinite matrix that is rank deficient.\n                // The decomposition terminates here, and 'r' represents the rank.\n                loop = false;\n\n            } else {\n                // The current pivot's diagonal element is significant (>= small).\n                // Proceed with the standard Cholesky transformation steps.\n\n                final double sqrt = FastMath.sqrt(c[ir][ir]);\n                b[r][r] = sqrt;\n                final double inverse  = 1 / sqrt;\n                for (int i = r + 1; i < order; ++i) {\n                    final int ii = index[i]; // Original row index for current row 'i'\n                    final double e = inverse * c[ii][ir]; // Calculate L[i][r]\n                    b[i][r] = e; // Store L[i][r] in b matrix (corresponding to permuted indices)\n\n                    // Update the diagonal element c[ii][ii]\n                    c[ii][ii] -= e * e;\n\n                    // Update the off-diagonal elements c[ii][ij] and c[ij][ii]\n                    for (int j = r + 1; j < i; ++j) {\n                        final int ij = index[j]; // Original column index for column 'j'\n                        final double f = c[ii][ij] - e * b[j][r];\n                        c[ii][ij] = f;\n                        c[ij][ii] = f; // Maintain symmetry in the remaining submatrix 'c'\n                    }\n                }\n\n                // Prepare for the next iteration: increment 'r' and check loop condition.\n                loop = (++r < order);\n            }\n        }\n\n        // Build the root matrix (L) using the calculated 'b' values and the final permutation 'index'.\n        rank = r; // 'r' now holds the correct rank of the decomposed matrix.\n        root = MatrixUtils.createRealMatrix(order, r);\n        for (int i = 0; i < order; ++i) {\n            for (int j = 0; j < r; ++j) {\n                // root.setEntry(originalRowIndex, columnOfL, value)\n                // index[i] maps the permuted row 'i' back to its original row index.\n                // b[i][j] is the element L[permuted_row_i][permuted_col_j]\n                root.setEntry(index[i], j, b[i][j]);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}