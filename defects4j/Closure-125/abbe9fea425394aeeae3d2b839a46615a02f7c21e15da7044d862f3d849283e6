{
    "generation": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    // restrictByNotNullOrUndefined handles the case where the constructor expression\n    // itself might evaluate to null or undefined. 'new' would typically throw in this case,\n    // but from a type perspective, we analyze the type assuming it's not null/undefined.\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n\n    // Case 1: Direct constructor function type\n    // A JSType can be both isConstructor() and isInterface() (e.g. FunctionType).\n    // We handle constructors first as they are the primary target for 'new'.\n    if (type.isConstructor()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      // This check is likely redundant if type.isConstructor() is true, but safe.\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        // Should be unreachable. Fallback to unknown type.\n        ensureTyped(t, n);\n      }\n    }\n    // Case 2: Empty or Unknown type\n    else if (type.isEmptyType() || type.isUnknownType()) {\n      // Cannot check parameters, result is unknown.\n      ensureTyped(t, n);\n    }\n    // Case 3: Union type - This is where the original code failed for Issue 1002\n    else if (type.isUnionType()) {\n      // If the type is a union, 'new' could potentially operate on any of the alternates.\n      // We need to find the LUB (Least Upper Bound) of the instance types produced by\n      // the constructable alternates.\n      JSType instanceType = typeRegistry.getNativeType(JSTypeNative.NO_TYPE);\n      FunctionType firstConstructor = null; // Use the first *constructor* found for param checks\n      boolean errorReported = false;\n\n      for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n        alt = alt.restrictByNotNullOrUndefined();\n        FunctionType altFn = alt.toMaybeFunctionType(); // Represents constructor or interface function types\n\n        // Check if the alternate is something that can be used with 'new'\n        if (altFn != null && (altFn.isConstructor() || altFn.isInterface())) {\n          // Record the first *constructor* for parameter checking.\n          // Interfaces usually don't define constructor sigs in the same way.\n          if (firstConstructor == null && altFn.isConstructor()) {\n             firstConstructor = altFn;\n          }\n          // Calculate the LUB of instance types produced by new'ing the alternates.\n          JSType altInstanceType = altFn.getInstanceType();\n          if (instanceType.isNoType()) {\n            instanceType = altInstanceType;\n          } else {\n            // Compute the LUB. If any alternate leads to an unknown instance type (e.g., from\n            // an unknown constructor), the LUB might become unknown.\n            instanceType = JSType.getLeastSupertype(instanceType, altInstanceType);\n          }\n        } else if (alt.isEmptyType() || alt.isUnknownType()) {\n          // Presence of empty/unknown makes the overall result potentially unknown.\n          // Update the LUB to include UNKNOWN.\n          instanceType = JSType.getLeastSupertype(instanceType, typeRegistry.getNativeType(UNKNOWN_TYPE));\n        } else {\n          // Alternate is definitely not constructable (e.g. number, string, ordinary function).\n          // Report error once.\n          if (!errorReported) {\n              report(t, n, NOT_A_CONSTRUCTOR);\n              errorReported = true;\n          }\n          // The result type must accommodate the possibility of error/unknown. Make it UNKNOWN.\n          instanceType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n          // If a non-constructable path exists, we cannot reliably check parameters.\n          firstConstructor = null;\n          // We know the result is definitely UNKNOWN now, no need to check other alternates for type.\n          break;\n        }\n      }\n\n      // After checking all alternates:\n      if (instanceType.isNoType()) {\n        // No constructable types (constructor/interface/empty/unknown) found at all in the union.\n        if (!errorReported) {\n             report(t, n, NOT_A_CONSTRUCTOR);\n        }\n        ensureTyped(t, n); // Ensure Unknown result type\n      } else {\n        // We have a resulting instance type (possibly Unknown or a LUB).\n        // Check params using the first valid constructor signature found, if any.\n        if (firstConstructor != null) {\n          visitParameterList(t, n, firstConstructor);\n        }\n        ensureTyped(t, n, instanceType);\n      }\n    }\n    // Case 4: Interface type (standalone, not in union)\n    // Check after UnionType, as a Union could contain interfaces.\n    // Check after Constructor, as a FunctionType can be both.\n    else if (type.isInterface()) {\n        FunctionType interfaceFnType = type.toMaybeFunctionType();\n        if (interfaceFnType != null) {\n            // Treat 'new Interface()' as potentially valid (e.g. if aliased to a constructor),\n            // yielding an instance of the interface type.\n            // Skip parameter check as interfaces don't define constructor params directly.\n            ensureTyped(t, n, interfaceFnType.getInstanceType());\n        } else {\n            // Should not happen if type.isInterface() is true? Fallback.\n             ensureTyped(t, n);\n        }\n    }\n    // Case 5: Definitely not constructable (e.g., primitive, object literal, ordinary function)\n    else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n); // Ensure Unknown result type\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}