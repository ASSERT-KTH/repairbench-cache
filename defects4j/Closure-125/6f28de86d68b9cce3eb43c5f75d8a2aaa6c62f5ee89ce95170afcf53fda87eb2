{
    "generation": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        // FunctionType.getInstanceType() throws IllegalStateException if 'this'\n        // is not a constructor, an interface, or an enum type.\n        // Although type.isConstructor() should ideally ensure this,\n        // in complex type inference scenarios (like dead code branches or union types),\n        // fnType might sometimes resolve to a FunctionType that doesn't fit these categories.\n        // Adding an explicit check here prevents the IllegalStateException.\n        if (fnType.isConstructor() || fnType.isInterface() || fnType.isEnumType()) {\n          visitParameterList(t, n, fnType);\n          ensureTyped(t, n, fnType.getInstanceType());\n        } else {\n          // If fnType is a FunctionType but not a constructor, interface, or enum,\n          // then it cannot be used with 'new'. Report an error.\n          report(t, n, NOT_A_CONSTRUCTOR);\n          ensureTyped(t, n);\n        }\n      } else {\n        // This branch is taken if type.isEmptyType() or type.isUnknownType() is true,\n        // as toMaybeFunctionType() returns null for these types.\n        // It also handles NoType, which can result from dead code analysis.\n        ensureTyped(t, n);\n      }\n    } else {\n      // This branch is taken if type is neither a constructor, empty, nor unknown.\n      // This includes cases where type is a regular function type that is not constructible.\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}