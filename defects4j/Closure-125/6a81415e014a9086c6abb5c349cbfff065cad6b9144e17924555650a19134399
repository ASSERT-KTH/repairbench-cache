{
    "generation": "/**\n * Visits a NEW node.\n */\nprivate void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  \n  // If the constructor\u2019s type is a union, try to extract all constructor alternatives.\n  if (type.isUnionType()) {\n    UnionType union = type.toMaybeUnionType();\n    List<FunctionType> fnTypes = new ArrayList<>();\n    for (JSType alt : union.getAlternates()) {\n      if (alt.isConstructor()) {\n        FunctionType fn = alt.toMaybeFunctionType();\n        if (fn != null) {\n          fnTypes.add(fn);\n        }\n      }\n    }\n    if (!fnTypes.isEmpty()) {\n      // Use the first function type to visit the parameter list.\n      visitParameterList(t, n, fnTypes.get(0));\n      // Compute the union of the instance types from all constructor alternatives.\n      JSType instanceType = fnTypes.get(0).getInstanceType();\n      for (int i = 1; i < fnTypes.size(); i++) {\n        instanceType = instanceType.getLeastSupertype(fnTypes.get(i).getInstanceType());\n      }\n      ensureTyped(t, n, instanceType);\n      return;\n    }\n  }\n  \n  // Otherwise, if the type is known to be a constructor (or is empty/unknown), use it.\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}