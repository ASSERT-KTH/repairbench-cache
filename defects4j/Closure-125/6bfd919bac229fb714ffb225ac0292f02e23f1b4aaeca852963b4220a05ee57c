{
    "generation": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        // If 'type' was a UnionType containing constructor functions,\n        // 'fnType' might be a FunctionType representing their common supertype.\n        // This common supertype FunctionType may not itself be a constructor.\n        // Calling getInstanceType() on a non-constructor FunctionType throws an IllegalStateException.\n        // We must ensure fnType is a constructor before calling getInstanceType().\n        if (fnType.isConstructor()) {\n          visitParameterList(t, n, fnType);\n          ensureTyped(t, n, fnType.getInstanceType());\n        } else {\n          // If fnType is not a constructor (e.g., common supertype of two distinct constructors),\n          // or if it was derived from an empty/unknown type and doesn't represent a precise constructor,\n          // we cannot determine a specific instance type.\n          ensureTyped(t, n);\n        }\n      } else {\n        // This path is taken if 'type' is Empty or Unknown, but not a FunctionType,\n        // or if it's a UnionType that cannot be meaningfully converted to a single FunctionType.\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}