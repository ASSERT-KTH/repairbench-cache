{
    "generation": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n\n  // If the constructor expression is a union of constructors, handle each arm.\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    JSTypeRegistry registry = t.getCompiler().getTypeRegistry();\n    List<JSType> instanceTypes = new ArrayList<JSType>();\n    for (JSType alt : unionType.getMembers()) {\n      JSType altRestr = alt.restrictByNotNullOrUndefined();\n      FunctionType altCtor = altRestr.toMaybeFunctionType();\n      if (altCtor == null || !altCtor.isConstructor()) {\n        report(t, n, NOT_A_CONSTRUCTOR);\n        ensureTyped(t, n);\n        return;\n      }\n      visitParameterList(t, n, altCtor);\n      instanceTypes.add(altCtor.getInstanceType());\n    }\n    // The result of `new` is the union of all possible instance types.\n    ensureTyped(t, n, registry.createUnionType(instanceTypes));\n  } else {\n    // The normal (non\u2010union) case.\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType != null && fnType.isConstructor()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else if (type.isEmptyType() || type.isUnknownType()) {\n      // Allow calls on empty/unknown without crashing.\n      ensureTyped(t, n);\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}