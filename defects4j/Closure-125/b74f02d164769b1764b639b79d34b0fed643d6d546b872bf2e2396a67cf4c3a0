{
    "generation": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    // getJSType returns the resolved type of the constructor function, which is\n    // sometimes different from the type of the constructor in the registry.\n    // It is necessary to restrict this type by non-null, because that's the contract\n    // of the NEW operator.\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n      if (fnType != null) {\n        visitParameterList(t, n, fnType);\n        JSType instanceType = fnType.getInstanceType();\n\n        // If flow inference leads to a situation where the inferred function type's\n        // instance type is not a simple object type (e.g., it's a UnionType or EmptyType\n        // due to conditions like `if (Ctor1 === Ctor2)`), passing such a type to\n        // ensureTyped might lead to downstream errors (like IllegalStateException).\n        // Check if the instance type is actually an ObjectType. If not, fall back\n        // to assigning the unknown type to the node to avoid potential issues.\n        ObjectType objectInstanceType = JSType.toMaybeObjectType(instanceType);\n        if (objectInstanceType != null) {\n          ensureTyped(t, n, objectInstanceType);\n        } else {\n          // Fallback for non-object instance types (null, unknown, empty, union, etc.)\n          ensureTyped(t, n);\n        }\n      } else {\n        // If the type was Empty or Unknown, toMaybeFunctionType could return null.\n        ensureTyped(t, n);\n      }\n    } else {\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}