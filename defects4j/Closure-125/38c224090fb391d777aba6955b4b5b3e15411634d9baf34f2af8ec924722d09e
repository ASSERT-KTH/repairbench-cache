{
    "generation": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n\n    // If 'type' is a constructor function type, an empty type, or an unknown type,\n    // we attempt to process it as a constructor.\n    if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n      FunctionType fnType = type.toMaybeFunctionType();\n\n      // IMPORTANT: If 'type' was a UnionType where one of the types was a constructor\n      // (making type.isConstructor() true), but the common supertype (fnType)\n      // is not a constructor (e.g., the base Function prototype), then calling\n      // fnType.getInstanceType() would throw an IllegalStateException.\n      // We must ensure that the resolved fnType is indeed a constructor or interface\n      // before attempting to get its instance type.\n      if (fnType != null && (fnType.isConstructor() || fnType.isInterface())) {\n        visitParameterList(t, n, fnType);\n        ensureTyped(t, n, fnType.getInstanceType());\n      } else {\n        // This path is taken if:\n        // 1. fnType is null (e.g., type was EmptyType or UnknownType, or a non-function type).\n        // 2. fnType is a FunctionType, but it's not a constructor or interface\n        //    (e.g., a generic FunctionType that is not a constructor, possibly derived\n        //    from a UnionType where type.isConstructor() was true due to a constituent type).\n        // In these cases, we cannot reliably determine the instance type, so we\n        // ensure a basic type (often unknown) for the 'new' expression.\n        ensureTyped(t, n);\n      }\n    } else {\n      // If the type is definitively not a constructor, report an error.\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}