{
    "generation": "  /**\n   * Visits a NEW node.\n   */\n  private void visitNew(NodeTraversal t, Node n) {\n    Node constructor = n.getFirstChild();\n    JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n\n    // Try to get a FunctionType from the constructor type.\n    FunctionType fnType = type.toMaybeFunctionType();\n\n    // Check if fnType is a valid constructor.\n    // If type.isConstructor() was true, fnType should be non-null and also a constructor.\n    // However, if type was EmptyType or UnknownType, fnType will be null,\n    // or if it was a union that resolved to a non-constructor function.\n    if (fnType != null && fnType.isConstructor()) {\n      // If it's a proper constructor function type, proceed.\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else if (type.isUnknownType() || type.isEmptyType() || (fnType != null && !fnType.isConstructor())) {\n      // If the type is unknown, empty, or it's a function type that is NOT a constructor\n      // (e.g., a function that can't be 'new'ed, or an interface function),\n      // we cannot determine a specific instance type. Treat the result of 'new' as unknown.\n      // The condition `(fnType != null && !fnType.isConstructor())` handles cases where\n      // the outer `type.isConstructor()` might have been false but `type.isEmptyType()`\n      // or `type.isUnknownType()` was true, leading to a non-constructor FunctionType via `toMaybeFunctionType()`,\n      // or to resolve inconsistencies where `type.isConstructor()` was true but `fnType.isConstructor()` is false.\n      ensureTyped(t, n);\n    } else {\n      // The type is known, but it's not a constructor, not empty, not unknown.\n      // For example, 'new 5()' or 'new someObject()'.\n      report(t, n, NOT_A_CONSTRUCTOR);\n      ensureTyped(t, n);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}