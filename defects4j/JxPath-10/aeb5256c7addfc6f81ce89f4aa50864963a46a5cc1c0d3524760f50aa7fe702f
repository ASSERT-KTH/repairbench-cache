{
    "generation": "    public final Object computeValue(EvalContext context) {\n        Object value1 = args[0].computeValue(context);\n        Object value2 = args[1].computeValue(context);\n\n        boolean v1IsEmptyNodeSet = false;\n        if (value1 == null) {\n            v1IsEmptyNodeSet = true;\n        } else if (value1 instanceof java.util.Collection) {\n            v1IsEmptyNodeSet = ((java.util.Collection) value1).isEmpty();\n        } else if (value1 instanceof java.util.Iterator) {\n            // Check if the iterator is empty without consuming it.\n            // For an empty iterator, hasNext() returns false immediately.\n            java.util.Iterator it = (java.util.Iterator) value1;\n            if (!it.hasNext()) {\n                v1IsEmptyNodeSet = true;\n            }\n        }\n\n        boolean v2IsEmptyNodeSet = false;\n        if (value2 == null) {\n            v2IsEmptyNodeSet = true;\n        } else if (value2 instanceof java.util.Collection) {\n            v2IsEmptyNodeSet = ((java.util.Collection) value2).isEmpty();\n        } else if (value2 instanceof java.util.Iterator) {\n            java.util.Iterator it = (java.util.Iterator) value2;\n            if (!it.hasNext()) {\n                v2IsEmptyNodeSet = true;\n            }\n        }\n\n        // According to XPath 1.0 specification for comparisons involving node-sets and numbers:\n        // An empty node-set, when converted to a number, becomes NaN (Not a Number).\n        // All comparisons involving NaN (except NaN != NaN) evaluate to false.\n        // However, the provided tests indicate a behavior where comparisons between an empty node-set\n        // and a number should generally result in Boolean.FALSE for all operators (including !=).\n        // This implies a specific interpretation in JXPath for empty node-set comparisons.\n        // The fix aligns with passing all provided `testEmptyNodeSetOperations`.\n        if ((v1IsEmptyNodeSet && value2 instanceof Number) || (v2IsEmptyNodeSet && value1 instanceof Number)) {\n            return Boolean.FALSE;\n        }\n\n        // Original logic for other cases or when the specific empty node-set vs number rule doesn't apply\n        return compute(value1, value2) ? Boolean.TRUE : Boolean.FALSE;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}