{
    "generation": "import java.util.Collection;\nimport java.util.Iterator;\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.compiler.NodeSet;\n\n// The class containing this method is org.apache.commons.jxpath.ri.compiler.CoreOperation\n// The 'compute' method is an abstract protected method in CoreOperation,\n// implemented by its subclasses (e.g., CoreOperationGreaterThanOrEqual).\n// 'args' is a protected field in CoreOperation, an array of Expression objects.\npublic final Object computeValue(EvalContext context) {\n    Object value1 = args[0].computeValue(context);\n    Object value2 = args[1].computeValue(context);\n\n    // According to XPath 1.0, when a comparison involves a NodeSet,\n    // it's true if any item in the first NodeSet (or its value)\n    // meets the condition with any item in the second NodeSet (or its value).\n    // If either NodeSet is empty, the comparison is false.\n    // This logic is specifically for relational operators (like =, !=, <, >, <=, >=).\n\n    // Convert NodeSet objects to their underlying collection of values.\n    // NodeSet implements Collection, and getValues() provides the actual node values.\n    if (value1 instanceof NodeSet) {\n        value1 = ((NodeSet) value1).getValues();\n    }\n    if (value2 instanceof NodeSet) {\n        value2 = ((NodeSet) value2).getValues();\n    }\n\n    // Handle comparisons where one or both operands are collections (NodeSets).\n    if (value1 instanceof Collection && value2 instanceof Collection) {\n        // Both operands are collections. Iterate through all combinations.\n        Iterator it1 = ((Collection) value1).iterator();\n        while (it1.hasNext()) {\n            Object o1 = it1.next();\n            Iterator it2 = ((Collection) value2).iterator();\n            while (it2.hasNext()) {\n                Object o2 = it2.next();\n                if (compute(o1, o2)) {\n                    return Boolean.TRUE; // Found a pair that satisfies the comparison\n                }\n            }\n        }\n        return Boolean.FALSE; // No pair satisfied the comparison\n    } else if (value1 instanceof Collection) {\n        // Only the first operand is a collection. Iterate through it.\n        Iterator it = ((Collection) value1).iterator();\n        while (it.hasNext()) {\n            if (compute(it.next(), value2)) {\n                return Boolean.TRUE; // Found an element that satisfies the comparison\n            }\n        }\n        return Boolean.FALSE; // No element satisfied the comparison\n    } else if (value2 instanceof Collection) {\n        // Only the second operand is a collection. Iterate through it.\n        Iterator it = ((Collection) value2).iterator();\n        while (it.hasNext()) {\n            if (compute(value1, it.next())) {\n                return Boolean.TRUE; // Found an element that satisfies the comparison\n            }\n        }\n        return Boolean.FALSE; // No element satisfied the comparison\n    } else {\n        // Neither operand is a collection. Perform a direct comparison.\n        return compute(value1, value2) ? Boolean.TRUE : Boolean.FALSE;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}