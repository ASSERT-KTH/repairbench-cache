{
    "generation": "import org.apache.commons.jxpath.util.ValueUtils;\n\n    public final Object computeValue(EvalContext context) {\n        Object v1 = args[0].computeValue(context);\n        Object v2 = args[1].computeValue(context);\n\n        // XPath 1.0 spec section 3.4:\n        // If one object to be compared is a node-set and the other is a number,\n        // then the comparison will be true if and only if there is a node in the\n        // node-set such that the result of performing the comparison on the number\n        // value of the node and the other number is true.\n        // Similar rules apply for node-set vs string and node-set vs boolean.\n        // Crucially, if the node-set is empty, \"there is a node\" is never true,\n        // so the comparison MUST be false for =, !=, <, >, <=, >=.\n\n        // Check if either operand represents a node-set or collection using ValueUtils.\n        boolean v1IsCollection = ValueUtils.isCollection(v1);\n        boolean v2IsCollection = ValueUtils.isCollection(v2);\n\n        // If either operand is an empty collection/node-set, the result of the comparison is false.\n        // ValueUtils.sizeOf handles various collection/iterator types and returns their size.\n        if ((v1IsCollection && ValueUtils.sizeOf(v1) == 0)\n                || (v2IsCollection && ValueUtils.sizeOf(v2) == 0)) {\n            return Boolean.FALSE;\n        }\n\n        // If neither is an empty node-set, proceed with the original computation logic.\n        return compute(v1, v2) ? Boolean.TRUE : Boolean.FALSE;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}