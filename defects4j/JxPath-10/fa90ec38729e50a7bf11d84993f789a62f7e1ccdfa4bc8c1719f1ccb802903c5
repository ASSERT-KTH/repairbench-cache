{
    "generation": "    public final Object computeValue(EvalContext context) {\n        Object value1 = args[0].computeValue(context);\n        Object value2 = args[1].computeValue(context);\n\n        // According to XPath 1.0 rules for comparisons involving node-sets:\n        // If one of the operands is an empty node-set, the comparison is always false.\n        // This applies to all comparison operators (=, !=, <, <=, >, >=).\n        // This check must happen before delegating to the 'compute' method,\n        // as 'compute' might not explicitly handle empty node-sets in this manner.\n        if (value1 instanceof org.apache.commons.jxpath.ri.axes.NodeSet) {\n            org.apache.commons.jxpath.ri.axes.NodeSet ns1 = (org.apache.commons.jxpath.ri.axes.NodeSet) value1;\n            if (!ns1.getIterator().hasNext()) { // Check if the node set is empty\n                return Boolean.FALSE;\n            }\n        }\n        if (value2 instanceof org.apache.commons.jxpath.ri.axes.NodeSet) {\n            org.apache.commons.jxpath.ri.axes.NodeSet ns2 = (org.apache.commons.jxpath.ri.axes.NodeSet) value2;\n            if (!ns2.getIterator().hasNext()) { // Check if the node set is empty\n                return Boolean.FALSE;\n            }\n        }\n        \n        // If neither operand is an empty node-set, proceed with the standard computation\n        // by delegating to the 'compute' method. The 'compute' method is expected to\n        // handle the actual comparison logic, including type conversions for numbers,\n        // booleans, strings, and non-empty node sets.\n        return compute(value1, value2) ? Boolean.TRUE : Boolean.FALSE;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}