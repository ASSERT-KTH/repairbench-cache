{
    "generation": "  /**\n   * Check whether there's any property conflict for for a particular super\n   * interface\n   * @param t The node traversal object that supplies context\n   * @param n The node being visited\n   * @param functionName The function name being checked\n   * @param properties The property names in the super interfaces that have\n   * been visited\n   * @param currentProperties The property names in the super interface\n   * that have been visited\n   * @param interfaceType The super interface that is being visited\n   */\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    // Handle cases where the interface type might be null or a proxy to an unknown type,\n    // which can occur with bad annotations like extending non-existent interfaces.\n    if (interfaceType == null || interfaceType.isUnknownType()) {\n      return; // Nothing to check for null or unknown types.\n    }\n\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n\n    // Check if the implicit prototype is null. This can happen if interfaceType\n    // is a proxy to a non-existent object (a bad type annotation), or for\n    // other reasons like structural interfaces.\n    if (implicitProto != null) {\n      Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();\n      for (String name : currentPropertyNames) {\n        ObjectType oType = properties.get(name);\n        if (oType != null) {\n          // Ensure both property types exist before comparing.\n          // JSType#isEquivalentTo should handle nulls or UnknownType gracefully,\n          // but direct comparison is safer if getPropertyType might return null unexpectedly.\n          JSType propType1 = interfaceType.getPropertyType(name);\n          JSType propType2 = oType.getPropertyType(name);\n          // Check for null defensively, although isEquivalentTo often handles this.\n          // If either type is null or couldn't be resolved, consider it not equivalent\n          // unless both are similarly unresolved/null? The isEquivalentTo method\n          // should define the correct semantics here.\n          if (propType1 != null && propType2 != null && !propType1.isEquivalentTo(propType2)) {\n            compiler.report(\n                t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                    functionName, name, oType.toString(),\n                    interfaceType.toString()));\n          } else if (propType1 == null || propType2 == null) {\n             // If one type is null and the other isn't, they are not equivalent.\n             // However, reporting this might be too noisy if types couldn't be resolved\n             // for reasons already reported (like unknown type).\n             // Let's stick to the original logic's reliance on isEquivalentTo,\n             // assuming it handles null/unknown appropriately.\n             // Reverting the explicit null check here based on that assumption.\n             if (!interfaceType.getPropertyType(name).isEquivalentTo(\n                 oType.getPropertyType(name))) {\n               compiler.report(\n                   t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                       functionName, name, oType.toString(),\n                       interfaceType.toString()));\n             }\n          }\n        }\n        // Record the property and the interface it's associated with in this path.\n        currentProperties.put(name, interfaceType);\n      }\n    }\n\n    // Recursively check the interfaces this interface extends.\n    // The recursive call will handle null/unknown types at its start.\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}