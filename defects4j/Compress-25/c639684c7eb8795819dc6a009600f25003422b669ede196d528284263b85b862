{
    "generation": "    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        // The constructor previously used buf.capacity() (8192) as the PushbackInputStream size.\n        // While not obviously incorrect, using a smaller size, like 1, decouples the pushback\n        // buffer size from the inflater buffer size and is sufficient for the single byte unread\n        // operation used in fillInflaterBuffer(). This change might avoid subtle bugs related\n        // to buffering interaction or PushbackInputStream implementation details with large buffer sizes,\n        // potentially fixing issues where the stream state is incorrect after reading headers,\n        // leading to incorrect data being read for the first entry.\n        in = new PushbackInputStream(inputStream, 1); // Changed size from buf.capacity() to 1\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        // Ensure the inflater buffer starts empty. While likely not the primary cause\n        // for the STORED entry issue, it's good practice.\n        buf.position(0);\n        buf.limit(0);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}