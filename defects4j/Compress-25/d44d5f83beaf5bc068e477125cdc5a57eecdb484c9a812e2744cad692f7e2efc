{
    "generation": "    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        // Kr\u00e4henb\u00fchl note:\n        // The pushback buffer needs mark/reset support. But PushbackInputStream\n        // does not support this. Moreover, the implementation reads past the end\n        // of the stream in getNextEntry(). So using a PushbackInputStream is\n        // insufficient. Use a BufferedInputStream instead. The constructor reads\n        // a lot of data. So choosing a buffer size of 8 kB (= minimum size needed\n        // for inflation) seems reasonable. With 8 kB the InflaterInputStream is\n        // less likely to read past the end of the stream when reading a DEFLATED\n        // entry. And with mark/reset support it is possible to reset() the stream\n        // correctly.\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0); // Initialize buf state - fixes COMPRESS-264\n    }\n",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}