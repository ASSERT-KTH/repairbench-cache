{
    "generation": "  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    String rootName = null;\n\n    if (node.isName()) {\n      // If node is a simple name (e.g., 'x'), its \"root\" is itself.\n      rootName = node.getString();\n    } else {\n      // If node is a GETPROP (e.g., 'x.y.z'), traverse down to find the root name.\n      Preconditions.checkArgument(node.isGetProp());\n      Node current = node;\n      while (current.isGetProp()) {\n        current = current.getFirstChild();\n      }\n      if (current.isName()) {\n        rootName = current.getString();\n      }\n    }\n\n    // If we couldn't find a root name (e.g., node is `(1+2).prop`), then it's\n    // always safe from a name-aliasing perspective.\n    if (rootName == null) {\n      return true;\n    }\n\n    // Check 1: The root name of 'node' is assigned to within the 'replacement' expression.\n    // E.g., node is `a.b`, replacement is `(a=1, 2)`. This is unsafe.\n    // E.g., node is `x`, replacement is `(x=1, 2)`. This is unsafe.\n    if (isNameAssignedTo(rootName, replacement)) {\n      return false;\n    }\n\n    // Check 2: The 'replacement' itself is a NAME node, and it's the same name\n    // as the root of 'node'. This covers the issue in testIssue1017.\n    // E.g., node: `x.parentNode.parentNode`, rootName: \"x\", replacement: `x`.\n    // This is unsafe because 'x' refers to the variable that was just modified\n    // by the assignment. Replacing an expression depending on x (like x.prop)\n    // with x itself, when x was just assigned that expression, changes semantics.\n    if (replacement.isName() && rootName.equals(replacement.getString())) {\n      return false;\n    }\n\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}