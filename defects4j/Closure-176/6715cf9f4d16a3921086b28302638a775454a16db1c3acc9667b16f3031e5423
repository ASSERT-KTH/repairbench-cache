{
    "generation": "  /**\n   * Updates the scope according to the result of a type change, like\n   * an assignment or a type cast.\n   */\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        boolean isVarDeclaration = left.hasChildren();\n        // Note: left represents the NAME node (variable itself).\n\n        // In a var declaration with a declared type (e.g., /** @type {Foo} */ var x = ...;),\n        // we usually want to keep the declared type in the scope, even if the\n        // initial assigned type is narrower. This preserves the programmer's intent and\n        // constraints like {Object<string>}.\n        // However, if null or undefined is assigned, the variable clearly holds that value\n        // at this point in the flow. The scope *must* reflect this for subsequent checks\n        // (like property access) to be accurate.\n\n        // Determine if we should update the scope with the resultType.\n        boolean updateScope = true; // Default to updating the scope.\n        if (isVarDeclaration && var != null && !var.isTypeInferred()) {\n          // This is a VAR declaration with an explicit JSDoc type annotation.\n          // Check if the assigned type is null or undefined.\n          if (resultType.isNullType() || resultType.isVoidType()) {\n            // Assigning null or undefined. Update scope to reflect the actual value.\n            updateScope = true;\n          } else {\n            // Assigning some other type. Keep the stronger declared type in the scope.\n            // This handles cases like:\n            // /** @type {Object<string>} */ var x = {}; (scope keeps Object<string>)\n            // /** @param ... */ var f = goog.abstractMethod; (scope keeps function type)\n            updateScope = false;\n          }\n        }\n        // For non-declarations, or declarations without explicit types, or inferred types,\n        // updateScope remains true (the default), so the scope reflects the assigned type.\n\n        if (updateScope) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n\n        // Set the JSType for the NAME node itself.\n        // Original logic: If it's a VAR decl or LHS had no type, use resultType, else null.\n        // This seems related to how the node itself is typed in the AST, possibly separate\n        // from the flow scope's tracking of the variable's type. Let's keep it.\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        // Update the type on the Var object itself IF its type was originally inferred.\n        // This affects global type inference or later lookups of the Var's static type.\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          // Infer the type of the qualified name slot in the scope.\n          scope.inferQualifiedSlot(left, qualifiedName,\n              // If leftType is null (e.g., obj.prop = val when obj unknown), use unknown.\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        // Set the type of the GETPROP expression itself to the result type.\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}