{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.Map;\n// Assuming 'full' map and 'unescapePattern' are accessible static members of the enclosing class (e.g., Entities)\n// e.g. static Map<String, Character> full = loadEntities(\"entities-full.properties\");\n// e.g. static Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        // Use StringBuffer as required by Matcher's appendReplacement method\n        StringBuffer accum = new StringBuffer(string.length());\n\n        while (m.find()) {\n            int charval = -1; // Initialize with -1 indicating not found or invalid\n            String entityContent = m.group(1); // The content between '&' and ';', e.g., \"amp\", \"#36\", \"#x20AC\"\n\n            if (entityContent.startsWith(\"#\")) { // Numeric entity: &#...; or &#x...;\n                String num = m.group(3); // The numeric part, e.g., \"36\", \"20AC\"\n                if (num != null) {\n                    try {\n                        int base = m.group(2) != null ? 16 : 10; // group(2) is 'x' or 'X' for hex\n                        charval = Integer.parseInt(num, base);\n                        // Note: HTML5 has specific handling for invalid numeric codes (e.g., 0, C1 controls)\n                        // which might differ from this simple conversion.\n                        // For this fix, we stick to direct conversion.\n                    } catch (NumberFormatException e) {\n                        // num was not parsable, charval remains -1\n                    }\n                }\n            } else { // Named entity: &...;\n                // Assumes 'full' is a Map<String, Integer> containing named entities.\n                // The original code used Map<String, Character>, implying only BMP characters.\n                // If 'full' needs to support supplementary characters, its type should be Map<String, Integer>.\n                // For now, assuming the existing 'full' map structure is sufficient or correctly typed.\n                if (full.containsKey(entityContent)) {\n                    // If using Map<String, Character>, this might truncate supplementary chars if they were stored.\n                    // If using Map<String, Integer>, this correctly retrieves the codepoint.\n                     Object value = full.get(entityContent);\n                     if (value instanceof Character) {\n                         charval = ((Character) value).charValue();\n                     } else if (value instanceof Integer) {\n                         charval = ((Integer) value).intValue();\n                     } // else charval remains -1 if map value type is unexpected\n                }\n                // If entityContent is not in the map, charval remains -1\n            }\n\n            // Perform the replacement\n            if (charval != -1) { // If a valid character value was found\n                String replacement;\n                if (charval > Character.MAX_VALUE) {\n                    // Handle supplementary characters (outside BMP) correctly\n                    replacement = new String(Character.toChars(charval));\n                } else {\n                    // Handle BMP characters (including null char for &#0;)\n                    replacement = Character.toString((char) charval);\n                }\n                // IMPORTANT: Quote the replacement string to handle special characters\n                // like '$' and '\\' which have special meaning in appendReplacement.\n                m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n            } else {\n                // If charval is -1 (entity not recognized or invalid),\n                // append the original matched sequence (e.g., \"&unknown;\", \"&#invalid;\")\n                // No need to quote m.group(0) as it's the literal input string.\n                m.appendReplacement(accum, m.group(0));\n            }\n        }\n        m.appendTail(accum); // Append the remainder of the input string\n        return accum.toString();\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}