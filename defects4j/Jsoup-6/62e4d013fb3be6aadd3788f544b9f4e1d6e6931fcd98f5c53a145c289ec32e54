{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Assuming 'full' map and 'unescapePattern' are defined elsewhere as static members of the class\n// E.g.: import static org.jsoup.nodes.Entities.full;\n// E.g.: import static org.jsoup.parser.Parser.unescapePattern;\n// Also assuming 'full' is a Map<String, Integer> storing entity names to codepoints.\n\nclass FixedEntities { // Helper class name for wrapping the method\n\n    // Assume 'full' map and 'unescapePattern' pattern are accessible static members.\n    // These would be defined in the actual class (e.g., org.jsoup.nodes.Entities)\n    // static java.util.Map<String, Integer> full = ...;\n    // static Pattern unescapePattern = Pattern.compile(...);\n\n    static String unescape(String string) {\n        if (string == null || !string.contains(\"&\")) // Added null check for robustness\n            return string;\n\n        // Assuming unescapePattern is defined elsewhere as:\n        // Pattern.compile(\"&(#(?:x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n        Matcher m = unescapePattern.matcher(string);\n        StringBuffer accum = new StringBuffer(string.length()); // Using StringBuffer as in original code\n\n        while (m.find()) {\n            int charval = -1;\n            String wholeEntity = m.group(0); // The entire matched entity, e.g., \"&amp;\", \"&#123;\", \"&#xabc;\"\n            String nameOrNumber = m.group(1); // The part after '&', e.g., \"amp\", \"#123\", \"#xabc\"\n            String numericValue = m.group(3); // The numeric part if present, e.g., \"123\", \"abc\"\n\n            if (numericValue != null) {\n                // Numeric entity: &#123; or &#xabc;\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // group(2) is 'x' or 'X' for hex\n                    charval = Integer.parseInt(numericValue, base);\n                    // Additional validation could be added here for HTML5 compliance\n                    // (e.g., handling null bytes, surrogates, non-characters)\n                    // but we stick to basic unescaping + validity check for now.\n                } catch (NumberFormatException | IllegalArgumentException e) {\n                    // Invalid number format or value outside int range.\n                    // charval remains -1, entity will be appended as is.\n                }\n            } else if (nameOrNumber != null) {\n                // Named entity: &amp; (Check it's not a malformed numeric like \"&#abc;\")\n                 if (!nameOrNumber.startsWith(\"#\") && full.containsKey(nameOrNumber)) {\n                    // Assume 'full' is Map<String, Integer> mapping name to codepoint\n                    charval = full.get(nameOrNumber);\n                 }\n                 // If name not found in 'full', or if it was malformed numeric, charval remains -1.\n            }\n            // If neither numericValue nor nameOrNumber matched (e.g., \"&;\"), charval remains -1.\n\n            if (charval != -1) { // A valid codepoint was determined\n                // Check if the codepoint is valid according to Unicode standard\n                if (Character.isValidCodePoint(charval)) {\n                    String replacement;\n                    if (charval > Character.MAX_VALUE) { // Outside BMP, handle as supplementary character\n                        replacement = new String(Character.toChars(charval));\n                    } else { // BMP character\n                        replacement = Character.toString((char) charval);\n                    }\n                    // Use Matcher.quoteReplacement to escape special characters like '$' and '\\'\n                    // in the replacement string, preventing IllegalArgumentException.\n                    m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n                } else {\n                    // The parsed codepoint is invalid (e.g., > 0x10FFFF), treat as unrecognized.\n                    m.appendReplacement(accum, wholeEntity); // Append original entity text\n                }\n            } else {\n                // Entity was not recognized or invalid (charval == -1).\n                m.appendReplacement(accum, wholeEntity); // Append original entity text\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n\n    // Dummy fields needed if compiling this snippet standalone\n    // In the actual context, these would be provided by the surrounding class.\n    private static final java.util.Map<String, Integer> full = new java.util.HashMap<>();\n    static {\n        full.put(\"amp\", 38); full.put(\"lt\", 60); full.put(\"gt\", 62); full.put(\"quot\", 34);\n        // ... etc, load all entities needed\n    }\n    private static final Pattern unescapePattern = Pattern.compile(\"&(#(?:x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}