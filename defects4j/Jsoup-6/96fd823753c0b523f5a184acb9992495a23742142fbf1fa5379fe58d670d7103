{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.Map; // Assuming 'full' is a Map defined elsewhere\n\nclass Entities {\n    // Assume unescapePattern and full map are defined elsewhere, e.g.:\n    // private static final Pattern unescapePattern = Pattern.compile(\"&(?:#(x|X)?([0-9a-fA-F]+)|([a-zA-Z]+));?\");\n    // private static final Map<String, Integer> full = loadEntities(); // some method to load HTML entities\n\n    private static final Pattern unescapePattern = Pattern.compile(\"&(?:#(x|X)?([0-9a-fA-F]+)|([a-zA-Z]+));?\");\n    // Example map, replace with actual entity map used by Jsoup\n    private static final Map<String, Integer> full = Map.of(\"amp\", 38, \"lt\", 60, \"gt\", 62, \"quot\", 34, \"nbsp\", 160);\n\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Assuming pattern is: & (?: #(x|X)? ([0-9a-fA-F]+) | ([a-zA-Z]+) );?\n        // Group 1: (x|X)? hex indicator\n        // Group 2: ([0-9a-fA-F]+) numeric value\n        // Group 3: ([a-zA-Z]+) name\n        Matcher m = unescapePattern.matcher(string);\n        // Using StringBuffer as in the original code, though StringBuilder is generally preferred.\n        StringBuffer accum = new StringBuffer(string.length());\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(2); // Numeric value group\n            String name = m.group(3); // Named entity group\n\n            if (num != null) { // Numeric entity: &#DDDD; or &#xHHHH;\n                try {\n                    String hexIndicator = m.group(1); // Hex indicator group 'x' or 'X'\n                    int base = (hexIndicator != null) ? 16 : 10;\n                    charval = Integer.parseInt(num, base);\n                } catch (NumberFormatException e) {\n                    // num matched regex but failed parse? Should be rare.\n                    // Keep charval = -1 to append original text.\n                }\n            } else if (name != null) { // Named entity: &NAME;\n                if (full.containsKey(name)) {\n                    charval = full.get(name);\n                }\n                // If name not in map, charval remains -1.\n            }\n\n            if (charval != -1) { // If a valid entity was found and decoded to a codepoint\n                // Check if the codepoint is valid Unicode.\n                if (Character.isValidCodePoint(charval)) {\n                    // Convert codepoint to String (handles supplementary characters correctly)\n                    String decoded = new String(Character.toChars(charval));\n                    // *** FIX: Use Matcher.quoteReplacement to handle special replacement chars like $ and \\ ***\n                    m.appendReplacement(accum, Matcher.quoteReplacement(decoded));\n                } else {\n                    // If charval from map or parsing is invalid, treat as unrecognized. Append original.\n                    // Use quoteReplacement here too for consistency, although m.group(0) is less likely to need it.\n                    m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n                }\n            } else { // Entity not recognized (numeric parse failed, name not in map, or malformed entity matched)\n                // Append the original matched text.\n                // Use quoteReplacement here too for consistency.\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}