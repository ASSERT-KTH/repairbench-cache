{
    "generation": "    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Assuming unescapePattern and full are accessible (e.g., static fields in the same class)\n        // unescapePattern regex: &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        Matcher m = unescapePattern.matcher(string);\n        StringBuffer accum = new StringBuffer(string.length()); \n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3); // Captured numeric value for numeric entities (e.g., \"92\" from \"&#92;\")\n            if (num != null) {\n                try {\n                    // group(2) captures 'x' or 'X' indicating a hexadecimal entity\n                    int base = m.group(2) != null ? 16 : 10; \n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                    // If the number is malformed, charval remains -1, causing the original entity to be preserved.\n                }\n            } else {\n                String name = m.group(1); // Captured name for named entities (e.g., \"amp\" from \"&amp;\")\n                // 'full' is presumed to be a Map<String, Integer> containing entity name to charval mappings\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            // Check if charval is a valid Unicode code point.\n            // If charval is -1 (not found/parsed) or not a valid Unicode code point,\n            // then the original matched entity string should be kept.\n            if (charval != -1 && Character.isValidCodePoint(charval)) {\n                // Convert the integer charval to a String.\n                // Character.toChars() handles all Unicode code points, including those outside the Basic Multilingual Plane (BMP),\n                // by returning a char array (e.g., surrogate pairs).\n                String c = String.valueOf(Character.toChars(charval));\n                \n                // Use Matcher.quoteReplacement to treat backslashes (\\) and dollar signs ($) in the\n                // replacement string literally. This prevents IllegalArgumentException if 'c' contains them.\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                // If charval is invalid or not found, append the original matched entity string (m.group(0)).\n                // Also quote this replacement to handle cases where the original entity text\n                // might contain special regex characters (though less common for entities).\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}