{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Entities { // Assuming Entities class is relevant for constants\n    // These static fields are assumed to be present in the original context.\n    // full and unescapePattern are likely initialized elsewhere in the class.\n    // For example:\n    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n    private static final java.util.HashMap<String, Integer> full = new java.util.HashMap<>();\n    static {\n        // Populate 'full' map with HTML entities, e.g.,\n        // full.put(\"amp\", 38);\n        // full.put(\"lt\", 60);\n        // full.put(\"gt\", 62);\n        // full.put(\"quot\", 34);\n        // full.put(\"apos\", 39);\n        // full.put(\"dollar\", 36); // for &#36;\n        // full.put(\"bsol\", 92);   // for &#92;\n        // The actual map population is external to this function.\n    }\n\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } // skip\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            // The original condition `charval != -1 || charval > 0xFFFF` is redundant\n            // because `charval > 0xFFFF` implies `charval != -1`.\n            // If `charval` is -1 (entity not found or invalid), it should fall to the else block.\n            // If `charval` is a valid code point (0 to 0x10FFFF), it should be unescaped.\n            if (charval != -1) {\n                // Character.toString((char) charval) truncates code points > 0xFFFF.\n                // Character.toChars handles supplementary code points (U+10000 to U+10FFFF)\n                // by returning a char array for surrogate pairs.\n                // new String(char[]) then creates the correct string.\n                // Matcher.appendReplacement requires special characters like '\\' and '$' to be escaped.\n                // Matcher.quoteReplacement handles this correctly.\n                String c = new String(Character.toChars(charval));\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                // If charval is -1 (entity not recognized or parse error),\n                // revert to the original matched string.\n                m.appendReplacement(accum, m.group(0));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}