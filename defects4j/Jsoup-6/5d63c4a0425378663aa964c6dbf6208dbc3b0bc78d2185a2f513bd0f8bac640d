{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Assuming unescapePattern and full map are available in the class scope.\n// For example:\n// private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n// private static final java.util.Map<String, Integer> full = new java.util.HashMap<>();\n\n// This class definition is for context, only the unescape function is requested.\n// public class Entities {\n//    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n//    private static final java.util.Map<String, Integer> full = new java.util.HashMap<>();\n//\n//    // ... static initializer for 'full' map\n// }\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        StringBuffer accum = new StringBuffer(string.length()); \n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } // skip\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            if (charval != -1 || charval > 0xFFFF) { // out of range\n                String c = Character.toString((char) charval);\n                // Fix: Properly escape the replacement string to prevent IllegalArgumentException\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                // Fix: Also quote the original matched string for robustness, though less likely to be the direct cause\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}