{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Assume Entities.full (Map<String, Integer>) and Entities.unescapePattern (Pattern) are defined and accessible statically.\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // The pattern matches entities like &amp; &#123; &#x41;\n        // Group 1: The whole content between & and ; (e.g., \"#123\", \"#x41\", \"amp\")\n        // Group 2: Hex indicator (x or X) for numeric entities\n        // Group 3: Numeric value (decimal or hex)\n        Matcher m = Entities.unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z0-9]+);? - adjusted pattern to include digits in names\n        StringBuffer accum = new StringBuffer(string.length());\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3); // Numeric value group\n            if (num != null) {\n                // Numeric entity\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // group(2) is hex indicator\n                    charval = Integer.parseInt(num, base);\n                } catch (NumberFormatException e) {\n                    // ignore, leave charval as -1\n                }\n            } else {\n                // Named entity\n                String name = m.group(1); // This captures the name when group 3 is null\n                // Note: The original pattern [a-zA-Z]+ might be too restrictive.\n                // HTML5 allows digits, e.g., &pi; &Pi; &delta;\n                // Assuming the pattern used is actually something like &(#...|([a-zA-Z0-9]+));?\n                // Let's assume `Entities.full` contains the mapping for valid names.\n                if (Entities.full.containsKey(name)) {\n                    charval = Entities.full.get(name);\n                }\n                // If name not in map, charval remains -1\n            }\n\n            // Now replace the found entity:\n            if (charval != -1) { // if valid entity found (numeric or named)\n                String replacement;\n                if (charval > 0xFFFF) { // handle supplementary characters (outside BMP)\n                    replacement = new String(Character.toChars(charval));\n                } else { // handle BMP characters\n                    replacement = String.valueOf((char) charval);\n                }\n                // *** FIX: Use Matcher.quoteReplacement to escape special characters like $ and \\ ***\n                m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n            } else {\n                // If charval is -1 (e.g., invalid numeric like &#;, unknown name like &foo;),\n                // then keep the original matched string. Use quoteReplacement for safety.\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n\n    // Dummy definitions for compilation context, assuming these exist in the actual Entities class\n    private static class Entities {\n        static final Pattern unescapePattern = Pattern.compile(\"&(?:#(?:(x|X)?([0-9a-fA-F]+))|([a-zA-Z0-9]+));?\"); // Adjusted pattern with non-capturing group and digits in name\n        static final java.util.Map<String, Integer> full = new java.util.HashMap<>();\n        static {\n            // Populate map with some examples for context\n            full.put(\"amp\", 38);\n            full.put(\"lt\", 60);\n            full.put(\"gt\", 62);\n            full.put(\"quot\", 34);\n            // ... etc\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}