{
    "generation": "    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Pattern for HTML entities: &#ddd; &#xhhh; &name;\n        // Group 1: entity name (e.g., \"amp\") or numerical part (e.g., \"#123\" or \"#xABC\")\n        // Group 2: \"x\" or \"X\" for hexadecimal\n        // Group 3: numerical value (e.g., \"123\" or \"ABC\")\n        // Note: unescapePattern is expected to be a pre-compiled Pattern object,\n        // typically defined as: Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n        Matcher m = unescapePattern.matcher(string); \n        StringBuffer accum = new StringBuffer(string.length()); \n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3); // numerical entity value (e.g., \"123\" or \"ABC\")\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // Group 2 captures 'x' or 'X' for hex\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                    // If parsing fails, charval remains -1, and the original entity will be kept.\n                } \n            } else {\n                String name = m.group(1); // named entity (e.g., \"amp\")\n                // 'full' is expected to be a Map<String, Integer> containing known HTML entities.\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            if (charval != -1) { // A valid character value was successfully parsed\n                String c;\n                if (charval > 0xFFFF) { // Handle supplementary characters (Unicode code points > U+FFFF)\n                    // These require surrogate pairs, Character.toString((char) charval) would truncate.\n                    c = new String(Character.toChars(charval));\n                } else { // Basic multilingual plane characters\n                    c = Character.toString((char) charval);\n                }\n                // Matcher.appendReplacement treats '\\' and '$' as special characters.\n                // To insert them literally, they must be quoted using Matcher.quoteReplacement.\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else { \n                // Charval is -1, meaning the entity was not recognized or invalid (e.g., &unknown;).\n                // In this case, keep the original entity string.\n                // It's also good practice to quote m.group(0) in case the matched entity string\n                // itself contains characters that are special to appendReplacement (unlikely for entities).\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum); // Append any remaining part of the string after the last match\n        return accum.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}