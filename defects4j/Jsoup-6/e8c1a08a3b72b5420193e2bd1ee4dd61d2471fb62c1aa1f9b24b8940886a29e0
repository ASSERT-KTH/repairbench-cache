{
    "generation": "import java.util.Map; // Assuming 'full' is a Map, add import if needed\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Assuming 'unescapePattern' (Pattern) and 'full' (Map<String, Integer>) are defined elsewhere as static members\n\n    static String unescape(String string) {\n        // Quick check to avoid regex allocation and processing for strings without entities\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Pattern should match HTML entities: &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n        // Example: &amp; &#123; &#xabc;\n        Matcher m = unescapePattern.matcher(string);\n        // StringBuffer is required by Matcher.appendReplacement API\n        StringBuffer accum = new StringBuffer(string.length());\n\n        while (m.find()) {\n            int charval = -1; // Decoded character value, or -1 if not decoded\n            String num = m.group(3); // Group 3 captures the numeric digits if it's a numeric entity\n\n            if (num != null) { // It's a numeric entity (e.g., &#123;, &#xabc;)\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // Group 2 captures 'x' or 'X' for hex base\n                    charval = Integer.parseInt(num, base);\n                } catch (NumberFormatException e) {\n                    // Ignore parse error; charval remains -1\n                    // This handles cases like &#invalid;\n                }\n            } else { // It's potentially a named entity (e.g., &amp;)\n                String name = m.group(1); // Group 1 captures the name if it's a named entity\n                // The regex design ensures that if group 3 (num) is null, group 1 holds the name.\n                if (name != null && full.containsKey(name)) { // Check if the name is a known entity\n                    charval = full.get(name);\n                }\n                // If name is null (e.g. lone '&') or not in the map, charval remains -1\n            }\n\n            if (charval != -1) { // Successfully decoded a numeric or named entity to a codepoint\n                // Check if the decoded codepoint is a valid Unicode character\n                // (prevents values > 0x10FFFF)\n                if (Character.isValidCodePoint(charval)) {\n                    // Convert codepoint to String, handling supplementary characters correctly\n                    String replacement = new String(Character.toChars(charval));\n                    // Use Matcher.quoteReplacement to escape special characters (like $ or \\)\n                    // in the replacement string, which are otherwise interpreted by appendReplacement.\n                    m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n                } else {\n                    // The decoded number is not a valid Unicode code point.\n                    // Append the original matched sequence (e.g., &#xfffffff;) without replacement.\n                    // Still quote it in case the original sequence contains $ or \\.\n                    m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n                }\n            } else {\n                // Failed to decode the entity (e.g., unknown name &foo;, malformed numeric &#;, empty &#;)\n                // Append the original matched sequence (e.g., &foo;) without replacement.\n                // Still quote it in case the original sequence contains $ or \\.\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n        m.appendTail(accum); // Append the rest of the input string that didn't contain any matches\n        return accum.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}