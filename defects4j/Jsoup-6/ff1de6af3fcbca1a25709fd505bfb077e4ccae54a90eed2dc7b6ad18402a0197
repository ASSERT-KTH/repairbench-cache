{
    "generation": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.Map;\n// Assume necessary imports and that 'unescapePattern' and 'full' map exist and are correctly defined elsewhere.\n// For context, typical definitions might be:\n// private static final Pattern unescapePattern = Pattern.compile(\"&(#(?:x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n// private static final Map<String, Integer> full = Entities.fullMap; // Or equivalent map\n\n    static String unescape(String string) {\n        if (!string.contains(\"&\"))\n            return string;\n\n        // Assume unescapePattern is defined elsewhere, e.g.:\n        // Pattern.compile(\"&(#(?:x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n        Matcher m = unescapePattern.matcher(string);\n        StringBuffer accum = new StringBuffer(string.length());\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3); // Numeric value group\n            if (num != null) {\n                // Numeric entity\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // group(2) is hex indicator 'x' or 'X'\n                    charval = Integer.parseInt(num, base);\n                } catch (NumberFormatException e) {\n                    // Keep charval = -1; invalid numeric entity format\n                }\n            } else {\n                // Named entity\n                String name = m.group(1); // group(1) holds the name if num is null\n                // Assume 'full' is the map of named entities to codepoints, defined elsewhere\n                if (full.containsKey(name)) {\n                    charval = full.get(name);\n                }\n                // else keep charval = -1; unknown named entity\n            }\n\n            if (charval != -1) {\n                // Valid entity found, convert codepoint to string\n                // Handle supplementary characters (codepoint > 0xFFFF) correctly using Character.toChars\n                String replacement = new String(Character.toChars(charval));\n                // Quote the replacement string for appendReplacement,\n                // as it might contain literal '$' or '\\' characters.\n                m.appendReplacement(accum, Matcher.quoteReplacement(replacement));\n            } else {\n                // Invalid or unknown entity, append the original matched sequence.\n                // No need to quote m.group(0) as it's the original literal string.\n                m.appendReplacement(accum, m.group(0));\n            }\n        }\n        m.appendTail(accum);\n        return accum.toString();\n    }\n\n// Assume 'full' map is available in the scope, e.g., as a static member of the class.\n// private static final Map<String, Integer> full = // ... initialize map ...;",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}