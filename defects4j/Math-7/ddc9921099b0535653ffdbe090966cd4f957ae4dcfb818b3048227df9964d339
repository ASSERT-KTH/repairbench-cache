{
    "generation": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            if (!statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occurringEvents = new TreeSet<>(new Comparator<EventState>() {\n                @Override\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n\n            for (EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    occurringEvents.add(state);\n                }\n            }\n\n            while (!occurringEvents.isEmpty()) {\n                Iterator<EventState> iterator = occurringEvents.iterator();\n                EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                double eventT = currentEvent.getEventTime();\n\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                interpolator.setInterpolatedTime(eventT);\n                double[] eventY = interpolator.getInterpolatedState().clone();\n\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                for (StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (EventState remaining : occurringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                boolean needReset = currentEvent.reset(eventT, eventY);\n                if (needReset) {\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    for (EventState remaining : occurringEvents) {\n                        remaining.stepAccepted(eventT, eventY);\n                    }\n                    return eventT;\n                }\n\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                if (currentEvent.evaluateStep(interpolator)) {\n                    occurringEvents.add(currentEvent);\n                }\n            }\n\n            interpolator.setInterpolatedTime(currentT);\n            double[] currentY = interpolator.getInterpolatedState();\n            for (EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}