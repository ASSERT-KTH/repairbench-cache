{
    "generation": "/** Accept a step, triggering events and step handlers.\n * @param interpolator step interpolator\n * @param y state vector at step end time, must be reset if an event\n * asks for resetting or if an event stops integration during the step\n * @param yDot placeholder array where to put the time derivative of the state vector\n * @param tEnd final integration time\n * @return time at end of step\n * @exception MaxCountExceededException if the interpolator throws one because\n * the number of functions evaluations is exceeded\n * @exception NoBracketingException if the location of an event cannot be bracketed\n * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n * @since 2.2\n */\nprotected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n    double previousT = interpolator.getGlobalPreviousTime();\n    final double currentT  = interpolator.getGlobalCurrentTime();\n\n    // initialize the events states if needed\n    if (!statesInitialized) {\n        for (EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n        statesInitialized = true;\n    }\n\n    final boolean forward      = interpolator.isForward();\n    final int     orderingSign = forward ? +1 : -1;\n\n    // collect all events strictly inside the step [previousT, currentT]\n    SortedSet<EventState> occuringEvents =\n        new TreeSet<EventState>(new Comparator<EventState>() {\n            public int compare(EventState es0, EventState es1) {\n                return orderingSign * Double.compare(es0.getEventTime(),\n                                                     es1.getEventTime());\n            }\n        });\n\n    // initial scan for events inside the step\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n            final double eventT = state.getEventTime();\n            if (forward ? (eventT > previousT && eventT < currentT)\n                        : (eventT < previousT && eventT > currentT)) {\n                occuringEvents.add(state);\n            }\n        }\n    }\n\n    // handle all the events found, in chronological order\n    while (!occuringEvents.isEmpty()) {\n\n        // the first event to occur\n        final Iterator<EventState> it = occuringEvents.iterator();\n        final EventState currentEvent = it.next();\n        it.remove();\n        final double eventT = currentEvent.getEventTime();\n\n        // restrict the interpolator to [previousT, eventT]\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n\n        // get the state at the event time\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState().clone();\n\n        // inform the event states\n        currentEvent.stepAccepted(eventT, eventY);\n        isLastStep = currentEvent.stop();\n\n        // handle the segment up to the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        if (isLastStep) {\n            // the event asked to stop integration\n            System.arraycopy(eventY, 0, y,    0, y.length);\n            for (final EventState remaining : occuringEvents) {\n                remaining.stepAccepted(eventT, eventY);\n            }\n            return eventT;\n        }\n\n        // handle a possible state reset\n        final boolean needReset = currentEvent.reset(eventT, eventY);\n        if (needReset) {\n            // state has changed, recompute derivatives\n            System.arraycopy(eventY, 0, y,    0, y.length);\n            computeDerivatives(eventT, y, yDot);\n            resetOccurred = true;\n            for (final EventState remaining : occuringEvents) {\n                remaining.stepAccepted(eventT, eventY);\n            }\n            return eventT;\n        }\n\n        // prepare the remaining part of the step [eventT, currentT]\n        previousT = eventT;\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(currentT);\n\n        // scan again for any events in the remaining substep\n        for (final EventState state : eventsStates) {\n            if (state.evaluateStep(interpolator)) {\n                final double nextT = state.getEventTime();\n                if (forward ? (nextT > previousT && nextT < currentT)\n                            : (nextT < previousT && nextT > currentT)) {\n                    occuringEvents.add(state);\n                }\n            }\n        }\n    }\n\n    // no more events in this step, handle the final segment [previousT, currentT]\n    interpolator.setInterpolatedTime(currentT);\n    final double[] currentY = interpolator.getInterpolatedState();\n    for (final EventState state : eventsStates) {\n        state.stepAccepted(currentT, currentY);\n        isLastStep = isLastStep || state.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n    // notify the step handlers of the last part of the step\n    for (final StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, isLastStep);\n    }\n\n    return currentT;\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}