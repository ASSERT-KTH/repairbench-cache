{
    "generation": "/** Accept a step, triggering events and step handlers.\n * @param interpolator step interpolator\n * @param y state vector at step end time, must be reset if an event\n * asks for resetting or if an events stops integration during the step\n * @param yDot placeholder array where to put the time derivative of the state vector\n * @param tEnd final integration time\n * @return time at end of step\n * @exception MaxCountExceededException if the interpolator throws one because\n * the number of functions evaluations is exceeded\n * @exception NoBracketingException if the location of an event cannot be bracketed\n * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n * @since 2.2\n */\nprotected double acceptStep(final AbstractStepInterpolator interpolator,\n                            final double[] y, final double[] yDot, final double tEnd)\n    throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n    double previousT = interpolator.getGlobalPreviousTime();\n    final double currentT = interpolator.getGlobalCurrentTime();\n\n    // initialize the events states if needed\n    if (! statesInitialized) {\n        for (EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n        statesInitialized = true;\n    }\n\n    // search for next events that may occur during the step\n    final int orderingSign = interpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n        /** {@inheritDoc} */\n        public int compare(EventState es0, EventState es1) {\n            int cmp = orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n            if (cmp != 0) {\n                return cmp;\n            }\n            // If two events have the same event time, preserve original ordering to ensure determinism\n            // since TreeSet requires unique keys, but two events can legitimately occur at the same time\n            // So distinguish by hash, or object identity\n            return System.identityHashCode(es0) - System.identityHashCode(es1);\n        }\n\n    });\n\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            occuringEvents.add(state);\n        }\n    }\n\n    while (!occuringEvents.isEmpty()) {\n\n        // handle the chronologically first event\n        final Iterator<EventState> iterator = occuringEvents.iterator();\n        final EventState currentEvent = iterator.next();\n        iterator.remove();\n\n        // restrict the interpolator to the first part of the step, up to the event\n        final double eventT = currentEvent.getEventTime();\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n\n        // get state at event time\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState().clone();\n\n        // advance all event states to current time, including for events at the same time\n        // Accept all events that occur at the current event time\n        List<EventState> handledEvents = new ArrayList<EventState>();\n        handledEvents.add(currentEvent);\n        // add any other events in occuringEvents at the same event time\n        for (EventState evt : occuringEvents) {\n            if (Precision.equalsIncludingNaN(evt.getEventTime(), eventT, 1)) {\n                handledEvents.add(evt);\n            }\n        }\n\n        boolean stop = false;\n        boolean needReset = false;\n        for (EventState evt : handledEvents) {\n            evt.stepAccepted(eventT, eventY);\n            stop = stop || evt.stop();\n        }\n\n        // handle the first part of the step, up to the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, stop);\n        }\n\n        if (stop) {\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            for (EventState remaining : eventsStates) {\n                if (!handledEvents.contains(remaining)) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n            }\n            return eventT;\n        }\n\n        for (EventState evt : handledEvents) {\n            needReset = needReset || evt.reset(eventT, eventY);\n        }\n        if (needReset) {\n            // some event handler has triggered changes that invalidate the derivatives, we need to recompute them\n            System.arraycopy(eventY, 0, y, 0, y.length);\n            computeDerivatives(eventT, y, yDot);\n            resetOccurred = true;\n            for (EventState remaining : eventsStates) {\n                if (!handledEvents.contains(remaining)) {\n                    remaining.stepAccepted(eventT, eventY);\n                }\n            }\n            return eventT;\n        }\n\n        // Remove all handled events from occuringEvents (those at the same event time)\n        for (int i = 1; i < handledEvents.size(); ++i) {\n            occuringEvents.remove(handledEvents.get(i));\n        }\n\n        // prepare handling of the remaining part of the step\n        previousT = eventT;\n        interpolator.setSoftPreviousTime(eventT);\n        interpolator.setSoftCurrentTime(currentT);\n\n        // check if any handled event occurs again in the remaining part of the step\n        for (EventState evt : handledEvents) {\n            if (evt.evaluateStep(interpolator)) {\n                occuringEvents.add(evt);\n            }\n        }\n    }\n\n    // last part of the step, after the last event\n    interpolator.setInterpolatedTime(currentT);\n    final double[] currentY = interpolator.getInterpolatedState();\n    for (final EventState state : eventsStates) {\n        state.stepAccepted(currentT, currentY);\n        isLastStep = isLastStep || state.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n    // handle the remaining part of the step, after all events if any\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, isLastStep);\n    }\n\n    return currentT;\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}