{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    // compare event times, giving priority to earlier events\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            boolean stepBecameLast = false; // Flag to indicate if an event requested stop\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                // Clone the state BEFORE triggering the event action, as the action might change the state\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // Check if the event triggers stop or reset. This calls the handler's eventOccurred method.\n                // The handler action (resetting state) can modify the eventY array passed to reset().\n                final boolean doesStop = currentEvent.stop(); // Calls handler.eventOccurred\n                final boolean doesReset = currentEvent.reset(eventT, eventY); // Calls handler.eventOccurred\n\n                // Handle the step segment ending at the event time.\n                // Pass the stop status determined by the current event.\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, doesStop);\n                }\n                stepBecameLast = stepBecameLast || doesStop; // Track if any event requested stop\n\n                if (doesStop || doesReset) {\n                    // Event requested stop or reset, integration has to end or restart at eventT.\n\n                    // Update the main state vector y with the state at event time.\n                    // Use the state stored in eventY, which might have been modified by the reset action.\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n\n                    // Update the internal state of ALL event states to reflect the step ending at eventT.\n                    // This ensures g0 is computed based on the final state y at eventT.\n                    for (final EventState state : eventsStates) {\n                         state.stepAccepted(eventT, y);\n                    }\n\n                    if (doesReset) {\n                        // Recompute derivatives after state reset\n                        computeDerivatives(eventT, y, yDot);\n                        resetOccurred = true;\n                    }\n\n                    // Return the event time as the endpoint of this step.\n                    return eventT;\n                }\n\n                // If neither stop nor reset, prepare handling of the remaining part of the step\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT); // Keep original target time\n\n                // Check if the same event occurs again in the remaining part of the step\n                // Need to evaluate based on the state after previous event handling (which didn't reset/stop)\n                // The interpolator is already set to [eventT, currentT]\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // The event occurs during the current step interval [eventT, currentT]\n                    occuringEvents.add(currentEvent);\n                }\n            } // End while loop processing events within the step\n\n            // Reaching here means the step completed normally up to currentT without stop/reset events.\n            final double finalT = currentT;\n\n            // Ensure interpolator covers the full step for final handler calls and state updates.\n            // This is important if the loop iterated and modified soft limits.\n            interpolator.setSoftPreviousTime(interpolator.getGlobalPreviousTime());\n            interpolator.setSoftCurrentTime(finalT);\n\n            // Get state at the end of the completed step.\n            interpolator.setInterpolatedTime(finalT);\n            final double[] currentY = interpolator.getInterpolatedState(); // Get final state\n\n            // Update the internal state of ALL event states to reflect the step ending at finalT.\n            // This ensures g0 is computed based on the final state currentY at finalT.\n            for (final EventState state : eventsStates) {\n                 state.stepAccepted(finalT, currentY);\n                 // DO NOT call stop() or reset() here again. The actions were handled inside the loop.\n            }\n\n            // Determine final 'isLastStep' status.\n            // It's true if any event in the loop requested stop, or if we reached tEnd.\n            isLastStep = stepBecameLast || Precision.equals(finalT, tEnd, 1);\n\n            // Trigger step handlers for the full completed step [previousGlobalTime, finalT].\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            // Return the time at the end of the step\n            return finalT;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}