{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            final double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // Loop to handle potential multiple events within the same step.\n            // The 't' variable represents the current start time for the *remaining* part of the step.\n            double t = previousT;\n\n            while (true) {\n\n                // 1. Set the interpolator's soft limits for the current sub-step segment [t, currentT]\n                interpolator.setSoftPreviousTime(t);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // 2. Find the earliest event that occurs in the current sub-step [t, currentT]\n                EventState occurringEvent = null;\n                double earliestEventTime = currentT; // Initialize with the end of the current sub-step\n\n                // This re-evaluates ALL event states for the current [t, currentT] interval.\n                for (final EventState state : eventsStates) {\n                    if (state.evaluateStep(interpolator)) { // This will update state's internal event time.\n                        if (orderingSign * (state.getEventTime() - earliestEventTime) < 0) {\n                            earliestEventTime = state.getEventTime();\n                            occurringEvent = state;\n                        }\n                    }\n                }\n\n                if (occurringEvent == null) {\n                    // No more events in the current sub-step [t, currentT].\n                    // Break from the event handling loop and proceed to final step processing.\n                    break;\n                }\n\n                // 3. An event was found at earliestEventTime. Process it.\n                final double eventT = earliestEventTime;\n\n                // Restrict the interpolator to the part of the step up to the event [t, eventT]\n                interpolator.setSoftCurrentTime(eventT);\n\n                // Get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // Call stepAccepted for ALL event states up to eventT\n                // This updates their internal tracking of time.\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                }\n\n                // Handle the event itself (call stop and reset)\n                isLastStep = occurringEvent.stop();\n                boolean needReset = occurringEvent.reset(eventT, eventY);\n\n                // Handle the part of the step from `t` up to `eventT`\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (isLastStep) {\n                    // The event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    return eventT;\n                }\n\n                if (needReset) {\n                    // Some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(eventT, y, yDot);\n                    resetOccurred = true;\n                    return eventT;\n                }\n\n                // If neither stop nor reset, continue integration from eventT\n                // Set the new start time for the next iteration of the event handling loop\n                t = eventT;\n            } // End of while(true) event handling loop\n\n            // After the loop, `t` holds the time of the last processed event, or `previousT` if no events occurred.\n            // The remaining part of the step is from `t` to `currentT`.\n            // The interpolator's soft limits need to be reset for this final segment.\n            interpolator.setSoftPreviousTime(t);\n            interpolator.setSoftCurrentTime(currentT);\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n\n            // Notify all event states that the step has been accepted up to currentT.\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}