{
    "generation": "    /** Accept a step, triggering events and step handlers.\n     * @param interpolator step interpolator\n     * @param y state vector at step end time, must be reset if an event\n     * asks for resetting or if an events stops integration during the step\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @param tEnd final integration time\n     * @return time at end of step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the location of an event cannot be bracketed\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     * @since 2.2\n     */\n    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n            boolean isLastStep = false; // Flag used for the final step handler call\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                // CLONE is needed to prevent event handlers potentially modifying it\n                // before reset or stop uses the original state.\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // Advance the state of the current event handler that triggered\n                currentEvent.stepAccepted(eventT, eventY);\n                boolean currentEventCausesStop = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    // Pass the stop status determined by this event for this segment\n                    handler.handleStep(interpolator, currentEventCausesStop);\n                }\n\n                if (currentEventCausesStop) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length); // Update state vector to event state\n                    // Integration stops at eventT, return it\n                    return eventT;\n                }\n\n                boolean currentEventRequestsReset = currentEvent.reset(eventT, eventY);\n                if (currentEventRequestsReset) {\n                    // Event handler requests state reset\n                    System.arraycopy(eventY, 0, y, 0, y.length); // Update state vector to event state (possibly modified by reset)\n                    computeDerivatives(eventT, y, yDot); // Recompute derivatives with the new state\n                    resetOccurred = true; // Set flag for integrator\n                    // Step processing terminates and integration restarts from eventT, return it\n                    return eventT;\n                }\n\n                // If no stop/reset, prepare for the next segment or re-evaluation\n                previousT = eventT;\n                interpolator.setSoftPreviousTime(eventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // Check if the same event occurs again in the remaining part of the step\n                // This is important for events that trigger multiple times within a single original step\n                if (currentEvent.evaluateStep(interpolator)) {\n                    // The event occurs again\n                    occuringEvents.add(currentEvent);\n                }\n\n            } // End of while loop processing events occurring in the current step\n\n            // If we reach here, the step ended at currentT without any event causing a stop or reset\n            // Process the final part of the step from previousT (time of the last event handled, or step start) to currentT\n            interpolator.setInterpolatedTime(currentT); // Ensure interpolator is set to the end of the step\n            // State at the end of the step. No clone needed as it's only read by stepAccepted and step handlers below.\n            final double[] currentY = interpolator.getInterpolatedState();\n\n            // Update the internal state of ALL event handlers to the end of the step time.\n            // This is crucial for detecting events accurately in the *next* step.\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                // We do NOT check state.stop() here. A stop is only effective if triggered *at the event time*.\n            }\n\n            // Check if this step completes the integration by reaching tEnd.\n            isLastStep = Precision.equals(currentT, tEnd, 1);\n\n            // Handle the final segment of the step [previousT, currentT] using all registered step handlers.\n            // The interpolator's soft bounds need to be set correctly for this final segment.\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(currentT);\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            // Return the time reached at the end of this step\n            return currentT;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}