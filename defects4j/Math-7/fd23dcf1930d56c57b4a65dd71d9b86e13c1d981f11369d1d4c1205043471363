{
    "generation": "    protected double acceptStep(final AbstractStepInterpolator interpolator,\n                                final double[] y, final double[] yDot, final double tEnd)\n        throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n\n            double previousT = interpolator.getGlobalPreviousTime();\n            final double currentT = interpolator.getGlobalCurrentTime();\n\n            // initialize the events states if needed\n            if (! statesInitialized) {\n                for (EventState state : eventsStates) {\n                    state.reinitializeBegin(interpolator);\n                }\n                statesInitialized = true;\n            }\n\n            // search for next events that may occur during the step\n            final int orderingSign = interpolator.isForward() ? +1 : -1;\n            SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n                /** {@inheritDoc} */\n                public int compare(EventState es0, EventState es1) {\n                    // Ensure consistent ordering to avoid duplicate entries with equal event times\n                    int c = orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                    if (c == 0 && es0 != es1) {\n                        // Ensure distinct objects are not considered equal\n                        return System.identityHashCode(es0) - System.identityHashCode(es1);\n                    }\n                    return c;\n                }\n\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            // Main fix: ensure event handlers are called in the declared order for simultaneous events\n            while (!occuringEvents.isEmpty()) {\n\n                // Find all events that have the same earliest event time\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState firstEvent = iterator.next();\n                final double firstEventT = firstEvent.getEventTime();\n                List<EventState> simultaneousEvents = new ArrayList<EventState>();\n                simultaneousEvents.add(firstEvent);\n                iterator.remove();\n\n                while (iterator.hasNext()) {\n                    EventState evt = iterator.next();\n                    if (Precision.equals(evt.getEventTime(), firstEventT, 1)) {\n                        simultaneousEvents.add(evt);\n                        iterator.remove();\n                    } else {\n                        break; // Events are ordered, so can stop\n                    }\n                }\n\n                // Remove all remaining with the same event time\n                // and ensure correct order (eventsStates order)\n                List<EventState> inDeclaredOrder = new ArrayList<EventState>();\n                for (final EventState declared : eventsStates) {\n                    for (final EventState evt : simultaneousEvents) {\n                        if (declared == evt) {\n                            inDeclaredOrder.add(evt);\n                        }\n                    }\n                }\n\n                // restrict the interpolator to the first part of the step, up to the event\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(firstEventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(firstEventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                boolean needReset = false;\n                boolean stopCalled = false;\n\n                // Now perform all handlers in order\n                for (final EventState evt : inDeclaredOrder) {\n                    evt.stepAccepted(firstEventT, eventY);\n                    isLastStep = isLastStep || evt.stop();\n                    stopCalled = stopCalled || evt.stop();\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                if (stopCalled) {\n                    // the event asked to stop integration\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(firstEventT, eventY);\n                    }\n                    return firstEventT;\n                }\n\n                for (final EventState evt : inDeclaredOrder) {\n                    needReset = needReset || evt.reset(firstEventT, eventY);\n                }\n\n                if (needReset) {\n                    // some event handler has triggered changes that\n                    // invalidate the derivatives, we need to recompute them\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    computeDerivatives(firstEventT, y, yDot);\n                    resetOccurred = true;\n                    for (final EventState remaining : occuringEvents) {\n                        remaining.stepAccepted(firstEventT, eventY);\n                    }\n                    return firstEventT;\n                }\n\n                // prepare handling of the remaining part of the step\n                previousT = firstEventT;\n                interpolator.setSoftPreviousTime(firstEventT);\n                interpolator.setSoftCurrentTime(currentT);\n\n                // check if the same event occurs again in the remaining part of the step\n                // (do for all events)\n                for (final EventState evt : inDeclaredOrder) {\n                    if (evt.evaluateStep(interpolator)) {\n                        occuringEvents.add(evt);\n                    }\n                }\n            }\n\n            // last part of the step, after the last event\n            interpolator.setInterpolatedTime(currentT);\n            final double[] currentY = interpolator.getInterpolatedState();\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentT, currentY);\n                isLastStep = isLastStep || state.stop();\n            }\n            isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n            // handle the remaining part of the step, after all events if any\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, isLastStep);\n            }\n\n            return currentT;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}