{
    "generation": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        // first, if outside our codes table, it's invalid in an unquoted name:\n        if (i >= maxCode) {\n            _reportError(\"Invalid unquoted character '\" + c + \"' (code \" + i + \") in name\");\n        }\n        // if this code signals a break (whitespace, delimiter, etc.), stop the name\n        if (codes[i] != 0) {\n            break;\n        }\n        // otherwise absorb it as part of the name\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n\n        // expand output buffer if needed\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n\n    // finalize and look up the name\n    TextBuffer tb = _textBuffer;\n    char[] buf = tb.getTextBuffer();\n    int start = tb.getTextOffset();\n    int len = tb.size();\n    return _symbols.findSymbol(buf, start, len, hash);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}