{
    "generation": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        XYDataItem overwritten = null;\n\n        // If duplicates are NOT allowed, we first check for an existing item to update.\n        if (!this.allowDuplicateXValues) {\n            // Find existing item by X-value.\n            // indexOf(x) uses Collections.binarySearch on X-values only.\n            int index = indexOf(x);\n            if (index >= 0) { // Item with this x-value already exists, so update it.\n                XYDataItem existing = (XYDataItem) this.data.get(index);\n                try {\n                    overwritten = (XYDataItem) existing.clone();\n                } catch (CloneNotSupportedException e) {\n                    throw new SeriesException(\"Couldn't clone XYDataItem!\");\n                }\n                existing.setY(y);\n                // The item was updated in place, no need to add/remove from list.\n                fireSeriesChanged();\n                return overwritten;\n            }\n            // If we reach here, it means duplicates are NOT allowed, and 'x' was not found.\n            // So, we proceed to add a new item. The 'index' from indexOf(x) is negative,\n            // and we'll use that to determine the insertion point if autoSort is true.\n        }\n\n        // --- Logic for ADDING a new item ---\n        // This branch is executed if:\n        // 1. Duplicates ARE allowed (so we always add).\n        // 2. Duplicates are NOT allowed, AND 'x' was not found (so we add a new unique item).\n        XYDataItem newItem = new XYDataItem(x, y);\n\n        if (this.autoSort) {\n            // Determine the correct insertion point for the new item to maintain sort order.\n            // We use `xAndYComparator` which considers both X and Y.\n            // Collections.binarySearch returns (-(insertion point) - 1) if not found,\n            // or the index if an identical item (same x, same y based on comparator) is found.\n            int insertionIndex = Collections.binarySearch(this.data, newItem, this.xAndYComparator);\n            if (insertionIndex < 0) {\n                // Item not found, so insert at the calculated insertion point.\n                this.data.add(-insertionIndex - 1, newItem);\n            } else {\n                // An item with the same X and Y value was found (or at least, comparator returned 0).\n                // If duplicates are allowed, we still add this new item.\n                // The standard behavior for Collections.binarySearch finding an equal element is\n                // to return one of the indices. Inserting at this index is acceptable.\n                this.data.add(insertionIndex, newItem);\n            }\n        } else {\n            // Not auto-sorted, just append the new item to the end of the list.\n            this.data.add(newItem);\n        }\n\n        // Check if this addition will exceed the maximum item count.\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0); // Remove the oldest item (at index 0).\n        }\n\n        fireSeriesChanged();\n        return overwritten; // This will be null if an item was added, or a copy of the old item if updated.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}