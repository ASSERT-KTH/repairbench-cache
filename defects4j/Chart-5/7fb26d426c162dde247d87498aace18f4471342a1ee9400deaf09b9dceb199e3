{
    "generation": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        XYDataItem overwritten = null;\n\n        if (!this.allowDuplicateXValues) {\n            // Case: Duplicates are NOT allowed.\n            // Check if an item with this x-value already exists.\n            int index = indexOf(x);\n            if (index >= 0) {\n                // Item found, update it.\n                XYDataItem existing = (XYDataItem) this.data.get(index);\n                try {\n                    overwritten = (XYDataItem) existing.clone();\n                }\n                catch (CloneNotSupportedException e) {\n                    throw new SeriesException(\"Couldn't clone XYDataItem!\");\n                }\n                existing.setY(y);\n            } else {\n                // Item not found, add it.\n                if (this.autoSort) {\n                    // Use the insertion point provided by indexOf(x) (which is a negative value from binarySearch)\n                    this.data.add(-index - 1, new XYDataItem(x, y));\n                } else {\n                    // Not sorted, just append.\n                    this.data.add(new XYDataItem(x, y));\n                }\n                // Check if this addition will exceed the maximum item count...\n                if (getItemCount() > this.maximumItemCount) {\n                    this.data.remove(0);\n                }\n            }\n        } else {\n            // Case: Duplicates ARE allowed.\n            // Always add a new item.\n            if (this.autoSort) {\n                // Find the correct insertion point for the new XYDataItem(x, y)\n                // using the xAndYComparator for precise sorting.\n                int insertIndex = Collections.binarySearch(this.data, new XYDataItem(x, y), this.xAndYComparator);\n                if (insertIndex < 0) {\n                    // Item not found, calculate insertion point.\n                    insertIndex = -insertIndex - 1;\n                } else {\n                    // An item with exactly (x, y) was found.\n                    // To maintain order and add duplicates *after* existing ones,\n                    // advance the index past any items that are \"equal\" to the new one.\n                    while (insertIndex < this.data.size() && this.xAndYComparator.compare(new XYDataItem(x, y), (XYDataItem) this.data.get(insertIndex)) == 0) {\n                        insertIndex++;\n                    }\n                }\n                this.data.add(insertIndex, new XYDataItem(x, y));\n            } else {\n                // Not sorted, just append.\n                this.data.add(new XYDataItem(x, y));\n            }\n            // Check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}