{
    "generation": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        XYDataItem overwritten = null;\n\n        // First, handle the 'update' case which only happens if duplicates\n        // are not allowed and an item with value x exists.\n        if (!this.allowDuplicateXValues) {\n            int index = indexOf(x); // Find the item to potentially update\n            if (index >= 0) {\n                // Item found, update it\n                XYDataItem existing = (XYDataItem) this.data.get(index);\n                try {\n                    overwritten = (XYDataItem) existing.clone();\n                } catch (CloneNotSupportedException e) {\n                    throw new SeriesException(\"Couldn't clone XYDataItem!\");\n                }\n                existing.setY(y);\n                fireSeriesChanged(); // Fire event because data changed\n                return overwritten; // Return the overwritten item\n            }\n            // If index < 0 (item not found), proceed to the 'add' logic below\n        }\n\n        // If we reach here, it means either:\n        // 1. duplicates are allowed, OR\n        // 2. duplicates are not allowed, but no item with value x exists.\n        // In both cases, we need to ADD the new item.\n\n        XYDataItem newItem = new XYDataItem(x, y);\n        if (this.autoSort) {\n            // Add requires finding the correct insertion point\n            // Use Collections.binarySearch to find the index or insertion point\n            int insertionPoint = java.util.Collections.binarySearch(this.data, newItem);\n            if (insertionPoint < 0) {\n                // Item with x not found, insert at calculated point\n                this.data.add(-insertionPoint - 1, newItem);\n            } else {\n                // Item with same X found by binarySearch at insertionPoint.\n                // Since we are in the 'add' path (duplicates allowed or item initially not found)\n                // we should insert.\n                if (this.allowDuplicateXValues) {\n                    // If duplicates allowed, find the position *after* the block\n                    // of existing items with the same x-value.\n                    int ip = insertionPoint;\n                    // Scan forward from the index returned by binarySearch\n                    while (ip < this.data.size() &&\n                           ((XYDataItem) this.data.get(ip)).compareTo(newItem) == 0) {\n                           // Note: compareTo checks x-value only.\n                           // We need to ensure we are past items with the same x.\n                           // Using getX().equals(x) might be safer if compareTo behavior changes.\n                           // Sticking to compareTo for consistency with binarySearch.\n                        ip++;\n                    }\n                    this.data.add(ip, newItem);\n                } else {\n                    // If duplicates are not allowed, this point should theoretically\n                    // not be reached if the earlier 'update' check was performed.\n                    // If it is reached, it implies an item with value X exists,\n                    // but we are instructed to add, not update. This is contradictory\n                    // to allowDuplicateXValues = false.\n                    // However, if we strictly follow the logic of adding when\n                    // an item wasn't found by indexOf (even if binarySearch finds one now),\n                    // we'd insert at the negative index position.\n                    // Let's assume the initial check (index < 0) was correct,\n                    // meaning binarySearch should also return < 0.\n                    // If binarySearch returns >= 0, it might indicate a concurrent modification\n                    // or inconsistency. For safety, let's throw an exception or log a warning.\n                    // Or, perhaps simpler, trust binarySearch and *replace* the item,\n                    // although the method name suggests add/update.\n                    // Sticking to the original plan: if duplicates not allowed, this path implies\n                    // item wasn't found by indexOf, so binarySearch result *should* be < 0.\n                    // If it's >= 0, maybe throw an internal error.\n                    // For now, let's insert based on the binarySearch result's implied position,\n                    // handling the < 0 case above. This 'else' implies insertionPoint >= 0.\n                    // Since duplicates are NOT allowed, update the item at insertionPoint.\n                    // This repeats the update logic, suggesting a flaw.\n                    // Safest is likely to rely on the initial check: if we are here and\n                    // !allowDuplicateXValues, index must have been < 0, so insertionPoint\n                    // should also be < 0. If not, there's an issue.\n                    // Let's add a fallback to insert using the negative index rule,\n                    // assuming insertionPoint >= 0 was unexpected.\n                     this.data.add(-insertionPoint - 1, newItem); // Treat as if not found\n                     // A better approach might be an exception:\n                     // throw new IllegalStateException(\"Inconsistent state: binary search found element for add operation when duplicates are not allowed.\");\n                }\n            }\n        } else {\n            // Not auto-sorted, just add to the end\n            this.data.add(newItem);\n        }\n\n        // Check if this addition exceeds the maximum item count\n        // Ensure this check happens *after* adding the item\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0); // Remove the oldest item (at index 0)\n        }\n\n        fireSeriesChanged(); // Fire event because data changed\n        return overwritten; // Will be null because we added, not updated (in this path)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}