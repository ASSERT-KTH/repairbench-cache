{
    "generation": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // Create the new item upfront in case it needs to be added\n        XYDataItem newItem = new XYDataItem(x, y);\n\n        XYDataItem overwritten = null;\n        boolean itemAdded = false;\n\n        // Find the index of x, using binary search if sorted\n        int index = indexOf(x);\n\n        if (index >= 0) { // An item with the same x-value exists\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            if (this.allowDuplicateXValues) {\n                // Add a new item (duplicates allowed)\n                if (this.autoSort) {\n                    // Find the correct insertion point to maintain sort order.\n                    // We should insert after all existing items with the same x-value.\n                    // The index returned by binarySearch might point to any of the duplicates.\n                    // Iterate forward from 'index' to find the position after the last duplicate.\n                    int insertionPoint = index;\n                    // Use compareTo for consistency with sorting logic.\n                    // Assumes XYDataItem implements Comparable based on x-value.\n                    while (insertionPoint < this.data.size() &&\n                           ((XYDataItem) this.data.get(insertionPoint)).compareTo(newItem) == 0) {\n                        insertionPoint++;\n                    }\n                    // Insert the new item at the determined position\n                    this.data.add(insertionPoint, newItem);\n                    itemAdded = true;\n                }\n                else {\n                    // Not sorted, just add to the end\n                    this.data.add(newItem);\n                    itemAdded = true;\n                }\n                // In this case, nothing is 'overwritten' in the update sense\n                overwritten = null;\n            }\n            else {\n                // Update existing item (duplicates not allowed)\n                try {\n                    // Clone the existing item to return as 'overwritten'\n                    overwritten = (XYDataItem) existing.clone();\n                }\n                catch (CloneNotSupportedException e) {\n                    // Should not happen if XYDataItem is properly cloneable\n                    throw new SeriesException(\"Couldn't clone XYDataItem!\");\n                }\n                // Update the y-value of the existing item found at 'index'\n                // Note: binarySearch might return any index if duplicates were somehow present\n                // despite allowDuplicateXValues being false, but updating the one at 'index'\n                // is the defined behavior here.\n                existing.setY(y);\n                // itemAdded remains false, as we updated, not added.\n            }\n        }\n        else { // No item with the same x-value exists (index < 0)\n            // Add the new item\n            if (this.autoSort) {\n                // Insert at the position determined by binary search result\n                // The formula -index - 1 gives the correct insertion point\n                this.data.add(-index - 1, newItem);\n                itemAdded = true;\n            }\n            else {\n                // Not sorted, just add to the end\n                this.data.add(newItem);\n                itemAdded = true;\n            }\n            // Nothing was overwritten\n            overwritten = null;\n        }\n\n        // If an item was added, check if the maximum item count is exceeded\n        if (itemAdded && getItemCount() > this.maximumItemCount) {\n            // Remove the oldest item (at index 0)\n            this.data.remove(0);\n        }\n\n        // Notify listeners of the change\n        fireSeriesChanged();\n\n        // Return the data item that was overwritten, or null if an item was added\n        return overwritten;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}