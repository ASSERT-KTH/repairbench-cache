{
    "generation": "    /**\n     * Adds or updates an item in the series and sends a\n     * {@link SeriesChangeEvent} to all registered listeners.\n     *\n     * @param x  the x-value (<code>null</code> not permitted).\n     * @param y  the y-value (<code>null</code> permitted).\n     *\n     * @return A copy of the overwritten data item, or <code>null</code> if no\n     *         item was overwritten.\n     */\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        XYDataItem overwritten = null;\n        boolean added = false; // Flag to track if we added a new item\n\n        // find the index for the item with the given x-value\n        int index = indexOf(x); // uses Collections.binarySearch if autoSort is true\n\n        if (index >= 0) {\n            // An item with the same x-value exists...\n            if (!this.allowDuplicateXValues) {\n                // If duplicates are not allowed, update the existing item\n                XYDataItem existing = (XYDataItem) this.data.get(index);\n                try {\n                    overwritten = (XYDataItem) existing.clone();\n                }\n                catch (CloneNotSupportedException e) {\n                    throw new SeriesException(\"Couldn't clone XYDataItem!\");\n                }\n                existing.setY(y);\n                // item updated, no need to add, added remains false\n            }\n            else {\n                // Duplicates ARE allowed, so we ADD a new item...\n                XYDataItem newItem = new XYDataItem(x, y);\n                if (this.autoSort) {\n                    // If sorted, insert the duplicate after the item found by\n                    // indexOf(). This maintains order relative to duplicates.\n                    // Note: List.add(index, item) inserts *before* the element\n                    // currently at 'index'. Adding at 'index + 1' inserts after.\n                    this.data.add(index + 1, newItem);\n                }\n                else {\n                    // If not sorted, just append the new item.\n                    this.data.add(newItem);\n                }\n                added = true;\n            }\n        }\n        else {\n            // No item with the same x-value exists, so ADD a new item...\n            XYDataItem newItem = new XYDataItem(x, y);\n            if (this.autoSort) {\n                // If sorted, insert item at the correct position determined\n                // by the binary search result (-(insertion point) - 1).\n                this.data.add(-index - 1, newItem);\n            }\n            else {\n                // If not sorted, just append the new item.\n                this.data.add(newItem);\n            }\n            added = true;\n        }\n\n        // If we added an item, check if this exceeds the maximum item count...\n        if (added && getItemCount() > this.maximumItemCount) {\n            this.data.remove(0);\n        }\n\n        // Notify listeners that the series has changed (either by update or add)\n        fireSeriesChanged();\n\n        // Return the overwritten item if an update occurred, otherwise null.\n        return overwritten;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}