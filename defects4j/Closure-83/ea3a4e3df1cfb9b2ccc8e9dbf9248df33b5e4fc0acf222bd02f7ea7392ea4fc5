{
    "generation": "      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = params.getParameter(0);\n\n        if (param == null) {\n          // This case handles a boolean flag present without an explicit value,\n          // e.g., --verbose. It defaults to true.\n          setter.addValue(true);\n          return 0; // Consumes 0 additional arguments.\n        } else {\n          // This case handles a boolean flag with an explicit value,\n          // e.g., --verbose=true or --verbose true.\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n            return 1; // Consumes 1 additional argument (the value).\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n            return 1; // Consumes 1 additional argument (the value).\n          } else {\n            // The 'param' is not null, but it's not a recognized \"true\" or \"false\" string.\n            // The original code was buggy here: it set the value to true but returned 0,\n            // which means 'param' was not consumed and would be re-processed or\n            // treated as a positional argument, leading to unexpected behavior.\n            // Correct behavior for an invalid explicit value is to throw an exception.\n            throw new CmdLineException(\n                \"Invalid boolean value for option. Expected one of \" + TRUES + \" or \" + FALSES + \", but got '\" + param + \"'.\");\n          }\n        }\n      }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}