{
    "generation": "import com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.UnionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.TernaryValue;\n\n// Assume JSType has a protected field 'registry' of type JSTypeRegistry\n// Assume TypePair is a simple pair class holding two JSType objects (typeA, typeB)\n\n  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null}, and its\n   *         components are never {@code null}.\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // Handle unions recursively by delegating to the UnionType implementation\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      // Swap the results as the order was reversed in the recursive call\n      return new TypePair(p.typeB, p.typeA);\n    }\n    // At this point, 'that' is not a UnionType.\n    // We also assume 'this' is not a UnionType, because UnionType overrides this method.\n\n    JSType typeA = this;\n    JSType typeB = that;\n\n    // We need access to the registry to potentially return NO_TYPE.\n    // Assuming 'this.registry' gives access to the JSTypeRegistry.\n    JSTypeRegistry registry = this.registry;\n    JSType noType = registry.getNativeType(JSTypeNative.NO_TYPE);\n\n    switch (typeA.testForEquality(typeB)) {\n      case TRUE:\n        // If types are definitely equal (e.g., void === void),\n        // then learning they are unequal means we're in an unreachable state.\n        // The resulting types should be the bottom type (NO_TYPE).\n        return new TypePair(noType, noType);\n\n      case FALSE:\n        // If types are definitely unequal (e.g., number !== string),\n        // then learning they are unequal provides no new information.\n        // Return the original types.\n        return new TypePair(typeA, typeB);\n\n      case UNKNOWN:\n        // If types might be equal (e.g., number vs (number|undefined)),\n        // then learning they are unequal allows for refinement based on null/undefined.\n        JSType restrictedA = typeA;\n        JSType restrictedB = typeB;\n\n        // Check if one type can be null/undefined while the other cannot.\n        boolean canBeNullUndefA = typeA.isNullable() || typeA.isVoidable();\n        boolean canBeNullUndefB = typeB.isNullable() || typeB.isVoidable();\n\n        // If A is definitely not null/undefined, and B could be, then A != B implies\n        // B cannot be null/undefined.\n        if (!canBeNullUndefA && canBeNullUndefB) {\n          restrictedB = typeB.restrictByNotNullOrUndefined();\n          // If B was purely null/undefined, restrictedB is now NO_TYPE. Check for bottom type:\n          if (restrictedB.isBottomType()) {\n             // If B must be non-null/undef, but its non-null/undef version is bottom,\n             // it implies an inconsistency if A could be equal to the null/undef part.\n             // However, A cannot be null/undef, so A != B is trivially true if B is null/undef.\n             // No new info is gained in this specific case, so maybe don't restrict?\n             // Revisit Javadoc: num != (undef|num) => num, num.\n             // restrict((undef|num)) -> num. Correct.\n             // What if A = num, B = undef? testForEquality=FALSE. Returns (num, undef). Correct.\n             // What if A = num, B = (undef|null)? testForEquality=UNKNOWN.\n             // !canBeNullUndefA=true, canBeNullUndefB=true.\n             // restrictedB = B.restrictByNotNullOrUndefined() -> NO_TYPE.\n             // Return (num, NO_TYPE). Seems correct, B cannot be its only possibilities.\n             restrictedB = restrictedB.isBottomType()? noType : restrictedB; // Ensure canonical NO_TYPE\n          }\n        }\n\n        // If B is definitely not null/undefined, and A could be, then A != B implies\n        // A cannot be null/undefined.\n        if (!canBeNullUndefB && canBeNullUndefA) {\n          restrictedA = typeA.restrictByNotNullOrUndefined();\n           if (restrictedA.isBottomType()) {\n             restrictedA = restrictedA.isBottomType()? noType : restrictedA; // Ensure canonical NO_TYPE\n           }\n        }\n\n        // Return the restricted (or original) types.\n        return new TypePair(restrictedA, restrictedB);\n    }\n\n    // Switch case should be exhaustive.\n    throw new IllegalStateException(\"Unexpected TernaryValue: \" + typeA.testForEquality(typeB));\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}