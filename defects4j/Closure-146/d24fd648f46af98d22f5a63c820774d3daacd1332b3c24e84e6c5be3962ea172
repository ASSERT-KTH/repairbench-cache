{
    "generation": "/**\n * Computes the subset of {@code this} and {@code that} types if inequality\n * is observed. If a value {@code v1} of type {@code number} is not equal to a\n * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n * type of {@code v1} is {@code number} and the type of {@code v2} is\n * {@code number} as well.\n *\n * @return a pair containing the restricted type of {@code this} as the first\n *         component and the restricted type of {@code that} as the second\n *         element. The returned pair is never {@code null} even though its\n *         components may be {@code null}\n */\npublic TypePair getTypesUnderInequality(JSType that) {\n  // unions types\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n\n  // other types\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return new TypePair(null, null);\n\n    case FALSE:\n      // If they're unequal, return the original types since we can't\n      // constrain them further.\n      return new TypePair(this, that);\n\n    case UNKNOWN:\n      // When equality is UNKNOWN (might be true or false), we should return the\n      // types that would hold in either case.\n      if (this == NO_TYPE || that == NO_TYPE) {\n        // If one type is NO_TYPE, return as-is since NO_TYPE is a bottom type\n        return new TypePair(this, that);\n      }\n\n      if (this.isUndefinedType() && that.isVoidType()) {\n        // Special case: when testing inequality between undefined and void,\n        // both types should become NO_TYPE (the false case is impossible)\n        return new TypePair(NO_TYPE, NO_TYPE);\n      }\n      else if (that.isUndefinedType() && this.isVoidType()) {\n        return new TypePair(NO_TYPE, NO_TYPE);\n      }\n      else if (this.isVoidType() && that.isUndefinedType()) {\n        return new TypePair(NO_TYPE, NO_TYPE);\n      }\n      else if (that.isVoidType() && this.isUndefinedType()) {\n        return new TypePair(NO_TYPE, NO_TYPE);\n      }\n      return new TypePair(this, that);\n  }\n\n  // switch case is exhaustive\n  throw new IllegalStateException();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}