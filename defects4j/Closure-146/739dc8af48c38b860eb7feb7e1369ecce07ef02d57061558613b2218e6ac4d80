{
    "generation": "  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        // If they are known to be equal, but inequality is observed,\n        // then this is a contradiction. No types remain.\n        return new TypePair(null, null);\n\n      case FALSE:\n        // If they are known to be unequal, and inequality is observed,\n        // then their types remain as they are.\n        return new TypePair(this, that);\n\n      case UNKNOWN:\n        // When equality is UNKNOWN, it means there's a possibility of equality\n        // and a possibility of inequality.\n        // Since we are observing inequality, we need to eliminate the cases\n        // where they could be equal.\n        // The parts of 'this' and 'that' that could be equal are their intersection.\n        JSType commonType = this.getGreatestSubtype(that);\n        if (commonType.isNoType()) {\n          // If there is no common subtype, they can never be equal.\n          // This implies testForEquality should have returned FALSE.\n          // If it returned UNKNOWN, and their commonType is NoType,\n          // then they are effectively disjoint and unequal. So return as is.\n          return new TypePair(this, that);\n        } else {\n          // Exclude the common type from both 'this' and 'that'.\n          // This will restrict 'this' to be 'this' without 'commonType',\n          // and 'that' to be 'that' without 'commonType'.\n          return new TypePair(this.getDifference(commonType), that.getDifference(commonType));\n        }\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}