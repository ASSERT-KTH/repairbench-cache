{
    "generation": "  /**\n   * Computes the subset of {@code this} and {@code that} types if inequality\n   * is observed. If a value {@code v1} of type {@code number} is not equal to a\n   * value {@code v2} of type {@code (undefined,number)}, we can infer that the\n   * type of {@code v1} is {@code number} and the type of {@code v2} is\n   * {@code number} as well.\n   *\n   * @return a pair containing the restricted type of {@code this} as the first\n   *         component and the restricted type of {@code that} as the second\n   *         element. The returned pair is never {@code null} even though its\n   *         components may be {@code null}\n   */\n  public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n      TypePair p = that.getTypesUnderInequality(this);\n      return new TypePair(p.typeB, p.typeA);\n    }\n\n    // other types\n    switch (this.testForEquality(that)) {\n      case TRUE:\n        // If this and that are always equal, then under inequality, they cannot exist.\n        return new TypePair(null, null);\n\n      case FALSE:\n        // If this and that are always unequal, then under inequality, their types remain as is.\n        return new TypePair(this, that);\n\n      case UNKNOWN:\n        // If equality is unknown, we need to restrict the types such that they are not equal.\n        // This implies removing any parts that would cause them to be equal.\n\n        // Special case: if both types are the same singleton (like 'undefined' or 'null')\n        // and testForEquality somehow yielded UNKNOWN (instead of TRUE, which is ideal),\n        // then under inequality, they cannot be that singleton.\n        // This addresses testEqCondition4 if the UNKNOWN path is unexpectedly taken for VOID_TYPE.\n        if (this.isSingleton() && that.isSingleton() && this.isEquivalentTo(that)) {\n          return new TypePair(null, null);\n        }\n\n        // For other UNKNOWN cases, compute the restricted types using the general mechanism.\n        // This handles cases like `number != (undefined|number)` correctly,\n        // as described in the Javadoc, by removing the 'undefined' part from the union.\n        JSType restrictedThis = this.getRestrictedTypeGivenOtherType(that, false);\n        JSType restrictedThat = that.getRestrictedTypeGivenOtherType(this, false);\n        return new TypePair(restrictedThis, restrictedThat);\n    }\n\n    // switch case is exhaustive\n    throw new IllegalStateException();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}