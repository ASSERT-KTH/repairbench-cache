{
    "generation": "    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // First, verify that assumption we make holds true:\n        // (note: we could perhaps also allow narrowing to unrelated type, if complex-generic?)\n        _assertSubclass(subclass, _class); // Throws exception if not true\n\n        // 17-Jun-2016, tatu: If initial type is `Object.class`, must rewrite\n        //   completely, starting from scratch...\n        // 08-Dec-2017, tatu: ... mostly. Need to retain value/type handlers tho\n        // 11-Jul-2019, tatu: And for Enum subtypes, super is Enum not Object so...\n        //   Let's see if this is sufficient:\n        if (_class == Object.class) {\n             // 13-Dec-2017, tatu: Need to retain specifics, so pass 'this' as super-class\n             //    (importantly, keeps track of resolved Interfaces)\n             return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                  _valueHandler, _typeHandler, _asStatic);\n        }\n        // Otherwise, just need to change class, keep definitions otherwise\n        JavaType newSuperClass = _superClass;\n        if (newSuperClass != null) {\n            // 13-Dec-2017, tatu: Need to make sure hierarchy is properly updated\n            newSuperClass = newSuperClass.narrowBy(subclass);\n        }\n        // Keep interfaces as is? Seems problematic, but works? (for now?)\n        // 20-Mar-2021, tatu: Maybe needs thinking like [databind#3010] suggests...\n        //   ... but for now, leave as is.\n\n        // Value/type handlers inherited as-is, seems ok:\n        return new SimpleType(subclass, _bindings,\n                 newSuperClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}