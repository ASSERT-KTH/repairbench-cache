{
    "generation": "    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        // 01-Dec-2016, tatu: Turns out we must check this; handling of interfaces\n        //    fails otherwise...\n        if (!_class.isAssignableFrom(subclass)) {\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n\n        // 19-Jun-2017, tatu: As per [databind#1611], need to also consider value/type handlers.\n        //    Basically, only retain `_asStatic` status, and handlers.\n\n        // TODO: CHECK: value-handler indeed tricky, need to leave for now\n\n        // 28-Jul-2017, tatu: This is tricky... Need to preserve type/value handlers.\n        //   But what about super-class, interfaces? Let's assume they are dynamic,\n        //   use `this` as super-class. Super-interfaces? Let's punt for now.\n\n        // 13-Mar-2017, tatu: For [databind#1511], we do need to check and assert\n        //    assignability early, not late. Fixed.\n        _assertSubclass(subclass, _class);\n\n        // Super-class is 'this' type; super-interfaces do not matter (at least not yet)\n        // and bindings we may be able togeneric type system?\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}