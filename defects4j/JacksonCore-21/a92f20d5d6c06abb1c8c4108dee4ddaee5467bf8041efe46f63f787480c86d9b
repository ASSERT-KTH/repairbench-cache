{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches = false, _includePath = false,\n        // and we have seen at least one token (which is _currToken)\n        // and that we are not currently unwinding buffered context (_exposedContext = null).\n        // If conditions match, we may be able to stop early.\n        // NOTE: Added check for `!_includePath` as of 2.9.7, to fix [core#446]\n        // (prevents premature termination for path-included single match)\n        if (!_allowMultipleMatches && !_includePath // Added !_includePath check\n             && (_currToken != null) && (_exposedContext == null)) {\n            // If the current token is structure end, AND it is NOT the parent start event\n            // (possible for root value)\n            if (_currToken.isStructEnd()) {\n                if (_headContext.isStartHandled()) {\n                    // Example: We saw the first match (a scalar value or full structure), and\n                    // then associated closing END_ARRAY/END_OBJECT. But since not including\n                    // path, can just stop.\n                    return (_currToken = null);\n                }\n            // Or, if scalar value, return null if it's not within an object/array started\n            // by the filter AND filter matched (INCLUDE_ALL)\n            } else if (_currToken.isScalarValue()) {\n                 // If scalar value, and not within structure started by filter,\n                 // and filter matched (INCLUDE_ALL), then we are done.\n                if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                    return (_currToken = null);\n                }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    // If we are using non-blocking parser, this check may be needed:\n                    /*\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    // Otherwise we are likely fine... except maybe for FIELD_NAME?\n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t == JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n\n                    // Nah; we are done with buffered context which means we may\n                    // need to advance the underlying parser to get next token\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // filter indicates skip\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) { // filter indicates skip\n                delegate.skipChildren();\n                break;\n            }\n            // But perhaps need to include START_ARRAY?\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            // Need to create context either way, to know when to pop it\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // 28-Oct-2018, tatu: Need to fall through to get the next token...\n            //   Oh actually, we may have been buffering, need to continue from there?\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // filter indicates skip\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) { // filter indicates skip\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            // 28-Oct-2018, tatu: Need to fall through to get the next token...\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    // 28-Oct-2018, tatu: Originally just called this for END_ARRAY, but\n                    //   looks like needs to be called for END_OBJECT as well?\n                    // 13-Dec-2018, tatu: Actually, TokenFilter API does not require symmetrical calls,\n                    //   so it's probably better NOT to make the call, as filter may not expect it.\n                    // (this was changed back from 2.9.8)\n//                    f.filterFinishArray();\n//                    f.filterFinishObject();\n                }\n                _headContext = _headContext.getParent();\n                // Important: get filter to use NEXT from context now popped\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            // If non-included array/object ended, need to continue processing...\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) { // include the whole sub-tree?\n                    _itemFilter = f;\n                    // If path is included, we need to buffer, return FIELD_NAME. If not, just return FIELD_NAME.\n                    // Difference is that buffering wrapper may return START_OBJECT for parent etc.\n                    if (_includePath) {\n                       return (_currToken = _nextTokenWithBuffering(_headContext));\n                    }\n                    // Minor twist here: if parent NOT included, may need to induce output of\n                    // surrounding START_OBJECT/END_OBJECT\n                    if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                        // And need to return the START_OBJECT first... does this work? What is `t`?\n                        _currToken = t; // _headContext.nextTokenToRead() has already returned START_OBJECT\n                        // Fall through, code below will return FIELD_NAME and work correctly? Or should we return START_OBJECT?\n                         return t; // Let's return START_OBJECT then\n                    }\n                     return (_currToken = t);\n                }\n                if (f == null) { // property is filtered out, skip value\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                // Property included, but need to check value\n                f = f.includeProperty(name);\n                if (f == null) { // value explicitly filtered out, skip\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f; // filter to use for value\n                // But is the FIELD_NAME itself included? Depends on includePath...\n                if (f == TokenFilter.INCLUDE_ALL) { // value included, FIELD_NAME needed unless...\n                     if (_includePath) {\n                        // If path included, need to buffer, maybe return START_OBJECT first etc:\n                         return (_currToken = _nextTokenWithBuffering(_headContext));\n                     }\n                     // If path not included, still need FIELD_NAME\n                     // but may also need START/END_OBJECT for the immediate parent:\n                     if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                         t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                         _exposedContext = _headContext;\n                         // Return START_OBJECT?\n                         _currToken = t;\n                         return t;\n                     }\n                     // And if parent was already handled, just the field name\n                     return (_currToken = delegate.getCurrentToken()); // return t == FIELD_NAME\n                }\n                 // If filter is not INCLUDE_ALL, need to check what to do with FIELD_NAME...\n                if (_includePath) {\n                    // Path included: Buffering needed to see if parent START_OBJECT needed,\n                    // and buffer FIELD_NAME if needed\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                    // If null, indicates FIELD_NAME should not be returned? Go to skip?\n                    // But why would this be null? Maybe if parent object wasn't included?\n                    // Let's fall through to _nextToken2(), seems safest\n                    break;\n                }\n                // Path not included: Should not include FIELD_NAME? Or if value is included?\n                // Seems like we should fall through to _nextToken2(), which handles\n                // potential inclusion of value itself (and FIELD_NAME checks there?)\n                // This seems confusing. Let's try breaking and forcing call to _nextToken2()\n\n                // 28-Oct-2018, tatu: As per [core#457] check, seems like falling through to logic\n                //   below is necessary...\n                // fall through?? Or break? Fall through seems wrong... let's break\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                 // If path not included, may need START_OBJECT/END_OBJECT for parent:\n                 if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {\n                     t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                     _exposedContext = _headContext;\n                     // Return START_OBJECT first?\n                     _currToken = t;\n                     return t;\n                 }\n                 // Otherwise just return the value\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                     // If path not included, may need START_OBJECT/END_OBJECT for parent:\n                     if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {\n                         t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                         _exposedContext = _headContext;\n                         // Return START_OBJECT first?\n                         _currToken = t;\n                         return t;\n                     }\n                     // Otherwise just return the value\n                    return (_currToken = t);\n                }\n                // If value not included, fall through to skip/loop\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found (filtered out); need to advance, handle buffering\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}