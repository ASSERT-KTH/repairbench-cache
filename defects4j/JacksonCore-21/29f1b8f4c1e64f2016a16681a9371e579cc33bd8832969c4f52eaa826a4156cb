{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n        // 10-Jun-2020, tatu: [core#607] This check is problematic as it prevents output of\n        //    closing END_OBJECT / END_ARRAY needed when `_includePath` is true.\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            //if not scalar and ended successfully, and !includePath, then return null\n            if (_currToken.isStructEnd()) {\n                // This check related to [core#607]; should not stop when path included\n                // as we need closing events.\n                if (!_includePath && _headContext.isStartHandled()) {\n                    return (_currToken = null);\n                }\n            } else if (_currToken.isScalarValue()) {\n                //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                // then return null\n                // This check related to [core#607]; should not stop when path included\n                if (!_includePath && !_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                    return (_currToken = null);\n                }\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            // Note: bufffered context can be either _headContext or one of its children.\n            // If it's _headContext, we are inside the structure governed by it;\n            // if it's a child context, we are handling START/END Object/Array or FIELD_NAME\n            // that was potentially buffered...\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    // If context has Filter set as INCLUDE_ALL then we are using the delegate directly\n                    // make sure the delegate has the same token as the context.\n                    if (ctxt.getFilter() == TokenFilter.INCLUDE_ALL) {\n                        _currToken = delegate.currentToken();\n                        return _currToken;\n                    }\n                    // Maybe we have context associated with the START_ARRAY/START_OBJECT token?\n                    // And if the context filter was null, then we need to make sure the delegate\n                    // did not move to the next token\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        if (t != JsonToken.START_ARRAY && t != JsonToken.END_ARRAY) {\n                            // When context filter is null, skipChildren() is called which moves the delegate\n                            // to the END_ARRAY token, but context has not been updated yet\n                            // make sure the context state is updated before setting _currToken\n                            if (_headContext.isStartHandled() && _headContext.getFilter() == null) {\n                                _currToken = delegate.currentToken();\n                                _headContext = _headContext.getParent();\n                                return _currToken;\n                            }\n                        }\n                        _currToken = t;\n                        return t;\n                    }\n                    if (ctxt.inObject()) {\n                        t = delegate.getCurrentToken();\n                        if (t != JsonToken.START_OBJECT && t != JsonToken.END_OBJECT) {\n                            // When context filter is null, skipChildren() is called which moves the delegate\n                            // to the END_OBJECT token, but context has not been updated yet\n                            // make sure the context state is updated before setting _currToken\n                            if (_headContext.isStartHandled() && _headContext.getFilter() == null) {\n                                _currToken = delegate.currentToken();\n                                _headContext = _headContext.getParent();\n                                return _currToken;\n                            }\n                        }\n                        _currToken = t;\n                        return t;\n                    }\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            // Except, perhaps, maybe we had buffered stuff?\n            /*\n            if (_headContext != null) {\n                TokenFilterContext ctxt = _headContext;\n                if (ctxt.isStartHandled()) {\n                    _exposedContext = ctxt;\n                }\n            }\n            */\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            // Do we need to include this specific START_ARRAY?\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            // Still not included, but need to create context for structure, scanning\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                // May need to buffer FIELD_NAME or START_OBJECT, then START_ARRAY\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // otherwise viable possibility is that we need to skip contents\n            // 28-Oct-2018, tatu: But, maybe call `_nextToken2()` first?\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            // Need to include this specific START_OBJECT?\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            // Still not included, but need to create context for structure, scanning\n            _headContext = _headContext.createChildObjectContext(f, false);\n\n            // Also: only need buffering if parent path to be included\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            if (_includePath) {\n                 t = _nextTokenWithBuffering(_headContext);\n                 if (t != null) {\n                     _currToken = t;\n                     return t;\n                 }\n            }\n            // 28-Oct-2018, tatu: Added for [core#493] like START_ARRAY case\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                f = _headContext.getFilter();\n                boolean returnEnd = _headContext.isStartHandled();\n\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    // Is this needed? Looks suspicious... Need to see what it does.\n                    // Oh. Probably needed to ensure state updates are done?\n                    f.filterFinishArray(); // or Object, won't matter\n                }\n                _headContext = _headContext.getParent();\n                // We just return entries if context started AND if we are processing it\n                // (if not included, context filter is null)\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n                // 28-Oct-2018, tatu: Added for [core#493] like START_ARRAY case\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    // Throttling for single match is handled earlier\n                    // But what about path inclusion? Included, unless we throttle?\n                    // 11-Jun-2020, tatu: Seems like we may need to consider this --\n                    //   however, simply returning `null` earlier (that caused #607) is wrong.\n                    //   Need to rethink.\n                    /*\n                    if (!_includePath && !_allowMultipleMatches && (_matchCount > 0)) {\n                        // Need to skip past value... Note: will return `null`\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        break;\n                    }\n                    */\n                    return (_currToken = t);\n                }\n                if (f == null) { // Not included, skip value\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                // Need to check if this property is to be included\n                f = f.includeProperty(name);\n                if (f == null) { // No match, skip\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                // Yes included. Need to return the token... Any case where not?\n                if (f == TokenFilter.INCLUDE_ALL) { // complete match\n                    // If path is included, we just need FIELD_NAME, but if not, possibly START_OBJECT too:\n                    if (_includePath) {\n                        // May need to buffer FIELD_NAME plus possibly START_OBJECT\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                           _currToken = t;\n                            return t;\n                        }\n                        // note: fall-through case is odd, should not happen?\n                    }\n                    // Otherwise fall-through just fine? Or, wait... perhaps need buffering\n                    // because we don't want the START_OBJECT?\n                    // 15-Jun-2016, tatu: If path is not included, but this property is fully\n                    //   included AND its START_OBJECT/ARRAY is not yet output, need to output that first\n                    //   (note: this is only possible with buffering)\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                    // note: fall-through case is odd, should not happen?\n                } else { // possibly partial match\n                    // Need to buffer if path is being included OR if we aren't certain about inclusion\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                    // But otherwise can skip if it's known that it's not included... how would\n                    // we know this again? Ah. If !START_OBJECT && !FIELD_NAME returned.\n                    // Hmmh. Looks like we'll need to call `_nextToken2()`?\n                }\n                // 28-Oct-2018, tatu: Added for [core#493] like START_ARRAY case\n            }\n            break;\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    // Gotcha! But if parent wasn't included, may need buffering:\n                    if (_includePath) {\n                        // Note: may return current token, or FIELD_NAME, or START_OBJECT/ARRAY\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                    // Otherwise, we got it, no buffering needed (I think?)\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included), skip\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        // Need to read/skip until we get a match or end of input\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}