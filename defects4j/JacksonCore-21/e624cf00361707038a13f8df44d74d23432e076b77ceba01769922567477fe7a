{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n\n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // check for path inclusion is disabled\n        // If all the conditions matches then check for scalar / non-scalar property\n        // Make sense to short-circuit if ALL of these conditions are met:\n        //\n        // 1. We are not allowing multiple matches (_allowMultipleMatches == false)\n        // 2. We have already returned at least one token (_currToken != null)\n        // 3. We are not currently handling buffered tokens (_exposedContext == null)\n        // 4. We are not including the full path (_includePath == false) <--- Added this check\n        //\n        // If all conditions are met, we MIGHT be able to stop processing.\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null) && !_includePath) {\n            // If the last token returned was the end of a structure (object/array)\n            // AND its corresponding start token was already handled/returned...\n            if (_currToken.isStructEnd() && _headContext.isStartHandled()) {\n                 // ... then we are done with the single match, return null to indicate end-of-input\n                 // for this filtered view\n                return (_currToken = null);\n            }\n            // If the last token was a scalar value, AND its enclosing structure's start\n            // token was NOT handled (meaning the structure itself wasn't included), AND\n            // the filter matched this specific scalar (_itemFilter == INCLUDE_ALL)...\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                // ... then we are done with the single match, return null.\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    // [databind#1744]: If buffer is consumed, may need to exit\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        // Let's NOT advance parser but use current token as is\n                         _currToken = t;\n                         return t;\n                    }\n                    // Similarly, with FIELD_NAME we're at field name, need to get value etc:\n                    /* 26-May-2017, tatu: As per [jackson-core#364], seems we do need this...\n                    if (ctxt.inObject()) {\n                        t = delegate.getCurrentToken(); // Should be FIELD_NAME\n                         _currToken = t;\n                         return t;\n                    }\n                    */\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of\n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray(); // misnomer, applied to objects too\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    // We may also need to output START_OBJECT/ARRAY if parent wasn't included:\n                    if (_includePath) {\n                        //slightly different if path is included\n                         // Important: need to make sure parent START_OBJECT/ARRAY is written, if not yet done:\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                            // Let's fall through and let caller fetch it from buffer\n                            // Fall through: will return FIELD_NAME in the end\n                        }\n                        // Otherwise can just return the FIELD_NAME we have\n                        return (_currToken = t);\n                    }\n                    // If path not included, may need to include START_OBJECT/ARRAY implicitly\n                    // Minor twist here: if parent NOT included, may need to induce output of\n                    // surrounding START_OBJECT/END_OBJECT\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        // Need to generate START_OBJECT/ARRAY first?\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                    }\n                    // And in either case, we will return the FIELD_NAME, then value etc:\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                     if (_includeProperty(f)) { // Also checks _includePath\n                        return (_currToken = t);\n                    }\n                     // If path not included, need similar logic as above?\n                     // Actually, no: if properties match, but not including path,\n                     // we are golden. But with path inclusion, need buffering.\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                // If we get here, need to skip the value\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                if (_includePath) {\n                    // Important: need to make sure parent START_OBJECT/ARRAY is written, if not yet done:\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                        // Let's fall through and let caller fetch it from buffer\n                     }\n                    // Otherwise can just return the scalar value we have\n                    return (_currToken = t);\n                }\n                // If path not included, we have plain scalar value, return\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                     if (_includeScalarValue(f)) { // Also checks _includePath\n                        return (_currToken = t);\n                     }\n                } else if (f != null) {\n                    if (f.includeValue(delegate)) {\n                         if (_includeScalarValue(f)) { // Also checks _includePath\n                            return (_currToken = t);\n                         }\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        // is needed. This occurs for two basic reasons:\n        //\n        // 1. Filtering by path (whether explicit or implicit) -> potentially need to buffer, return enclosing structure\n        // 2. A match is found but potentially needs enclosing structure to be returned (when path inclusion enabled)\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}