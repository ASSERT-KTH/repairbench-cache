{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // This initial block handles stopping when the filter is complete, especially in single-match mode.\n        // It should return null only if the very last token of the filtered stream has been produced.\n        // This includes the closing token of the outermost included structure (e.g., root object/array).\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // Case 1: Just returned a structural end token (END_OBJECT/ARRAY)\n            if (_currToken.isStructEnd()) {\n                // If the _headContext (which is the parent of the token just consumed,\n                // as _headContext is popped in the ID_END_ARRAY/ID_END_OBJECT case below)\n                // is the root context (or null after root was popped), and its START token was handled,\n                // then we are done.\n                if (_headContext == null || (_headContext.getParent() == null && _headContext.isStartHandled())) {\n                    return (_currToken = null);\n                }\n            }\n            // Case 2: Just returned a scalar value.\n            // This is primarily for _includePath=false, where only scalar is returned without its path.\n            // If _headContext.isStartHandled() is false, it means the parent struct was NOT included.\n            // So after scalar, we stop.\n            else if (_currToken.isScalarValue()) {\n                if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                    return (_currToken = null);\n                }\n            }\n            // If _matchFound is true, and we are not in the above 'final stop' cases, it means\n            // we have returned the match, but still need to return closing tokens for the included path.\n            // So we shouldn't return null here yet. We proceed to _nextOrEmitEndTokens() to handle closing out.\n        }\n\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray(); // or Object\n                }\n                _headContext = _headContext.getParent();\n                // Fix: Ensure _itemFilter is updated correctly when _headContext becomes null\n                _itemFilter = (_headContext == null) ? TokenFilter.INCLUDE_ALL : _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    // Fix: Set _matchFound if single-match mode and this is the matching token\n                    if (!_allowMultipleMatches) { \n                        _matchFound = true;\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        // Fix: Set _matchFound if single-match mode and this is the matching token\n                        if (!_allowMultipleMatches) { \n                            _matchFound = true;\n                        }\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                // Fix: Set _matchFound if single-match mode and this is the matching token\n                if (!_allowMultipleMatches) { \n                    _matchFound = true;\n                }\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    // Fix: Set _matchFound if single-match mode and this is the matching token\n                    if (!_allowMultipleMatches) { \n                        _matchFound = true;\n                    }\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        // If a match was found in single-match mode, subsequent calls should only\n        // emit closing tokens for the included path, then null.\n        if (_matchFound && !_allowMultipleMatches) {\n            return _nextOrEmitEndTokens();\n        }\n        return _nextToken2();\n    }\n\n\n    // Helper method to emit only closing tokens when _matchFound is true and !_allowMultipleMatches.\n    // This is called when `nextToken()` needs to find a token, but the filter is effectively\n    // in a \"closing path\" state after finding the main match.\n    // This method will find and return structural end tokens (END_ARRAY, END_OBJECT)\n    // for contexts whose START tokens were previously emitted as part of the path,\n    // skipping any other tokens from the delegate.\n    protected JsonToken _nextOrEmitEndTokens() throws IOException\n    {\n        while (true) {\n            // 1. If _headContext is null, all contexts have been closed (including root).\n            // This signifies the true end of the filtered stream.\n            if (_headContext == null) {\n                return null;\n            }\n\n            // 2. If the current _headContext's START token was NOT handled (i.e., filtered out),\n            // we should not emit its corresponding END token either.\n            // We need to pop this context and look at its parent.\n            if (!_headContext.isStartHandled()) {\n                _headContext = _headContext.getParent();\n                _itemFilter = (_headContext == null) ? TokenFilter.INCLUDE_ALL : _headContext.getFilter();\n                // IMPORTANT: When popping an unhandled context, we must ensure\n                // that the delegate parser skips all tokens belonging to that context\n                // until its corresponding END token is reached.\n                // The current token in delegate is the one that caused this context to be created (e.g. START_OBJECT).\n                // So skip its children.\n                delegate.skipChildren(); // Skips all contents of the unhandled context.\n                continue; // Re-evaluate with the new (parent) _headContext.\n            }\n\n            // 3. _headContext is not null AND its START was handled.\n            // This means we should emit its corresponding END token.\n            JsonToken expectedEnd = _headContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            \n            // Read from the delegate until we find the expected END token for the current _headContext.\n            // Any other tokens (field names, values, nested structures) encountered during this search\n            // are considered extraneous and should be skipped.\n            JsonToken t = delegate.nextToken();\n            if (t == null) {\n                // This indicates an unexpected end of the underlying stream.\n                // It means a START token was returned, but no matching END was found.\n                // Or simply the delegate ran out of tokens before all expected ENDs were produced.\n                return null;\n            }\n            \n            // If the token from the delegate is the expected END for the current context:\n            if (t == expectedEnd) {\n                _headContext = _headContext.getParent(); // Pop context (move up the hierarchy)\n                _itemFilter = (_headContext == null) ? TokenFilter.INCLUDE_ALL : _headContext.getFilter();\n                return (_currToken = t); // Return this END token.\n            }\n            \n            // If it's not the expected END token, it means we're still inside the current context\n            // and encountered a token (e.g., FIELD_NAME, another START_ARRAY/OBJECT, or a scalar)\n            // that is NOT the match and should be skipped.\n            if (t.isStructStart() || t.isFieldName()) {\n                delegate.skipChildren(); // Skip the entire structure or field value.\n            }\n            // Continue the loop to read the next token from the delegate, searching for the expected END.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}