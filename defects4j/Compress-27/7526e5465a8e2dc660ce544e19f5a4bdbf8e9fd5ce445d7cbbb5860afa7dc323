{
    "generation": "    /**\n     * Parse an octal string from a buffer.\n     *\n     * <p>Leading spaces are ignored.\n     * The buffer must contain a trailing space or NUL,\n     * and may contain an additional trailing space or NUL.</p>\n     *\n     * <p>The input buffer is allowed to contain all NULs,\n     * in which case the method returns 0L\n     * (this allows for missing fields).</p>\n     *\n     * <p>To work-around some tar implementations that insert a\n     * leading NUL this method returns 0 if it detects a leading NUL\n     * since Commons Compress 1.4.</p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n     * @return The long value of the octal string.\n     * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n     */\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end = offset + length;\n        int     start = offset;\n\n        if (length < 2){\n            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n        }\n\n        // Handle cases of starting NUL bytes, returning 0 as specified.\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end){\n            if (buffer[start] == ' '){\n                start++;\n            } else {\n                break;\n            }\n        }\n\n        // Trim all trailing NULs and spaces.\n        // The ustar and POSIX tar specs require a trailing NUL or\n        // space but some implementations use the extra digit for big\n        // sizes/uids/gids ...\n        // Keep track of the last byte before trimming, although it's unused now\n        // as the exception it was used for is replaced by returning 0.\n        byte trailer = buffer[end - 1]; // Save potential last byte for context (unused in fixed code)\n        // Loop while the byte at end-1 is a NUL or space.\n        while (start < end && (buffer[end - 1] == 0 || buffer[end - 1] == ' ')) {\n            end--;\n            // If end becomes <= start, the loop condition start < end will handle termination.\n        }\n\n        // FIX: If start == end after trimming leading spaces and trailing NULs/spaces,\n        // it means the string contained only spaces/NULs or was effectively empty.\n        // Return 0 in this case, consistent with handling of all-NUL fields.\n        if (start == end) {\n            // The original code threw an exception here.\n            // The test case for {' ', 0} expected 0L.\n            // throw new IllegalArgumentException(\n            //        exceptionMessage(buffer, offset, length, start, trailer)); // Old failing code\n             return 0L;\n        }\n        // If we reach here, start < end, and the byte at buffer[end-1] (the last one considered part of the number)\n        // is not a space or NUL. We proceed to parse the digits between start and end.\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            // CheckStyle:MagicNumber OFF\n            if (currentByte < '0' || currentByte > '7'){\n                // Use a helper method (assumed to exist) to generate the exception message\n                // Pass the actual invalid byte and its position.\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n            // CheckStyle:MagicNumber ON\n        }\n\n        return result;\n    }\n\n    // Assume this helper method exists in the original class TarUtils\n    // It's needed for the IllegalArgumentException thrown inside the parsing loop.\n    // Based on the test failure message, it likely creates a message like:\n    // \"Invalid byte [byteValue] at offset [offsetInField] in '[fieldContent]' len=[totalLength]\"\n    private static String exceptionMessage(byte[] buffer, int offset, int length, int badByteOffset, byte badByte) {\n         // This is a plausible implementation based on typical error messages\n         String prefix = \"Invalid byte \" + badByte + \" at offset \" + (badByteOffset - offset) + \" in '\";\n         String suffix = \"' len=\" + length;\n         // Create string representation, replacing NULs for clarity\n         StringBuilder sb = new StringBuilder();\n         for (int i = 0; i < length; i++) {\n             byte b = buffer[offset + i];\n             if (b == 0) {\n                 sb.append(\"{NUL}\");\n             } else {\n                 // Handle potential non-printable characters if needed,\n                 // but simple char cast is often sufficient for TAR data.\n                 sb.append((char) b);\n             }\n         }\n         return prefix + sb.toString() + suffix;\n     }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}