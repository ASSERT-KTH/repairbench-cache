{
    "generation": "@SuppressWarnings(\"deprecation\")\nprotected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n    throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        if (serializationType == null) {\n            // serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n    \n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n\n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        Object defaultBean = _defaultBean;\n        if (_useRealPropertyDefaults && defaultBean != null) {\n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n            suppressNulls = true;\n        }\n        // Fix for https://github.com/FasterXML/jackson-databind/issues/1351: \n        // for NON_DEFAULT, if the actual value is null, suppress output\n        suppressNulls = true;\n\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n        break;\n    case NON_ABSENT:\n        suppressNulls = true;\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        suppressNulls = true;\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}