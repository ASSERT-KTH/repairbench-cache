{
    "generation": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        \n        // Start with the specific mix-in class.\n        parents.add(mixInCls);\n        \n        // Add all its super-types (classes and interfaces) up to Object.class.\n        // ClassUtil.findSuperTypes will add elements in specific-to-general order (e.g., direct super-class, then its super-class, etc.).\n        // It does NOT include the starting `mixInCls` itself, which is why we add it manually first.\n        ClassUtil.findSuperTypes(mixInCls, Object.class, parents);\n        \n        // To ensure correct merging order (general to specific, so more specific mix-in annotations override earlier ones),\n        // reverse the list. This makes the iteration go from base classes of mix-ins to the mixInCls itself.\n        Collections.reverse(parents);\n\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    // When iterating from general to specific, _addMixUnders will first apply annotations\n                    // from super-mixins, then from sub-mixins. This allows sub-mixins to effectively\n                    // override or augment annotations applied by their super-mixins, ensuring correct precedence.\n                    _addMixUnders(m, am);\n                } else {\n                    // This else branch handles methods that are introduced solely by the mix-in hierarchy\n                    // and do not have a corresponding method on the targetClass.\n                    // `AnnotatedMethodMap.add` will merge/replace based on signature, so processing\n                    // from general to specific ensures the most specific mix-in's annotations prevail.\n                    mixIns.add(_constructMethod(m));\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}