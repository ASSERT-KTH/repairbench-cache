{
    "generation": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        // [databind#137] Ensure proper merging of multi-level mixins\n        // findSuperTypes will add parent classes to `parents` list.\n        // It's `ClassUtil.findSuperTypes(mixInCls, targetClass, parents);`\n        // which means `parents` will be ordered from mixInCls to targetClass/Object.\n        // Example: [PersonMixin, BaseMixin, Object] if Person.class is not parent of PersonMixin.\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n\n        // So that we get \"parent-most\" first (until targetClass or Object),\n        // let's iterate from end to start.\n        // This ensures that annotations from more general mixins (e.g., BaseMixin) are processed first,\n        // and then potentially overridden/augmented by more specific mixins (e.g., PersonMixin).\n        for (int i = parents.size(); --i >= 0; ) {\n            Class<?> mixin = parents.get(i);\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                \n                // [databind#515] Multi-level mixins: must ensure mixin method itself gets merged\n                // Check if *already* found in mixIns (from a more specific mixin already processed)\n                AnnotatedMethod am = mixIns.find(m);\n                if (am != null) {\n                    // If found, merge current mixin's annotations into existing mixin method.\n                    // This handles scenarios where a method from a super-mixin is being augmented\n                    // by a sub-mixin's version (even if the sub-mixin doesn't add new annotations).\n                    _addMixUnders(m, am);\n                } else {\n                    // Otherwise, construct a new AnnotatedMethod for this mixin method and add it.\n                    mixIns.add(_constructMethod(m));\n                }\n                \n                // And now also apply to actual target method (if it exists).\n                // This updates the 'AnnotatedMethod' object which is already in 'methods' map\n                // (representing the target class's methods).\n                AnnotatedMethod actualMethod = methods.find(m);\n                if (actualMethod != null) {\n                    _addMixUnders(m, actualMethod);\n                }\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}