{
    "generation": "import java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n// Assuming MethodKey is available, e.g., import com.fasterxml.jackson.databind.introspect.MethodKey;\n// Assuming ClassUtil is available, e.g., import com.fasterxml.jackson.databind.util.ClassUtil;\n// Assuming AnnotatedMethodMap is available, e.g., import com.fasterxml.jackson.databind.introspect.AnnotatedMethodMap;\n// Assuming AnnotatedMethod is available, e.g., import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n\n\n    /**\n     * Helper method used for adding annotated methods from given mix-in\n     * class (and its supertypes)\n     * \n     * @param targetClass Target class to add methods to\n     * @param methods Map of methods to add methods to\n     * @param mixInCls Mix-in class that contains annotated methods to add\n     * @param mixIns Map of mix-in methods found so far (passed to allow\n     *   handling of possible duplicates)\n     */\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        // [databind#515]: need to ensure that we do NOT add mix-ins if masked by non-mixin ones.\n        // And based on experiments, seems like we MUST include mix-in class itself as well,\n        // not just super types. Also, order seems to matter, presumably sub-classes override\n        // super-class annotations.\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        // We used to pass `targetClass` as 3rd arg, but that seems wrong, filtering has to happen later?\n        // Or maybe requirement is that we should only consider mix-in hierarchy up to target class? Let's revert that part for now\n         ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n\n        // Keep track of signatures for which mix-ins have been applied or added.\n        // Use MethodKey for robust signature matching.\n        // This prevents super-class mix-in annotations from overriding sub-class mix-in annotations.\n        HashSet<MethodKey> processed = new HashSet<>();\n\n        for (Class<?> mixin : parents) { // Process subclass mixins first (due to parents.add(mixInCls) first)\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                MethodKey key = new MethodKey(m);\n                // Let's process only the first time we encounter a method signature\n                // (which will be from the most specific mixin subclass)\n                if (processed.add(key)) {\n                    AnnotatedMethod am = methods.find(m);\n                    if (am != null) {\n                        // Method exists in target class hierarchy: apply annotations from mixin\n                        _addMixUnders(m, am);\n                    } else {\n                        // Method does not exist in target class hierarchy (yet): add mixin method to mixIns map\n                        // (for possible later application, e.g. on fields)\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n                // If processed.add(key) returned false, we've already handled this signature\n                // with a more specific mixin subclass, so we do nothing for this superclass method 'm'.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}