{
    "generation": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return position on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text. The returned position is the index\n     * into the text string.\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int limit = startPos + width;\n\n        // Check if the rest of the text fits within the width.\n        // Also handles cases where startPos is already at or beyond the text length.\n        if (limit >= text.length()) {\n            return -1; // No wrap needed, indicates end of text.\n        }\n\n        // Check for the first explicit newline or tab occurring strictly before the limit.\n        int pos_n = text.indexOf('\\n', startPos);\n        int pos_t = text.indexOf('\\t', startPos);\n        int explicitBreakPos = -1;\n\n        // Determine the position of the earliest explicit break character (\\n or \\t).\n        if (pos_n != -1 && (pos_t == -1 || pos_n < pos_t)) {\n            explicitBreakPos = pos_n;\n        } else {\n            explicitBreakPos = pos_t; // Assigns pos_t, which might be -1.\n        }\n\n        // If an explicit break character was found before the width limit,\n        // return the position immediately following it as the wrap point.\n        if (explicitBreakPos != -1 && explicitBreakPos < limit) {\n            return explicitBreakPos + 1;\n        }\n\n        // Look for the last whitespace character (' ', '\\n', '\\r') \n        // in the range [startPos, limit - 1]. Search backwards from limit - 1.\n        int searchPos = limit; // Initialize search position relative to the limit.\n        while (searchPos > startPos) {\n            // Decrement first to check indices from limit - 1 down to startPos.\n            searchPos--; \n\n            // Get the character at the current search position.\n            char c = text.charAt(searchPos);\n\n            // If a whitespace character is found\n            if (c == ' ' || c == '\\n' || c == '\\r') {\n                // Found the last whitespace position before the limit.\n                // Return its index as the wrap position. This matches test expectations where\n                // for \"This is a test.\", width=8, startPos=0, the space at index 7 is found,\n                // and 7 is returned.\n                return searchPos;\n            }\n        }\n\n        // No whitespace found within the range [startPos, limit - 1].\n        // This means a word is longer than the allowed width or runs up to the limit.\n        // Force a wrap at the width limit.\n        return limit;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}