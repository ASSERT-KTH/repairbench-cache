{
    "generation": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a\n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        // Calculate the absolute end position for the current line segment.\n        // This is the boundary (exclusive) for finding a wrap point.\n        int wrapLimit = startPos + width;\n\n        // Check for explicit newlines or tabs that force a break before the wrapLimit.\n        // This takes precedence over finding other whitespace for wrapping.\n        // It prioritizes the earliest \\n, then earliest \\t, within the wrapLimit.\n        // The return pos + 1 means the line breaks AFTER the newline/tab character.\n        int newlinePos = text.indexOf('\\n', startPos);\n        int tabPos = text.indexOf('\\t', startPos);\n\n        // Determine the effective earliest hard break if any exist within the wrapLimit\n        int earliestHardBreakPos = Integer.MAX_VALUE;\n\n        if (newlinePos != -1 && newlinePos < wrapLimit) {\n            earliestHardBreakPos = Math.min(earliestHardBreakPos, newlinePos);\n        }\n        if (tabPos != -1 && tabPos < wrapLimit) {\n            earliestHardBreakPos = Math.min(earliestHardBreakPos, tabPos);\n        }\n\n        if (earliestHardBreakPos != Integer.MAX_VALUE) {\n            return earliestHardBreakPos + 1; // Break after the hard break character\n        }\n\n        // If the remaining text from startPos fits entirely within 'width'\n        // (i.e., wrapLimit reaches or exceeds the text length),\n        // no wrapping is needed for this segment.\n        if (wrapLimit >= text.length())\n        {\n            return -1;\n        }\n\n        // Look for the last whitespace character (space, \\n, \\r)\n        // strictly before 'wrapLimit' (i.e., from index `wrapLimit - 1` downwards)\n        // and at or after 'startPos'.\n        // If a whitespace is found, that's the desired wrap point.\n        for (int i = wrapLimit - 1; i >= startPos; i--)\n        {\n            char c = text.charAt(i);\n            if (c == ' ' || c == '\\n' || c == '\\r')\n            {\n                // Found a whitespace, return its position. The line breaks AT this character.\n                return i;\n            }\n        }\n\n        // If no whitespace character was found in the range [startPos, wrapLimit - 1],\n        // then according to the specification, return startPos + width.\n        // This means chopping the word at the exact width boundary (wrapLimit).\n        return wrapLimit;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}