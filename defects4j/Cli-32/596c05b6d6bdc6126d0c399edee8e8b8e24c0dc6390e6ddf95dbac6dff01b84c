{
    "generation": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a\n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return position on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text. This is the index of the whitespace\n     * character or startPos + width if no whitespace was found.\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int limit = startPos + width;\n\n        // Check if the wrap position is beyond the text length or\n        // if the remaining text is shorter than the width\n        if (limit >= text.length())\n        {\n            // End of text is within the width, so no wrap needed\n            return -1;\n        }\n\n        // Search backward from the character just before the limit\n        // for the last whitespace character (space, newline, carriage return).\n        // Start searching from limit index backwards. The first check will be limit - 1.\n        int pos = limit; \n        while (--pos >= startPos) // Check indices from limit - 1 down to startPos\n        {\n            char c = text.charAt(pos);\n            if (c == ' ' || c == '\\n' || c == '\\r')\n            {\n                // Found the last whitespace character within the range [startPos, limit).\n                // Return its index. The caller (renderWrappedText) should handle\n                // advancing past this character (e.g., start next line at pos + 1).\n                return pos;\n            }\n        }\n\n        // No whitespace character found within the range [startPos, limit).\n        // The word must be split/cut at the limit.\n        // Return the limit position (startPos + width).\n        return limit;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}