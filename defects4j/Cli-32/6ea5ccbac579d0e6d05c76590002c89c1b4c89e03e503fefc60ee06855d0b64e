{
    "generation": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos;\n        \n        // The original code uses `pos <= width` here. Assuming `width` refers to\n        // the max length from `startPos`, a position `p` is within the limit\n        // if `p - startPos < width`, or `p < startPos + width`.\n        // This change aligns the check with the concept of column width.\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos < startPos + width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos < startPos + width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n        // Determine the effective end of the search range for finding a whitespace.\n        // This is `startPos + width - 1` (the last character index within the width limit).\n        // Ensure this index does not go beyond the actual end of the text.\n        int searchEndIndex = startPos + width;\n        pos = Math.min(searchEndIndex - 1, text.length() - 1);\n\n        // If, after calculating `pos`, it falls before `startPos`, it means\n        // the effective search range (e.g., for very small `width` values like 0 or 1)\n        // is invalid. In this case, no whitespace can be found within the range,\n        // so we fall back to chopping at `startPos + width` as per the description.\n        if (pos < startPos) {\n            return startPos + width;\n        }\n\n        char c;\n\n        // Look for the last whitespace character before `startPos + width`.\n        // The loop iterates backwards from `pos` (which is `startPos + width - 1` or `text.length() - 1`)\n        // down to `startPos`. `pos < text.length()` is implicitly handled by `Math.min` above.\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // If a whitespace was found (i.e., `pos` is still a valid index >= `startPos`),\n        // return its position.\n        // Original code used `pos > startPos`, which would ignore a whitespace at `startPos`.\n        // Changing to `pos >= startPos` correctly includes it.\n        if (pos >= startPos)\n        {\n            return pos;\n        }\n        \n        // If no whitespace character was found in the specified range,\n        // simply chop at `startPos + width` as per the function's description.\n        // The original code's second `while` loop (which searched forward for the\n        // next whitespace) was removed because it contradicted this specific rule.\n        return startPos + width;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}