{
    "generation": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     * Newlines and tabs characters found before startPos+width will also cause\n     * wrapping, returning the position after the newline/tab.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap\n     * position is at the end of the text (meaning the rest fits)\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int length = text.length();\n\n        // Check for forced wrap characters (newline, tab) within the window [startPos, startPos + width)\n        int earliestSpecialCharPos = -1;\n        int newlinePos = text.indexOf('\\n', startPos);\n        int tabPos = text.indexOf('\\t', startPos);\n\n        // Find the first occurring newline or tab\n        if (newlinePos != -1 && (tabPos == -1 || newlinePos < tabPos)) {\n            earliestSpecialCharPos = newlinePos;\n        } else {\n            earliestSpecialCharPos = tabPos;\n        }\n\n        // If a special character forces an early wrap within the desired width\n        if (earliestSpecialCharPos != -1 && earliestSpecialCharPos < startPos + width) {\n            // Return position immediately following the special character\n            return earliestSpecialCharPos + 1;\n        }\n\n        // If the potential wrap position (startPos + width) is at or beyond the end of the text,\n        // it means the rest of the text fits on the current line. Return -1 to indicate this.\n        if (startPos + width >= length) {\n            return -1;\n        }\n\n        // Look for the last whitespace character (space, \\n, \\r) in the range [startPos, startPos + width - 1]\n        // The position where we cut if no whitespace is found.\n        int potentialCutPos = startPos + width;\n        int lastWhitespaceIndex = -1;\n\n        // Search backwards from index startPos + width - 1 down to startPos\n        // Note: We check down to startPos (inclusive) because whitespace at startPos itself\n        // (like leading space in the substring) is not a wrap point according to the logic,\n        // but finding it helps determine if any *other* whitespace exists later in the range.\n        for (int i = potentialCutPos - 1; i >= startPos; --i) {\n            char c = text.charAt(i);\n            if (c == ' ' || c == '\\n' || c == '\\r') {\n                lastWhitespaceIndex = i; // Found the last whitespace in the relevant range\n                break;\n            }\n        }\n\n        // If we found a whitespace at an index strictly greater than startPos\n        // (we don't wrap right at the beginning of the segment unless it was \\n or \\t handled above)\n        if (lastWhitespaceIndex > startPos) {\n            // The wrap position is immediately after the whitespace\n            return lastWhitespaceIndex + 1;\n        }\n        \n        // Otherwise, no suitable whitespace was found in (startPos, startPos + width - 1].\n        // We must wrap by cutting the word at the width limit.\n        // We already know potentialCutPos < length from the check above.\n        return potentialCutPos;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}