{
    "generation": "    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last position before startPos+width having a \n     * whitespace character (space, \\n, \\r). If there is no whitespace character\n     * before startPos+width, it will return startPos+width.\n     * <p>\n     * This method returns the index of the first character of the next line.\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace\n     * character\n     * @return position on which the text must be wrapped (the start index of the\n     * next line) or -1 if the wrap position is at the end of the text.\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int limit = startPos + width;\n\n        // 1. Check for forced breaks (\\n, \\t) first\n        int pos = -1;\n        int newlinePos = text.indexOf('\\n', startPos);\n        int tabPos = text.indexOf('\\t', startPos);\n\n        // Find the earliest forced break\n        if (newlinePos != -1 && (tabPos == -1 || newlinePos < tabPos))\n        {\n            pos = newlinePos;\n        }\n        else\n        {\n            pos = tabPos;\n        }\n\n        // If a forced break exists and occurs before the desired limit\n        if (pos != -1 && pos < limit)\n        {\n            // Wrap position is after the forced break character\n            return pos + 1;\n        }\n\n        // 2. Check if we have effectively reached the end of the text\n        // within the limit. Return -1 to signal no further wrapping is needed.\n        if (limit >= text.length())\n        {\n            return -1;\n        }\n\n        // 3. Search backwards for a whitespace character within [startPos, limit)\n        // The wrap position is the index *after* the whitespace.\n        int currentIdx = limit; // Start searching backward from index limit-1 down to startPos\n        while (currentIdx > startPos)\n        {\n            currentIdx--; // index to check: limit-1, limit-2, ..., startPos\n            char c = text.charAt(currentIdx);\n\n            if (c == ' ' || c == '\\n' || c == '\\r')\n            {\n                // Found whitespace. Wrap position is after this character.\n                return currentIdx + 1;\n            }\n        }\n        // Loop finished without finding whitespace between startPos and limit-1.\n\n        // 4. No whitespace found in [startPos, limit).\n        // We have to cut the word at the width limit. The next line starts at limit.\n        return limit;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}