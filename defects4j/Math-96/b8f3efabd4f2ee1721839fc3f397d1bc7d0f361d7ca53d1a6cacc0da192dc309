{
    "generation": "    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to\n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     *\n     */\n    public boolean equals(Object other) {\n        boolean ret;\n\n        if (this == other) {\n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    // The original code used Double.doubleToRawLongBits for comparison.\n                    // This method distinguishes between 0.0 and -0.0 (positive and negative zero),\n                    // which are considered mathematically equal by the IEEE 754 standard for most operations,\n                    // and by Java's '==' operator for doubles.\n                    // The test 'testMath221' fails because the multiply operation can result in -0.0\n                    // when the expected value is 0.0, causing the raw bit comparison to fail.\n                    //\n                    // To align with mathematical equality and fix the bug, we should use the '==' operator\n                    // for double comparison, which treats 0.0 and -0.0 as equal.\n                    // The special NaN equality rule (NaN == NaN is true) is handled by the\n                    // 'rhs.isNaN()' and 'this.isNaN()' checks above.\n                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary());\n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n\n        return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}