{
    "generation": "    /**\n     * Test for the equality of two Complex objects.\n     * <p>\n     * If both the real and imaginary parts of two Complex numbers\n     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n     * Complex objects are considered to be equal.</p>\n     * <p>\n     * All <code>NaN</code> values are considered to be equal - i.e, if either\n     * (or both) real and imaginary parts of the complex number are equal\n     * to <code>Double.NaN</code>, the complex number is equal to \n     * <code>Complex.NaN</code>.</p>\n     *\n     * @param other Object to test for equality to this\n     * @return true if two Complex objects are equal, false if\n     *         object is null, not an instance of Complex, or\n     *         not equal to this Complex instance\n     * \n     */\n    public boolean equals(Object other) {\n        boolean ret;\n        \n        if (this == other) { \n            ret = true;\n        } else if (other == null) {\n            ret = false;\n        } else  {\n            try {\n                Complex rhs = (Complex)other;\n                // As per the Javadoc, if either Complex number is a \"NaN complex number\"\n                // (i.e., its real or imaginary part is Double.NaN), then they are equal\n                // if and only if both are \"NaN complex numbers\".\n                if (rhs.isNaN()) {\n                    ret = this.isNaN();\n                } else {\n                    // If neither 'this' nor 'rhs' are \"NaN complex numbers\",\n                    // then equality is determined by the exact sameness of their parts.\n                    // The original code used Double.doubleToRawLongBits for comparison.\n                    // This distinguishes between +0.0 and -0.0.\n                    // The test case `testMath221` implies that +0.0 and -0.0 should be\n                    // considered equal for the purpose of Complex equality (e.g., if a\n                    // multiplication results in -0.0 for a part where the expected\n                    // value is +0.0, they should still be considered equal).\n                    // Double.compare() treats +0.0 and -0.0 as equal, and also NaN as equal to NaN\n                    // (though NaN comparison for individual parts should ideally not be reached here\n                    // if the initial isNaN() check is correct).\n                    // Using Double.compare provides the desired numerical equality for non-NaN values.\n                    ret = (Double.compare(real, rhs.getReal()) == 0) && \n                          (Double.compare(imaginary, rhs.getImaginary()) == 0);\n                }\n            } catch (ClassCastException ex) {\n                // ignore exception\n                ret = false;\n            }\n        }\n      \n        return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}