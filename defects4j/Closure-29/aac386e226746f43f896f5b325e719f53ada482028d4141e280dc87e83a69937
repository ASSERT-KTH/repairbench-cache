{
    "generation": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n *\n * In order for the object literal to be \u201cinlinable\u201d all non\u2010full\n * (i.e. GETPROP) references must only access properties that are either\n * defined by the full assignment or (in a few very specific cases)\n * are taken from Object.prototype.\n *\n * Also, if more than one full assignment exists the union of property\n * names must be \u201ccompatible\u201d. (For example, if a property is read but \n * has never been written to, we bail out unless it is one of a few \n * well\u2013known prototype properties.)\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n  // When inlining an object literal, we gather the \u201cknown\u201d property names.\n  // For a full assignment, these are the literal\u2019s own keys; and for a property-\n  // assignment (like x.foo = \u2026) the property name is added as soon as we see a write.\n  Set<String> inlinedKeys = new HashSet<>();\n  boolean foundFullAssignment = false;\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    if (parent.isGetProp()) {\n      // The GETPROP references (indirect accesses) are not \u201cfull\u201d\n      // references.  They are safe only if the property being accessed\n      // is one that we have already \u201cseen\u201d (or, for a read, is one of a few\n      // allowed properties on Object.prototype).\n      Preconditions.checkState(parent.getFirstChild() == name);\n\n      // If the GETPROP is used as the call\u2019s target, then the object may be used\n      // as the \"this\" value, and we can\u2019t split it up.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // Determine which property is being accessed.\n      String prop = parent.getLastChild().getString();\n\n      // For property assignments (writes), ref.getAssignedValue() is non-null.\n      if (ref.getAssignedValue() != null) {\n        inlinedKeys.add(prop);\n      } else {\n        // For property reads, the property must have been seen already,\n        // or else it must be one of a few safe built\u2010ins.\n        if (!inlinedKeys.contains(prop)) {\n          if (!(\"toString\".equals(prop) || \"valueOf\".equals(prop) ||\n                \"hasOwnProperty\".equals(prop))) {\n            return false;\n          }\n        }\n      }\n      continue;\n    }\n\n    // Only allow full references that are either variable declarations\n    // or simple assignment statements.\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A declaration with no assignment is safe.\n      continue;\n    }\n    // For full assignments we only accept object literal initializers.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n    // As a safety\u2013valve we do not inline an \u201cempty\u201d object literal if it comes\n    // from an ordinary assignment. (In practice many safe inlinable objects come\n    // from VAR declarations whose initializer is an object literal.)\n    if (val.getFirstChild() == null && !parent.isVar()) {\n      return false;\n    }\n    // Check for banned features \u2013 for example ES5 getters/setters or self\u2013referral.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        return false;\n      }\n      // Record this property as \u201cpresent\u201d in the object.\n      String key = child.getString();\n      inlinedKeys.add(key);\n      Node childVal = child.getFirstChild();\n      // If any of the references somehow occur inside the value\n      // for an initializer (a self reference), bail out.\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    foundFullAssignment = true;\n  }\n  return foundFullAssignment;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}