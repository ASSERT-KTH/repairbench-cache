{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n\nclass Fixed {\n    /**\n     * Determines if *all* references to a variable are safe for inlining\n     * an object literal assigned to it. Disallows property accesses/calls,\n     * property assignments, inc/dec, delete, non-literal assignments,\n     * and literals with getters/setters or self-references.\n     *\n     * Based on original logic, updated to handle GETPROP/GETELEM more strictly.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean foundGoodAssignment = false;\n\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // --- Disallowed cases ---\n\n        // 1. Property access/call via '.' (GETPROP)\n        // Examples: x.prop, x.prop(), x.prop = 1\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name,\n              \"Parent's first child should be the NAME node %s\", name);\n          // x.prop() is disallowed because 'this' might be used.\n          if (gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n          // Any other access (read x.prop or write x.prop=...) prevents inlining\n          // because the property might be undefined or inherited via prototype.\n          // The pass doesn't handle properties not explicitly defined in an\n          // inlinable assignment.\n          return false;\n        }\n\n        // 2. Property access/call via '[]' (GETELEM)\n        // Examples: x[prop], x[prop](), x[prop] = 1\n        if (parent.isGetElem()) {\n             Preconditions.checkState(parent.getFirstChild() == name,\n                 \"Parent's first child should be the NAME node %s\", name);\n             // x[prop]() is disallowed.\n             if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                 return false;\n             }\n             // Any other access (read x[prop] or write x[prop]=...) prevents inlining.\n             return false;\n         }\n\n        // 3. Increment/decrement (x++, --x)\n        if (parent.isInc() || parent.isDec()) {\n          return false;\n        }\n\n        // 4. Delete variable (delete x)\n        // NodeUtil.isDeleteOperator covers the DELPROP token\n        if (NodeUtil.isDeleteOperator(parent) && parent.getFirstChild() == name) {\n           return false;\n        }\n\n        // --- Allowed assignment cases ---\n        // Check if the reference is 'name' as the LHS of VAR or ASSIGN\n        if (isVarOrAssignExprLhs(name)) {\n          Node val = ref.getAssignedValue();\n          if (val == null) {\n            // var x; (No assignment) - This is fine.\n            continue; // Check other references.\n          }\n\n          // Assigned value must be an object literal.\n          if (!val.isObjectLit()) {\n            // x = non_object_literal; - Prevents inlining.\n            return false;\n          }\n\n          // Check object literal contents for disallowed patterns.\n          for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            // Disallow ES5 getters/setters.\n            if (child.isGetterDef() || child.isSetterDef()) {\n              return false;\n            }\n\n            // Disallow self-reference, e.g., var x = {a: x.b} or var x = {a: x}\n            // Check the value part of the key-value pair.\n            Node childVal = child.getLastChild(); // Value node for STRING_KEY\n            if (childVal != null && isNameInSubtree(childVal, name, refs)) {\n              return false;\n            }\n          }\n\n          // This reference is a valid object literal assignment. Mark that we found one.\n          foundGoodAssignment = true;\n          continue; // Continue checking other references.\n        }\n\n        // --- Other allowed cases (Assumed to be reads) ---\n        // If it's not one of the explicitly disallowed uses (cases 1-4)\n        // and not an assignment (handled above), assume it's an allowed read.\n        // Examples: foo(x), x || y, return x, if(x)\n        // These uses don't inherently prevent inlining the object's properties elsewhere.\n        continue;\n\n      } // End for loop over references\n\n      // To be inlinable, there must have been at least one valid object literal assignment,\n      // and no disqualifying uses encountered during the loop.\n      return foundGoodAssignment;\n    }\n\n   /** Helper to check if the specific variable 'varNameNode' (the variable being considered\n    * for inlining) is referenced within the 'subtree' node (part of an object literal value).\n    * Uses the 'refs' list to confirm it's the *same* variable, not just a matching name. */\n    private boolean isNameInSubtree(Node subtree, Node varNameNode, List<Reference> refs) {\n        if (subtree.isName() && subtree.getString().equals(varNameNode.getString())) {\n            // Check if this specific NAME node is one of the variable's references.\n            for (Reference ref : refs) {\n                if (ref.getNode() == subtree) {\n                    // Found a reference to the variable itself within the object literal value.\n                    return true;\n                }\n            }\n        }\n        // Recursively check children.\n        for (Node child = subtree.getFirstChild(); child != null; child = child.getNext()) {\n            if (isNameInSubtree(child, varNameNode, refs)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /** Checks if node n is the NAME node that is the direct LHS of a VAR or ASSIGN. */\n    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      // Check VAR: parent is VAR, n is the NAME node (first child)\n      if (parent.isVar() && parent.getFirstChild() == n) {\n          return true;\n      }\n      // Check ASSIGN: parent is ASSIGN, n is the LHS (first child)\n      if (parent.isAssign() && parent.getFirstChild() == n) {\n          return true;\n      }\n      return false;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}