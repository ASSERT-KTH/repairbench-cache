{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isObjectLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an array.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableArray(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isArrayLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a string.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableString(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isStringLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a number.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableNumber(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isNumberLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a boolean.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableBoolean(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isBooleanLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a regexp.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableRegExp(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isRegExpLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a null.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableNull(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isNullLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an undefined.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableUndefined(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isUndefinedLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a symbol.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableSymbol(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isSymbolLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a function.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableFunction(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isFunctionLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an object literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObjectLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isObjectLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an array literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableArrayLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isArrayLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a string literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableStringLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isStringLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a number literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableNumberLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isNumberLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a boolean literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableBooleanLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isBooleanLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a regexp literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableRegExpLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isRegExpLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a null literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableNullLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isNullLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an undefined literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableUndefinedLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isUndefinedLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a symbol literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableSymbolLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isSymbolLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a function literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableFunctionLiteral(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isFunctionLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an object literal.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isObjectLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to an array.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableArray(List<Reference> refs) {\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node refNode = ref.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          refNode = refNode.getParent();\n        }\n        if (!NodeUtil.isArrayLiteral(refNode)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Counts the number of direct (full) references to a string.\n     * Specifically we check for references of the following type:\n     * <pre>\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}