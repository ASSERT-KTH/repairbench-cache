{
    "generation": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  boolean seenLiteralAssignment = false;\n  Set<String> unionProps = new HashSet<>();\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Ignore indirect references, like x.y (except x.y(), since\n    // the function referenced by y might reference 'this').\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target maybe using the object as a 'this' value.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      // Can't handle any property refs before we see a literal assignment.\n      if (!seenLiteralAssignment) {\n        return false;\n      }\n      String propName = parent.getLastChild().getString();\n      // If this is a write to x.prop = val, record the new prop.\n      if (gramps.isAssign() && gramps.getFirstChild() == parent) {\n        unionProps.add(propName);\n        continue;\n      }\n      // Otherwise it's a read; bail if the prop was never inlined or written.\n      if (!unionProps.contains(propName)) {\n        return false;\n      }\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Bail out on empty object literal (e.g., x = {}).\n    Node firstChild = val.getFirstChild();\n    if (firstChild == null) {\n      return false;\n    }\n\n    // Collect the properties of this literal, check for ES5 get/set and self-refs.\n    Set<String> propsInThisLiteral = new HashSet<>();\n    for (Node child = firstChild; child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        // ES5 get/set not supported.\n        return false;\n      }\n      String childName = child.getString();\n      propsInThisLiteral.add(childName);\n\n      // Check self-referential assignments.\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n\n    // Record the literal properties in our union set.\n    unionProps.addAll(propsInThisLiteral);\n    seenLiteralAssignment = true;\n    // Found a valid object literal assignment; we can inline as long\n    // as nothing else invalidates it.\n    ret = true;\n  }\n  return ret;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}