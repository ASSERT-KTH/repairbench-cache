{
    "generation": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n *\n * In addition to checking that every \u201cfull\u201d reference is safe, this version also\n * \u201ccollects\u201d the set of property names that are explicitly defined on the object.\n * If a property is later read, the property must have been defined (or, for an\n * empty object literal defined \u201cin\u2010line\u201d as part of a VAR declaration, be one\n * of a few allowed inherited properties, like \"toString\").\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n  // First pass: collect all property names coming from a defining assignment.\n  // Also determine whether we can \u201callow\u201d a property read if the object literal\n  // was empty in its VAR initializer (and thus does not have its own properties)\n  // in which case we allow reads of a few well\u2013known inherited properties.\n  Set<String> definedProps = new HashSet<>();\n  boolean foundDefinition = false;\n  // Default: disallow inherited properties.\n  boolean allowInherited = false;\n  // Whitelist for inherited properties that we allow only when the literal was\n  // written inline as a var initializer (and was empty).\n  Set<String> inheritedWhitelist = new HashSet<>(Arrays.asList(\n      \"toString\", \"valueOf\", \"hasOwnProperty\", \"constructor\"));\n  \n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    // For non\u2013getProp references, these should be the defining assignments\n    if (!parent.isGetProp()) {\n      if (!isVarOrAssignExprLhs(name)) {\n        return false;\n      }\n      Node val = ref.getAssignedValue();\n      if (val == null) {\n        continue;\n      }\n      if (!val.isObjectLit()) {\n        return false;\n      }\n      // If the assignment is part of a VAR declaration initializer then we can\n      // allow certain inherited properties if the literal is empty.\n      if (name.getParent() != null && name.getParent().isVar()) {\n        // When the literal is empty, there are no explicitly defined properties.\n        if (val.getChildCount() == 0) {\n          allowInherited = true;\n        }\n      } else {\n        // For assignments outside of a var declaration,\n        // do not allow inherited (implicit) properties.\n        allowInherited = false;\n      }\n      // Process the properties from the object literal.\n      for (Node prop = val.getFirstChild(); prop != null; prop = prop.getNext()) {\n        if (prop.isGetterDef() || prop.isSetterDef()) {\n          return false;\n        }\n        String key = prop.getString();\n        definedProps.add(key);\n        // Check for self-referential assignments.\n        Node childVal = prop.getFirstChild();\n        for (Reference t : refs) {\n          Node refNode = t.getParent();\n          while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n            if (refNode == childVal) {\n              return false;\n            }\n            refNode = refNode.getParent();\n          }\n        }\n      }\n      foundDefinition = true;\n    }\n    // Also, for getProp references that are assignments (e.g. x.foo = ...)\n    // we add the property to our set.\n    if (parent.isGetProp() && ref.getAssignedValue() != null) {\n      // The assumption is that in a getProp assignment the left child is the object.\n      Preconditions.checkState(parent.getFirstChild() == name);\n      String propName = parent.getLastChild().getString();\n      definedProps.add(propName);\n      // (We continue here even for assignments.)\n    }\n  }\n  \n  // Second pass: check all getProp accesses that are pure reads.\n  // Every property read must have been defined on the object\n  // (or, if none was defined and we allowed inherited properties, it must be in the whitelist).\n  for (Reference ref : refs) {\n    Node parent = ref.getParent();\n    if (parent.isGetProp() && ref.getAssignedValue() == null) {\n      // For a full property access such as x.foo, the object part is 'x'\n      // and the property name is in the last child.\n      String propName = parent.getLastChild().getString();\n      if (!definedProps.contains(propName)) {\n        if (allowInherited && inheritedWhitelist.contains(propName)) {\n          // Add it so that subsequent reads succeed.\n          definedProps.add(propName);\n        } else {\n          return false;\n        }\n      }\n      // Also, x.foo() is disallowed if the getProp is the call target.\n      Node gramps = ref.getGrandparent();\n      if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n    }\n  }\n  \n  return foundDefinition;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}