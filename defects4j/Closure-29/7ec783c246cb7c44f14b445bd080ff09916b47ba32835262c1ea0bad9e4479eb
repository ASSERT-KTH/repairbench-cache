{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  // We'll compute a union of \u201callowed\u201d property names that the object literal\n  // \u201cdefines\u201d (either explicitly via an assignment of an object literal or via an\n  // explicit property write later).  Any \u201cread\u201d of a property not in this set\n  // causes us to bail out.\n  Set<String> allowedProps = new HashSet<>();\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    if (parent.isGetProp()) {\n      // Our assumption is that for a property access, the first child of the getProp\n      // is the variable reference.\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // If the property\u2019s value is being used as a function \u201cthis\u201d (i.e. it\u2019s the call\n      // target) then we can\u2019t inline.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      // Distinguish property writes from property reads.\n      if (NodeUtil.isAssignmentOp(gramps) && gramps.getFirstChild() == parent) {\n        // This is a property assignment like: x.foo = <expr>.\n        Node propNode = parent.getLastChild();\n        if (!propNode.isString()) {\n          return false;\n        }\n        allowedProps.add(propNode.getString());\n        continue;\n      } else {\n        // Otherwise, it is a property read.  Bail if the property isn\u2019t one that has been\n        // \u201cdefined\u201d by one of the object literal assignments or a later property write.\n        Node propNode = parent.getLastChild();\n        if (!propNode.isString()) {\n          return false;\n        }\n        String prop = propNode.getString();\n        if (!allowedProps.contains(prop)) {\n          return false;\n        }\n        continue;\n      }\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements.\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A variable declaration with no initializer.\n      continue;\n    }\n\n    // We only want to inline assignments that are object literals.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Process every property in the object literal.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        // ES5 getters/setters are not supported.\n        return false;\n      }\n\n      // Record the property name as \u201cdefined\u201d by the literal.\n      String prop = child.getString();\n      allowedProps.add(prop);\n\n      Node childVal = child.getFirstChild();\n      // Make sure that this literal\u2019s property value is not a self reference.\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // Self-referential assignment detected.\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    // At least one assignment reference was acceptable.\n    ret = true;\n  }\n  return ret;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}