{
    "generation": "    /**\n     * Checks if all references are suitable for object literal inlining.\n     * Suitable references are:\n     * 1. Var declaration: `var x;`\n     * 2. Object literal assignment: `var x = {...}` or `x = {...}`\n     *    - Literal must not contain get/set or self-references.\n     * 3. Property assignment: `x.prop = ...`\n     * It disallows:\n     * - Non-object literal assignment: `x = 5`\n     * - Method call: `x.prop()`\n     * - Property read: `... x.prop ...` (due to prototype/undefined risks)\n     * - Other uses: `foo(x)`\n     *\n     * This is a conservative check based on the original code's comment\n     * about blind spots and the failing tests (Issue 724).\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      // An object is not inlinable unless there is at least one object literal\n      // assignment.\n      boolean foundObjectLiteralAssign = false;\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore indirect references, like x.y (except x.y(), since\n        // the function referenced by y might reference 'this').\n        // We also allow x.y = foo; for properties defined in the object literal.\n        // Other indirect references may be referencing prototype properties.\n        // Accessing prototype properties is problematic for this optimization,\n        // so we blacklist indirect references here, unless it is explicitly\n        // allowed.\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name,\n              \"Object literal node should be the first child of GETPROP\");\n\n          // A call target maybe using the object as a 'this' value.\n          // x.y()\n          // Check gramps != null before gramps.isCall()\n          if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Allow property assignments like x.y = foo;\n          // Check gramps != null before gramps.isAssign()\n          boolean isLhsOfAssign = gramps != null && gramps.isAssign() && gramps.getFirstChild() == parent;\n          if (isLhsOfAssign) {\n            // This reference is a property assignment (x.prop = ...).\n            // This is structurally compatible with inlining. Continue to the next ref.\n            continue;\n          }\n\n          // Otherwise, any other property access (read) is disallowed\n          // for safety (e.g. prototype reads like x.toString).\n          return false;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        // where the variable name is on the left-hand side.\n        if (!isVarOrAssignExprLhs(name)) {\n           // Any other use (e.g., foo(x), x + 1) disallows inlining.\n           return false;\n        }\n\n        // Handle VAR x or x = ...\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var declaration with no assignment (var x;). Fine.\n          continue;\n        }\n\n        // Check that the assigned value is an object literal.\n        if (!val.isObjectLit()) {\n          // Assigned something else (x = 5, x = foo()). Disallow.\n          return false;\n        }\n\n        // We found a valid object literal assignment. Mark it.\n        foundObjectLiteralAssign = true;\n\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x = {b: x.a}.\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() || child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          // Check for self-references in the values of the object literal\n          // The value is the second child of a STRING_KEY, GETTER_DEF, or SETTER_DEF\n          Node childVal = child.getLastChild();\n          Preconditions.checkNotNull(childVal, \"Object literal key node has no value\");\n\n          // Check if childVal is an ancestor of the usage t.getParent()\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            // Add null check for safety and avoid infinite loop if node is its own parent\n            while (refNode != null && refNode != refNode.getParent() && !NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n        // Literal checks passed for this reference.\n      } // end for loop\n\n      // We can inline if all references were OK and at least one was an objlit.\n      return foundObjectLiteralAssign;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}