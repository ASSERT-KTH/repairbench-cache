{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false; // Indicates if at least one acceptable object literal assignment is found.\n\n      for (Reference ref : refs) {\n        Node name = ref.getNode(); // The variable name being referenced (e.g., 'x')\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n        Node greatGramps = ref.getGreatGrandparent(); // Get the node 3 levels up\n\n        // Check for references that might use the object as a 'this' value.\n        // If it's a GETPROP, we need to check if it's the target of a call.\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n\n          // Case 1: Direct method call where 'name' is the 'this' context.\n          // Example: x.fn(); (where 'x.fn' is the parent, and its parent 'gramps' is a CALL node)\n          // This means the object 'x' is the 'this' context for the method 'fn'.\n          if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Case 2: Method called via .apply or .call on a property of 'name'.\n          // Example: x.prop.apply(thisArg, ...) or x.prop.call(thisArg, ...)\n          // Here, 'name' (x) is the base object. 'parent' is 'x.prop'.\n          // 'gramps' is the GETPROP node for 'x.prop.apply' (or '.call').\n          // 'greatGramps' is the CALL node for the 'apply' or 'call' invocation.\n          // In this scenario, 'x' is implicitly the 'this' context for 'prop'.\n          if (gramps != null && gramps.isGetProp() // e.g., gramps is the 'x.prop.apply' GETPROP node\n              && greatGramps != null && greatGramps.isCall() // greatGramps is the CALL node (e.g., for `apply`)\n              && greatGramps.getFirstChild() == gramps) { // gramps is the function target of the CALL\n            Node callTargetProperty = gramps.getSecondChild(); // This should be the 'apply' or 'call' NAME node\n            if (callTargetProperty != null &&\n                (\"apply\".equals(callTargetProperty.getString()) ||\n                 \"call\".equals(callTargetProperty.getString()))) {\n              return false; // Cannot inline if used this way.\n            }\n          }\n\n          // If it's a property access (x.y or x.y()) that doesn't involve 'this' context issues\n          // for 'x' itself, we can continue. These references don't determine inlinability,\n          // but the inliner itself will handle them.\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements.\n        // If the reference 'name' is not a VAR declaration or the left-hand side\n        // of an assignment expression, it means 'name' is used directly (e.g., f(x), x++, return x).\n        // Such direct uses prevent inlining because the inliner replaces property accesses,\n        // not the entire object's identity.\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment, e.g., `var x;`. This doesn't prevent inlining\n          // if a later assignment makes it an object literal, but it doesn't\n          // contribute to 'ret = true' either.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        // If 'name' is assigned something other than an object literal, it's not inlinable.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // If we reach this point, 'ref' is an assignment of an object literal.\n        // This is an acceptable type of reference for inlining.\n        ret = true;\n\n        // Make sure that the value is not self-referential. IOW,\n        // disallow things like x = {b: x.a}.\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported for inlining.\n            return false;\n          }\n\n          Node childVal = child.getFirstChild(); // The value node of the property (e.g., 'x.a' in 'b: x.a')\n          if (childVal == null) {\n              // Happens for shorthand properties like {a} or properties without explicit value in object literal.\n              continue;\n          }\n\n          // Check if childVal (a property value within the object literal) refers back to the\n          // object itself (e.g., x = {b: x.a}).\n          // This iterates through all references to the object 'name' (`x`).\n          // If the parent of any of these references (`refNode`) is the `childVal`\n          // (e.g., if `x.a` is the value of a property, and `x.a` is itself a reference parent),\n          // it's a self-referential assignment.\n          for (Reference t : refs) {\n            Node refNode = t.getParent(); // This is the parent of the reference `t` (e.g., GETPROP for x.a)\n            // Climb up the AST from `refNode` until a statement block is reached or null.\n            // If `childVal` is found along this path, it's a self-reference.\n            // The `while` loop ensures we only consider relevant ancestor nodes.\n            while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n      }\n      // An object is inlinable if at least one object literal assignment was found\n      // and no blocking conditions (like 'this' usage or non-literal assignments) were encountered.\n      return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}