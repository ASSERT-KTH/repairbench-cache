{
    "generation": "/**\n * Counts the number of direct (full) references to an object\n * and decides whether it\u2019s safe to inline it.  We keep track of\n * which properties have been defined (via object\u2010literal\n * assignments or via explicit \u201cx.prop = \u2026\u201d statements), bail\n * out on any unknown\u2010prop read or on any method\u2010call use of a\n * property (x.m(), to preserve this), and make sure we saw at\n * least one object\u2010literal assignment.\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n  // The set of properties we've seen defined so far.\n  Set<String> definedProps = new HashSet<>();\n  // Did we see at least one object\u2010literal assignment?\n  boolean sawObjectLiteral = false;\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = parent.getParent();\n\n    // 1) PROPERTY READ OR METHOD CALL\n    if (parent.isGetProp()) {\n      // Bail on method calls (x.m()) to preserve 'this'\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      // Otherwise it's a property read: must have been defined\n      String propName = parent.getLastChild().getString();\n      if (!definedProps.contains(propName)) {\n        return false;\n      }\n      continue;\n    }\n\n    // 2) MUST BE a VAR or simple ASSIGN LHS\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    // e.g. \"var x;\" with no initializer\n    if (val == null) {\n      continue;\n    }\n\n    // 3) OBJECT\u2010LITERAL ASSIGNMENT: collect its keys\n    if (val.isObjectLit()) {\n      sawObjectLiteral = true;\n      for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.isGetterDef() || child.isSetterDef()) {\n          // ES5 getters/setters not supported\n          return false;\n        }\n        String key = child.getString();\n        definedProps.add(key);\n\n        // Make sure we don't have self\u2010references like x = {a: x.b}\n        Node childVal = child.getFirstChild();\n        for (Reference r2 : refs) {\n          Node scan = r2.getParent();\n          while (!NodeUtil.isStatementBlock(scan)) {\n            if (scan == childVal) {\n              return false;\n            }\n            scan = scan.getParent();\n          }\n        }\n      }\n      continue;\n    }\n\n    // 4) EXPLICIT PROPERTY ASSIGNMENT, e.g. x.c = c\n    //    We accept it and record the new prop.\n    if (name.isGetProp()) {\n      String key = name.getLastChild().getString();\n      definedProps.add(key);\n      continue;\n    }\n\n    // Any other kind of assignment (x = non\u2010object) is not inlineable\n    return false;\n  }\n\n  // We only inline if we saw at least one object\u2010literal assignment\n  return sawObjectLiteral;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}