{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // This set will record the \u201cknown\u201d properties that have been defined\n  // by an object\u2010literal assignment or by an explicit property write.\n  Set<String> definedProps = new HashSet<>();\n  boolean hasDirectAssignment = false;\n\n  // First pass: Process \u201cfull\u201d (direct) assignments:\n  // We only allow inlining if there is at least one direct assignment\n  // where the assigned value is an object literal.\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    // If the reference is not a property access, it must be a var decl or\n    // a simple assignment.\n    if (!parent.isGetProp()) {\n      if (!isVarOrAssignExprLhs(name)) {\n        return false;\n      }\n      Node val = ref.getAssignedValue();\n      if (val != null) {\n        if (!val.isObjectLit()) {\n          return false;\n        }\n        hasDirectAssignment = true;\n        // For every property defined in the literal,\n        // check that there is no self-referential use.\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n          if (child.isGetterDef() || child.isSetterDef()) {\n            return false;\n          }\n          Node childVal = child.getFirstChild();\n          // If any part of the object literal\u2019s property value contains a\n          // reference back to the variable, bail out.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n          definedProps.add(child.getString());\n        }\n      }\n    }\n  }\n\n  // Second pass: Process property accesses (i.e. indirect references).\n  // We need to ensure that every property read of the variable only refers\n  // to a property that is \u201cknown\u201d (either defined in the literal or later\n  // assigned).  (An exception is made for \"toString\" and \"valueOf\",\n  // which might be inherited from Object.prototype.)\n  for (Reference ref : refs) {\n    Node parent = ref.getParent();\n    if (parent.isGetProp()) {\n      Node gramps = ref.getGrandparent();\n      // If the entire GETPROP is used as a call target, then the object\n      // might be used as the \"this\" value, so disallow inlining.\n      if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      // Get the property name from the GETPROP.\n      Node propNode = parent.getLastChild();\n      String propName = propNode.getString();\n      // Determine whether this GETPROP is used as the left-hand side of an assignment.\n      Node pParent = parent.getParent();\n      boolean isWrite = (pParent != null && pParent.isAssign() && pParent.getFirstChild() == parent);\n      if (isWrite) {\n        // A property write extends the set of defined properties.\n        definedProps.add(propName);\n      } else {\n        // A property read is only allowed if the property has already been defined\n        // (or if the property is one of the ones inherited from Object.prototype).\n        if (!definedProps.contains(propName) && \n            !(\"toString\".equals(propName) || \"valueOf\".equals(propName))) {\n          return false;\n        }\n      }\n      // In any case, we ignore the indirect property references for the count.\n      continue;\n    }\n    // For non-GETPROP references (the \u201cfull\u201d ones), we already checked\n    // that they are proper var declarations or assignments above.\n    if (!isVarOrAssignExprLhs(ref.getNode())) {\n      return false;\n    }\n  }\n  \n  return hasDirectAssignment;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}