{
    "generation": "/**\n * Counts the number of direct (full) references to an object.\n * Specifically we check for references of the following type:\n * <pre>\n *   x;\n *   x.fn();\n * </pre>\n */\nprivate boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = null;\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Ignore indirect references, like x.y (except x.y(), since\n    // the function referenced by y might reference 'this').\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // A call target maybe using the object as a 'this' value.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      // Bail if there's unknown property usage.\n      if (validProperties == null) {\n        // validProperties uninitialized means no object literal assignment yet,\n        // so conservatively bail out.\n        return false;\n      }\n\n      Node propertyNameNode = parent.getLastChild();\n      if (propertyNameNode != null && propertyNameNode.isString()) {\n        String propName = propertyNameNode.getString();\n        if (!validProperties.contains(propName)) {\n          return false;\n        }\n      } else {\n        // Dynamic property access, so bail\n        return false;\n      }\n\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!isVarOrAssignExprLhs(name)) {\n       return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Make sure that the value is not self-refential. IOW,\n    // disallow things like x = {b: x.a}.\n    //\n    // TODO: Only exclude unorderable self-referential\n    // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n    // but x = {a: 1, b: x.a} is.\n    //\n    // Also, ES5 getters/setters aren't handled by this pass.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        // ES5 get/set not supported.\n        return false;\n      }\n\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n\n    // Record valid property names from the first object literal we see\n    if (validProperties == null) {\n      validProperties = new HashSet<>();\n      for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.getFirstChild() != null) {\n          String key = child.getString();\n          validProperties.add(key);\n        }\n      }\n    } else {\n      // For subsequent assignments check that their keys are subset of known props\n      Set<String> newProps = new HashSet<>();\n      for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.getFirstChild() != null) {\n          newProps.add(child.getString());\n        }\n      }\n      validProperties.addAll(newProps);\n    }\n\n    ret = true;\n  }\n  return ret;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}