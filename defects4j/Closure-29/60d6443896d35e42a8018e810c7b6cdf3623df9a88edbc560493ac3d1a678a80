{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // We only inline if there's at least one object\u2010literal assignment,\n  // and every property read/write is safe and defined.\n  boolean foundObjectLitAssign = false;\n  // The set of property names we've seen in object literals or\n  // written via x.prop = ... assignments.\n  java.util.Set<String> knownProps = new java.util.HashSet<String>();\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Handle any property access or write: x.prop\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n\n      // 1) If it's an assignment to a property (x.prop = ...), record it.\n      if (gramps.isAssign() && gramps.getFirstChild() == parent) {\n        knownProps.add(parent.getLastChild().getString());\n        continue;\n      }\n\n      // 2) If it's used as a call target anywhere in the chain, bail out.\n      //    (Detect x.y(), x.y.z(), getType.toString.apply(), etc.)\n      Node cur = parent;\n      while (cur != null) {\n        Node p = cur.getParent();\n        if (p == null) {\n          break;\n        }\n        if (p.isCall() && p.getFirstChild() == cur) {\n          return false;\n        }\n        cur = p;\n      }\n\n      // 3) Property read: must come after an object-literal assignment.\n      if (!foundObjectLitAssign) {\n        return false;\n      }\n      // 4) And the property must be one we know about.\n      String propName = parent.getLastChild().getString();\n      if (!knownProps.contains(propName)) {\n        return false;\n      }\n      continue;\n    }\n\n    // Beyond GETPROP, we only allow var-decls or simple \"x = ...\" assignments.\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n    Node val = ref.getAssignedValue();\n    // var x;  (no initializer) is fine, just skip.\n    if (val == null) {\n      continue;\n    }\n    // But if there's an initializer, it must be an object literal.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // We've found an object-literal assignment.  Record its keys,\n    // and ensure no getters/setters or self-references.\n    java.util.Set<String> litProps = new java.util.HashSet<String>();\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        // ES5 get/set not supported\n        return false;\n      }\n      String prop = child.getString();\n      litProps.add(prop);\n      // Check for self\u2010referential values like x = {a: x.b}\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    knownProps.addAll(litProps);\n    foundObjectLitAssign = true;\n  }\n\n  return foundObjectLitAssign;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}