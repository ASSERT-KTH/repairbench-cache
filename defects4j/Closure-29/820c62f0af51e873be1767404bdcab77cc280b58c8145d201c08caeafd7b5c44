{
    "generation": "    /**\n     * Checks if the variable is suitable for inlining as an object literal.\n     * An object literal assignment is suitable for inlining if the variable name is\n     * only used in the following ways:\n     * <ol>\n     *  <li>In a VAR declaration (e.g., var x = { ... };)\n     *  <li>As the left side of a simple assignment (e.g., x = { ... };)\n     *  <li>As the object part of a property access (e.g., ... x.prop ...)\n     *  <li>As the object part of a property assignment (e.g., x.prop = ...)\n     * </ol>\n     * Any other use, such as a function call argument or a method call target,\n     * disqualifies the variable.\n     * Additionally, the object literal itself must not contain ES5 getters/setters\n     * or self-referential assignments.\n     *\n     * @param refs The list of references to the variable being considered.\n     * @return True if the variable appears suitable for inlining.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false; // Tracks if we found at least one inlinable assignment\n      for (Reference ref : refs) {\n        Node name = ref.getNode(); // The NAME node (e.g., 'x')\n        // A Reference must have a Node\n        Preconditions.checkNotNull(name, \"Reference node cannot be null\");\n        Node parent = ref.getParent(); // Parent of NAME\n        // A Node must have a parent (unless it's the root, which 'name' won't be)\n        Preconditions.checkNotNull(parent, \"Reference parent node cannot be null\");\n        Node gramps = ref.getGrandparent(); // Grandparent of NAME (can be null)\n\n        // Handle GETPROP references (x.prop)\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name,\n              \"Object variable node must be the first child of GETPROP\");\n          // Disallow method calls (x.prop()) due to 'this' potentially referring to the object.\n          if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n          // Allow property reads (... x.prop ...) and assignments (x.prop = ...)\n          // The main pass (tryInlineObjectLit) performs more detailed checks later,\n          // comparing accessed properties against those defined in the literal.\n          continue;\n        }\n\n        // Allow only VAR declarations or simple assignments (x = ...)\n        // as potentially defining references.\n        if (!isVarOrAssignExprLhs(name)) {\n           // Any other use (e.g., foo(x), x++, for(x in...), return x) prevents inlining\n           // because the object might escape or be modified in complex ways.\n           return false;\n        }\n\n        // We are now looking at a VAR or ASSIGN reference (e.g., var x = ..., or x = ...)\n        Node val = ref.getAssignedValue(); // Value assigned in VAR or ASSIGN\n        if (val == null) {\n          // A var with no assignment (e.g., var x;). This reference is fine.\n          continue;\n        }\n\n        // The assigned value must be an object literal for this reference to be\n        // considered a candidate definition site.\n        if (!val.isObjectLit()) {\n          // Example: x = y; or x = 5; prevents inlining.\n          return false;\n        }\n\n        // Check for disallowed features within the object literal 'val'.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n\n          // Disallow ES5 getters/setters as they are not handled by this pass.\n          if (child.isGetterDef() || child.isSetterDef()) {\n            return false;\n          }\n\n          // Check for self-referential assignments (e.g., x = {a: x.b})\n          // Get the value node associated with the property 'child'.\n          // For STRING_KEY, GETTER_DEF, SETTER_DEF, MEMBER_FUNCTION_DEF, the value is the last child.\n          Node childVal = child.getLastChild();\n\n          // If childVal is null, it might be a shorthand property {a} (desugared to {a:a})\n          // or something complex like a computed property name.\n          // TODO(b/123): Handle shorthand properties and computed keys more robustly if needed.\n          // For now, skip the self-reference check if we can't easily find the value node.\n          if (childVal == null) {\n              continue;\n          }\n\n          // Check if the calculation of 'childVal' involves a reference 't' to the\n          // object 'name' itself. Use the original check logic: see if 'childVal'\n          // is an ancestor of the parent of reference 't'.\n          for (Reference t : refs) {\n            // 't' is another reference to the same object 'name'.\n            Node refAncestor = t.getParent(); // Start search from parent of the reference 't'\n            // Walk up the AST from the reference 't's parent. Stop if we hit the object\n            // literal node 'val' itself, a statement block, or the root.\n            while (refAncestor != null && refAncestor != val && !NodeUtil.isStatementBlock(refAncestor)) {\n              // If we find that the value node 'childVal' is an ancestor of the\n              // reference 't' (i.e., refAncestor == childVal), it means the value\n              // calculation requires the object itself.\n              if (refAncestor == childVal) {\n                // Example: x = { a: x.b }\n                // 'child' is STRING_KEY 'a'. 'childVal' is GETPROP 'x.b'.\n                // 't' is the reference to 'x' inside 'x.b'.\n                // 't.getParent()' is GETPROP 'x.b'.\n                // The loop starts with refAncestor = GETPROP 'x.b'.\n                // Condition refAncestor == childVal is immediately true.\n                return false; // Self-referential assignment found.\n              }\n              refAncestor = refAncestor.getParent();\n            }\n          } // End inner loop (checking self-reference for one property)\n        } // End loop checking object literal children\n\n        // This reference 'ref' corresponds to an acceptable object literal assignment.\n        // Mark that we have found at least one ('ret = true').\n        // We must continue checking other references, as any one could disqualify the object.\n        ret = true;\n      } // End loop over all references\n\n      // Return true only if we found at least one valid object literal\n      // assignment ('ret' is true) AND encountered no disqualifying references\n      // (i.e., we never returned false).\n      return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}