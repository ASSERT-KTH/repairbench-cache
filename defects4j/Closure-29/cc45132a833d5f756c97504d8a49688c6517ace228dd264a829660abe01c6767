{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // Gather the \u201cuniverse\u201d of property names that the object variable acquires\n  // from its object\u2010literal definitions and from any later property writes.\n  Set<String> definedProps = new HashSet<>();\n  for (Reference ref : refs) {\n    // If the assignment is an object literal, add every property key.\n    Node val = ref.getAssignedValue();\n    if (val != null && val.isObjectLit()) {\n      for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n        // Assume that child.getString() yields the key name.\n        definedProps.add(child.getString());\n      }\n    }\n    // Also, if the variable is \u201cupdated\u201d via a property assignment like a.foo = \u2026,\n    // add the property name from that write.\n    Node parent = ref.getParent();\n    if (parent != null && parent.isGetProp()) {\n      Node gp = ref.getGrandparent();\n      if (gp != null && gp.isAssign() && gp.getFirstChild() == parent) {\n        Node prop = parent.getLastChild();\n        definedProps.add(prop.getString());\n      }\n    }\n  }\n\n  boolean ret = false;\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // \u2013\u2013 Case 1: the reference is used as a property access, e.g. x.foo\n    if (parent.isGetProp()) {\n      // If the getprop is used as a call target (e.g. x.foo()), then the\n      // \u201cthis\u201d value might be important \u2013 bail out.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      // Determine whether this GETPROP node is a write rather than a read.\n      boolean isWrite = parent.getParent() != null \n              && parent.getParent().isAssign() \n              && parent.getParent().getFirstChild() == parent;\n      if (!isWrite) {\n        // For a pure read, make sure that the property being read is \u201cknown.\u201d\n        // In our typical case (an object literal with properties) every legal\n        // property must already have been defined. However, for an empty object literal\n        // the inliner redeclares properties for a handful of safe native names.\n        Node propNode = parent.getLastChild();\n        String propName = propNode.getString();\n        if (!definedProps.contains(propName)) {\n          // If the union of properties so far is empty,\n          // then the only allowed reads are ones that normally appear on Object.prototype.\n          if (definedProps.isEmpty()) {\n            if (!(propName.equals(\"toString\")\n                  || propName.equals(\"valueOf\")\n                  || propName.equals(\"hasOwnProperty\"))) {\n              return false;\n            }\n          } else {\n            return false;\n          }\n        }\n      }\n      continue;\n    }\n\n    // \u2013\u2013 Case 2: the reference is the \u201cfull\u201d name, as in a var declaration\n    // or an assignment statement \u201cx = \u2026\u201d\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // a declaration with no initializer\n      continue;\n    }\n    if (!val.isObjectLit()) {\n      return false;\n    }\n    // For an object literal assignment it\u2019s important that we \u201cown\u201d every property.\n    // (There is a blind\u2010spot if a property read is not defined on the literal.)\n    // However, if the object literal is empty then we\u2019re relying on the prototype.\n    // To be safe, only inline an empty literal when it appears as an initializer\n    // in a var declaration (and not as a separate assignment).\n    if (val.getFirstChild() == null) {\n      // Check that the empty literal is directly attached to a VAR declaration.\n      // (A separate assignment would have a parent that isn\u2019t a VAR node.)\n      if (!(parent.getParent() != null && parent.getParent().isVar())) {\n        return false;\n      }\n    }\n    // Finally, for each property in an object literal definition, check for ES5 getters/setters\n    // (which this pass does not support) or any self\u2010referential use of the literal.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        return false;\n      }\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // A self-referential assignment; e.g. x = {a: x.a}\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    ret = true;\n  }\n  return ret;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}