{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // When checking property accesses we want to allow \u201cinherited\u201d\n  // properties that come from Object.prototype.\n  // (This is mainly to let things like getType.toString inline in ADVANCED mode.)\n  Set<String> whitelist = new HashSet<>();\n  whitelist.add(\"toString\");\n  whitelist.add(\"valueOf\");\n  whitelist.add(\"hasOwnProperty\");\n  whitelist.add(\"isPrototypeOf\");\n  whitelist.add(\"propertyIsEnumerable\");\n  whitelist.add(\"toLocaleString\");\n\n  // inlineProps will accumulate the \u201cown\u201d properties that the object ends up having.\n  Set<String> inlineProps = new HashSet<>();\n  // This flag indicates whether we\u2019ve seen at least one direct assignment\n  // (x = {\u2026}) to the variable. Without that the property accesses (x.foo) are not safe.\n  boolean seenAssignment = false;\n\n  // We assume refs is ordered by the source occurrence.  (For loop ordering matters.)\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n\n    if (parent.isGetProp()) {\n      // For property accesses like: x.foo or assignments like: x.foo = \u2026\n      // The first child of the getprop must be our variable.\n      Preconditions.checkState(parent.getFirstChild() == name);\n\n      Node gramps = ref.getGrandparent();\n      // Bail out if this property is being used as a call target.\n      // (E.g. prevent inlining x.fn() because the function might use x as \u201cthis\u201d.)\n      if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      if (ref.getAssignedValue() != null) {\n        // This is a property assignment like: x.foo = \u2026 \n        // Record that the property \u201cfoo\u201d is being (re)assigned.\n        String propName = parent.getLastChild().getString();\n        inlineProps.add(propName);\n      } else {\n        // This is a plain property read: x.foo.\n        // If we haven\u2019t seen any direct assignment to the object at all,\n        // then we aren\u2019t allowed to inline.\n        if (!seenAssignment) {\n          return false;\n        }\n        String propName = parent.getLastChild().getString();\n        // It is safe only when the property has been defined either\n        // (1) as an \u201cown\u201d property in one of the object literal assignments,\n        // (2) via a property assignment, or\n        // (3) it is one of the well\u2010known built\u2010ins from Object.prototype.\n        if (!inlineProps.contains(propName) && !whitelist.contains(propName)) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    // Only rewrite variables if they appear in a declaration\n    // or as the left\u2010hand side of a simple assignment.\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // e.g. a var declaration without an initialization.\n      continue;\n    }\n    // We only inline assignments whose value is an object literal.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Check that the object literal is \u201cclean\u201d: no getters/setters\n    // and no self-references in the property values.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        return false;\n      }\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            // There is a self-referential assignment.\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n      // Record the property name defined in the literal.\n      inlineProps.add(child.getString());\n    }\n    seenAssignment = true;\n  }\n  return seenAssignment;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}