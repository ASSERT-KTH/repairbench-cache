{
    "generation": "    /**\n     * Checks if an object literal is valid for inlining.\n     * An object literal is valid for inlining if all references to it\n     * are either:\n     * 1) A VAR declaration or simple assignment LHS.\n     * 2) The object literal is assigned immediately in the VAR declaration\n     *    or assignment.\n     * 3) There are no self-referential assignments like x = {a: x.b}.\n     * 4) The object literal has no getter/setter properties.\n     * 5) Property accesses are safe (not calling methods, not accessing\n     *    potentially undefined properties inherited from prototype).\n     * 6) Assignments to properties (like x.prop = 1) are allowed.\n     *\n     * @param refs The references to check.\n     * @return Whether the object literal definition is valid for inlining.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean hasObjectLiteralAssignment = false;\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Handle GETPROP x.prop\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name,\n              \"Expected parent's first child to be %s; found %s\", name, parent.getFirstChild());\n          // Disallow x.prop() because it might rely on 'this'.\n          if (gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Allow x.prop = ... assignments. These are handled by the main pass.\n          // The reference 'x' itself in this context is safe.\n          if (gramps.isAssign() && gramps.getFirstChild() == parent) {\n            continue; // Safe reference, check next.\n          }\n\n          // Disallow any other property access like y = x.prop, f(x.prop), x.prop;\n          // This avoids issues with potential accesses to prototype properties (Issue 724)\n          // or properties not defined in the literal (testObject12).\n          return false;\n        }\n\n        // Only allow references that are assignments or declarations\n        if (!NodeUtil.isVarOrAssignExprLhs(name)) {\n          // Disallows f(x), return x, if(x), etc.\n          return false;\n        }\n\n        // At this point, the reference must be a VAR or ASSIGN LHS.\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment (e.g., \"var x;\"). Allowed.\n          continue;\n        }\n\n        // If it's an assignment, it must be an object literal.\n        if (!val.isObjectLit()) {\n          // e.g., x = 1, x = foo()\n          return false;\n        }\n\n        // Check object literal properties for issues.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          // Disallow ES5 getters/setters.\n          if (child.isGetterDef() || child.isSetterDef()) {\n            return false;\n          }\n\n          // Disallow self-referential assignments (e.g., x = {a: x.b})\n          // Use getLastChild b/c structure is STRING_KEY/GET/SET -> name/key, value/function.\n          Node childVal = child.getLastChild();\n\n          // Check for self-referential assignments within the value: e.g., x = {a: x.b}\n          // Check if childVal is null or missing, indicating an issue or unsupported feature.\n          if (childVal == null) {\n              // Cannot analyze this case (e.g., object spread, shorthand property). Be conservative.\n              return false;\n          }\n\n          for (Reference t : refs) {\n             Node tNode = t.getNode(); // The NAME node (e.g., 'x' in x.b)\n             // Check if the reference 't' occurs anywhere within the value 'childVal'\n             if (childVal.isAncestor(tNode)) {\n                 // Check if the reference tNode is a direct child of childVal or deeper.\n                 // We need to ensure that tNode refers to the object being defined (name)\n                 // and is inside the value part of the object literal.\n                 // Example: x = { a: x.b } -> childVal is GETPROP(x.b), tNode is NAME(x)\n                 // childVal.isAncestor(tNode) is true. This is self-referential.\n                 return false; // Self-reference detected.\n             }\n          }\n        } // End loop over object properties 'child'\n\n        // If we passed all checks for this assignment, mark it.\n        hasObjectLiteralAssignment = true;\n      } // End loop over references 'ref'\n\n      // Inline only if we found at least one valid object literal assignment\n      // and no reference violated the rules.\n      return hasObjectLiteralAssignment;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}