{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     *\n     * Returns true if x can be inlined (object literal), false otherwise.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> definedProps = null;\n\n      // First, collect the set of all properties defined in any object literal assignment.\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n\n        // Ignore GetProp except for x.y()\n        if (parent.isGetProp()) {\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n          continue;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (val.isObjectLit()) {\n          if (definedProps == null) {\n            definedProps = new LinkedHashSet<>();\n          }\n          for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n            if (!child.isComputedProp() && child.getFirstChild() != null) { // avoid destructuring etc\n              definedProps.add(child.getString());\n            }\n          }\n          ret = true;\n        }\n      }\n\n      // Now check all refs to x.prop (GetProp). All must be to defined property.\n      if (ret && definedProps != null) {\n        for (Reference ref : refs) {\n          Node name = ref.getNode();\n          Node parent = ref.getParent();\n          Node gramps = ref.getGrandparent();\n\n          if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n            // A call target maybe using the object as a 'this' value.\n            if (gramps.isCall() && gramps.getFirstChild() == parent) {\n              return false;\n            }\n            // If property isn't in definedProps, bail out.\n            String prop = parent.getLastChild().getString();\n            if (!definedProps.contains(prop)) {\n              return false;\n            }\n          }\n\n          // Only rewrite VAR declarations or simple assignment statements\n          if (!parent.isGetProp() && !isVarOrAssignExprLhs(name)) {\n            return false;\n          }\n\n          Node val = ref.getAssignedValue();\n          if (val != null && val.isObjectLit()) {\n            for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n              // ES5 Getter/Setter is not handled\n              if (child.isGetterDef() || child.isSetterDef()) {\n                return false;\n              }\n              Node childVal = child.getFirstChild();\n              // Check if childVal is the parent of any of the passed in\n              // references, as that is how self-referential assignments will happen.\n              for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n                  if (refNode == childVal) {\n                    // There's a self-referential assignment\n                    return false;\n                  }\n                  refNode = refNode.getParent();\n                }\n              }\n            }\n          }\n        }\n      }\n      return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}