{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.rhino.Node;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n    /**\n     * Checks if an object literal assignment can be inlined.\n     * An object literal assignment can be inlined if:\n     * 1. There's exactly one object literal assignment to the variable.\n     * 2. The assigned literal does not contain ES5 getters/setters, non-string keys, or self-references.\n     * 3. All other references to the variable are either:\n     *    - Simple variable declarations (var x;)\n     *    - Property assignments (e.g., x.prop = val;)\n     *    - Property reads of keys defined in the object literal (e.g., f(x.prop);)\n     * 4. The variable is not used in other ways (e.g., method calls x.method(), direct use f(x),\n     *    reassigned to non-literal values, reads of undefined/inherited properties).\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      Node definingObjectLit = null;\n      Reference definingRef = null;\n      Node variableNode = null; // Store the node for the variable name\n\n      // First pass: Find the unique object literal assignment and validate it.\n      for (Reference ref : refs) {\n         Node name = ref.getNode();\n         // Initialize variableNode with the first valid NAME node encountered.\n         if (variableNode == null && name != null && name.isName()) {\n             variableNode = name;\n         }\n         // Basic check: Ensure all references point to the same variable name node.\n         // Skip refs with null names (shouldn't happen for variable references).\n         if (name == null || variableNode == null || variableNode != name) {\n             // This might happen for non-variable references if the list is mixed,\n             // or indicate an issue with the reference collection. Be lenient for now.\n             // Preconditions.checkState(variableNode == name, \"References point to different variables: %s != %s\", variableNode, name);\n             continue; // Skip potentially problematic references\n         }\n\n\n         if (isVarOrAssignExprLhs(name)) {\n             Node val = ref.getAssignedValue();\n             if (val != null && val.isObjectLit()) {\n                 // Check for get/set first (simple check)\n                 if (hasGetterSetter(val)) {\n                    return false; // Literal has unsupported features\n                 }\n                 // Check for self-reference (more complex)\n                 // Pass variableNode itself for potentially more accurate future checks if needed.\n                 if (isSelfReferential(val, name, refs)) {\n                    return false; // Literal has self-references\n                 }\n\n                 // Found a valid object literal assignment.\n                 if (definingObjectLit == null) {\n                    definingObjectLit = val;\n                    definingRef = ref;\n                    // Check keys here for early exit if non-string keys exist\n                    for (Node keyNode = definingObjectLit.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n                         if (!keyNode.isStringKey()) {\n                            // Disallow non-string keys (computed, shorthand methods etc.)\n                            // Get/Set already handled by hasGetterSetter.\n                            return false;\n                         }\n                    }\n                 } else {\n                    // Found more than one object literal assignment. Disallow for simplicity.\n                    return false;\n                 }\n             } else if (val != null) {\n                 // Assigned something other than object literal (e.g., x = 1, x = foo()). Disallow.\n                 return false;\n             }\n             // val == null (var x;) is OK.\n         }\n      }\n\n      // If no defining object literal assignment found, cannot inline.\n      if (definingObjectLit == null) {\n          return false;\n      }\n\n      // Collect keys defined in the literal (already validated they are string keys).\n      Set<String> definedKeys = new HashSet<>();\n      for (Node keyNode = definingObjectLit.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n          definedKeys.add(keyNode.getString());\n      }\n\n      // Second pass: Validate ALL references according to the rules.\n      for (Reference ref : refs) {\n          // Skip the reference that defined the object literal itself.\n          if (ref == definingRef) {\n              continue;\n          }\n          // Skip refs with null names encountered in pass 1.\n          if (ref.getNode() == null || ref.getNode() != variableNode) {\n              continue;\n          }\n\n          Node name = ref.getNode();\n          Node parent = ref.getParent();\n          Node gramps = ref.getGrandparent();\n\n          if (parent.isGetProp()) {\n              // Case: x.something\n              Node propNode = parent.getLastChild();\n              // We only handle string properties. Computed properties etc. are disallowed.\n              if (!propNode.isString()) {\n                 return false;\n              }\n              String propName = propNode.getString();\n\n              // Case: x.method() - Disallow\n              if (gramps.isCall() && gramps.getFirstChild() == parent) {\n                  return false;\n              }\n\n              // Case: x.prop = value - Allow\n              if (gramps.isAssign() && gramps.getFirstChild() == parent) {\n                  continue;\n              }\n\n              // Case: x.prop read (e.g., f(x.prop) or x.prop.deeper)\n              // Allow ONLY if the key was defined in the original literal.\n              if (definedKeys.contains(propName)) {\n                  // Reading a known property defined in the literal.\n                  continue;\n              } else {\n                  // Reading unknown/inherited property or property added later.\n                  // Disallow to avoid prototype issues and complexity.\n                  return false;\n              }\n          } else if (isVarOrAssignExprLhs(name)) {\n              // Case: Another assignment or var decl for the same variable 'name'\n              Node val = ref.getAssignedValue();\n              if (val == null) {\n                  // Another 'var x;' is OK (might occur in loops etc.)\n                  continue;\n              } else {\n                  // Re-assignment x = ...; Pass 1 should have caught this if non-literal or >1 literal.\n                  // This implies a re-assignment after the initial defining literal,\n                  // which we disallowed in pass 1. Return false as a safeguard.\n                  return false;\n              }\n          } else {\n              // Case: Direct use like f(x), x++, return x - DISALLOW\n              return false;\n          }\n      }\n\n      // If all references passed the checks.\n      return true;\n    }\n\n    /** Helper to check for ES5 getters/setters */\n    private boolean hasGetterSetter(Node objectLit) {\n        for (Node keyNode = objectLit.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n            if (keyNode.isGetterDef() || keyNode.isSetterDef()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper to check for self-referential assignments like x = {a: x.b}.\n     * Uses the original logic structure which checks if the property value node\n     * is an ancestor of a reference's parent node within the object literal context.\n     */\n    private boolean isSelfReferential(Node objectLit, Node variableName, List<Reference> refs) {\n        for (Node keyNode = objectLit.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n            // String key, get/set def. Get the value node.\n            Node childVal = keyNode.getLastChild(); // Value is last child (e.g., for STRING_KEY)\n            if (childVal == null) continue;\n\n            // Check if any reference 't' to 'variableName' occurs within 'childVal'.\n            // The original logic checks ancestry: Is childVal an ancestor of t.getParent()?\n            for (Reference t : refs) {\n                // Ensure the reference node matches the variable we're checking.\n                if (t.getNode() != variableName) continue;\n\n                Node refParent = t.getParent();\n                // Walk up from the reference's parent node.\n                Node ancestor = refParent;\n                while (ancestor != null && ancestor != objectLit && !NodeUtil.isStatementBlock(ancestor)) {\n                     // If we find the property's value node during the walk up, it's self-referential.\n                     // e.g., x = { a: x.b } -> ref 'x' in x.b; parent is GETPROP(x.b); childVal is GETPROP(x.b). Match.\n                    if (ancestor == childVal) {\n                        return true; // Found self-reference\n                    }\n                    ancestor = ancestor.getParent();\n                }\n            }\n        }\n        return false;\n    }\n\n    /** Returns true if the node n is the LHS of a var declaration or simple assignment. */\n    private static boolean isVarOrAssignExprLhs(Node n) {\n      // Check if n is a NAME node, which is expected for variables\n      if (n == null || !n.isName()) {\n        return false;\n      }\n      Node parent = n.getParent();\n      if (parent == null) {\n        return false;\n      }\n      // var n; or var n = ...; (NAME is child of VAR)\n      if (parent.isVar()) {\n        return true;\n      }\n      // n = ...; (NAME is first child of ASSIGN)\n      if (parent.isAssign() && parent.getFirstChild() == n) {\n        return true;\n      }\n      return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}