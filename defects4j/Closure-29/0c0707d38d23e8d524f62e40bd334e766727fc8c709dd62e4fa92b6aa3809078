{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // First, compute the union of property names that are \u201cdefined\u201d on this object.\n  // (Either via an object literal assignment or via a property\u2010assignment.)\n  Set<String> definedProps = new HashSet<>();\n  boolean foundLiteral = false;\n  for (Reference ref : refs) {\n    Node val = ref.getAssignedValue();\n    if (val != null && val.isObjectLit()) {\n      foundLiteral = true;\n      for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n        // We do not support ES5 getters/setters.\n        if (child.isGetterDef() || child.isSetterDef()) {\n          return false;\n        }\n        if (child.hasString()) {\n          definedProps.add(child.getString());\n        }\n      }\n    }\n    // Also, if a property is later assigned through a GETPROP (e.g. x.c = c),\n    // add that property name to the set.\n    Node parent = ref.getParent();\n    if (parent.isGetProp()) {\n      Node gp = parent.getParent();\n      boolean isWrite = gp != null && gp.isAssign() && gp.getFirstChild() == parent;\n      if (isWrite) {\n        definedProps.add(parent.getLastChild().getString());\n      }\n    }\n  }\n  \n  // We inline only if there is at least one object-literal assignment.\n  if (!foundLiteral) {\n    return false;\n  }\n  \n  // For GETPROP read accesses, allow only properties that are either defined on the object\n  // or are built in (from Object.prototype). (This is our safeguard against reading an\n  // inherited property that might be non-void.)\n  Set<String> builtinProps = new HashSet<>(Arrays.asList(\n      \"toString\", \"valueOf\", \"hasOwnProperty\", \"isPrototypeOf\", \n      \"propertyIsEnumerable\", \"toLocaleString\"));\n  \n  boolean ret = false;\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n  \n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // If we see a call of the form x.y(), then the object might be used as\n      // a \u201cthis\u201d value.  Bail out.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n  \n      // Determine if this GETPROP is being read or written.\n      Node gp = parent.getParent();\n      boolean isWrite = gp != null && gp.isAssign() && gp.getFirstChild() == parent;\n      if (!isWrite) {  // A read access\n        String propName = parent.getLastChild().getString();\n        // If the property isn\u2019t defined in our union\u2014and isn\u2019t one of the allowed\n        // builtins (like \"toString\")\u2014then we must bail.\n        if (!definedProps.contains(propName) && !builtinProps.contains(propName)) {\n          return false;\n        }\n      }\n      continue;\n    }\n  \n    // For non-GETPROP references, we only allow VAR declarations or simple\n    // assignments (e.g. \u201cx = {\u2026}\u201d).\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n  \n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      continue;\n    }\n  \n    // We only inline object literal assignments.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n  \n    // Finally, ensure that the object literal isn\u2019t self-referential.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        return false;\n      }\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n    ret = true;\n  }\n  return ret;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}