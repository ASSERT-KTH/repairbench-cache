{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      Reference objectLiteralRef = null;\n\n      // First pass: Identify the primary object literal assignment and check for disqualifying assignments.\n      // An object is inlinable only if it has exactly one assignment as an object literal,\n      // and no other assignments that are not object literals.\n      for (Reference ref : refs) {\n        Node name = ref.getNode(); // The NAME node representing the object variable (e.g., 'x')\n\n        // Check if this reference is an assignment to the object variable (e.g., `var x = ...` or `x = ...`).\n        if (isVarOrAssignExprLhs(name)) {\n          Node val = ref.getAssignedValue(); // The value assigned to the variable\n\n          if (val != null) { // It's an assignment with a value (e.g., `x = {a:1}` or `x = 5`)\n            if (val.isObjectLit()) {\n              if (objectLiteralRef != null) {\n                // Found more than one object literal assignment. This object is not inlinable.\n                return false;\n              }\n              objectLiteralRef = ref; // Store the first found object literal assignment\n            } else {\n              // Found an assignment to something that is not an object literal (e.g., `x = 5`).\n              // This immediately disqualifies the object for inlining.\n              return false;\n            }\n          } else { // It's a VAR declaration without an assignment (e.g., `var x;`)\n            // This is allowed, as long as there is a subsequent object literal assignment.\n            // No action needed here, as we only track the object literal assignment.\n          }\n        }\n        // References that are not assignments (e.g., usages like `x.prop`, `f(x)`)\n        // are validated in the second pass.\n      }\n\n      // If no single object literal assignment was found, this object is not inlinable.\n      if (objectLiteralRef == null) {\n        return false;\n      }\n\n      // Now, validate the properties of the found object literal itself,\n      // especially for ES5 getters/setters and self-referential assignments.\n      Node objLit = objectLiteralRef.getAssignedValue();\n      // At this point, objLit is guaranteed to be a non-null object literal due to previous checks.\n\n      for (Node child = objLit.getFirstChild(); child != null;\n           child = child.getNext()) {\n        if (child.isGetterDef() || child.isSetterDef()) {\n          // ES5 get/set properties are not supported by this inlining pass.\n          return false;\n        }\n\n        // Check for self-referential assignments within the object literal.\n        // Example: `x = {b: x.a}` - the value of property 'b' refers back to 'x'.\n        Node childVal = child.getFirstChild(); // The value assigned to the property (e.g., `x.a` for `b: x.a`)\n        if (childVal != null) { // Only check if there's an actual value (not for methods or empty properties)\n          for (Reference otherRef : refs) {\n            // `otherRef.getNode()` is the NAME node 'x'.\n            // `otherRef.getParent()` is the direct parent node containing the reference to 'x',\n            // e.g., for `x` in `x.a`, `getParent()` is the GETPROP node representing `x.a`.\n            Node currentRefParent = otherRef.getParent();\n            // Traverse up the AST from the reference's parent until a statement block or null is reached.\n            // If `childVal` (the property's value) is found in this ancestry, it's a self-reference.\n            while (currentRefParent != null && !NodeUtil.isStatementBlock(currentRefParent)) {\n              if (currentRefParent == childVal) {\n                // There's a self-referential assignment (e.g., `x = {b: x.a}` where `x.a` is `childVal`).\n                return false;\n              }\n              currentRefParent = currentRefParent.getParent();\n            }\n          }\n        }\n      }\n\n      // Second pass: Validate all other references (usages) of the object variable.\n      for (Reference ref : refs) {\n        // The object literal assignment itself has been validated and is inherently fine.\n        if (ref == objectLiteralRef) {\n          continue;\n        }\n\n        Node name = ref.getNode(); // The NAME node of the object variable (e.g., `x`)\n        Node parent = ref.getParent(); // The parent of `name`\n        Node gramps = ref.getGrandparent(); // The grandparent of `name`\n\n        // Handle property access references (e.g., `x.prop` or `x['prop']`).\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name); // Ensure `name` is the object part of `x.y`\n\n          // Special case: a call target where the object might be used as `this` (e.g., `x.method()`).\n          // `gramps` would be a CALL node, and `parent` (the GETPROP `x.method`) would be its first child.\n          if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false; // Disqualify if it's a method call target.\n          }\n\n          // This is a simple property access (e.g., `x.y`).\n          // This pass generally requires that accessed properties exist within the object literal.\n          // This addresses the \"blind spot\" mentioned in the original comment and cases like `a.y2` in tests.\n          String propName = parent.getLastChild().getString(); // Get the string name of the property (e.g., \"y\")\n          if (objLit.getPropertiesForName(propName).isEmpty()) {\n            // If the property is accessed but not defined directly on the object literal,\n            // it's not inlinable by this pass.\n            return false;\n          }\n          // If the property exists, this reference is valid for inlining.\n          // Continue to the next reference.\n        } else if (isVarOrAssignExprLhs(name)) {\n          // This branch handles cases where 'name' is the LHS of a VAR or ASSIGN node.\n          // We've already filtered out problematic assignments (multiple object literals, non-object literals)\n          // in the first pass. This case should only apply to the initial `var x;` declaration if it's not\n          // the `objectLiteralRef` itself (e.g., if `objectLiteralRef` was `x = {a:1}` and `var x;` also exists).\n          // These are harmless and don't disqualify.\n        } else {\n          // This covers any other usage of the object variable `name` that is not:\n          // 1. The object literal assignment (`objectLiteralRef`).\n          // 2. A property access (`x.prop`).\n          // 3. A variable declaration or direct assignment to the name (`isVarOrAssignExprLhs(name)`).\n          // Examples: `f(x)`, `x++`, `return x;`, `x;` (as a standalone statement).\n          // These types of references to the object variable itself typically prevent object literal inlining.\n          return false;\n        }\n      }\n\n      // If all checks pass, the object is considered inlinable by this pass.\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}