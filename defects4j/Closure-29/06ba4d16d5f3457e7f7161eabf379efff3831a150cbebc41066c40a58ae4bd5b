{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.rhino.Node;\n\nimport java.util.List;\n\n// Helper methods like isVarOrAssignExprLhs and isBuiltInObjectProperty are assumed\n// to be defined elsewhere in the surrounding class or context.\n// Example definition for isBuiltInObjectProperty:\n/*\n    private static boolean isBuiltInObjectProperty(String name) {\n      // List from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n      return name.equals(\"constructor\")\n          || name.equals(\"hasOwnProperty\")\n          || name.equals(\"isPrototypeOf\")\n          || name.equals(\"propertyIsEnumerable\")\n          || name.equals(\"toLocaleString\")\n          || name.equals(\"toString\")\n          || name.equals(\"valueOf\");\n    }\n*/\n\n\n    /**\n     * Checks if the references to a variable include anything that would prevent\n     * an object literal value assigned to it from being inlined.\n     *\n     * <p>Specifically, we check for references of the following type that would\n     * prevent inlining:\n     * <pre>\n     *   x.someNonDeclaredProperty; // Potential prototype access (checked via isBuiltInObjectProperty)\n     *   x.method(); // Call using x as 'this'\n     *   foo(x); // Use other than direct assignment or property access\n     *   x = y; // Reassignment to non-object literal\n     *   var x = { get y() { ... } }; // Getters/setters\n     *   var x = { y: x.z }; // Self-referential assignment\n     * </pre>\n     *\n     * <p>This function assumes that the safety of accessing declared properties\n     * (e.g., `x.prop` where `prop` was defined in the object literal `{prop: 1}`)\n     * will be verified by the caller, which knows the specific literal being considered.\n     * It allows such accesses by using `continue`.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean foundGoodAssignment = false; // Tracks if we found a valid object lit assignment\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Check for property accesses (parent is GETPROP)\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name,\n              \"Parent of name node %s should be GETPROP\", name);\n\n          // Check for method calls (e.g., x.y())\n          if (gramps != null && gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            // A call target might be using the object as a 'this' value. Disallow inlining.\n            return false;\n          }\n\n          // Access to a property (e.g., x.y).\n          // Check if the property name suggests it might be an access to a\n          // built-in Object prototype property (like x.toString). This prevents issues\n          // like Issue 724 where prototype properties are accessed.\n          String propName = parent.getLastChild().getString();\n          // Assumes isBuiltInObjectProperty is defined in the class or accessible in scope.\n          if (isBuiltInObjectProperty(propName)) {\n             // Accessing a potentially built-in prototype property. Disallow inlining.\n             return false;\n          }\n\n          // Otherwise, assume it's a user-defined property access (like x.a).\n          // The safety of this (i.e., whether 'a' is defined in the literal)\n          // should be checked by the caller (checkInlineability). We 'continue'\n          // here to allow this reference and proceed to check others.\n          continue;\n        } // End if (parent.isGetProp())\n\n        // If the reference is not a property access base (GETPROP), check if it's a\n        // valid assignment LHS (VAR or ASSIGN).\n        // Assumes isVarOrAssignExprLhs is defined in the class or accessible in scope.\n        if (!isVarOrAssignExprLhs(name)) {\n           // Used in some other complex way (e.g., as function argument, operand). Disallow inlining.\n           return false;\n        }\n\n        // It's the LHS of a VAR or ASSIGN statement.\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var declaration with no assignment (e.g., \"var x;\"). This is safe, continue checking refs.\n          continue;\n        }\n\n        // If there is an assigned value, check if it's an object literal.\n        if (!val.isObjectLit()) {\n          // Assigned something other than an object literal (e.g., x = 1, x = foo()).\n          // This specific reference prevents inlining the object.\n          return false;\n        }\n\n        // It's an assignment of an object literal. Check for problematic constructs\n        // within the literal itself (getters, setters, self-references).\n        for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n          if (child.isGetterDef() || child.isSetterDef()) {\n            // ES5 get/set not supported by this optimization.\n            return false;\n          }\n\n          // Check for self-referential properties: e.g. x = {a: x.b}\n          // A property value (child.getLastChild()) might contain a reference\n          // back to the variable 'x' itself.\n          Node childVal = child.getLastChild(); // Property value node (e.g., 'x.b' node)\n          if (childVal == null) {\n              // Skip check for non-key-value pairs or potential invalid AST.\n              continue;\n          }\n          for (Reference t : refs) {\n            // Check if any reference 't' to the variable 'x' occurs within the value 'childVal'.\n            // We check if 'childVal' is an ancestor of the reference node 't.getParent()'.\n            Node refNode = t.getParent();\n            while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n               if (refNode == childVal) {\n                 // Found self-reference (e.g., x = {a: x.b} or x = {a: fn(){ return x; }})\n                 return false;\n               }\n               // Move up the AST\n               refNode = refNode.getParent();\n            }\n          } // End inner loop (checking self-reference for one property)\n        } // End loop through object literal properties\n\n        // If we get here, this specific reference points to a safe object literal assignment.\n        foundGoodAssignment = true;\n      } // End outer loop (iterating through all references)\n\n      // Return true if we found at least one good object literal assignment and\n      // encountered no disqualifying references (like method calls, prototype access,\n      // complex usage, bad literals).\n      return foundGoodAssignment;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}