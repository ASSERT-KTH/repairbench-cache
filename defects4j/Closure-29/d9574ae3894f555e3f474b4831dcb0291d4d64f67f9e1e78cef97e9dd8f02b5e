{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // The idea is to \u201clock\u2010in\u201d a single object literal initialization and\n  // then check that every other use of the variable is \u201ccomponentized\u201d \u2013 that is,\n  // it only accesses or updates properties. In addition, when the object literal\n  // is not \u201cshaped\u201d (i.e. it\u2019s empty) we allow new properties to be \u201cpicked up\u201d\n  // on GETPROP reads. Otherwise, a GETPROP read must request a property that\n  // is already in the literal (or later assigned to).\n  Node candidateLiteral = null;\n  int numLiteralAssignments = 0;\n  // The set of property names that we suppose the inlined object \u201cowns.\u201d\n  Set<String> props = new HashSet<>();\n\n  // First, look for a full (non-getprop) assignment of an object literal.\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    if (!parent.isGetProp() && isVarOrAssignExprLhs(name)) {\n      Node val = ref.getAssignedValue();\n      if (val != null) {\n        // We only allow assignments to an object literal.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n        candidateLiteral = val;\n        numLiteralAssignments++;\n        // Record the keys present in the literal.\n        for (Node child = candidateLiteral.getFirstChild(); child != null; child = child.getNext()) {\n          // ES5 getters/setters aren\u2019t supported.\n          if (child.isGetterDef() || child.isSetterDef()) {\n            return false;\n          }\n          // Ideally the property key is a string.\n          if (!child.hasString()) {\n            return false;\n          }\n          props.add(child.getString());\n          \n          // Check for any self-referential assignment:\n          Node childVal = child.getFirstChild();\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            // Walk upward until we hit a statement block.\n            while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Must have exactly one object literal assignment to inline.\n  if (numLiteralAssignments != 1 || candidateLiteral == null) {\n    return false;\n  }\n  \n  // Now go through every reference.\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    \n    // If the reference is used as a property access (e.g. x.someProp)\n    if (parent.isGetProp()) {\n      // Make sure that the GETPROP node is well\u2010formed.\n      Preconditions.checkState(parent.getFirstChild() == name);\n      // If this GETPROP is being used as the target of a call (e.g. x.fn()),\n      // then we cannot inline it.\n      if (gramps != null && gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      \n      // Grab the property name.\n      Node propNameNode = parent.getLastChild();\n      if (!propNameNode.isString()) {\n        return false;\n      }\n      String propName = propNameNode.getString();\n\n      // Determine whether this GETPROP is part of an assignment.\n      boolean isPropAssignment = (gramps != null && gramps.isAssign() && gramps.getFirstChild() == parent);\n      \n      if (isPropAssignment) {\n        // For a property assignment like \"x.foo = ...\", add/update the property.\n        props.add(propName);\n      } else {\n        // For a property \u201cread\u201d access:\n        // \u2022 If the literal was originally empty, then we \u201cpick up\u201d the property.\n        // \u2022 Otherwise the property must already appear.\n        if (candidateLiteral.getFirstChild() == null) {\n          props.add(propName);\n        } else if (!props.contains(propName)) {\n          return false;\n        }\n      }\n    } else {\n      // Otherwise the reference must be to a VAR declaration or simple assignment.\n      if (!isVarOrAssignExprLhs(name)) {\n         return false;\n      }\n      Node val = ref.getAssignedValue();\n      // If there is an assignment, it must be an object literal.\n      if (val != null && !val.isObjectLit()) {\n         return false;\n      }\n    }\n  }\n  \n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}