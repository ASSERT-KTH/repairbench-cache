{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> definedProps = null;\n\n      // Find the primary object literal assignment\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n\n        // Only consider VAR declarations or simple assignment statements\n        if (isVarOrAssignExprLhs(name)) {\n          Node val = ref.getAssignedValue();\n          if (val != null && val.isObjectLit()) {\n            // Collect all defined properties of the object literal\n            definedProps = new HashSet<>();\n            for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n              if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n              }\n              String propName = child.getString();\n              definedProps.add(propName);\n              Node childVal = child.getFirstChild();\n              // Check for simple self-reference. This is not a perfect check.\n              for (Reference t : refs) {\n                Node refNode = t.getParent();\n                while (refNode != null && !NodeUtil.isStatementBlock(refNode)) {\n                  if (refNode == childVal) {\n                    return false;\n                  }\n                  refNode = refNode.getParent();\n                }\n              }\n            }\n            ret = true;\n            break; // Only consider the first object literal assignment\n          }\n        }\n      }\n\n      if (definedProps == null) {\n        // No object literal assignment found\n        return false;\n      }\n\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore indirect references like x.y (except x.y() as call target)\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n\n          // A call target maybe using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Only allow GETPROP access if the property is defined in the object literal\n          Node propNode = parent.getLastChild();\n          if (propNode.isString() || propNode.isNumber() || propNode.isStringKey()) {\n            String prop = propNode.getString();\n            if (!definedProps.contains(prop)) {\n              return false;\n            }\n          } else {\n            // In case propNode is not a string, be conservative\n            return false;\n          }\n          continue;\n        }\n\n        // Only allow simple VAR or assignment to object literal\n        if (!isVarOrAssignExprLhs(name)) {\n          return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // Must assign to an object literal\n        if (!val.isObjectLit()) {\n          return false;\n        }\n      }\n      return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}