{
    "generation": "    /**\n     * Checks if the references associated with a variable are suitable\n     * for object literal inlining.\n     *\n     * This function verifies that the variable is primarily assigned object\n     * literals and that its uses are restricted in ways that make inlining safe.\n     * Specifically, it disallows:\n     * - References where the object is called as a function (e.g., x.prop()).\n     * - References where the object itself is passed around (e.g., f(x)).\n     * - Assignments of non-object-literal values (e.g., x = 123).\n     * - Object literals containing getters, setters, or self-references.\n     * - References involving property access (e.g., x.prop) due to potential\n     *   issues with inherited properties (like Object.prototype.toString).\n     *\n     * @param refs The list of references to the variable.\n     * @return True if the variable's uses are safe for inlining, false otherwise.\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false; // Tracks if we found at least one valid OBJECTLIT assignment\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Check for property access/calls (e.g., x.prop or x.prop())\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name,\n              \"Expected name node to be the first child of GETPROP\");\n\n          // Disallow method calls (e.g., x.prop()) because the 'this' value matters.\n          if (gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot concerning properties inherited from the prototype chain\n          // (e.g., Object.prototype.toString). Accessing such properties would\n          // yield unexpected results if the object literal were inlined.\n          // To prevent this, we conservatively disallow *any* property access\n          // that isn't a method call. While the main pass might handle properties\n          // defined in the literal or assigned later, this function enforces\n          // the safety rule regarding potential prototype accesses by bailing out.\n          // The original code used 'continue', allowing these potentially unsafe\n          // accesses to pass this check, leading to incorrect inlining attempts.\n          return false; // Disallow property reads/assignments like x.prop\n        }\n\n        // Check for uses other than VAR declaration or LHS of assignment.\n        // Allowed: var x; var x = {...}; x = {...};\n        // Disallowed: f(x); x++; return x; etc.\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        // At this point, ref is either 'var x;' or 'var x = ...' or 'x = ...'\n\n        Node assignedValue = ref.getAssignedValue();\n        if (assignedValue == null) {\n          // No assigned value (e.g., 'var x;'), this is safe.\n          continue;\n        }\n\n        // Assigned value must be an object literal.\n        if (!assignedValue.isObjectLit()) {\n          return false;\n        }\n\n        // Check the object literal itself for disallowed features.\n        for (Node keyNode = assignedValue.getFirstChild(); keyNode != null;\n             keyNode = keyNode.getNext()) {\n\n          // Disallow ES5 getters/setters.\n          if (keyNode.isGetterDef() || keyNode.isSetterDef()) {\n            return false;\n          }\n\n          // Check for self-referential assignments (e.g., x = { key: x.something })\n          // The value associated with the key might contain a reference back to x.\n          Node childVal = keyNode.getLastChild(); // Value is last child of STRING_KEY, GETTER_DEF, etc.\n          if (childVal != null) {\n            // Check if childVal is an ancestor of the node using 'x' (t.getParent()).\n            // Iterate through all references to 'x' to see if any appear inside 'childVal'.\n            for (Reference t : refs) {\n                // Find the node that uses the variable reference 't'.\n                // e.g., for x in x.a, refParent is GETPROP(x.a)\n                // e.g., for x in foo(x), refParent is CALL(foo, x)\n                Node refParent = t.getParent();\n\n                // Check ancestry: Is childVal an ancestor of refParent?\n                // We need to walk up from refParent and see if we hit childVal\n                // before hitting the object literal itself or a scope boundary.\n                Node current = refParent;\n                while (current != null && current != assignedValue && !NodeUtil.isStatementBlock(current)) {\n                    if (current == childVal) {\n                        // Found a self-reference: the value 'childVal' contains the reference 't'.\n                        // Examples:\n                        // x = { a: x.b } (childVal is GETPROP(x.b), current starts as GETPROP(x.b))\n                        // x = { a: foo(x) } (childVal is CALL(foo, NAME(x)), current hits CALL)\n                        // x = { a: x } (childVal is NAME(x), current hits NAME(x))\n                        return false;\n                    }\n                    current = current.getParent();\n                }\n            }\n          }\n        } // End loop checking object literal keys/values\n\n        // If we reached here, this reference is a valid object literal assignment.\n        // Mark that we found at least one suitable assignment.\n        ret = true;\n      } // End loop over all references\n\n      // Return true iff we found at least one valid OBJECTLIT assignment ('ret' is true)\n      // and none of the references triggered an early 'return false'.\n      return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}