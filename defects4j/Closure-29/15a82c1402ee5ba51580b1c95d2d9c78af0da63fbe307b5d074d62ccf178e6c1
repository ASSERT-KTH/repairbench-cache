{
    "generation": "private boolean isInlinableObject(List<Reference> refs) {\n  // Have we seen at least one object\u2010literal assignment?\n  boolean foundLiteral = false;\n  // The set of properties defined in any object literal so far.\n  Set<String> literalProps = new HashSet<>();\n  // The set of properties added via dynamic assignments (x.p = ...).\n  Set<String> dynamicProps = new HashSet<>();\n\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n\n    // Handle any property access on the object.\n    if (parent.isGetProp()) {\n      // name must be the receiver.\n      Preconditions.checkState(parent.getFirstChild() == name);\n\n      // Bail out on a direct call x.y(), since 'this' could be used.\n      if (gramps.isCall() && gramps.getFirstChild() == parent) {\n        return false;\n      }\n\n      String propName = parent.getLastChild().getString();\n\n      // If this is a dynamic assignment (x.p = ...), record it.\n      if (gramps.isAssign() && gramps.getFirstChild() == parent) {\n        dynamicProps.add(propName);\n        continue;\n      }\n\n      // Otherwise it's a property read or other usage.\n      // We must already have seen a literal assignment or a dynamic\n      // assignment for this prop.\n      if (!foundLiteral && dynamicProps.isEmpty()) {\n        // no object literal yet, no dynamic props yet\n        return false;\n      }\n      if (!literalProps.contains(propName) && !dynamicProps.contains(propName)) {\n        // reading or using a prop that was never defined\n        return false;\n      }\n      continue;\n    }\n\n    // Only simple var-decls or x = ... assignments to the base var.\n    if (!isVarOrAssignExprLhs(name)) {\n      return false;\n    }\n\n    Node val = ref.getAssignedValue();\n    if (val == null) {\n      // var x;  (no initializer)\n      continue;\n    }\n\n    // We only inline object\u2010literal assignments.\n    if (!val.isObjectLit()) {\n      return false;\n    }\n\n    // Record that we now have a literal assignment.\n    foundLiteral = true;\n\n    // Collect all the literal's own (non-getter/setter) property names.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isGetterDef() || child.isSetterDef()) {\n        // ES5 get/set not supported by this pass.\n        return false;\n      }\n      literalProps.add(child.getString());\n    }\n\n    // Disallow self\u2010referential assignments like x = { a: x.b }.\n    for (Node child = val.getFirstChild(); child != null; child = child.getNext()) {\n      Node childVal = child.getFirstChild();\n      for (Reference t : refs) {\n        Node refNode = t.getParent();\n        while (!NodeUtil.isStatementBlock(refNode)) {\n          if (refNode == childVal) {\n            return false;\n          }\n          refNode = refNode.getParent();\n        }\n      }\n    }\n  }\n\n  return foundLiteral;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}