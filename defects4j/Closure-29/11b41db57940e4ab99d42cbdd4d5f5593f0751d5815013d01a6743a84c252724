{
    "generation": "    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     *\n     * This function determines if a variable, primarily assigned an object literal,\n     * can have its properties inlined into separate variables. It iterates through\n     * all references to the variable and checks for conditions that prevent inlining.\n     *\n     * Conditions that prevent inlining:\n     * - The variable is assigned a non-object literal value (e.g., `x = 5;`).\n     * - The object literal contains ES5 getters or setters.\n     * - The object literal is self-referential in a problematic way (e.g., x = {a: x.b}).\n     * - The variable itself is used directly (e.g., `f(x)`, `return x`), other than its initial assignment\n     *   or assignment to an object literal.\n     * - A property access `x.prop()` implies `x` is the `this` context.\n     * - A property read `x.prop` where `prop` is not explicitly defined on the object literal\n     *   (to avoid breaking prototype chain lookups).\n     *\n     * Conditions that do NOT prevent inlining (and are handled by the pass):\n     * - Simple property assignments like `x.prop = value;`.\n     * - Multiple object literal assignments to the same variable (the inliner is designed to handle this).\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      // Find a representative object literal definition from the references.\n      // This node will be used for property existence checks (the \"blind spot\" fix).\n      // We pick the first one encountered as the reference.\n      Node effectiveObjectLiteralForProperties = null;\n      boolean foundAnyObjectLiteralAssignment = false; // Tracks if at least one object literal assignment exists.\n\n      for (Reference ref : refs) {\n        Node val = ref.getAssignedValue();\n        if (val != null && val.isObjectLit()) {\n          effectiveObjectLiteralForProperties = val;\n          foundAnyObjectLiteralAssignment = true;\n          // We break here because we just need *a* representative literal for property checks.\n          // The pass handles multiple assignments separately, so this function doesn't need to return false for that.\n          break;\n        }\n      }\n\n      // If no object literal assignment was found among the references,\n      // this variable cannot be inlined as an object literal.\n      if (!foundAnyObjectLiteralAssignment) {\n        return false;\n      }\n\n      // 'ret' tracks if at least one acceptable object literal assignment was found.\n      // If any reference causes an immediate 'return false', the whole variable is not inlinable.\n      boolean ret = false;\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Check if the reference is an assignment to the variable itself.\n        Node val = ref.getAssignedValue();\n        if (val != null) { // This is an assignment reference (e.g., x = {...}, x = 5)\n          if (!val.isObjectLit()) {\n            // If the assigned value is not an object literal, this variable cannot be inlined.\n            return false;\n          }\n\n          // If it is an object literal assignment, mark that we found at least one.\n          ret = true;\n\n          // Make sure that the value is not self-referential and doesn't use ES5 getters/setters.\n          for (Node child = val.getFirstChild(); child != null;\n               child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n              // ES5 get/set not supported for inlining.\n              return false;\n            }\n\n            Node childVal = child.getFirstChild(); // The value of the property (e.g., `x.a` in `y = {b: x.a}`).\n            if (childVal != null) {\n              // Check if `childVal` is self-referential (e.g., `x = {b: x.a}`).\n              // Iterate through all references to the variable (`t` in `refs`).\n              // If `childVal` (e.g., `x.a`) is an ancestor of any such reference `t` (e.g., the `x` in `x.a`),\n              // then it's a problematic self-reference.\n              for (Reference t : refs) {\n                Node currentRefParent = t.getParent();\n                // Walk up the AST from the parent of the current reference `t`.\n                // Stop at the first statement block to avoid checking unrelated code blocks.\n                while (!NodeUtil.isStatementBlock(currentRefParent)) {\n                  if (currentRefParent == childVal) {\n                    return false; // Self-referential assignment found.\n                  }\n                  currentRefParent = currentRefParent.getParent();\n                }\n              }\n            }\n          }\n          continue; // This object literal assignment reference has been processed.\n        }\n\n        // If 'name' is not the left-hand side of a VAR declaration or an ASSIGN_EXPR,\n        // it means the variable itself is used as a value (e.g., `f(x)`, `return x`, `x++`).\n        // Inlining the object into its properties makes `x` disappear, so such direct uses are not allowed.\n        // This check correctly catches direct references to `x` that are not property accesses.\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        // Handle property access references (e.g., x.fn(), x.prop, x.prop = value).\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          String propertyName = parent.getSecondChild().getString();\n\n          // If the property access is the target of a call (e.g., `x.fn()`),\n          // `x` is implicitly used as the `this` value. Inlining would lose the `this` context.\n          if (gramps.isCall() && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          //\n          // This \"blind spot\" check applies only to property *reads*.\n          // Property assignments (e.g., `x.prop = value`) are handled by the inliner\n          // by creating a new variable for the property, so they should not prevent inlining.\n          if (! (gramps.isAssign() && gramps.getFirstChild() == parent) ) {\n              // This is a property read (not an assignment to a property).\n              boolean propertyFoundInLiteral = false;\n              // Check if the property is explicitly defined on the `effectiveObjectLiteralForProperties`.\n              for (Node prop : effectiveObjectLiteralForProperties.children()) {\n                // Check string keys, getters, and setters as defined properties.\n                if (prop.isStringKey() || prop.isGetterDef() || prop.isSetterDef()) {\n                    if (prop.getString().equals(propertyName)) {\n                        propertyFoundInLiteral = true;\n                        break;\n                    }\n                }\n              }\n              if (!propertyFoundInLiteral) {\n                  // Property not found in the object literal itself.\n                  // This means it could come from the prototype chain, which inlining breaks.\n                  return false;\n              }\n          }\n          // If it's a property read found in the literal, or an assignment to a property (which is allowed),\n          // this reference is compatible. Continue to the next reference.\n          continue;\n        }\n\n        // Other cases, like `var x;` (which is `isVarOrAssignExprLhs` and `val` is null),\n        // are implicitly fine and should not cause `return false`.\n      }\n\n      // If we reach here, it means:\n      // 1. At least one object literal assignment was found (`ret` is true).\n      // 2. All references were compatible with inlining based on the rules above.\n      return ret;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}