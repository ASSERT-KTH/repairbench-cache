{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex state for comparison and contraction/shrink\n            final RealPointValuePair[] original = simplex; // This is the simplex state at the beginning of the current iteration.\n            final RealPointValuePair bestOriginal = original[0];\n\n            // 1. Perform a reflection step\n            // evaluateNewSimplex computes the new point based on `original`,\n            // replaces the worst point in `this.simplex` with the new point, and sorts `this.simplex`.\n            // The returned `reflectedPoint` is the point that was inserted.\n            final RealPointValuePair reflectedPoint = evaluateNewSimplex(original, 1.0, comparator);\n\n            // Compare the newly inserted reflected point with the best point of the original simplex.\n            if (comparator.compare(reflectedPoint, bestOriginal) < 0) { // If reflected point is better than original best\n\n                // Reflection was successful, now try expansion\n                // Store the state of `this.simplex` *after reflection* before attempting expansion.\n                // We need a deep copy if RealPointValuePair was mutable, but it's immutable, so shallow copy of array is fine.\n                final RealPointValuePair[] simplexAfterReflection = new RealPointValuePair[simplex.length];\n                System.arraycopy(simplex, 0, simplexAfterReflection, 0, simplex.length);\n\n                // Compute the expanded point. This will update `this.simplex` again, based on `original`.\n                final RealPointValuePair expandedPoint = evaluateNewSimplex(original, khi, comparator);\n\n                // Compare the newly inserted expanded point with the reflected point.\n                // If expanded point is strictly better than reflected point, keep the expanded simplex.\n                // Otherwise (expanded is not better), revert to the reflected simplex.\n                if (comparator.compare(expandedPoint, reflectedPoint) < 0) {\n                    // Expanded point is strictly better. Keep the current `this.simplex` (which is the expanded simplex).\n                    // No action needed here.\n                } else {\n                    // Expanded point is not better. Revert `this.simplex` to the state after reflection.\n                    simplex = simplexAfterReflection;\n                }\n\n            } else { // Reflection did not improve the best point. Try contraction.\n\n                // Compute the contracted point. This will update `this.simplex`.\n                final RealPointValuePair contractedPoint = evaluateNewSimplex(original, gamma, comparator);\n\n                // If contraction improved the best point (compared to original best).\n                if (comparator.compare(contractedPoint, bestOriginal) < 0) {\n                    // Contraction was successful. Keep the current `this.simplex` (which is the contracted simplex).\n                    // No action needed here.\n                } else {\n                    // Neither reflection nor contraction improved the best point. Perform shrink.\n                    // Shrink moves all points (except the best) towards the best point of the *original* simplex.\n                    final RealPointValuePair bestPointOfOriginalSimplex = original[0];\n                    for (int i = 1; i < original.length; ++i) { // Iterate from second best to worst point in the original simplex\n                        final double[] originalPointCoords = original[i].getPoint();\n                        final double[] newCoords = new double[originalPointCoords.length];\n                        for (int j = 0; j < originalPointCoords.length; ++j) {\n                            // Calculate new coordinates: p_new = p_best + sigma * (p_original - p_best)\n                            newCoords[j] = bestPointOfOriginalSimplex.getPoint()[j] + sigma * (originalPointCoords[j] - bestPointOfOriginalSimplex.getPoint()[j]);\n                        }\n                        // Create a new RealPointValuePair with the shrunk coordinates and evaluate its value.\n                        simplex[i] = new RealPointValuePair(newCoords, function.value(newCoords));\n                    }\n                    // After shrinking, the simplex might not be sorted. Re-sort it.\n                    sort(comparator);\n                }\n            }\n            // The loop continues to the next iteration. Convergence check or maximal iterations are handled by the calling `doOptimize` method.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}