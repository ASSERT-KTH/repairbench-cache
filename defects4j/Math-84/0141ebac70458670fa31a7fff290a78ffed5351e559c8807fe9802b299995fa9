{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // Count the iteration.\n    incrementIterationsCounter();\n\n    // Save the original simplex and its best vertex.\n    final RealPointValuePair[] original = simplex;\n    final RealPointValuePair best = original[0];\n\n    // --- Reflection step ---\n    // Try to reflect the worst point through the centroid.\n    final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n    if (comparator.compare(reflected, best) < 0) {\n        // The reflected point is an improvement.\n        // Try to further expand the simplex along the reflection direction.\n        // Note: evaluateNewSimplex updates the member \"simplex\" with the new vertices.\n        final RealPointValuePair[] reflectedSimplex = simplex;  // save the state after reflection\n        final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n        // If the expansion did not improve over the reflection then keep the reflected simplex.\n        if (comparator.compare(reflected, expanded) <= 0) {\n            simplex = reflectedSimplex;\n        }\n        return;\n    }\n\n    // --- Contraction step ---\n    // Try to contract (move vertices toward the best vertex) since reflection failed.\n    final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n    if (comparator.compare(contracted, best) < 0) {\n        // The contraction yielded an improvement.\n        return;\n    }\n\n    // --- Shrink (reduction) step ---\n    // Neither reflection nor contraction improved the simplex.\n    // Shrink all vertices (except the best) toward the best vertex.\n    final double sigma = 0.5;  // shrink factor (typically 0.5)\n    final double[] bestPoint = best.getPoint();\n    for (int i = 1; i < simplex.length; i++) {\n        final double[] currentPoint = simplex[i].getPoint();\n        final double[] newPoint = new double[currentPoint.length];\n        for (int j = 0; j < currentPoint.length; j++) {\n            newPoint[j] = bestPoint[j] + sigma * (currentPoint[j] - bestPoint[j]);\n        }\n        simplex[i] = new RealPointValuePair(newPoint, computeObjectiveValue(newPoint));\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}