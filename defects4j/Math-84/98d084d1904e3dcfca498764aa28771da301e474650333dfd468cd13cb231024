{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        incrementIterationsCounter();\n\n        // save the original vertex (only the best point is needed for comparisons here)\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // perform a reflection step\n        // evaluateNewSimplex updates the simplex internally\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n\n        if (comparator.compare(reflected, best) < 0) {\n            // reflected is better than the best point\n\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex; // Capture simplex state after reflection\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); // Compute expansion, updates simplex\n\n            // accept the reflected simplex if it is better than or equal to the expanded one\n            // (i.e., if expansion did not produce a strictly better point)\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // revert to the reflected simplex state, because expansion was not better\n                simplex = reflectedSimplex;\n            }\n            // otherwise, the expanded simplex is kept (it's already in simplex)\n\n            // No return here, iteration finishes.\n\n        } else {\n            // reflected is not better than the best point\n\n            // compute the contracted simplex\n            // evaluateNewSimplex updates the simplex internally\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n            // check if contracted is better than the best point\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n                // (simplex is already updated by evaluateNewSimplex, so no explicit action needed)\n\n            // No return here, iteration finishes.\n            } else {\n                // Neither reflected nor contracted yielded a better point than 'best'.\n                // The MultiDirectional algorithm (unlike Nelder-Mead) does not necessarily\n                // perform a shrink step here. The simplex state after the contraction\n                // attempt (which is already stored in 'simplex' by evaluateNewSimplex) is kept.\n                // The main optimization loop will decide whether to continue based on convergence criteria.\n\n            // No return here, iteration finishes.\n            }\n        }\n        // The simplex array has been updated by one of the evaluateNewSimplex calls.\n        // The iteration is complete. The base class optimization loop handles termination.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}