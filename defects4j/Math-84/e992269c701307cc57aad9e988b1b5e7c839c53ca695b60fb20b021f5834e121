{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // The simplex state is updated by evaluateNewSimplex. Need to save the original\n        // state to potentially revert/restart steps like expansion or contraction from it.\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // Perform a reflection step. The evaluateNewSimplex method presumably updates\n        // the simplex field internally and returns the best point of the new simplex.\n        // Standard coefficient for reflection is rho (typically 1.0).\n        final RealPointValuePair reflected = evaluateNewSimplex(original, rho, comparator);\n\n        if (comparator.compare(reflected, best) < 0) {\n            // Reflection gave an improvement. Now try expansion.\n\n            // Keep track of the simplex state after successful reflection.\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            // Perform expansion step starting from the original simplex.\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n            // Accept the expanded simplex if it's better than the reflected one.\n            // Otherwise, revert to the reflected simplex.\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // Expansion was not better than reflection, accept the reflected simplex.\n                simplex = reflectedSimplex;\n            }\n            // else: Expansion was better, simplex is already updated by evaluateNewSimplex.\n\n            // Iteration successful (reflection or expansion).\n            incrementIterationsCounter();\n            return;\n\n        } else {\n            // Reflection did not produce a better point. Try contraction.\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n            if (comparator.compare(contracted, best) < 0) {\n                // Contraction gave an improvement. Accept the contracted simplex.\n                // (simplex is already updated by evaluateNewSimplex).\n\n                // Iteration successful (contraction).\n                incrementIterationsCounter();\n                return;\n            } else {\n                // Neither reflection nor contraction improved the situation.\n                // Perform a shrink step (reducing the size of the simplex around the best point).\n                // The shrink step is performed starting from the original simplex state.\n                // evaluateNewSimplex with sigma coefficient performs the shrink.\n                evaluateNewSimplex(original, sigma, comparator);\n\n                // Iteration concluded (shrink).\n                incrementIterationsCounter();\n                return;\n            }\n        }\n        // Note: The original while(true) loop was removed because each logical path\n        // now leads to a return, completing one iteration step (reflection/expansion,\n        // contraction, or shrink). The outer optimization loop handles convergence checks\n        // and iteration limits. Incrementing the counter should happen once per completed step.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}