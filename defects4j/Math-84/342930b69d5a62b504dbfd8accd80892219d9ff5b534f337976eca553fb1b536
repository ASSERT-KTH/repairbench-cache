{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        incrementIterationsCounter();\n\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // perform a reflection step\n        // evaluateNewSimplex is assumed to update the simplex field with the new configuration\n        // and return the best point in the new simplex.\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); // Factor 1.0 for reflection\n        if (comparator.compare(reflected, best) < 0) {\n            // Reflection is better than best. Store the reflected simplex state temporarily.\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            // Try expansion.\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); // Factor khi for expansion\n            // Accept expansion if it's strictly better than reflection.\n            // Otherwise, revert to the reflected simplex state.\n            // Assumption: evaluateNewSimplex updates the 'simplex' field.\n            if (comparator.compare(expanded, reflected) >= 0) {\n                 // Expansion was not better, revert to reflected state.\n                 simplex = reflectedSimplex;\n            }\n            // else: simplex is already the expanded state.\n\n            // Iteration finished (found improvement via reflection/expansion)\n            return;\n        }\n\n        // Reflection was not better than best. Try contraction.\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); // Factor gamma for contraction\n        if (comparator.compare(contracted, best) < 0) {\n            // Contraction is better than best. Accept the contracted simplex.\n            // Assumption: simplex field is already updated by evaluateNewSimplex.\n\n            // Iteration finished (found improvement via contraction)\n            return;\n        }\n\n        // Neither reflection nor contraction improved.\n        // The original Nelder-Mead performs a shrink step here.\n        // However, MultiDirectional doesn't define sigma.\n        // We just return, ending the iteration. The simplex state\n        // might be the result of the failed contraction attempt or unchanged,\n        // depending on evaluateNewSimplex implementation details.\n        // This fixes the infinite loop.\n        return;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}