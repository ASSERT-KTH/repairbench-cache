{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) { // Loop until convergence or max iterations/evaluations\n\n            incrementIterationsCounter();\n\n            // Save the simplex state before this iteration for convergence check.\n            // The convergence checker compares the simplex from the previous iteration\n            // with the simplex from the current iteration.\n            final RealPointValuePair[] previousSimplex = simplex;\n\n            // save the original vertex state from the start of the iteration\n            // (before any step modifies `this.simplex`)\n            final RealPointValuePair[] originalSimplexState = simplex;\n            final RealPointValuePair best = originalSimplexState[0];\n\n            // perform a reflection step\n            // `evaluateNewSimplex` modifies `this.simplex` in place by creating a new array.\n            final RealPointValuePair reflected = evaluateNewSimplex(originalSimplexState, 1.0, comparator);\n\n            if (comparator.compare(reflected, best) < 0) { // Reflected point is better than the original best.\n\n                // compute the expanded simplex\n                // Store the current (reflected) simplex state in case we need to revert.\n                final RealPointValuePair[] simplexAfterReflection = simplex;\n                // Evaluate expansion based on the *original* simplex (originalSimplexState)\n                final RealPointValuePair expanded = evaluateNewSimplex(originalSimplexState, khi, comparator);\n\n                if (comparator.compare(expanded, reflected) < 0) { // Expanded point is better than reflected.\n                    // Accept the expanded simplex. `this.simplex` is already updated to `expanded` state.\n                    // No action needed.\n                } else {\n                    // Accept the reflected simplex (expanded was not better).\n                    this.simplex = simplexAfterReflection; // Revert `this.simplex` to the reflected state.\n                }\n\n                // No immediate return. The algorithm must continue iterating.\n\n            } else { // Reflected point is NOT better than the original best.\n\n                // compute the contracted simplex\n                // Evaluate contraction based on the *original* simplex (originalSimplexState)\n                final RealPointValuePair contracted = evaluateNewSimplex(originalSimplexState, gamma, comparator);\n\n                if (comparator.compare(contracted, best) < 0) { // Contracted point is better than the original best.\n                    // Accept the contracted simplex. `this.simplex` is already updated to `contracted` state.\n                    // No action needed.\n                } else {\n                    // Neither reflection, expansion, nor contraction improved the simplex over the best point.\n                    // The simplex might be oscillating or stuck. The algorithm proceeds to the next iteration.\n                    // `this.simplex` is currently in the state after the failed contraction.\n                }\n                // No immediate return. The algorithm must continue iterating.\n            }\n\n            // Check for convergence after each iteration.\n            // If converged, exit the loop.\n            if (getConvergenceChecker().converged(getIterations(), previousSimplex, simplex)) {\n                return;\n            }\n        }\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}