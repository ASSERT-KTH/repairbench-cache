{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter(); // This also calls checkIterationsCounter() which might throw MaxIterationsExceededException\n\n            // save the original vertex to check for convergence later\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0]; // original[0] is the best point as simplex is sorted\n\n            // perform a reflection step\n            // The evaluateNewSimplex method is expected to modify 'this.simplex'\n            // to the new (reflected) simplex and return its best point.\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            \n            // At this point, 'simplex' holds the reflected simplex. 'reflected' is 'simplex[0]'.\n\n            if (comparator.compare(reflected, best) < 0) { // If the reflected simplex has a better best point\n\n                // Reflection was successful.\n                // Store the state of the simplex after reflection, before potential expansion.\n                final RealPointValuePair[] reflectedSimplex = simplex; \n\n                // compute the expanded simplex\n                // This call will overwrite 'this.simplex' with the expanded simplex.\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n                // 'expanded' is 'this.simplex[0]' (best point of the expanded simplex)\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // Expanded simplex is not better than reflected (or only equally good).\n                    // Accept the reflected simplex by reverting 'this.simplex'.\n                    simplex = reflectedSimplex;\n                }\n                // If expanded was strictly better, 'simplex' already holds the expanded simplex.\n                // Removed the premature 'return' statement. The algorithm should continue iterating.\n\n            } else { // Reflection did not improve the best point (reflected >= best)\n\n                // Try contraction.\n                // This call will overwrite 'this.simplex' with the contracted simplex.\n                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n                // 'contracted' is 'this.simplex[0]' (best point of the contracted simplex)\n                if (comparator.compare(contracted, best) < 0) {\n                    // Contraction improved the best point.\n                    // 'simplex' already holds the contracted simplex.\n                    // Removed the premature 'return' statement. The algorithm should continue iterating.\n                } else {\n                    // Neither reflection nor contraction improved the best point.\n                    // The 'simplex' is currently the contracted simplex, which did not improve.\n                    // In the MultiDirectional method, there is no explicit \"shrink\" step here\n                    // as found in Nelder-Mead. The algorithm will proceed to the convergence check.\n                    // If not converged and no improvement, it will continue the loop, relying\n                    // on the convergence checker to detect stagnation or the max iterations counter.\n                }\n            }\n\n            // Check for convergence after each iteration step.\n            // 'original' holds the simplex before this iteration.\n            // 'simplex' holds the simplex after reflection/expansion/contraction.\n            if (getConvergenceChecker().converged(getIterations(), original, simplex)) {\n                return; // Converged, exit the loop.\n            }\n            // If not converged, the loop continues for the next iteration.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}