{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        incrementIterationsCounter();\n\n        // Save the state of the original simplex before any modifications\n        // The simplex is assumed to be ordered from best [0] to worst [n] by the caller\n        final RealPointValuePair[] original = new RealPointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, original, 0, simplex.length);\n        final RealPointValuePair originalBest = original[0]; // Best point of the original simplex\n\n        // --- Reflection Step ---\n        // Evaluate the simplex reflected with respect to the best point.\n        // evaluateNewSimplex updates the 'simplex' field to the reflected simplex state\n        // and returns the best point of this new simplex.\n        final RealPointValuePair reflectedBest = evaluateNewSimplex(original, 1.0, comparator);\n\n        if (comparator.compare(reflectedBest, originalBest) < 0) {\n            // Reflection gave an improvement over the original best.\n\n            // --- Expansion Step ---\n            // Keep the reflected simplex state in case expansion is worse.\n            final RealPointValuePair[] reflectedSimplex = new RealPointValuePair[simplex.length];\n            System.arraycopy(simplex, 0, reflectedSimplex, 0, simplex.length);\n\n            // Evaluate the simplex expanded with respect to the original best.\n            // evaluateNewSimplex updates the 'simplex' field to the expanded simplex state.\n            final RealPointValuePair expandedBest = evaluateNewSimplex(original, khi, comparator);\n\n            // Accept the better of the expanded and reflected simplex.\n            // If expanded is not strictly better than reflected, revert to the reflected state.\n            if (comparator.compare(expandedBest, reflectedBest) >= 0) {\n                // Revert: Accept the reflected simplex\n                simplex = reflectedSimplex;\n            }\n            // Else: Accept expanded simplex (which is already the current state of 'simplex')\n\n        } else {\n            // Reflection did not produce a better simplex than the original best.\n\n            // --- Contraction Step ---\n            // Evaluate the simplex contracted with respect to the original best.\n            // evaluateNewSimplex updates the 'simplex' field to the contracted simplex state.\n            final RealPointValuePair contractedBest = evaluateNewSimplex(original, gamma, comparator);\n\n            if (comparator.compare(contractedBest, originalBest) < 0) {\n                // Contraction gave an improvement over the original best.\n                // Accept the contracted simplex (already in 'simplex' field)\n                // No action needed.\n            } else {\n                // Neither reflection nor contraction improved upon the original best point.\n                // --- Shrink Step ---\n                // Perform a shrink step: evaluate the simplex shrunk towards the original best.\n                // evaluateNewSimplex with a coefficient of 0.5 performs the shrink operation.\n                // This updates the 'simplex' field to the shrunk simplex state.\n                 evaluateNewSimplex(original, 0.5, comparator);\n                 // Accept the shrunk simplex (now in 'simplex' field)\n            }\n        }\n        // The simplex field now holds the simplex resulting from this iteration.\n        // Control returns to the calling optimizer loop which checks for convergence.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}