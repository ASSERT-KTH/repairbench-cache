{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    while (true) {\n        // Record an iteration.\n        incrementIterationsCounter();\n\n        // Make a copy of the current simplex (the vertices are assumed to be sorted).\n        final RealPointValuePair[] original = simplex.clone();\n        final RealPointValuePair best = original[0];\n\n        // --- Reflection step ---\n        // Try a reflection with a factor of 1.0.\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n            // If reflection improves on the best vertex, try an expansion.\n            final RealPointValuePair[] reflectedSimplex = simplex.clone();\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // Accept the reflected simplex.\n                simplex = reflectedSimplex;\n            }\n            // Optionally check for convergence using the best vertex.\n            if (convergenceChecker != null &&\n                convergenceChecker.converged(getIterations(), best, simplex[0])) {\n                return;\n            }\n            return;\n        }\n\n        // --- Contraction step ---\n        // If reflection did not yield improvement, try a contraction with factor gamma.\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n        if (comparator.compare(contracted, best) < 0) {\n            // Accept the contracted simplex.\n            if (convergenceChecker != null &&\n                convergenceChecker.converged(getIterations(), best, simplex[0])) {\n                return;\n            }\n            return;\n        }\n\n        // --- Shrink step ---\n        // Neither reflection nor contraction produced an improved simplex.\n        // In this case, shrink the simplex toward the best vertex.\n        final int n = simplex.length;\n        final int dim = best.getPoint().length;\n        for (int i = 1; i < n; i++) {\n            final double[] newPoint = new double[dim];\n            final double[] bestPoint = best.getPoint();\n            final double[] currentPoint = simplex[i].getPoint();\n            for (int j = 0; j < dim; j++) {\n                newPoint[j] = bestPoint[j] + 0.5 * (currentPoint[j] - bestPoint[j]);\n            }\n            // Evaluate the objective function at the new point.\n            double newValue = evaluate(newPoint);\n            simplex[i] = new RealPointValuePair(newPoint, newValue, false);\n        }\n        // After shrinking the simplex, check if the convergence criteria is met.\n        if (convergenceChecker != null &&\n            convergenceChecker.converged(getIterations(), best, simplex[0])) {\n            return;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}