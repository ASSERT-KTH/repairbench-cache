{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // Initialize previousSimplex for the first convergence check.\n        // It's the state of the simplex *before* the first iteration step.\n        // A copy is needed because the 'simplex' field itself will be modified.\n        RealPointValuePair[] previousSimplex = new RealPointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, previousSimplex, 0, simplex.length);\n\n        while (true) {\n            // Check for convergence before performing the current iteration step.\n            // If the simplex has converged since the last state, we are done.\n            if (getConvergenceChecker().converged(getIterations(), previousSimplex, simplex)) {\n                return;\n            }\n\n            // Increment iteration counter and check against maximal iterations.\n            // This call will throw MaxIterationsExceededException if the limit is reached.\n            incrementIterationsCounter();\n\n            // Store the current simplex state *before* modifying it in this iteration.\n            // This becomes 'previousSimplex' for the *next* iteration's convergence check.\n            previousSimplex = new RealPointValuePair[simplex.length];\n            System.arraycopy(simplex, 0, previousSimplex, 0, simplex.length);\n\n            final RealPointValuePair[] original = simplex; // Current simplex for this iteration step\n            final RealPointValuePair best = original[0]; // Best point of the current simplex\n\n            boolean shrinkRequired = true; // Flag to indicate if a shrink step is needed\n\n            // Perform a reflection step\n            // evaluateNewSimplex updates 'this.simplex' and returns its best point.\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n\n            if (comparator.compare(reflected, best) < 0) {\n                // Reflection was successful (reflected point is better than original best).\n                // Now, try expansion.\n                \n                // Capture the state of the simplex *after* the successful reflection.\n                // 'this.simplex' currently holds the reflected simplex if evaluateNewSimplex updated it.\n                final RealPointValuePair[] reflectedSimplex = simplex;\n\n                // Compute the expanded simplex (from the original configuration).\n                // This call will potentially update 'this.simplex' again to the expanded simplex.\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n                // Compare reflected and expanded results.\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // Reflected is better or equal to expanded, so we accept the reflected simplex.\n                    // Revert 'this.simplex' back to the reflected simplex state.\n                    simplex = reflectedSimplex;\n                }\n                // Else (expanded is strictly better than reflected), 'simplex' already holds the expanded one.\n                // No action needed as evaluateNewSimplex already placed the better result into 'this.simplex'.\n\n                shrinkRequired = false; // An improvement was found (reflection or expansion), so no shrink is needed.\n\n            } else { // Reflection was not better than original best\n                // Reflection did not improve the simplex. Try contraction.\n                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n                if (comparator.compare(contracted, best) < 0) {\n                    // Contraction was successful (contracted point is better than original best).\n                    shrinkRequired = false; // An improvement was found, so no shrink is needed.\n                }\n                // Else (contracted was not better than original best), shrinkRequired remains true.\n            }\n\n            // If no improvement was found through reflection, expansion, or contraction, perform a shrink.\n            if (shrinkRequired) {\n                evaluateNewSimplex(original, sigma, comparator); // 'sigma' is the shrink coefficient\n            }\n            // The loop continues to the next iteration to re-evaluate convergence and perform another step.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}