{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    final RealPointValuePair[] previous = simplex.clone();\n\n    while (true) {\n\n        incrementIterationsCounter();\n\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n\n        if (comparator.compare(reflected, best) < 0) {\n\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // accept the reflected simplex\n                simplex = reflectedSimplex;\n            }\n            // check convergence\n            break;\n\n        } else {\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n                // check convergence\n                break;\n            } else {\n                // shrink simplex towards best point\n                for (int i = 1; i < simplex.length; ++i) {\n                    final double[] xBest = simplex[0].getPoint();\n                    final double[] x = simplex[i].getPoint();\n                    double[] newX = new double[x.length];\n                    for (int j = 0; j < x.length; ++j) {\n                        newX[j] = 0.5 * (xBest[j] + x[j]);\n                    }\n                    simplex[i] = new RealPointValuePair(newX,\n                                                        computeObjectiveValue(newX),\n                                                        false);\n                }\n                // check convergence\n                break;\n            }\n        }\n    }\n\n    // Check convergence: if simplex has not changed significantly, stop\n    boolean converged = true;\n    for (int i = 0; i < simplex.length; ++i) {\n        final double[] prev = previous[i].getPoint();\n        final double[] curr = simplex[i].getPoint();\n        for (int j = 0; j < prev.length; ++j) {\n            if (Math.abs(prev[j] - curr[j]) > 1e-10) {\n                converged = false;\n                break;\n            }\n        }\n        if (!converged) {\n            break;\n        }\n    }\n\n    if (!converged) {\n        // Not yet converged: continue iterating in next iteration of optimize()\n        // (this will be handled by outer optimization loop)\n        // Otherwise, do nothing here: converge exit handled by outer loop via convergence checker\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}