{
    "generation": "import org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport java.util.Comparator;\n\n    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        incrementIterationsCounter();\n\n        // Simplex is assumed sorted by the caller (DirectSearchOptimizer.optimize)\n        final int n = simplex.length - 1;\n        final RealPointValuePair best = simplex[0];\n\n        // Keep the original simplex state as evaluateNewSimplex seems to need it as input\n        // AND it modifies the instance variable 'simplex' as a side effect.\n        final RealPointValuePair[] original = simplex.clone();\n\n        // --- Reflection ---\n        // evaluateNewSimplex updates the instance 'simplex' by replacing the worst point\n        // The reflection coefficient used here is 1.0, as in the original buggy code.\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n\n        if (comparator.compare(reflected, best) < 0) {\n            // Reflected point is better than the current best.\n            // Keep track of the simplex state after reflection.\n            final RealPointValuePair[] reflectedSimplexState = simplex.clone();\n\n            // --- Expansion ---\n            // Try expansion (updates instance 'simplex' based on 'original')\n            // Uses khi coefficient (defined in AbstractSimplexOptimizer).\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n            // Accept expansion if it is better than reflection.\n            if (comparator.compare(expanded, reflected) < 0) {\n                // Accept expanded: the instance 'simplex' was already updated by evaluateNewSimplex.\n                // No assignment needed here, simplex already holds the expanded state.\n            } else {\n                // Expansion was not better, revert the instance 'simplex' to the reflected state.\n                simplex = reflectedSimplexState;\n            }\n            // Iteration finished (found reflection or expansion).\n\n        } else {\n            // Reflected point is not better than the current best.\n            // --- Contraction ---\n            // Try contraction (updates instance 'simplex' based on 'original').\n            // Uses gamma coefficient (defined in AbstractSimplexOptimizer).\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n            if (comparator.compare(contracted, best) < 0) {\n                // Contracted point is better than the original best.\n                // Accept contracted: instance 'simplex' is already updated.\n                // No assignment needed here, simplex already holds the contracted state.\n                // Iteration finished (found contraction).\n\n            } else {\n                // Neither reflected nor contracted are better than the original best.\n                // --- Shrink ---\n                // Perform shrink step around the current best point (simplex[0]).\n                // Shrinking requires re-evaluating n points.\n                // Uses sigma coefficient (defined in AbstractSimplexOptimizer).\n\n                // The best point is simplex[0] from the current state (which might have\n                // been updated by the failed reflection or contraction attempt, but evaluateNewSimplex\n                // operates based on 'original', so the current 'simplex[0]' should still be valid).\n                final RealPointValuePair shrinkBest = simplex[0];\n\n                // Create a new array for the shrunk simplex\n                RealPointValuePair[] shrunkSimplex = new RealPointValuePair[n + 1];\n                shrunkSimplex[0] = shrinkBest; // Keep the best point\n\n                for (int i = 1; i <= n; i++) {\n                    // Calculate the new shrunk point coordinates\n                    // Shrink happens from the current simplex state towards the best point of that state.\n                    double[] currentPoint = simplex[i].getPointRef();\n                    double[] bestPoint = shrinkBest.getPointRef();\n                    double[] newPoint = new double[bestPoint.length];\n                    for (int j = 0; j < bestPoint.length; j++) {\n                        newPoint[j] = bestPoint[j] + sigma * (currentPoint[j] - bestPoint[j]);\n                    }\n                    // Evaluate the objective function for the new shrunk point\n                    // Use computeObjectiveValue (available from DirectSearchOptimizer)\n                    // Need to handle potential exceptions from computeObjectiveValue if necessary,\n                    // but the method signature already declares them.\n                    shrunkSimplex[i] = new RealPointValuePair(newPoint, computeObjectiveValue(newPoint));\n                }\n                // Update the instance simplex with the shrunk points and values\n                simplex = shrunkSimplex;\n                // Iteration finished (performed shrink).\n            }\n        }\n        // End of iteration step. Control returns to the optimize() method in the base class,\n        // which will sort the simplex and check convergence criteria. No return statement needed here.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}