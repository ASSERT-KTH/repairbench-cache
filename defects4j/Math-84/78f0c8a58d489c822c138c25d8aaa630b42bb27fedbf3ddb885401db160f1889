{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) { // Loop until convergence or max iterations\n\n            incrementIterationsCounter();\n\n            // Check if maximal number of iterations is exceeded.\n            // This is a standard early exit condition for iterative algorithms.\n            if (getIterations() > getMaxIterations()) {\n                throw new OptimizationException(new MaxIterationsExceededException(getMaxIterations()));\n            }\n\n            // Save the state of the simplex at the beginning of this iteration.\n            // This 'original' array will be used to calculate new points and for the convergence check.\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0]; // Best point from the *start* of this iteration.\n\n            // Perform a reflection step.\n            // The `evaluateNewSimplex` method in MultiDirectional is designed to:\n            // 1. Calculate a new point based on the 'original' simplex and the given coefficient (rho for reflection).\n            // 2. Replace the worst point in the *class's `simplex` field* with this new point.\n            // 3. Sort the *class's `simplex` field*.\n            // 4. Return the newly created point.\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n\n            // After the reflection, the class's `simplex` field has been updated with the `reflected` point\n            // (if it replaced the worst vertex) and is sorted.\n\n            // If the reflected point is better than the original best point:\n            if (comparator.compare(reflected, best) < 0) {\n\n                // The class's `simplex` field currently holds the state after reflection.\n                // Store this state in case we decide to keep the reflected point over an expanded one.\n                final RealPointValuePair[] simplexAfterReflection = simplex;\n\n                // Compute the expanded simplex, using the 'original' (start-of-iteration) simplex for calculations.\n                // This call will again modify the class's `simplex` field.\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n                // If the reflected point is still better or equally good compared to the expanded point:\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // This implies expansion was not beneficial enough (or worse).\n                    // Revert the class's `simplex` field to the state it had after the reflection step.\n                    simplex = simplexAfterReflection;\n                }\n                // If 'expanded' was strictly better, the class's `simplex` field is already in the desired state.\n                // The original code had a 'return' statement here, which is removed to allow further iterations.\n\n            } else { // Reflected point is NOT better than the original best point.\n\n                // Compute the contracted simplex, using the 'original' (start-of-iteration) simplex for calculations.\n                // This call will again modify the class's `simplex` field.\n                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n                // If the contracted point is better than the original best point:\n                if (comparator.compare(contracted, best) < 0) {\n                    // Accept the contracted simplex. The class's `simplex` field is already updated by `evaluateNewSimplex`.\n                    // The original code had an empty block and a 'return' here, which is removed.\n                } else {\n                    // Neither reflection nor contraction improved the best point compared to the original best.\n                    // In MultiDirectional, if no improvement is found, the algorithm continues, relying on the\n                    // convergence checker to detect stagnation or local optima.\n                }\n            }\n\n            // After all simplex operations for this iteration, check for convergence.\n            // Compare the best point from the start of this iteration (`original[0]`)\n            // with the best point at the end of this iteration (`simplex[0]`).\n            if (getConvergenceChecker().converged(original[0], simplex[0])) {\n                break; // Exit the loop if convergence is achieved.\n            }\n\n        } // End of while (true) loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}