{
    "generation": "import org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.optimization.OptimizationException;\nimport org.apache.commons.math.optimization.RealPointValuePair;\nimport java.util.Comparator;\nimport java.lang.IllegalArgumentException;\n\n// Assumes base class AbstractSimplexOptimizer provides:\n// - Member variables: double rho, khi, gamma, sigma; (coefficients)\n// - Member variable: RealPointValuePair[] simplex;\n// - Method: double evaluate(double[] p) throws FunctionEvaluationException, IllegalArgumentException;\n// - Method: RealPointValuePair evaluateNewSimplex(RealPointValuePair[] originalSimplex, double coeff, Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException, OptimizationException;\n//   (This helper likely calculates a new point based on originalSimplex using coeff, evaluates it, replaces the worst point in *this.simplex* if the new point is better, sorts *this.simplex*, and returns the new point.)\n// - Method: void sortSimplex(Comparator<RealPointValuePair> comparator);\n\n    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // The iteration counter increment and convergence checks are handled by the caller (AbstractSimplexOptimizer.optimize)\n\n        // Save the original simplex state at the start of the iteration.\n        // Create a copy to prevent modification issues and clearly define the iteration's starting state.\n        final RealPointValuePair[] original = new RealPointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, original, 0, simplex.length);\n        final RealPointValuePair originalBest = original[0]; // Assumes simplex is sorted before this call\n\n        // --- Reflection Step ---\n        // Compute the reflected point, evaluate it, and update the simplex if it's better than the worst.\n        final RealPointValuePair reflected = evaluateNewSimplex(original, rho, comparator);\n\n        // Check if reflection improved compared to the *original* best point of this iteration.\n        if (comparator.compare(reflected, originalBest) < 0) {\n            // Reflection was successful relative to the original best.\n            // Save the state after the successful reflection.\n            final RealPointValuePair[] reflectedSimplexState = new RealPointValuePair[simplex.length];\n            System.arraycopy(simplex, 0, reflectedSimplexState, 0, simplex.length);\n            final RealPointValuePair reflectedBest = simplex[0]; // Best point in the simplex *after* reflection\n\n            // --- Expansion Step ---\n            // Try expanding from the original state.\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n            // Did expansion improve further compared to just reflection?\n            // Compare the best point after the expansion attempt (simplex[0]) vs. the best after reflection (reflectedBest).\n            if (comparator.compare(simplex[0], reflectedBest) < 0) {\n                // Yes, expansion improved further. The simplex is already in the expanded state.\n            } else {\n                // No, expansion was not better than reflection. Revert to the reflected state.\n                simplex = reflectedSimplexState;\n            }\n            // End the iteration after successful reflection/expansion.\n            return;\n        }\n\n        // --- Contraction Step ---\n        // Reflection did not improve relative to the original best. Try contraction.\n        final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n        // Check if contraction improved compared to the *original* best point.\n        // Note: Standard Nelder-Mead often compares contracted vs. reflected or worst.\n        // This follows the original code's apparent logic of comparing vs. original best.\n        if (comparator.compare(contracted, originalBest) < 0) {\n            // Contraction was successful relative to the original best. Simplex has been updated.\n            // End the iteration after successful contraction.\n            return;\n        }\n\n        // --- Shrink Step ---\n        // Neither reflection nor contraction improved relative to the original best.\n        // Shrink the simplex towards the current best point.\n        // This step was missing, causing the infinite loop.\n        final int n = simplex[0].getPointRef().length; // Dimension\n        final int N = simplex.length;     // Number of points in simplex\n\n        // Create a new array for the shrunk simplex.\n        RealPointValuePair[] shrunkSimplex = new RealPointValuePair[N];\n        // The reference point for shrinking is the current best point in the simplex.\n        final RealPointValuePair currentBest = simplex[0];\n        shrunkSimplex[0] = currentBest;\n\n        // Calculate and evaluate the shrunk points.\n        for (int i = 1; i < N; ++i) {\n            final double[] bestPt = currentBest.getPointRef();\n            final double[] currentPt = simplex[i].getPointRef(); // Use points from the current simplex\n            final double[] shrunkPt = new double[n];\n            for (int j = 0; j < n; ++j) {\n                // Shrink formula: best + sigma * (current - best)\n                shrunkPt[j] = bestPt[j] + sigma * (currentPt[j] - bestPt[j]);\n            }\n            // Evaluate the new shrunk point.\n            shrunkSimplex[i] = new RealPointValuePair(shrunkPt, evaluate(shrunkPt));\n        }\n\n        // Replace the old simplex with the new shrunk simplex.\n        simplex = shrunkSimplex;\n        // Ensure the new simplex is sorted.\n        sortSimplex(comparator);\n\n        // End the iteration after performing the shrink step.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}