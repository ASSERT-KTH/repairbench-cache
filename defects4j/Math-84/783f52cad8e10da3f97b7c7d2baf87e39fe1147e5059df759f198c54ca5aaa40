{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // Need to store the previous simplex for the convergence check at the end of each iteration.\n        RealPointValuePair[] previousSimplex = null;\n\n        while (true) {\n            // Save the current simplex state as 'previousSimplex' for the convergence check.\n            // For the first iteration, 'simplex' will be the initial configuration.\n            previousSimplex = simplex;\n\n            // Increment iteration counter and check against max iterations.\n            // This method throws MaxIterationsExceededException if the limit is hit.\n            incrementIterationsCounter();\n\n            // Get the best point from the simplex at the beginning of this iteration.\n            final RealPointValuePair best = previousSimplex[0];\n\n            // Perform a reflection step.\n            // The evaluateNewSimplex method updates 'this.simplex' and returns its new best point.\n            final RealPointValuePair reflected = evaluateNewSimplex(previousSimplex, 1.0, comparator);\n\n            // Check if the reflected point is better than the original best point.\n            if (comparator.compare(reflected, best) < 0) {\n                // Reflection was successful. Now, try an expansion step.\n                // Store the simplex resulting from the reflection step.\n                final RealPointValuePair[] reflectedSimplex = simplex;\n\n                // Compute the expanded simplex. This call will also update 'this.simplex'.\n                final RealPointValuePair expanded = evaluateNewSimplex(previousSimplex, khi, comparator);\n\n                // If the reflected point is better than or equal to the expanded point,\n                // accept the reflected simplex (revert 'this.simplex' to 'reflectedSimplex').\n                // Otherwise (expanded is better), the expanded simplex is already in 'this.simplex'.\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    simplex = reflectedSimplex;\n                }\n                // No return here; continue to the convergence check.\n            } else {\n                // Reflected point was not better than the original best point. Try a contraction step.\n                // This call also updates 'this.simplex'.\n                final RealPointValuePair contracted = evaluateNewSimplex(previousSimplex, gamma, comparator);\n\n                // If the contracted point is better than the original best point, accept it.\n                // 'this.simplex' is already updated to the contracted simplex.\n                if (comparator.compare(contracted, best) < 0) {\n                    // No return here; continue to the convergence check.\n                } else {\n                    // Neither reflection nor contraction yielded a better point than the original best.\n                    // The 'simplex' now holds the result of the (unsuccessful) contraction.\n                    // The algorithm might be stuck or have converged, which will be handled by the checkConvergence.\n                }\n            }\n\n            // After attempting reflection, and possibly expansion or contraction,\n            // check for convergence using the simplex from the beginning of the iteration\n            // and the simplex at the end of this iteration.\n            if (checkConvergence(previousSimplex, simplex)) {\n                return; // The simplex has converged, so exit the optimization loop.\n            }\n\n            // If not converged, the loop continues to the next iteration.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}