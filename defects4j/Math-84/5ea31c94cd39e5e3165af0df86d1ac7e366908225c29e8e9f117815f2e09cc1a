{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // Stores the simplex state from the previous iteration to check for convergence.\n        RealPointValuePair[] previousSimplex = null;\n\n        // Loop until convergence or maximal number of iterations is exceeded.\n        // The loop condition is the primary fix for \"MaxIterationsExceededException\".\n        while (true) {\n            incrementIterationsCounter();\n\n            // Check for convergence.\n            // This check must happen *after* incrementing and *before* starting the next iteration's work.\n            // `previousSimplex` is null on the very first iteration, so we skip the check (`getIterations() > 1`).\n            if (getIterations() > 1 && getConvergenceChecker().converged(getIterations(), previousSimplex, simplex)) {\n                return; // Optimization converged, exit loop.\n            }\n\n            // Save the current simplex state for the next iteration's convergence check.\n            // Crucial to clone to get a distinct array for comparison.\n            previousSimplex = simplex.clone();\n\n            // Store the best point from the start of this iteration for comparison.\n            final RealPointValuePair originalBest = simplex[0];\n\n            // MultiDirectional algorithm steps:\n\n            // Step 1: Reflection\n            // evaluateNewSimplex modifies 'simplex' in place by moving points away from the best.\n            // (The returned RealPointValuePair from evaluateNewSimplex is typically the best transformed point,\n            // but the primary effect is the in-place modification of the simplex array.)\n            evaluateNewSimplex(simplex, 1.0, comparator);\n            // After this, `simplex` contains the reflected points. It needs to be sorted to find the new best.\n            sort(simplex, comparator);\n\n            // Check if reflection improved the best point of the *entire simplex*.\n            if (comparator.compare(simplex[0], originalBest) < 0) {\n                // Reflection improved the simplex. Try expansion.\n                // Expansion is typically tried from the *original* simplex state for proper comparison.\n                final RealPointValuePair[] expandedSimplexCandidate = previousSimplex.clone(); // Use the stored previous state\n                evaluateNewSimplex(expandedSimplexCandidate, khi, comparator); // Modifies expandedSimplexCandidate in place\n                sort(expandedSimplexCandidate, comparator); // Sort the expanded candidate\n\n                // If the expanded simplex's best point is better than the reflected simplex's best point\n                if (comparator.compare(expandedSimplexCandidate[0], simplex[0]) < 0) {\n                    // Accept the expanded simplex.\n                    simplex = expandedSimplexCandidate;\n                }\n                // Else: Reflection is better or equal. `simplex` already holds the reflected state (from step 1), so no change needed.\n            } else {\n                // Reflection did not improve the best point significantly. Try contraction.\n                // Contraction is also tried from the *original* simplex state.\n                final RealPointValuePair[] contractedSimplexCandidate = previousSimplex.clone(); // Use the stored previous state\n                evaluateNewSimplex(contractedSimplexCandidate, gamma, comparator); // Modifies contractedSimplexCandidate in place\n                sort(contractedSimplexCandidate, comparator); // Sort the contracted candidate\n\n                // If contraction improved the best point compared to the *original* best\n                if (comparator.compare(contractedSimplexCandidate[0], originalBest) < 0) {\n                    // Accept the contracted simplex.\n                    simplex = contractedSimplexCandidate;\n                } else {\n                    // Neither reflection nor contraction improved the best point.\n                    // Perform shrinkage: move all points (except the best) towards the best point.\n                    // This is applied to the *current* simplex (which might have been slightly moved by the failed reflection).\n                    // This assumes 'sigma' (shrinkage factor, typically 0.5) is available as a class field or can be used as a literal.\n                    // In Apache Commons Math, MultiDirectional uses a coefficient of 0.5 for shrinkage.\n                    evaluateNewSimplex(simplex, 0.5, comparator); // Assuming sigma = 0.5\n                    sort(simplex, comparator); // Sort after shrinkage.\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}