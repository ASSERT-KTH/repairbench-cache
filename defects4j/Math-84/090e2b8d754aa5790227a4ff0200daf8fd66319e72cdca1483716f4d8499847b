{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n            incrementIterationsCounter();\n\n            // save the original vertex state for reference\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0]; // The best point in the simplex\n\n            // 1. Perform a reflection step\n            // evaluateNewSimplex updates 'this.simplex' with the reflected simplex\n            // and returns the point that replaced the worst.\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n\n            // Check if the reflected point is better than the original best point\n            if (comparator.compare(reflected, best) < 0) {\n                // Reflection was successful: reflected point is better than original best\n\n                // Store the simplex after reflection\n                final RealPointValuePair[] reflectedSimplex = simplex; // 'simplex' is now the reflected simplex\n\n                // 2. Compute the expanded simplex (from original, as per MultiDirectional algorithm behavior)\n                // This call will update 'this.simplex' again, now to the expanded simplex.\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n\n                // Compare the reflected point with the expanded point\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // Reflected point is better than or equal to the expanded point.\n                    // Accept the reflected simplex: revert 'this.simplex' to the reflected state.\n                    simplex = reflectedSimplex;\n                }\n                // Else (expanded point is better than reflected point), 'this.simplex' already holds the expanded simplex, so nothing to do.\n\n            } else {\n                // Reflection was not successful (reflected point is not better than original best)\n\n                // 3. Compute the contracted simplex (from original)\n                // This call will update 'this.simplex' to the contracted simplex.\n                final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n\n                // Check if the contracted point is better than the original best point\n                if (comparator.compare(contracted, best) < 0) {\n                    // Contraction was successful: contracted point is better than original best\n                    // 'this.simplex' already holds the contracted simplex.\n                } else {\n                    // Neither reflection nor contraction improved the simplex significantly.\n                    // 4. Perform a shrink step.\n                    // Move all points (except the best) towards the best point.\n                    // The best point is `original[0]`.\n                    final RealPointValuePair[] newSimplex = new RealPointValuePair[original.length];\n                    newSimplex[0] = best; // Best point remains unchanged\n\n                    for (int i = 1; i < original.length; i++) {\n                        final double[] p = original[i].getPoint();\n                        final double[] ref = best.getPoint();\n                        final double[] newPoint = new double[getN()]; // getN() gets dimension\n                        for (int j = 0; j < getN(); j++) {\n                            newPoint[j] = ref[j] + sigma * (p[j] - ref[j]);\n                        }\n                        // Create new point pair with value NaN; its value will be evaluated by evaluateSimplex\n                        newSimplex[i] = new RealPointValuePair(newPoint, Double.NaN);\n                    }\n                    // Evaluate the new points for the shrunk simplex and sort it.\n                    simplex = evaluateSimplex(newSimplex, comparator);\n                }\n            }\n\n            // After any simplex transformation (or lack thereof), check for convergence.\n            // The 'checker' field is inherited from AbstractDirectOptimizer.\n            if (this.checker.converged(simplex)) {\n                return; // Converged, exit the method.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}