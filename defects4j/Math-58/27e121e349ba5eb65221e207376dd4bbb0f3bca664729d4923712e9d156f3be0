{
    "generation": "/**\n * Fits a Gaussian function to the observed points.\n *\n * @return the parameters of the Gaussian function that best fits the\n * observed points (in the same order as above).\n */\npublic double[] fit() {\n    // compute an initial guess for [norm, mean, sigma]\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    // the \"true\" Gaussian function that may throw on sigma<=0\n    final ParametricUnivariateRealFunction gauss = new Gaussian.Parametric();\n    // wrap it so that any NotStrictlyPositiveException is caught\n    // and converted to NaN, allowing the optimizer to continue\n    ParametricUnivariateRealFunction safeGauss =\n        new ParametricUnivariateRealFunction() {\n            public double value(double x, double[] p) {\n                try {\n                    return gauss.value(x, p);\n                } catch (NotStrictlyPositiveException ex) {\n                    return Double.NaN;\n                }\n            }\n            public double[] gradient(double x, double[] p) {\n                try {\n                    return gauss.gradient(x, p);\n                } catch (NotStrictlyPositiveException ex) {\n                    double[] g = new double[p.length];\n                    for (int i = 0; i < g.length; i++) {\n                        g[i] = Double.NaN;\n                    }\n                    return g;\n                }\n            }\n        };\n    return fit(safeGauss, guess);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}