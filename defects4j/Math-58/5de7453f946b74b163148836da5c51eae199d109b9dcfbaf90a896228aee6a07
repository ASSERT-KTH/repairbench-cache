{
    "generation": "    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        // Transform sigma to log space to ensure positivity during optimization\n        double[] transformedGuess = new double[] { guess[0], guess[1], Math.log(guess[2]) };\n\n        ParametricMultivariateRealFunction transformedParametric = new ParametricMultivariateRealFunction() {\n            private final Gaussian.Parametric original = new Gaussian.Parametric();\n\n            @Override\n            public double value(double x, double[] parameters) {\n                double sigma = Math.exp(parameters[2]);\n                return original.value(x, new double[] { parameters[0], parameters[1], sigma });\n            }\n\n            @Override\n            public double[] gradient(double x, double[] parameters) {\n                double sigma = Math.exp(parameters[2]);\n                double[] originalGradient = original.gradient(x, new double[] { parameters[0], parameters[1], sigma });\n                double dlogSigma = originalGradient[2] * sigma;\n                return new double[] { originalGradient[0], originalGradient[1], dlogSigma };\n            }\n        };\n\n        double[] transformedParams = fit(transformedParametric, transformedGuess);\n        return new double[] { transformedParams[0], transformedParams[1], Math.exp(transformedParams[2]) };\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}