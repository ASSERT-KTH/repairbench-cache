{
    "generation": "    /**\n     * Fits a Gaussian function to the observed points.\n     *\n     * @return the parameters of the Gaussian function that best fits the\n     * observed points (in the same order as above).\n     */\n    public double[] fit() {\n        // wrap the Gaussian.Parametric so that any non\u2010positive sigma\n        // doesn\u2019t throw but returns NaN, allowing the optimizer to reject\n        // those trial steps rather than aborting outright\n        final Gaussian.Parametric base = new Gaussian.Parametric();\n        final ParametricUnivariateRealFunction safe =\n            new ParametricUnivariateRealFunction() {\n                public double value(double x, double[] p) {\n                    try {\n                        return base.value(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        return Double.NaN;\n                    }\n                }\n                public double[] gradient(double x, double[] p) {\n                    try {\n                        return base.gradient(x, p);\n                    } catch (NotStrictlyPositiveException e) {\n                        double[] g = new double[p.length];\n                        for (int i = 0; i < g.length; i++) {\n                            g[i] = Double.NaN;\n                        }\n                        return g;\n                    }\n                }\n            };\n        final double[] guess = new ParameterGuesser(getObservations()).guess();\n        return fit(safe, guess);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}