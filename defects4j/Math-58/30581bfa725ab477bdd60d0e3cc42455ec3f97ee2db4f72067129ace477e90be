{
    "generation": "/**\n * Fits a Gaussian function to the observed points, re\u2010parameterizing \u03c3 = exp(s)\n * so that during optimization \u03c3 never becomes non\u2010positive.\n *\n * @return the parameters [amplitude, mean, sigma] of the best\u2010fit Gaussian.\n */\npublic double[] fit() {\n    // 1) get the usual [A, \u03bc, \u03c3] initial guess\n    final double[] guess = new ParameterGuesser(getObservations()).guess();\n\n    // 2) reparameterize \u03c3 \u2192 s = ln(\u03c3)\n    guess[2] = Math.log(guess[2]);\n\n    // 3) wrap the Gaussian so that the optimizer works in [A, \u03bc, s] space\n    final ParametricRealFunction logSpaceGaussian = new ParametricRealFunction() {\n        private final Gaussian.Parametric base = new Gaussian.Parametric();\n\n        @Override\n        public double value(double x, double[] p) {\n            // p = [A, \u03bc, s], we recover \u03c3 = e^s\n            double sigma = Math.exp(p[2]);\n            return base.value(x, new double[] { p[0], p[1], sigma });\n        }\n\n        @Override\n        public double[] gradient(double x, double[] p) {\n            // base.gradient gives [\u2202/\u2202A, \u2202/\u2202\u03bc, \u2202/\u2202\u03c3]\n            double sigma = Math.exp(p[2]);\n            double[] g = base.gradient(x, new double[] { p[0], p[1], sigma });\n            // chain\u2010rule: \u2202/\u2202s = (\u2202\u03c3/\u2202s)\u00b7(\u2202/\u2202\u03c3) = \u03c3\u00b7(\u2202/\u2202\u03c3)\n            return new double[] { g[0], g[1], g[2] * sigma };\n        }\n    };\n\n    // 4) run the fitter in [A, \u03bc, s] space\n    double[] sol = fit(logSpaceGaussian, guess);\n\n    // 5) transform the final s back to \u03c3\n    sol[2] = Math.exp(sol[2]);\n    return sol;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}