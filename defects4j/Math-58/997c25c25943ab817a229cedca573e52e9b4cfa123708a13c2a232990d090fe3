{
    "generation": "/**\n * Fits a Gaussian function to the observed points.\n *\n * @return the parameters of the Gaussian function that best fits the\n * observed points (in the same order as above).\n */\npublic double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n    // wrap the Gaussian.Parametric to catch non\u2010positive sigma exceptions\n    final Gaussian.Parametric original = new Gaussian.Parametric();\n    ParametricUnivariateRealFunction safeFunc = new ParametricUnivariateRealFunction() {\n        @Override\n        public double value(double x, double... p) {\n            try {\n                return original.value(x, p);\n            } catch (org.apache.commons.math.exception.NotStrictlyPositiveException e) {\n                // if sigma <= 0, signal an invalid evaluation\n                return Double.NaN;\n            }\n        }\n        @Override\n        public double[] gradient(double x, double... p) {\n            try {\n                return original.gradient(x, p);\n            } catch (org.apache.commons.math.exception.NotStrictlyPositiveException e) {\n                // if sigma <= 0, signal invalid derivatives\n                double[] nanGrad = new double[p.length];\n                for (int i = 0; i < nanGrad.length; i++) {\n                    nanGrad[i] = Double.NaN;\n                }\n                return nanGrad;\n            }\n        }\n    };\n    return fit(safeFunc, guess);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}