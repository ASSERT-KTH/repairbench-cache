{
    "generation": "@Override\nprotected double doSolve() {\n\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n    verifySequence(x[0], x[1], x[2]);\n\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, 1)) {\n        return x[1];\n    }\n\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, 1)) {\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n        nbPoints = 2;\n        signChangeIndex = 1;\n    } else {\n        y[2] = computeObjectiveValue(x[2]);\n        if (Precision.equals(y[2], 0.0, 1)) {\n            return x[2];\n        }\n\n        if (y[1] * y[2] < 0) {\n            nbPoints = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n        }\n    }\n\n    final double[] tmpX = new double[x.length];\n    double xA = x[signChangeIndex - 1];\n    double yA = y[signChangeIndex - 1];\n    double absYA = FastMath.abs(yA);\n    double xB = x[signChangeIndex];\n    double yB = y[signChangeIndex];\n    double absYB = FastMath.abs(yB);\n    int agingA = 0, agingB = 0;\n\n    while (true) {\n\n        final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n                case ANY_SIDE: return absYA < absYB ? xA : xB;\n                case LEFT_SIDE: return xA;\n                case RIGHT_SIDE: return xB;\n                case BELOW_SIDE: return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE: return (yA < 0) ? xB : xA;\n                default: throw new MathInternalError(null);\n            }\n        }\n\n        double targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            targetY = -REDUCTION_FACTOR * yB;\n        } else if (agingB >= MAXIMAL_AGING) {\n            targetY = -REDUCTION_FACTOR * yA;\n        } else {\n            targetY = 0;\n        }\n\n        double nextX;\n        int start = 0;\n        int end = nbPoints;\n        boolean valid = isValid(xA, xB, yA, yB, targetY);\n        do {\n\n            if (valid) {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n            } else {\n                nextX = Double.NaN;\n            }\n\n            if (!(nextX > xA && nextX < xB)) {\n\n                if (Double.isNaN(nextX) && end - start > 1) {\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        ++start;\n                    } else {\n                        --end;\n                    }\n                    if (end - start > 1) {\n                        valid = isValid(x[start], x[end - 1], y[start], y[end - 1], targetY);\n                    }\n                }\n\n                nextX = Double.NaN;\n            }\n\n        } while (Double.isNaN(nextX) && (end - start > 1));\n\n        if (Double.isNaN(nextX)) {\n            nextX = xA + 0.5 * (xB - xA);\n            start = signChangeIndex - 1;\n            end = signChangeIndex;\n        }\n\n        final double nextY = computeObjectiveValue(nextX);\n        if (Precision.equals(nextY, 0.0, 1)) {\n            return nextX;\n        }\n\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n        } else if (nbPoints == x.length) {\n            nbPoints--;\n            if (signChangeIndex >= (x.length + 1) / 2) {\n                System.arraycopy(x, 1, x, 0, nbPoints);\n                System.arraycopy(y, 1, y, 0, nbPoints);\n                --signChangeIndex;\n            }\n        }\n\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n        x[signChangeIndex] = nextX;\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n        y[signChangeIndex] = nextY;\n        ++nbPoints;\n\n        if (nextY * yA <= 0) {\n            xB = nextX;\n            yB = nextY;\n            absYB = FastMath.abs(yB);\n            ++agingA;\n            agingB = 0;\n        } else {\n            xA = nextX;\n            yA = nextY;\n            absYA = FastMath.abs(yA);\n            agingA = 0;\n            ++agingB;\n            signChangeIndex++;\n        }\n    }\n}\n\nprivate boolean isValid(final double xA, final double xB, final double yA, final double yB, final double targetY) {\n    final double min = FastMath.min(xA, xB);\n    final double max = FastMath.max(xA, xB);\n\n    return FastMath.abs(targetY) * MAX.norms(yA, yB, FastMath.abs(targetY)) >=\n           (MAX(norms(xA, targetY, FastMath.abs(yA)), norms(xB, targetY, FastMath.abs(yB))));\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}