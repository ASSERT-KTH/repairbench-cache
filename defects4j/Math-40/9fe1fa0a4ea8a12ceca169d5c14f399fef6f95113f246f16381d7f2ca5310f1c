{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() throws TooManyEvaluationsException, NoBracketingException {\n\n        // prepare arrays with the first points\n        final int maximalOrder = getMaximalOrder(); // Use getter\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n\n        // Get solver settings from abstract class\n        final AllowedSolution allowed = getAllowedSolutions();\n        final int MAXIMAL_AGING = 2;        // From class constant (assuming it's 2)\n        final double REDUCTION_FACTOR = 0.5; // From class constant (assuming it's 0.5)\n\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                case ANY_SIDE :\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return (yA <= 0) ? xA : xB;\n                case ABOVE_SIDE :\n                    return (yA <  0) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            double targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // guess a value for current target, using inverse polynomial interpolation\n            double nextX;\n            int start = 0; // Use all available points for interpolation attempt\n            int end   = nbPoints;\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end); // Assume guessX exists and is correct\n\n            // Check if the guess is valid and strictly within the tightest current bracket.\n            if (Double.isNaN(nextX) || !(nextX > xA && nextX < xB)) {\n                // The guessed root is not strictly inside of the tightest bracketing interval,\n                // or the guess is NaN (e.g., due to duplicate y-values).\n                // Fall back to bisection.\n                nextX = xA + 0.5 * (xB - xA);\n                // Reset start/end to invalid state to indicate bisection was chosen\n                // This prevents the point-dropping logic triggered by start/end changes.\n                start = -1;\n                end = -1;\n            }\n\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            // If the interpolation attempt reduced the number of points used (start/end modified),\n            // drop the unused points from the main arrays.\n            // NOTE: With the fix above (falling back to bisection immediately), this block\n            // should ideally not be needed unless guessX itself modifies start/end internally\n            // upon success but using fewer points (which is unlikely). Kept for safety.\n            if (start != -1 && (nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else if (nbPoints == x.length) {\n                 // The array is full, we have to drop one point to insert the new one.\n                 nbPoints--;\n\n                // Keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n                // else: drop the highest point (implicitly done by the insertion logic below)\n            }\n\n            // insert the last computed point\n            // (by construction, we know it lies inside the tightest bracketing interval (xA, xB)\n            // or is the bisection point). Insert it at the correct sorted position.\n            // The original code inserts at signChangeIndex, which is correct as\n            // xA = x[signChangeIndex-1] and xB = x[signChangeIndex], and nextX is between xA and xB.\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            // Increment number of points *after* potential drop and insertion\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs between xA and nextX\n                xB = nextX;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                ++agingA;\n                agingB = 0;\n                // signChangeIndex remains the index of the new xB\n            } else {\n                // the sign change occurs between nextX and xB (as yA and yB have opposite signs)\n                xA = nextX;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                ++agingB;\n                // update the sign change index, as xA is now at the old signChangeIndex position\n                signChangeIndex++;\n            }\n        } // end search loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}