{
    "generation": "/**\n * {@inheritDoc}\n */\n@Override\nprotected double doSolve() {\n\n    // prepare arrays with the first points\n    final double[] x = new double[maximalOrder + 1];\n    final double[] y = new double[maximalOrder + 1];\n    x[0] = getMin();\n    x[1] = getStartValue();\n    x[2] = getMax();\n    verifySequence(x[0], x[1], x[2]);\n\n    // evaluate initial guess\n    y[1] = computeObjectiveValue(x[1]);\n    if (Precision.equals(y[1], 0.0, 1)) {\n        // return the initial guess if it is a perfect root.\n        return x[1];\n    }\n\n    // evaluate first  endpoint\n    y[0] = computeObjectiveValue(x[0]);\n    if (Precision.equals(y[0], 0.0, 1)) {\n        // return the first endpoint if it is a perfect root.\n        return x[0];\n    }\n\n    int nbPoints;\n    int signChangeIndex;\n    if (y[0] * y[1] < 0) {\n\n        // reduce interval if it brackets the root\n        nbPoints        = 2;\n        signChangeIndex = 1;\n\n    } else {\n\n        // evaluate second endpoint\n        y[2] = computeObjectiveValue(x[2]);\n        if (Precision.equals(y[2], 0.0, 1)) {\n            // return the second endpoint if it is a perfect root.\n            return x[2];\n        }\n\n        if (y[1] * y[2] < 0) {\n            // use all computed point as a start sampling array for solving\n            nbPoints        = 3;\n            signChangeIndex = 2;\n        } else {\n            throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n        }\n\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] tmpX = new double[x.length];\n\n    // current tightest bracketing of the root\n    double xA    = x[signChangeIndex - 1];\n    double yA    = y[signChangeIndex - 1];\n    double absYA = FastMath.abs(yA);\n    int agingA   = 0;\n    double xB    = x[signChangeIndex];\n    double yB    = y[signChangeIndex];\n    double absYB = FastMath.abs(yB);\n    int agingB   = 0;\n\n    // search loop\n    while (true) {\n\n        // check convergence of bracketing interval\n        final double xTol = getAbsoluteAccuracy() +\n                            getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n            case ANY_SIDE :\n                return absYA < absYB ? xA : xB;\n            case LEFT_SIDE :\n                return xA;\n            case RIGHT_SIDE :\n                return xB;\n            case BELOW_SIDE :\n                return (yA <= 0) ? xA : xB;\n            case ABOVE_SIDE :\n                return (yA <  0) ? xB : xA;\n            default :\n                // this should never happen\n                throw new MathInternalError(null);\n            }\n        }\n\n        // target for the next evaluation point\n        double targetY;\n        if (agingA >= MAXIMAL_AGING) {\n            // we keep updating the high bracket, try to compensate this\n            targetY = -REDUCTION_FACTOR * yB;\n        } else if (agingB >= MAXIMAL_AGING) {\n            // we keep updating the low bracket, try to compensate this\n            targetY = -REDUCTION_FACTOR * yA;\n        } else {\n            // bracketing is balanced, try to find the root itself\n            targetY = 0;\n        }\n\n        // make a few attempts to guess a root,\n        double nextX;\n        int start = 0;\n        int end   = nbPoints;\n        boolean valid = false;\n        do {\n\n            // guess a value for current target, using inverse polynomial interpolation\n            System.arraycopy(x, start, tmpX, start, end - start);\n            nextX = guessX(targetY, tmpX, y, start, end);\n\n            if (Double.isNaN(nextX)) {\n                // guessX failed, lower the interpolation order\n                if (signChangeIndex - start >= end - signChangeIndex) {\n                    ++start;\n                } else {\n                    --end;\n                }\n                continue;\n            }\n\n            // allow convergence to the end points if the function value at that point matches targetY\n            // This is the patch: if we're failing to get in (xA, xB), allow endpoints if their f value == targetY\n            if (!((nextX > xA) && (nextX < xB))) {\n\n                boolean accept = false;\n                if (Precision.equals(targetY, 0.0, 1)) {\n                    // If we are targeting zero, check if endpoints are exactly root according to desired precision\n                    if (Precision.equals(yA, 0.0, 1) && Precision.equals(nextX, xA, 2)) {\n                        nextX = xA;\n                        accept = true;\n                    } else if (Precision.equals(yB, 0.0, 1) && Precision.equals(nextX, xB, 2)) {\n                        nextX = xB;\n                        accept = true;\n                    }\n                } else {\n                    // If we are targeting yA/yB, also allow to land on endpoint if that matches targetY\n                    if (Precision.equals(yA, targetY, 1) && Precision.equals(nextX, xA, 2)) {\n                        nextX = xA;\n                        accept = true;\n                    } else if (Precision.equals(yB, targetY, 1) && Precision.equals(nextX, xB, 2)) {\n                        nextX = xB;\n                        accept = true;\n                    }\n                }\n                if (!accept) {\n                    // the guessed root is either not strictly inside the tightest bracketing interval or NaN\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n                    nextX = Double.NaN; // force another attempt\n                } else {\n                    valid = true;\n                }\n            } else {\n                valid = true;\n            }\n\n        } while (!valid && (end - start > 1));\n\n        if (Double.isNaN(nextX)) {\n            // fall back to bisection\n            nextX = xA + 0.5 * (xB - xA);\n            start = signChangeIndex - 1;\n            end   = signChangeIndex;\n        }\n\n        // evaluate the function at the guessed root\n        final double nextY = computeObjectiveValue(nextX);\n        if (Precision.equals(nextY, 0.0, 1)) {\n            // we have found an exact root, since it is not an approximation\n            // we don't need to bother about the allowed solutions setting\n            return nextX;\n        }\n\n        if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n            // we have been forced to ignore some points to keep bracketing,\n            // they are probably too far from the root, drop them from now on\n            nbPoints = end - start;\n            System.arraycopy(x, start, x, 0, nbPoints);\n            System.arraycopy(y, start, y, 0, nbPoints);\n            signChangeIndex -= start;\n\n        } else  if (nbPoints == x.length) {\n\n            // we have to drop one point in order to insert the new one\n            nbPoints--;\n\n            // keep the tightest bracketing interval as centered as possible\n            if (signChangeIndex >= (x.length + 1) / 2) {\n                // we drop the lowest point, we have to shift the arrays and the index\n                System.arraycopy(x, 1, x, 0, nbPoints);\n                System.arraycopy(y, 1, y, 0, nbPoints);\n                --signChangeIndex;\n            }\n\n        }\n\n        // insert the last computed point\n        //(by construction, we know it lies inside the tightest bracketing interval)\n        System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n        x[signChangeIndex] = nextX;\n        System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n        y[signChangeIndex] = nextY;\n        ++nbPoints;\n\n        // update the bracketing interval\n        if (nextY * yA <= 0) {\n            // the sign change occurs before the inserted point\n            xB = nextX;\n            yB = nextY;\n            absYB = FastMath.abs(yB);\n            ++agingA;\n            agingB = 0;\n        } else {\n            // the sign change occurs after the inserted point\n            xA = nextX;\n            yA = nextY;\n            absYA = FastMath.abs(yA);\n            agingA = 0;\n            ++agingB;\n\n            // update the sign change index\n            signChangeIndex++;\n\n        }\n\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}