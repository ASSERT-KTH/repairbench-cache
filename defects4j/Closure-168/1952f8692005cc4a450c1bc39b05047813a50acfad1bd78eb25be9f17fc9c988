{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      // Record non-empty returns for the function being traversed.\n      if (n.isReturn() && n.getFirstChild() != null) {\n        FunctionAnalysisData functionData = data.get(t.getScopeRoot());\n        // functionData might be null if this function is defined in the global scope\n        // or within a function that itself is not analyzed (e.g., depth <= 2 filter below).\n        if (functionData != null) {\n            functionData.recordNonEmptyReturn();\n        }\n      }\n\n      // This analysis is specifically interested in variable usage within\n      // scopes deeper than the immediate function scope (e.g., inner functions, depth >= 3).\n      // It analyzes how variables defined in outer scopes (like depth 2) are used.\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        // We also skip the top-level function scope (depth 2) itself, focusing on\n        // nodes *within* deeper scopes.\n        return;\n      }\n\n      // Handle NAME nodes (variable access or assignment) in inner scopes (depth >= 3)\n      if (n.isName()) {\n        String name = n.getString();\n        Scope currentScope = t.getScope(); // The inner scope (depth >= 3)\n        Var var = currentScope.getVar(name);\n\n        // Ensure the name resolves to a variable in the scope chain.\n        if (var != null) {\n          Scope ownerScope = var.getScope(); // The scope where 'var' was declared.\n\n          // We only care about variables declared in local scopes (not global/extern).\n          if (ownerScope.isLocal()) {\n            Node ownerRoot = ownerScope.getRootNode();\n            FunctionAnalysisData ownerData = data.get(ownerRoot);\n\n            // ownerData would be null if the ownerScope corresponds to a function\n            // that isn't being analyzed (e.g., global scope functions if the pass\n            // only runs on specific functions, or potentially very deeply nested scopes\n            // depending on pass configuration). Assume relevant ownerData exists.\n            if (ownerData != null) {\n                // Record assignment if it's an L-value assignment to a local variable.\n                // This helps track variables that are assigned multiple times.\n                // We check !isBleedingFunctionName because function declarations create\n                // variables in their containing scope, not the current scope.\n                if (NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) {\n                   ownerData.recordAssignedName(name);\n                }\n\n                // Record variable escape if a local variable defined in an outer scope\n                // is accessed (read or written) within the current inner scope.\n                if (currentScope != ownerScope) {\n                   ownerData.recordEscapedVarName(name);\n                }\n            }\n          }\n        }\n      // Handle assignments to qualified names (e.g., obj.prop = ...) where the base object\n      // might be an escaped local variable.\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n        // Check assignments like localVar.property = value; inside an inner function\n        String rootName = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope currentScope = t.getScope(); // The inner scope (depth >= 3)\n        Var var = currentScope.getVar(rootName);\n\n        // Ensure the base name resolves to a variable.\n        if (var != null) {\n          Scope ownerScope = var.getScope(); // Scope where the base variable was declared.\n\n          // Check if the base variable is local and the assignment occurs in a different scope.\n          if (ownerScope.isLocal() && currentScope != ownerScope) {\n            Node ownerRoot = ownerScope.getRootNode();\n            FunctionAnalysisData ownerData = data.get(ownerRoot);\n             // Record the qualified name escape if the owner scope's data exists.\n            if (ownerData != null) {\n                ownerData.recordEscapedQualifiedName(n.getQualifiedName());\n            }\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}