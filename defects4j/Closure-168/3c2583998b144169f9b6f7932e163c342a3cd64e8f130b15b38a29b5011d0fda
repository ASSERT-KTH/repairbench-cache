{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n        if (t.inGlobalScope()) {\n            return;\n        }\n\n        if (n.isReturn() && n.getFirstChild() != null) {\n            data.get(t.getScopeRoot()).recordNonEmptyReturn();\n        }\n\n        if (t.getScopeDepth() <= 2) {\n            return;\n        }\n\n        if (n.isName() && NodeUtil.isLValue(n) &&\n            !NodeUtil.isBleedingFunctionName(n)) {\n            String name = n.getString();\n            Scope scope = t.getScope();\n            Var var = scope.getVar(name);\n            if (var != null) {\n                Scope ownerScope = var.getScope();\n                if (ownerScope.isLocal()) {\n                    data.get(ownerScope.getRootNode()).recordAssignedName(name);\n                }\n\n                if (scope != ownerScope && ownerScope.isLocal()) {\n                    if (!var.isThisParam()) { // Fix: Ignore \"this\" variables to avoid false positives\n                        data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n                    }\n                }\n            }\n        } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n            NodeUtil.isLValue(n)) {\n            String name = NodeUtil.getRootOfQualifiedName(n).getString();\n            Scope scope = t.getScope();\n            Var var = scope.getVar(name);\n            if (var != null) {\n                Scope ownerScope = var.getScope();\n                if (scope != ownerScope && ownerScope.isLocal()) {\n                    if (!var.isThisParam()) { // Fix: Ignore \"this\" variables for qualified names as well\n                        data.get(ownerScope.getRootNode())\n                            .recordEscapedQualifiedName(n.getQualifiedName());\n                    }\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}