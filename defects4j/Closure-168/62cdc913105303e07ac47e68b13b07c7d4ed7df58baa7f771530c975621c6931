{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Skip global scope\n      if (t.inGlobalScope()) { // depth 0\n        return;\n      }\n\n      // Record non-empty returns for the function represented by the scope root\n      if (n.isReturn() && n.getFirstChild() != null) {\n        FunctionInformation fnInfo = data.get(t.getScopeRoot());\n        // Ensure fnInfo is not null, might happen for non-function scope roots?\n        if (fnInfo != null) {\n           fnInfo.recordNonEmptyReturn();\n        }\n      }\n\n      // Skip analysis for top-level functions/scopes (depth 1).\n      // We only care about accesses within nested scopes (depth 2+).\n      // The original check t.getScopeDepth() <= 2 skipped depth 2, where\n      // escaped variable access typically occurs in the first level of nesting.\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      // Analyze local variable accesses (reads and writes)\n      if (n.isName()) {\n        String name = n.getString();\n        Scope scope = t.getScope(); // The current scope where 'n' is accessed\n        Var var = scope.getVar(name);\n\n        // Check if 'name' resolves to a variable and it's declared in a local scope\n        if (var != null && var.isLocal()) {\n          Scope ownerScope = var.getScope(); // The scope where 'var' is declared\n          // Bleeding functions can have a null scope.\n          if (ownerScope == null) {\n              return;\n          }\n          Node ownerRoot = ownerScope.getRootNode();\n          // Scope root could be null if scope is detached\n          if (ownerRoot == null) {\n              return;\n          }\n          FunctionInformation fnInfo = data.get(ownerRoot);\n\n          // Should not be null if ownerScope.isLocal() is true and ownerRoot is valid,\n          // but check defensively\n          if (fnInfo != null) {\n            // Record assignment if it's an LValue assigned within its declaring scope\n            // or an inner scope, and not a bleeding function name.\n            if (NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) {\n               fnInfo.recordAssignedName(name);\n            }\n\n            // Record escape if 'name' is accessed (read or write) in a scope\n            // different from (and nested within) its declaring scope.\n            // The original code only checked for LValues here. Reads must also\n            // be considered for escaped variables.\n            if (scope != ownerScope && scope.isDescendantOf(ownerScope)) {\n               fnInfo.recordEscapedVarName(name);\n            }\n          }\n        }\n      }\n      // Analyze assignments to qualified names based on local variables\n      else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n        Node root = NodeUtil.getRootOfQualifiedName(n);\n        // Ensure root is a NAME node before getting string\n        if (root.isName()) {\n            String name = root.getString();\n            Scope scope = t.getScope(); // Current scope where assignment occurs\n            Var var = scope.getVar(name);\n\n            // Check if the base 'name' is a local variable\n            if (var != null && var.isLocal()) {\n              Scope ownerScope = var.getScope(); // Scope where base var is declared\n              // Bleeding functions can have a null scope.\n              if (ownerScope == null) {\n                  return;\n              }\n              Node ownerRoot = ownerScope.getRootNode();\n              // Scope root could be null if scope is detached\n              if (ownerRoot == null) {\n                  return;\n              }\n              FunctionInformation fnInfo = data.get(ownerRoot);\n\n              if (fnInfo != null) {\n                // Record escape of the qualified name if assignment happens in a\n                // scope different from (and nested within) the base variable's scope.\n                if (scope != ownerScope && scope.isDescendantOf(ownerScope)) {\n                  fnInfo.recordEscapedQualifiedName(n.getQualifiedName());\n                }\n              }\n            }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}