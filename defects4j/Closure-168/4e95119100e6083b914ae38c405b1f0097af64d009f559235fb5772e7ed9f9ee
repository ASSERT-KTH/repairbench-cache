{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // 1. Initial checks and non-empty return recording\n      if (t.inGlobalScope()) {\n        return;\n      }\n      if (n.isReturn() && n.getFirstChild() != null) {\n        // Note: t.getScopeRoot() should be used carefully. If 'n' is inside\n        // a nested function, this might record the return for the outer function.\n        // However, assuming this pass analyzes one function at a time,\n        // t.getScopeRoot() would correspond to the function being analyzed.\n        // Let's trust the existing logic here for now.\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // 2. Scope depth check (Only analyze escapes into inner functions)\n      // Scope depth 1 = global, 2 = top-level function/script\n      // Inner functions start at depth 3. We care about refs in depth 3+\n      // to variables declared at depth 2 or outer function scopes.\n      if (t.getScopeDepth() <= 2) {\n        // The comment mentions \"first-order function analyzer\". This pass might be\n        // specifically looking for variables from the immediate outer scope (depth 2)\n        // being used in the first level of inner scopes (depth 3).\n        // Regardless, the logic for detecting escapes needs to consider reads.\n        return;\n      }\n\n      // 3. Analyze NAME and GETPROP nodes for escapes\n      Var var = null;\n      Scope scope = t.getScope(); // Scope of the reference/assignment\n      Scope ownerScope = null;    // Scope where the variable is defined\n      String varName = null;\n      boolean isLValue = NodeUtil.isLValue(n);\n      Node ownerRoot = null; // Cache the owner scope's root node\n\n      // Check NAME nodes\n      if (n.isName()) {\n        // Bleeding functions are declared in the *inner* scope, skip.\n        if (NodeUtil.isBleedingFunctionName(n)) {\n            return;\n        }\n        varName = n.getString();\n        var = scope.getVar(varName);\n        if (var != null) {\n            ownerScope = var.getScope();\n        }\n      }\n      // Check GETPROP nodes (base must be a NAME)\n      else if (n.isGetProp() && n.isUnscopedQualifiedName()) {\n        Node root = NodeUtil.getRootOfQualifiedName(n);\n        // Ensure the base of the qualified name is a simple variable name\n        if (root != null && root.isName()) {\n          varName = root.getString();\n          var = scope.getVar(varName);\n          if (var != null) {\n              ownerScope = var.getScope();\n          }\n        }\n      }\n\n      // 4. If we identified a variable reference (var != null) defined in a local scope...\n      if (var != null && ownerScope != null && ownerScope.isLocal()) {\n        ownerRoot = ownerScope.getRootNode();\n\n        // Record assignment if it's a NAME node being assigned to\n        if (n.isName() && isLValue) {\n          // Record that the variable was assigned somewhere in the function.\n          data.get(ownerRoot).recordAssignedName(varName);\n        }\n\n        // If the reference/assignment scope is different from the owner scope,\n        // it means the variable is potentially escaping its original scope.\n        if (scope != ownerScope) {\n          // Mark the variable as escaped because it's referenced from an inner scope.\n          // This applies to both reads and writes in the inner scope.\n          data.get(ownerRoot).recordEscapedVarName(varName);\n\n          // Additionally, if assigning to an escaped qualified name (e.g., outerVar.prop = ...)\n          // record the qualified name specifically. This was in the original code.\n          if (n.isGetProp() && isLValue) {\n             data.get(ownerRoot)\n                 .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}