{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // CHANGE 1: Only skip global scope (depth 1). The original check\n      // (t.getScopeDepth() <= 2) prevented analysis in top-level functions,\n      // potentially missing escape information needed for type checking nested\n      // functions, as seen in testIssue726.\n      if (t.getScopeDepth() <= 1) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // No early exit for depth 2 anymore\n\n      // Handle NAME nodes\n      if (n.isName()) {\n        // LValue case (Assignment)\n        if (NodeUtil.isLValue(n) &&\n            // Be careful of bleeding functions, which create variables\n            // in the inner scope, not the scope where the name appears.\n            !NodeUtil.isBleedingFunctionName(n)) {\n          String name = n.getString();\n          Scope scope = t.getScope();\n          Var var = scope.getVar(name);\n          if (var != null) {\n            Scope ownerScope = var.getScope();\n            // Record assignment only if the variable is local to some function scope.\n            if (ownerScope.isLocal()) {\n              data.get(ownerScope.getRootNode()).recordAssignedName(name);\n            }\n            // If assignment happens in a scope different from the declaration scope,\n            // and the variable is local, record it as escaped.\n            if (scope != ownerScope && ownerScope.isLocal()) {\n              data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n            }\n          }\n        } else { // RValue case (Use)\n          // CHANGE 2: Record escape if a local variable is *used* (read)\n          // in a scope different from its declaration scope. This is crucial\n          // for tracking variables like 'self' in testIssue726 that alias 'this'\n          // and are used in inner functions.\n          String name = n.getString();\n          Scope scope = t.getScope();\n          Var var = scope.getVar(name);\n          if (var != null) {\n            Scope ownerScope = var.getScope();\n            // If used in a scope different from its definition and is local, mark as escaped.\n            if (scope != ownerScope && ownerScope.isLocal()) {\n               data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n            }\n          }\n        }\n      }\n      // Handle GETPROP nodes (Assignments like obj.prop = x and Uses like obj.prop())\n      else if (n.isGetProp() && n.isUnscopedQualifiedName()) {\n          String rootName = NodeUtil.getRootOfQualifiedName(n).getString();\n          Scope scope = t.getScope();\n          Var var = scope.getVar(rootName);\n          if (var != null) {\n              Scope ownerScope = var.getScope();\n              // Check if the root variable is local and the property access/assignment\n              // occurs in a different scope than the variable's declaration.\n              if (scope != ownerScope && ownerScope.isLocal()) {\n                  // LValue case (Assignment like a.b = 1)\n                  if (NodeUtil.isLValue(n)) {\n                      // Record the qualified name itself as being assigned externally.\n                      data.get(ownerScope.getRootNode())\n                          .recordEscapedQualifiedName(n.getQualifiedName());\n                  } else { // RValue case (Use like a.b())\n                      // CHANGE 3: Record the root variable as escaped if its property\n                      // is *used* (read/called) in a scope different from declaration.\n                      data.get(ownerScope.getRootNode()).recordEscapedVarName(rootName);\n                  }\n              }\n          }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}