{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      // Initial checks\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // Skip global scope (depth 1) and top-level functions/scripts (depth 2)\n      // This analysis focuses on inner functions and closures.\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned OR REFERENCED in inner scopes\n        //    (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      // Try to find the variable and its defining scope if the node refers to one.\n      Var var = null;\n      Scope scope = t.getScope(); // The current scope where the node 'n' resides\n      Scope ownerScope = null;   // The scope where the variable is defined\n      Node function = null;     // The root node of the function where the variable is defined\n      String varName = null;    // The simple name of the base variable, if applicable\n\n      if (n.isName()) {\n        varName = n.getString();\n        var = scope.getVar(varName);\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName()) {\n        // Check if the base of the qualified name is a variable\n        Node root = NodeUtil.getRootOfQualifiedName(n);\n        if (root.isName()) {\n           varName = root.getString();\n           var = scope.getVar(varName);\n        }\n      }\n\n      // If we found a variable and it's defined in a local scope...\n      if (var != null && var.getScope().isLocal()) {\n        ownerScope = var.getScope();\n        function = ownerScope.getRootNode();\n        // Ensure we have analysis data for the function where the var is defined\n        if (function == null || !data.containsKey(function)) {\n            // This can happen if the owner scope's root node isn't a function,\n            // e.g., a catch block. We aren't analyzing variables from such scopes here.\n             return;\n        }\n        FunctionAnalysisData functionData = data.get(function);\n\n        // Check for assignment to a simple name (e.g., x = 1)\n        // Note: Bleeding functions (function fn(){}) declare 'fn' in the inner scope.\n        if (n.isName() && NodeUtil.isLValue(n) &&\n            !NodeUtil.isBleedingFunctionName(n)) {\n           functionData.recordAssignedName(varName);\n        }\n\n        // Check for escaping: variable used in a scope different from its definition scope.\n        // This includes both reads (RValues) and writes (LValues) in the inner scope.\n        if (scope != ownerScope) {\n           // Record that the base variable escapes\n           functionData.recordEscapedVarName(varName);\n\n           // If it's an assignment to a qualified name (e.g., localVar.prop = 1),\n           // record the escaped qualified name as well.\n           if (n.isGetProp() && NodeUtil.isLValue(n)) {\n              // We already checked isUnscopedQualifiedName and root.isName() above\n              functionData.recordEscapedQualifiedName(n.getQualifiedName());\n           }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}