{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        return;\n      }\n\n      // Handle NAME nodes (variable references)\n      // This block identifies both local variables assigned in inner scopes\n      // and local variables that are referenced from inner scopes (escaped vars).\n      if (n.isName() && !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope(); // Current scope\n        Var var = scope.getVar(name);\n        if (var != null) {\n          Scope ownerScope = var.getScope(); // Scope where the variable was declared\n          if (ownerScope.isLocal()) { // Only analyze local variables\n            // A variable is considered \"assigned\" if it's an LValue.\n            if (NodeUtil.isLValue(n)) {\n              data.get(ownerScope.getRootNode()).recordAssignedName(name);\n            }\n\n            // A local variable \"escapes\" if it's accessed (read or written)\n            // from a different, inner scope.\n            if (scope != ownerScope) {\n              data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n            }\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n          NodeUtil.isLValue(n)) {\n        // This block handles qualified names (e.g., `obj.prop`) that are LValues\n        // (i.e., being assigned to) where the root of the qualified name is a local variable\n        // that escapes.\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name); // Get the Var for the root of the qualified name (e.g., 'obj')\n        if (var != null) {\n          Scope ownerScope = var.getScope();\n          // If the root variable is local and accessed from a different scope,\n          // and the qualified name itself is an LValue, record it as an escaped qualified name.\n          if (scope != ownerScope && ownerScope.isLocal()) {\n            data.get(ownerScope.getRootNode())\n                .recordEscapedQualifiedName(n.getQualifiedName());\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}