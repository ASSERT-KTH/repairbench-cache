{
    "generation": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      // Skip analysis for global scope (depth 1) and top-level functions (depth 2)\n      // We only care about uses/assignments in *inner* scopes (closures).\n      if (t.getScopeDepth() <= 2) {\n        // The first-order function analyzer looks at two types of variables:\n        //\n        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n        //\n        // 2) Local variables that are assigned more than once.\n        //\n        // We treat all global variables as escaped by default, so there's\n        // no reason to do this extra computation for them.\n        // This optimization also skips analysis for variables accessed\n        // directly in depth 2 scopes, focusing on closures (depth > 2).\n        return;\n      }\n\n      // We are now in a scope with depth > 2 (an inner function/scope).\n      Scope scope = t.getScope();\n\n      if (n.isName()) {\n        String name = n.getString();\n        // Be careful of bleeding functions, which create variables\n        // in the inner scope, not the scope where the name appears.\n        if (NodeUtil.isBleedingFunctionName(n)) {\n          return;\n        }\n\n        Var var = scope.getVar(name);\n        // Check if 'name' corresponds to a variable defined in a local scope (outer or current)\n        if (var != null && var.getScope().isLocal()) {\n          Scope ownerScope = var.getScope();\n          // Record if the variable is defined in an *outer* local scope and accessed here.\n          // This marks the variable as \"escaping\" to this inner scope.\n          if (scope != ownerScope) { // ownerScope.isLocal() is checked above\n            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n          }\n\n          // Record if the variable is assigned to here (LValue).\n          if (NodeUtil.isLValue(n)) {\n            // This information is used to track assignments, potentially\n            // for multiple assignment checks or side effect analysis.\n            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n          }\n        }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName()) {\n        Node root = NodeUtil.getRootOfQualifiedName(n);\n        // Check if the base of the qualified name is a simple name\n        if (root.isName()) {\n          String baseName = root.getString();\n          Var var = scope.getVar(baseName);\n          // Check if the base name corresponds to a variable defined in a local scope\n          if (var != null && var.getScope().isLocal()) {\n            Scope ownerScope = var.getScope();\n            // Record if the base variable is defined in an *outer* local scope and accessed here\n            // via a property access/assignment.\n            if (scope != ownerScope) { // ownerScope.isLocal() is checked above\n              // Record the base name as escaped due to property access/assignment\n              data.get(ownerScope.getRootNode()).recordEscapedVarName(baseName);\n\n              // Additionally, if this is an assignment to the property (LValue),\n              // record the qualified name that escapes and is assigned.\n              if (NodeUtil.isLValue(n)) {\n                 data.get(ownerScope.getRootNode())\n                    .recordEscapedQualifiedName(n.getQualifiedName());\n              }\n            }\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}