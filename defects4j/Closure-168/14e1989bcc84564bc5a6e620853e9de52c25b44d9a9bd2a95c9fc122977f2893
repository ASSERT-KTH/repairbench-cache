{
    "generation": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  // Don\u2019t do any of this in the global scope.\n  if (t.inGlobalScope()) {\n    return;\n  }\n\n  // Note if this function ever returns a non-void value.\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  // We only care about local-variable assignment/escape in truly\n  // nested scopes (depth > 2).\n  if (t.getScopeDepth() <= 2) {\n    return;\n  }\n\n  // 1) Track simple-name assignments and any use of a local name from\n  //    an inner scope (\u201cescaped\u201d).\n  if (n.isName() && !NodeUtil.isBleedingFunctionName(n)) {\n    String name = n.getString();\n    Scope scope = t.getScope();\n    Var var = scope.getVar(name);\n    if (var != null) {\n      Scope ownerScope = var.getScope();\n      if (ownerScope.isLocal()) {\n        // Assignment in the inner scope?\n        if (NodeUtil.isLValue(n)) {\n          data.get(ownerScope.getRootNode()).recordAssignedName(name);\n        }\n        // Any reference in an inner scope is an \u201cescape.\u201d\n        if (scope != ownerScope) {\n          data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n        }\n      }\n    }\n  }\n  // 2) Track qualified\u2010name (getprop) \u201cescapes\u201d from inner scopes.\n  else if (n.isGetProp()) {\n    Node root = NodeUtil.getRootOfQualifiedName(n);\n    if (root != null && root.isName()) {\n      String rootName = root.getString();\n      Scope scope = t.getScope();\n      Var var = scope.getVar(rootName);\n      if (var != null) {\n        Scope ownerScope = var.getScope();\n        if (ownerScope.isLocal() && scope != ownerScope) {\n          data.get(ownerScope.getRootNode())\n              .recordEscapedQualifiedName(n.getQualifiedName());\n        }\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}