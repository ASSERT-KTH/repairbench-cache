{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // Parent should never be null, except for the root node, which is never useless code itself.\n    if (parent == null) {\n      return;\n    }\n\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // The original comment indicated these should be allowed. `test(\"foo();;;;bar();;;;\", ok);`\n    // supports this. However, `test(\"function f(x) { if(x); }\", e);` implies an empty statement\n    // as a child of an IF statement should generate an error.\n    // We differentiate: allow block-level empty statements, but report others.\n    if (n.isEmpty()) {\n      if (parent.getType() == Token.BLOCK) {\n        return; // Allow extra semicolons in blocks.\n      }\n      // If not in a block (e.g., `if (x);`), it falls through to be checked as useless code.\n    }\n\n    // Comma nodes themselves are structural nodes, and their direct children are\n    // typically evaluated. The \"usefulness\" of a comma expression's sub-parts\n    // is determined by whether the sub-expression's result is used or has side effects.\n    // The visit method on children (which happens before the parent is visited)\n    // should handle their uselessness. The COMMA node itself shouldn't be reported\n    // as useless code.\n    if (n.isComma()) {\n      return;\n    }\n\n    // An EXPR_RESULT node is a statement wrapper for an expression.\n    // The warning for useless code should typically be generated for the child\n    // expression (e.g., `x == 3`), not for the EXPR_RESULT wrapper itself.\n    // Returning here prevents duplicate warnings or warnings on the wrong node.\n    // The `NodeUtil.isStatement(n)` check later in this method correctly prevents\n    // EXPR_RESULT nodes from being added to `problemNodes` for removal anyway.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // The large conditional block in the original code that checked `parent.getType()`\n    // (e.g., `if (parent.getType() == Token.COMMA) { ... } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { ... }`)\n    // was problematic. It prematurely returned for many nodes whose usefulness should\n    // be determined by `NodeUtil.isExpressionResultUsed` and `NodeUtil.mayHaveSideEffects`.\n    // By removing this block, we ensure that the core side-effect check applies broadly\n    // to expressions that might be useless.\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n    // If the result of the expression is not used AND (it's a simple operator OR has no side effects),\n    // then it's considered useless code.\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n\n      // This specific case allows qualified names with JSDoc information to avoid\n      // being flagged as useless, as the JSDoc might indicate intended use.\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        return;\n      }\n\n      // Generate the appropriate warning message based on the node type.\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      // Report the useless code warning.\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Add the node to `problemNodes` only if it's not a statement.\n      // Statements (like EXPR_RESULT, BLOCK, IF, FOR, EMPTY etc.) are structural nodes\n      // and are not directly removed by this pass; their removal is left to\n      // peephole optimizations to ensure tree consistency.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}