{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // Allow these.\n    if (n.isEmpty()) {\n      return;\n    }\n    if (parent == null) {\n      return;\n    }\n\n    // Determine if the result of 'n' is effectively unused in the program.\n    boolean isResultUnused = false;\n\n    // 1. Check standard expression statement contexts:\n    //    expr;\n    if (parent.isExprResult() || parent.isBlock()) {\n      isResultUnused = true;\n    }\n    // 2. Check FOR loop initializers and increments:\n    //    for(init; cond; iter) {}\n    else if (parent.isFor()) {\n        Node init = parent.getFirstChild();\n        // Check if 'n' is the initializer or iterator expression node.\n        // The condition expression's result is used by the loop.\n        // The body is obviously used.\n        if (n == init || n == init.getNext().getNext()) {\n             isResultUnused = true;\n        }\n    }\n    // 3. Check non-last children of COMMA operator:\n    //    a, b, c; (a and b's results are unused by the comma itself)\n    else if (parent.isComma() && n != parent.getLastChild()) {\n      isResultUnused = true;\n    }\n    // 4. If the standard checks didn't mark it as unused, check if 'n' is the\n    //    last child of a comma chain that is ultimately unused.\n    //    e.g., for((a,b); ... ) where b's result is used by comma, but comma's result is unused by FOR.\n    //    e.g., (a,b); where b's result is used by comma, but comma's result is unused by EXPR_RESULT.\n    else if (parent.isComma()) { // && n == parent.getLastChild() is implied here\n      Node curNode = parent; // Start with the parent comma node\n      Node curParent = curNode.getParent();\n      // Find the top-most comma in a chain of commas\n      while (curParent != null && curParent.isComma()) {\n        curNode = curParent;\n        curParent = curNode.getParent();\n      }\n      // Check the context of the top-most comma (curNode)\n      if (curParent != null) {\n        // Is the comma chain itself in a context where its result is unused?\n        if (curParent.isExprResult() || curParent.isBlock()) {\n          isResultUnused = true;\n        } else if (curParent.isFor()) {\n            Node init = curParent.getFirstChild();\n            Node iter = init.getNext().getNext(); // Get iter expression node\n            if (curNode == init || curNode == iter) {\n                isResultUnused = true; // Comma chain is FOR init or iter\n            }\n        }\n        // If the top comma's context isn't one of these (e.g., ASSIGN, CALL, RETURN), the result is used.\n      }\n    }\n\n    // If the result is determined to be unused, check for lack of side effects.\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (isResultUnused &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n\n      // Allow certain patterns that lack side effects but are common/intentional.\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        // Allow names with JSDoc attached (often used for type declarations).\n        return;\n      }\n      if (n.isString() && \"use strict\".equals(n.getString())) {\n         // Allow \"use strict\"; directives.\n         return;\n      }\n\n      // Report the useless code warning.\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        // Use a more specific message for simple operators like +, ==, etc.\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Add to problemNodes if it's not a statement node itself.\n      // This list is potentially used by the RemoveSideEffectFreeCode pass.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}