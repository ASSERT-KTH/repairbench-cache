{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // Initial skips for nodes that don't represent expressions requiring checks\n    // or are handled by visiting their children.\n    // We also skip checking COMMA nodes directly, but check their children.\n    if (n.isEmpty() || n.isComma() || n.isExprResult() || n.isBlock() || n.isScript()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    boolean maybeUseless = false;\n\n    // Determine if the node 'n' is in a context where its result is possibly unused.\n    // We check these contexts specifically. Assume result is used in all other contexts.\n    if (parent.isExprResult() || parent.isBlock() || parent.isScript()) {\n      // Case 1: Direct statement context (EXPR_RESULT / SCRIPT / BLOCK)\n      // The result of 'n' is not used by the statement structure.\n      maybeUseless = true;\n    } else if (parent.isFor() && !NodeUtil.isForIn(parent) && !NodeUtil.isForOf(parent) && parent.getChildCount() == 4) {\n      // Case 2: Standard FOR loop: for(init; condition; increment) body\n      Node first = parent.getFirstChild();\n      Node third = first.getNext().getNext();\n      if (n == first || n == third) { // init or increment part\n        // The result of the initializer or increment expression is not used by FOR structure.\n        maybeUseless = true;\n      }\n      // Note: Condition expression's result *is* used. Body is handled like BLOCK.\n    } else if (parent.isComma()) {\n      // Case 3: Comma operator operands\n\n      // Special case for \"eval\": eval(\"foo\", \"bar\") --> eval(\"bar\")\n      // In IE, this implies an indirect eval, preserving the first arg matters.\n      Node gramps = parent.getParent();\n      if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild()) {\n         // Check structure corresponding to eval(\"...\", \"eval\") based on original code comment\n         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n           return; // indirect eval in IE. Don't warn.\n         }\n      }\n\n      if (n != parent.getLastChild()) {\n        // Intermediate comma operand: result is never used. Check side effects.\n        maybeUseless = true;\n      } else {\n        // Last child of comma. Need to check context of the comma expression itself.\n        // Traverse up comma ancestors to find the effective context where the comma expression resides.\n        Node ancestor = parent;\n        Node ancestorParent = parent.getParent();\n        while (ancestorParent != null && ancestorParent.isComma()) {\n            ancestor = ancestorParent;\n            ancestorParent = ancestorParent.getParent();\n        }\n\n        // Check if the ancestor context uses the result of the comma expression.\n        boolean commaResultUsed = true; // Assume used by default\n        if (ancestorParent == null) {\n            // Should not happen in valid AST? Assume top-level comma is unused.\n            commaResultUsed = false;\n        } else if (ancestorParent.isExprResult() || ancestorParent.isBlock() || ancestorParent.isScript()) {\n            // Comma expression is a statement, result unused.\n            commaResultUsed = false;\n        } else if (ancestorParent.isFor() && !NodeUtil.isForIn(ancestorParent) && !NodeUtil.isForOf(ancestorParent) && ancestorParent.getChildCount() == 4) {\n            // Comma expression is in a FOR loop header.\n            Node first = ancestorParent.getFirstChild();\n            Node third = first.getNext().getNext();\n            if (ancestor == first || ancestor == third) { // FOR init or increment part\n                commaResultUsed = false;\n            }\n            // If in condition, result is used.\n        }\n        // In other contexts (ASSIGN, CALL args, RETURN value, IF condition, etc.), the result is used.\n\n        if (!commaResultUsed) {\n            // The overall comma expression's result is unused, so check this last operand.\n            maybeUseless = true;\n        }\n      }\n    }\n\n    // If the context indicates the result is potentially unused ('maybeUseless' is true),\n    // then perform the side-effect check on node 'n'.\n    if (maybeUseless) {\n        boolean hasSideEffects = NodeUtil.mayHaveSideEffects(n, t.getCompiler());\n        // Check if it's a simple operator (e.g., comparison, typeof) whose\n        // main purpose is the value, or if the node lacks side effects entirely.\n        boolean isSimpleOperator = NodeUtil.isSimpleOperatorType(n.getType());\n\n        // Report if it's a simple operator (whose value isn't used) OR if it lacks side effects.\n        if (isSimpleOperator || !hasSideEffects) {\n            // Potentially useless code found.\n\n            // Exception: Allow JSDoc comments on qualified names used as statements.\n            // Example: /** @type {Foo} */ bar.baz;\n            if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n                // Don't report a warning, this is a recognized pattern for type annotation.\n            } else {\n                // Report the useless code error.\n                String msg = \"This code lacks side-effects. Is there a bug?\";\n                if (n.isString()) {\n                    msg = \"Is there a missing '+' on the previous line?\";\n                } else if (isSimpleOperator) {\n                    msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n                          \"' operator is not being used.\";\n                }\n\n                t.getCompiler().report(\n                    t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n                // Mark node for potential removal if it's not a statement node itself.\n                // (Actual removal logic is handled elsewhere based on 'problemNodes').\n                if (!NodeUtil.isStatement(n)) {\n                    problemNodes.add(n);\n                }\n            }\n        }\n    }\n    // If maybeUseless was false (result is used by context), or if the node had side effects,\n    // or if it matched an exception (JSDoc), we simply return without reporting a warning.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}