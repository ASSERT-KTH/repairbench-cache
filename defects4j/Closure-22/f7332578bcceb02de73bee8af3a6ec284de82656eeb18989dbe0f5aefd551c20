{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) { // Don't check COMMA nodes directly, check their children.\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (parent.getType() == Token.COMMA) {\n      Node gramps = parent.getParent();\n      // Special case: eval(x, global) is used to eval in the global scope.\n      // Don't warn on the possibly-useless first argument.\n      if (gramps != null && gramps.isCall() && parent == gramps.getFirstChild() &&\n          n == parent.getFirstChild() && // n is first child of comma\n          n.getNext() != null && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n          // This is the eval(firstExpr, 'eval') pattern.\n          return;\n      }\n\n      // If n is the last child of a comma expression, the comma result is n's result.\n      // Only check n if the comma expression's result itself is unused.\n      if (n == parent.getLastChild() && NodeUtil.isExpressionResultUsed(parent)) {\n            return; // The result of the comma expression (n) is used.\n      }\n      // If n is not the last child, or it is the last child but the comma\n      // expression's result is not used, fall through to the main check.\n\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      // Only check expressions whose results are likely unused.\n      // This includes FOR loop initializers and increment expressions.\n      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&\n          (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) {\n          // Fall through to the main check for FOR initializer/increment.\n      } else {\n          // Otherwise, the expression is in a context where its result is likely used\n          // (e.g., condition, function call argument, assignment RHS), so don't check.\n          return;\n      }\n    }\n    // Fall through to the main check if the parent is EXPR_RESULT, BLOCK,\n    // FOR (init/incr), or COMMA (and conditions above allow).\n\n\n    // Check for code that produces no side effects.\n    // NodeUtil.isExpressionResultUsed(n) is the primary check.\n    // If the value is used, it doesn't matter if it has side effects.\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n\n    // If the result of the expression is not used, check for side effects.\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n\n      // Allow certain types of expressions regardless.\n\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        // Allow `/** @type {foo} */ ns.bar;` This is used for type documentation.\n        return;\n      } else if (n.isExprResult()) {\n        // This is the wrapper node (EXPR_RESULT). The actual expression is the child.\n        // Visiting the child will trigger the check. Avoid warning on the wrapper itself.\n        return;\n      }\n\n      // Report the useless code error.\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Track the node if it's not a statement itself, for potential removal by other passes.\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}