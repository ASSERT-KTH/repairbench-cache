{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // Allow them. Also EXPR_RESULT and BLOCK nodes are handled via their\n    // children, and the determination of whether their value is used is\n    // complex, so don't check themselves.\n    if (n.isEmpty() || n.isExprResult() || n.isBlock()) {\n      return;\n    }\n\n    // Don't reported parent-less nodes.\n    if (parent == null) {\n      return;\n    }\n\n    // Check if the result of the expression is used. This function accurately\n    // determines if the value computed by `n` is used by its parent context.\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n\n    // If the node is a qualified name with JSDoc and its result isn't used,\n    // don't report it as useless code. This allows constructs like:\n    // /** @type {foo} */ bar.baz; for type annotation.\n    if (!isResultUsed && n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    // Now, check for useless code:\n    // The result must not be used, and EITHER\n    // 1) The node represents a simple operator (e.g. +, ==, !, typeof) OR\n    // 2) The node has no side effects.\n    // Simple operators are flagged even if their operands might have side\n    // effects (like getters) because the operation itself is useless if the\n    // result isn't used (e.g., \"a + b;\").\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n\n      // If we get here, the code is potentially useless. Report it.\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      compiler.report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Add to list for potential removal later by optimization passes\n      // if it's not a statement node itself. Expressions within statements\n      // (like EQ in EXPR_RESULT or 5 in (5,6)) are not statements.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}