{
    "generation": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (n.isEmpty() || n.isComma()) {\n    return;\n  }\n  if (parent == null) {\n    return;\n  }\n\n  // When an expression is inside a comma operator, its \u201cresult\u201d is only\n  // used if it is the last operand. However, not all comma\u2010expressions are\n  // suspicious. In particular, when a comma expression is used to sequence\n  // assignments (or pure value\u2013producing expressions) for an overall value,\n  // it is often intentional. By contrast, if a comma expression mixes a non\u2010assignment\n  // side\u2013effect (like a function call) with a pure operand, then the discarded\n  // pure value is often a mistake.\n  //\n  // Here we adjust the behavior for nodes whose direct parent is a COMMA:\n  if (parent.getType() == Token.COMMA) {\n    Node commaParent = parent.getParent();\n    // We consider the comma-expression \u201cin an assignment context\u201d if its immediate\n    // parent is, for example, an assignment, a VAR initializer, or a NAME node.\n    boolean inAssignmentContext = commaParent != null &&\n        (commaParent.getType() == Token.ASSIGN ||\n         commaParent.getType() == Token.VAR ||\n         commaParent.getType() == Token.NAME);\n    // Scan all children of the comma operator to see if any non-assignment expression\n    // may have side effects.\n    boolean hasNonAssignmentSideEffect = false;\n    for (Node c = parent.getFirstChild(); c != null; c = c.getNext()) {\n      // When checking, ignore operands that are assignments.\n      if (c.getType() != Token.ASSIGN && NodeUtil.mayHaveSideEffects(c, t.getCompiler())) {\n        hasNonAssignmentSideEffect = true;\n        break;\n      }\n    }\n    // In an assignment/initializer, if the comma expression is entirely \u201cpure\u201d\n    // (or only contains assignments) then we do not warn on any of its parts.\n    if (inAssignmentContext && !hasNonAssignmentSideEffect) {\n      return;\n    }\n    // In non\u2013assignment contexts (say, as a function argument) we want to warn only\n    // for non\u2013last operands. Also, for the last operand we require that an ancestor\n    // is an EXPR_RESULT or BLOCK; otherwise the value is being used.\n    if (!inAssignmentContext) {\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) {\n            continue;\n          }\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {\n            return;\n          } else {\n            break;\n          }\n        }\n      }\n      // For non\u2013last children in non\u2013assignment comma expressions we always check.\n    }\n    // In assignment contexts that mix a non-assignment side\u2013effect (say, a call) with\n    // a pure intermediate operand, we allow the warning to go through.\n  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n    // Allow a couple of FOR-loop sub\u2013expressions.\n    if (parent.getType() == Token.FOR && parent.getChildCount() == 4 &&\n       (n == parent.getFirstChild() ||\n        n == parent.getFirstChild().getNext().getNext())) {\n      // Allowed.\n    } else {\n      return;\n    }\n  }\n\n  // Now check whether the expression n has a \u201cused\u201d value or it is a side-effect\n  // free \u201cuseless\u201d expression that may indicate a bug.\n  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n  if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n    // Do not report for a qualified name that carries JSDoc,\n    // or if the expression node is itself a statement.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    } else if (n.isExprResult()) {\n      return;\n    }\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n    }\n    t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // Protect non-statement nodes.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}