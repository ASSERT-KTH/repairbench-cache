{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n\n        // Simple case first: serialize as numeric timestamp?\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern/locale/timezone from @JsonFormat will override things\n        // IMPORTANT: The condition here was changed. It no longer implicitly uses\n        // StdDateFormat.DATE_FORMAT_STR_ISO8601 when only JsonFormat.Shape.STRING is present.\n        if (format != null && (format.hasPattern() || format.hasLocale() || format.hasTimeZone())) {\n            TimeZone tz = format.getTimeZone();\n            final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601; // Fallback to ISO if no pattern in @JsonFormat, but locale/timezone are\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n            if (tz == null) {\n                tz = serializers.getTimeZone();\n            }\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise (no numeric, no explicit pattern/locale/timezone in @JsonFormat):\n        // If there's no `@JsonFormat` annotation, or `@JsonFormat` only specifies STRING shape (or default),\n        // we should use the globally configured DateFormat from `serializers.getConfig()`.\n        // This addresses [databind#1648] by ensuring `ObjectMapper.setDateFormat()` is respected.\n        // We only proceed if the current serializer isn't already using that specific DateFormat instance.\n        if ((format == null) || (format.getShape() == JsonFormat.Shape.STRING)) {\n            DateFormat df = serializers.getConfig().getDateFormat();\n            if (df != null && df != _customDateFormat) {\n                // If _useTimestamp is null, it means it's currently using string format implicitly.\n                // If it's explicitly Boolean.FALSE, it's also string.\n                // If it's Boolean.TRUE, it would have been handled by the numeric case.\n                return withFormat(Boolean.FALSE, df);\n            }\n        }\n\n        // If none of the above specific format overrides or global settings apply,\n        // or if the serializer is already correctly configured, return this instance.\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}