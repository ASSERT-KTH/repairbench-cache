{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        // 08-Jun-2017, tatu: As per [databind#1648], need to also\n        //   take `TimeZone` and `Locale` from `SerializerProvider` if\n        //   not defined in format.\n        // Also: if `shape` is `STRING` but no pattern, default to `StdDateFormat`\n        // pattern which is ISO-8601.\n        // ^^^ NOTE: The above logic was incorrect. It should NOT use ISO-8601\n        // if no pattern is specified: rather, the default `DateFormat` from\n        // `ObjectMapper` should be used.\n        if (format == null) {\n            return this;\n        }\n        \n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // If shape is STRING but no specific format instructions (pattern, locale, timezone),\n        // then the default DateFormat from ObjectMapper should apply.\n        // In this case, we return 'this' to let the default behavior take over,\n        // which will implicitly use the DateFormat configured on the ObjectMapper.\n        if (shape == JsonFormat.Shape.STRING &&\n                !format.hasPattern() && !format.hasLocale() && !format.hasTimeZone()) {\n            return this;\n        }\n\n        // Otherwise, need to create/configure a DateFormat instance\n        // Get the default DateFormat from the provider.\n        DateFormat defaultDateFormat = serializers.getConfig().getDateFormat();\n\n        // If JsonFormat specifies a pattern, locale, or timezone, we need to create a new DateFormat\n        if (format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {\n            String pattern = format.getPattern(); // This will be null if !hasPattern()\n            Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n\n            // Case 1: Default is SimpleDateFormat. We can derive pattern from it and create new instance.\n            if (defaultDateFormat instanceof SimpleDateFormat) {\n                SimpleDateFormat sdf = (SimpleDateFormat) defaultDateFormat;\n                if (pattern == null) { // no pattern from format, use default's pattern\n                    pattern = sdf.toPattern();\n                }\n                SimpleDateFormat newSdf = new SimpleDateFormat(pattern, loc);\n                newSdf.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, newSdf);\n            }\n            // Case 2: Default is StdDateFormat. We can apply overrides to it.\n            else if (defaultDateFormat instanceof StdDateFormat) {\n                StdDateFormat stdDf = (StdDateFormat) defaultDateFormat;\n                if (pattern != null) { // only apply pattern if specified\n                    stdDf = stdDf.withPattern(pattern);\n                }\n                // StdDateFormat `withLocale` and `withTimeZone` also exist\n                if (format.hasLocale()) {\n                    stdDf = stdDf.withLocale(loc);\n                }\n                if (format.hasTimeZone()) {\n                    stdDf = stdDf.withTimeZone(tz);\n                }\n                return withFormat(Boolean.FALSE, stdDf);\n            }\n            // Case 3: Other DateFormat type. Cannot safely modify/clone.\n            // Revert to original behavior: return 'this' if unhandled type.\n            // The existing comment \"Ugh. No way to change `Locale`, create copy\" refers to this.\n            return this; // Cannot apply contextual changes for this DateFormat type\n        }\n\n        // All other cases (e.g., shape is not numeric, not STRING with no overrides, and no explicit pattern/locale/timezone overrides)\n        // should use the default serializer without specific DateFormat instance.\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}