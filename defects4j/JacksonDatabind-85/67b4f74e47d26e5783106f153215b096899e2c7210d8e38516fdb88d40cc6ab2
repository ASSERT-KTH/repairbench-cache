{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n\n        JsonFormat.Shape shape = format.getShape();\n\n        // NOTE: Shape ANY/null means \"use default\", which is String here\n        if (shape == JsonFormat.Shape.ANY || shape == null) {\n            shape = JsonFormat.Shape.STRING;\n        }\n\n        // Numeric format?\n        if (shape.isNumeric()) {\n             return withFormat(Boolean.TRUE, null);\n        }\n\n        // Otherwise, need a textual format...\n        TimeZone tz = format.getTimeZone();\n\n        // First: custom pattern will override things\n        if (format.hasPattern()) {\n            final String pattern = format.getPattern();\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n            // Timezone override? If not specified, use default timezone\n            if (tz == null) {\n                tz = serializers.getTimeZone();\n            }\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // If not pattern, maybe other overrides? Locale, TimeZone\n        boolean hasLocale = format.hasLocale();\n        // null tz means \"use default\", which needs to be handled separately\n        boolean hasTZ = (tz != null);\n\n        // If shape is String, need pattern. Missing means using default...\n        if (shape == JsonFormat.Shape.STRING || hasLocale || hasTZ) {\n            DateFormat df0 = serializers.getConfig().getDateFormat();\n            // 13-Oct-2019, tatu: Let's allow use of StdDateFormat regardless of timezone/locale override\n            if (df0 instanceof StdDateFormat) {\n                StdDateFormat std = (StdDateFormat) df0;\n                // timezone first, as it may affect pattern in some cases?\n                if (hasTZ) {\n                    // Must create new instance if time zone changes\n                    std = std.withTimeZone(tz);\n                }\n                if (hasLocale) {\n                    // Must create new instance if locale changes\n                     std = std.withLocale(format.getLocale());\n                }\n                // If neither changes, can return original? No, internal state may have changed (possible?)\n                // For now let's always return instance from `withFormat()`\n                return withFormat(Boolean.FALSE, std);\n            }\n\n            // If default is Serializer, can not override timezone or locale, without custom pattern\n            // except if it's SimpleDateFormat AND Locale/TZ differs\n            if (!(df0 instanceof SimpleDateFormat)) {\n                // 05-Aug-2019, tatu: Ok maybe we can allow this if nothing is specified...\n                //   but if Locale or TimeZone is indicated, we must fail.\n                if (hasLocale || hasTZ) {\n                    serializers.reportBadDefinition(handledType(), String.format(\n\"Configured `DateFormat` (%s) not usable as base for customization: must be `SimpleDateFormat` or `StdJdkDateFormat` (or override default with custom `JsonFormat` annotation using pattern)\",\ndf0.getClass().getName()));\n                }\n                // otherwise, ok to use as is; no changes needed:\n                return this;\n            }\n\n            // We know it's `SimpleDateFormat`; can customize, Create copy first\n            // NOTE: must create new instance, cannot modify possibly shared instance.\n            SimpleDateFormat df = (SimpleDateFormat) df0.clone();\n            final Locale loc = hasLocale ? format.getLocale() : serializers.getLocale();\n            // But SimpleDateFormat has no dedicated Locale setter... only with constructor\n            // 17-Nov-2019, tatu: Actually, no... can't change Locale. Must re-construct.\n            if (hasLocale && !loc.equals(df.getLocale())) {\n                 // [databind#1743] Need to construct new instance\n                df = new SimpleDateFormat(df.toPattern(), loc);\n                 // TimeZone might have been set implicitly based on Locale, reset?\n                 // For now, assume we might need to reset based on original/provider default\n                 // ... this gets complicated. Let's assume for now TZ needs explicit handling\n                 // Re-set the original timezone because constructing with Locale might have reset it\n                 // (note: this was the case before [databind#1743] was fixed)\n                df.setTimeZone(df0.getTimeZone());\n            }\n\n            // And then specified TimeZone\n            if (tz != null && !tz.equals(df.getTimeZone())) {\n                df.setTimeZone(tz);\n            }\n            return withFormat(Boolean.FALSE, df);\n        }\n        // Otherwise, no overrides relevant in this context; return as-is\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}