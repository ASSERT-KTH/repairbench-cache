{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            // [databind#1648]: If nothing specified, should not change settings based\n            // on TimeZone, Locale defaults BUT based on specific format settings\n            // (or, as per [databind#2094], could clone just in case)\n\n            // 08-Oct-2018, tatu: [databind#2094] Need to clone default DateFormat on contextualization,\n            //    to avoid race conditions. Except for NON-SimpleDateFormat ones which are typically\n            //    stateless (like StdDateFormat)\n            DateFormat df = serializers.getConfig().getDateFormat();\n            if (df instanceof SimpleDateFormat) {\n                 df = (SimpleDateFormat) df.clone();\n                 // 09-Oct-2018, tatu: Ok, one more twist; we may need to force timezone,\n                 //    if explicitly set via `ObjectMapper`...\n                 TimeZone tz = serializers.getTimeZone();\n                 if ((tz != null) && !tz.equals(df.getTimeZone())) {\n                      df.setTimeZone(tz);\n                 }\n                 return withFormat(Boolean.FALSE, df);\n            }\n            // otherwise can return this if default format is not SimpleDateFormat\n            return this;\n        }\n\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        Boolean useTimestamp = (shape == JsonFormat.Shape.STRING) ? Boolean.FALSE : null;\n        DateFormat df = null;\n        TimeZone tz = null;\n\n        // If not numeric, must be textual / string-based. Check if Class based defaults,\n        // explicit Format takes precedence\n        if (format.hasPattern()) {\n            final String pattern = format.getPattern();\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale() : serializers.getLocale();\n            SimpleDateFormat sdf = new SimpleDateFormat(pattern, loc);\n            tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n            sdf.setTimeZone(tz);\n            return withFormat(useTimestamp, sdf);\n        }\n        // If not pattern, maybe other overrides?\n        if (format.hasLocale() || format.hasTimeZone() || format.hasShape()) {\n            DateFormat blueprint = serializers.getConfig().getDateFormat();\n            if (blueprint instanceof SimpleDateFormat) {\n                // If default is SimpleDateFormat, great, modify settings:\n                SimpleDateFormat sdf = (SimpleDateFormat) blueprint.clone();\n                // Locale override?\n                Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale();\n                 if (!loc.equals(sdf.getLocale())) {\n                     sdf = new SimpleDateFormat(sdf.toPattern(), loc);\n                     // Timezone might be derived from Locale, so need to force override based on original blueprint\n                     // or explicit override\n                     sdf.setTimeZone(blueprint.getTimeZone());\n                 }\n                 // Timezone override?\n                 tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n                 if ((tz != null) && !tz.equals(sdf.getTimeZone())) {\n                     sdf.setTimeZone(tz);\n                 }\n                return withFormat(useTimestamp, sdf);\n            } else {\n                // 17-Nov-2017, tatu: If base format not SimpleDateFormat, need to construct\n                //   one. Note that this might not be properly thread-safe, depending on\n                //   underlying implementation but best we can do?\n                 // Otherwise, need to use the standard fallback format\n                 // (which is configured with default timezone, locale)\n                 // 17-Nov-2017, tatu: Actually, as per [databind#1648] we can and should force use of ISO-8601 format\n                 //    if no pattern is specified explicitly\n                 final Locale loc = format.hasLocale()\n                         ? format.getLocale() : serializers.getLocale();\n                 SimpleDateFormat sdf = new SimpleDateFormat(StdDateFormat.DATE_FORMAT_STR_ISO8601, loc);\n\n                 // Timezone might be specified via annotation, OR, via provider. If either is available,\n                 // MUST specify:\n                 tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n                 if (tz == null) { // Should not happen, as we have explicit check but...\n                      tz = serializers.getTimeZone();\n                 }\n                 sdf.setTimeZone(tz); // which is never null\n                 return withFormat(useTimestamp, sdf);\n            }\n        }\n        // Otherwise, we have nothing to contribute, return `this` as is\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}