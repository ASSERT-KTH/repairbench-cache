{
    "generation": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    // 1) look for any @JsonFormat overrides\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format != null) {\n        // a) numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n        // b) explicit string pattern, locale, time\u2010zone, or forced STRING\n        if (shape == JsonFormat.Shape.STRING\n                || format.hasPattern()\n                || format.hasLocale()\n                || format.hasTimeZone())\n        {\n            String pattern = format.hasPattern()\n                    ? format.getPattern()\n                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            Locale locale = format.hasLocale()\n                    ? format.getLocale()\n                    : serializers.getLocale();\n            TimeZone tz = format.hasTimeZone()\n                    ? format.getTimeZone()\n                    : serializers.getTimeZone();\n            SimpleDateFormat df = new SimpleDateFormat(pattern, locale);\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n        // otherwise fall through to use defaults\n    }\n\n    // 2) no annotation overrides: fall back on global settings\n    if (serializers.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n        return withFormat(Boolean.TRUE, null);\n    }\n    // use the DateFormat configured on the ObjectMapper\n    DateFormat df = serializers.getConfig().getDateFormat();\n    return withFormat(Boolean.FALSE, df);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}