{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        // findFormatOverrides merges property annotations with global config defaults.\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n\n        // If no format overrides are found (neither from annotations nor specific global config),\n        // use the current serializer's default behavior (return this).\n        if (format == null) {\n            return this;\n        }\n\n        JsonFormat.Shape shape = format.getShape();\n\n        // 1. Handle explicit numeric timestamp format requested\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // From this point, we are handling string/other formats, which will likely produce a string representation.\n\n        // 2. Handle cases where explicit pattern, locale, or timezone is defined in JsonFormat.Value.\n        // This implies constructing a new SimpleDateFormat based on these explicit overrides.\n        if (format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {\n            TimeZone tz = format.getTimeZone();\n            // If a pattern is NOT explicitly set in @JsonFormat, but locale/timezone are,\n            // we use ISO8601 as a default pattern for constructing SimpleDateFormat.\n            final String pattern = format.hasPattern()\n                                    ? format.getPattern()\n                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale(); // Default locale from serializer config if not explicit\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n            if (tz == null) { // If timezone was not specified in format, use serializerProvider's default\n                tz = serializers.getTimeZone();\n            }\n            df.setTimeZone(tz);\n            // Always return a new serializer with this specific DateFormat\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // 3. Handle the case where JsonFormat.Shape.STRING is explicitly set,\n        // but no pattern, locale, or timezone overrides are provided via @JsonFormat.\n        // This is crucial for fixing [databind#1648]: it means we should use the\n        // default DateFormat configured on the ObjectMapper/SerializationConfig.\n        if (shape == JsonFormat.Shape.STRING) {\n            DateFormat defaultDateFormat = serializers.getConfig().getDateFormat();\n            // If the current serializer is already configured to use this default string DateFormat,\n            // return `this` to avoid unnecessary re-creation.\n            // _useTimestamp == Boolean.FALSE indicates string format.\n            // Check if _customDateFormat matches defaultDateFormat (by instance identity)\n            // or if this serializer implicitly uses StdDateFormat and defaultDateFormat is also StdDateFormat.\n            if (_useTimestamp == Boolean.FALSE && (defaultDateFormat == _customDateFormat ||\n                    (_customDateFormat == null && defaultDateFormat instanceof StdDateFormat))) {\n                return this;\n            }\n            // Otherwise, return a new serializer instance configured with the defaultDateFormat.\n            return withFormat(Boolean.FALSE, defaultDateFormat);\n        }\n\n        // 4. If none of the above conditions met, it means no specific JsonFormat overrides\n        // (neither shape, pattern, locale, nor timezone) were found.\n        // In this scenario, the serializer should use its default behavior.\n        // The `this` instance is already correctly configured for such a default (e.g., using StdDateFormat implicitly).\n        return this;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}