{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // If not numeric, textual it is...\n        // Any overrides specified? Shape, pattern, locale, timezone?\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // First: custom pattern will override things\n        if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                || format.hasLocale() || format.hasTimeZone()) {\n\n            TimeZone tz = format.getTimeZone();\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n\n            // Pattern specified? Creates a new SimpleDateFormat\n            DateFormat df;\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                if (tz == null) {\n                    tz = serializers.getTimeZone();\n                }\n                SimpleDateFormat simpleDf = new SimpleDateFormat(pattern, loc);\n                simpleDf.setTimeZone(tz);\n                df = simpleDf;\n            }\n            // No pattern specified: Start with configured format, modify if necessary\n            else {\n                DateFormat base = serializers.getConfig().getDateFormat();\n                // Default specified? Requires cloning if SimpleDateFormat\n                if (base instanceof SimpleDateFormat) {\n                    // Important: clone() to prevent modifying the shared instance\n                    SimpleDateFormat simpleDf = (SimpleDateFormat) base.clone();\n                    // Locale override? Must recreate with pattern/locale.\n                    // NOTE: order matters; locale first then timezone.\n                    if (format.hasLocale() && !loc.equals(simpleDf.getLocale())) {\n                        simpleDf = new SimpleDateFormat(simpleDf.toPattern(), loc);\n                        // timezone may have been reset: needs re-setting later\n                    }\n\n                    // Timezone override?\n                    // [databind#1743]: Don't override if annotation doesn't specify one (i.e. tz == null)\n                    // But wait; Annotation default 'null' SHOULD mean \"use context timezone\", shouldn't it?\n                    if (tz == null) {\n                        tz = serializers.getTimeZone(); // Use default timezone from provider\n                    }\n                    // [databind#3142]: only apply timezone if it differs from format's default\n                    if ((tz != null) && !tz.equals(simpleDf.getTimeZone())) {\n                        simpleDf.setTimeZone(tz);\n                    }\n                    df = simpleDf;\n                }\n                // If base is not SimpleDateFormat, we cannot modify it.\n                // Check if overrides requires us to fail or fallback.\n                else if (format.hasLocale() || format.hasTimeZone()) {\n                    // Cannot modify; fallback to default ISO pattern\n                    // (note: this used to be an error, but makes sense as fallback)\n                    final String pattern = StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                    if (tz == null) {\n                        tz = serializers.getTimeZone();\n                    }\n                    SimpleDateFormat simpleDf = new SimpleDateFormat(pattern, loc);\n                    simpleDf.setTimeZone(tz);\n                    df = simpleDf;\n                } else {\n                    // No pattern, locale, or timezone override applied to a non-SimpleDateFormat base.\n                    // Just use the base format. This can happen if only shape=STRING is set.\n                    df = base;\n                }\n            }\n             // Use Boolean.FALSE to indicate textual format using 'df'.\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, no overrides, just return 'this'\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}