{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            // No @JsonFormat annotation. Check for global default.\n            DateFormat globalDf = serializers.getConfig().getDateFormat();\n            // If global definition seems to differ, may need to create new instance\n            if (globalDf != null) {\n                DateFormat newFormat = null;\n                // Need to clone for thread-safety, if possible & needed\n                // SimpleDateFormat is not thread-safe, must clone.\n                if (globalDf instanceof SimpleDateFormat) {\n                    newFormat = (DateFormat) ((SimpleDateFormat)globalDf).clone();\n                }\n                // StdDateFormat is thread-safe, but we might need to apply context (tz)\n                else if (globalDf instanceof StdDateFormat) {\n                    StdDateFormat std = (StdDateFormat) globalDf;\n                    TimeZone tz = serializers.getTimeZone();\n                    // Only create new instance if timezone differs\n                    if (!tz.equals(std.getTimeZone())) {\n                        newFormat = std.withTimeZone(tz);\n                    } else {\n                        newFormat = std; // Use shared instance\n                    }\n                    // Note: could consider locale too, but timezone is primary contextual aspect\n                } else {\n                    // Other DateFormat type? Try cloning, warn if not possible.\n                    try {\n                        newFormat = (DateFormat) globalDf.clone();\n                    } catch (Exception e) {\n                         // 17-Jan-2018, tatu: Maybe log warning? Or should this throw exception?\n                         serializers.reportBadDefinition(handledType(), String.format(\n                                 \"Configured `DateFormat` (%s) not cloneable: serializer instances for type %s will be shared, potentially causing thread-safety issues\",\n                                 globalDf.getClass().getName(), handledType().getName()));\n                         newFormat = globalDf; // Use shared (potentially unsafe)\n                    }\n                }\n\n                // Check if the derived format `newFormat` (string-based) differs from current config\n                boolean useTimestamp;\n\n                // If serializer is currently configured for numeric timestamp,\n                // and global default is NOT numeric format, change that\n                if (Boolean.TRUE.equals(this._useTimestamp)) {\n                    // [databind#1744]: careful explanation of precedence\n                    // If the default mapping is timestamp,asking for default format should NOT change that\n                    if (newFormat == null) { // should not happen if globalDf != null\n                        return this;\n                    }\n                    // Otherwise, string format definition does override default numeric choice:\n                    useTimestamp = false;\n                } else {\n                    useTimestamp = false;\n                }\n\n                // Either way, need to check if format differs\n                if ((useTimestamp != this._useTimestamp) // use of timestamp changed?\n                        || (newFormat != this._customFormat // format instance changed?\n                            // also, handle case where current format is null (default)\n                            // and new format is non-null\n                           && (this._customFormat == null || !this._customFormat.equals(newFormat)))\n               ) {\n                    // Important: indicate change via timestamp flag, rather than format,\n                    // if format remains null\n                    return withFormat(useTimestamp, newFormat);\n                }\n            }\n            // No @JsonFormat and no differing global format found, return current configuration\n            return this; // Return 'this' if no change needed\n        }\n\n        // --- @JsonFormat annotation found ---\n\n        JsonFormat.Shape shape = format.getShape();\n        // Numeric timestamp?\n        if (shape.isNumeric()) {\n            // Let base class handle optimization of returning 'this' if no change\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // String format? (Explicit shape, pattern, locale, or timezone)\n        if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                        || format.hasLocale() || format.hasTimeZone()) {\n            TimeZone tz = format.getTimeZone();\n            final String pattern = format.hasPattern()\n                            ? format.getPattern()\n                            // If not specified, default to standard format *as string*:\n                            : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale(); // Default locale from context\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n            if (tz == null) {\n                tz = serializers.getTimeZone(); // Default timezone from context\n            }\n            df.setTimeZone(tz);\n            // Let base class handle optimization of returning 'this' if no change\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Other shapes or @JsonFormat without specific overrides?\n        // Fall through, return 'this'. Use the existing configuration.\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}