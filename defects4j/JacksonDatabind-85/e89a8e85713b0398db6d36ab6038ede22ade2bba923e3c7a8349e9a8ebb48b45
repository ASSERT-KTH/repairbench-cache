{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // If contextual format overrides exist that imply string output (shape STRING,\n        // or explicit pattern/locale/timezone):\n        if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                        || format.hasLocale() || format.hasTimeZone()) {\n            TimeZone tz = format.getTimeZone();\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n\n            // Case 1: Explicit pattern is defined\n            if (format.hasPattern()) {\n                final String pattern = format.getPattern();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n                if (tz == null) { // If no custom TZ, use serializer's default\n                    tz = serializers.getTimeZone();\n                }\n                df.setTimeZone(tz);\n                return withFormat(Boolean.FALSE, df);\n            }\n\n            // Case 2: No explicit pattern, but other string-related overrides (shape STRING, locale, tz)\n            // Use the default/configured DateFormat from the serializer provider\n            DateFormat defaultOrConfiguredFormat = serializers.getConfig().getDateFormat();\n\n            // 2.1: If it's Jackson's StdDateFormat, it supports `with` methods for contextualization\n            if (defaultOrConfiguredFormat instanceof StdDateFormat) {\n                StdDateFormat stdDf = (StdDateFormat) defaultOrConfiguredFormat;\n                // `withTimeZone` and `withLocale` methods clone the instance for thread-safety\n                if (tz != null) {\n                    stdDf = stdDf.withTimeZone(tz);\n                } else {\n                    // Apply serializer's default timezone if no explicit override\n                    stdDf = stdDf.withTimeZone(serializers.getTimeZone());\n                }\n                stdDf = stdDf.withLocale(loc);\n                return withFormat(Boolean.FALSE, stdDf);\n            }\n\n            // 2.2: If it's a SimpleDateFormat (e.g., configured via ObjectMapper.setDateFormat())\n            // SimpleDateFormat cannot change locale after construction (no setLocale()).\n            // So if locale is contextual, we must recreate it.\n            // Also, SimpleDateFormat is not thread-safe, so we generally clone or recreate.\n            if (defaultOrConfiguredFormat instanceof SimpleDateFormat) {\n                SimpleDateFormat sdf = (SimpleDateFormat) defaultOrConfiguredFormat;\n                String pattern = sdf.toPattern(); // Get the pattern from the existing SimpleDateFormat\n                \n                // Create a new SimpleDateFormat to apply potentially new locale and timezone\n                SimpleDateFormat newSdf = new SimpleDateFormat(pattern, loc);\n                if (tz != null) {\n                    newSdf.setTimeZone(tz);\n                } else {\n                    newSdf.setTimeZone(serializers.getTimeZone());\n                }\n                return withFormat(Boolean.FALSE, newSdf);\n            }\n\n            // 2.3: For other DateFormat types or unhandleable combinations,\n            // fall back to the original serializer's default behavior.\n            // This means contextual TZ/Locale might not apply to the format itself.\n            return this;\n        }\n\n        // Otherwise, no specific format override that implies string output,\n        // or `shape` is `NATURAL`/`ARRAY`/`OBJECT` and no pattern/locale/timezone in format,\n        // so use the default `this` serializer.\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}