{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        if (property == null) {\n            return this;\n        }\n        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n        if (format == null) {\n            return this;\n        }\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n        // 16-Oct-2019, tatu: [databind#1743] adds another twist...\n        // First: custom pattern will override things\n        if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n                        || format.hasLocale() || format.hasTimeZone()) {\n            TimeZone tz = format.getTimeZone();\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n\n            // Determine the pattern to use:\n            String pattern;\n            if (format.hasPattern()) {\n                pattern = format.getPattern();\n            } else {\n                // No pattern in @JsonFormat: check base format\n                DateFormat blueprint = serializers.getConfig().getDateFormat();\n                // [databind#1743]: If passing format String, should use it;\n                //   otherwise, default without pattern is ISO8601\n                //   ... except if we just specified shape OR locale OR timezone,\n                //   in which case pattern is needed.\n                // And [databind#1648] says that timezone needs to be respected\n                if (blueprint instanceof SimpleDateFormat) {\n                    // Use pattern from SimpleDateFormat blueprint\n                    pattern = ((SimpleDateFormat) blueprint).toPattern();\n                } else {\n                    // Otherwise, default to ISO8601\n                    // (NOTE: StdDateFormat.DEFAULT_TIMEZONE_FORMAT is package protected)\n                    pattern = StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                }\n            }\n\n            // Need to create a new instance, usually, due to locale/timezone changes\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n\n            // Timezone override? If specified in `@JsonFormat`, use it; otherwise use default\n            if (tz == null) {\n                tz = serializers.getTimeZone();\n            }\n            // Compare `tz` with the timezone `df` was created with (via locale)\n            // NOTE: `getTimeZone()` may return null if locale lacks default;\n            // also TimeZone equality check is tricky... safest is to just set it\n            // if we have a non-default timezone.\n            // 06-Sep-2021, tatu: make sure we have non-null tz to set\n            if (tz != null) {\n                df.setTimeZone(tz);\n            }\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, need one of these changes:\n\n        // Jackson's own `StdDateFormat` is quite easy to deal with...\n\n        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n        //    So: require it be `SimpleDateFormat`; can't config other types\n//            serializers.reportBadDefinition(handledType(), String.format(\n            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        // If no format settings specified (shape, pattern, locale, timezone) via @JsonFormat,\n        // just use the default serializer, which will use the ObjectMapper's configured DateFormat.\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}