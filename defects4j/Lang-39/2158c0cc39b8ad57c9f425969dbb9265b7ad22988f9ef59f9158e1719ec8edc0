{
    "generation": "private static String replaceEach(String text, String[] searchList, String[] replacementList,\n                                  boolean repeat, int timeToLive)\n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (text == null || text.length() == 0 || searchList == null ||\n        searchList.length == 0 || replacementList == null || replacementList.length == 0)\n    {\n        return text;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n\n    // keep track of which still have matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n\n    // index on index that the match was found\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n\n    // index of replace array that will replace the search string found\n    // NOTE: logic duplicated below START\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n            searchList[i].length() == 0 || replacementList[i] == null)\n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n\n        // see if we need to keep searching for this\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    // NOTE: logic mostly below END\n\n    // no search strings found, we are done\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int increase = 0;\n\n    // count the replacement text elements that are larger than their corresponding text being replaced\n    for (int i = 0; i < searchList.length; i++) {\n        if (searchList[i] == null || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater; // assume 3 matches\n        }\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    increase = Math.min(increase, text.length() / 5);\n\n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n\n        for (int i = start; i < textIndex; i++) {\n            buf.append(text.charAt(i));\n        }\n        String replacement = replacementList[replaceIndex];\n        if (replacement != null) {  // Add null check before appending\n            buf.append(replacement);\n        }\n\n        start = textIndex + searchList[replaceIndex].length();\n\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n        // find the next earliest match\n        // NOTE: logic mostly duplicated above START\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n                searchList[i].length() == 0 || replacementList[i] == null)\n            {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n\n            // see if we need to keep searching for this\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n        // NOTE: logic duplicated above END\n\n    }\n    int textLength = text.length();\n    for (int i = start; i < textLength; i++) {\n        buf.append(text.charAt(i));\n    }\n    String result = buf.toString();\n    if (!repeat) {\n        return result;\n    }\n\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}