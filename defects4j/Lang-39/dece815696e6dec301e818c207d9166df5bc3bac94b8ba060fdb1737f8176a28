{
    "generation": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                    boolean repeat, int timeToLive) {\n    if (text == null || text.length() == 0 || searchList == null \n            || searchList.length == 0 || replacementList == null \n            || replacementList.length == 0) {\n        return text;\n    }\n\n    // on recursive calls, timeToLive must never be negative\n    if (timeToLive < 0) {\n        throw new IllegalArgumentException(\n            \"Aborting to protect against infinite loop in replaceEach: \" + text);\n    }\n\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" \n                + searchLength + \" vs \" + replacementLength);\n    }\n\n    // track which replacements can no longer find matches\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;  // index of earliest match\n    int replaceIndex = -1;  // corresponding index in searchList/replacementList\n    int tempIndex = -1;\n\n    // find the first match in the text for any of the search strings\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null \n                || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n\n    // no replacements were found\n    if (textIndex == -1) {\n        return text;\n    }\n\n    int start = 0;\n\n    // calculate initial buffer size increase guess; note the null-safety added here\n    int increase = 0;\n    for (int i = 0; i < searchLength; i++) {\n        if (searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n            continue;\n        }\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (greater > 0) {\n            increase += 3 * greater;  // assume 3 matches\n        }\n    }\n    increase = Math.min(increase, text.length() / 5);\n    \n    StringBuilder buf = new StringBuilder(text.length() + increase);\n\n    while (textIndex != -1) {\n        // append the portion before the match\n        buf.append(text, start, textIndex);\n        // append the replacement string for the match\n        buf.append(replacementList[replaceIndex]);\n\n        // move past the match\n        start = textIndex + searchList[replaceIndex].length();\n        textIndex = -1;\n        replaceIndex = -1;\n        tempIndex = -1;\n\n        // find the next earliest match starting at 'start'\n        for (int i = 0; i < searchLength; i++) {\n            if (noMoreMatchesForReplIndex[i] || searchList[i] == null \n                    || searchList[i].length() == 0 || replacementList[i] == null) {\n                continue;\n            }\n            tempIndex = text.indexOf(searchList[i], start);\n            if (tempIndex == -1) {\n                noMoreMatchesForReplIndex[i] = true;\n            } else {\n                if (textIndex == -1 || tempIndex < textIndex) {\n                    textIndex = tempIndex;\n                    replaceIndex = i;\n                }\n            }\n        }\n    }\n    \n    // append the remainder of the text\n    buf.append(text.substring(start));\n    String result = buf.toString();\n    \n    // if not repeating, we're done; if repeating, do another pass with updated timeToLive\n    if (!repeat) {\n        return result;\n    }\n    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}