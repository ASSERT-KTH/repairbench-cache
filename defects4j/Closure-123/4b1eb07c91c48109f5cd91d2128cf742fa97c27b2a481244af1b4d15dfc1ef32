{
    "generation": "void add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    // ... all other cases unchanged ...\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      // We use the normal OTHER context except in a for-init clause.\n      Context rhsContext = Context.OTHER;\n\n      // Print the test expression.\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n\n      // Print the 'then' branch.\n      Node thenBranch = first.getNext();\n      if (context == Context.IN_FOR_INIT_CLAUSE && thenBranch.getType() == Token.IN) {\n        // Wrap an 'in' inside a hook when we're in a for-init to preserve the parentheses.\n        add(\"(\");\n        add(thenBranch, Context.IN_FOR_INIT_CLAUSE);\n        add(\")\");\n      } else {\n        addExpr(thenBranch, 1, rhsContext);\n      }\n\n      cc.addOp(\":\", true);\n\n      // Print the 'else' branch.\n      Node elseBranch = last;\n      if (context == Context.IN_FOR_INIT_CLAUSE && elseBranch.getType() == Token.IN) {\n        // Likewise wrap an 'in' operator here.\n        add(\"(\");\n        add(elseBranch, Context.IN_FOR_INIT_CLAUSE);\n        add(\")\");\n      } else {\n        addExpr(elseBranch, 1, rhsContext);\n      }\n      break;\n    }\n\n    // ... all other cases unchanged ...\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}