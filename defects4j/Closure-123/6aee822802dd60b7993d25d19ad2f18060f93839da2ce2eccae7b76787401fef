{
    "generation": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) { // Check for potential binary operator\n      // Verify it's actually a binary operator node.\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of assignment ops, we need to preserve the context\n      // to correctly handle 'in' operators. For others, we want to stop\n      // the 'in' context propagating to the RHS, which getContextForNoInOperator does.\n      Context rhsContext;\n      if (NodeUtil.isAssignmentOp(n)) {\n         rhsContext = context; // Preserve original context for RHS of assignment.\n      } else {\n         rhsContext = getContextForNoInOperator(context); // Use OTHER if context is IN_FOR_INIT_CLAUSE.\n      }\n\n      // Handle associativity / special cases explicitly like the original code.\n      // e.g. if the parse tree is a * (b * c), we can simply generate a * b * c.\n      if (last.getType() == type && NodeUtil.isAssociative(type)) {\n        // Associative op: a * (b * c) -> a * b * c\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext); // Use calculated rhsContext for recursive call\n      } else if (NodeUtil.isAssignmentOp(n)) {\n        // Assignment is right-associative. Print LHS, op, RHS.\n        // The original code had a check for `NodeUtil.isAssignmentOp(last)` here,\n        // which seemed specific to unrolling `a = b = c`. Removing it to handle\n        // all assignments (`a = hook`, `a = b`, etc.) consistently here.\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext); // Use calculated rhsContext\n      } else {\n        // General case: Use unrollBinaryOperator for other binary operators.\n        // It handles precedence and potential line breaks.\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return; // Done with binary operators\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          // Pass the original context, as VAR acts like an assignment context\n          // for its initializers regarding the 'in' operator ambiguity.\n          addList(first, false, context); // Use 'context' instead of 'getContextForNoInOperator(context)'\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          // NAME node with an initializer. This is handled within VAR or FOR contexts typically.\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            // Assignment to comma expression, e.g., var x = (a(), b);\n            // Ensure 'in' operator within comma expression is handled correctly.\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), context); // Pass 'context'\n          } else {\n            // Assignment to a simple expression, e.g., var x = foo();\n            // Pass original context so addExpr can handle IN_FOR_INIT_CLAUSE if needed.\n            addExpr(first, 0, context); // Pass 'context'\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        // This case is only hit directly for comma expressions outside of binary op handling.\n        Preconditions.checkState(childCount == 2);\n        // The context passed to the right side is important for 'in' operator.\n        // Since COMMA is left-associative, getContextForNoInOperator is appropriate for rhs.\n        unrollBinaryOperator(n, Token.COMMA, \",\", context,\n            getContextForNoInOperator(context), 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        // Precedence matters here. Consider ++(x).\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        // Hook operator is right-associative. The expressions within the hook\n        // are evaluated with low precedence relative to the hook itself.\n        // Pass the original context to the branches, so that addExpr can\n        // correctly parenthesize 'in' operators if the hook itself is\n        // in an IN_FOR_INIT_CLAUSE context. Precedence level 1 is used\n        // for the branches, as they have the lowest precedence within the hook.\n        Context branchContext = context;\n        addExpr(first, p + 1, context); // Condition evaluated first. Needs parens if lower precedence than context.\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, branchContext); // True branch.\n        cc.addOp(\":\", true);\n        addExpr(last, 1, branchContext); // False branch.\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            (childCount == 2 && !last.isString())) { // last exists only if childCount == 2\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first); // Function name (identifier)\n\n        add(first.getNext()); // Param list\n        add(last, Context.PRESERVE_BLOCK); // Body\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed on the function node itself.\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n             // Use addJsString to handle quoting and escaping for string keys.\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions potentially\n          // (like for loops), but needs one when it's a statement directly in a block.\n          if (c.isVar() && context != Context.IN_FOR_INIT_CLAUSE) { // Added check for context\n            cc.endStatement();\n          }\n\n          // Function declarations don't need a ;. Handled by add(\"function\").\n          // Expression statements need a ;. Handled by EXPR_RESULT.\n          // Other control structures handle their own ; or block structure.\n\n          if (c.isFunction()) { // Add spacing after functions in blocks.\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) { // for(init; cond; incr)\n          add(\"for(\");\n          if (first.isVar()) {\n            // Pass IN_FOR_INIT_CLAUSE, VAR case now handles propagation.\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            // Pass IN_FOR_INIT_CLAUSE, addExpr handles propagation.\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext()); // Condition\n          add(\";\");\n          add(first.getNext().getNext()); // Increment\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false); // Body\n        } else { // for(item in list)\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first); // Item (often a NAME or VAR)\n          add(\"in\");\n          add(first.getNext()); // List\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false); // Body\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false); // Body\n        add(\"while(\");\n        add(last); // Condition\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first); // Condition\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false); // Body\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        // Represents an empty statement ';'\n        // Handled by endStatement calls elsewhere, or explicitly if needed.\n        // cc.maybeEndStatement(); // Avoid adding ; if not needed.\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber()); // e.g. (1).foo\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        // Quote reserved words as properties in ES3\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\n            && TokenStream.isKeyword(last.getString())) {\n          add(\"[\");\n          // Use addJsString for the property name string literal\n          addJsString(last);\n          add(\"]\");\n        } else {\n          add(\".\");\n          addIdentifier(last.getString());\n        }\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context); // Object/Array\n        add(\"[\");\n        add(first.getNext()); // Element expression\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first); // Object\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false); // Body\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default (0) is pre-inc/dec.\n        if (postProp != 0) { // Postfix: x++\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else { // Prefix: ++x\n          cc.addOp(o, false);\n          addExpr(first, NodeUtil.precedence(type), context); // Use addExpr for precedence check\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // Handle indirect eval and free calls.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          // Precedence of comma inside the call wrapper is lowest.\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        // Arguments\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        // An IF node can be the first element of an ELSE clause. We need to\n        // parenthesize it to avoid ambiguity. eg:\n        // if(x) if(y) .. else .. <-- ambiguous\n        // if(x) { if(y).. } else .. <-- unambiguous\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          // Wrap dangling-if in block\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first); // Condition\n        add(\")\");\n\n        if (hasElse) {\n          // Pass dangling-else context to THEN clause.\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          // ELSE clause is not ambiguous.\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else { // No ELSE clause\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock(); // End block for dangling-if wrapper\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          Preconditions.checkState(first.isLabelName());\n          add(\" \");\n          add(first); // Label name\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          Preconditions.checkState(first.isLabelName());\n          add(\" \");\n          add(first); // Label name\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // Check if the constructor expression needs parens, e.g., new (a().b)().\n        // Higher precedence is needed if the constructor is a CALL node itself,\n        // or contains lower precedence operators. Let addExpr handle this.\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' are optional only when no arguments are present AND the node originally had no args.\n        // The AST always includes the arguments as children nodes (even if empty).\n        // So we check if there's a non-empty list of arguments.\n        Node args = first.getNext();\n        if (args != null) { // Arguments node always exists if call has args list.\n          add(\"(\");\n          addList(args);\n          add(\")\");\n        } else {\n          // If the ARGUMENTS node is missing, it means new Foo was called without ().\n          // This is semantically different from new Foo(), so we don't add ().\n        }\n        break;\n\n      case Token.STRING_KEY: // Object literal key\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        // The key's name is the STRING_KEY node's string value.\n        // The child is the value associated with the key.\n        // This case is handled inside OBJECTLIT processing.\n         // Fall-through or error? Let's assume OBJECTLIT handles it. Error seems safer.\n         throw new IllegalStateException(\"STRING_KEY encountered outside OBJECTLIT\");\n        // break; // Should not be reached if OBJECTLIT handles it.\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        // Needs higher precedence for operand, e.g. delete ++x;\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        boolean firstEntry = true;\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (!firstEntry) {\n            cc.listSeparator();\n          }\n          firstEntry = false;\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            // Getter/setter syntax handled in their respective cases.\n            add(c);\n          } else if (c.isStringKey()) { // Regular key-value pair\n             // Key is the string property of the STRING_KEY node 'c'.\n             // Value is the child of 'c'.\n             String key = c.getString();\n             Node value = c.getFirstChild();\n             Preconditions.checkNotNull(value);\n\n            // Check if key needs quotes.\n            if (!c.isQuotedString()\n                && !(languageMode == LanguageMode.ECMASCRIPT3\n                    && TokenStream.isKeyword(key))\n                && TokenStream.isJSIdentifier(key)\n                && NodeUtil.isLatin(key)) {\n              // Print bare key identifier.\n              add(key);\n            } else {\n              // Check if it's a simple number key.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                 // Key needs quotes, use addJsString on the key node 'c'.\n                 // Pass 'c' itself which holds the string and quoting info.\n                 addJsString(c);\n              }\n            }\n            add(\":\");\n             // Value expression, precedence 1 (lowest within objlit).\n            addExpr(value, 1, Context.OTHER);\n          } else {\n             throw new IllegalStateException(\"Unexpected child node in OBJECTLIT: \" + c.toStringTree());\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first); // Switch expression\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext()); // Add all CASE/DEFAULT_CASE nodes\n        cc.endBlock(context == Context.STATEMENT); // Always break after switch if it's a statement.\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first); // Case expression\n        addCaseBody(last); // Block of statements for the case\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first); // Block of statements for the default case\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        Preconditions.checkState(first.isLabelName());\n        add(first); // Label name\n        add(\":\");\n        // Add the labeled statement. A labeled statement can't be empty.\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST: // Closure specific\n        add(\"(\");\n        addExpr(first, 0, context); // Casted expression\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}