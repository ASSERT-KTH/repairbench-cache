{
    "generation": "import java.util.Random;\n\n    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Integer.MAX_VALUE}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end are chosen.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive). If {@code chars} is not null, this is an index into the array.\n     * @param end  the position in set of chars to end before (exclusive). If {@code chars} is not null, this is an index into the array.\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars based on {@code start} and {@code end}.\n     * @param random  a source of randomness.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if {@code start} or {@code end} are out of bounds for the {@code chars} array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0, the provided {@code chars} array is empty, or {@code start} &ge; {@code end}.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        // Check for empty chars array *after* count check, as count < 0 exception takes precedence\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The provided chars array is empty.\");\n        }\n\n        int realStart;\n        int realEnd;\n\n        if (chars == null) {\n            // Generate from Unicode range\n            if (start == 0 && end == 0) {\n                if (!letters && !numbers) {\n                    // Full Unicode range potentially including surrogates.\n                    // Note: Integer.MAX_VALUE is not a valid code point, but used as range limit.\n                    realStart = 0;\n                    realEnd = Integer.MAX_VALUE;\n                } else {\n                    // Default printable ASCII range\n                    realStart = ' '; // 32\n                    realEnd = 'z' + 1; // 123\n                }\n            } else {\n                // Use specified Unicode range [start, end)\n                realStart = start;\n                realEnd = end;\n            }\n             // Defer validation of range (end > start) to random.nextInt(gap) below\n        } else {\n            // Generate from provided char array\n            if (start == 0 && end == 0) {\n                // Default: use the entire chars array\n                realStart = 0;\n                realEnd = chars.length; // Cannot be 0 here due to the earlier check\n            } else {\n                 // Use the specified range within the chars array [start, end)\n                 // Validate the indices according to array constraints\n                 if (start < 0) {\n                     // Use AIOOBE for negative start index\n                     throw new ArrayIndexOutOfBoundsException(\n                         \"Requested random string range start index \" + start + \" is less than 0.\");\n                 }\n                 if (end > chars.length) {\n                     // Use AIOOBE for end index exceeding array length\n                     throw new ArrayIndexOutOfBoundsException(\n                         \"Requested random string range end index \" + end + \" is greater than array length \" + chars.length);\n                 }\n                 if (start >= end) {\n                     // Use IAE for invalid range where start is not less than end\n                     throw new IllegalArgumentException(\n                          \"Requested random string range start index \" + start + \" must be less than end index \" + end);\n                 }\n                 realStart = start;\n                 realEnd = end;\n            }\n        }\n\n        // Calculate the gap for random number generation\n        // Note: If realEnd <= realStart, gap will be <= 0\n        int gap = realEnd - realStart;\n\n        char[] buffer = new char[count];\n\n        while (count-- != 0) {\n            char ch;\n            try {\n                if (chars == null) {\n                    // random.nextInt will throw IAE if gap <= 0\n                    ch = (char) (random.nextInt(gap) + realStart);\n                } else {\n                    // random.nextInt will throw IAE if gap <= 0\n                    int randomIndex = random.nextInt(gap) + realStart;\n                    ch = chars[randomIndex];\n                }\n            } catch (IllegalArgumentException e) {\n                // Catch exception from random.nextInt(gap) when gap <= 0\n                // This indicates an invalid start/end range was provided (or default calc resulted in invalid range)\n                 throw new IllegalArgumentException(\n                     \"Cannot generate random char from range [\" + realStart + \", \" + realEnd + \")\", e);\n            }\n\n            // Filter based on letters/numbers criteria\n            if ((letters && Character.isLetter(ch))\n                    || (numbers && Character.isDigit(ch))\n                    || (!letters && !numbers)) {\n\n                // Surrogate pair handling (copied from original logic)\n                // Ensure generated characters form valid Unicode strings if surrogates are possible\n                if(ch >= 56320 && ch <= 57343) { // Low surrogate (U+DC00..U+DFFF)\n                    if(count == 0) {\n                        count++; // Need space for high surrogate, retry\n                    } else {\n                        // Add low surrogate, step back, add random high surrogate\n                        buffer[count] = ch;\n                        count--;\n                        // Range 55296..55423 (U+D800..U+D87F) - From original code\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) { // High surrogate, non-private range (U+D800..U+DB7F) - From original code\n                    if(count == 0) {\n                        count++; // Need space for low surrogate, retry\n                    } else {\n                        // Add random low surrogate, step back, add high surrogate\n                        // Range 56320..56447 (U+DC00..U+DC7F) - From original code\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) { // High surrogate, private range (U+DB80..U+DBFF) - From original code\n                    // Skip & retry\n                    count++;\n                } else {\n                    // Not a surrogate or already handled, add to buffer\n                    buffer[count] = ch;\n                }\n            } else {\n                // Character did not meet letters/numbers criteria, retry\n                count++;\n            }\n        }\n        return new String(buffer);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}