{
    "generation": "    /**\n     * <p>Creates a random string based on a variety of options, using\n     * supplied source of randomness.</p>\n     *\n     * <p>If start and end are both {@code 0}, start and end are set\n     * to {@code ' '} and {@code 'z'}, the ASCII printable\n     * characters, will be used, unless letters and numbers are both\n     * {@code false}, in which case, start and end are set to\n     * {@code 0} and {@code Character.MAX_CODE_POINT + 1}.\n     *\n     * <p>If set is not {@code null}, characters between start and\n     * end indices (exclusive) are chosen from the set.</p>\n     *\n     * <p>This method accepts a user-supplied {@link Random}\n     * instance to use as a source of randomness. By seeding a single\n     * {@link Random} instance with a fixed seed and using it for each call,\n     * the same random sequence of strings can be generated repeatedly\n     * and predictably.</p>\n     *\n     * @param count  the length of random string to create\n     * @param start  the position in set of chars to start at (inclusive). If chars is null, this is the starting code point.\n     * @param end  the position in set of chars to end before (exclusive). If chars is null, this is the ending code point (exclusive).\n     * @param letters  only allow letters?\n     * @param numbers  only allow numbers?\n     * @param chars  the set of chars to choose randoms from, must not be empty.\n     *  If {@code null}, then it will use the set of all chars based on start/end code points.\n     * @param random  a source of randomness, must not be null.\n     * @return the random string\n     * @throws ArrayIndexOutOfBoundsException if {@code start/end} are invalid indices for {@code chars} array.\n     * @throws IllegalArgumentException if {@code count} &lt; 0, the provided {@code chars} array is empty,\n     * {@code random} is null, or the range specified by {@code start/end} is invalid.\n     * @since 2.0\n     */\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n        if (chars != null && chars.length == 0) {\n            throw new IllegalArgumentException(\"The provided chars array is empty.\");\n        }\n        if (random == null) {\n            throw new IllegalArgumentException(\"Random generator must not be null.\");\n        }\n\n\n        char[] buffer = new char[count];\n        int bufferPos = 0;\n\n        if (chars == null) {\n            // Generate using character code points\n            int codePointStart = start;\n            int codePointEnd = end; // Exclusive end boundary\n\n            // Define defaults if range is 0/0\n            if (start == 0 && end == 0) {\n                if (!letters && !numbers) {\n                    // Use full Unicode range [0, MAX_CODE_POINT]\n                    codePointStart = 0;\n                    codePointEnd = Character.MAX_CODE_POINT + 1; // exclusive end\n                } else {\n                    // Default to printable ASCII range [' ', 'z']\n                    codePointStart = ' '; // 32 (inclusive)\n                    codePointEnd = 'z' + 1; // 123 (exclusive)\n                }\n            } else {\n                // Use provided start/end as code points. End is already exclusive.\n            }\n\n            // Validate the range\n            if (codePointEnd <= codePointStart) {\n                 throw new IllegalArgumentException(\n                     String.format(\"Character code range [%d, %d) is invalid.\", codePointStart, codePointEnd));\n            }\n\n            int codePointRange = codePointEnd - codePointStart;\n\n            while (bufferPos < count) {\n                int randomCodePoint = codePointStart + random.nextInt(codePointRange);\n\n                // Filter based on letters/numbers flags\n                boolean characterAccepted = (letters && Character.isLetter(randomCodePoint))\n                                         || (numbers && Character.isDigit(randomCodePoint))\n                                         || (!letters && !numbers);\n\n                // Ensure the code point is valid and can fit in the buffer\n                if (characterAccepted && Character.isValidCodePoint(randomCodePoint)) {\n                    int charsNeeded = Character.charCount(randomCodePoint);\n                    if (bufferPos + charsNeeded <= count) {\n                        // Append character(s) to buffer\n                        Character.toChars(randomCodePoint, buffer, bufferPos);\n                        bufferPos += charsNeeded;\n                    }\n                    // If not enough space (only occurs for surrogate pairs near the end),\n                    // loop again to find a character that fits (likely BMP).\n                }\n                // If not accepted, not valid, or not enough space, loop again\n            }\n        } else {\n            // Generate using provided chars array\n            int indexStart = start;\n            int indexEnd = end; // Exclusive index boundary\n\n            // Define defaults if range is 0/0\n            if (start == 0 && end == 0) {\n                indexStart = 0;\n                indexEnd = chars.length; // exclusive end\n            }\n            // else: use provided start/end as indices. End is already exclusive.\n\n            // Validate the range indices\n            if (indexEnd <= indexStart) {\n                 throw new IllegalArgumentException(\n                     String.format(\"Character array range [%d, %d) is invalid.\", indexStart, indexEnd));\n            }\n            // Check if indices are within the bounds of the array\n            // (ArrayIndexOutOfBoundsException is specified in the Javadoc for this)\n            if (indexStart < 0 || indexEnd > chars.length) {\n                 throw new ArrayIndexOutOfBoundsException(\n                     String.format(\"Character array range [%d, %d) is out of bounds for array of length %d.\", indexStart, indexEnd, chars.length));\n            }\n\n            int indexRange = indexEnd - indexStart;\n\n            while (bufferPos < count) {\n                // Select a character index from the specified range in the chars array\n                int charIndex = indexStart + random.nextInt(indexRange);\n                char ch = chars[charIndex];\n\n                // Filter based on letters/numbers flags\n                boolean characterAccepted = (letters && Character.isLetter(ch))\n                                         || (numbers && Character.isDigit(ch))\n                                         || (!letters && !numbers);\n\n                if (characterAccepted) {\n                    // Skip lone surrogates from the provided array, as they can lead to invalid strings.\n                    // A valid surrogate pair in the input array would be treated as two separate chars here,\n                    // potentially being picked individually. Skipping lone ones is safer.\n                    if (!Character.isSurrogate(ch)) {\n                        buffer[bufferPos++] = ch;\n                    }\n                    // If ch is a surrogate, loop again to find an acceptable char.\n                }\n                // If not accepted or is a lone surrogate, loop again\n            }\n        }\n\n        return new String(buffer);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}