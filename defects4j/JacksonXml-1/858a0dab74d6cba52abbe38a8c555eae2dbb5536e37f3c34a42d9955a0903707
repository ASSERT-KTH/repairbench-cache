{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n\n        // Main loop for fetching XML tokens and converting to JsonTokens.\n        // We need a loop because some XML tokens might be skipped or transformed\n        // into sequences of JsonTokens, requiring multiple reads of XML tokens\n        // for a single JsonToken stream advancement.\n        while (true) {\n            int token = _xmlTokens.next();\n\n            switch (token) {\n            case XmlTokenStream.XML_START_ELEMENT:\n                // If we thought we might get leaf, but instead found a nested element.\n                // This means the current element is not a simple leaf value, but an object.\n                if (_mayBeLeaf) {\n                    _nextToken = JsonToken.FIELD_NAME; // The nested element's name\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1); // Current element becomes an object\n                    return (_currToken = JsonToken.START_OBJECT); // Return START_OBJECT for the current element\n                }\n                // If this START_ELEMENT is for an item within an unwrapped array.\n                // We don't report its name immediately; we need to check its content.\n                if (_parsingContext.inArray()) {\n                    _mayBeLeaf = true; // This item might be a leaf value (e.g. <item>value</item>) or an object/array.\n                    // We effectively \"skip\" this START_ELEMENT as a FIELD_NAME and await its content.\n                    // Continue the outer loop to read the next XML token (which will be the content or end tag of this item).\n                    continue;\n                }\n                // Regular START_ELEMENT for a field in an object.\n                String name = _xmlTokens.getLocalName();\n                _parsingContext.setCurrentName(name);\n\n                // Handle virtual wrapping by replaying the start element.\n                if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                    _xmlTokens.repeatStartElement();\n                }\n\n                _mayBeLeaf = true; // This element *could* be a leaf (text value or empty content)\n                return (_currToken = JsonToken.FIELD_NAME); // Return FIELD_NAME for the current element\n\n            case XmlTokenStream.XML_END_ELEMENT:\n                // If _mayBeLeaf is true, it means we encountered an empty element (e.g., <foo/> or <foo></foo>)\n                // after a START_ELEMENT that was expected to be a leaf.\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // As per [dataformat-xml#180]: an empty element should be exposed as an empty Object (START_OBJECT, END_OBJECT), not null.\n                    _nextToken = JsonToken.END_OBJECT; // Prepare END_OBJECT for the next call.\n                    // Create a child context for this empty object.\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT); // Return START_OBJECT for this empty object.\n                }\n                // Standard end element: close the current object or array.\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If a leaf was expected but an attribute is found, it means the current element is an object.\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText(); // Note: this sets _currText to the attribute *name* here.\n                                                      // It's used for VALUE_STRING later, which will be the attribute value.\n                                                      // This might be a minor semantic oddity but does not break current tests.\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                // If _mayBeLeaf is true, this text is the content of the current element.\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // We've consumed the text, so we need to skip the implicit END_ELEMENT for this node.\n                    _xmlTokens.skipEndElement();\n                    // If the text content is empty (e.g., <foo></foo> with just whitespace),\n                    // treat it as an empty object as per [dataformat-xml#180].\n                    if (_isEmpty(_currText)) {\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // If _mayBeLeaf is false, this text is not the primary content of a leaf element.\n                    // If it's empty (whitespace), it should be skipped.\n                    if (_isEmpty(_currText)) {\n                        continue; // Skip this XML token and fetch the next one.\n                    }\n                }\n                // If not a leaf (or ignorable empty text), transform into a property named by _cfgNameForTextElement.\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n            \n            // Should never get here for valid XML parsing, if all tokens are handled.\n            _throwInternal();\n            return null; // Should not be reached.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}