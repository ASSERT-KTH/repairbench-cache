{
    "generation": "  @Override\n  public void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle the case where the constraint is a union type.\n    // When an object literal is matched against a union of object types\n    // (e.g., `{a:X}|{b:Y}`), the resulting type of the object literal should\n    // contain the union of properties from all contributing object types.\n    if (constraint.isUnionType()) {\n      for (JSType alternate : constraint.toUnionType().getAlternates()) {\n        // Recursively apply the constraint for each object type in the union.\n        // Only consider object types (including record types) as sources for properties.\n        if (alternate.isObjectType() && !alternate.isUnknownType() && !alternate.isAllType()) {\n          matchRecordTypeConstraint(alternate.toObjectType());\n        }\n      }\n      return; // Union type handled, no further processing needed for this constraint.\n    }\n\n    // Handle the case where the constraint object is a single object type (including record types).\n    // We want to modify the object literal to match the constraint, by\n    // taking each property on the constraint object and trying to match\n    // properties on this object.\n    // Avoid matching against JSType.UNKNOWN or JSType.ALL as they don't provide\n    // useful structural information.\n    if (constraint.isObjectType() && !constraint.isUnknownType() && !constraint.isAllType()) {\n      matchRecordTypeConstraint(constraint.toObjectType());\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}