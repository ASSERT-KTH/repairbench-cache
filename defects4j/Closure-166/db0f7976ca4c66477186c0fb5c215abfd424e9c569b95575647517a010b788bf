{
    "generation": "  @Override\n  public void matchConstraint(JSType constraint) {\n    // We only want to match constraints on anonymous types.\n    if (hasReferenceName()) {\n      return;\n    }\n\n    // Handle union types by matching each alternative.\n    // If an anonymous object literal is constrained by a union,\n    // it must satisfy the properties imposed by *all* alternatives that are\n    // record-like. For example, if 'out = {}' is constrained by\n    // '{a:number}|{b:string}', 'out' should infer to '{a:(number|undefined), b:(string|undefined)}'.\n    // This is because an object literal must be assignable to any of the union alternatives.\n    // To be assignable to '{a:number}', it needs 'a'. To be assignable to '{b:string}', it needs 'b'.\n    // Therefore, it needs both 'a' and 'b' (as optional properties if they are undefined in the constraint).\n    if (constraint.isUnionType()) {\n      for (JSType alternative : constraint.toUnionType().getAlternatives()) {\n        // Recursively call matchConstraint for each alternative in the union.\n        // This ensures that all structural properties from all record-like alternatives\n        // are applied to 'this' object type.\n        matchConstraint(alternative);\n      }\n      return; // All alternatives have been processed, so we are done with the union.\n    }\n\n    // Handle the case where the constraint object is a record type.\n    // This is the specific structural constraint that adds properties.\n    //\n    // param constraint {{prop: (number|undefined)}}\n    // function f(constraint) {}\n    // f({});\n    //\n    // We want to modify the object literal to match the constraint, by\n    // taking any each property on the record and trying to match\n    // properties on this object.\n    if (constraint.isRecordType()) {\n      matchRecordTypeConstraint(constraint.toObjectType());\n    }\n\n    // If the constraint is neither a UnionType nor a RecordType (e.g., a primitive type,\n    // or an unknown type), for an anonymous object literal, it typically means\n    // no structural properties are added. The existing behavior for such cases\n    // (likely doing nothing or delegating to a superclass that doesn't modify\n    // structural properties for non-record types) is implicitly assumed to be correct\n    // based on the test cases.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}