{
    "generation": "/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant based on the chronology\n * and time-zone of the supplied instant.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text     the text to parse\n * @param position position to start parsing from\n * @return new position, negative value means parse failed -\n *         apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException      if the instant is null\n * @throws IllegalArgumentException      if any field is out of range\n */\npublic int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    // The raw millis in UTC\n    long instantMillis = instant.getMillis();\n    // Get the instant's chronology (which includes its zone)\n    Chronology chrono = instant.getChronology();\n    // Allow any formatter\u2010override of the chronology\n    chrono = selectChronology(chrono);\n\n    // Compute the default year once (using UTC\u2010millis so that .year().get does\n    // its own single zone\u2010conversion).  This avoids \"double\u2010offsetting\"\n    int defaultYear = chrono.year().get(instantMillis);\n\n    // Compute the local instant for the bucket\n    long instantLocal = chrono.getZone().convertUTCToLocal(instantMillis);\n\n    // Create the bucket with our corrected default year\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n\n    // Do the parse\n    int newPos = parser.parseInto(bucket, text, position);\n\n    // Build the new millis and apply to the instant\n    instant.setMillis(bucket.computeMillis(false, text));\n\n    // If an offset or zone was parsed, respect it\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n\n    // Finally set chronology and any override zone on the instant\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n\n    return newPos;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}