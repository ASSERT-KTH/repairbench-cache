{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        //LANG-645 Field values are compared using ==. Identity comparison should not be used for Integers.\n        // Comment: This is not applicable here as 'field' is an int primitive and Calendar constants are final ints.\n\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 / LANG-346 --------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        // see http://issues.apache.org/jira/browse/LANG-346\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods. Field specific rounding is handled later.\n        // This is because of previous issues with Calendar implementation bugs (LANG-140).\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // Store original values needed for rounding decisions and truncation\n        int originalMillis = val.get(Calendar.MILLISECOND);\n        int originalSeconds = val.get(Calendar.SECOND);\n        int originalMinutes = val.get(Calendar.MINUTE);\n        // Use HOUR_OF_DAY for rounding calculations involving hours (e.g. rounding up DAY)\n        // Store original value for AM/PM rounding check.\n        int originalHourOfDay = val.get(Calendar.HOUR_OF_DAY);\n\n\n        // Pre-calculate roundUp decisions based on original values\n        // Use >= for rounding up @ midpoint. Original code used > offset which is equivalent.\n        boolean roundUpMillis = round && originalMillis >= 500;\n        boolean roundUpSeconds = round && originalSeconds >= 30;\n        boolean roundUpMinutes = round && originalMinutes >= 30;\n\n        // truncate milliseconds\n        if (originalMillis > 0) {\n           time = time - originalMillis; // Subtract original milliseconds\n        }\n        // Stop truncation if processing the field immediately above the target field\n        if (field == Calendar.SECOND) {\n            done = true; // If target is SECOND, don't truncate seconds/minutes\n        }\n\n        // truncate seconds\n        if (!done) {\n            if (originalSeconds > 0) {\n                time = time - (originalSeconds * 1000L); // Subtract original seconds in milliseconds\n            }\n        }\n        if (field == Calendar.MINUTE) {\n            done = true; // If target is MINUTE, don't truncate minutes\n        }\n\n        // truncate minutes\n        if (!done) {\n           // done logic implies field is HOUR or larger\n           if (originalMinutes > 0) {\n                time = time - (originalMinutes * 60000L); // Subtract original minutes in milliseconds\n           }\n        }\n\n        // reset time only if modified\n        if (date.getTime() != time) {\n            date.setTime(time); // date now represents the time truncated below the target field (or minute/hour)\n            val.setTime(date); // val is updated with truncated values for ms, second, minute\n        }\n        // ----------------- Fix for LANG-59 / LANG-346 --------------- END -----------------\n\n        boolean roundUp = false; // This flag carries the round-up decision from the previous field iteration\n        for (int i = 0; i < fields.length; i++) {\n            int currentFieldGroup = fields[i][0]; // The primary field for this group (e.g., Calendar.MILLISECOND)\n\n            // Determine roundUp decision to apply to the current field group, based on the *previous* field processed.\n            // Use pre-calculated values for fields affected by the initial truncation block.\n            boolean useCalculatedRoundUp = false;\n            if (currentFieldGroup == Calendar.SECOND) { // Current field is SECOND, roundUp is based on MILLISECOND\n                 roundUp = roundUpMillis;\n                 useCalculatedRoundUp = true;\n            } else if (currentFieldGroup == Calendar.MINUTE) { // Current field is MINUTE, roundUp is based on SECOND\n                 roundUp = roundUpSeconds;\n                 useCalculatedRoundUp = true;\n            } else if (currentFieldGroup == Calendar.HOUR_OF_DAY) { // Current field is HOUR_OF_DAY, roundUp is based on MINUTE\n                 roundUp = roundUpMinutes;\n                 useCalculatedRoundUp = true;\n                 // Note: HOUR is an alias in fields[i], HOUR_OF_DAY is primary (fields[i][0])\n            }\n\n            // Check if the target field is in the current group\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    // This is our target field. Apply roundUp calculated in the previous iteration (or derived from pre-calculated values).\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            // Special case: SEMI_MONTH\n                            // If date is 1, round up to 16. Otherwise (presumably 16 after truncation/rounding), subtract 15 and add 1 month.\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            // General case: add 1 to the primary field of the group\n                            // Note: This potentially rolls over adjacent fields (e.g. minute to hour) automatically.\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    // We've processed the target field (or decided not to round it), return.\n                    return;\n                }\n            } // End inner loop (checking aliases for target field)\n\n            // --- Process fields smaller than the target field ---\n\n            // We need to calculate `roundUp` for the *next* iteration (if applicable) based on the current field group,\n            // and ensure the current field is set to its minimum value (zeroed out).\n\n            int offset = 0;\n            boolean offsetSet = false; // Tracks if offset/roundUp calculation was handled by special case\n\n            // Special rounding rules for SEMI_MONTH and AM_PM targets affect how roundUp is calculated\n            // when processing DATE or HOUR_OF_DAY respectively.\n            switch (field) { // Check the *target* field\n                case DateUtils.SEMI_MONTH:\n                    if (currentFieldGroup == Calendar.DATE) { // Current field group is DATE, target is SEMI_MONTH\n                        // Calculate offset based on current DATE in val (which should be 1 after truncation/rounding effects)\n                        offset = val.get(Calendar.DATE) - 1; // val.getActualMinimum(Calendar.DATE) is 1\n                        // This offset is relative to the start of the month. Adjust for semi-month boundary.\n                        if (offset >= 15) {\n                            offset -= 15; // Offset within the second half (0-15 typically)\n                        }\n                        // Calculate roundUp for SEMI_MONTH based on DATE's position within its half-month. Midpoint is 7.5 days. Round up if offset > 7?\n                        roundUp = offset > 7; // This roundUp flag will be used when i loops to MONTH/SEMI_MONTH group\n                        offsetSet = true; // Mark that roundUp is calculated for the next step\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (currentFieldGroup == Calendar.HOUR_OF_DAY) { // Current field group is HOUR_OF_DAY, target is AM_PM\n                        // Calculate offset based on original HOUR_OF_DAY for AM/PM rounding decision\n                        offset = originalHourOfDay; // Use original hour\n                        if (offset >= 12) {\n                            offset -= 12; // Offset within the AM/PM half (0-11)\n                        }\n                        // Calculate roundUp for AM_PM based on HOUR's position. Midpoint is 6 hours. Round up if offset > 6?\n                        roundUp = offset > 6; // This roundUp flag will be used when i loops to DATE/AM_PM group\n                        offsetSet = true; // Mark that roundUp is calculated for the next step\n                    }\n                    break;\n            }\n\n            // Calculate roundUp for the general case (for the next field group up)\n            // unless roundUp was determined by pre-calculated values (useCalculatedRoundUp) or special cases (offsetSet).\n            if (!useCalculatedRoundUp && !offsetSet) {\n                 int min = val.getActualMinimum(currentFieldGroup);\n                 int max = val.getActualMaximum(currentFieldGroup);\n                 // Calculate offset based on the *current* value in val (which should be minimum if field < HOUR).\n                 // This determines if the current field's original value was past the midpoint, to round the next higher field.\n                 offset = val.get(currentFieldGroup) - min;\n                 // Check if offset is more than half the range. (> rather than >= is correct here for rounding up).\n                 roundUp = offset > ((max - min) / 2); // Set roundUp flag for next iteration\n            }\n            // If useCalculatedRoundUp=true, roundUp was already set correctly based on original values of lower fields.\n            // If offsetSet=true, roundUp was already set correctly by special SEMI_MONTH/AM_PM logic based on DATE/HOUR.\n\n            // Ensure the current field group is set to its minimum value (zeroed out).\n            // The initial truncation block handled fields below HOUR_OF_DAY.\n            // This loop needs to zero out fields from HOUR_OF_DAY up to the one below the target field.\n            if (currentFieldGroup >= Calendar.HOUR_OF_DAY) {\n                // Check if the field is already at its minimum value.\n                int min = val.getActualMinimum(currentFieldGroup);\n                if (val.get(currentFieldGroup) != min) {\n                    val.set(currentFieldGroup, min); // Set to minimum\n                }\n            }\n\n        } // End main loop\n\n        // Should never normally reach here, means field is not supported.\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}