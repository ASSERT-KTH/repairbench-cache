{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     *\n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n\n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 / LANG-346 ---------------------- START ---------------\n        // Manually modify milliseconds, seconds and minutes fields for rounding/truncation.\n        // This avoids potentially incorrect modifications by Calendar#add(int, int)\n        // when smaller fields are rolled over, particularly across DST boundaries.\n\n        Date date = val.getTime(); // Store original date object\n        long time = date.getTime(); // Get initial time in milliseconds\n        long originalTime = time; // Keep original time for comparison later\n        boolean done = false;\n\n        // MILLISECONDS\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            // truncate milliseconds\n            time = time - millisecs;\n        } else {\n            // round up milliseconds\n            time = time - millisecs + 1000L; // adds a second\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        // SECONDS\n        // Need to get the second value based on the time after millisecond modification\n        Calendar workingCal = null; // Use a working calendar only if needed\n        if (!done) {\n            // We need a Calendar object to handle time zones and DST correctly when getting fields\n            workingCal = Calendar.getInstance(val.getTimeZone()); // Use original timezone\n            workingCal.setTimeInMillis(time); // Set time potentially modified by millis round/truncate\n            int seconds = workingCal.get(Calendar.SECOND); // Get seconds from potentially modified time\n\n            if (!round || seconds < 30) {\n                // truncate seconds\n                time = time - (seconds * 1000L);\n            } else {\n                // round up seconds\n                time = time - (seconds * 1000L) + 60000L; // adds a minute\n            }\n            if (field == Calendar.MINUTE) {\n                done = true;\n            }\n        }\n\n        // MINUTES\n        // Need to get the minute value based on the time after second modification\n        if (!done) {\n            // Reuse or create working calendar\n            if (workingCal == null) {\n                 workingCal = Calendar.getInstance(val.getTimeZone());\n            }\n             workingCal.setTimeInMillis(time); // Update time in working calendar\n            int minutes = workingCal.get(Calendar.MINUTE); // Get minutes from potentially modified time\n\n            if (!round || minutes < 30) {\n                // truncate minutes\n                time = time - (minutes * 60000L);\n            } else {\n                // round up minutes\n                time = time - (minutes * 60000L) + 3600000L; // adds an hour\n            }\n            // Note: Fields from HOUR upwards are handled by the main loop below.\n            // We don't set done=true here; the time modification propagates into the main loop.\n        }\n\n        // Reset time in the original Calendar object if it changed\n        if (time != originalTime) {\n            // Set the new time millisecond value into the original Date object\n            date.setTime(time);\n            // Set the Calendar's time using the modified Date object.\n            // This is crucial as it forces the Calendar to recalculate its fields\n            // based on the potentially rounded/truncated time, considering time zone and DST.\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 / LANG-346 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        // Loop modifies fields from smallest (milliseconds) up to the target field.\n        // It clears smaller fields and determines if the target field needs rounding up.\n        for (int i = 0; i < fields.length; i++) {\n            // Check each field level defined in the fields array\n            for (int j = 0; j < fields[i].length; j++) {\n                int currentFieldInIter = fields[i][j]; // The specific Calendar constant (e.g., Calendar.SECOND)\n\n                // Check if this field constant matches the target field\n                 if (currentFieldInIter == field) {\n                    // This is our target field level. Apply rounding if needed and return.\n                    if (round && roundUp) {\n                        // If roundUp is true (determined by the previous field level processed),\n                        // we need to increment the target field.\n                        if (field == DateUtils.SEMI_MONTH) {\n                            // Special case for SEMI_MONTH rounding\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else if (field == Calendar.AM_PM) {\n                             // If rounding up to AM/PM boundary (noon or midnight), add 12 hours.\n                             // The roundUp flag was set based on HOUR_OF_DAY in the previous iteration.\n                             val.add(Calendar.HOUR_OF_DAY, 12);\n                        } else {\n                            // General case: add 1 unit to the primary field of this level.\n                            // fields[i][0] is assumed to be the primary field (e.g., HOUR_OF_DAY for hours).\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    return; // Target field processed, exit modify method.\n                }\n            } // End inner loop (checking synonyms like HOUR/HOUR_OF_DAY)\n\n            // --- We are processing a field level SMALLER than the target field ---\n            // We need to:\n            // 1. Determine if this level's value requires rounding up the *next* level (set roundUp flag).\n            // 2. Set this field level to its minimum value (truncate).\n\n            int offset = 0;\n            boolean offsetSet = false;\n            // fields[i][0] is the primary field constant for the current level (e.g., Calendar.SECOND)\n            int primaryField = fields[i][0];\n\n            // Skip clearing/roundUp calculation for levels already handled by the LANG-59 fix block?\n            // The fix block already potentially rounded up and set the final time.\n            // The val.setTime(date) call updated the Calendar fields.\n            // Example: Rounding to HOUR. Fix block calculates time for xx:00:00 or (xx+1):00:00.\n            // val is set to this time.\n            // Loop processes MILLISECOND: val.get(MILLISECOND) is 0. min=0, max=999. offset=0. roundUp=false. Clears field (no-op).\n            // Loop processes SECOND: val.get(SECOND) is 0. min=0, max=59. offset=0. roundUp=false. Clears field (no-op).\n            // Loop processes MINUTE: val.get(MINUTE) is 0. min=0, max=59. offset=0. roundUp=false. Clears field (no-op).\n            // Loop processes HOUR level: Target found, returns.\n            // Conclusion: The logic below correctly handles fields >= HOUR and correctly finds offset=0/roundUp=false\n            //             for fields < HOUR because the LANG-59 block already zeroed them (or rounded up).\n\n            // Special rounding logic depends on the *target* field, applied when processing the\n            // field level just below the target.\n            switch (field) { // Switch on the *target* field\n                case DateUtils.SEMI_MONTH:\n                    // If target is SEMI_MONTH, check when processing DATE level\n                    if (primaryField == Calendar.DATE) {\n                        offset = val.get(Calendar.DATE) - 1; // 0-based offset from day 1\n                        if (offset >= 15) { // If in second half (day 16+)\n                            offset -= 15;   // Offset within second half (0-15)\n                        }\n                        // Round up if offset > 7 (i.e., day 9-15 or day 24+)\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    // If target is AM_PM, check when processing HOUR_OF_DAY level\n                     // Assumes fields array has {Calendar.HOUR_OF_DAY, Calendar.HOUR} for this level\n                    if (primaryField == Calendar.HOUR_OF_DAY) {\n                        offset = val.get(Calendar.HOUR_OF_DAY); // 0-23\n                        if (offset >= 12) { // If PM (12-23)\n                            offset -= 12;   // Offset within AM/PM cycle (0-11)\n                        }\n                        // Round up if hour is 6 or more within the AM/PM cycle (6-11 or 18-23)\n                        roundUp = offset >= 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // If not a special rounding case, calculate offset and roundUp based on min/max\n            if (!offsetSet) {\n                int min = val.getActualMinimum(primaryField);\n                int max = val.getActualMaximum(primaryField);\n                offset = val.get(primaryField) - min;\n                // Round up if the value is more than halfway between min and max\n                roundUp = offset > ((max - min) / 2);\n            }\n\n            // Truncate the current field level by setting it to its minimum value.\n            // Only set if the value is not already the minimum.\n            if (val.get(primaryField) != val.getActualMinimum(primaryField)) {\n                 val.set(primaryField, val.getActualMinimum(primaryField));\n            }\n        } // End outer loop (iterating through field levels)\n\n        // Should never reach here if the fields array covers all supported Calendar constants + custom ones\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}