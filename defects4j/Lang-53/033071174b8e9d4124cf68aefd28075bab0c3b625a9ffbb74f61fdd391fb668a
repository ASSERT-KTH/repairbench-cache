{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) {\n            time = time - millisecs;\n        }\n        // This if statement was likely intended to be outside the above if block,\n        // allowing done to be set regardless of truncation/rounding condition.\n        // As per source, it's NOT in braces, so it's a separate statement.\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        // Similar placement as above\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            int offset = 0; // Moved declaration here, scope for each major field group\n            boolean offsetSet = false; // Moved declaration here\n\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    //This is our field... we stop looping\n\n                    // Special cases for SEMI_MONTH and AM_PM (LANG-346 related fix)\n                    // The original code calculated offset/roundUp *after* the `return`\n                    // block. This is a common refactoring issue.\n                    // This section should calculate `offset` and `roundUp` for the current field.\n                    switch (field) { // Note: this is the target 'field', not fields[i][0]\n                        case DateUtils.SEMI_MONTH:\n                            if (fields[i][0] == Calendar.DATE) { // if the current processing field is DATE\n                                offset = val.get(Calendar.DATE) - 1;\n                                if (offset >= 15) {\n                                    offset -= 15;\n                                }\n                                roundUp = offset > 7;\n                                offsetSet = true;\n                            }\n                            break;\n                        case Calendar.AM_PM:\n                            if (fields[i][0] == Calendar.HOUR_OF_DAY) { // if the current processing field is HOUR_OF_DAY\n                                offset = val.get(Calendar.HOUR_OF_DAY);\n                                if (offset >= 12) {\n                                    offset -= 12;\n                                }\n                                roundUp = offset > 6;\n                                offsetSet = true;\n                            }\n                            break;\n                    }\n                    if (!offsetSet) {\n                        int min = val.getActualMinimum(fields[i][0]);\n                        int max = val.getActualMaximum(fields[i][0]);\n                        offset = val.get(fields[i][0]) - min;\n                        roundUp = offset > ((max - min) / 2); // This is the roundUp for *this* field.\n                    }\n\n                    if (round && roundUp) { // Use the `roundUp` calculated for this field\n                        if (field == DateUtils.SEMI_MONTH) {\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n\n                    // Always truncate the target field to its minimum value after potential rounding up\n                    // This was missing for the target field itself, leading to values like 08:01:00\n                    if (offset != 0) { // If there's an offset from minimum\n                         val.set(fields[i][0], val.get(fields[i][0]) - offset);\n                    } else { // If offset is 0, ensure it's set to minimum (e.g. 0)\n                         val.set(fields[i][0], val.getActualMinimum(fields[i][0]));\n                    }\n                    \n                    return; // Return after processing the target field\n                }\n            }\n            // If not the target field, perform truncation for this field and update roundUp for the next.\n            // This part is for fields *lower* than the target field.\n            // These lines were originally after the inner loop and before the `switch` for target field.\n            // They are moved here to be within the outer loop for each fields[i] group.\n            switch (field) { // This switch handles rounding behavior of 'lower' fields affecting the 'target' field.\n                case DateUtils.SEMI_MONTH: // When target field is SEMI_MONTH\n                    if (fields[i][0] == Calendar.DATE) { // current field is DATE\n                        offset = val.get(Calendar.DATE) - 1;\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM: // When target field is AM_PM\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) { // current field is HOUR_OF_DAY\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) { // Default calculation for fields not matching special cases\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                offset = val.get(fields[i][0]) - min;\n                roundUp = offset > ((max - min) / 2);\n            }\n            // Truncate this field to its minimum\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}