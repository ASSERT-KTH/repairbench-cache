{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods.\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate milliseconds\n        int millisecs = val.get(Calendar.MILLISECOND);\n        if (!round || millisecs < 500) { // If truncating or rounding down milliseconds\n            time = time - millisecs;\n        }\n        if (field == Calendar.SECOND) { // Stop truncation logic if SECOND is the target field\n            done = true;\n        }\n\n        // truncate seconds\n        int seconds = val.get(Calendar.SECOND);\n        // Only truncate seconds if the target field is MINUTE or larger\n        // and we are truncating or rounding down seconds\n        if (!done && (!round || seconds < 30)) {\n            time = time - (seconds * 1000L);\n        }\n        if (field == Calendar.MINUTE) { // Stop truncation logic if MINUTE is the target field\n             done = true;\n        }\n\n        // truncate minutes\n        int minutes = val.get(Calendar.MINUTE);\n        // Only truncate minutes if the target field is HOUR or larger\n        // and we are truncating or rounding down minutes\n        if (!done && (!round || minutes < 30)) {\n            time = time - (minutes * 60000L);\n        }\n\n        // reset time\n        // NOTE: We only need to update the Calendar object if the time has actually changed\n        //       during this initial truncation phase.\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date); // This updates the Calendar object for the main loop\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        // Main rounding/truncation loop\n        for (int i = 0; i < fields.length; i++) {\n             // Iterate through the fields to be zeroed (smaller than the target field)\n            for (int j = 0; j < fields[i].length; j++) {\n                // Check if we've found the target field\n                if (fields[i][j] == field) {\n                    // If we are rounding and the previous field processing indicated\n                    // a round-up condition, then increment the target field.\n                    if (round && roundUp) {\n                        if (field == DateUtils.SEMI_MONTH) {\n                            // Special case for SEMI_MONTH\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            // General case: Add 1 to the target field\n                            // (fields[i][0] is the primary field in the current group)\n                            val.add(fields[i][0], 1);\n                        }\n                    }\n                    // Target field reached, processing complete.\n                    return;\n                }\n            } // End of inner loop\n\n            // We are processing a field level smaller than the target field.\n            // We need to determine the offset from the minimum value\n            // and whether to round up the next higher field (handled by roundUp flag).\n            int offset = 0;\n            boolean offsetSet = false;\n\n            // Handle special rounding cases (SEMI_MONTH, AM_PM)\n            switch (field) { // Check if the *target* field requires special handling\n                             // when clearing *lower* fields.\n                case DateUtils.SEMI_MONTH:\n                    // If the target is SEMI_MONTH, and we are currently processing the DATE field level\n                    if (fields[i][0] == Calendar.DATE) {\n                        // Calculate offset for DATE field relative to start of month (1-based)\n                        offset = val.get(Calendar.DATE) - 1;\n                        // Adjust offset for the second half of the month (16-31)\n                        if (offset >= 15) {\n                            offset -= 15; // Offset within the 15-day period (0-14 or 0-15 typically)\n                        }\n                        // Round up if offset is past the midpoint (7.5 days -> > 7)\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                     // If the target is AM_PM, and we are currently processing the HOUR_OF_DAY field level\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        // Calculate offset for HOUR_OF_DAY relative to start of AM/PM period (0-11)\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) { // Adjust for PM hours\n                            offset -= 12;\n                        }\n                        // Round up if offset is past the midpoint (6 hours -> > 6)\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // If not a special case handled above\n            if (!offsetSet) {\n                // Get the minimum and maximum values for the primary field of the current level (e.g., Calendar.SECOND)\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                // Calculate the offset from the minimum value\n                offset = val.get(fields[i][0]) - min;\n                // Determine if we need to round up based on whether the offset is more than half the range\n                roundUp = offset > ((max - min) / 2);\n            }\n\n            // If there's an offset (meaning the field is not already at its minimum),\n            // subtract the offset to zero/floor this field using set().\n            if (offset != 0) {\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        } // End of outer loop\n\n        // If the loop completes without finding the field, it's unsupported.\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}