{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n// Required imports if these helpers are not in the same class or static imports are not used:\n// import org.apache.commons.lang3.StringUtils;\n\n// Assume the following helper methods exist and function correctly:\n// StringUtils.isBlank(String)\n// createInteger(String) -> Creates Integer/Long/BigInteger, handles hex/octal/decimal like decode()\n// createLong(String) -> Creates Long\n// createBigInteger(String) -> Creates BigInteger\n// createFloat(String) -> Creates Float\n// createDouble(String) -> Creates Double\n// createBigDecimal(String) -> Creates BigDecimal\n\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    // lang-3 does not have StringUtils.isBlank\n    // Replace StringUtils.isBlank with manual check for null or whitespace-only strings\n    // if (StringUtils.isBlank(str)) {\n    if (str.trim().isEmpty()) { // Simple replacement, assumes trim is acceptable performance-wise\n                                 // Or iterate through string to check for non-whitespace chars if trim is too slow/allocates too much.\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // LANG-574 blocks -- parsing\n    if (str.startsWith(\"--\")) {\n        // Leading -- is rejected by new BigDecimal(String) in Java 7+\n        // and seems unintended for this method. Throw NFE for clarity.\n         throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n    // Hexadecimal handling (0x/-0x or 0X/-0X)\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n         // Check for minimum length (sign + 0x + digit)\n         int sign = (str.startsWith(\"-\") ? 1 : 0);\n         if(str.length() <= sign + 2) { // e.g. \"0x\", \"-0X\"\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n         // Basic check for invalid hex chars after 0x. Further validation delegated.\n         for (int i = sign + 2; i < str.length(); i++) {\n             char c = str.charAt(i);\n             if ((c < '0' || c > '9') && (c < 'a' || c > 'f') && (c < 'A' || c > 'F')) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n         }\n        // Assuming createInteger handles hex conversion and returns Integer/Long/BigInteger\n        return createInteger(str);\n    }\n\n    char lastChar = str.charAt(str.length() - 1);\n    String numeric; // Part of string excluding the qualifier\n    boolean hasQualifier = false;\n\n    // Check for type qualifiers L,l,F,f,D,d at the end of the string\n    if (Character.isLetter(lastChar) && lastChar != 'e' && lastChar != 'E') {\n        numeric = str.substring(0, str.length() - 1); // String without the qualifier\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                // Validate Long qualifier: numeric part must not contain ., e, E\n                if (numeric.indexOf('.') != -1 || numeric.indexOf('e') != -1 || numeric.indexOf('E') != -1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                 // Check numeric is not empty or just a sign (\"-L\" is invalid)\n                if (numeric.isEmpty() || (numeric.length() == 1 && (numeric.charAt(0) == '-' || numeric.charAt(0) == '+'))) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                hasQualifier = true;\n                break; // Valid L/l qualifier\n            case 'f':\n            case 'F':\n            case 'd':\n            case 'D':\n                // Float/Double qualifiers allow ., e, E.\n                // Check numeric is not empty or just a sign (\"-f\" is invalid)\n                 if (numeric.isEmpty() || (numeric.length() == 1 && (numeric.charAt(0) == '-' || numeric.charAt(0) == '+'))) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                // Further validation delegated to createFloat/Double/BigDecimal\n                hasQualifier = true;\n                break; // Valid F/f/D/d qualifier\n            default:\n                // Any other trailing letter is invalid\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        // No letter qualifier found. Check for other invalid trailing characters.\n        // Allows digits, '.', or '+'/' -' if part of an exponent.\n        if (lastChar == '+' || lastChar == '-') {\n            // Trailing sign must be part of an exponent\n            int expPos = str.lastIndexOf('e'); // Find the last exponent marker\n             if (expPos == -1) {\n                 expPos = str.lastIndexOf('E');\n             }\n             // If a trailing sign exists, it must immediately follow the exponent marker.\n             if (expPos != str.length() - 2) {\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n        } else if (lastChar != '.' && !Character.isDigit(lastChar)) {\n            // Any other non-digit, non- '.' trailing char is invalid (covers cases missed above)\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // No qualifier, use the full string as the numeric part\n        numeric = str;\n    }\n\n    if (hasQualifier) {\n        // --- Qualified Number Parsing ---\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                // Structure already validated. Try Long, then BigInteger for range.\n                try {\n                    return createLong(numeric);\n                } catch (NumberFormatException nfe) {\n                    // If createLong fails (likely range issue), use BigInteger\n                    return createBigInteger(numeric);\n                }\n            case 'f':\n            case 'F':\n                try {\n                    Float f = createFloat(numeric);\n                    // Check for infinity and precision loss (using BigDecimal)\n                    if (!f.isInfinite()) {\n                        // Return if non-zero, OR if zero and BigDecimal confirms it's truly zero\n                        if (f.floatValue() != 0.0F || new BigDecimal(numeric).signum() == 0) {\n                            return f;\n                        }\n                        // Else: Float is 0.0 but original string was non-zero -> precision loss, fall through\n                    }\n                    // Fall through if infinite or precision loss occurred\n                } catch (NumberFormatException nfe) { /* Fall through */ }\n                 // FALLTHROUGH intended for F/f -> D/d -> BigDecimal\n            case 'd':\n            case 'D':\n                try {\n                    Double d = createDouble(numeric);\n                    // Check for infinity and precision loss (using BigDecimal)\n                    if (!d.isInfinite()) {\n                        // Use doubleValue() and check if truly zero via BigDecimal\n                        if (d.doubleValue() != 0.0D || new BigDecimal(numeric).signum() == 0) {\n                            return d;\n                        }\n                         // Else: Double is 0.0 but original string was non-zero -> precision loss, fall through\n                    }\n                    // Fall through if infinite or precision loss occurred\n                } catch (NumberFormatException nfe) { /* Fall through */ }\n                // Final fallback: BigDecimal for D/d, or if F/f fell through\n                try {\n                    // BigDecimal constructor does not accept type qualifiers. Use 'numeric'.\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // If createBigDecimal fails, the numeric string is fundamentally invalid.\n                    // Throw NFE based on the original input string for clarity.\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n        }\n        // Should be unreachable due to switch logic\n        throw new AssertionError(\"Unreachable code after qualifier switch.\");\n\n    } else {\n        // --- Non-qualified Number Parsing ---\n        // Determine type (integer vs float/double/decimal) from structure.\n        int decPos = numeric.indexOf('.');\n        int expPos = numeric.lastIndexOf('e'); // Use lastIndexOf to catch multiple exponents like \"1e2e3\"\n        if (expPos == -1) {\n            expPos = numeric.lastIndexOf('E');\n        }\n\n        // Basic structural validation for non-qualified numbers\n        if (expPos > -1) {\n             // Exponent marker cannot be first char (unless after sign) or last char\n             if (expPos == numeric.length() - 1 || expPos == 0 || (expPos == 1 && (numeric.charAt(0)=='+' || numeric.charAt(0)=='-'))) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             // Exponent marker cannot appear before a decimal point (\"1e2.3\" is invalid)\n             // Note: This also catches multiple exponent markers if lastIndexOf is used.\n              if (expPos < decPos && decPos != -1) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n              }\n             // Check char immediately after exponent indicator is digit or sign\n             char charAfterExp = numeric.charAt(expPos + 1);\n             if (charAfterExp != '+' && charAfterExp != '-' && !Character.isDigit(charAfterExp)) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             // Check that sign in exponent is followed by digits\n             if ((charAfterExp == '+' || charAfterExp == '-') && expPos == numeric.length() - 2) {\n                 throw new NumberFormatException(str + \" is not a valid number.\"); // e.g. \"1e+\"\n             }\n        }\n        // Check for multiple decimal points? Delegated to createX methods.\n\n        // If no decimal point AND no exponent -> Integer style\n        // Exception: Trailing decimal point (\"123.\") treated as floating point below.\n        if (decPos == -1 && expPos == -1) {\n            if (lastChar == '.') {\n                // Treat \"123.\" as floating point -> fall through to logic below\n            } else {\n                // Integer type: Try Integer -> Long -> BigInteger\n                // Rely on createX methods for full validation (e.g., reject \"123a\")\n                try {\n                    // Assuming createInteger handles Integer/Long/BigInteger pathway\n                    return createInteger(numeric);\n                } catch (NumberFormatException nfe) { /* ignore */ }\n                try {\n                    return createLong(numeric);\n                } catch (NumberFormatException nfe) { /* ignore */ }\n                // Final fallback for integer-style numbers\n                return createBigInteger(numeric);\n            }\n        }\n\n        // Has decimal point OR exponent OR ends with '.' -> Float/Double/BigDecimal style\n        try {\n            Float f = createFloat(numeric);\n            // Check for infinity and precision loss (using BigDecimal)\n            if (!f.isInfinite()) {\n                 // Handle \"2.\" -> createFloat(\"2.\") returns 2.0f. signum(\"2.\")=1. Returns f. OK.\n                if (f.floatValue() != 0.0f || new BigDecimal(numeric).signum() == 0) {\n                    return f;\n                }\n                 // Else: precision loss, fall through\n            }\n             // Fall through if infinite or precision loss\n        } catch (NumberFormatException nfe) { /* Fall through */ }\n        try {\n            Double d = createDouble(numeric);\n            if (!d.isInfinite()) {\n                 if (d.doubleValue() != 0.0d || new BigDecimal(numeric).signum() == 0) {\n                     return d;\n                 }\n                 // Else: precision loss, fall through\n            }\n             // Fall through if infinite or precision loss\n        } catch (NumberFormatException nfe) { /* Fall through */ }\n        // Final fallback for float/double/decimal styles\n        try {\n             return createBigDecimal(numeric);\n        } catch (NumberFormatException e) {\n             // If BigDecimal fails here, the string structure is fundamentally invalid.\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}