{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport org.apache.commons.lang3.StringUtils;\n\n// Assume necessary helper methods like isDigits, isAllZeros, createFloat, createDouble, etc., exist in the actual class context.\n// The following definition includes the fixed createNumber method.\n\npublic class NumberUtils { // Placeholder class definition\n\n    // --- Assume helper methods like these exist ---\n    private static boolean isDigits(String str) {\n        if (StringUtils.isEmpty(str)) return false;\n        for (char c : str.toCharArray()) if (!Character.isDigit(c)) return false;\n        return true;\n    }\n    private static boolean isAllZeros(String str) {\n        if (str == null) return true; // Treat null as all zeros\n        for (char c : str.toCharArray()) if (c != '0') return false;\n        return !str.isEmpty(); // Treat empty string as true (no non-zero digits)\n    }\n    private static Float createFloat(String str) { return Float.valueOf(str); }\n    private static Double createDouble(String str) { return Double.valueOf(str); }\n    private static Integer createInteger(String str) { return Integer.decode(str); } // decode handles 0x, 0, # prefixes\n    private static Long createLong(String str) { return Long.decode(str); } // decode handles 0x, 0, # prefixes\n    private static BigInteger createBigInteger(String str) {\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             int index = str.startsWith(\"-\") ? 3 : 2;\n             // Ensure the hex part is not empty after removing prefix\n             if (index >= str.length()) {\n                 throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n             }\n             return new BigInteger(str.substring(index), 16);\n        }\n        return new BigInteger(str);\n    }\n    private static BigDecimal createBigDecimal(String str) { return new BigDecimal(str); }\n    // --- End of assumed helper methods ---\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear\n            // to be in specification of class. OS X Java parses it to\n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             // Use createBigInteger for hex parsing, as it handles arbitrary size and base 16.\n             // Note: Relies on a createBigInteger implementation that handles \"0x\" prefix.\n             // If createInteger/Long handle hex adequately, original code might be sufficient,\n             // but BigInteger is safer for potentially large hex values.\n            try {\n                 return createBigInteger(str);\n             } catch (NumberFormatException nfe) {\n                  // If BigInteger parsing itself fails for hex format\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             } catch (Exception e) { // Catch other potential exceptions from BigInteger\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n        }\n        final char lastChar = str.charAt(str.length() - 1);\n        final String mant;\n        final String dec;\n        final String exp;\n        final int decPos = str.indexOf('.');\n        // final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // Original buggy line\n        final int expPos = Math.max(str.indexOf('e'), str.indexOf('E')); // FIX 1: Correct exponent position calculation\n\n        // Validate positions, check for invalid formats like \".e1\", \"1e\", \"1.\", \".\"\n        if (expPos > -1) {\n             // Exponent cannot be final char, must be digit/sign after 'e'/'E'\n             if (expPos == str.length() - 1) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             // Exponent cannot come before decimal point\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n             // Check for sign after exponent indicator that is the last character\n             final char expSignChar = str.charAt(expPos + 1);\n             if ((expSignChar == '+' || expSignChar == '-') && expPos + 1 == str.length() - 1) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n        }\n        // Reject \".\" or \"-.\" alone\n        if (decPos > -1 && str.length() == decPos + 1) { // Ends in \".\"\n             if (str.length() == 1 || (str.length() == 2 && str.charAt(0) == '-')) {\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n         }\n\n\n        // Parse mantissa and decimal part\n        if (decPos > -1) {\n            if (expPos > -1) {\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1); // Handles trailing \".\" (substring(len) -> \"\")\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n\n        if (Character.isLetter(lastChar) && lastChar != 'e' && lastChar != 'E') {\n            // Type qualifier present\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            final String numeric = str.substring(0, str.length() - 1);\n            // Use original isAllZeros check logic (mantissa and exponent)\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n            switch (lastChar) {\n                case 'l' : case 'L' :\n                    // Check for valid long format (no decimal, no exponent in numeric part, digits only)\n                    if (dec == null && exp == null && (numeric.startsWith(\"-\") ? isDigits(numeric.substring(1)) : isDigits(numeric))) {\n                         try {\n                            // Use createLong for parsing potential octal/hex if createLong handles it\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) {\n                             // Fallback for large numbers\n                             // Use createBigInteger which should handle large integers\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n                case 'f' : case 'F' :\n                    try {\n                        final Float f = createFloat(numeric);\n                         // Check for NaN/Infinity/precision loss\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0f && !allZeros))) {\n                            // Additional check: ensure value didn't become NaN if numeric wasn't \"NaN\"\n                            if (f.isNaN() && !\"NaN\".equalsIgnoreCase(numeric)) {\n                                // Fall through if parsing resulted in NaN unexpectedly\n                            } else {\n                                return f;\n                            }\n                        }\n                    } catch (final NumberFormatException nfe) {\n                        // Fall through\n                    }\n                    // Fallthrough intended\n\n                case 'd' : case 'D' :\n                    try {\n                        final Double d = createDouble(numeric);\n                        // Check for NaN/Infinity/precision loss - FIX 2: Use doubleValue()\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0d && !allZeros))) {\n                             // Additional check: ensure value didn't become NaN if numeric wasn't \"NaN\"\n                             if (d.isNaN() && !\"NaN\".equalsIgnoreCase(numeric)) {\n                                 // Fall through if parsing resulted in NaN unexpectedly\n                             } else {\n                                 return d;\n                             }\n                        }\n                    } catch (final NumberFormatException nfe) {\n                        // Fall through\n                    }\n                    try {\n                        // Last resort for F/f/D/d is BigDecimal\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) {\n                        // If BigDecimal fails, throw NFE below\n                    }\n                    // Fallthrough intended\n\n                default : // Invalid qualifier\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n             // Only reached if fallthrough from F/D fails BigDecimal parsing\n            throw new NumberFormatException(str + \" is not a valid number.\");\n\n        } else {\n            // No type qualifier (last char is digit or '.')\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1);\n            } else {\n                exp = null;\n            }\n            // Use original isAllZeros check logic (mantissa and exponent)\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n            if (dec == null && exp == null) {\n                // Integer type\n                try {\n                    // Use createInteger for parsing potential octal/hex if createInteger handles it\n                    return createInteger(str);\n                } catch (final NumberFormatException nfe) { /* Ignore */ }\n                try {\n                    // Use createLong for parsing potential octal/hex if createLong handles it\n                    return createLong(str);\n                } catch (final NumberFormatException nfe) { /* Ignore */ }\n                 // Use createBigInteger which should handle large integers\n                return createBigInteger(str);\n\n            } else {\n                // Float/Double/BigDecimal type\n                try {\n                    final Float f = createFloat(str);\n                     // Check for NaN/Infinity/precision loss\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0f && !allZeros))) {\n                         if (f.isNaN() && !\"NaN\".equalsIgnoreCase(str)) {\n                             // Ignore if parsing resulted in NaN unexpectedly\n                         } else {\n                             return f;\n                         }\n                    }\n                } catch (final NumberFormatException nfe) { /* Ignore */ }\n                try {\n                    final Double d = createDouble(str);\n                     // Check for NaN/Infinity/precision loss - FIX 2: Use doubleValue()\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0d && !allZeros))) {\n                         if (d.isNaN() && !\"NaN\".equalsIgnoreCase(str)) {\n                             // Ignore if parsing resulted in NaN unexpectedly\n                         } else {\n                             return d;\n                         }\n                    }\n                } catch (final NumberFormatException nfe) { /* Ignore */ }\n                return createBigDecimal(str);\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}