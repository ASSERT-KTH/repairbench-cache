{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n// NOTE: The following imports would be needed based on the context\n// import org.apache.commons.lang3.StringUtils;\n\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can represent the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * or exponent and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code>, <code>0X</code>, <code>#</code>,\n * or leading zero, it will be interpreted using {@link Integer#decode(String)},\n * {@link Long#decode(String)} or {@link BigInteger#BigInteger(String, int)}.\n * The input string must not have a type qualifier suffix for these forms.\n * (Modification: Hex numbers with 'L' suffix are handled). </p>\n *\n * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n *\n * <p>This method does not trim the input string, i.e., strings with leading\n * or trailing spaces will generate NumberFormatExceptions.</p>\n *\n * @param str  String containing a number, may be null\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    // lang-3 requirement: reject blank strings\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // -- LANG-1006 avoid potential issues with BigDecimal constructor for values like \"\" or \"-\"\n    final String trimmed = str.trim(); // Used for specific checks, original str used for parsing\n    if (trimmed.startsWith(\"--\")) {\n        // BigDecimal constructor parses \"--\" as 0 but fails on \"--1.1\"\n        // Return null to keep compatibility with previous behavior for \"--\"\n        // But throw for other \"--\" cases, consistent with most parsers failing double sign\n        if (str.equals(\"--\")) {\n            return null;\n        } else {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        // Handle Hexadecimal Numbers\n        int startDigits = (str.startsWith(\"-\") ? 3 : 2); // Index past \"0x\" or \"-0x\"\n        if (str.length() <= startDigits) { // Case like \"0x\" or \"-0X\"\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        final char lastChar = str.charAt(str.length() - 1);\n        final boolean isLong = (lastChar == 'l' || lastChar == 'L');\n        final String hexString = isLong ? str.substring(0, str.length() - 1) : str;\n\n        // Ensure hex part is not empty after stripping 'L'\n        if (isLong && hexString.length() <= startDigits) { // Case like \"0xL\" or \"-0XL\"\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        // Use standard decode methods which handle \"0x\" prefix and potential ranges\n        try {\n            // Try Long first as it covers Integer range and handles large hex\n            // Long.decode handles the sign and \"0x\" prefix.\n             return Long.decode(hexString);\n        } catch (final NumberFormatException nfeLong) {\n             // If Long.decode fails (e.g., too large), try BigInteger\n             // BigInteger constructor needs hex string without prefix, handle sign separately\n             String digits = hexString.substring(startDigits);\n             BigInteger bigIntResult;\n             try {\n                 bigIntResult = new BigInteger(digits, 16);\n             } catch (final NumberFormatException nfeBig) {\n                 // If BigInteger also fails, the format is invalid\n                 throw new NumberFormatException(\"For input string: \\\"\" + str + \"\\\"\"); // Match JVM error style\n             }\n             // Apply sign if needed\n             if (hexString.startsWith(\"-\")) {\n                 bigIntResult = bigIntResult.negate();\n             }\n             return bigIntResult;\n        }\n    }\n\n    // Standard Number Parsing (non-hex)\n    final char lastChar = str.charAt(str.length() - 1);\n    final boolean hasQualifier = (lastChar == 'f' || lastChar == 'F' || lastChar == 'd' || lastChar == 'D' || lastChar == 'l' || lastChar == 'L');\n    // Use original string for parsing, but strip qualifier for logic checks and specific parsers\n    final String numberStr = hasQualifier ? str.substring(0, str.length() - 1) : str;\n\n    // Early exit for simple invalid formats after stripping qualifier\n    if (numberStr.isEmpty() || numberStr.equals(\".\") || numberStr.equals(\"-\") || numberStr.equals(\"+\")) {\n         throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n\n    final int decPos = numberStr.indexOf('.');\n    final int expPos = Math.max(numberStr.indexOf('e'), numberStr.indexOf('E'));\n\n    // --- Start Structural Validation of numberStr ---\n    // LANG-638: Exponent validation\n    if (expPos > -1) {\n        if (expPos + 1 >= numberStr.length()) { // Exponent marker is last char (\"1e\", \"1.0e\")\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // Check char immediately after exponent marker\n        final char charAfterExp = numberStr.charAt(expPos + 1);\n        final boolean validExpChar = (charAfterExp == '+' || charAfterExp == '-' || Character.isDigit(charAfterExp));\n        if (!validExpChar) {\n             throw new NumberFormatException(str + \" is not a valid number.\"); // e.g. \"1e.\", \"1ea\"\n        }\n        // Ensure exponent part itself has digits after potential sign\n        String expPart = numberStr.substring(expPos + 1);\n        if (expPart.length() > 0 && (expPart.charAt(0) == '+' || expPart.charAt(0) == '-')) {\n            expPart = expPart.substring(1); // Check digits after sign\n        }\n        if (expPart.isEmpty() || !expPart.chars().allMatch(Character::isDigit)) {\n             throw new NumberFormatException(str + \" is not a valid number.\"); // e.g. \"1e+\", \"1e-\", \"1e+a\"\n        }\n\n        if (decPos > -1 && expPos < decPos) { // Exponent marker before decimal (\"1e2.3\")\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n    // Decimal point validation\n    if (decPos > -1) {\n         // Check for multiple decimal points\n         if (numberStr.indexOf('.', decPos + 1) != -1) {\n              throw new NumberFormatException(str + \" is not a valid number.\"); // e.g. \"1.2.3\"\n         }\n    }\n    // --- End Structural Validation ---\n\n\n    // --- Prepare for isAllZeros check (used for Float/Double precision fallback) ---\n    // Based on the structure of numberStr\n    String mant, dec, exp;\n    if (decPos > -1) {\n        // Re-calculate effective exponent position for splitting based on potentially validated numberStr\n        final int effExpPos = Math.max(numberStr.indexOf('e'), numberStr.indexOf('E'));\n        if (effExpPos > -1) { // Has decimal and exponent\n            mant = numberStr.substring(0, decPos);\n            dec = numberStr.substring(decPos + 1, effExpPos);\n            exp = numberStr.substring(effExpPos + 1);\n        } else { // Has decimal, no exponent\n            mant = numberStr.substring(0, decPos);\n            dec = numberStr.substring(decPos + 1);\n            exp = null;\n        }\n    } else { // No decimal\n        final int effExpPos = Math.max(numberStr.indexOf('e'), numberStr.indexOf('E'));\n        if (effExpPos > -1) { // No decimal, has exponent\n            mant = numberStr.substring(0, effExpPos);\n            dec = null;\n            exp = numberStr.substring(effExpPos + 1);\n        } else { // No decimal, no exponent\n            mant = numberStr;\n            dec = null;\n            exp = null;\n        }\n    }\n    // Assumes isAllZeros helper handles null/empty/sign correctly\n    final boolean allZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp);\n\n\n    // --- Main Parsing Logic ---\n    if (hasQualifier) {\n        // Use 'numberStr' (without qualifier) for parsing qualified types\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                // Long format: No decimal, no exponent, digits (optional leading '-')\n                 if (decPos == -1 && expPos == -1 &&\n                     (numberStr.matches(\"-?\\\\d+\"))) { // Check basic integer format\n                    try {\n                        return Long.valueOf(numberStr);\n                    } catch (final NumberFormatException nfe) {\n                        // Fallback for numbers larger than Long.MAX_VALUE\n                        return new BigInteger(numberStr);\n                    }\n                 }\n                throw new NumberFormatException(str + \" is not a valid number.\"); // Invalid format for 'L'\n\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = Float.valueOf(numberStr);\n                    // Prevent returning 0.0f if the input string had non-zeros (precision loss)\n                    // Also prevent returning Infinity if Double/BigDecimal might work\n                    if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                        return f;\n                    }\n                    // Fall through if Float is Inf or zero due to precision loss\n                } catch (final NumberFormatException nfe) {\n                     // Fall through if Float format is invalid (e.g., range)\n                }\n                // Fallthrough intended\n\n            case 'd':\n            case 'D':\n                try {\n                    final Double d = Double.valueOf(numberStr);\n                    // Prevent returning 0.0d if the input string had non-zeros (precision loss)\n                    // Also prevent returning Infinity if BigDecimal might work\n                    if (!(d.isInfinite() || d.doubleValue() == 0.0D && !allZeros)) {\n                         return d;\n                    }\n                    // Fall through if Double is Inf or zero due to precision loss\n                } catch (final NumberFormatException nfe) {\n                     // Fall through if Double format is invalid (e.g., range)\n                }\n                // Fallthrough intended\n\n                // Try BigDecimal as last resort for F/D qualifiers\n                try {\n                     // Handles ranges beyond Float/Double and avoids precision loss for zero\n                    return new BigDecimal(numberStr);\n                } catch (final NumberFormatException ignored) {\n                    // If BigDecimal also fails after F/D failed/fell-through\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            default:\n                 // Should not happen with current qualifiers\n                throw new NumberFormatException(str + \" is not a valid number.\"); // Should be unreachable\n        }\n\n    } else {\n        // No qualifier: Try Integer -> Long -> BigInteger OR Float -> Double -> BigDecimal\n        // Use 'numberStr' for parsing here as well\n        if (expPos == -1 && decPos == -1) {\n             // Looks like an integer type\n             try {\n                 return Integer.valueOf(numberStr);\n             } catch (final NumberFormatException nfeInt) {\n                 try {\n                     return Long.valueOf(numberStr);\n                 } catch (final NumberFormatException nfeLong) {\n                     try {\n                         return new BigInteger(numberStr);\n                     } catch (final NumberFormatException nfeBig) {\n                         // If all integer types fail, throw exception\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n                 }\n             }\n        } else {\n            // Looks like a floating point type\n            // LANG-521: Handle trailing decimal point \"2.\" correctly -> parsed as Float/Double/BigDecimal\n            try {\n                final Float f = Float.valueOf(numberStr);\n                 // Prevent 0.0f due to precision loss if !allZeros\n                 // Do not return Float.Inf/-Inf if Double/BigDecimal might work\n                 if (!(f.isInfinite() || f.floatValue() == 0.0F && !allZeros)) {\n                    return f;\n                }\n            } catch (final NumberFormatException nfeFloat) {\n                // ignore, try Double\n            }\n            try {\n                final Double d = Double.valueOf(numberStr);\n                 // Prevent 0.0d due to precision loss if !allZeros\n                 // Do not return Double.Inf/-Inf if BigDecimal might work\n                 if (!(d.isInfinite() || d.doubleValue() == 0.0D && !allZeros)) {\n                     return d;\n                 }\n            } catch (final NumberFormatException nfeDouble) {\n                 // ignore, try BigDecimal\n            }\n            try {\n                // Final fallback for floating point numbers\n                return new BigDecimal(numberStr);\n            } catch (final NumberFormatException e) {\n                 // If Float/Double/BigDecimal all fail, the format is invalid\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n    }\n}\n\n// Helper methods assumed to exist in the same class or be imported (like StringUtils.isBlank)\n\n/**\n * <p>Checks if the string contains only Unicode digits.</p>\n * A decimal point is not a Unicode digit and returns false.\n * Used by createNumber.\n * @param str the String to check, may be null\n * @return true if only contains digits, false otherwise\n */\n// static boolean isDigits(final String str) { ... } // Replace with regex or keep original\n\n/**\n * <p>Checks if the string represents all zeros.</p>\n * Handles optional sign. Used by createNumber.\n * @param str the string to check, may be null or empty\n * @return true if represents zero, false otherwise\n */\nprivate static boolean isAllZeros(String str) {\n    if (str == null || str.isEmpty()) {\n        return true; // Treat null/empty as zero for this check's purpose\n    }\n    int start = 0;\n    if (str.charAt(0) == '-' || str.charAt(0) == '+') {\n        if (str.length() == 1) return false; // Only sign\n        start = 1;\n    }\n    for (int i = start; i < str.length(); i++) {\n        if (str.charAt(i) != '0' && str.charAt(i) != '.') { // Allow decimal point in zero check? Original didn't parse parts fully. Let's allow '.'\n             if (str.charAt(i) == '.') continue; // Allow decimal point within zero parts\n             return false; // Found a non-zero digit\n        }\n    }\n    // Check if it was just \".\" or \"-.\" or \"+.\"\n    if(str.matches(\"[\\\\-\\\\+]?\\\\.+\")) return false; // String was only sign and/or dots\n\n    return true; // All characters were '0' or '.' (after optional sign)\n}\n\n// Dummy StringUtils for compilation if needed\nprivate static class StringUtils {\n    public static boolean isBlank(final CharSequence cs) {\n        int strLen;\n        if (cs == null || (strLen = cs.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(cs.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}