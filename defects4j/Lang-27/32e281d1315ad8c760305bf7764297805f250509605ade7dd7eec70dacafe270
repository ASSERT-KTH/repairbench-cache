{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assuming access to org.apache.commons.lang3.StringUtils\nimport org.apache.commons.lang3.StringUtils;\n\n// Assuming helper methods (isDigits, isAllZeros, create*) are defined in the actual class.\n// For context, minimal implementations might be:\n// private static boolean isDigits(String str) { ... } // Checks if string contains only digits\n// private static boolean isAllZeros(String str) { ... } // Checks if string contains only '0's (or is null/empty)\n// private static Integer createInteger(String str) { return Integer.valueOf(str); } // Or Integer.decode(str) if needed elsewhere\n// private static Long createLong(String str) { return Long.valueOf(str); }\n// private static BigInteger createBigInteger(String str) { return new BigInteger(str); }\n// private static Float createFloat(String str) { return Float.valueOf(str); }\n// private static Double createDouble(String str) { return Double.valueOf(str); }\n// private static BigDecimal createBigDecimal(String str) { return new BigDecimal(str); }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code>, <code>0X</code>, <code>#</code>,\n     * <code>-0x</code>, <code>-0X</code>, or <code>-#</code> (representing hex),\n     * it will be interpreted using {@link BigInteger#BigInteger(String, int)}.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n\n        // Simplified handling of hex prefixes\n        if (str.startsWith(\"0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0x\") || str.startsWith(\"-0X\") || str.startsWith(\"#\")) {\n            int sign = str.startsWith(\"-\") ? -1 : 1;\n            String hexdigits;\n            if (sign == -1) { // Check prefix after sign\n                 if (str.startsWith(\"0x\", 1) || str.startsWith(\"0X\", 1)) {\n                     hexdigits = str.substring(3);\n                 } else if (str.startsWith(\"#\", 1)) {\n                     hexdigits = str.substring(2);\n                 } else { // Should not happen with outer check, but safeguard\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n            } else { // Check prefix at start\n                if (str.startsWith(\"0x\") || str.startsWith(\"0X\")) {\n                    hexdigits = str.substring(2);\n                } else { // Starts with #\n                    hexdigits = str.substring(1);\n                }\n            }\n\n            if (hexdigits.isEmpty()) {\n                 throw new NumberFormatException(str + \" is not a valid number.\"); // e.g., \"0x\", \"-#\"\n            }\n\n            try {\n                // Use BigInteger for hex, then check if it fits Long/Integer\n                BigInteger val = new BigInteger(hexdigits, 16);\n                if (sign == -1) {\n                    val = val.negate();\n                }\n                // Check if it fits in Long\n                if (val.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0 && val.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) >= 0) {\n                    // Check if it fits in Integer\n                    if (val.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) <= 0 && val.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) >= 0) {\n                        return Integer.valueOf(val.intValue());\n                    }\n                    return Long.valueOf(val.longValue());\n                }\n                // Doesn't fit Long, return BigInteger\n                return val;\n            } catch (NumberFormatException e) {\n                // Invalid hex digits\n                throw new NumberFormatException(str + \" is not a valid number. \" + e.getMessage());\n            }\n        }\n\n        // Standard Number Parsing (Non-Hex)\n        final char lastChar = str.charAt(str.length() - 1);\n        final String mant;\n        final String dec;\n        final String exp;\n\n        final int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        // String representing the number, without potential type suffix\n        String numeric = str;\n        boolean hasSuffix = false;\n        // Check for type suffix (L, F, D)\n        if (Character.isLetter(lastChar) && lastChar != 'e' && lastChar != 'E') {\n            final char suffixUpper = Character.toUpperCase(lastChar);\n            if (suffixUpper == 'L' || suffixUpper == 'D' || suffixUpper == 'F') {\n                // Check for invalid structure like \"1eL\" or \"-L\"\n                if (expPos != -1 && expPos == str.length() - 2) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                if (str.length() == 1 || (str.length() == 2 && (str.charAt(0) == '+' || str.charAt(0) == '-'))) {\n                    throw new NumberFormatException(str + \" is not a valid number.\"); // e.g. \"L\", \"-L\"\n                }\n                hasSuffix = true;\n                numeric = str.substring(0, str.length() - 1); // Remove suffix\n            } else {\n                // Invalid trailing letter\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n        // Validate structure of the 'numeric' string part\n        final int decPosNumeric = numeric.indexOf('.');\n        int expPosNumeric = numeric.indexOf('e');\n        if (expPosNumeric == -1) {\n            expPosNumeric = numeric.indexOf('E');\n        }\n\n        // Basic structural checks on 'numeric' string\n        if (expPosNumeric > -1) {\n            // Cannot end with 'e'/'E'\n            if (expPosNumeric == numeric.length() - 1) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            // Cannot have 'e' immediately after sign unless part of number like \"-e\" or \"+e\"\n            if (expPosNumeric == 0 || ((numeric.startsWith(\"-\") || numeric.startsWith(\"+\")) && expPosNumeric == 1)) {\n                // Allow only if sign belongs to the number itself, not exponent, handled by parsers.\n                // But explicitly disallow \"e1\", \"-e1\" etc. where e is first meaningful char.\n                 if (!Character.isDigit(numeric.charAt(expPosNumeric - (numeric.startsWith(\"-\")||numeric.startsWith(\"+\") ? 2:1 ))) && numeric.charAt(expPosNumeric - (numeric.startsWith(\"-\")||numeric.startsWith(\"+\") ? 2:1 )) != '.')\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            // Exponent must appear after decimal point if both exist\n            if (decPosNumeric > -1 && expPosNumeric < decPosNumeric) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n        // Cannot have multiple decimal points\n        if (decPosNumeric > -1 && numeric.indexOf('.', decPosNumeric + 1) != -1) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // Cannot have multiple exponent markers\n        if (expPosNumeric > -1) {\n             int ePos2 = numeric.indexOf('e', expPosNumeric + 1);\n             if (ePos2 == -1) ePos2 = numeric.indexOf('E', expPosNumeric + 1);\n             if (ePos2 != -1) {\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n        }\n         // Cannot end with a sign unless part of exponent\n         if (numeric.endsWith(\"+\") || numeric.endsWith(\"-\")) {\n             if (expPosNumeric != numeric.length() - 2) {\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n         }\n         // Protect against \"--\" cases within the numeric part if not caught earlier\n         if (numeric.contains(\"--\") || numeric.contains(\"+-\") || numeric.contains(\"-+\")) {\n             // Check if it's part of exponent e.g., \"1e-1\" is valid\n             int badSeq = numeric.indexOf(\"--\");\n             if (badSeq == -1) badSeq = numeric.indexOf(\"+-\");\n             if (badSeq == -1) badSeq = numeric.indexOf(\"-+\");\n             if (badSeq != -1 && badSeq != expPosNumeric + 1) { // Allow if immediately after 'e'/'E'\n                  throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n         }\n\n        // Split the 'numeric' string for the allZeros check\n        if (decPosNumeric > -1) {\n            if (expPosNumeric > -1) {\n                mant = numeric.substring(0, decPosNumeric);\n                dec = numeric.substring(decPosNumeric + 1, expPosNumeric);\n                exp = numeric.substring(expPosNumeric + 1);\n            } else {\n                mant = numeric.substring(0, decPosNumeric);\n                dec = numeric.substring(decPosNumeric + 1);\n                exp = null;\n            }\n        } else { // No decimal point in numeric\n            if (expPosNumeric > -1) {\n                mant = numeric.substring(0, expPosNumeric);\n                dec = null;\n                exp = numeric.substring(expPosNumeric + 1);\n            } else {\n                mant = numeric;\n                dec = null;\n                exp = null;\n            }\n        }\n\n        // Calculate allZeros based on mantissa/decimal/exponent parts derived from the 'numeric' string\n        String mantAndDec = mant + (dec == null ? \"\" : dec);\n        // Remove sign for allZeros check\n        if (!mantAndDec.isEmpty() && (mantAndDec.charAt(0) == '-' || mantAndDec.charAt(0) == '+')) {\n            mantAndDec = mantAndDec.substring(1);\n        }\n        String expDigits = exp;\n        if (expDigits != null && !expDigits.isEmpty() && (expDigits.charAt(0) == '-' || expDigits.charAt(0) == '+')) {\n            expDigits = expDigits.substring(1);\n        }\n        // isAllZeros: true if null, empty, or only '0' digits\n        final boolean allZeros = isAllZeros(mantAndDec) && isAllZeros(expDigits);\n\n\n        // --- Parsing Logic ---\n        if (hasSuffix) {\n            final char suffixUpper = Character.toUpperCase(lastChar);\n            switch (suffixUpper) {\n                case 'L':\n                    // Ensure L suffix is only for integer types (no '.', no 'e') in the 'numeric' part\n                    if (decPosNumeric != -1 || expPosNumeric != -1) {\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                    // Validate integer format using helper (on numeric part)\n                    String intDigits = numeric;\n                     if (!intDigits.isEmpty() && (intDigits.charAt(0) == '-' || intDigits.charAt(0) == '+')) {\n                         intDigits = intDigits.substring(1);\n                     }\n                     if (!isDigits(intDigits)) { // Check digits after potential sign removal\n                          throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n\n                    // Try Long, then BigInteger on the 'numeric' part\n                    try {\n                        // Use createLong for consistency\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) { /* Fall through */ }\n                    try {\n                        return createBigInteger(numeric);\n                    } catch (final NumberFormatException e2) {\n                        // Should not happen if structure passed initial checks\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n\n                case 'F':\n                    try {\n                        final Float f = createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (final NumberFormatException nfe) {\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                    // $FALL-THROUGH$\n                case 'D':\n                    try {\n                        final Double d = createDouble(numeric);\n                        // Fixed: use d.doubleValue()\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) {\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                    // $FALL-THROUGH$\n                // Try BigDecimal for F/D cases if Float/Double failed or had issues\n                try {\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            }\n        } else { // No Suffix\n            // Determine if it looks like integer or float based on presence of '.' or 'e'/'E' in the *original* string\n            final boolean looksLikeInteger = decPos == -1 && expPos == -1;\n\n            if (looksLikeInteger) {\n                // Validate integer format using helper (on original string)\n                 String intDigits = str;\n                 if (!intDigits.isEmpty() && (intDigits.charAt(0) == '-' || intDigits.charAt(0) == '+')) {\n                     intDigits = intDigits.substring(1);\n                 }\n                 if (!isDigits(intDigits)) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n\n                // Try Integer -> Long -> BigInteger using the original string 'str'\n                try {\n                    return createInteger(str); // Use appropriate createInteger method (handles decode?)\n                } catch (final NumberFormatException nfe) { /* ignore */ }\n                try {\n                    return createLong(str);\n                } catch (final NumberFormatException nfe) { /* ignore */ }\n                try {\n                    return createBigInteger(str);\n                } catch (final NumberFormatException e2) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            } else { // Looks like float/double/decimal (has '.' or 'e'/'E')\n                // Try Float -> Double -> BigDecimal using the original string 'str'\n                try {\n                    final Float f = createFloat(str);\n                    // Handle trailing '.' which becomes NaN by checking isNaN\n                    if (!f.isNaN() && !(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (final NumberFormatException nfe) { /* ignore */ }\n                try {\n                    final Double d = createDouble(str);\n                     // Handle trailing '.' which becomes NaN by checking isNaN\n                    if (!d.isNaN() && !(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (final NumberFormatException nfe) { /* ignore */ }\n                try {\n                    // BigDecimal handles trailing '.' correctly, and is the final fallback\n                    return createBigDecimal(str);\n                } catch (final NumberFormatException e2) {\n                    throw new NumberFormatException(str + \" is not a valid number.\"); // Final attempt failed\n                }\n            }\n        }\n        // Should not be reachable due to exhaustive checks/returns/throws\n        throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n\n    // --- Assume helper methods are defined in the actual class ---\n    // Required signature for isAllZeros (based on its usage)\n    private static boolean isAllZeros(String str) {\n        if (str == null || str.isEmpty()) {\n            return true;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Required signature for isDigits (based on its usage)\n    private static boolean isDigits(final String str) {\n         if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         for (int i = 0; i < str.length(); i++) {\n             if (!Character.isDigit(str.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n\n     // Assume create* methods map to standard Java parsing methods:\n     private static Integer createInteger(String s) { return Integer.valueOf(s); }\n     private static Long createLong(String s) { return Long.valueOf(s); }\n     private static BigInteger createBigInteger(String s) { return new BigInteger(s); }\n     private static Float createFloat(String s) { return Float.valueOf(s); }\n     private static Double createDouble(String s) { return Double.valueOf(s); }\n     private static BigDecimal createBigDecimal(String s) { return new BigDecimal(s); }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}