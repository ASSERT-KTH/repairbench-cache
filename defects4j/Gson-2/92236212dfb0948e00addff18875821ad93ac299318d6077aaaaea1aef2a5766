{
    "generation": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n\n        // The 'typeAdapter' is for the base type T1 (e.g., JsonElement).\n        // The 'requestedType' is T2, which is T1 or a subtype of T1 (e.g., JsonObject).\n        // The original code directly cast TypeAdapter<T1> to TypeAdapter<T2>,\n        // which could lead to ClassCastException if the JSON content was for a different\n        // subtype (e.g., JsonPrimitive) than the requested T2 (e.g., JsonObject).\n        // We need to ensure that the object read by the base type adapter is indeed\n        // an instance of the requested type T2.\n\n        final TypeAdapter<T1> checkedAdapter = typeAdapter; // The adapter for the base type T1\n\n        // Return a new TypeAdapter<T2> that wraps the original typeAdapter.\n        // This wrapper will perform the necessary runtime type check during deserialization.\n        return new TypeAdapter<T2>() {\n          @Override\n          public void write(JsonWriter out, T2 value) throws IOException {\n            // It's safe to cast T2 to T1 since T2 is a subtype of T1 (or T1 itself).\n            checkedAdapter.write(out, (T1) value);\n          }\n\n          @Override\n          public T2 read(JsonReader in) throws IOException {\n            // Read the JSON content using the adapter for the base type T1.\n            T1 result = checkedAdapter.read(in);\n\n            // If the result is not null and is not an instance of the requested type T2,\n            // throw a JsonSyntaxException. This handles cases like expecting JsonObject\n            // but receiving a JsonPrimitive.\n            if (result != null && !requestedType.isInstance(result)) {\n              throw new com.google.gson.JsonSyntaxException(\n                  \"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName());\n            }\n\n            // If the type matches (or result is null), it's safe to cast T1 to T2.\n            @SuppressWarnings(\"unchecked\") // Safe due to the isInstance check above.\n            T2 castResult = (T2) result;\n            return castResult;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}