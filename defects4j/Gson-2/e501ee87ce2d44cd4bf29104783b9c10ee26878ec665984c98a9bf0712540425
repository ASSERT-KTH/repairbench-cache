{
    "generation": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n\n        // The original `typeAdapter` is for `T1` (the base class in the hierarchy).\n        // We need to return a `TypeAdapter` for `T2` (the specific subtype requested).\n        // This new adapter wraps the original `typeAdapter` and adds the necessary\n        // runtime type check as described in the Javadoc.\n        final TypeAdapter<T1> hierarchyAdapter = typeAdapter;\n\n        return new TypeAdapter<T2>() {\n          @Override\n          public void write(JsonWriter out, T2 value) throws IOException {\n            // T2 is either T1 or a subtype of T1 (checked by clazz.isAssignableFrom(requestedType)).\n            // Therefore, casting `value` from `T2` to `T1` is safe for writing.\n            hierarchyAdapter.write(out, (T1) value);\n          }\n\n          @Override\n          public T2 read(JsonReader in) throws IOException {\n            // Read the object using the base adapter for T1.\n            T1 result = hierarchyAdapter.read(in);\n\n            // Perform the runtime check: confirm that the deserialized `result`\n            // is an instance of the `requestedType` (T2).\n            // If `result` is null, it's generally considered valid for any type.\n            if (result == null || requestedType.isInstance(result)) {\n              // If the object is null or an instance of the requested type, it's valid.\n              // The cast to T2 is safe because we just verified it with `isInstance`.\n              return (T2) result;\n            } else {\n              // If the deserialized object's actual type does not match the requested type,\n              // throw a JsonSyntaxException, as per the test case's expectation.\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n                  + \" but was \" + result.getClass().getName());\n            }\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}