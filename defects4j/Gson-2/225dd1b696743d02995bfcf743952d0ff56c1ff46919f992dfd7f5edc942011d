{
    "generation": "  /**\n   * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n   * that the deserialized type matches the type requested.\n   */\n  public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n      final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n    return new TypeAdapterFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n        final Class<? super T2> requestedType = typeToken.getRawType();\n        if (!clazz.isAssignableFrom(requestedType)) {\n          return null;\n        }\n\n        // The original typeAdapter is for T1.\n        // We need an adapter for T2, which is a subtype of T1.\n        // This adapter must ensure that the deserialized object is indeed an instance of T2.\n        // The original code returned (TypeAdapter<T2>) typeAdapter directly, which was unsafe\n        // because typeAdapter<T1> might deserialize to a type that is a T1 but not a T2.\n        // For example, if T1 is JsonElement and T2 is JsonObject, an adapter for JsonElement\n        // might read a JsonPrimitive, leading to a ClassCastException if expected as JsonObject.\n        final TypeAdapter<T1> chosenAdapter = typeAdapter;\n\n        return new TypeAdapter<T2>() {\n          @Override\n          public void write(JsonWriter out, T2 value) throws java.io.IOException {\n            // If T2 is a subtype of T1 (which it is, because requestedType.isAssignableFrom(clazz) is true),\n            // then 'value' (T2) can be safely cast to T1 for writing.\n            chosenAdapter.write(out, (T1) value);\n          }\n\n          @Override\n          public T2 read(com.google.gson.stream.JsonReader in) throws java.io.IOException {\n            // Read the object as T1 using the base adapter.\n            T1 result = chosenAdapter.read(in);\n\n            // If the result is not null, ensure it's an instance of the requested type T2.\n            // This is the runtime check that prevents ClassCastException.\n            if (result != null && !requestedType.isInstance(result)) {\n              // This indicates a type mismatch. Throw a JsonSyntaxException as expected by tests.\n              throw new com.google.gson.JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName());\n            }\n\n            // If result is null, or if requestedType.isInstance(result) was true,\n            // then the cast from T1 to T2 is safe.\n            return (T2) result;\n          }\n        };\n      }\n      @Override public String toString() {\n        return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}