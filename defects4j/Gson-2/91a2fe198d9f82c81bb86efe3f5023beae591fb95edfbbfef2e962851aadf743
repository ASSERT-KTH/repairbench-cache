{
    "generation": "/**\n * Returns a factory for all subtypes of {@code typeAdapter}. We do a runtime check to confirm\n * that the deserialized type matches the type requested.\n */\npublic static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n    final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n  return new TypeAdapterFactory() {\n    @SuppressWarnings(\"unchecked\")\n    public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n      final Class<? super T2> requestedType = typeToken.getRawType();\n      if (clazz.isAssignableFrom(requestedType)) {\n        // Create a new TypeAdapter that wraps the original typeAdapter\n        // and performs the necessary casting.\n        return new TypeAdapter<T2>() {\n          @Override\n          public void write(JsonWriter out, T2 value) throws IOException {\n            typeAdapter.write(out, (T1) value);\n          }\n\n          @Override\n          public T2 read(JsonReader in) throws IOException {\n            T1 tempValue = typeAdapter.read(in);\n            if (requestedType.isInstance(tempValue)) {\n              return (T2) tempValue;\n            } else {\n              throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + tempValue.getClass().getName());\n            }\n          }\n        };\n      }\n      return null;\n    }\n\n    @Override\n    public String toString() {\n      return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n    }\n  };\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}