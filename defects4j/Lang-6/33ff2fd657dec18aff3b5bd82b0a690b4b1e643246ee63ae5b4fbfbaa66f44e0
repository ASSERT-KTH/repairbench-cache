{
    "generation": "    for (int pt = 0; pt < consumed; pt++) {\n        pos += Character.charCount(Character.codePointAt(input, pos));\n    }\n    ```\n    If `translate` returns `consumed > 0`, it means `consumed` characters have already been processed. The `pos` should simply be advanced by `consumed`.\n    However, the loop attempts to re-evaluate how many `char`s correspond to codepoints *starting from the current `pos` in each iteration*. This is problematic:\n    *   If `consumed` is 1 (e.g., a single BMP character), the loop runs once, `Character.charCount(Character.codePointAt(input, pos))` returns 1, and `pos` advances by 1. This works.\n    *   If `consumed` is 2 (e.g., a surrogate pair was consumed by the `translate` method), the loop runs twice.\n        *   In the first iteration (`pt = 0`), `Character.codePointAt(input, pos)` reads the start of the surrogate pair, `Character.charCount` returns 2. `pos` is advanced by 2.\n        *   In the second iteration (`pt = 1`), `pos` has *already* been advanced by 2. Now `Character.codePointAt(input, pos)` attempts to read at `pos + 2` relative to its original starting point. If the input string itself had only 2 characters (like a single surrogate pair), this access will go out of bounds, leading to `StringIndexOutOfBoundsException`.\n\n**The Fix:**\nWhen `translate` returns `consumed` characters, it means exactly that: `consumed` characters have been processed. Therefore, `pos` should simply be incremented by `consumed`.\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}