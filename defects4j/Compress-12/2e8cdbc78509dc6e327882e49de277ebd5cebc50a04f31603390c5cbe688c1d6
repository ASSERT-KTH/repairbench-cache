{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            /* Skip refers to backing map entries, not underlying stream positions */\n            long numToSkip = entrySize - entryOffset;\n\n            // System.out.println(\"TarAIS.read() skipping: \" + numToSkip);\n\n            // DEV-40: Small files are read/skipped at once. Should be partial too.\n            if (numToSkip > 0) {\n                skip(numToSkip);\n//                long skipped = skip(numToSkip);\n//                if (skipped != numToSkip) {\n//                     BUG!                // TODO:                             IOUtils.skip() returns -1 if EOF, so we should check for that.\n//                    throw new IOException(\"Possible tar file corruption: failed to skip \" + numToSkip\n//                                          + \" bytes from entry \" + currEntry.getName());\n//                }\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n        // System.out.println(\"TarAIS.read() - found entry: '\" + currEntry.getName() + \"'\");\n\n        entryOffset = 0;\n        // COMPRESS-156: tar formats allow for null blocks further inside the stream\n        entrySize = currEntry.getSize();\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value. We are adding the line here as we need\n        // to read the entry header to get to the size information.\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long link entry name not followed by entry\n                return null;\n            }\n            currEntry.setLinkName(new String(longLinkData, 0, longLinkData.length - 1));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            currEntry.setName(new String(longNameData, 0, longNameData.length - 1));\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}