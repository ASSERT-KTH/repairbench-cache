{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n\n            // After skipping all data for the current entry,\n            // we must also skip any padding bytes to reach the next record boundary.\n            // The 'skip' method defined in this class only skips data bytes within the entry,\n            // not padding. The padding is part of the physical block layout of tar.\n            long bytesToSkipForPadding = TarUtils.alignSize(entrySize) - entrySize;\n            if (bytesToSkipForPadding > 0) {\n                long skipped = 0;\n                while (skipped < bytesToSkipForPadding) {\n                    // Read dummy bytes to advance the underlying stream and update the total bytes read.\n                    // Using recordBuf as a temporary buffer.\n                    long rem = bytesToSkipForPadding - skipped;\n                    int readLen = (int)Math.min(recordBuf.length, rem);\n                    long n = is.read(recordBuf, 0, readLen);\n                    if (n < 0) {\n                        // Unexpected EOF while skipping padding\n                        throw new IOException(\"truncated tar archive\");\n                    }\n                    count(n); // Update total bytes read from the archive\n                    skipped += n;\n                }\n            }\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            // After reading the long name data, the 'currEntry' (the long name entry itself)\n            // is still active. The next call to getNextEntry() will process the *actual*\n            // entry whose name was just read. The padding of the long name entry will\n            // be skipped by the logic added at the beginning of this function on the recursive call.\n            TarArchiveEntry nextEntry = getNextTarEntry();\n            if (nextEntry == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by entry\n                return null;\n            }\n            currEntry = nextEntry; // The recursive call sets currEntry, we need to pick it up.\n\n            // remove trailing null terminator\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}