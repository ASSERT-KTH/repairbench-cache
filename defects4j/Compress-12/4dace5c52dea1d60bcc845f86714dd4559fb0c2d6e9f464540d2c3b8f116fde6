{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            // Skip the remaining data of the current entry\n            while (numToSkip > 0) {\n                // Use InputStream.skip method (or overridden version in TarArchiveInputStream)\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    // Keep original exception type as changing it might have unintended consequences\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null; // Reset buffer potentially used by read() method\n        }\n\n        // Read the next 512-byte header record\n        byte[] headerBuf = getRecord();\n\n        // Check if EOF was detected by getRecord() or if the record is null\n        // Assuming getRecord() sets hasHitEOF or returns null at EOF/error\n        if (hasHitEOF || headerBuf == null) {\n            hasHitEOF = true; // Ensure EOF flag is set\n            currEntry = null;\n            return null;\n        }\n\n        // Check if the record is an EOF marker (all zeros). TAR requires two zero blocks at the end.\n        boolean allZeros = true;\n        for (byte b : headerBuf) {\n            if (b != 0) {\n                allZeros = false;\n                break;\n            }\n        }\n        if (allZeros) {\n            hasHitEOF = true; // Detected the first zero block\n            currEntry = null;\n            // Should ideally read and discard the second zero block here,\n            // but for getNextEntry, finding the first is sufficient to signal EOF.\n            return null;\n        }\n\n        // Attempt to parse the header buffer into a TarArchiveEntry\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            // Wrap the parsing exception in an IOException as expected by the API contract\n            // and the failing test (COMPRESS-178)\n            IOException ioe = new IOException(\"Error parsing tar header entry: \" + e.getMessage(), e);\n            // The constructor IOException(String, Throwable) sets the cause.\n            throw ioe;\n        }\n\n        // Initialize entry-specific fields\n        entryOffset = 0; // Start reading from the beginning of the entry data\n        entrySize = currEntry.getSize(); // Store the entry size from the header\n\n        // Handle GNU long name extension (Type 'L')\n        if (currEntry.isGNULongNameEntry()) {\n            // The data of this entry is the long name for the *next* entry.\n            StringBuffer longName = new StringBuffer();\n            // Assuming SMALL_BUFFER_SIZE is defined appropriately elsewhere (e.g., 256 or 512)\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            // The read() method must respect entry boundaries (stop after entrySize bytes).\n            // It reads the data associated with the 'L' type entry.\n            while ((length = read(buf)) >= 0) {\n                // Charset issues might exist here if the name isn't ASCII/default.\n                // Tar headers traditionally use ASCII, but data payload charset can vary.\n                // Assuming default platform encoding works for the long name data.\n                longName.append(new String(buf, 0, length));\n            }\n            // We've consumed the long name entry's data. Now get the *actual* next entry header.\n            getNextEntry(); // Recursive call to process the header following the long name data\n            if (currEntry == null) {\n                // Error case: Archive ends abruptly after a long name entry.\n                // Ref: Bugzilla 40334\n                return null;\n            }\n            // Remove trailing null terminator(s) commonly found in GNU long names.\n            // C strings are null-terminated, and the name data might include it.\n            while (longName.length() > 0\n                   && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            // Apply the retrieved long name to the *actual* entry (now in currEntry).\n            currEntry.setName(longName.toString());\n        }\n\n        // Handle PAX headers (Type 'x' or 'g')\n        // PAX headers contain key-value metadata applying to the *next* entry.\n        // The original code structure calls paxHeaders() *after* assigning currEntry,\n        // implying it modifies the current entry. This might be valid if the PAX data\n        // is stored *within* the entry itself (non-standard) or if paxHeaders()\n        // recursively calls getNextEntry() like the long name handler does.\n        // Assuming the original structure is intended, even if potentially confusing.\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders(); // Assume this method reads the PAX data and updates currEntry's metadata\n                          // It must consume the data portion of the PAX entry.\n        }\n\n        // Handle GNU sparse file headers (Type 'S')\n        // Similar to PAX/LongName, a Type 'S' entry's data contains the sparse map\n        // for the *next* file entry.\n        // Again, assuming the original structure where readGNUSparse() is called\n        // on the *current* entry is intended.\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse(); // Assume this method reads sparse map info from the current entry's data\n                             // and updates currEntry's sparse information.\n        }\n\n        // Final update of entry size, as PAX headers (specifically the 'size' keyword)\n        // can override the size from the original tar header.\n        entrySize = currEntry.getSize();\n\n        // Return the fully processed entry\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}