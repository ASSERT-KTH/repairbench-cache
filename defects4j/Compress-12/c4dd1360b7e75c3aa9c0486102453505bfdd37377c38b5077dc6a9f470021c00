{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            if (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped != numToSkip) {\n                    throw new IOException(\"Failed to skip \" + numToSkip + \" bytes, only skipped \" + skipped);\n                }\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            hasHitEOF = true;\n            currEntry = null;\n            return null;\n        }\n\n        if (TarArchiveEntry.matchesHeader(headerBuf)) {\n            currEntry = new TarArchiveEntry(headerBuf);\n            entryOffset = 0;\n            entrySize = currEntry.getSize();\n\n            if (currEntry.isGNULongNameEntry()) {\n                // read in the name\n                ByteArrayOutputStream longName = new ByteArrayOutputStream();\n                byte[] buf = new byte[SMALL_BUFFER_SIZE];\n                int length;\n                while ((length = read(buf)) >= 0) {\n                    longName.write(buf, 0, length);\n                }\n                getNextEntry();\n                if (currEntry == null) {\n                    // Bugzilla: 40334\n                    // Malformed tar file - long entry name not followed by entry\n                    throw new IOException(\"Malformed tar file - long entry name not followed by entry\");\n                }\n                // remove trailing null terminator\n                byte[] longNameBytes = longName.toByteArray();\n                if (longNameBytes.length > 0 && longNameBytes[longNameBytes.length - 1] == 0) {\n                    currEntry.setName(new String(longNameBytes, 0, longNameBytes.length - 1, \"UTF-8\"));\n                } else {\n                    currEntry.setName(new String(longNameBytes, \"UTF-8\"));\n                }\n            }\n\n            if (currEntry.isPaxHeader()) { // Process Pax headers\n                paxHeaders();\n            }\n\n            if (currEntry.isGNUSparse()) { // Process sparse files\n                readGNUSparse();\n            }\n\n            // If the size of the next element in the archive has changed\n            // due to a new size being reported in the posix header\n            // information, we update entrySize here so that it contains\n            // the correct value.\n            entrySize = currEntry.getSize();\n            return currEntry;\n        } else {\n            throw new IllegalArgumentException(\"Invalid tar header: \" + new String(headerBuf, 0, headerBuf.length < 100 ? headerBuf.length : 100));\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}