{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n            if (numToSkip > 0) { // Only skip if there's remaining data/padding\n                while (numToSkip > 0) {\n                    long skipped = skip(numToSkip);\n                    if (skipped <= 0) {\n                        // This indicates an issue, possibly a corrupt archive\n                        // or that skip did not make progress.\n                        throw new IOException(\"Failed to skip current tar entry, entrySize=\" + entrySize + \", entryOffset=\" + entryOffset + \", numToSkip=\" + numToSkip);\n                    }\n                    numToSkip -= skipped;\n                }\n            }\n            readBuf = null; // Clear internal buffer to ensure next getRecord() reads new block\n        }\n\n        byte[] headerBuf = getRecord(); // Read the potential header for the *next* entry\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf); // Tentatively create current entry\n        entryOffset = 0;\n        entrySize = currEntry.getSize(); // Size of this entry\n\n        // Special handling for GNU long name entries and Pax headers.\n        // These are metadata entries that describe the *next* actual entry.\n        // The common pattern is to read their content, skip their padding,\n        // then read the actual entry's header in the same method invocation.\n        if (currEntry.isGNULongNameEntry()) {\n            // Read the long name content.\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            // The 'read' method limits itself to entrySize, so this loop will stop naturally.\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n\n            // After reading the long name content, ensure the stream is aligned to the next 512-byte block.\n            // entryOffset should equal entrySize here if fully read.\n            long numPadBytes = (512 - (entrySize % 512)) % 512;\n            if (numPadBytes > 0) {\n                long skipped = skip(numPadBytes);\n                if (skipped != numPadBytes) {\n                    throw new IOException(\"Failed to skip padding for GNU long name entry. Expected \" + numPadBytes + \", skipped \" + skipped);\n                }\n            }\n            readBuf = null; // Clear internal buffer to ensure getRecord() reads new block\n            \n            // Now, read the header of the *actual* entry described by the long name.\n            headerBuf = getRecord();\n            if (hasHitEOF) {\n                currEntry = null;\n                return null;\n            }\n            currEntry = new TarArchiveEntry(headerBuf); // This is now the actual entry\n            entryOffset = 0;\n            entrySize = currEntry.getSize(); // Update entrySize for the actual entry\n\n            // Apply the long name to the newly read actual entry\n            if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString());\n\n        } else if (currEntry.isPaxHeader()){ // Process Pax headers\n            // Assuming paxHeaders() reads the content of the PaxHeader entry and\n            // internally stores the parsed headers (e.g., in a map accessible later or modifies currEntry).\n            paxHeaders(); // Reads content of the pax header entry itself\n\n            // After reading the pax header content, ensure the stream is aligned to the next 512-byte block.\n            // entrySize here is still the size of the PaxHeader entry itself.\n            long numPadBytes = (512 - (entrySize % 512)) % 512;\n            if (numPadBytes > 0) {\n                long skipped = skip(numPadBytes);\n                if (skipped != numPadBytes) {\n                    throw new IOException(\"Failed to skip padding for Pax header entry. Expected \" + numPadBytes + \", skipped \" + skipped);\n                }\n            }\n            readBuf = null; // Clear internal buffer for new header\n\n            // Read the header of the *actual* entry described by the Pax headers.\n            headerBuf = getRecord();\n            if (hasHitEOF) {\n                currEntry = null;\n                return null;\n            }\n            TarArchiveEntry nextEntry = new TarArchiveEntry(headerBuf); // This is the actual entry\n\n            // Apply collected pax headers to the actual entry.\n            // This assumes paxHeaders() method sets up necessary internal state,\n            // or modifies the current currEntry object such that it applies to the next entry.\n            // A typical implementation would involve `nextEntry.applyPaxHeadersToEntry(someCollectedMap);`\n            // Given the original void `paxHeaders()` call and subsequent checks on `currEntry`,\n            // we assume `paxHeaders()` implicitly applies headers to the entry being processed.\n            // The critical part here is replacing `currEntry` with `nextEntry`.\n            currEntry = nextEntry; // Replace currEntry with the actual entry\n            entryOffset = 0;\n            entrySize = currEntry.getSize(); // Update entrySize for the actual entry\n\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}