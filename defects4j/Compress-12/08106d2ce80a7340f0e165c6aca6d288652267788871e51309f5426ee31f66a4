{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            // First, skip any remaining data of the *current* entry\n            // entryOffset tracks how much data has been read from currEntry.\n            // entrySize is the total size of currEntry's data.\n            long numToSkip = entrySize - entryOffset;\n\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    throw new RuntimeException(\"failed to skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            // Second, skip the padding bytes to align to the next 512-byte block boundary.\n            // Tar entries are always padded to a multiple of 512 bytes.\n            // This is crucial to ensure that the next call to getRecord() reads a correctly aligned header.\n            long padding = TarUtils.calculatePadding(entrySize);\n            if (padding > 0) {\n                long skippedPadding = skip(padding);\n                if (skippedPadding < padding) {\n                    // This indicates that we couldn't skip all required padding,\n                    // which might mean unexpected EOF or a corrupted archive.\n                    throw new IOException(\"failed to skip padding bytes (\" + skippedPadding + \" instead of \" + padding + \")\");\n                }\n            }\n            \n            readBuf = null; // Clear the read buffer as we are moving to a new entry\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) {\n            currEntry = null;\n            return null;\n        }\n\n        currEntry = new TarArchiveEntry(headerBuf);\n        entryOffset = 0; // Reset offset for the new current entry\n        entrySize = currEntry.getSize(); // Set size for the new current entry\n\n        if (currEntry.isGNULongNameEntry()) {\n            // This entry is a GNU long name entry, its data is the actual long file name.\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            \n            // Read the long name from the current entry's data stream.\n            // The read() method itself ensures entryOffset is updated and respects entrySize.\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));\n            }\n            \n            // After reading the long name data, we must get the *actual* entry that this long name refers to.\n            // This is a recursive call to getNextTarEntry, which will handle skipping the\n            // long name entry's remaining data (which should be zero) and its padding,\n            // then read the header of the next entry (the actual file/directory entry).\n            TarArchiveEntry actualEntry = getNextTarEntry();\n            if (actualEntry == null) {\n                // Bugzilla: 40334 - Malformed tar file - long entry name not followed by entry\n                currEntry = null; // Ensure currEntry is null if actual entry not found\n                return null;\n            }\n            currEntry = actualEntry; // The \"current\" entry is now the actual entry\n\n            // Remove trailing null terminator if present in the long name.\n            if (longName.length() > 0\n                && longName.charAt(longName.length() - 1) == 0) {\n                longName.deleteCharAt(longName.length() - 1);\n            }\n            currEntry.setName(longName.toString()); // Set the long name on the actual entry\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the current entry has been modified by Pax headers or sparse file processing,\n        // we update entrySize here so it contains the correct value for subsequent data reads.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}