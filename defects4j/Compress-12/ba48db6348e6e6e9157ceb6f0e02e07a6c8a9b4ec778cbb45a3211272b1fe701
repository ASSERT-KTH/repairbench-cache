{
    "generation": "    /**\n     * Get the next entry in this tar archive. This will skip\n     * over any remaining data in the current entry, if there\n     * is one, and place the input stream at the header of the\n     * next entry, and read the header and instantiate a new\n     * TarEntry from the header bytes and return that entry.\n     * If there are no more entries in the archive, null will\n     * be returned to indicate that the end of the archive has\n     * been reached.\n     *\n     * @return The next TarEntry in the archive, or null.\n     * @throws IOException on error\n     */\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            long numToSkip = entrySize - entryOffset;\n\n            // Skip the rest of the current entry\n            // This loop is needed as stream skip may not skip requested\n            // number of bytes in one go\n            while (numToSkip > 0) {\n                long skipped = skip(numToSkip);\n                if (skipped <= 0) {\n                    // TarStream should normally skip to the end of the entry\n                    // automatically if the user doesn't read it all, but we include\n                    // this check for safety and robustness against unusual implementations.\n                    // IOException is more appropriate than RuntimeException here.\n                    throw new IOException(\"Possible tar file corruption: failed to fully skip current tar entry\");\n                }\n                numToSkip -= skipped;\n            }\n\n            readBuf = null;\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (hasHitEOF) { // getRecord() may have set hasHitEOF\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf);\n        } catch (IllegalArgumentException e) {\n            // Header block contains invalid data, report it as IOException\n            // This addresses the issue highlighted by testCOMPRESS178\n            throw new IOException(\"Error parsing tar entry header: \" + e.getMessage(), e);\n        }\n        entryOffset = 0;\n        // Must be reset everytime implicitly, with PAX headers isExplicit is important\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongNameEntry()) {\n            // read in the name\n            // GNU long name entries contain the actual name as data\n            byte[] nameBytes = new byte[(int) entrySize];\n            int numToRead = (int) entrySize;\n            int off = 0;\n            while (numToRead > 0) {\n                int numRead = read(nameBytes, off, numToRead);\n                if (numRead == -1) {\n                    throw new IOException(\"Unexpected EOF reading GNU long name data\");\n                }\n                off += numRead;\n                numToRead -= numRead;\n                // entryOffset is updated by read()\n            }\n            // The next entry is the actual entry for the long name\n            getNextEntry(); // Recursive call\n            if (currEntry == null) {\n                // Bugzilla: 40334 - Malformed tar file, long name not followed by entry\n                // Returning null might mask the error, throwing IOException is clearer\n                throw new IOException(\"GNU long name entry is not followed by a regular entry\");\n                // return null; // Original behavior\n            }\n            // Remove trailing null terminator(s)\n            int nameLen = nameBytes.length;\n            while (nameLen > 0 && nameBytes[nameLen - 1] == 0) {\n                nameLen--;\n            }\n            currEntry.setName(new String(nameBytes, 0, nameLen)); // Assumes default charset; consider encoding\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders(); // Reads entry data and updates currEntry fields (like size)\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse(); // Reads sparse map data\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header information\n        // (e.g., by PAX headers), we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n        return currEntry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}