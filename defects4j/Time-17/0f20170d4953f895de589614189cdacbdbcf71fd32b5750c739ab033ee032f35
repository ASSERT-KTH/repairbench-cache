{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * <p>\n     * If the instant is not in an overlap, the instant is returned unaltered.\n     * If the instant is in an overlap, the returned instant will have the same\n     * local time, but will be expressed in the earlier or later offset as requested.\n     *\n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier offset, true for later offset\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // Find the transition potentially relevant to this instant.\n        // Use instant + 1 to ensure we get the transition that instant might be on or just after.\n        long transition = previousTransition(instant + 1);\n\n        // If transition is Long.MIN_VALUE, it means no transition exists before instant + 1.\n        // This implies the instant is in the first defined offset period or the implementation\n        // cannot determine a relevant previous transition. In such cases, the instant is likely\n        // unambiguous, or at least cannot be adjusted based on a preceding transition.\n        if (transition == Long.MIN_VALUE) {\n             return instant; // Cannot adjust based on previous transition\n        }\n        \n        // Check if the transition is actually an overlap (offset after < offset before)\n        long offsetBefore = getOffset(transition - 1);\n        long offsetAfter = getOffset(transition);\n\n        if (offsetAfter >= offsetBefore) {\n             // It's a gap or a standard offset change, not an overlap.\n             // The instant is therefore unambiguous with respect to this transition.\n             // We might still need convertLocalToUTC if the local time maps to\n             // *another* overlap, but for adjusting the offset *at this instant*,\n             // no adjustment is needed if it's not in an overlap defined by this transition.\n             // Let's refine: Check if the instant itself falls within the UTC range of the overlap.\n             // This handles cases where the transition is an overlap, but the instant is outside it.\n             return instant;\n        }\n\n        // Overlap confirmed. Check if the instant is within the UTC range of the overlap.\n        // The overlap duration is (offsetBefore - offsetAfter).\n        long overlapDuration = offsetBefore - offsetAfter;\n        long overlapStartUTC = transition;\n        long overlapEndUTC = transition + overlapDuration;\n\n        if (instant < overlapStartUTC || instant >= overlapEndUTC) {\n             // Instant is outside the UTC range of this overlap.\n             return instant;\n        }\n\n        // Instant is within an overlap period.\n        // Determine the reference UTC instant to pass to convertLocalToUTC.\n        // This reference instant dictates the choice of offset if the local time is ambiguous.\n        // If we want the earlier offset (offsetBefore), use a time before the transition.\n        // If we want the later offset (offsetAfter), use a time at or after the transition.\n        long referenceInstant = earlierOrLater ? transition : (transition - 1);\n\n        // Convert the original instant to local time millis.\n        // This local time will be ambiguous (fall within the local time overlap).\n        long localInstant = convertUTCToLocal(instant);\n\n        // Convert the local time back to UTC. Since localInstant is ambiguous,\n        // convertLocalToUTC uses the referenceInstant relative to the transition\n        // time associated with localInstant to select the appropriate UTC instant\n        // (corresponding to either the earlier or later offset).\n        return convertLocalToUTC(localInstant, false, referenceInstant);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}