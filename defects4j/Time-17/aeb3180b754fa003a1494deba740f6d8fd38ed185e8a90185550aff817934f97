{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        \n        // Attempt to convert local back to UTC using the original instant as a preference.\n        // This will usually pick the offset corresponding to the original instant.\n        long result = convertLocalToUTC(local, false, instant);\n        \n        // If the offset found matches the original instant's offset, it means we are still\n        // on the same side of the overlap (or not in an overlap).\n        // The test cases imply that if we are already on the requested side, we should\n        // toggle to the *other* side of the overlap.\n        if (getOffset(result) == getOffset(instant)) {\n            long opposite;\n            if (earlierOrLater) {\n                // If 'earlierOrLater' is true (requesting later offset), and we got the\n                // current offset, we need to try to get the *earlier* of the two.\n                // This is achieved by providing a preferred instant that is before the current instant.\n                opposite = convertLocalToUTC(local, false, instant - DateTimeConstants.MILLIS_PER_HOUR);\n            } else {\n                // If 'earlierOrLater' is false (requesting earlier offset), and we got the\n                // current offset, we need to try to get the *later* of the two.\n                // This is achieved by providing a preferred instant that is after the current instant.\n                opposite = convertLocalToUTC(local, false, instant + DateTimeConstants.MILLIS_PER_HOUR);\n            }\n            \n            // Only return 'opposite' if it genuinely provides a different offset,\n            // indicating we successfully switched to the other side of an overlap.\n            if (getOffset(opposite) != getOffset(instant)) {\n                return opposite;\n            }\n        }\n        \n        // If no change was needed or possible, return the original result.\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}