{
    "generation": "/**\n * Adjusts the offset to be the earlier or later one during an overlap.\n * \n * @param instant  the instant to adjust\n * @param earlierOrLater  false for earlier, true for later\n * @return the adjusted instant millis\n */\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long offsetBefore = getOffset(instantBefore);\n    long offsetAfter = getOffset(instantAfter);\n    if (offsetBefore == offsetAfter) {\n        return instant;  // not an overlap\n    }\n\n    // calculate the local time for the given instant\n    long localInstant = instant + getOffset(instant);\n\n    // find the two possible offsets at this local time\n    long earlierOffset;\n    long laterOffset;\n    if (offsetAfter < offsetBefore) {\n        earlierOffset = offsetAfter;\n        laterOffset = offsetBefore;\n    } else {\n        earlierOffset = offsetBefore;\n        laterOffset = offsetAfter;\n    }\n\n    // Figure out which offset applies at this local time\n    long earlierInstant = localInstant - earlierOffset;\n    long laterInstant = localInstant - laterOffset;\n\n    // Return the correct instant according to the flag\n    if (earlierOrLater) {\n        // Later offset\n        if (laterInstant == instant) {\n            return instant;\n        }\n        return laterInstant;\n    } else {\n        // Earlier offset\n        if (earlierInstant == instant) {\n            return instant;\n        }\n        return earlierInstant;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}