{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        // we check offsets not local instants because of complexities with gaps\n        long offsetBefore = getOffset(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long offsetAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n\n        if (offsetBefore == offsetAfter) {\n             // Check if the instant is actually in a gap. If so, cannot adjust.\n             // This handles cases where the offset 3 hours before and after are the same\n             // but the instant itself is invalid.\n             if (isLocalDateTimeGap(convertUTCToLocal(instant))) {\n                 // Cannot adjust instant in gap, return original instant\n                 // Note: This is a defensive check, behavior in gaps might be undefined.\n             }\n             // If offsets are the same and not in a gap, it implies no overlap/gap affecting\n             // the instant's offset relative to its neighbors. Return original instant.\n             // This also handles cases where the transition is outside the +/- 3 hour window.\n            return instant;\n        }\n        \n        // If offsets are different, there is a transition nearby.\n        // Convert the instant to local time. This local time might be ambiguous\n        // if the instant falls within the overlap period.\n        long local = convertUTCToLocal(instant);\n\n        // convertLocalToUTC will resolve the ambiguity based on the preferred instant.\n        // We need to provide a UTC instant for preference. Using instants far away\n        // biases the choice correctly towards the earlier or later offset.\n        long preferredInstantUTC = earlierOrLater ? \n            (instant + 3 * DateTimeConstants.MILLIS_PER_HOUR) : \n            (instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n            \n        // When converting local time back to UTC, use the preferred instant to\n        // select the correct offset if in an overlap. false means non-strict.\n        return convertLocalToUTC(local, false, preferredInstantUTC);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}