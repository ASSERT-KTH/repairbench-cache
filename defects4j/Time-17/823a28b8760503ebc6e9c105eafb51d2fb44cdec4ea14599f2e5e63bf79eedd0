{
    "generation": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBeforeUTC = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long instantAfterUTC = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n        long offsetBefore = getOffset(instantBeforeUTC);\n        long offsetAfter = getOffset(instantAfterUTC);\n        if (offsetBefore == offsetAfter) {\n            // Check if the instant itself is in an overlap - edge case issue #145\n            // If it is, convertuses the later offset, which is correct for withLaterOffsetAtOverlap RFE#3476684\n            long offset = getOffset(instant);\n            long local = instant + offset;\n            if (local >= previousTransition(local) && local < nextTransition(local)) {\n                 // Instant is in a regular period, so must be correct\n                 return instant;\n            }\n            // Otherwise, we are in an overlap. Fall through.\n            // The check above might return true if the transition is > 3 hours from instant,\n            // but the instant is still in an overlap.\n            // Example: Easter Island transitions at midnight Oct 7/8 2017. Instant is Oct 8 00:30.\n            // 3 hours before is Sep 7 21:30. 3 hours after is Oct 8 03:30. Offsets are same.\n            // But 00:30 is in the overlap [00:00, 01:00).\n            // We need to check if the instant's local time is ambiguous.\n            \n            // Simpler check: if offsets are same 3h before/after, AND the offset at the instant\n            // is also the same, then we are definitely not in an overlap related to those transitions.\n            if (offset == offsetBefore) { // or offset == offsetAfter\n                 return instant;\n            }\n            // If offset at instant differs from offset 3h before/after, it implies a transition\n            // occurred, but we might not be *in* the overlap/gap. However, if we are in an overlap,\n            // the offsets 3h away *might* be equal if the overlap is short.\n            // The original check `offsetBefore == offsetAfter` is primarily to optimize for the common case\n            // where the instant is far from any transition. If it passes, we *might* still be in an overlap.\n            // Fall through to the more detailed check using convertLocalToUTC.\n        }\n        \n        // work out local time representation of instant\n        long local = convertUTCToLocal(instant);\n        // This is messy, but will work in all non-pathological cases\n        // If we need the later instant, pass something LATER. If we need the earlier instant, pass something EARLIER.\n        // The instants passed are UTC instants. convertLocalToUTC uses the offset at the UTC instant\n        // passed as the third parameter to disambiguate the local instant.\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfterUTC : instantBeforeUTC);\n        \n        // Note: Previous buggy version passed local millis calculated from the instants +/- 3 hours\n        // into convertLocalToUTC, which expects a UTC millis hint. It also used a less reliable\n        // initial check based on comparing local millis representations 6 hours apart.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}