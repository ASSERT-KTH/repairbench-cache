{
    "generation": "public long adjustOffset(long instant, boolean earlierOrLater) {\n    // Check the previous transition for an overlap (clocks went backward)\n    long prevTrans = previousTransition(instant);\n    int prevOffset = getOffset(prevTrans - 1);\n    int postOffset = getOffset(prevTrans);\n    if (postOffset < prevOffset) {\n        long overlap = prevOffset - postOffset;\n        long overlapStart = prevTrans - overlap;\n        long overlapEnd   = prevTrans + overlap;\n        if (instant >= overlapStart && instant < overlapEnd) {\n            // In the ambiguous window around prevTrans\n            if (instant < prevTrans) {\n                // first half of the overlap\n                return earlierOrLater ? instant + overlap : instant;\n            } else {\n                // second half of the overlap\n                return earlierOrLater ? instant : instant - overlap;\n            }\n        }\n    }\n    // Check the next transition for an overlap\n    long nextTrans = nextTransition(instant);\n    prevOffset = getOffset(nextTrans - 1);\n    postOffset = getOffset(nextTrans);\n    if (postOffset < prevOffset) {\n        long overlap = prevOffset - postOffset;\n        long overlapStart = nextTrans - overlap;\n        long overlapEnd   = nextTrans + overlap;\n        if (instant >= overlapStart && instant < overlapEnd) {\n            // In the ambiguous window around nextTrans\n            if (instant < nextTrans) {\n                // first half of the overlap\n                return earlierOrLater ? instant + overlap : instant;\n            } else {\n                // second half of the overlap\n                return earlierOrLater ? instant : instant - overlap;\n            }\n        }\n    }\n    // Not in an overlap period, no adjustment\n    return instant;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}