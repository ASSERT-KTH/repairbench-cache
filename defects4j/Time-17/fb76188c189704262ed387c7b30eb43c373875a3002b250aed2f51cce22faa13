{
    "generation": "/**\n * Adjusts the offset to be the earlier or later one during an overlap.\n * \n * For ambiguous (overlap) instants there are two valid UTC values: one that, when\n * converted to local time, uses one offset and one that uses the other. In our\n * example (America/Sao_Paulo on 2012\u201002\u201025) the ambiguous wall time 23:15\n * can occur with an offset of \u201302:00 (the \u201cearlier\u201d time in absolute UTC, i.e.\n * 23:15 \u2013 (\u201302:00) = 01:15 UTC) or with \u201303:00 (the \u201clater\u201d time i.e. 23:15 \u2013 (\u201303:00)\n * = 02:15 UTC). Note that because the offsets are negative, \u201cearlier offset\u201d\n * means the one with the larger numerical value (\u201302:00) and \u201clater offset\u201d\n * means the one with the smaller numerical value (\u201303:00).\n * \n * The strategy is to convert the given instant to its ambiguous local time,\n * then resolve the ambiguity by \u201cnudging\u201d the assumed instant by 1 millisecond:\n * if the current instant already represents one candidate and the alternate candidate\n * (computed by assuming instant+1 or instant\u20131) has a different offset, then we\n * choose the candidate that gives the desired offset. Specifically, if earlierOrLater\n * is false (i.e. withEarlierOffsetAtOverlap is requested) we return the candidate\n * whose offset is the maximum (less negative) and if earlierOrLater is true (withLaterOffsetAtOverlap)\n * we return the candidate whose offset is the minimum.\n * \n * If the instant is not ambiguous then it is returned unchanged.\n *\n * @param instant         the instant to adjust (in UTC millis)\n * @param earlierOrLater  false for \u201cearlier offset\u201d (i.e. the candidate with the larger offset value),\n *                        true for \u201clater offset\u201d (i.e. the candidate with the smaller offset value)\n * @return the adjusted instant millis\n */\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // Convert the UTC instant to the \"ambiguous\" local time.\n    long local = convertUTCToLocal(instant);\n    \n    // Get the offset in force at the given instant.\n    int offsetCurrent = getOffset(instant);\n    \n    // Resolve the ambiguity: by nudging the assumed instant by 1 ms in the appropriate direction,\n    // we force convertLocalToUTC to pick the alternate candidate.\n    // (A nudge of 1 ms is tiny compared to the typical DST shift.)\n    long assumedInstant = instant + (earlierOrLater ? 1L : -1L);\n    long otherInstant = convertLocalToUTC(local, false, assumedInstant);\n    int offsetOther = getOffset(otherInstant);\n    \n    // If both candidates give the same offset, then the instant is not in an overlap.\n    if (offsetCurrent == offsetOther) {\n        return instant;\n    }\n    \n    // In an overlap there are two valid offsets.\n    // For withEarlierOffsetAtOverlap (flag false) we want the candidate with the larger offset value;\n    // for withLaterOffsetAtOverlap (flag true) we want the candidate with the smaller offset.\n    int desiredOffset = earlierOrLater ? Math.min(offsetCurrent, offsetOther)\n                                       : Math.max(offsetCurrent, offsetOther);\n    // The resolved UTC instant is obtained by subtracting the desired offset from the local time.\n    long adjusted = local - desiredOffset;\n    return adjusted == instant ? instant : adjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}