{
    "generation": "/**\n * Adjusts the offset to be the earlier or later one during an overlap.\n * \n * @param instant  the instant to adjust\n * @param earlierOrLater  false for earlier, true for later\n * @return the adjusted instant millis\n */\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long offsetBefore = getOffset(instantBefore);\n    long offsetAfter = getOffset(instantAfter);\n    if (offsetBefore == offsetAfter) {\n        return instant;  // not an overlap\n    }\n\n    // work out range of instants that have duplicate local times\n    long localInstant = convertUTCToLocal(instant);\n\n    // Calculate candidate instants for both earlier and later offsets\n    long earlierOffset = Math.min(offsetBefore, offsetAfter);\n    long laterOffset = Math.max(offsetBefore, offsetAfter);\n\n    long earlierInstant = localInstant - earlierOffset;\n    long laterInstant = localInstant - laterOffset;\n\n    // Now, local time might map to two instants in UTC. Determine which is which.\n    // Pick the one that is closer to the supplied instant.\n    if (earlierOrLater) {\n        // later offset\n        if (instant != laterInstant && getOffset(laterInstant) == laterOffset) {\n            return laterInstant;\n        } else {\n            return instant;\n        }\n    } else {\n        // earlier offset\n        if (instant != earlierInstant && getOffset(earlierInstant) == earlierOffset) {\n            return earlierInstant;\n        } else {\n            return instant;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}