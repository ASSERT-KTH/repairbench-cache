{
    "generation": "/**\n * Adjusts the offset to be the earlier or later one during an overlap.\n *\n * @param instant  the instant to adjust\n * @param earlierOrLater  false for earlier, true for later\n * @return the adjusted instant millis\n */\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // Convert the UTC instant to local time\n    long localMillis = convertUTCToLocal(instant);\n\n    // 1) Check for a backward transition just before or at this instant\n    long prevTrans = previousTransition(instant);\n    int offsetBefore = getOffset(prevTrans - 1);\n    int offsetAfter  = getOffset(prevTrans + 1);\n    if (offsetAfter < offsetBefore) {\n        // We have an overlap starting at local = prevTrans + offsetAfter\n        long startLocal = prevTrans + offsetAfter;\n        long endLocal   = prevTrans + offsetBefore;\n        if (localMillis >= startLocal && localMillis < endLocal) {\n            // In the overlap \u2013 choose earlier or later mapping\n            return earlierOrLater\n                 ? (localMillis - offsetAfter)\n                 : (localMillis - offsetBefore);\n        }\n    }\n\n    // 2) Check for a backward transition just after this instant\n    long nextTrans = nextTransition(instant);\n    offsetBefore = getOffset(nextTrans - 1);\n    offsetAfter  = getOffset(nextTrans + 1);\n    if (offsetAfter < offsetBefore) {\n        long startLocal = nextTrans + offsetAfter;\n        long endLocal   = nextTrans + offsetBefore;\n        if (localMillis >= startLocal && localMillis < endLocal) {\n            return earlierOrLater\n                 ? (localMillis - offsetAfter)\n                 : (localMillis - offsetBefore);\n        }\n    }\n\n    // Not in an overlap, return original instant\n    return instant;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}