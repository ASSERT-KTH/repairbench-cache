{
    "generation": "/**\n * Adjusts the offset to be the earlier or later one during an overlap.\n * \n * @param instant       the instant to adjust (in UTC millis)\n * @param earlierOrLater false for earlier offset, true for later offset\n * @return the adjusted instant millis\n */\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // 1) Check if we are in the *second* half of a backward shift (the \"later\" window)\n    long prevTrans = previousTransition(instant);\n    int offsetBefore = getOffset(prevTrans - 1);\n    int offsetAfter  = getOffset(prevTrans);\n    int delta = offsetBefore - offsetAfter;\n    if (delta > 0) {\n        long overlapEnd = prevTrans + delta;\n        if (instant >= prevTrans && instant < overlapEnd) {\n            // We are in the later\u2010offset half of the overlap\n            if (earlierOrLater) {\n                // user wants the later offset => no change\n                return instant;\n            } else {\n                // user wants the earlier offset => move back by the gap\n                return instant - delta;\n            }\n        }\n    }\n\n    // 2) Check if we are in the *first* half of an upcoming backward shift (\"earlier\" window)\n    long nextTrans = nextTransition(instant);\n    offsetBefore = getOffset(nextTrans - 1);\n    offsetAfter  = getOffset(nextTrans);\n    delta = offsetBefore - offsetAfter;\n    if (delta > 0) {\n        long overlapStart = nextTrans - delta;\n        if (instant >= overlapStart && instant < nextTrans) {\n            // We are in the earlier\u2010offset half of the overlap\n            if (earlierOrLater) {\n                // user wants the later offset => move forward by the gap\n                return instant + delta;\n            } else {\n                // user wants the earlier offset => no change\n                return instant;\n            }\n        }\n    }\n\n    // Not in any overlap\n    return instant;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}