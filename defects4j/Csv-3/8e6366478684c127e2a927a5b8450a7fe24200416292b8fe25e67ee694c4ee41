{
    "generation": "int readEscape() throws IOException {\n    // the escape char has just been read (normally a backslash)\n    final int c = in.read();\n    switch (c) {\n    case 'r':\n        return CR;\n    case 'n':\n        return LF;\n    case 't':\n        return TAB;\n    case 'b':\n        return BACKSPACE;\n    case 'f':\n        return FF;\n    case CR:\n    case LF:\n    case FF:\n    case TAB:\n    case BACKSPACE:\n        return c;\n    case END_OF_STREAM:\n        throw new IOException(\"EOF whilst processing escape sequence\");\n    default:\n        // special handling for \\N (MySQL null) and arbitrary escaped characters\n        // return slash + char as two characters to preserve in output\n        // So we \"undo\" the escaping, and treat \\N etc as backslash plus 'N'\n        // To support this, we reset the char to escape char and let caller pick both\n        // but since this method must return a char, a good approach is to simply\n        // return the escaped char itself, but the main fix is:\n        // do NOT remove escape sequences for unknown escapes -- treat as literal backslash + char\n        // Since the escape character has already been consumed, \n        // we simulate the behaviour by returning the character itself, but the parser needs to append the escape char + char\n        in.unread(c); // unread the non-standard escaped char so parser will see it after the escape char\n        return '\\\\'; // or whatever is the escape char (assuming backslash), should be general escape char variable\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}