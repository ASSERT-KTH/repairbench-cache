{
    "generation": "int readEscape() throws IOException {\n    // The escape character (already read) has been encountered.\n    final int c = in.read();\n    if (c == END_OF_STREAM) {\n        throw new IOException(\"EOF whilst processing escape sequence\");\n    }\n    \n    // If the escape char is a backslash, allow standard letter escapes.\n    // (Only backslash\u2010escapes support conversion such as \"\\n\", \"\\r\", etc.)\n    if (escape == '\\\\') {\n        switch (c) {\n            case 'r':\n                return CR;\n            case 'n':\n                return LF;\n            case 't':\n                return TAB;\n            case 'b':\n                return BACKSPACE;\n            case 'f':\n                return FF;\n            default:\n                // Fall through if not one of the recognized letter escapes.\n                break;\n        }\n    }\n    \n    // In any CSV setting the escape character should also work to quote\n    // special CSV meta\u2010characters.  If the character following the escape\n    // is the escape char itself, the quote character or the delimiter, or if\n    // it is an actual newline (CR or LF), then unescape it (i.e. return it directly).\n    if (c == escape || c == quote || c == delimiter || c == CR || c == LF) {\n        return c;\n    }\n    \n    // Otherwise, the escape sequence is not a special one.\n    // \"Unread\" the character so that it will be processed normally later\n    // and return the literal escape character.\n    in.unread(c);\n    return escape;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}