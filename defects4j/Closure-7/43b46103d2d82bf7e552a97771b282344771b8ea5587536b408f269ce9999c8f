{
    "generation": "    @Override\n    public JSType caseObjectType(ObjectType type) {\n      if (value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE); // Represents the Function type\n        if (resultEqualsValue) { // Corresponds to `typeof x === \"function\"` or `goog.isFunction(x)` is true\n          // If the expectation is that 'x' is a function, and 'type' is an ObjectType,\n          // then 'type' should be narrowed to the Function type.\n          return ctorType;\n        } else { // Corresponds to `typeof x !== \"function\"` or `goog.isFunction(x)` is false\n          // If the expectation is that 'x' is NOT a function, and 'type' is an ObjectType,\n          // we need to filter out the Function type from 'type'.\n          // If 'type' itself is the Function type (or a subtype of Function), it's a contradiction,\n          // so return null (meaning this specific type is excluded from the union).\n          // Otherwise, 'type' is a generic ObjectType (e.g., Object, Array) that is not a Function,\n          // so it remains a possibility and should be returned.\n          return type.isSubtype(ctorType) ? null : type;\n        }\n      }\n      // This part handles other typeof string values (e.g., \"object\", \"string\", \"number\", etc.)\n      // and other checks (e.g., goog.isObject).\n      // 'matchesExpectation(\"object\")' checks if the `value` is \"object\" and `resultEqualsValue` matches,\n      // or if `value` is not \"object\" and `resultEqualsValue` doesn't match.\n      // For instance, if `value` is \"object\" and `resultEqualsValue` is true, it keeps the type.\n      // If `value` is \"string\" and `resultEqualsValue` is true, it means `x` is a string,\n      // so `x` cannot be an object, thus `null` is returned (filtered out).\n      return matchesExpectation(\"object\") ? type : null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}