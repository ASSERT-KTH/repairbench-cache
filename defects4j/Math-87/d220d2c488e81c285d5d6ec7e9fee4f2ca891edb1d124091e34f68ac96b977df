{
    "generation": "    /**\n     * Checks whether the given column is basic.\n     * @param col index of the column to check\n     * @return the row that the variable is basic in.  null if the column is not basic\n     */\n    private Integer getBasicRow(final int col) {\n        Integer row = null;\n        // Iterate through all rows, including objective function rows (starting from 0)\n        for (int i = 0; i < getHeight(); i++) {\n            final double entry = getEntry(i, col);\n            // If the entry is not effectively zero\n            if (!MathUtils.equals(entry, 0.0, epsilon)) {\n                // If it's a candidate for a basic variable, its single non-zero entry must be 1.0\n                if (MathUtils.equals(entry, 1.0, epsilon)) {\n                    // This is the first 1.0 we found in this column\n                    if (row == null) {\n                        row = i;\n                    } else {\n                        // Found a second 1.0 (or effectively 1.0) in this column.\n                        // A basic column can only have one 1.0. So, this column is not basic.\n                        return null;\n                    }\n                } else {\n                    // Found a non-zero entry that is not 1.0.\n                    // A basic column must have its single non-zero entry as 1.0.\n                    // So, this column is not basic.\n                    return null;\n                }\n            }\n        }\n        // If we reached here, it means:\n        // - All entries were 0.0 (row will be null).\n        // - Exactly one 1.0 was found, and all other entries were 0.0 (row will be the index of that 1.0).\n        // In both cases, 'row' correctly reflects whether the column is basic and, if so, in which row.\n        return row;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}