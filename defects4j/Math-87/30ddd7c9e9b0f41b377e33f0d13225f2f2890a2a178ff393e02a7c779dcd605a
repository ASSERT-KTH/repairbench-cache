{
    "generation": "    /**\n     * Checks whether the given column is basic.\n     * @param col index of the column to check\n     * @return the row that the variable is basic in. null if the column is not basic\n     */\n    private Integer getBasicRow(final int col) {\n        Integer basicRow = null;\n        // Check constraint rows first\n        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n            final double entry = getEntry(i, col);\n            // Check if entry is close to 1.0\n            if (MathUtils.equals(entry, 1.0, epsilon)) {\n                // If we already found a potential basic row, this column is not basic\n                // (requires exactly one 1 in the column among constraint rows)\n                if (basicRow != null) {\n                    return null;\n                }\n                // Store the potential basic row\n                basicRow = i;\n            // Check if entry is significantly different from 0.0 (and not 1.0)\n            } else if (!MathUtils.equals(entry, 0.0, epsilon)) {\n                // Found a non-zero, non-one entry in constraint rows -> column is not basic\n                return null;\n            }\n        }\n\n        // If we found a unique '1' in constraint rows,\n        // check if all entries in the objective function rows are zero.\n        if (basicRow != null) {\n            for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n                 // If any entry in objective rows is non-zero, column is not basic\n                 if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n                     return null;\n                 }\n            }\n        }\n\n        // If we found exactly one '1' in constraint rows and all other entries\n        // (including objective rows) are '0', then return the row index.\n        // Otherwise, return null.\n        return basicRow;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}