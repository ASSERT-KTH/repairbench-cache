{
    "generation": "import org.mockito.internal.matchers.AnyVararg;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.Matcher;\n\nimport java.lang.reflect.Array;\nimport java.util.List; // Assuming 'matchers' is a List<Matcher>\n\npublic class InvocationMatcher { // Assuming this is the class containing the method\n    private final List<Matcher> matchers; // Assuming 'matchers' field exists\n\n    // Constructor placeholder, actual constructor would be more complex\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.matchers = matchers;\n    }\n\n    public void captureArgumentsFrom(Invocation invocation) {\n        Object[] rawArguments = invocation.getRawArguments();\n        \n        // Determine if the method is a vararg method\n        boolean methodIsVararg = invocation.getMethod().isVarArgs();\n        \n        // The index of the last formal parameter, which would be the vararg array if it's a vararg method\n        int lastFormalParameterIndex = -1;\n        if (methodIsVararg) {\n            lastFormalParameterIndex = invocation.getMethod().getParameterTypes().length - 1;\n        }\n\n        // Iterate through the matchers to capture arguments\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n\n            // Only process if the matcher is an argument captor\n            if (m instanceof CapturesArguments) {\n                CapturesArguments captor = (CapturesArguments) m;\n\n                // Special handling for the AnyVararg matcher when used with a vararg method\n                // It captures all remaining arguments from its position onwards.\n                if (methodIsVararg && position == lastFormalParameterIndex && m == AnyVararg.ANY_VARARG) {\n                    // Capture all actual arguments from this 'position' until the end of the raw arguments list\n                    for (int i = position; i < rawArguments.length; i++) {\n                        // Use invocation.getArgumentAt for robustness (handling primitives, boxing, etc.)\n                        captor.captureFrom(invocation.getArgumentAt(i, Object.class));\n                    }\n                    // After AnyVararg processes, no further matchers need to be processed for argument capturing\n                    return;\n                } else {\n                    // For regular matchers (not AnyVararg, or AnyVararg not at the vararg position),\n                    // and for non-vararg methods, capture the argument at the current 'position'.\n                    // Ensure there's an actual argument at this position to prevent IndexOutOfBoundsException.\n                    if (rawArguments.length > position) {\n                        // Use invocation.getArgumentAt for robustness (handling primitives, boxing, etc.)\n                        captor.captureFrom(invocation.getArgumentAt(position, Object.class));\n                    }\n                }\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}