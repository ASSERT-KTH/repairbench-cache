{
    "generation": "public void captureArgumentsFrom(Invocation invocation) {\n    // If the method is varargs, we need to handle the vararg parameters specially.\n    int rawArgsLength = invocation.getRawArguments().length;\n    int matchersSize = matchers.size();\n\n    for (int position = 0; position < matchersSize; position++) {\n        Matcher m = matchers.get(position);\n        if (!(m instanceof CapturesArguments)) continue;\n\n        // Only capture if there's a real argument at the position\n        if (rawArgsLength > position) {\n            // If this is a vararg method, and this argument is the vararg array, and matcher is a vararg matcher\n            boolean isVarArgs = invocation.getMethod().isVarArgs();\n            boolean isLastArg = position == (matchersSize - 1);\n            if (isVarArgs && isLastArg && isVarargMatcher(m)) {\n                Object array = invocation.getRawArguments()[position];\n                // Could be null if vararg passed as `null`\n                if (array != null && array.getClass().isArray()) {\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                } else {\n                    // If the vararg array is null, capture `null`\n                    ((CapturesArguments) m).captureFrom(array);\n                }\n            } else {\n                ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n            }\n        }\n    }\n}\n\n// Helper method, typically present in this class or base class\nprivate boolean isVarargMatcher(Matcher matcher) {\n    // This could check for a specific marker interface/class for vararg matchers.\n    // Here's an example (replace with actual logic from your codebase if different):\n    return matcher instanceof org.mockito.internal.matchers.VarargMatcher;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}