{
    "generation": "import org.mockito.internal.matchers.CapturesArguments;\nimport org.mockito.internal.matchers.AnyVararg;\nimport org.mockito.internal.matchers.LocalizedMatcher;\nimport org.mockito.invocation.Invocation;\nimport org.hamcrest.Matcher;\nimport java.lang.reflect.Array;\nimport java.util.List; // Assuming matchers field is List<Matcher>\n\n// Assumes this method is within a class that has access to:\n// private List<Matcher> matchers;\npublic void captureArgumentsFrom(Invocation invocation) {\n    // Determine the vararg parameter position if the method has varargs\n    int varargPosition = -1;\n    if (invocation.getMethod().isVarArgs()) {\n        // The vararg parameter is the last one\n        varargPosition = invocation.getMethod().getParameterTypes().length - 1;\n    }\n\n    // Iterate through the matchers provided for this invocation match\n    for (int matcherPosition = 0; matcherPosition < matchers.size(); matcherPosition++) {\n        Matcher m = matchers.get(matcherPosition);\n\n        // Check if the matcher is an argument captor\n        if (m instanceof CapturesArguments) {\n            CapturesArguments captor = (CapturesArguments) m;\n\n            // Unwrap the matcher if necessary (e.g., from LocalizedMatcher)\n            // This allows checking the type of the actual matcher (e.g., AnyVararg)\n            Matcher actualMatcher = m;\n            if (m instanceof LocalizedMatcher) {\n                 actualMatcher = ((LocalizedMatcher) m).getMatcher();\n            }\n\n            // Check if the unwrapped matcher is specifically for varargs (e.g., AnyVararg)\n            boolean isVarargSpecificMatcher = actualMatcher instanceof AnyVararg;\n\n            // Check if this matcher's position corresponds to the vararg parameter position\n            boolean isMatcherAtVarargPos = (varargPosition != -1 && matcherPosition == varargPosition);\n\n            if (isMatcherAtVarargPos && isVarargSpecificMatcher) {\n                // Case 1: A vararg-specific captor (like AnyVararg) at the vararg position.\n                // Capture elements from the raw vararg argument array.\n                Object[] rawArgs = invocation.getRawArguments();\n                // Check if vararg argument exists in raw args (it might not if invoked with fewer args than vararg position)\n                if (varargPosition < rawArgs.length) {\n                    Object rawVarargArgument = rawArgs[varargPosition];\n                    // Ensure the raw argument is a non-null array before iterating\n                    if (rawVarargArgument != null && rawVarargArgument.getClass().isArray()) {\n                        // Iterate through the vararg array and capture each element\n                        for (int i = 0; i < Array.getLength(rawVarargArgument); i++) {\n                            captor.captureFrom(Array.get(rawVarargArgument, i));\n                        }\n                    }\n                    // If rawVarargArgument is null or not an array (e.g., explicit null passed for varargs),\n                    // the AnyVararg matcher should capture nothing, as there are no elements. Handled by the check.\n                }\n                // If varargPosition >= rawArgs.length (e.g., method(\"fixed\") for method(String, String...)),\n                // the vararg array is effectively empty, so capture nothing. Handled by the check.\n\n            } else {\n                // Case 2: Any other captor (regular captor, or vararg captor not at vararg position - less common).\n                // Capture the single 'effective' argument at this logical position.\n                // Use invocation.getArgumentAt() as it handles vararg expansion correctly.\n                try {\n                    // Get the argument corresponding to the matcher's position, considering vararg expansion.\n                    Object effectiveArgument = invocation.getArgumentAt(matcherPosition, Object.class);\n                    captor.captureFrom(effectiveArgument);\n                } catch (IndexOutOfBoundsException e) {\n                    // This exception occurs if this matcher position doesn't correspond to any effective argument\n                    // (e.g., more captors provided than effective arguments for this invocation).\n                    // In this situation, the captor associated with this position captures nothing for this specific invocation.\n                    // This is the expected behavior, so we ignore the exception and proceed.\n                }\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}