{
    "generation": "    public void captureArgumentsFrom(Invocation invocation) {\n        int nrOfMatchers = matchers.size();\n        // Use getRawArguments length as it corresponds to the number of arguments passed,\n        // where varargs are represented as a single array entry. This length is suitable\n        // for bounds checking when using getArgumentAt(parameterIndex, ...).\n        int nrOfArgs = invocation.getRawArguments().length;\n\n        if (invocation.getMethod().isVarArgs()) {\n            int varargParameterIndex = invocation.getMethod().getParameterTypes().length - 1;\n\n            for (int position = 0; position < nrOfMatchers; position++) {\n                // Assumes 'matchers' list contains ArgumentMatcher or similar that can be cast to Matcher\n                org.mockito.ArgumentMatcher m = (org.mockito.ArgumentMatcher) matchers.get(position);\n                if (m instanceof CapturesArguments) {\n                    CapturesArguments captor = (CapturesArguments) m;\n\n                    if (position < varargParameterIndex) {\n                        // Capture regular argument before varargs\n                        if (position < nrOfArgs) { // Check arg exists\n                            captor.captureFrom(invocation.getArgumentAt(position, Object.class));\n                        }\n                    } else if (position == varargParameterIndex) {\n                        // Capture varargs. The argument at this position is the vararg array.\n                        // Check if the vararg argument itself exists in the invocation\n                        if (varargParameterIndex < nrOfArgs) {\n                            Object varargArray = invocation.getArgumentAt(varargParameterIndex, Object.class);\n                            if (varargArray != null && varargArray.getClass().isArray()) {\n                                int length = java.lang.reflect.Array.getLength(varargArray);\n                                for (int i = 0; i < length; i++) {\n                                    captor.captureFrom(java.lang.reflect.Array.get(varargArray, i));\n                                }\n                            } else {\n                                // Capture the argument as-is if it's null or not an array (e.g., null passed explicitly)\n                                captor.captureFrom(varargArray);\n                            }\n                        }\n                        // If varargParameterIndex >= nrOfArgs, it implies an empty vararg array or fewer args than expected.\n                        // Capturing nothing in this case is correct as no corresponding vararg elements were passed.\n                    }\n                    // else: Matcher position is > varargParameterIndex. This implies more matchers than parameters.\n                    // There's no distinct argument to capture. Ignore.\n                }\n            }\n        } else {\n            // Non-varargs: Capture arguments using getArgumentAt, checking bounds.\n            for (int position = 0; position < nrOfMatchers; position++) {\n                org.mockito.ArgumentMatcher m = (org.mockito.ArgumentMatcher) matchers.get(position);\n                if (m instanceof CapturesArguments && position < nrOfArgs) {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}