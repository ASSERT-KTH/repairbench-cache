{
    "generation": "    public void captureArgumentsFrom(Invocation invocation) {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            \n            // Ensure the matcher is a CapturesArguments instance and that there's a corresponding\n            // raw argument at the current position to avoid ArrayIndexOutOfBoundsException.\n            // This also implies that if the number of matchers exceeds the number of actual arguments,\n            // we won't try to access non-existent arguments.\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                Object currentArgument = invocation.getRawArguments()[position];\n\n                // Determine if the method is a varargs method AND if the current argument being processed\n                // is the vararg array (which is always the last argument in a varargs method's raw arguments).\n                boolean isCurrentArgumentVarargArrayPosition = invocation.getMethod().isVarArgs() && \n                                                               position == invocation.getRawArguments().length - 1;\n                \n                // Determine if the current matcher is specifically a vararg matcher (e.g., AnyVararg).\n                // This assumes AnyVararg is the primary matcher designed to capture elements of a vararg array.\n                boolean isMatcherForVarargElements = m instanceof org.mockito.internal.matchers.AnyVararg;\n\n                if (isCurrentArgumentVarargArrayPosition && isMatcherForVarargElements) {\n                    // If it's the vararg array and the matcher is for vararg elements,\n                    // we need to capture each element from the array.\n                    if (currentArgument != null && currentArgument.getClass().isArray()) {\n                        for (int i = 0; i < Array.getLength(currentArgument); i++) {\n                            ((CapturesArguments) m).captureFrom(Array.get(currentArgument, i));\n                        }\n                    }\n                    // Since we've processed all elements of the vararg array (or handled a null/empty vararg array),\n                    // and the vararg is always the last argument, there's no need to process further matchers.\n                    return; \n                } else {\n                    // This branch handles:\n                    // 1. Regular arguments (not a vararg method, or not the vararg position).\n                    // 2. Vararg method, but current position is not the vararg array position (for fixed arguments before vararg).\n                    // 3. Vararg method, current position IS vararg array position, but the matcher is NOT a vararg-specific matcher\n                    //    (e.g., an `anyObject()` or `eq(null)` used to match the vararg array itself, not its contents).\n                    // In these cases, we capture the argument as a single object.\n                    // Using `invocation.getArgumentAt` is generally more robust for type handling.\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}