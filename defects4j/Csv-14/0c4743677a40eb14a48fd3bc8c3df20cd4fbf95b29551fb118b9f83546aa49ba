{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharObj = getQuoteCharacter();\n        final char quoteChar = quoteCharObj != null ? quoteCharObj.charValue() : 0; // Default to 0 if no quote char\n        final Character escapeCharObj = getEscapeCharacter();\n        // char escapeChar = escapeCharObj != null ? escapeCharObj.charValue() : 0; // Not used directly in new logic flow\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        // --- FIX 1: Handle QuoteMode.NONE defensively for null escape character ---\n        if (quoteModePolicy == QuoteMode.NONE) {\n            if (escapeCharObj == null) {\n                // No quoting and no escape character means print the raw value.\n                out.append(value, offset, len);\n            } else {\n                // An escape character is defined, so use printAndEscape.\n                // Assuming printAndEscape handles non-null escapeChar correctly.\n                printAndEscape(value, offset, len, out);\n            }\n            return;\n        }\n\n        // Determine if quoting is needed based on the quote mode policy.\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE: // This case is already handled above to avoid fall-through.\n            throw new IllegalStateException(\"QuoteMode.NONE should have been handled earlier.\");\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // --- FIX 2: Remove problematic RFC4180 TEXTDATA specific range check ---\n                // This condition often incorrectly quotes characters like backslash that\n                // RFC4180 TEXTDATA definition actually permits without quoting.\n                /*\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else\n                */\n                if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    // This loop checks for characters that strictly require quoting by RFC4180\n                    // (LF, CR, the defined quoteChar, or the delimiter).\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        // --- FIX 3: Special condition for backslash as quote character ---\n                        // If quoteChar is '\\' AND no explicit escapeChar is set,\n                        // then '\\' should not trigger quoting for itself.\n                        if (c == '\\n' || c == '\\r' || c == delimChar ||\n                            (quoteCharObj != null && c == quoteChar && !(quoteChar == '\\\\' && escapeCharObj == null))) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        // Check last character for quoting if not already quoted.\n                        pos = end - 1; // Reset pos to last char\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            break; // End of MINIMAL case\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End of switch statement for quoteModePolicy\n\n        // --- General Output Handling based on 'quote' flag and 'escapeChar' presence ---\n\n        // If no quoting is determined and no explicit escape character is present,\n        // then simply append the raw value without any transformation.\n        if (!quote && escapeCharObj == null) {\n            out.append(value, offset, len);\n            return;\n        }\n\n        // If quoting is required OR an escape character is defined (which implies escaping),\n        // proceed with appending quotes and handling internal characters.\n        if (quote) {\n            out.append(quoteChar); // Append opening quote\n        }\n\n        // --- FIX 4: Conditional Use of printAndEscape vs. Quote Doubling ---\n        if (escapeCharObj != null) {\n            // If an escape character is defined, use the printAndEscape method for content.\n            // This method is assumed to handle all internal character escaping.\n            printAndEscape(value, offset, len, out);\n        } else {\n            // If no explicit escape character, perform RFC4180-style doubling of the quote character.\n            // Reset start and pos for this inner loop as they might have been modified in MINIMAL checks.\n            start = offset;\n            pos = offset;\n            while (pos < end) {\n                final char c = value.charAt(pos);\n                if (quoteCharObj != null && c == quoteChar) { // Only double if quoteChar is actually defined\n                    // Write the segment up to and including the current quote character.\n                    out.append(value, start, pos + 1);\n                    // Set the next starting position to the current quote character's position\n                    // so it will be written again with the next segment (effectively doubling it).\n                    start = pos;\n                }\n                pos++;\n            }\n            // Write the last segment of the value.\n            out.append(value, start, pos);\n        }\n\n        if (quote) {\n            out.append(quoteChar); // Append closing quote\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}