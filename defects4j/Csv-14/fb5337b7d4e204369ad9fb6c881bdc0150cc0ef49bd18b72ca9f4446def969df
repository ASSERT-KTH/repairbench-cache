{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset; // pos used for scanning checks in MINIMAL mode\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharObject = getQuoteCharacter(); // Keep as Character object to check for null\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        // Check if quoting is disabled or not configured\n        if (quoteCharObject == null || quoteModePolicy == QuoteMode.NONE) {\n            // If quote char is null or mode is NONE, disable quoting logic, rely on escaping\n            printAndEscape(value, offset, len, out);\n            return;\n        }\n\n        // We have a valid quoteChar and a mode other than NONE.\n        final char quoteChar = quoteCharObject.charValue();\n\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            // Quote if the object is not a Number.\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // This case is handled by the check above, but included for completeness.\n            // Should not be reached if quoteCharObject is not null.\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Quote empty fields on new records to distinguish from empty lines.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char firstChar = value.charAt(start);\n\n                // Rule 1: Quote if first char is the quote char or delimiter\n                // Checking CR/LF here is redundant due to the loop below.\n                if (firstChar == quoteChar || firstChar == delimChar) {\n                    quote = true;\n                } else {\n                    // Rule 2: Scan the whole string for quote, delimiter, CR, LF\n                    // Reset pos ensures scan starts from the beginning for this check.\n                    pos = start;\n                    while (pos < end) {\n                        final char c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break; // Found a character requiring quoting\n                        }\n                        pos++;\n                    }\n\n                    // Rule 3: Heuristic: Quote if ends with whitespace (original code check: char <= SP)\n                    // This check is applied only if the loop didn't already decide to quote.\n                    if (!quote) {\n                        // Using charAt(end - 1) is safe due to len > 0 check above\n                        if (value.charAt(end - 1) <= SP) {\n                            quote = true;\n                        }\n                        // Note: Removed the original code's check for leading chars <= COMMENT\n                        // Note: Removed the original code's check for non-alphanumeric first char on newRecord\n                    }\n                }\n            }\n\n            // If MINIMAL decided not to quote, print directly and return\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // Otherwise, MINIMAL decided quoting is needed, break to common quoting logic\n            break; // Break from MINIMAL case\n\n        default:\n            // Should not happen if QuoteMode is an enum\n            throw new IllegalStateException(\"Unexpected QuoteMode: \" + quoteModePolicy);\n        }\n\n        // If we reach here, quoting *might* be required.\n        // It's required for ALL, or if MINIMAL decided to quote,\n        // or if NON_NUMERIC decided to quote.\n        // Check if quoting is actually needed before proceeding.\n        if (!quote) {\n            // This path is reachable for NON_NUMERIC mode when the object is a Number.\n            // It was also reachable in original code if MINIMAL decided not to quote,\n            // but that case now returns early.\n            out.append(value, start, end);\n            return;\n        }\n\n\n        // --- Common Quoting Logic ---\n        // We determined quoting is needed (quote == true)\n        out.append(quoteChar);\n\n        // Scan the value again to write segments and double quotes\n        // Reset scanning variables 'start' and 'pos' for the writing loop\n        start = offset; // Start writing from the beginning\n        pos = offset;   // Scan from the beginning\n\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point (exclusive end), plus the quote char itself\n                out.append(value, start, pos + 1);\n                // Set start for the next segment to be this quote char (effectively doubling it)\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment (from last detected quote char or beginning, up to the end)\n        out.append(value, start, pos); // pos is now equal to 'end'\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}