{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // Always quote an empty token if it\u2019s the first on the line.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            // In MINIMAL mode, we quote only if the value contains characters that\n            // might confuse the parser: delimiters, line breaks or leading/trailing whitespace.\n            for (int i = offset; i < end; i++) {\n                char c = value.charAt(i);\n                if (c == LF || c == CR || c == delimChar) {\n                    quote = true;\n                    break;\n                }\n            }\n            if (!quote) {\n                // Quote if the first or last character is whitespace.\n                if (Character.isWhitespace(value.charAt(offset)) || Character.isWhitespace(value.charAt(end - 1))) {\n                    quote = true;\n                }\n            }\n            // In standard CSV a field that contains a quote character must be quoted.\n            // However, when the quote character is a backslash, Apache Commons CSV leaves\n            // backslashes unquoted. (See tests testEscapeBackslash1/4/5.)\n            if (!quote && quoteChar != '\\\\') {\n                for (int i = offset; i < end; i++) {\n                    if (value.charAt(i) == quoteChar) {\n                        quote = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (!quote) {\n            // The value doesn\u2019t require quoting \u2013 just write it out exactly.\n            out.append(value, offset, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    // We must encapsulate the field.\n    out.append(quoteChar);\n\n    // Walk through the field \u2013 double any occurrences of the quote character.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // Append up to and including the quote that needs to be doubled.\n            out.append(value, start, pos + 1);\n            // Reset start to the current position so that the quote will be duplicated.\n            start = pos;\n        }\n        pos++;\n    }\n\n    // Append the remainder of the field.\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}