{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharObject = getQuoteCharacter();\n        // Use a default or handle null quote char if necessary, though modes requiring quotes should have it set.\n        // Assign UNDEFINED and rely on checks below if null.\n        final char quoteChar = quoteCharObject != null ? quoteCharObject.charValue() : Constants.UNDEFINED;\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            // Requires a quote char. Assume format validation ensures this, or handle error.\n            if (quoteCharObject == null) {\n                throw new IllegalStateException(\"QuoteMode.NON_NUMERIC requires a quote character.\");\n            }\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code. Handles null escape char as well.\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            // Requires a quote char. Assume format validation ensures this, or handle error.\n            if (quoteCharObject == null) {\n                throw new IllegalStateException(\"QuoteMode.MINIMAL requires a quote character.\");\n            }\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char firstChar = value.charAt(start);\n\n                // Check for primary reasons to quote: delimiter, quote char, CR/LF\n                // Reset pos to iterate from the start of the relevant value segment\n                pos = start;\n                while (pos < end) {\n                    final char c = value.charAt(pos);\n                    // Note: quoteChar is checked here. It must be valid if quoteCharObject wasn't null.\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break; // Found a mandatory reason to quote\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    // Check for secondary reasons (only if not already quoting)\n                    // Reason 1: Trailing char <= SP (original logic to quote trailing spaces/controls)\n                    char lastChar = value.charAt(end - 1);\n                    if (lastChar <= SP) {\n                        quote = true;\n                    } else {\n                        // Reason 2: Comment marker start (if comments enabled)\n                        final Character commentStart = getCommentMarker();\n                        if (commentStart != null && firstChar == commentStart.charValue()) {\n                            quote = true;\n                        }\n                    }\n                    // Removed: The buggy checks:\n                    // - if (newRecord && (c < '0' || ...)) which incorrectly quoted '\\'\n                    // - if (c <= COMMENT) which was overly broad and incorrect.\n                }\n            }\n\n            // If MINIMAL decided against quoting, print directly and return.\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // Otherwise, fall through to the quoting logic below.\n            break; // End of MINIMAL case\n\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // If we reach here, it means quote=true was set by the policy.\n        // Ensure quoteChar is valid (already checked/required for MINIMAL/NON_NUMERIC, ALL implies it's needed).\n        if (quoteCharObject == null) {\n            // This should ideally not be reachable if format enforces quote char for relevant modes.\n            throw new IllegalStateException(\"Quoting required, but no quote character is defined\");\n        }\n\n        // Perform quoting: write opening quote, value with doubled internal quotes, closing quote.\n        out.append(quoteChar);\n\n        // Reset start and pos for iterating through the value to handle doubling quotes.\n        // The original loop logic for doubling quotes seemed correct.\n        start = offset; // Segment starts at the beginning of the value initially.\n        pos = offset;   // Use pos for iteration.\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point (including the quote character)\n                out.append(value, start, pos + 1);\n                // Set start to the current position (the quote character's index),\n                // so the quote character is effectively written again by the next append, achieving the doubling.\n                start = pos;\n            }\n            pos++;\n        }\n\n        // write the last segment (from the last start position to the end)\n        out.append(value, start, end); // pos is equal to 'end' here\n        out.append(quoteChar); // Closing quote\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}