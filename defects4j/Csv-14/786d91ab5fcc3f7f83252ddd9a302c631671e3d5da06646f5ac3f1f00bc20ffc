{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n\n    // If the escape character is disabled (null)\n    // or if the quote and escape characters are identical,\n    // then simply use the \"non\u2010quoting\" printing logic.\n    if (getEscapeCharacter() == null ||\n        (getQuoteCharacter() != null && getQuoteCharacter().equals(getEscapeCharacter()))) {\n        printAndEscape(value, offset, len, out);\n        return;\n    }\n\n    boolean quote = false;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    // Determine which quote-mode to follow.\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len == 0) {\n                // Quote an empty token only if it\u2019s the first field on the record.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                // Scan all characters: if any character is the delimiter, a newline,\n                // or the quote character itself, then quoting is needed.\n                for (int i = offset; i < end; i++) {\n                    char c = value.charAt(i);\n                    if (c == quoteChar || c == delimChar || c == LF || c == CR) {\n                        quote = true;\n                        break;\n                    }\n                }\n            }\n            if (!quote) {\n                // No quoting needed \u2013 write the original token.\n                out.append(value, offset, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    // If quoting is required, enclose the field with the quote character.\n    // Also double any embedded quote characters.\n    out.append(quoteChar);\n    int last = offset;\n    for (int i = offset; i < end; i++) {\n        char c = value.charAt(i);\n        if (c == quoteChar) {\n            // Write through the embedded quote and duplicate it.\n            out.append(value, last, i + 1);\n            last = i;\n        }\n    }\n    out.append(value, last, end);\n    out.append(quoteChar);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}