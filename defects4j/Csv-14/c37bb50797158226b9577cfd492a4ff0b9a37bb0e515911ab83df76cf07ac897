{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final char quoteChar = getQuoteCharacter().charValue();\n        // Get the actual comment character from the format, as it can be null.\n        final Character formatCommentChar = getCommentCharacter(); \n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                // The previous logic for `newRecord` and non-alphanumeric chars (e.g., `(c < '0' || c > '9' && ...)`)\n                // incorrectly quoted TEXTDATA characters like '\\'.\n                // This fix uses a more specific and standard-compliant check for problematic leading characters.\n                boolean leadingCharNeedsQuote = false;\n                if (c == ' ' || c == '\\t') { // Quote leading space or tab\n                    leadingCharNeedsQuote = true;\n                } else if (newRecord && formatCommentChar != null && c == formatCommentChar.charValue()) { // Quote leading comment char if on a new record\n                    leadingCharNeedsQuote = true;\n                } else if (c >= 1 && c < ' ') { // Quote other control characters (0x01-0x1F), excluding space (0x20)\n                                                 // CR (0x0D) and LF (0x0A) are also handled by the loop below.\n                                                 // This ensures characters that could be misinterpreted by parsers are quoted.\n                    leadingCharNeedsQuote = true;\n                }\n\n                if (leadingCharNeedsQuote) {\n                    quote = true;\n                } else {\n                    // Check for delimiter, quoteChar, CR, LF within the value.\n                    // 'pos' needs to be reset to 'offset' to start scanning from the beginning.\n                    // This loop will increment 'pos' and break if a problematic char is found.\n                    pos = offset; \n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break; // 'pos' is now at the character that caused quoting\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        // If not quoted by internal char rule, check trailing character\n                        pos = end - 1; // Set 'pos' to the last char index for this check\n                        if (len > 0) { // Safety check to prevent IndexOutOfBounds, though already implied by len > 0\n                            c = value.charAt(pos);\n                            // Some other chars at the end caused the parser to fail, so for now\n                            // encapsulate if we end in anything less than ' '\n                            if (c <= ' ') { // Check for trailing space or control character (0x00-0x20)\n                                quote = true;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // This block is generally executed if 'quote' is true due to MINIMAL case,\n        // or if 'ALL' or 'NON_NUMERIC' quote modes were used.\n        if (!quote) {\n            // This is a fallback to ensure the value is written if no quoting is needed\n            // and the previous specific return path in MINIMAL was not taken.\n            out.append(value, start, end);\n            return;\n        }\n\n        // We hit something that needed encapsulation\n        out.append(quoteChar);\n\n        // Pick up where we left off: 'pos' should be positioned on the first character that caused\n        // the need for encapsulation (if an internal character caused it) or at 'offset' (if a leading/trailing rule caused it).\n        // The loop will correctly re-scan from 'offset' if 'pos' was not advanced by the internal character loop.\n        pos = offset; // Reset pos to start of the segment for character doubling logic.\n                      // The original logic implicitly did this by setting pos = offset at the start.\n                      // If the quote reason was a leading/trailing char, pos might be end-1.\n                      // Resetting pos to offset ensures the loop correctly finds all quoteChars for doubling.\n\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // Write out the chunk up until this point, including the current quoteChar.\n                out.append(value, start, pos + 1);\n                // Put the next starting position on the encapsulator so we will\n                // write it out again with the next string (effectively doubling it).\n                start = pos;\n            }\n            pos++;\n        }\n\n        // Write the last segment of the value.\n        out.append(value, start, pos);\n        out.append(quoteChar); // Append the closing quote.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}