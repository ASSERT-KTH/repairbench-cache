{
    "generation": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        // When no quoting is enabled, use the regular escaping.\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            // Always quote an empty token that is the first on the line.\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n            /* \n             * RFC4180 defines TEXTDATA as: \n             *   %x20-21 (space and !) OR %x23-2B (# to +) OR %x2D-7E (- to ~)\n             * We also force quoting if the first character is the comment marker.\n             */\n            if (newRecord && (c == COMMENT ||\n                               !((c >= ' ' && c <= '!') || (c >= '#' && c <= '+') || (c >= '-' && c <= '~')))) {\n                quote = true;\n            } else {\n                while (pos < end) {\n                    c = value.charAt(pos);\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n                if (!quote) {\n                    pos = end - 1;\n                    c = value.charAt(pos);\n                    // Quote if the final character is less than or equal to space.\n                    if (c <= SP) {\n                        quote = true;\n                    }\n                }\n            }\n        }\n\n        if (!quote) {\n            // No quoting needed; output the original value.\n            out.append(value, start, end);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        out.append(value, start, end);\n        return;\n    }\n\n    // Start quoting now.\n    out.append(quoteChar);\n    // Process the field and double any occurrences of the quote character.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // Write out the part up to and including the problematic quote.\n            out.append(value, start, pos + 1);\n            // Reset the start to the current position so it gets output again.\n            start = pos;\n        }\n        pos++;\n    }\n    // Write the remainder and close the quote.\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}