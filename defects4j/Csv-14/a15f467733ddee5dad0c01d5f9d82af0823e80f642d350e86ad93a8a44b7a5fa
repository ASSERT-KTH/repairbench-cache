{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        final int start = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharOpt = getQuoteCharacter();\n        // quoteChar value is only used later if quote is true\n\n        // Define constants locally if not available as class members/imports\n        final char LF = '\\n';\n        final char CR = '\\r';\n        final char SP = ' ';\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n            if (quoteCharOpt == null) {\n                 throw new IllegalStateException(\"Cannot use QuoteMode.ALL with no quote character configured.\");\n            }\n            quote = true;\n            break;\n        case NON_NUMERIC:\n             if (quoteCharOpt == null) {\n                 throw new IllegalStateException(\"Cannot use QuoteMode.NON_NUMERIC with no quote character configured.\");\n            }\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // If quote mode is NONE, just append the value.\n            // Escaping (if an escape char is configured) should be handled by CSVPrinter calling printAndEscape,\n            // not this method. If this method is called with NONE, it implies no escape char, so raw output is correct.\n            out.append(value, start, end);\n            return;\n        case MINIMAL:\n            if (quoteCharOpt == null) {\n                 // If no quote char, MINIMAL behaves like NONE\n                 out.append(value, start, end);\n                 return;\n            }\n            // Only fetch quoteChar if MINIMAL mode might use it\n            final char quoteChar = quoteCharOpt.charValue();\n\n            if (len <= 0) {\n                // Quote empty field if it's the first on a new record\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char firstChar = value.charAt(start);\n                // Rule: Quote if starts or ends with SP or control characters (<= SP)\n                // Rule: Quote if contains CR, LF, delimiter, or the quote character itself.\n                if (firstChar <= SP) {\n                    quote = true;\n                } else {\n                    // Search for internal triggers (CR, LF, Delimiter, Quote Char)\n                    // Use a local variable 'pos' for the search loop.\n                    int pos = start;\n                    while (pos < end) {\n                        final char c = value.charAt(pos);\n                        // Check for standard triggers for quoting\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break; // Found a trigger char\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) { // If no internal trigger, check the trailing character\n                        final char lastChar = value.charAt(end - 1);\n                        if (lastChar <= SP) { // Quote if ends with space or control char (<= SP)\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            // MINIMAL decision logic ends, 'quote' is set.\n            break; // Break from MINIMAL case\n\n        default:\n            throw new IllegalStateException(\"Unexpected QuoteMode value: \" + quoteModePolicy);\n        } // End of switch\n\n        // ---- Write the output ----\n\n        if (!quote) {\n            // No quoting needed\n            out.append(value, start, end);\n        } else {\n            // Quoting is needed. We know quoteCharOpt is not null here for modes ALL, NON_NUMERIC, MINIMAL.\n            final char quoteChar = quoteCharOpt.charValue();\n            out.append(quoteChar);\n\n            // Iterate through the value[start..end-1], doubling internal quote characters.\n            int segmentStart = start;\n            for (int i = start; i < end; i++) { // Use local loop variable 'i'\n                final char c = value.charAt(i);\n                if (c == quoteChar) {\n                    // Append segment before the quote char\n                    out.append(value, segmentStart, i);\n                    // Append the quote char twice\n                    out.append(quoteChar);\n                    out.append(quoteChar);\n                    // Update start of the next segment to be after the processed quote char\n                    segmentStart = i + 1;\n                }\n            }\n\n            // Write the final segment (from last special char/start to the end)\n            out.append(value, segmentStart, end);\n\n            out.append(quoteChar); // Append closing quote\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}