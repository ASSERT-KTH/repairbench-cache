{
    "generation": "// Fixed version of printAndQuote\nprivate void printAndQuote(final Object object,\n                           final CharSequence value,\n                           final int offset,\n                           final int len,\n                           final Appendable out,\n                           final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token if it's the first on the line\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                // examine the first character\n                char c = value.charAt(pos);\n                // if it's at or below the comment threshold, we must quote\n                if (c <= COMMENT) {\n                    quote = true;\n                } else {\n                    // scan for characters that force quoting\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n                    // if still not quoting, check last character for trailing space/tab\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n                }\n            }\n            if (!quote) {\n                // no encapsulation needed - write out the original value\n                out.append(value, start, end);\n                return;\n            }\n            break;\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n    }\n\n    if (!quote) {\n        // no encapsulation needed - write out the original value\n        out.append(value, start, end);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    out.append(quoteChar);\n\n    // Pick up where we left off: pos should be positioned on the first character that caused\n    // the need for encapsulation.\n    while (pos < end) {\n        final char c = value.charAt(pos);\n        if (c == quoteChar) {\n            // write out the chunk up until this point (including the quote)\n            out.append(value, start, pos + 1);\n            // next segment starts at this quote (so it will get doubled)\n            start = pos;\n        }\n        pos++;\n    }\n\n    // write the last segment\n    out.append(value, start, pos);\n    out.append(quoteChar);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}