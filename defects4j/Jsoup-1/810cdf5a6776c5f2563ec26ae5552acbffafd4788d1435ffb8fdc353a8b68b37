{
    "generation": "    // does not recurse.\n    private void normalise(Element element) {\n        List<Node> toMove = new ArrayList<Node>();\n        for (Node node: element.childNodes) {\n            if (node instanceof TextNode) {\n                TextNode tn = (TextNode) node;\n                if (!tn.isBlank())\n                    toMove.add(tn);\n            }\n        }\n\n        // The test case \"foo <b>bar</b> baz\" implies that \"foo\" (a TextNode\n        // likely at the document root level) needs to be moved to the beginning\n        // of the <body> element.\n        //\n        // The original code appended these nodes to the end of the body,\n        // leading to \"bar baz foo\" instead of \"foo bar baz\".\n        //\n        // To move nodes to the beginning of the body while maintaining their\n        // relative order, we need to process them in reverse order when\n        // using `prependChild()`.\n        java.util.Collections.reverse(toMove);\n\n        for (Node node: toMove) {\n            element.removeChild(node);\n            // The original code `body().appendChild(new TextNode(\" \", \"\"));`\n            // would add an extra space before each moved text node, which is\n            // not desired for the test case (e.g., \"foo  bar baz\"). Jsoup's\n            // text() method typically collapses whitespace, so explicit space\n            // insertion here is likely incorrect.\n            body().prependChild(node);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}