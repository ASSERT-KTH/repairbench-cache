{
    "generation": "    // does not recurse.\n    private void normalise(Element element) {\n        if (element == null || element.childNodes() == null) {\n            return;\n        }\n\n        List<Node> toMove = new ArrayList<Node>();\n        for (Node node : element.childNodes()) {\n            if (node instanceof TextNode) {\n                TextNode tn = (TextNode) node;\n                if (!tn.isBlank()) {\n                    toMove.add(tn);\n                }\n            }\n        }\n\n        if (toMove.isEmpty()) {\n            return;\n        }\n\n        // Find the first non-empty text node in the body (or root element)\n        Element root = element.ownerDocument().body();\n        if (root == null) {\n            root = element.ownerDocument();\n        }\n\n        // Insert all nodes before existing content\n        int insertPos = 0;\n        List<Node> bodyChildren = root.childNodes();\n        for (int i = 0; i < bodyChildren.size(); i++) {\n            Node child = bodyChildren.get(i);\n            if (child instanceof TextNode && !((TextNode)child).isBlank()) {\n                insertPos = i;\n                break;\n            }\n        }\n\n        for (Node node : toMove) {\n            element.removeChild(node);\n            root.insertChildren(insertPos, Collections.singletonList(node));\n            // Add space after each inserted text node (except if it was the last one)\n            if (toMove.indexOf(node) < toMove.size() - 1) {\n                root.insertChildren(insertPos + 1, Collections.singletonList(new TextNode(\" \", \"\")));\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}