{
    "generation": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    // Check: String(a) -> '' + (a)\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Check for the correct pattern: String(a)\n      Node value = callTarget.getNext();\n      // Make sure there is exactly one argument, and\n      // it is an immutable value (string, number, boolean, null, void).\n      // We don't want to fold String(someObject) because\n      // String(o) !== '' + o if o.toString !== o.valueOf.\n      // See http://code.google.com/p/closure-compiler/issues/detail?id=759\n      // Also, fold String() to \"\"\n      if (value == null) {\n        Node emptyString = IR.string(\"\");\n        emptyString.srcrefTreeIfMissing(n);\n        n.getParent().replaceChild(n, emptyString);\n        reportCodeChange();\n        return emptyString;\n      } else if (value.getNext() == null && NodeUtil.isImmutableValue(value)) {\n        // Fold String(a) to '' + (a) on immutable literals\n        Node emptyString = IR.string(\"\");\n        // Use the source info of the original call for the new empty string.\n        emptyString.srcref(n);\n\n        Node addition = IR.add(\n            emptyString,\n            value.detachFromParent());\n        // Use the source info of the original call for the new ADD node.\n        addition.srcrefTreeIfMissing(n);\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}