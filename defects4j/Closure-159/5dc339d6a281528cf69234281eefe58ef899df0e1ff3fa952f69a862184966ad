{
    "generation": "  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.getType() == Token.CALL) {\n      Node callTarget = node.getFirstChild(); // The expression representing the function being called\n\n      // Case 1: The call target is a simple name or a qualified name (e.g., 'foo()' or 'Foo.Bar.baz()')\n      if (callTarget.isQualifiedName()) {\n        changed.add(callTarget.getQualifiedName());\n      }\n      // Case 2: The call target is a GETPROP (e.g., 'obj.method()' or 'funcRef.call()')\n      else if (callTarget.getType() == Token.GETPROP) {\n        // A GETPROP node has two children: the target object/expression and the property name.\n        // The property name is usually a STRING node.\n        Node propertyNameNode = callTarget.getChildAtIndex(1);\n        \n        if (propertyNameNode != null && propertyNameNode.isString()) {\n          String propertyName = propertyNameNode.getString();\n          \n          // Subcase 2a: It's a '.call' or '.apply' invocation (e.g., 'initialize.call(this, options)')\n          if (\"call\".equals(propertyName) || \"apply\".equals(propertyName)) {\n            // The actual function being called is the target object/expression of the GETPROP.\n            Node actualFunctionTarget = callTarget.getFirstChild();\n            // If this target is a qualified name (e.g., 'initialize' or 'Foo.Bar.baz'), add it.\n            if (actualFunctionTarget.isQualifiedName()) {\n              changed.add(actualFunctionTarget.getQualifiedName());\n            }\n            // If actualFunctionTarget is not a qualified name (e.g., '(function(){}).call()'),\n            // we don't extract a static name here. The recursive traversal below will handle its children.\n          }\n          // Subcase 2b: It's a regular method call (e.g., 'obj.method()')\n          // If the GETPROP itself forms a qualified name, it would have been caught by callTarget.isQualifiedName() above.\n          // If not (e.g., 'this.method()'), we generally don't add the method name directly\n          // unless it represents a named function available for inlining.\n          // The current `InlineFunctions` pass typically handles top-level functions or functions assigned to qualified names.\n        }\n      }\n      // Other types of callTarget (e.g., GETELEM for arr[0](), or FUNCTION literal for (function(){})())\n      // are not processed for a static name here, as they typically don't represent functions\n      // that are directly inlinable by their name in the same way.\n      // Their sub-expressions will be recursively visited.\n    }\n\n    // Recursively visit all children of the current node to find nested calls.\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}