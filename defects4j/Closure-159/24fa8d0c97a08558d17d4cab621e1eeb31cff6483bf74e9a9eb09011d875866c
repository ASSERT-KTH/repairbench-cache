{
    "generation": "  /**\n   * @see #findCalledFunctions(Node)\n   */\n  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.isCall()) { // Check if the node is a CALL node\n      Node functionNode = node.getFirstChild();\n      // Direct call: foo()\n      if (functionNode.isName()) {\n        changed.add(functionNode.getString());\n      }\n      // Call via .call or .apply: foo.call(...) or foo.apply(...)\n      else if (functionNode.isGetProp()) {\n        Node propNameNode = functionNode.getLastChild(); // The property name (\"call\" or \"apply\")\n        if (propNameNode.isString()) {\n          String propName = propNameNode.getString();\n          if (\"call\".equals(propName) || \"apply\".equals(propName)) {\n            Node targetNode = functionNode.getFirstChild(); // The object/function before \".call\" or \".apply\"\n            // If the function being called via .call/.apply is a simple name, add it.\n            if (targetNode.isName()) {\n              changed.add(targetNode.getString());\n            }\n            // TODO(brad): Handle methods applied to \"this\",\n            // e.g. this.foo.call(this);\n            // TODO(johnlenz): Add support for Function.prototype.bind and\n            // window.setTimeout, etc. Also add support for goog.bind.\n          }\n        }\n      }\n    }\n\n    // Recursively traverse children\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}