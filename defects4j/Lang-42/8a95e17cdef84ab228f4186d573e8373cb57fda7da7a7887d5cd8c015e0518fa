{
    "generation": "    /**\n     * <p>\n     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n     * passed.\n     * </p>\n     *\n     * @param writer\n     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n     * @param str\n     *            The <code>String</code> to escape. Assumed to be a non-null value.\n     * @throws IOException\n     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n     *             or {@link Writer#write(String)} methods.\n     *\n     * @see #escape(String)\n     * @see Writer\n     */\n    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; ) {\n            int codepoint = str.codePointAt(i);\n            // Assuming entityName(int) exists or the underlying lookup mechanism handles int codepoints.\n            // In Apache Commons Lang Entities, the lookup map typically uses Integer codepoints.\n            // If entityName specifically requires a char, this might need adjustment based on the\n            // specific implementation of entityName and the Entities class structure.\n            // However, standard HTML entity definitions include codepoints beyond the BMP,\n            // so handling int codepoints is expected.\n            String entityName;\n            // Check if the codepoint is within the BMP range where entityName(char) might be applicable\n            // or if it's supplementary. A robust entityName should handle int codepoints directly.\n            // We call a hypothetical entityName(int) for clarity. If the actual method signature\n            // is entityName(char), it implies supplementary characters cannot have named entities\n            // in this specific implementation, which is unlikely for a general HTML escaper.\n            // Let's stick to the assumption that the lookup handles int codepoints.\n            // We use a hypothetical method lookupEntityName(int) to represent this lookup.\n            // If the actual class has `entityName(int)`, use that. If it only has `entityName(char)`,\n            // then supplementary characters won't get named entities.\n\n            // Based on the context of Apache Commons Lang Entities, the lookup map uses Integer keys.\n            // Let's assume `this.entityName(codepoint)` works correctly by looking up the integer codepoint.\n            // (The original method `entityName(char)` would implicitly cast char to int for lookup if needed,\n            // but wouldn't handle supplementary characters correctly).\n            // Let's proceed assuming `this.entityName(int)` or equivalent capability exists.\n            // Note: The actual implementation in Entities.java might have different internal methods.\n            // The key is to look up the *codepoint* for a named entity.\n\n            // Simulate lookup based on codepoint (assuming internal map uses Integer keys)\n            // This requires access to the internal map or a method that takes an int codepoint.\n            // If we strictly adhere to the original `entityName(char)` signature, we need to check\n            // if the codepoint is BMP first.\n            if (codepoint <= 0xFFFF) {\n                 entityName = this.entityName((char)codepoint); // Use existing method for BMP\n            } else {\n                 // No named entities for supplementary characters if entityName only takes char.\n                 // However, a proper HTML escaper should support this via an int-based lookup.\n                 // Assuming the class has a mechanism (e.g., internal map lookup) for int codepoints:\n                 entityName = null; // Placeholder: Replace with actual lookup if available, e.g., entities.getName(codepoint)\n                 // If relying *only* on the provided `entityName(char)` method, this branch implies no named entities > 0xFFFF.\n            }\n\n\n            if (entityName == null) {\n                // Check if the codepoint is outside the basic ASCII range (0-127)\n                // or needs escaping for other reasons (e.g. '<', '>', '&', '\"')\n                // The original code escaped > 0x7F. HTML escaping also typically escapes <, >, &, \".\n                // Assuming this simplified logic is sufficient for the specific context (or that\n                // named entities cover < > & \"). If not, add checks for those characters.\n                if (codepoint > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(codepoint, 10));\n                    writer.write(';');\n                } else {\n                    // Codepoint is <= 0x7F (ASCII) and not a named entity\n                    writer.write(codepoint); // Writes the character corresponding to the codepoint\n                }\n            } else {\n                // Found a named entity for the codepoint\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            }\n            // Advance the index by the number of char units used by the codepoint\n            i += Character.charCount(codepoint);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}