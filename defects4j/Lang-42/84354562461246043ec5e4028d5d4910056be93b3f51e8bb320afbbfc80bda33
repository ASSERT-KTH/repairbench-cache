{
    "generation": "    /**\n     * <p>\n     * Escapes the characters in the <code>String</code> passed and writes the result to the <code>Writer</code>\n     * passed.\n     * </p>\n     * \n     * @param writer\n     *            The <code>Writer</code> to write the results of the escaping to. Assumed to be a non-null value.\n     * @param str\n     *            The <code>String</code> to escape. Assumed to be a non-null value.\n     * @throws IOException\n     *             when <code>Writer</code> passed throws the exception from calls to the {@link Writer#write(int)}\n     *             methods.\n     * \n     * @see #escape(String)\n     * @see Writer\n     */\n    public void escape(Writer writer, String str) throws IOException {\n        // Iterate through the string by code points to correctly handle\n        // supplementary characters (those outside the Basic Multilingual Plane, U+0000 to U+FFFF).\n        // Java's char is a 16-bit UTF-16 code unit, so supplementary characters are represented by two chars (a surrogate pair).\n        // The original code iterated by char, leading to incorrect escaping of surrogate pairs as two separate entities.\n        int len = str.length();\n        for (int i = 0; i < len; ) { // 'i' is incremented inside the loop based on the code point size\n            int codePoint = str.codePointAt(i); // Get the full Unicode code point at the current index\n\n            String entityNameForCodePoint = null;\n            // Check if the code point is within the Basic Multilingual Plane (BMP).\n            // The `entityName(char)` method is likely designed to map only BMP characters\n            // (those representable by a single char) to named HTML entities.\n            // Supplementary characters typically do not have named HTML entities.\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                entityNameForCodePoint = this.entityName((char) codePoint);\n            }\n\n            if (entityNameForCodePoint == null) {\n                // No named HTML entity found for this code point, or it's a supplementary character.\n                // In such cases, determine if numerical escaping is required.\n                // The condition `c > 0x7F` from the original code effectively meant \"not ASCII\".\n                // This logic should be applied to the full code point.\n                // All non-ASCII characters (including supplementary characters) should be numerically escaped\n                // if they don't have a named entity.\n                if (codePoint > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(codePoint, 10)); // Write the decimal value of the code point\n                    writer.write(';');\n                } else {\n                    // It's an ASCII character (codePoint <= 0x7F) and it does not have a named entity.\n                    // Write the character directly.\n                    // This covers basic ASCII characters like 'A', '1', space, etc., that don't need escaping.\n                    writer.write(codePoint); \n                }\n            } else {\n                // A named HTML entity was found for this code point (must be a BMP character).\n                writer.write('&');\n                writer.write(entityNameForCodePoint);\n                writer.write(';');\n            }\n\n            // Advance the index 'i' by the number of Java 'char's that make up the current code point.\n            // This is 1 for BMP characters and 2 for supplementary characters.\n            i += Character.charCount(codePoint);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}