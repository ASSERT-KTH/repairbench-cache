{
    "generation": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear\n            // to be in specification of class. OS X Java parses it to\n            // a wrong value.\n            // behaviour based on comment and existing tests: should return null?\n            // However, throwing NumberFormatException seems more appropriate for an invalid format.\n            // Let's keep original behaviour which seems to be returning null (although test might expect exception).\n            // Reverting to throwing exception as '--' is not valid number format.\n            // Update: Original code returns null. Keep it that way to avoid breaking other potential users.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            // Use createInteger as it correctly handles potential BigInteger for large hex values\n            return createInteger(val);\n        }\n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1; // Handles 'e' or 'E' correctly\n\n        // Reset expPos if it is out of bounds\n        if (expPos > val.length()) {\n             expPos = -1;\n        }\n\n        if (decPos > -1) {\n            // Found decimal point\n            if (expPos > -1) {\n                // Found exponent marker\n                if (expPos < decPos || expPos > val.length()) { // Check if 'e' is after '.' and within bounds\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n                mant = val.substring(0, decPos);\n            } else {\n                // No exponent marker\n                dec = val.substring(decPos + 1);\n                mant = val.substring(0, decPos);\n            }\n             // Handle case of \".\" or \"-.\" considered alone. The parsing below will likely throw.\n             // We need to ensure mant or dec is not empty if decPos > -1\n             // Example: \".\" or \"-.\"\n             if (mant.length() == 0 && dec.length() == 0) {\n                  throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n        } else {\n            // No decimal point\n            if (expPos > -1) {\n                 // Found exponent marker\n                 if (expPos > val.length()) { // Check index bounds\n                      throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n                mant = val.substring(0, expPos);\n            } else {\n                // No decimal point, no exponent marker\n                mant = val;\n            }\n            dec = null; // No decimal part\n        }\n\n        // Check for trailing type qualifier L, l, F, f, D, d\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            // If exponent marker exists and is not the second to last char (i.e. valid like 1e5L)\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            // The numeric part before the type qualifier\n            String numeric = val.substring(0, val.length() - 1);\n            // isAllZeros check - used to check for loss of precision in float/double parsing\n            // Note: isAllZeros must handle null returning true.\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp); // Use mant and exp derived from original string segmentation\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // Must be an integer (no decimal point, no exponent)\n                    // Check numeric part is not empty and consists of digits (optional sign)\n                    if (dec == null\n                        && exp == null // Check the derived exp String, not just expPos\n                        && !numeric.isEmpty() // FIX: check for empty string (\"L\")\n                        && (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric))) {\n                            // Check if the numeric part is actually digits\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            // Too big for a long, return as BigInteger\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    // Invalid format for L/l qualifier (e.g., has '.', 'e', or non-digits)\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        // Use helper method which should handle NumberFormatException\n                        Float f = NumberUtils.createFloat(numeric);\n                        // Check for Inf/NaN and precision loss (0.0F from non-zero string)\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number, fall through to try Double\n                    }\n                    // Fall \u0631\u0645\u0648\u0632 through intended\n                case 'd' :\n                case 'D' :\n                    try {\n                         // Use helper method which should handle NumberFormatException\n                        Double d = NumberUtils.createDouble(numeric);\n                         // Check for Inf/NaN and precision loss (0.0D from non-zero string)\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                         // ignore the bad number, fall through to try BigDecimal\n                    }\n                    try {\n                        // Final fallback for F/f/D/d is BigDecimal for precision\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // If even BigDecimal fails, fall through to default exception\n                    }\n                    // Fall through intended\n                default :\n                    // Invalid type qualifier character\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            // No type qualifier, last character is digit or '.'\n            // Get exponent part if exists\n             if (expPos > -1 && expPos < val.length()) {\n                exp = val.substring(expPos + 1);\n            } else {\n                exp = null;\n            }\n\n            if (dec == null && exp == null) {\n                // No decimal, no exponent => integer type\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // ignore, try next type\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // ignore, try next type\n                }\n                // Final fallback for integer types is BigInteger\n                return createBigInteger(val);\n\n            } else {\n                // Has decimal or exponent => floating point type\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                     // Use helper method which should handle NumberFormatException\n                    Float f = createFloat(val);\n                     // Check for Inf/NaN and precision loss (0.0F from non-zero string)\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore, try next type\n                }\n                try {\n                     // Use helper method which should handle NumberFormatException\n                    Double d = createDouble(val);\n                     // Check for Inf/NaN and precision loss (0.0D from non-zero string)\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                     // ignore, try next type\n                }\n                // Final fallback for float types is BigDecimal\n                return createBigDecimal(val);\n            }\n        }\n    }\n\n    // Dummy helper methods assumed to exist based on original code for context\n    private static boolean isDigits(String str) {\n        if (str == null || str.length() == 0) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isAllZeros(String str) {\n         if (str == null) {\n            return true; // Treat null as all zeros for the check logic\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0; // Empty string is not all zeros? Based on usage, empty means lack of component. Let's return true for empty.\n    }\n\n    // Assume these exist and function correctly, throwing NFE if invalid format for the specific type\n    private static Integer createInteger(String val) throws NumberFormatException { return Integer.valueOf(val); }\n    private static Long createLong(String val) throws NumberFormatException { return Long.valueOf(val); }\n    private static java.math.BigInteger createBigInteger(String val) throws NumberFormatException { return new java.math.BigInteger(val); }\n    private static Float createFloat(String val) throws NumberFormatException { return Float.valueOf(val); }\n    private static Double createDouble(String val) throws NumberFormatException { return Double.valueOf(val); }\n    private static java.math.BigDecimal createBigDecimal(String val) throws NumberFormatException {\n        // BigDecimal constructor has issues with empty strings unlike Float/Double.valueOf\n        if (val != null && val.length() == 0) {\n           throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        return new java.math.BigDecimal(val);\n    }\n    // Reference to NumberUtils static methods needed if they exist in the same class\n    static class NumberUtils {\n        public static Float createFloat(String val) throws NumberFormatException { return Float.valueOf(val); }\n        public static Double createDouble(String val) throws NumberFormatException { return Double.valueOf(val); }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}