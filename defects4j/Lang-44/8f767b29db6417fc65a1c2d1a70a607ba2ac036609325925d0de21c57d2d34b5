{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Added imports for clarity, assuming they are available.\n// Removed class definition as only the method is required.\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (or <code>0X</code> or <code>-0X</code>),\n     * it will be interpreted as a hexadecimal integer. Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear\n            // to be in specification of class. OS X Java parses it to\n            // a wrong value. (LANG-1BigDecimal constructor is buggy)\n            // Return null as historically users may have expected this behavior.\n            return null;\n        }\n        // Handle hexadecimal numbers (0x or 0X)\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\") || val.startsWith(\"0X\") || val.startsWith(\"-0X\")) {\n             int signLen = (val.startsWith(\"-\") ? 1 : 0);\n             // Check if string is only \"0x\", \"-0x\", \"0X\", \"-0X\"\n             if (val.length() <= signLen + 2) {\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n             // Ensure characters after hex prefix are valid hex digits\n             for (int i = signLen + 2; i < val.length(); i++) {\n                 char c = val.charAt(i);\n                 if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))) {\n                     throw new NumberFormatException(val + \" is not a valid number.\"); // Invalid hex character\n                 }\n             }\n             // Use Integer.decode to handle hex, or implement custom logic if needed elsewhere\n             // Assuming createInteger handles hex like Integer.decode does\n            return createInteger(val);\n        }\n\n        char lastChar = val.charAt(val.length() - 1);\n        String mant; // Part before decimal/exponent\n        String exp;  // Part after exponent marker\n\n        int decPos = val.indexOf('.');\n        int ePos = val.indexOf('e');\n        int EPos = val.indexOf('E');\n        int expPos = Math.max(ePos, EPos); // Store correct exponent position\n\n        // Check if the string represents a qualified number (ends in L,l,F,f,D,d)\n        if (Character.isLetter(lastChar) && lastChar != 'e' && lastChar != 'E') {\n            // Check for valid suffixes\n            if (lastChar == 'd' || lastChar == 'D' || lastChar == 'f' || lastChar == 'F' || lastChar == 'l' || lastChar == 'L') {\n                 // Check if suffix is immediately after exponent marker (e.g., \"1eL\") -> invalid\n                 if (expPos != -1 && expPos == val.length() - 2) {\n                     throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n\n                 String numeric = val.substring(0, val.length() - 1); // String without the suffix\n\n                 // FIX: Check if the numeric part is empty (e.g., \"L\") or just a sign (\"-L\", \"+L\")\n                 if (numeric.length() == 0 || numeric.equals(\"-\") || numeric.equals(\"+\")) {\n                     throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n                 // Check for \"--\" prefix within the numeric part as well\n                 if (numeric.startsWith(\"--\")) {\n                     return null; // Consistent with the initial check\n                 }\n\n                 // Calculate mantissa/exponent parts based on 'numeric' for allZeros check\n                 // This logic assumes isAllZeros helper exists and correctly checks if parts are all zero digits.\n                 String numMant;\n                 String numExp;\n                 int numDecPos = numeric.indexOf('.');\n                 int numEPos = numeric.indexOf('e');\n                 int numBigEPos = numeric.indexOf('E');\n                 int numExpPos = Math.max(numEPos, numBigEPos);\n\n                 if (numDecPos > -1) {\n                     if (numExpPos > -1) {\n                         if (numExpPos < numDecPos || numExpPos > numeric.length()) { // Check bounds and order\n                             throw new NumberFormatException(val + \" is not a valid number.\");\n                         }\n                         numMant = numeric.substring(0, numDecPos);\n                         numExp = numeric.substring(numExpPos + 1);\n                     } else {\n                         numMant = numeric.substring(0, numDecPos);\n                         numExp = null;\n                     }\n                 } else { // No decimal point\n                     if (numExpPos > -1) {\n                          if (numExpPos > numeric.length()) { // Check bounds\n                              throw new NumberFormatException(val + \" is not a valid number.\");\n                          }\n                         numMant = numeric.substring(0, numExpPos);\n                         numExp = numeric.substring(numExpPos + 1);\n                     } else { // Integer format\n                         numMant = numeric;\n                         numExp = null;\n                     }\n                 }\n                 // Assuming isAllZeros helper exists and handles null correctly\n                 boolean allZeros = isAllZeros(numMant) && isAllZeros(numExp);\n\n                 switch (lastChar) {\n                     case 'l':\n                     case 'L':\n                         // Long type requested: numeric part must not have '.', 'e', or 'E'\n                         if (numDecPos == -1 && numExpPos == -1) {\n                             try {\n                                 // Rely on createLong/BigInteger to handle format parsing and range.\n                                 // createBigInteger should throw NFE for invalid formats like \"abcL\".\n                                 return createLong(numeric);\n                             } catch (NumberFormatException nfe) {\n                                 // Input is likely too large for Long, try BigInteger\n                                 return createBigInteger(numeric);\n                             }\n                         }\n                         // Contains invalid characters for Long type\n                         throw new NumberFormatException(val + \" is not a valid number.\");\n                     case 'f':\n                     case 'F':\n                         try {\n                             // Assuming createFloat helper exists (could be Float.valueOf)\n                             Float f = createFloat(numeric);\n                             // Check for infinity and potential precision loss (value is 0, but string wasn't)\n                             if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                                 return f;\n                             }\n                             // If Float is not suitable, fall through to try Double/BigDecimal\n                         } catch (NumberFormatException e) {\n                             // Fall through: Allow Double/BigDecimal check even if Float parsing fails?\n                             // Original code suggests fall-through.\n                         }\n                         // Fall through\n                     case 'd':\n                     case 'D':\n                         try {\n                            // Assuming createDouble helper exists (could be Double.valueOf)\n                             Double d = createDouble(numeric);\n                             // FIX: Use doubleValue() for the check, not floatValue()\n                             if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                                 return d;\n                             }\n                             // If Double is not suitable, fall through to try BigDecimal\n                         } catch (NumberFormatException nfe) {\n                             // Fall through\n                         }\n                         try {\n                            // Assuming createBigDecimal helper exists (could be new BigDecimal)\n                             return createBigDecimal(numeric);\n                         } catch (NumberFormatException e) {\n                             // If Float/Double were unsuitable or failed, and BigDecimal also fails,\n                             // the original numeric string was likely invalid.\n                         }\n                         // If we reach here, indicates failure after fall-through.\n                         throw new NumberFormatException(val + \" is not a valid number.\");\n\n                     // Default case should not be reachable as suffix is checked above\n                 }\n            } else {\n                 // Last character is a letter but not a valid suffix (e, E handled elsewhere)\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n\n        } else { // Last character is a digit or potentially 'e'/'E' if exponent is last\n            // Check for invalid exponent formats like \"1e\", \"1e+\", \"1e-\" at the end\n             if (expPos > -1 && expPos >= val.length() - 1) { // Exponent marker is last char\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n             }\n             if (expPos > -1 && (val.charAt(expPos+1) == '+' || val.charAt(expPos+1) == '-')) {\n                 if (expPos + 1 == val.length() - 1) { // Sign is the very last char after e/E\n                     throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n             }\n\n            // No type suffix; determine type based on content (decimal/exponent)\n            if (decPos == -1 && expPos == -1) {\n                // Looks like an Integer, Long, or BigInteger\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) { /* ignore */ }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) { /* ignore */ }\n                // Rely on createBigInteger for final validation (handles range and format like \"+\")\n                return createBigInteger(val);\n\n            } else {\n                // Looks like a Float, Double, or BigDecimal\n                 // Calculate mantissa/exponent parts based on 'val' for allZeros check\n                 String currentMant;\n                 String currentExp;\n                 if (decPos > -1) {\n                     if (expPos > -1) {\n                         // Ensure exponent comes after decimal for standard notation\n                          if (expPos < decPos) {\n                              throw new NumberFormatException(val + \" is not a valid number.\");\n                          }\n                         currentMant = val.substring(0, decPos);\n                         currentExp = val.substring(expPos + 1);\n                     } else { // Has decimal, no exponent\n                         currentMant = val.substring(0, decPos);\n                         currentExp = null;\n                     }\n                 } else { // No decimal, must have exponent if we're in this else block\n                     currentMant = val.substring(0, expPos);\n                     currentExp = val.substring(expPos + 1);\n                 }\n                boolean allZeros = isAllZeros(currentMant) && isAllZeros(currentExp);\n\n                try {\n                    Float f = createFloat(val);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) { /* ignore */ }\n                try {\n                    Double d = createDouble(val);\n                     // FIX: Use doubleValue() for the check\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) { /* ignore */ }\n\n                // Rely on createBigDecimal for final validation (handles range and format)\n                return createBigDecimal(val);\n            }\n        }\n        // This part should ideally not be reachable if all paths return or throw.\n        // However, to satisfy compiler, we might need a throw here.\n        // throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n\n    // NOTE: The following helper methods are assumed to exist elsewhere in the NumberUtils class.\n    // These are just stubs for context.\n    private static Integer createInteger(String val) { return Integer.decode(val); }\n    private static Long createLong(String val) { return Long.valueOf(val); }\n    private static BigInteger createBigInteger(String val) { return new BigInteger(val); }\n    private static Float createFloat(String val) { return Float.valueOf(val); }\n    private static Double createDouble(String val) { return Double.valueOf(val); }\n    private static BigDecimal createBigDecimal(String val) { return new BigDecimal(val); }\n    private static boolean isAllZeros(String str) {\n        if (str == null || str.length() == 0) {\n            return true; // Treat null or empty string as all zeros for check purpose\n        }\n        // Check if string contains only '0' characters (ignoring sign if present)\n        int start = 0;\n        if (str.charAt(0) == '-' || str.charAt(0) == '+') {\n            start = 1;\n             // If string is only a sign, it's not considered \"all zeros\" in a numeric sense,\n             // but for the purpose of checking if Float/Double became 0 due to underflow,\n             // an empty mantissa/exponent part can be treated as zero. Let's allow empty after sign.\n             if (str.length() == 1) return true;\n        }\n        for (int i = start; i < str.length(); i++) {\n            if (str.charAt(i) != '0') {\n                // Allow decimal point in mantissa? Original intent unclear.\n                // Safest assumption: only '0' is allowed for the \"all zeros\" check.\n                 if (str.charAt(i) == '.') continue; // Allow decimal point within mantissa part for isAllZeros check? Seems reasonable.\n                return false;\n            }\n        }\n        return true; // Contains only zeros (and potentially a sign or decimal points)\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}