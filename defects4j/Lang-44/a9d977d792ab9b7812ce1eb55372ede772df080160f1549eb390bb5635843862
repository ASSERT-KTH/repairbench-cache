{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assume NumberUtils has helper methods like createLong, createFloat etc.\n// Assume they behave like standard Java parsing methods (Long.parseLong, Float.valueOf, etc.)\n// Assume NumberUtils has helper: isDigits(String)\n// Assume NumberUtils has helper: isAllZeros(String) - checks if all digits are zero\n\n/**\n * <p>Turns a string value into a java.lang.Number.</p>\n *\n * <p>First, the value is examined for a type qualifier on the end\n * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n * trying to create successively larger types from the type specified\n * until one is found that can hold the value.</p>\n *\n * <p>If a type specifier is not found, it will check for a decimal point\n * and then try successively larger types from <code>Integer</code> to\n * <code>BigInteger</code> and from <code>Float</code> to\n * <code>BigDecimal</code>.</p>\n *\n * <p>If the string starts with <code>0x</code> or <code>-0x</code> (or <code>0X</code>, <code>-0X</code>, <code>#</code>),\n * it will be interpreted as a hexadecimal integer. Values with leading\n * <code>0</code>'s will not be interpreted as octal.</p>\n *\n * @param val String containing a number\n * @return Number created from the string\n * @throws NumberFormatException if the value cannot be converted\n */\npublic static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.isEmpty()) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    // LANG-411: BigDecimal constructor accepts \"--\", but we don't want that\n    if (val.startsWith(\"--\")) {\n        return null;\n    }\n    // Handle Hexadecimal Numbers robustly using BigInteger\n    if (val.startsWith(\"0x\") || val.startsWith(\"-0x\") || val.startsWith(\"0X\") || val.startsWith(\"-0X\") || val.startsWith(\"#\")) {\n        int index = 0;\n        boolean negate = false;\n        if (val.startsWith(\"-\")) {\n            negate = true;\n            index++;\n        }\n        // Determine start of hex digits\n        if (val.startsWith(\"0x\", index) || val.startsWith(\"0X\", index)) {\n            index += 2;\n        } else if (val.startsWith(\"#\", index)) {\n            index++;\n        } else {\n            // Only possible if val is \"-\", \"-0x\", \"-0X\", \"-#\" which are invalid\n            throw new NumberFormatException(val + \" is not a valid hexadecimal number.\");\n        }\n\n        if (index >= val.length()) { // e.g., \"0x\", \"-0X\"\n            throw new NumberFormatException(val + \" is not a valid hexadecimal number.\");\n        }\n        String hexDigits = val.substring(index);\n\n        try {\n            BigInteger bi = new BigInteger(hexDigits, 16);\n            if (negate) {\n                bi = bi.negate();\n            }\n            // Although BigInteger is safe, the original code returned Integer.\n            // Let's return BigInteger as it handles all valid hex inputs.\n            // Callers can check instance type if needed.\n            return bi;\n        } catch (NumberFormatException e) {\n            // Wrap exception for clarity\n            throw new NumberFormatException(val + \" is not a valid hexadecimal number. \" + e.getMessage());\n        }\n    }\n\n    String numeric = val;\n    char lastChar = val.charAt(val.length() - 1);\n    boolean hasQualifier = false;\n\n    // Check for and remove type qualifier\n    if (lastChar == 'f' || lastChar == 'F' ||\n        lastChar == 'd' || lastChar == 'D' ||\n        lastChar == 'l' || lastChar == 'L') {\n        hasQualifier = true;\n        numeric = val.substring(0, val.length() - 1);\n        // FIX: Check if numeric part is empty after removing qualifier (handles \"L\", \"f\", etc.)\n        if (numeric.isEmpty()) {\n             throw new NumberFormatException(\"A type qualifier must be preceded by digits: \" + val);\n        }\n    }\n\n    // Now, parse 'numeric' string structure\n    int decPos = numeric.indexOf('.');\n    int expPos = numeric.indexOf('e');\n    if (expPos == -1) {\n        expPos = numeric.indexOf('E');\n    }\n\n    // --- Structural validation of the 'numeric' part ---\n    // Reject early if the structure is clearly invalid before trying createX methods.\n    if (decPos > -1 && expPos > -1 && expPos < decPos) { // Exponent before decimal\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    if (expPos > -1 && expPos == numeric.length() - 1) { // Exponent marker is last char\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    if (numeric.indexOf('.') != numeric.lastIndexOf('.')) { // Multiple decimal points\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    // Check for multiple/mixed 'e'/'E'\n    if ((expPos > -1 && (numeric.indexOf('e', expPos + 1) > -1 || numeric.indexOf('E', expPos + 1) > -1)) ||\n        (numeric.indexOf('e') > -1 && numeric.indexOf('E') > -1)) {\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    // Check for invalid +/- signs placement\n    boolean signValid = true;\n    int signCount = 0;\n    for (int i = 0; i < numeric.length(); i++) {\n        char c = numeric.charAt(i);\n        if (c == '+' || c == '-') {\n            signCount++;\n            if (i > 0 && i != expPos + 1) { // Sign not at start and not immediately after e/E\n                signValid = false;\n                break;\n            }\n            // This check handles cases like \"1e+-\" or \"1e--\", which are invalid.\n            if (i == expPos + 1 && (i + 1 == numeric.length() || !Character.isDigit(numeric.charAt(i+1)))) {\n                 signValid = false;\n                 break;\n            }\n        }\n    }\n    // Allow max 1 sign overall if no exponent, max 2 signs if exponent present.\n    if (!signValid || (expPos == -1 && signCount > 1) || (expPos != -1 && signCount > 2)) {\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    // Reject if numeric part ends with a non-digit (excluding '.')\n    char numericLastChar = numeric.charAt(numeric.length() - 1);\n    if (!Character.isDigit(numericLastChar) && numericLastChar != '.') {\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n    // --- End structural validation ---\n\n\n    // 'allZeros' check: true iff all digits in 'numeric' are '0'\n    // Used for Float/Double precision loss check. Assumes helper exists.\n    // boolean allZeros = isAllZeros(numeric); // Assuming helper exists\n    // Simple inline check if helper is unavailable:\n    boolean allZeros = true;\n    boolean hasDigit = false;\n    for (int i = 0; i < numeric.length(); i++) {\n        char c = numeric.charAt(i);\n        if (Character.isDigit(c)) {\n            hasDigit = true;\n            if (c != '0') {\n                allZeros = false;\n                // No need to break if we must confirm hasDigit\n            }\n        }\n    }\n    allZeros = allZeros && hasDigit; // Must contain at least one digit, all must be 0.\n\n\n    if (hasQualifier) {\n        // Qualifier was present, use it to guide type creation from 'numeric'\n        char qualifier = val.charAt(val.length() - 1);\n        switch (qualifier) {\n            case 'l' : case 'L' :\n                // L/l requires an integer format (no decimal, no exponent, no trailing dot)\n                if (decPos != -1 || expPos != -1 || numeric.endsWith(\".\")) {\n                    throw new NumberFormatException(val + \" is not a valid Long number.\");\n                }\n                // Assuming createLong/createBigInteger handle base 10 and sign correctly.\n                try {\n                    return createLong(numeric);\n                } catch (NumberFormatException nfe) {\n                    // Fall through to BigInteger\n                }\n                return createBigInteger(numeric);\n\n            case 'f' : case 'F' :\n                try {\n                    Float f = createFloat(numeric);\n                    // Check for Inf/NaN and precision loss on zero-like values\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException e) {\n                    // Re-throw if format is invalid for Float\n                    throw new NumberFormatException(val + \" is not a valid Float number. \" + e.getMessage());\n                }\n                // Fall through: Float failed checks, try Double/BigDecimal\n\n            case 'd' : case 'D' :\n                // Handles 'd', 'D', and fall-through from 'f', 'F'\n                try {\n                    Double d = createDouble(numeric);\n                    // Check for Inf/NaN and precision loss on zero-like values\n                    // FIX: Use doubleValue() for comparison\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                   // Re-throw if format is invalid for Double\n                   throw new NumberFormatException(val + \" is not a valid Double number. \" + nfe.getMessage());\n                }\n                // Fall through: Double failed checks, try BigDecimal\n\n                // Last resort for f/F/d/D is BigDecimal\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                   // Re-throw if format is invalid for BigDecimal\n                   throw new NumberFormatException(val + \" is not a valid BigDecimal number. \" + e.getMessage());\n                }\n            // Default should be unreachable due to initial qualifier check\n        }\n\n    } else {\n        // No qualifier, determine type based on format ('numeric' is same as 'val' here)\n        boolean isIntegral = decPos == -1 && expPos == -1 && !numeric.endsWith(\".\");\n        if (isIntegral) {\n            // Try Integer types: Integer -> Long -> BigInteger\n            // Assuming createInteger/Long/BigInteger handle base 10 and sign.\n            try {\n                return createInteger(numeric);\n            } catch (NumberFormatException nfe) { /* ignore */ }\n            try {\n                return createLong(numeric);\n            } catch (NumberFormatException nfe_long) { /* ignore */ }\n            return createBigInteger(numeric); // Let it throw final NFE\n\n        } else {\n            // Has decimal or exponent or ends with \".\" -> try Floating point types\n            // Float -> Double -> BigDecimal\n            try {\n                Float f = createFloat(numeric);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore, could be valid for Double/BigDecimal\n             }\n            try {\n                Double d = createDouble(numeric);\n                // FIX: Use doubleValue() for comparison\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                 // ignore, could be valid for BigDecimal\n             }\n            // Use BigDecimal constructor, let it throw final NFE if invalid\n            return createBigDecimal(numeric);\n        }\n    }\n    // Should be unreachable\n    throw new AssertionError(\"Unreachable code reached in createNumber for value: \" + val);\n}\n\n// Helper method stubs assumed to exist in the same class (e.g., NumberUtils)\n// These are needed for the logic above but are not part of the provided solution block.\n/*\nprivate static boolean isDigits(String str) { ... }\nprivate static boolean isAllZeros(String str) { ... } // Checks if all digits in str are '0'\nprivate static Integer createInteger(String str) throws NumberFormatException { ... }\nprivate static Long createLong(String str) throws NumberFormatException { ... }\nprivate static BigInteger createBigInteger(String str) throws NumberFormatException { ... }\nprivate static Float createFloat(String str) throws NumberFormatException { ... }\nprivate static Double createDouble(String str) throws NumberFormatException { ... }\nprivate static BigDecimal createBigDecimal(String str) throws NumberFormatException { ... }\n*/",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}