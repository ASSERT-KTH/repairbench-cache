{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assume NumberUtils class exists and these helpers are available/defined,\n// potentially as private static methods within NumberUtils itself.\n// We need: createFloat, createDouble, createInteger, createLong, createBigInteger, createBigDecimal.\n// We also need isAllZeros helper method.\n\npublic class FixedNumberUtils { // Renamed class for clarity\n\n    // Placeholder for the assumed helper methods (implementations need to be provided/exist)\n    // These should ideally handle hex/octal prefixes, signs appropriately.\n    // For this fix, we assume they exist and behave like standard Java parsing (e.g., valueOf, decode, new BigDecimal).\n    private static Float createFloat(String s) throws NumberFormatException { return Float.valueOf(s); }\n    private static Double createDouble(String s) throws NumberFormatException { return Double.valueOf(s); }\n    private static Integer createInteger(String s) throws NumberFormatException { return Integer.decode(s); } // Assumes decode for hex/octal\n    private static Long createLong(String s) throws NumberFormatException { return Long.decode(s); } // Assumes decode for hex/octal\n    private static BigInteger createBigInteger(String s) throws NumberFormatException {\n        int index = 0;\n        int radix = 10;\n        boolean negative = false;\n        if (s.startsWith(\"-\")) {\n            negative = true;\n            index++;\n        } else if (s.startsWith(\"+\")) {\n            index++;\n        }\n        if (s.startsWith(\"0x\", index) || s.startsWith(\"0X\", index)) {\n            index += 2;\n            radix = 16;\n        } else if (s.startsWith(\"#\", index)) {\n             index++;\n             radix = 16;\n        }\n        // Standard BigInteger constructor doesn't handle '0' octal prefix by default\n        String num = s.substring(index);\n        if (num.isEmpty()) {\n            // Handle case like \"+\" or \"-\" or \"0x\"\n            throw new NumberFormatException(\"Illegal embedded sign character or empty number\");\n        }\n        BigInteger bi = new BigInteger(num, radix);\n        return negative ? bi.negate() : bi;\n    }\n    private static BigDecimal createBigDecimal(String s) throws NumberFormatException { return new BigDecimal(s); }\n\n    /**\n     * Checks if the string {@code s} contains only zeros.\n     * Handles {@code null} input by returning {@code true}.\n     */\n    private static boolean isAllZeros(String s) {\n        if (s == null) {\n            return true;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) != '0') {\n                return false;\n            }\n        }\n        // Returns true if s is null, empty, or contains only '0's.\n        return true;\n    }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code> (or <code>0X</code> / <code>-0X</code>), it\n     * will be interpreted as a hexadecimal integer. Values with leading\n     * <code>0</code>'s *might* be interpreted as octal depending on the\n     * underlying parsing method (e.g., <code>Integer.decode</code> does).</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n\n        // Handle common prefixes/suffixes that indicate specific types or invalid patterns\n        if (val.startsWith(\"--\")) {\n             // Reject -- which is parsed inconsistently and is likely invalid intent\n             throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n        // Handle Hex Numbers: 0x or -0x (and case variants)\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\") || val.startsWith(\"0X\") || val.startsWith(\"-0X\")) {\n            // Use appropriate parsing method that handles hex (decode or BigInteger with radix)\n             try {\n                  // Try Integer first (assuming createInteger uses decode or similar)\n                  return createInteger(val);\n             } catch (NumberFormatException nfe){\n                 try {\n                      // Try Long next (assuming createLong uses decode or similar)\n                      return createLong(val);\n                 } catch (NumberFormatException nfe2){\n                      // Fallback to BigInteger for potentially very large hex numbers\n                      return createBigInteger(val);\n                 }\n             }\n        }\n        // Reject underscores in non-hex numbers as standard parse methods don't support them\n        if (val.contains(\"_\")){\n             throw new NumberFormatException(val + \" contains underscores and is not a valid number.\");\n        }\n\n        char lastChar = val.charAt(val.length() - 1);\n\n        // Find decimal and exponent separators\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e');\n        if (expPos == -1) {\n            expPos = val.indexOf('E');\n        }\n\n        // Basic structural validation BEFORE splitting based on potential qualifier\n        String numeric = val; // Assume no qualifier initially\n        boolean hasQualifier = false;\n        char qualifier = 0;\n\n        // Check for trailing exponent/decimal issues on the full string\n        if (expPos > -1) {\n            if (decPos > -1 && expPos < decPos) { // Exponent before decimal \"1e2.3\"\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            if (expPos == val.length() - 1) { // Trailing exponent \"1e\"\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        }\n         if (val.equals(\".\") || val.equals(\"-.\") || val.equals(\"+.\")) { // Just a dot or sign+dot\n             throw new NumberFormatException(val + \" is not a valid number.\");\n         }\n        // Check for invalid trailing sign\n        if (lastChar == '+' || lastChar == '-') {\n             throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n\n        // Check for Type Qualifier ('f','F','d','D','l','L')\n        if (Character.isLetter(lastChar)) {\n            if (lastChar == 'l' || lastChar == 'L' || lastChar == 'f' ||\n                lastChar == 'F' || lastChar == 'd' || lastChar == 'D') {\n\n                 numeric = val.substring(0, val.length() - 1);\n                 // Prevent StringIndexOutOfBoundsException for \"L\", \"F\" etc. and invalid forms like \"-L\", \"+L\"\n                 if (numeric.isEmpty() || numeric.equals(\"-\") || numeric.equals(\"+\")) {\n                      throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n                 // Check last char of numeric part isn't a sign either (\"1+L\", \"1-F\")\n                 char lastNumericChar = numeric.charAt(numeric.length() - 1);\n                 if (lastNumericChar == '+' || lastNumericChar == '-') {\n                      throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n\n                 hasQualifier = true;\n                 qualifier = lastChar;\n            } else {\n                // Ends in a letter that is not a valid qualifier\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        }\n        // Note: If no qualifier, 'numeric' remains equal to 'val'.\n\n        // Recalculate positions based on the 'numeric' string (after potential qualifier removal).\n        int numericDecPos = numeric.indexOf('.');\n        int numericExpPos = numeric.indexOf('e');\n        if (numericExpPos == -1) {\n            numericExpPos = numeric.indexOf('E');\n        }\n\n        // Further structural checks now on 'numeric' part\n        if (numericDecPos > -1 && numeric.indexOf('.', numericDecPos + 1) > -1) { // Multiple decimal points\n             throw new NumberFormatException(numeric + \" is not a valid number.\");\n        }\n        if (numericExpPos > -1) { // Check structure around exponent\n             if ( (numeric.indexOf('e', numericExpPos + 1) > -1 || numeric.indexOf('E', numericExpPos + 1) > -1) ) { // Multiple exponents\n                throw new NumberFormatException(numeric + \" has multiple exponents and is not a valid number.\");\n             }\n             // Check if char after E/e is valid (digit or sign) - handled by createX methods mostly, but basic check:\n             if (numericExpPos + 1 < numeric.length()) {\n                 char charAfterExp = numeric.charAt(numericExpPos + 1);\n                 if (charAfterExp != '+' && charAfterExp != '-' && !Character.isDigit(charAfterExp)) {\n                    throw new NumberFormatException(\"Invalid character \" + charAfterExp + \" after exponent in \" + numeric);\n                 }\n             } // Trailing 'e'/'E' was already checked on 'val'\n\n             // Check exponent part for validity (e.g., signs only allowed at start)\n             String expPart = numeric.substring(numericExpPos + 1);\n             if (expPart.indexOf('+') > 0 || expPart.indexOf('-') > 0) {\n                 throw new NumberFormatException(\"Invalid sign in exponent \" + expPart + \" in \" + numeric);\n             }\n             if (expPart.isEmpty() || expPart.equals(\"+\") || expPart.equals(\"-\")) {\n                // Should have been caught by trailing 'e' check, but double check structure\n                 throw new NumberFormatException(\"Invalid or empty exponent in \" + numeric);\n             }\n        }\n        // Check if sign character appears mid-string (outside of exponent)\n        int signPos = numeric.indexOf('+');\n        if (signPos > 0 && signPos != numericExpPos + 1) throw new NumberFormatException(numeric + \" has misplaced '+' sign.\");\n        signPos = numeric.indexOf('-');\n        // Allow sign only at start (index 0) or right after 'e'/'E' (index numericExpPos + 1)\n        if (signPos > 0 && signPos != numericExpPos + 1) throw new NumberFormatException(numeric + \" has misplaced '-' sign.\");\n\n\n        // Split numeric into components (mantissa, decimal, exponent) for the 'allZeros' check\n        String mant;\n        String dec;\n        String exp;\n        if (numericDecPos > -1) {\n            if (numericExpPos > -1) {\n                mant = numeric.substring(0, numericDecPos);\n                dec = numeric.substring(numericDecPos + 1, numericExpPos);\n            } else {\n                mant = numeric.substring(0, numericDecPos);\n                dec = numeric.substring(numericDecPos + 1);\n            }\n        } else { // No decimal\n            if (numericExpPos > -1) {\n                mant = numeric.substring(0, numericExpPos);\n            } else {\n                mant = numeric;\n            }\n            dec = null;\n        }\n        if (numericExpPos > -1 ) {\n            exp = numeric.substring(numericExpPos + 1);\n        } else {\n            exp = null;\n        }\n\n\n        // Create number based on qualifier or content\n        if (hasQualifier) {\n             boolean allZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp); // Fixed: checks all parts\n             switch (qualifier) {\n                 case 'l' :\n                 case 'L' :\n                     // Qualifier L/l requires integer format (no decimal, no exponent)\n                     if (numericDecPos == -1 && numericExpPos == -1) {\n                         try {\n                             // Use createLong first (assumes handles hex/octal via decode)\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             // Fallback to BigInteger for range\n                             return createBigInteger(numeric);\n                         }\n                     }\n                     // Invalid format for L/l (e.g., \"1.2L\", \"1e2L\")\n                     throw new NumberFormatException(val + \" is not a valid number.\");\n\n                 case 'f' :\n                 case 'F' :\n                     try {\n                         Float f = createFloat(numeric); // Assumes Float.valueOf\n                         // Check for infinity or zero result where original string wasn't all zeros\n                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             return f;\n                         }\n                         // If Inf, NaN, or 0.0 from non-zero, fall through to Double/BigDecimal\n                     } catch (NumberFormatException e) {\n                         // If createFloat fails (e.g., invalid format), fall through to try Double/BigDecimal\n                     }\n                     // Fall through intended\n\n                 case 'd' :\n                 case 'D' :\n                     // Handles 'd', 'D', and fallthrough from 'f', 'F'\n                     try {\n                         Double d = createDouble(numeric); // Assumes Double.valueOf\n                         // Check for infinity or zero result where original string wasn't all zeros\n                         if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { // Fixed: use doubleValue()\n                             return d;\n                         }\n                         // If Inf, NaN, or 0.0 from non-zero, fall through to BigDecimal\n                     } catch (NumberFormatException nfe) {\n                         // If createDouble fails, fall through to BigDecimal\n                     }\n                     // Final attempt with BigDecimal for F/f/D/d suffixes\n                     try {\n                         return createBigDecimal(numeric); // Assumes new BigDecimal(String)\n                     } catch (NumberFormatException e) {\n                          // If all attempts (Float, Double, BigDecimal) fail for this numeric part, throw\n                          throw new NumberFormatException(val + \" is not a valid number.\");\n                     }\n                 // Default case should not be reachable due to checks on qualifier char\n             }\n         } else { // No qualifier - determine type from content\n             if (numericDecPos == -1 && numericExpPos == -1) {\n                 // Looks like an integer (no decimal, no exponent)\n                 try {\n                     // Try Integer (assuming handles hex/octal via decode)\n                     return createInteger(numeric);\n                 } catch (NumberFormatException nfe) { /* ignore */ }\n                 try {\n                      // Try Long (assuming handles hex/octal via decode)\n                     return createLong(numeric);\n                 } catch (NumberFormatException nfe) { /* ignore */ }\n                 // Final fallback for integers is BigInteger\n                 return createBigInteger(numeric);\n\n             } else {\n                 // Looks like a floating point number\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(dec) && isAllZeros(exp); // Fixed: checks all parts\n                 try {\n                     // Try float first\n                     Float f = createFloat(numeric);\n                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                         return f;\n                     }\n                 } catch (NumberFormatException nfe) { /* ignore */ }\n                 try {\n                     // Try double next\n                     Double d = createDouble(numeric);\n                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { // Fixed: use doubleValue()\n                         return d;\n                     }\n                 } catch (NumberFormatException nfe) { /* ignore */ }\n                 // Final fallback to BigDecimal for precision/range\n                 return createBigDecimal(numeric);\n             }\n         }\n         // This part should ideally be unreachable if all paths return or throw.\n         // Adding assertion for safety.\n         throw new AssertionError(\"Logic error in createNumber: Fell through all cases for value '\" + val + \"'\");\n    }\n\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}