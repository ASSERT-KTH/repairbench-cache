{
    "generation": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can hold the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * @param val String containing a number\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear\n            // to be in specification of class. OS X Java parses it to\n            // a wrong value.\n            return null;\n        }\n        if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n            return createInteger(val);\n        }\n        char lastChar = val.charAt(val.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1; // Avoid multiple calls\n\n        // Detect if the value starts with +/-sign\n        boolean hasSign = val.charAt(0) == '-' || val.charAt(0) == '+';\n        // Detect trailing sign, if present\n        boolean signPresent = hasSign && (val.endsWith(\"L\") || val.endsWith(\"l\") || val.endsWith(\"F\") || val.endsWith(\"f\") || val.endsWith(\"D\") || val.endsWith(\"d\"));\n\n        // Check for characters after the exponent sign\n        if (expPos > -1) {\n            // Check that the exponent expression is valid, e.g. not just \"1e\"\n            if (expPos == val.length() - 1) {\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            // Check that the exponent is numeric\n            String expStr = val.substring(expPos + 1);\n            if (expStr.length() > 0 && (expStr.charAt(0) == '+' || expStr.charAt(0) == '-')) {\n                expStr = expStr.substring(1);\n            }\n            if(expStr.length() == 0 || !isDigits(expStr)){\n                 throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        }\n\n\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos || expPos > val.length() -1 ) { // Check exponent position validity relative to decimal and string end\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                dec = val.substring(decPos + 1, expPos);\n            } else {\n                // No exponent, check for type specifier\n                char potentialQualifier = val.charAt(val.length() - 1);\n                 if (Character.isLetter(potentialQualifier) && potentialQualifier != 'e' && potentialQualifier != 'E') {\n                    dec = val.substring(decPos + 1, val.length() - 1);\n                 } else {\n                    dec = val.substring(decPos + 1);\n                 }\n            }\n            mant = val.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                 if (expPos > val.length() -1) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n                mant = val.substring(0, expPos);\n            } else {\n                // No decimal, no exponent - could be integer or qualified float/double\n                char potentialQualifier = val.charAt(val.length() - 1);\n                if (Character.isLetter(potentialQualifier) && val.length() > 1) { // Avoid single letter strings like \"L\"\n                    mant = val.substring(0, val.length() - 1);\n                } else {\n                    mant = val;\n                }\n            }\n            dec = null;\n        }\n\n        // Handle type qualifiers at the end\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n             // Ensure exponent part exists if 'e' or 'E' is present but not last char\n            if (expPos > -1 && expPos < val.length() - 1) {\n                exp = val.substring(expPos + 1, val.length() - 1);\n            } else {\n                exp = null;\n            }\n            String numeric = val.substring(0, val.length() - 1); // String excluding the qualifier\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp); // Use mant and exp derived above\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // Check if the string before L/l is a valid integer/long format\n                    if (dec == null && exp == null) {\n                        // Handle potential signs correctly\n                        if (numeric.length() == 0 || (numeric.charAt(0) == '-' && numeric.length() == 1)) {\n                           throw new NumberFormatException(val + \" is not a valid number.\"); // Catches \"L\", \"-L\"\n                        }\n                        String digits = numeric.charAt(0) == '-' ? numeric.substring(1) : numeric;\n                        if (isDigits(digits)) { // Checks \"123L\", \"-123L\", rejects \"1.2L\", \"1e2L\", \"bobL\"\n                            try {\n                                return createLong(numeric);\n                            } catch (NumberFormatException nfe) {\n                                // It was probably too big for a Long\n                            }\n                            return createBigInteger(numeric);\n                        }\n                         // Fall through to throw exception if not digits, e.g. \"bobL\"\n                    }\n                    // If decimal or exponent present with L/l, it's invalid\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    // Use the pre-calculated numeric part\n                    if (numeric.length() == 0 || (numeric.charAt(0) == '-' && numeric.length() == 1)) {\n                         throw new NumberFormatException(val + \" is not a valid number.\"); // Catches \"F\", \"-F\"\n                    }\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        // Check for underflow/overflow issues\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException e) {\n                        // Invalid format, fall through\n                    }\n                     // If createFloat failed or resulted in zero/infinity inappropriately, throw error\n                    // (Removed fallthrough to Double/BigDecimal for explicit F/f)\n                     throw new NumberFormatException(val + \" is not a valid number.\");\n\n                case 'd' :\n                case 'D' :\n                    // Use the pre-calculated numeric part\n                     if (numeric.length() == 0 || (numeric.charAt(0) == '-' && numeric.length() == 1)) {\n                         throw new NumberFormatException(val + \" is not a valid number.\"); // Catches \"D\", \"-D\"\n                    }\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        // Check for underflow/overflow issues\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                       // Invalid format, fall through\n                    }\n                    // If createDouble failed or resulted in zero/infinity inappropriately, try BigDecimal\n                    try {\n                         // Check if numeric is valid for BigDecimal before creating it\n                         // BigDecimal constructor can throw NumberFormatException for invalid formats like \"1.2e\"\n                         if (!isValidBigDecimalString(numeric)) {\n                              throw new NumberFormatException(val + \" is not a valid number.\");\n                         }\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // If BigDecimal also fails\n                        throw new NumberFormatException(val + \" is not a valid number.\");\n                    }\n\n                default :\n                    // Qualifier is not L, F, D\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        } else {\n            // No type qualifier, determine type based on presence of decimal or exponent\n             if (expPos > -1 && expPos < val.length() ) { // expPos checked for validity earlier\n                 exp = val.substring(expPos + 1); // Exponent is from expPos+1 to end\n             } else {\n                 exp = null;\n             }\n            if (dec == null && exp == null) { // Should be Integer, Long, or BigInteger\n                 // Check for leading + sign which createInteger/Long/BigInteger might reject\n                String numberToCheck = val;\n                 if (val.charAt(0) == '+') {\n                    numberToCheck = val.substring(1);\n                 }\n\n                if(numberToCheck.length() == 0 || !isDigits(numberToCheck.charAt(0) == '-' ? numberToCheck.substring(1) : numberToCheck)) {\n                    // Reject strings like \"+\", \"-\" or containing non-digits\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n\n                try {\n                    return createInteger(val);\n                } catch (NumberFormatException nfe) {\n                    // Not an Integer\n                }\n                try {\n                    return createLong(val);\n                } catch (NumberFormatException nfe) {\n                    // Not a Long\n                }\n                // Must be BigInteger\n                return createBigInteger(val);\n\n            } else { // Should be Float, Double, or BigDecimal\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp); // Re-evaluate based on final mant/exp\n                 try {\n                    // Check if valid for BigDecimal first to avoid precision loss with Float/Double\n                    // if the number can be perfectly represented.\n                     if (!isValidBigDecimalString(val)) {\n                         throw new NumberFormatException(val + \" is not a valid number.\");\n                    }\n\n                    BigDecimal bigDec = createBigDecimal(val);\n                    // If it fits in a Double with no loss of precision and isn't infinite/zero inappropriately\n                     if (bigDec.compareTo(BigDecimal.valueOf(bigDec.doubleValue())) == 0 && !(bigDec.doubleValue() == 0.0 && !allZeros) && !Double.isInfinite(bigDec.doubleValue()) ) {\n                         Double d = bigDec.doubleValue();\n                          // Check if it also fits in a Float\n                         if (bigDec.compareTo(BigDecimal.valueOf(bigDec.floatValue())) == 0 && !(bigDec.floatValue() == 0.0F && !allZeros) && !Float.isInfinite(bigDec.floatValue())) {\n                             return bigDec.floatValue();\n                         }\n                         return d;\n                     }\n                     // Otherwise, return as BigDecimal\n                     return bigDec;\n\n                 } catch (NumberFormatException nfe) {\n                    // Should not happen if isValidBigDecimalString passed, but handle defensively\n                     throw new NumberFormatException(val + \" is not a valid number.\");\n                 }\n            }\n        }\n    }\n\n    // Helper method to check for all zeros (implementation assumed elsewhere)\n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n     // Helper method to check if a string consists of digits (implementation assumed elsewhere)\n    private static boolean isDigits(String str) {\n         if (str == null || str.length() == 0) {\n             return false;\n         }\n         for (int i = 0; i < str.length(); i++) {\n             if (!Character.isDigit(str.charAt(i))) {\n                 return false;\n             }\n         }\n         return true;\n     }\n\n     // Helper method (you might need to create this or use an existing utility)\n     // to validate string format before passing to BigDecimal constructor.\n     // This is a basic check; a robust one might use regex or more detailed parsing.\n    private static boolean isValidBigDecimalString(String s) {\n        if (s == null || s.length() == 0) return false;\n        // Simplified check: allows digits, optional sign, optional decimal, optional exponent\n        // Does not fully validate exponent format or multiple decimals/signs.\n        // A proper validation might be needed depending on strictness required.\n        try {\n            new java.math.BigDecimal(s);\n            return true;\n        } catch (NumberFormatException nfe) {\n            return false;\n        }\n    }\n    // Assumed helper methods (implementations not shown but required by the original code)\n    // private static Integer createInteger(String str) { ... }\n    // private static Long createLong(String str) { ... }\n    // private static BigInteger createBigInteger(String str) { ... }\n    // private static Float createFloat(String str) { ... }\n    // private static Double createDouble(String str) { ... }\n    // private static BigDecimal createBigDecimal(String str) { ... }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}