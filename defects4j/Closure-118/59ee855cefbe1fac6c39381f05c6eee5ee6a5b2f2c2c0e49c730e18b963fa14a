{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      // Get the type of the object literal expression itself. This is the type\n      // of the object being constructed or assigned to.\n      T objectLitType = typeSystem.getType(getScope(), n, null);\n\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Object literal keys may be STRING, GETTER_DEF, or SETTER_DEF nodes.\n        // We use getStringKey() which works for all these types.\n        String name = child.getStringKey();\n\n        // Skip numeric keys, as they are not handled by this pass.\n        if (name == null) {\n          // TODO(b/181204127): Handle numeric keys properly.\n          continue;\n        }\n\n        Property prop = getProperty(name);\n\n        // Pass the type of the object literal (objectLitType) and the node\n        // representing the property definition (child) to processProperty.\n        // The original code incorrectly passed the type of the property's value.\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, objectLitType, child))) {\n          // If scheduling failed (e.g., due to conflicting types) and this\n          // property is specifically marked for errors, report it.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                // Use the object's type in the error message.\n                (objectLitType == null ? \"null\" : objectLitType.toString()),\n                n.toString(), \"\"));\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}