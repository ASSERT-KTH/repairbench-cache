{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      Node parent = n.getParent();\n      JSType objectLitOwnerType = null;\n\n      // Determine the owner type of the object literal based on its assignment context.\n      // This is crucial for disambiguating properties on prototypes.\n      if (parent != null && parent.isAssign() && parent.getLastChild() == n) {\n        Node lhs = parent.getFirstChild(); // The left-hand side of the assignment (e.g., Foo.prototype)\n        // Check if it's an assignment to a prototype property (e.g., Foo.prototype)\n        if (lhs.isGetProp() && \"prototype\".equals(lhs.getSecondChild().getString())) {\n          Node constructorNode = lhs.getFirstChild(); // This is the 'Foo' node in Foo.prototype\n          JSType constructorType = typeSystem.getType(t.getScope(), constructorNode, null);\n          if (constructorType != null && constructorType.isConstructor()) {\n            // Get the instance type of the constructor (e.g., the Foo instance type)\n            objectLitOwnerType = constructorType.toMaybeFunctionType().getInstanceType();\n          }\n        }\n      }\n\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // 'child' here is the property key node (e.g., STRING_KEY, STRING, GET, SET).\n        // It's not the key-value pair parent node.\n\n        // Robustly get the property name using NodeUtil.\n        String name = NodeUtil.getObjectLiteralPropertyKey(child);\n        if (name == null) {\n          // Skip computed properties or other non-string/numeric keys that\n          // are not candidates for renaming in this pass.\n          continue;\n        }\n\n        // The node for the property value (e.g., '0' in `a: 0`).\n        Node valueNode = child.getFirstChild();\n        JSType propertyValueType = null;\n        if (valueNode != null) {\n            propertyValueType = typeSystem.getType(t.getScope(), valueNode, null);\n        }\n\n        Property prop = getProperty(name);\n        // scheduleRenaming expects the key node (child) and the property graph node from processProperty.\n        // processProperty takes the property's value type and its owner type.\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, propertyValueType, objectLitOwnerType))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                // Use the correct propertyValueType for error reporting.\n                (propertyValueType == null ? \"null\" : propertyValueType.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}