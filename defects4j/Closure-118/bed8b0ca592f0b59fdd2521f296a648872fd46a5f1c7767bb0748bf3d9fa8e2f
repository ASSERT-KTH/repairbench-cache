{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Maybe STRING_KEY, GETTER_DEF, SETTER_DEF\n        // We skip number keys, assuming they are disallowed or handled elsewhere.\n        // Computed property names are NAME nodes, not STRING_KEY.\n        if (!child.isStringKey() && !child.isGetterDef() && !child.isSetterDef()) {\n           continue;\n        }\n\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n\n        // Record the type information for this property definition.\n        // processProperty also checks for invalidation based on type system rules.\n        // We pass null for the replacement node, as this is a definition site.\n        boolean okToRename = processProperty(t, prop, type, null);\n\n        // If the key was quoted, this property cannot be safely renamed.\n        // Mark the property globally as invalidating.\n        if (child.isQuotedString()) {\n            prop.setInvalidatingType(typeSystem.getNativeType(STRING_TYPE), child);\n            // Prevent scheduling renaming for this specific node based on the quoted key.\n            okToRename = false;\n        }\n\n        // scheduleRenaming tracks nodes related to a property for the actual rename step.\n        // It returns false if scheduling fails (e.g., property already invalidated).\n        // We only schedule if the key wasn't quoted AND processProperty returned true.\n        if (!prop.scheduleRenaming(child, okToRename)) {\n          // If scheduling failed (either because okToRename=false initially,\n          // or okToRename became false due to quoted key, or prop was already invalid),\n          // check if we should report an error.\n          if (propertiesToErrorFor.containsKey(name)) {\n            // Use the invalidation reason stored in the property if available.\n            String reason = prop.getInvalidationReason();\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(),\n                reason == null ? \"\" : reason));\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}