{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Child node must be a STRING_KEY, GETTER_DEF, or SETTER_DEF\n        // Handle quoted keys ('foo': 1) which cannot be safely renamed.\n        // Getters/setters (get foo() {}) are never quoted.\n\n        // Use NodeUtil to safely check and get the key name.\n        // Handles STRING_KEY, GETTER_DEF, SETTER_DEF.\n        if (!NodeUtil.isObjectLitKey(child)) {\n          // Skip other node types like computed properties, spread operators, etc.\n          // Numeric keys are also skipped as they typically don't participate\n          // in property disambiguation based on type information.\n          continue;\n        }\n        String name = NodeUtil.getObjectLitKeyName(child);\n        // A non-string name (e.g. number from a numeric key) cannot be disambiguated.\n        if (name == null) {\n          continue;\n        }\n\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n\n        // Determine if this object literal definition prevents renaming.\n        // Condition 1: Was the key quoted? (e.g., {'foo': 1})\n        // Quoted keys invalidate renaming. Getters/setters are never quoted.\n        boolean quotedKey = child.isStringKey() && child.isQuotedStringKey();\n\n        // Condition 2: Does general analysis allow renaming for this property usage?\n        // Passing 'null' for the context node, as the object literal itself\n        // doesn't provide context for invalidation like a CALL node would.\n        boolean processPropertyAllows = processProperty(t, prop, type, null);\n\n        // Renaming is allowed only if the key is NOT quoted AND processProperty allows it.\n        boolean canRename = !quotedKey && processPropertyAllows;\n\n        // Schedule the renaming if possible, otherwise invalidate the property.\n        // scheduleRenaming returns true if the property is still valid *after*\n        // processing this node, and false if it became invalid or already was.\n        if (!prop.scheduleRenaming(child, canRename)) {\n          // Property became invalid or was already invalid. Report error if necessary.\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}