{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      // Loop over the children, skipping over values to process only the keys.\n      // Children of OBJECTLIT are structured as: key1, value1, key2, value2, ...\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext().getNext()) { // Fix: Advance by two to skip the value node\n        String name;\n        if (child.isStringKey()) {\n          // For simple string properties like {'a': 0}, the child node itself\n          // is a STRING node representing the key.\n          name = child.getString();\n        } else if (child.isGetterDef() || child.isSetterDef()) {\n          // For accessor properties (getters/setters like {get a(){}}),\n          // the child node is a GETTER_DEF or SETTER_DEF. The actual property\n          // name is stored in its first child, which is a STRING node.\n          name = child.getFirstChild().getString();\n        } else {\n          // This pass generally renames string-based properties.\n          // Numeric literal keys (e.g., {1: 2}) or computed properties\n          // (e.g., {[foo()]: bar}) are typically not renamed by this pass.\n          // If the node type is unexpected, skip it to avoid errors.\n          continue;\n        }\n\n        T type = typeSystem.getType(getScope(), n, name);\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child, // Pass the key node for renaming\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name), // Pass the key node for error reporting location\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}