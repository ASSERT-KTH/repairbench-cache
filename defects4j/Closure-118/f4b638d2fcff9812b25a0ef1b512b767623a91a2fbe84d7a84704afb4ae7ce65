{
    "generation": "/**\n * Processes an OBJECTLIT node.\n */\nprivate void handleObjectLit(NodeTraversal t, Node n) {\n  // We need to pick up object\u2010literal definitions on Foo.prototype = { \u2026 }.\n  // When the OBJECTLIT is on the right side of an assignment to\n  // Foo.prototype, pass that GETPROP node to the type system, otherwise\n  // fall back to the literal itself.\n  Node parent = n.getParent();\n  Node typeRoot = n;\n  if (parent != null\n      && parent.isAssign()\n      && parent.getLastChild() == n) {\n    Node lhs = parent.getFirstChild();\n    if (lhs.isGetProp()\n        && \"prototype\".equals(lhs.getLastChild().getString())) {\n      typeRoot = lhs;\n    }\n  }\n\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    String name = child.getString();\n    T type = typeSystem.getType(getScope(), typeRoot, name);\n\n    Property prop = getProperty(name);\n    if (!prop.scheduleRenaming(\n            child,\n            processProperty(t, prop, type, null))) {\n      // TODO(user): It doesn't look like the user can do much in this\n      // case right now.\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(JSError.make(\n            t.getSourceName(),\n            child,\n            propertiesToErrorFor.get(name),\n            Warnings.INVALIDATION,\n            name,\n            (type == null ? \"null\" : type.toString()),\n            n.toString(),\n            \"\"));\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}