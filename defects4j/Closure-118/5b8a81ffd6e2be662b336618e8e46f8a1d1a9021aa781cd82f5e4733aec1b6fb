{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      // Object literal nodes have children in pairs: key, value, key, value, ...\n      // Iterate over the key nodes.\n      for (Node key = n.getFirstChild(); key != null; key = key.getNext().getNext()) {\n        // Node value = key.getNext(); // The value node, not directly used here but useful to acknowledge.\n\n        String name;\n        boolean isQuoted = false;\n\n        if (key.isString()) {\n          // e.g., {'a': 0}\n          name = key.getString();\n          // String literal keys are always considered quoted in object literals\n          // for the purpose of disambiguation, as they cannot be renamed.\n          isQuoted = true;\n        } else if (key.isNumber()) {\n          // e.g., {1: 0}\n          name = String.valueOf(key.getDouble());\n          // Numeric literal keys are also always considered quoted.\n          isQuoted = true;\n        } else if (key.isGet() || key.isSet()) {\n          // e.g., {get a() {}} or {set a(v) {}}\n          // The actual property name is the first child of the GET/SET node.\n          Node propertyNameNode = key.getFirstChild();\n          name = propertyNameNode.getString();\n          // An accessor property is quoted if its name is a quoted string or a computed property.\n          // E.g., `get \"a\"() {}` is quoted, but `get a() {}` is not.\n          isQuoted = propertyNameNode.isQuotedString() || propertyNameNode.isComputedProp();\n        } else if (key.isName()) {\n          // e.g., {a} (ES6 shorthand property, equivalent to {a: a})\n          name = key.getString();\n          isQuoted = false; // Shorthand properties are not quoted.\n        } else if (key.isComputedProp()) {\n          // e.g., {[keyExpr]: value} (ES6 computed property name)\n          // These are always considered quoted for disambiguation, as their names are not\n          // compile-time constants. The actual name is typically not available.\n          name = \"\"; // Use empty string for unknown names from computed properties.\n          isQuoted = true;\n        } else {\n          // This case should ideally not be reached with a well-formed AST.\n          // For robustness, attempt to get a name and treat as quoted to prevent unexpected renaming.\n          name = key.getString();\n          isQuoted = true;\n          compiler.report(JSError.make(\n              t.getSourceName(), key,\n              JSError.error(Warnings.UNEXPECTED_OBJECT_LIT_PROPERTY),\n              \"Unexpected node type in object literal property key: \" + key.getToken()));\n        }\n\n        // If the property is quoted, it should not be scheduled for renaming.\n        if (isQuoted) {\n          continue; // Skip to the next key-value pair.\n        }\n\n        // Process non-quoted properties for renaming.\n        T type = typeSystem.getType(getScope(), n, name);\n        Property prop = getProperty(name);\n\n        // Schedule the property for renaming. The 'key' node is the usage.\n        if (!prop.scheduleRenaming(key,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), key, propertiesToErrorFor.get(name), // Use 'key' for error location\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}