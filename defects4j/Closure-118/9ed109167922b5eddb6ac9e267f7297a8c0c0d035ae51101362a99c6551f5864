{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Process STRING, GETTER_DEF, SETTER_DEF, MEMBER_FUNCTION_DEF keys.\n        // We need to distinguish between quoted ('prop': ...) and unquoted (prop: ...)\n        // string keys. Unquoted keys and other key types (like getters/setters)\n        // are candidates for renaming, quoted string keys are not.\n        if (child.isStringKey()) { // Covers STRING, GETTER_DEF, SETTER_DEF, MEMBER_FUNCTION_DEF\n          String name = child.getString(); // Correctly gets name for all StringKey types\n          T type = typeSystem.getType(getScope(), n, name); // Type of the property *value*\n\n          Property prop = getProperty(name);\n          // processProperty updates type information for the property name globally\n          // and returns true if the property is currently considered valid for renaming\n          // based on type consistency across all encountered uses so far.\n          boolean isConsistent = processProperty(t, prop, type, null);\n\n          // Determine if this specific key instance is eligible for renaming.\n          // Quoted string keys {'a': 1} are not eligible, like bracket access x['a'].\n          // Unquoted keys {a: 1} and getters/setters/methods are eligible, like dot access x.a.\n          boolean canRenameThisInstance = !child.isString() || !child.isQuotedString();\n\n          if (canRenameThisInstance) {\n            // Schedule this specific instance for renaming if the property itself is consistent.\n            // scheduleRenaming returns false if renaming is invalidated, typically because\n            // isConsistent was false (due to type conflicts found in processProperty)\n            // or other reasons determined by the Property object.\n            if (!prop.scheduleRenaming(child, isConsistent)) {\n              // If scheduling fails (property is invalidated), report an error\n              // if this property name is explicitly tracked for errors.\n              if (propertiesToErrorFor.containsKey(name)) {\n                compiler.report(JSError.make(\n                    t.getSourceName(), child, propertiesToErrorFor.get(name),\n                    Warnings.INVALIDATION, name,\n                    (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n              }\n            }\n          }\n          // If it's a quoted string key (!canRenameThisInstance), we still called processProperty\n          // to record the type occurrence (which might contribute to invalidating the property\n          // if types conflict), but we don't call scheduleRenaming for this specific node\n          // because quoted keys cannot be renamed.\n        }\n        // We ignore other node types like computed properties or spread operators,\n        // as they are not handled by this logic.\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}