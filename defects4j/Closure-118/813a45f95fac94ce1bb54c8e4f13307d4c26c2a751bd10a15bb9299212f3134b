{
    "generation": "    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      // Ensure the JSType is computed. This is necessary to get the type context\n      // for the properties defined in this literal.\n      // TODO(johnlenz): compute the object literal's type lazily?\n      n.getJSType();\n\n      for (Node child = n.getFirstChild();\n          child != null;\n          child = child.getNext()) {\n        // Child node is the key (STRING_KEY, GETTER_DEF, SETTER_DEF)\n        // We should never see a mix of numbers and strings for keys here,\n        // numeric keys are handled implicitly by JS interpreters as strings.\n        String name = child.getString(); // Property name\n\n        // Get the type of the object literal itself. This is the object\n        // on which the property is being defined in this context.\n        T objectLitType = (T) n.getJSType();\n\n        // If we don't know the type of the object literal, we can't disambiguate\n        // properties defined on it. This might happen if type inference failed\n        // or the context doesn't provide enough information.\n        // Also skip if the type is too broad (Object, Unknown, All).\n        // NOTE: We might potentially want to handle the case where objectLitType is\n        // null, though theoretically, type inference should always assign a type.\n        if (objectLitType == null || objectLitType.isUnknownType() || objectLitType.isEmptyType() || objectLitType.isAllType()) {\n            // Cannot disambiguate properties on unknown/broad types.\n            continue;\n        }\n\n\n        Property prop = getProperty(name);\n\n        // processProperty expects the type of the object on which the property\n        // is accessed/defined. In this case, it's the object literal type.\n        // computedProp is null because this is not a GETELEM/SETELEM.\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, objectLitType, null))) {\n          // Renaming failed (e.g., due to invalidation).\n          // Report an error if this property was specifically marked for error reporting.\n          if (propertiesToErrorFor.containsKey(name)) {\n            // For the error message, it's helpful to include the type of the\n            // property's value as defined in the literal.\n            T valueType = typeSystem.getType(getScope(), n, name);\n\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (valueType == null ? \"null\" : valueType.toString()), // Type of the property's value\n                n.toString(), // Source code of the object literal\n                \"\")); // Currently missing context for the original definition site\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}