{
    "generation": "/** {@inheritDoc} */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    int agingA = 0;\n    int agingB = 0;\n    double fa = f0;\n    double fb = f1;\n    double a = x0;\n    double b = x1;\n\n    // Keep finding better approximations.\n    while (true) {\n        // Check for allowed solutions after evaluations (guard for infinite loop like MATH-631)\n        if (FastMath.abs(b - a) < FastMath.max(rtol * FastMath.abs(b), atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return b;\n            case LEFT_SIDE:\n                return inverted ? b : a;\n            case RIGHT_SIDE:\n                return inverted ? a : b;\n            case BELOW_SIDE:\n                return (fb <= 0) ? b : a;\n            case ABOVE_SIDE:\n                return (fb >= 0) ? b : a;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (FastMath.abs(fb) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return b;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return b;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return b;\n                }\n                break;\n            case BELOW_SIDE:\n                if (fb <= 0) {\n                    return b;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (fb >= 0) {\n                    return b;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        // Calculate the next approximation.\n        final double x = b - fb * (b - a) / (fb - fa);\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        // Update a or b as appropriate.\n        if (fb * fx < 0) {\n            a = b;\n            fa = fb;\n            b = x;\n            fb = fx;\n            inverted = !inverted;\n            agingA = 0;\n            agingB++;\n        } else {\n            // The sign did not change.\n            switch (method) {\n            case ILLINOIS:\n                fa *= 0.5;\n                break;\n            case PEGASUS:\n                fa *= fb / (fb + fx);\n                break;\n            case REGULA_FALSI:\n                // Aging: if the update fails to change endpoint, we shrink the interval artificially\n                agingA++;\n                if (agingA >= 2) {\n                    // Shrink the interval\n                    a = 0.5 * (a + b - FastMath.max(rtol * FastMath.abs(b), atol));\n                    fa = computeObjectiveValue(a);\n                    agingA = 0;\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            b = x;\n            fb = fx;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}