{
    "generation": "/** {@inheritDoc} */\nprotected final double doSolve() {\n    // Get initial solution\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(x0, x1);\n\n    // Get accuracies.\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean inverted = false;\n\n    int agingA = 0;\n    int agingB = 0;\n    double fa = f0;\n    double fb = f1;\n    double a = x0;\n    double b = x1;\n\n    while (true) {\n        // Calculate the next approximation.\n        final double x = b - ((fb * (b - a)) / (fb - fa));\n        final double fx = computeObjectiveValue(x);\n\n        // If the new approximation is the exact root, return it. Since\n        // this is not an under-approximation or an over-approximation,\n        // we can return it regardless of the allowed solutions.\n        if (fx == 0.0) {\n            return x;\n        }\n\n        if (fb * fx < 0) {\n            // Root is bracketed between b and x\n            a = b;\n            fa = fb;\n            agingA = 0;\n            b = x;\n            fb = fx;\n            agingB = 0;\n            inverted = !inverted;\n        } else {\n            // f(a) and f(x) have same sign: move a to x\n            switch (method) {\n            case ILLINOIS:\n                fa *= 0.5;\n                break;\n            case PEGASUS:\n                fa *= fb / (fb + fx);\n                break;\n            case REGULA_FALSI:\n                // REGULA FALSI: no improvement, increase aging counter.\n                agingA++;\n                if (agingA >= 2) {\n                    fa *= 0.5;\n                    agingA = 0;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n            b = x;\n            fb = fx;\n            agingB = 0;\n        }\n\n        // If the function value of the last approximation is too small,\n        // given the function value accuracy, then we can't get closer to\n        // the root than we already are.\n        if (FastMath.abs(fb) <= ftol) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return b;\n            case LEFT_SIDE:\n                if (inverted) {\n                    return b;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!inverted) {\n                    return b;\n                }\n                break;\n            case BELOW_SIDE:\n                if (fb <= 0) {\n                    return b;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (fb >= 0) {\n                    return b;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n\n        // If the current interval is within the given accuracies, we\n        // are satisfied with the current approximation.\n        if (FastMath.abs(b - a) < FastMath.max(rtol * FastMath.abs(b), atol)) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return b;\n            case LEFT_SIDE:\n                return inverted ? b : a;\n            case RIGHT_SIDE:\n                return inverted ? a : b;\n            case BELOW_SIDE:\n                return (fb <= 0) ? b : a;\n            case ABOVE_SIDE:\n                return (fb >= 0) ? b : a;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}