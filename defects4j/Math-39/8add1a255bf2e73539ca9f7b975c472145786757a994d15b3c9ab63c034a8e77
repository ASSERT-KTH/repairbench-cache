{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1; // stages include the first one (k=0)\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length]; // Stores the derivative at the end of the step\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime(); // Initialize stepStart from ODE\n    double  hNew      = 0; // Will be initialized based on first step estimation\n    boolean firstTime = true;\n    initIntegration(equations.getTime(), y0, t); // Initialize event handlers, stepStart (potentially adjusted), etc.\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // Compute the first stage derivative if needed (i.e., first step or not FSAL)\n      // This is yDot(stepStart, y)\n      if (!fsal || firstTime) {\n          computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // Initialize the step size proposal hNew for the very first step\n      if (firstTime) {\n          final double[] scale = new double[mainSetDimension];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n              }\n          } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n              }\n          }\n          // Initialize the step size proposal hNew based on tolerances and first derivatives\n          hNew = initializeStep(forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]); // yDotK[1] is estimated here\n          firstTime = false;\n      }\n      // For subsequent steps, hNew is the proposal calculated at the end of the previous step's adaptation.\n\n\n      // Error control loop: keep trying steps until the error is acceptable\n      double error = 10.0; // Initialize error > 1 to ensure the loop runs at least once\n      while (error >= 1.0) {\n\n          // Set the step size for the current attempt.\n          stepSize = hNew; // Proposed step size from init or previous rejection/acceptance cycle\n\n          // Check if the proposed step size exceeds the final time t.\n          // If so, adjust stepSize to end exactly at t to avoid evaluating derivatives outside the interval.\n          final double timeLeft = t - stepStart;\n          if (forward) {\n              // Check if the proposed step goes past t.\n              if (stepSize >= timeLeft) { // Use >= to handle the case where step hits t exactly\n                   // Ensure we don't step backward if already at t\n                   if (stepStart + stepSize > t) {\n                        stepSize = timeLeft;\n                   }\n              }\n          } else { // backward\n              // Check if the proposed step goes past t (t is \"earlier\" than stepStart).\n              if (stepSize <= timeLeft) { // Use <= as stepSize and timeLeft are negative\n                   // Ensure we don't step forward if already at t\n                   if (stepStart + stepSize < t) {\n                        stepSize = timeLeft;\n                   }\n              }\n          }\n          // If stepStart is already t, timeLeft is 0, and stepSize becomes 0.\n\n          // Prevent division by zero or infinite loops if step size is extremely small.\n          if (forward) {\n              stepSize = FastMath.max(stepSize, Math.ulp(stepStart));\n          } else {\n              stepSize = FastMath.min(stepSize, -Math.ulp(stepStart));\n          }\n\n\n          // Compute the intermediate stages (k=1 to stages-1) using the potentially adjusted stepSize.\n          for (int k = 1; k < stages; ++k) {\n\n              // Calculate y value for this stage evaluation\n              for (int j = 0; j < y0.length; ++j) {\n                  double sum = a[k-1][0] * yDotK[0][j];\n                  for (int l = 1; l < k; ++l) {\n                      sum += a[k-1][l] * yDotK[l][j];\n                  }\n                  yTmp[j] = y[j] + stepSize * sum;\n              }\n\n              // Calculate the time for this stage evaluation\n              double evalTime = stepStart + c[k-1] * stepSize;\n              // Defensively ensure the evaluation time does not go past t due to rounding,\n              // especially if c[k-1] is 1 or slightly larger, or if stepSize was capped.\n              if (forward) {\n                  evalTime = FastMath.min(evalTime, t);\n              } else {\n                  evalTime = FastMath.max(evalTime, t);\n              }\n\n              // Compute the derivative at the intermediate stage time and state\n              computeDerivatives(evalTime, yTmp, yDotK[k]);\n          }\n\n          // Estimate the state (yTmp) at the end of the step (stepStart + stepSize)\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = b[0] * yDotK[0][j];\n              for (int l = 1; l < stages; ++l) {\n                  sum += b[l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          // Estimate the local error using the derivatives computed for this step attempt.\n          // The error estimation relies on the Butcher tableau's error coefficients (not explicit here).\n          error = estimateError(yDotK, y, yTmp, stepSize);\n\n          if (Double.isNaN(error) || error >= 1.0) {\n              // Error is too large or NaN: reject the step and reduce the step size proposal (hNew).\n              final double factor = FastMath.min(maxGrowth,\n                               FastMath.max(minReduction, safety * FastMath.pow(Double.isNaN(error) ? 1.0 : error, exp))); // Treat NaN error as error = 1 for reduction\n              hNew = filterStep(stepSize * factor, forward, false); // Propose smaller step for next attempt in this loop\n\n              // Check for step size underflow - filterStep should handle minStep violation\n          }\n          // If error < 1.0, the loop condition fails, and the step is accepted below.\n\n      } // End of inner while loop (error control)\n\n\n      // Error is acceptable: accept the step.\n      // The state yTmp corresponds to the accepted state at stepStart + stepSize.\n      // The step size used was 'stepSize' (potentially adjusted to hit t).\n\n      // Store the accepted end time and state in the interpolator.\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length); // Update main state vector y\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length); // Save derivative at end of step for FSAL/handlers\n\n      // Process events, step handlers, update stepStart, and determine if this was the last step.\n      stepStart = acceptStep(interpolator, y, yDotTmp, t); // acceptStep updates integrator's isLastStep field\n\n      // Ensure yTmp is synchronized with the accepted state y (needed by interpolator before next shift/reinitialize)\n      System.arraycopy(y, 0, yTmp, 0, y.length);\n\n      // Prepare for the next step if integration is not finished.\n      if (!isLastStep) {\n\n          // Store the new step start time in the interpolator.\n          interpolator.storeTime(stepStart);\n\n          // If using FSAL, the derivative from the end of the accepted step is the first derivative for the next step.\n          if (fsal) {\n              // yDotTmp holds yDotK[stages-1] from the accepted step\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          // Propose a step size (hNew) for the next step based on the error and accepted step size of the completed step.\n          final double factor = FastMath.min(maxGrowth,\n                              FastMath.max(minReduction, safety * FastMath.pow(error, exp))); // error is the value from the accepted step\n          final double scaledH = stepSize * factor; // Base proposal on the accepted stepSize\n          final double nextT = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n\n          // Filter the proposed step size based on min/max step limits.\n          hNew = filterStep(scaledH, forward, nextIsLast); // nextIsLast might influence minStep handling in filterStep\n\n          // Final adjustment: ensure the filtered step size doesn't overshoot t for the *next* step.\n          final double filteredNextT = stepStart + hNew;\n          final boolean filteredNextIsLastCheck = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLastCheck) {\n              hNew = t - stepStart; // Adjust proposal to hit t exactly\n          }\n          // hNew is now the step size proposal for the next iteration of the main loop's error control.\n      }\n\n    } while (!isLastStep); // End of outer do-while loop (main integration)\n\n    // Integration finished. Set final state and time in the ODE object.\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState(); // Clean up internal states of the integrator\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}