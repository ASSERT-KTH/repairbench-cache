{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        // Handle cases where pointers become null during recursion up the parent chain\n        // (e.g., if one path is shorter or getParent() returns null)\n        if (p1 == null && p2 == null) {\n            // Both paths ended simultaneously, treat as equal\n            return 0;\n        }\n        if (p1 == null) {\n            // p1's path ended first (null), p2 is non-null; null comes first\n            return -1;\n        }\n        if (p2 == null) {\n            // p2's path ended first (null), p1 is non-null; null comes first\n            return 1;\n        }\n\n        // Equalize depths by moving up the deeper pointer's parent chain\n        if (depth1 < depth2) {\n            // Recurse with p2's parent. If p2.parent is null, the initial null checks\n            // in the recursive call will handle it.\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If parents compare equal (r == 0), the pointer with the greater depth (p2)\n            // comes after the pointer with the lesser depth (p1).\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            // Recurse with p1's parent.\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If parents compare equal (r == 0), the pointer with the greater depth (p1)\n            // comes after the pointer with the lesser depth (p2).\n            return r == 0 ? 1 : r;\n        }\n\n        // Depths are now equal (depth1 == depth2), and p1 and p2 are non-null.\n\n        // Optimization: if pointers are logically equal, they are equal in order.\n        // Using equals is generally safer than == for objects like NodePointer\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // Check if we have reached the root level (depth 1)\n        if (depth1 == 1) {\n            // We are comparing roots (or variable pointers which usually have depth 1).\n            // p1 and p2 are different (checked by equals above).\n\n            boolean p1IsVar = p1.isVariable(); // Assumes NodePointer has isVariable()\n            boolean p2IsVar = p2.isVariable();\n\n            if (p1IsVar != p2IsVar) {\n                // One is a variable, the other is not (a document root).\n                // Define order: Variables come before document roots.\n                return p1IsVar ? -1 : 1;\n            }\n            else {\n                // Both are variables OR both are non-variable roots.\n                if (p1IsVar) {\n                    // Both are variables (e.g., comparing $var1 and $var2).\n                    // Compare them based on their path representation (e.g., \"$varName\").\n                    // We assume asPath() provides a suitable comparable string.\n                    return p1.asPath().compareTo(p2.asPath());\n                }\n                else {\n                    // Both are non-variable roots (e.g., roots of different documents),\n                    // but they are not equal. JXPath considers pointers from different\n                    // trees incomparable in the standard document order.\n                    // Keep the original behavior of throwing an exception here.\n                    throw new JXPathException(\n                            \"Cannot compare pointers that do not belong to the same tree: '\"\n                                    + p1 + \"' and '\" + p2 + \"'\");\n                }\n            }\n        }\n\n        // Depths are equal, not at the root (depth1 > 1), pointers are different.\n        // Move up one level and compare their parents recursively.\n        NodePointer p1parent = p1.parent; // Assumes parent field is accessible\n        NodePointer p2parent = p2.parent; // Assumes parent field is accessible\n\n        int r = compareNodePointers(p1parent, depth1 - 1, p2parent, depth2 - 1);\n\n        if (r != 0) {\n            // Parents are different or one path ended; the order is determined by the parents.\n            return r;\n        }\n\n        // Parents compare as equal (r == 0).\n        // This means p1 and p2 are siblings under the same logical parent node.\n        // The recursive call returning 0 implies that p1parent and p2parent\n        // led to an equal comparison result (most likely, they point to the same common ancestor).\n        // Since depth1 > 1, this common ancestor (p1parent) should be non-null.\n\n        // We must use the parent pointer to compare the children (p1, p2)\n        // according to the rules specific to that parent type (e.g., DOM element order).\n        if (p1parent == null) {\n             // This state should theoretically not be reached if depth1 > 1 and the\n             // recursive call returned r = 0 based on finding a common ancestor.\n             // Throw an error indicating an unexpected internal state.\n             throw new IllegalStateException(\n                 \"Cannot compare sibling pointers: parent is null unexpectedly. Pointers: \" + p1 + \", \" + p2);\n        }\n\n        // Use the common parent's method to determine the order of its children p1 and p2.\n        return p1parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}