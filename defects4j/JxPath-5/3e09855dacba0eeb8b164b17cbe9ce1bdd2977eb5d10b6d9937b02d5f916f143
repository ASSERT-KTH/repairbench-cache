{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        // Handle VariablePointers first, as they are not part of the document tree hierarchy.\n        // They need a distinct comparison strategy from document node pointers.\n        boolean p1IsVar = (p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer);\n        boolean p2IsVar = (p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer);\n\n        if (p1IsVar && p2IsVar) {\n            // Both are VariablePointers.\n            // If they are the same, return 0.\n            if (p1.equals(p2)) {\n                return 0;\n            }\n            // If different VariablePointers, order them consistently by their variable names.\n            // This ensures a stable sort order for variable nodes.\n            String name1 = ((org.apache.commons.jxpath.ri.model.VariablePointer) p1).getVariableName().getName();\n            String name2 = ((org.apache.commons.jxpath.ri.model.VariablePointer) p2).getVariableName().getName();\n            return name1.compareTo(name2);\n        }\n        \n        if (p1IsVar) {\n            // If p1 is a VariablePointer and p2 is not, p1 comes before p2.\n            // This establishes an arbitrary but consistent order between variable and document nodes.\n            return -1;\n        }\n        if (p2IsVar) {\n            // If p2 is a VariablePointer and p1 is not, p2 comes before p1 (so p1 comes after p2).\n            return 1;\n        }\n\n        // At this point, neither p1 nor p2 is a VariablePointer.\n        // They are both assumed to be pointers within a document structure,\n        // and the existing tree comparison logic applies.\n\n        if (depth1 < depth2) {\n            // p1 is shallower than p2, so compare p1 with p2's parent.\n            // If p1 is an ancestor of p2, or on a path that would come before p2.\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If parents match (r == 0), it means p1 is an ancestor of p2's ancestor,\n            // or p1 is a child of p2's ancestor, effectively putting p1 before p2.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            // p1 is deeper than p2, so compare p1's parent with p2.\n            // If p2 is an ancestor of p1, or on a path that would come before p1.\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If parents match (r == 0), it means p2 is an ancestor of p1's ancestor,\n            // or p2 is a child of p1's ancestor, effectively putting p2 before p1.\n            return r == 0 ? 1 : r;\n        }\n        // Depths are equal here.\n\n        if (p1 == null && p2 == null) {\n            return 0; // Both are null, considered equal.\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0; // Pointers are equal.\n        }\n\n        // If depths are equal, and pointers are not equal, and they are not VariablePointers,\n        // and we are at depth 1 (root level), then they cannot belong to the same tree/document.\n        // This check prevents NullPointerExceptions if distinct root pointers are compared\n        // where a common parent cannot be found and `p1.parent.compareChildNodePointers` would fail.\n        if (depth1 == 1) {\n            throw new org.apache.commons.jxpath.JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        \n        // Recursively compare parents to find the common ancestor.\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r; // If parents (or higher ancestors) are different, use that ordering.\n        }\n\n        // If parents are equal (r == 0), it means p1 and p2 are siblings.\n        // Delegate the comparison to their common parent to determine their order among children.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}