{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        // Handle null pointers explicitly at the very beginning.\n        // A null pointer should generally come after any non-null pointer for sorting.\n        if (p1 == null && p2 == null) {\n            return 0; // Both are null, considered equal\n        }\n        if (p1 == null) {\n            return 1; // p1 is null, p2 is not. p1 comes after p2.\n        }\n        if (p2 == null) {\n            return -1; // p2 is null, p1 is not. p1 comes before p2.\n        }\n\n        // Handle VariablePointers specifically for cross-type comparison.\n        // VariablePointers usually sort before other NodePointers in JXPath union operations.\n        boolean p1IsVariable = (p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer);\n        boolean p2IsVariable = (p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer);\n\n        if (p1IsVariable && !p2IsVariable) {\n            return -1; // VariablePointer comes before regular NodePointer\n        }\n        if (!p1IsVariable && p2IsVariable) {\n            return 1;  // Regular NodePointer comes after VariablePointer\n        }\n\n        // If both are VariablePointers OR both are non-VariablePointers.\n        // If both are VariablePointers, compare them directly.\n        // Their parents are null and depth is 0, so the recursive logic won't work for distinct variables.\n        if (p1IsVariable /* && p2IsVariable is implied here */) {\n            if (p1.equals(p2)) {\n                return 0;\n            }\n            // If two VariablePointers are not equal, order them by their string representation (e.g., name).\n            return p1.toString().compareTo(p2.toString());\n        }\n\n        // --- Original logic for comparing non-VariablePointers (NodePointers representing paths) ---\n\n        // Try to equalize depths by moving up the parent hierarchy\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If p1 is an ancestor of p2 (r == 0), p1 comes before p2.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If p2 is an ancestor of p1 (r == 0), p1 comes after p2.\n            return r == 0 ? 1 : r;\n        }\n        // At this point, depth1 == depth2, and both p1 and p2 are non-null and non-variable.\n\n        // If they are the same pointer instance or equivalent\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // If both pointers are at the root level (depth 0, parent is null) and are not equal,\n        // they represent different trees. This is an unresolvable comparison.\n        if (depth1 == 0 && p1.parent == null && p2.parent == null) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n\n        // Recursively compare parents to find a common ancestor\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r; // Parents are different, so the order is determined by parent comparison\n        }\n\n        // If parents are identical (r == 0), compare children within the same parent\n        // This relies on the specific NodePointer implementation's compareChildNodePointers.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}