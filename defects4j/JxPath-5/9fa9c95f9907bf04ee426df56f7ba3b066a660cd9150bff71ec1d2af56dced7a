{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        // Handle null pointers first\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n        if (p1 == null) {\n            return -1; // null is \"smaller\" than any non-null pointer\n        }\n        if (p2 == null) {\n            return 1;  // non-null is \"larger\" than null\n        }\n\n        // If they are the same instance or logically equal, they are ordered identically.\n        // This check should come early as it applies to all pointer types.\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // Special handling for VariablePointers, as they don't belong to the regular document tree.\n        boolean p1IsVar = p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n        boolean p2IsVar = p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n\n        if (p1IsVar && p2IsVar) {\n            // Both are VariablePointers and are not equal (checked above).\n            // Order them deterministically by their variable names.\n            String name1 = ((org.apache.commons.jxpath.ri.model.VariablePointer) p1).getName().getName();\n            String name2 = ((org.apache.commons.jxpath.ri.model.VariablePointer) p2).getName().getName();\n            return name1.compareTo(name2);\n        } else if (p1IsVar) {\n            // p1 is a VariablePointer, p2 is not.\n            // Establish an arbitrary but consistent order: VariablePointers come before other NodePointers.\n            return -1;\n        } else if (p2IsVar) {\n            // p2 is a VariablePointer, p1 is not.\n            // Establish an arbitrary but consistent order: VariablePointers come before other NodePointers.\n            return 1;\n        }\n\n        // --- Original logic for comparing non-VariablePointers (or after var-specific handling) ---\n        // Pointers are not null, not equal, and not inter-variable-pointer types (or already ordered if both var).\n\n        // If at different depths, recurse up the deeper pointer's parent chain until depths match.\n        if (depth1 < depth2) {\n            // p1 is shallower, p2 is deeper. Move p2 up towards p1.\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If 'r == 0' after moving p2 up, it means p1 is an ancestor of p2.\n            // In document order, ancestors come before descendants. So p1 < p2.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            // p1 is deeper, p2 is shallower. Move p1 up towards p2.\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If 'r == 0' after moving p1 up, it means p2 is an ancestor of p1.\n            // In document order, ancestors come before descendants. So p2 < p1, meaning p1 > p2.\n            return r == 0 ? 1 : r;\n        }\n\n        // At this point, depth1 == depth2, and both p1 and p2 are non-null, not equal,\n        // and not VariablePointers (or their VariablePointer comparison yielded 0).\n\n        // If depth1 == 1, they are different root pointers.\n        // The original code threw a JXPathException here because they do not belong to the same logical tree\n        // and 'p1.parent' would be null, leading to a NullPointerException if we proceeded.\n        // Instead of throwing an exception, provide a stable, deterministic order for different roots.\n        if (depth1 == 1) {\n            // They are distinct root pointers (e.g., two distinct XML documents).\n            // Use their string representation for a deterministic order.\n            return p1.toString().compareTo(p2.toString());\n        }\n\n        // General case: same depth, not equal, not root. Recurse on parents to find common ancestor.\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r; // Parents were different, their comparison determines the order.\n        }\n\n        // Parents are effectively the same (r == 0). This means p1 and p2 are siblings.\n        // Compare them using their parent's specific child comparison logic.\n        // p1.parent should not be null here because depth1 > 1.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}