{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        // Adjust depths to match by moving up the tree\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If a common ancestor is found (r == 0), it means p1 is an ancestor of p2,\n            // so p1 comes before p2. Otherwise, return the comparison result.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If a common ancestor is found (r == 0), it means p2 is an ancestor of p1,\n            // so p1 comes after p2. Otherwise, return the comparison result.\n            return r == 0 ? 1 : r;\n        }\n\n        // At this point, depth1 == depth2 (same depth)\n        \n        // Base case: both pointers are null\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        // Base case: pointers are equal (refer to the same node)\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        // If we are at depth 1 (root level) and pointers are distinct and non-null,\n        // they are distinct root nodes from potentially different logical trees\n        // (e.g., a variable pointer and a document pointer).\n        // Their parents are null, so `p1.parent.compareChildNodePointers` would cause an NPE.\n        // Instead of throwing an exception, provide a consistent arbitrary order.\n        if (depth1 == 1) {\n            // Compare by class name first for a stable order across different pointer types.\n            // E.g., VariablePointer, PrimitiveNodePointer, DocumentPointer etc.\n            String class1 = p1.getClass().getName();\n            String class2 = p2.getClass().getName();\n            int r = class1.compareTo(class2);\n            if (r != 0) {\n                return r;\n            }\n            // If they are of the same class (e.g., two different VariablePointers),\n            // use their XPath path string as a tie-breaker. asPath() provides a unique string.\n            return p1.asPath().compareTo(p2.asPath());\n        }\n\n        // If depth > 1, both pointers are non-null, not equal, and at the same depth.\n        // Recursively compare their parents. This will eventually lead to either:\n        // 1. A difference being found at a higher level (r != 0).\n        // 2. A common parent being found (r == 0), meaning they share a common ancestor.\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        // If parents are equal (r == 0), then compare the two children under that common parent.\n        // This line is only reached if depth1 > 1, guaranteeing p1.parent is not null.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}