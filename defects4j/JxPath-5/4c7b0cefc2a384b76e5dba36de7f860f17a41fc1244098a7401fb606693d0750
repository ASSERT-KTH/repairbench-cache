{
    "generation": "    /**\n     * Recursively compares two node pointers based on their depth and ancestry.\n     * Handles comparisons between standard NodePointers and VariablePointers.\n     * @param p1 pointer 1\n     * @param depth1 depth of pointer 1\n     * @param p2 pointer 2\n     * @param depth2 depth of pointer 2\n     * @return -1, 0, or 1 according to the comparison result\n     */\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        if (depth1 < depth2) {\n            // If p1 is shallower, get p2's parent and compare p1 with p2's parent at depth - 1.\n            // Need to handle potential null pointer for p2 if logic allows.\n            NodePointer p2Parent = p2 == null ? null : p2.getParent();\n            int r = compareNodePointers(p1, depth1, p2Parent, depth2 - 1);\n            // If the comparison of p1 and p2's parent yields 0 (meaning p1 is an ancestor of p2 or they share the same parent at this level),\n            // then the shallower node p1 comes first.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            // If p2 is shallower, get p1's parent and compare p1's parent with p2 at depth - 1.\n            // Need to handle potential null pointer for p1 if logic allows.\n            NodePointer p1Parent = p1 == null ? null : p1.getParent();\n            int r = compareNodePointers(p1Parent, depth1 - 1, p2, depth2);\n            // If the comparison of p1's parent and p2 yields 0 (meaning p2 is an ancestor of p1 or they share the same parent at this level),\n            // then the shallower node p2 comes first, so p1 comes after p2.\n            return r == 0 ? 1 : r;\n        }\n\n        // Depths are equal (depth = depth1 = depth2)\n\n        // Check for identity or equality using NodePointer.equals()\n        // This also correctly handles the case where both p1 and p2 are null.\n        if (p1 == p2 || (p1 != null && p1.equals(p2))) {\n            return 0;\n        }\n\n        // If depths are equal but pointers are not identical/equal, handle cases where one is null.\n        // This logic assumes NodePointer.equals(null) returns false or throws exception,\n        // and relies on the previous check for p1 == p2 == null case.\n        if (p1 == null) {\n            return -1; // Define null < non-null when depths are considered equal\n        }\n        if (p2 == null) {\n            return 1; // Define non-null > null when depths are considered equal\n        }\n\n        // Both pointers are non-null, not equal, and at the same depth.\n        // Get their parents to compare ancestry.\n        NodePointer p1Parent = p1.getParent();\n        NodePointer p2Parent = p2.getParent();\n\n        // Special handling for depth 1: comparing roots or variables.\n        if (depth1 == 1) {\n            // Recursively compare their parents (which should be null or represent the ultimate root context).\n            // This call compares nodes at depth 0.\n            int r = compareNodePointers(p1Parent, 0, p2Parent, 0);\n\n            if (r == 0) {\n                // The comparison of parents at depth 0 returned 0. This typically means both parents are null\n                // or represent equivalent root contexts. We need to differentiate between NodePointers and\n                // VariablePointers, as they might wrongly appear to be in the same \"null parent\" tree.\n\n                boolean p1IsVar = p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n                boolean p2IsVar = p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n\n                if (p1IsVar != p2IsVar) {\n                     // If one is a Variable and the other is a Node, they belong to different conceptual trees.\n                     // Define an arbitrary but consistent order: Variables < Nodes.\n                     return p1IsVar ? -1 : 1;\n                }\n                else if (p1IsVar) { // Both are Variables (p1IsVar && p2IsVar)\n                    // They are different variables (since p1.equals(p2) was false).\n                    // Order them consistently using their canonical path representation (e.g., \"$varName\").\n                    // Using asPath() is a robust way to get a comparable string.\n                    return p1.asPath().compareTo(p2.asPath());\n                }\n                else { // Both are NodePointers (and not Variables)\n                    // They are different node pointers at the root level (depth 1) whose parents compared equal (r=0).\n                    // This implies they are roots of different documents or trees. JXPath cannot compare across trees.\n                    throw new org.apache.commons.jxpath.JXPathException(\n                        \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1.asPath() + \"' and '\" + p2.asPath() + \"'\");\n                }\n            }\n            else {\n                // The parents (at depth 0) compared differently (r != 0).\n                // This might happen if comparing e.g., a variable (null parent) vs a node whose root context is non-null.\n                // Return the result of the parent comparison.\n                return r;\n            }\n        }\n\n        // General case: Depths are equal and > 1.\n        // Recursively compare the parents at depth - 1.\n        int r = compareNodePointers(p1Parent, depth1 - 1, p2Parent, depth1 - 1);\n        if (r != 0) {\n            // The parents (or ancestors) differ at some level. The order is determined by the first differing ancestor.\n            return r;\n        }\n\n        // If r == 0, it means the parents compare as equal through recursion.\n        // This implies p1 and p2 are siblings under the same parent node (or conceptually under the same null parent).\n\n        // If the common parent resolved to null (can happen for variables, detached nodes, etc.),\n        // we cannot call compareChildNodePointers on the parent.\n        if (p1Parent == null) {\n             // Fallback to comparing the pointers themselves using their path representation.\n             // Since p1 and p2 are siblings (implied by r=0) but not equal, their paths should ideally differ\n             // or provide a consistent ordering basis.\n             return p1.asPath().compareTo(p2.asPath());\n        }\n\n        // If the common parent is non-null, ask it to compare its children p1 and p2.\n        // This relies on the parent node's implementation of compareChildNodePointers\n        // to determine the order of its children (e.g., document order).\n        return p1Parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}