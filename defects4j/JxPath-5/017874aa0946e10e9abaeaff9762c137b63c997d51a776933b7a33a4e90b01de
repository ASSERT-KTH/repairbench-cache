{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        // 1. Handle null pointers first and consistently.\n        // A null pointer is considered \"less than\" a non-null pointer for consistent ordering.\n        if (p1 == null && p2 == null) {\n            return 0; // Both are null, considered equal\n        }\n        if (p1 == null) {\n            return -1; // p1 is null, p2 is not null. p1 comes before p2.\n        }\n        if (p2 == null) {\n            return 1; // p1 is not null, p2 is null. p1 comes after p2.\n        }\n\n        // At this point, both p1 and p2 are guaranteed to be non-null.\n\n        // 2. If they are the same instance or logically equal, return 0.\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // 3. Adjust depths and recurse if depths are different.\n        // These recursive calls correctly handle `p.parent` as we know `p` is not null.\n        // If `p.parent` is null, the recursive call will hit the null checks at the beginning.\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            // If parents are considered equal (r == 0), it implies p2 is an ancestor (or represents an ancestor path) of p1's comparison point.\n            // Therefore, p2 should come before p1.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            // If parents are considered equal (r == 0), it implies p1 is an ancestor (or represents an ancestor path) of p2's comparison point.\n            // Therefore, p1 should come before p2.\n            return r == 0 ? 1 : r;\n        }\n\n        // 4. At this point, depth1 == depth2, and p1 != p2 (not .equals).\n        // Compare their parents recursively.\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            // Parents are different, so the order is determined by parent comparison.\n            return r;\n        }\n\n        // 5. Parents are considered equal (r == 0). Now compare the children themselves.\n        // This branch is reached if:\n        //    - p1.parent and p2.parent are the same non-null instance.\n        //    - OR p1.parent is null AND p2.parent is also null (due to the initial null handling returning 0).\n\n        if (p1.parent == null) {\n            // This implies p2.parent is also null because their comparison (r) was 0.\n            // This typically handles cases like comparing two different VariablePointers,\n            // or other \"root-level\" pointers that don't have a common non-null parent in the DOM tree.\n            // Since they are not .equals() and don't share a parent for document order comparison,\n            // provide a stable, arbitrary order.\n            int nameComp = p1.getName().compareTo(p2.getName());\n            if (nameComp != 0) {\n                return nameComp;\n            }\n            // If names are also equal (e.g., both are `text()`), fall back to identity hash code\n            // to ensure a consistent but arbitrary order for truly distinct and otherwise incomparable pointers.\n            return System.identityHashCode(p1) - System.identityHashCode(p2);\n        }\n\n        // If p1.parent is not null, it means we have a common non-null parent.\n        // Delegate the comparison to the parent's specific compareChildNodePointers method,\n        // which understands how to order its children.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}