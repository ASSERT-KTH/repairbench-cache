{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        // 1. Handle null pointers first for robust comparison\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n        if (p1 == null) { // p2 must be non-null\n            return -1; // Null comes before non-null\n        }\n        if (p2 == null) { // p1 must be non-null\n            return 1; // Non-null comes after null\n        }\n\n        // 2. Check if pointers belong to different root contexts (different \"trees\").\n        // This is crucial for comparing VariablePointers (from a variable tree) and DOMNodePointers (from a DOM tree).\n        // JXPath specifies that order for nodes from different documents/trees is \"undefined, but consistent.\"\n        if (p1.getRootNode() != p2.getRootNode()) {\n            // Provide an arbitrary but consistent order.\n            // Compare based on the hash codes of their root nodes.\n            int rootComparison = Integer.compare(p1.getRootNode().hashCode(), p2.getRootNode().hashCode());\n            if (rootComparison != 0) {\n                return rootComparison;\n            }\n            // If root hash codes are identical (highly unlikely for different root instances, but good for robustness),\n            // use their full paths as a tie-breaker to ensure consistency.\n            return p1.asPath().compareTo(p2.asPath());\n        }\n\n        // From this point, both pointers are non-null and belong to the same logical tree.\n\n        // 3. Adjust depths for comparison, moving up the tree until they are at the same level.\n        if (depth1 < depth2) {\n            // p1 is at a higher level (closer to root) or is an ancestor of p2.\n            // Recursively compare p1 with p2's parent until depths align.\n            // If `r == 0`, it means p1 and p2's parent are \"equal\" (i.e., they share the same path up to that level).\n            // In this case, p1 is an ancestor of p2, so p1 should come before p2 (-1).\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            // p2 is at a higher level (closer to root) or is an ancestor of p1.\n            // Recursively compare p1's parent with p2 until depths align.\n            // If `r == 0`, it means p2 and p1's parent are \"equal\".\n            // In this case, p2 is an ancestor of p1, so p1 should come after p2 (1).\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n\n        // 4. Depths are equal and pointers are from the same tree.\n        if (p1.equals(p2)) {\n            return 0; // Pointers are the same instance or represent the same node.\n        }\n\n        // Pointers are different but at the same depth and from the same tree.\n        // This means they are siblings or cousins.\n        // Recursively compare their parents.\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r; // If parents are different, their order determines the child order.\n        }\n\n        // Parents are the same, so p1 and p2 are siblings.\n        // Delegate to the parent to compare its children.\n        // At this point, depth1 >= 1 (since NodePointer.getDepth() for a RootNodePointer is typically 0, its children start at depth 1).\n        // Therefore, p1.parent (which is a RootNodePointer if depth1 was 1, or some other NodePointer) will not be null.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}