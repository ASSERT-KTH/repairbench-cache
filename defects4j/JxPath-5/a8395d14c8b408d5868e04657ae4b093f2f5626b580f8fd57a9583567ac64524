{
    "generation": "    /**\n     * Compare two node pointers based on their depth and position.\n     * This is a recursive helper method for comparing nodes that might\n     * not have an immediate common parent. It traverses up the tree\n     * until depths are equal or a common ancestor is found.\n     * Handles comparison between different types of pointers (like NodePointer and VariablePointer)\n     * by defining an arbitrary but consistent order when they don't share a common tree structure.\n     *\n     * @param p1     First node pointer\n     * @param depth1 Depth of the first pointer\n     * @param p2     Second node pointer\n     * @param depth2 Depth of the second pointer\n     * @return -1 if p1 < p2, 0 if p1 == p2, 1 if p1 > p2\n     */\n    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        // 1. Align depths by moving up the tree for the deeper node\n        if (depth1 < depth2) {\n            NodePointer p2parent = p2.getParent();\n            // If p2 has no parent but depth suggests it should, we might be comparing\n            // pointers from fundamentally different structures (e.g., node vs variable).\n            // Define an order: p1 comes before p2 (arbitrary, but consistent).\n            if (p2parent == null) {\n                 // If p1 is also null, they are equal in this context.\n                 // Otherwise, p1 comes first.\n                 return p1 == null ? 0 : -1;\n            }\n            int r = compareNodePointers(p1, depth1, p2parent, depth2 - 1);\n            // If the recursive call returns 0, it means p1 is equal to or an ancestor of p2.parent.\n            // Since p2 is a child of p2.parent, p1 must come before p2 in document order.\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            NodePointer p1parent = p1.getParent();\n            // Symmetrical case to the above.\n            if (p1parent == null) {\n                 // If p2 is also null, equal. Otherwise, p1 comes after p2.\n                 return p2 == null ? 0 : 1;\n            }\n            int r = compareNodePointers(p1parent, depth1 - 1, p2, depth2);\n            // If the recursive call returns 0, p2 is equal to or an ancestor of p1.parent.\n            // Since p1 is a child of p1.parent, p1 must come after p2 in document order.\n            return r == 0 ? 1 : r;\n        }\n\n        // 2. Depths are equal (depth1 == depth2 == d)\n        if (p1 == p2 || (p1 != null && p1.equals(p2))) {\n            // Pointers are identical or logically equal.\n            return 0;\n        }\n\n        // Pointers are different, but at the same depth 'd'.\n        // We need to find a common ancestor or determine order if none exists.\n\n        // Handle cases where one or both pointers might be null at equal depth,\n        // although depth calculation should ideally mean non-null pointers have depth >= 1.\n        if (p1 == null) {\n            return p2 == null ? 0 : -1; // null comes before non-null\n        }\n        if (p2 == null) {\n            return 1; // non-null comes after null\n        }\n\n        NodePointer parent1 = p1.getParent();\n        NodePointer parent2 = p2.getParent();\n\n        // 3. Check if parents are the same non-null node.\n        if (parent1 != null && parent1.equals(parent2)) {\n            // Common parent found. Compare p1 and p2 as siblings using the parent's method.\n            // This delegates to type-specific sibling comparison (e.g., DOM order).\n            try {\n                 return parent1.compareChildNodePointers(p1, p2);\n            } catch (UnsupportedOperationException ex) {\n                 // Fallback if parent type doesn't support child comparison (e.g., VariableScopePointer)\n                 // Use the root-level arbitrary comparison logic (see step 5 below).\n                 return compareRootPointers(p1, p2);\n            }\n        }\n\n        // 4. Parents are different, or at least one is null. Recurse on parents.\n        // The depth parameter 'd' (depth1) is decremented.\n        int d = depth1;\n        // Avoid infinite recursion or errors if depth calculation leads to d=0 unexpectedly.\n        // A depth of 0 should ideally correspond to null pointers already handled.\n        if (d == 0) {\n            // This state suggests roots that are not equal. Use root comparison logic.\n            return compareRootPointers(p1, p2);\n        }\n\n        int r = compareNodePointers(parent1, d - 1, parent2, d - 1);\n\n        // 5. Handle result of parent comparison.\n        if (r == 0) {\n            // Parents compared equal. This implies p1 and p2 are siblings relative to\n            // that common parent context (which could be null if they are roots).\n            // If parent1 was non-null, step 3 should have handled it.\n            // So, r=0 here likely means parents were both null or compared equal recursively\n            // up to a null root. We need to compare p1 and p2 as roots/top-level items.\n            return compareRootPointers(p1, p2);\n        }\n        else {\n            // Parents compared non-equal (r != 0). The order is determined by the parent order.\n            return r;\n        }\n    }\n\n    /**\n     * Helper method to compare two pointers assumed to be roots or top-level items\n     * without a common structural parent (e.g., VariablePointer vs RootPointer).\n     * Defines an arbitrary but consistent order.\n     */\n    private int compareRootPointers(NodePointer p1, NodePointer p2) {\n        // Handle nulls just in case they reach here\n        if (p1 == null) return p2 == null ? 0 : -1;\n        if (p2 == null) return 1;\n\n        // Define order based on pointer type: Variables first.\n        boolean var1 = p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n        boolean var2 = p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer;\n        if (var1 != var2) {\n            return var1 ? -1 : 1; // Variables come before non-variables\n        }\n\n        // Fallback for comparing two pointers of the same category (e.g., two nodes from\n        // different documents, or two variables) where standard parent traversal failed.\n        // Using identity hash code is not ideal as it's not stable across runs/JVMs,\n        // but provides *some* consistent order within a single execution context\n        // when no other structural comparison is possible.\n        // A more robust solution might involve context-specific IDs if available.\n        return System.identityHashCode(p1) < System.identityHashCode(p2) ? -1 : 1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}