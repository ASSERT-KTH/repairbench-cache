{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2) \n    {\n        // Added check: If one is a VariablePointer and the other is not,\n        // they are not comparable in the tree hierarchy sense.\n        // Define an arbitrary but consistent order to allow sorting.\n        boolean p1IsVar = (p1 instanceof org.apache.commons.jxpath.ri.model.VariablePointer);\n        boolean p2IsVar = (p2 instanceof org.apache.commons.jxpath.ri.model.VariablePointer);\n\n        if (p1IsVar != p2IsVar) {\n            // One is a VariablePointer and the other is not.\n            // This comparison should not result in a JXPathException from the depth1==1 check,\n            // as they belong to fundamentally different contexts.\n            // We define an arbitrary but consistent order for sorting:\n            // VariablePointers come before all other NodePointers.\n            return p1IsVar ? -1 : 1;\n        }\n\n        // Proceed with original logic for cases where:\n        // 1. Both are VariablePointers (their depth is usually 0, so they won't hit depth1==1 block anyway,\n        //    and will return 0 if their parents are both null and they are not equal, which is fine for distinct variables).\n        // 2. Both are NOT VariablePointers (i.e., regular NodePointers from a DOM-like tree).\n        //    In this case, the existing logic, including the JXPathException for unrelated trees, is correct.\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n\n        if (p1 != null && p1.equals(p2)) {\n            return 0;\n        }\n\n        // This block is now only reached if:\n        // - Both p1 and p2 are non-null.\n        // - Their depths are equal.\n        // - They are not equal themselves.\n        // - AND (both are VariablePointers OR both are NOT VariablePointers).\n        // If both are VariablePointers, their depth is typically 0, so this `depth1 == 1` condition will be false.\n        // Therefore, this `if (depth1 == 1)` block will only be triggered for two non-VariablePointers\n        // that are distinct roots of different DOM trees, which is the intended behavior for the exception.\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}