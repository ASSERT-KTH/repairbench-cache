{
    "generation": "    private int compareNodePointers(\n        NodePointer p1,\n        int depth1,\n        NodePointer p2,\n        int depth2)\n    {\n        // Handle null pointers explicitly to establish an arbitrary but stable order.\n        // A null pointer is generally considered \"less\" than a non-null pointer.\n        if (p1 == null && p2 == null) {\n            return 0;\n        }\n        if (p1 == null) {\n            return -1; // p1 is null, p2 is not null\n        }\n        if (p2 == null) {\n            return 1;  // p2 is null, p1 is not null\n        }\n\n        // Both p1 and p2 are guaranteed to be non-null at this point.\n\n        // If they are literally the same pointer or represent the same node, they are equal.\n        if (p1.equals(p2)) {\n            return 0;\n        }\n\n        // Distinguish between 'node-like' pointers (e.g., DOM elements, complex beans)\n        // and 'non-node-like' pointers (e.g., variables pointing to scalar values).\n        // These belong to fundamentally different types of \"trees\" and cannot be compared\n        // hierarchically. Provide a stable, arbitrary order based on their node status.\n        // For sorting in unions, it's better to have an arbitrary order than to throw an exception.\n        if (p1.isNode() != p2.isNode()) {\n            // Arbitrarily order non-nodes before nodes.\n            // For example, a VariablePointer (pointing to a String) would be isNode() == false,\n            // while a DOMNodePointer would be isNode() == true.\n            return p1.isNode() ? 1 : -1;\n        }\n\n        // If depths are different, recurse up the hierarchy to match depths.\n        // When parents are equal, the \"shorter\" path (less depth) is considered \"less\".\n        if (depth1 < depth2) {\n            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n            return r == 0 ? -1 : r;\n        }\n        if (depth1 > depth2) {\n            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n            return r == 0 ? 1 : r;\n        }\n\n        // At this point, depth1 == depth2, p1 != p2, and p1.isNode() == p2.isNode().\n\n        // If at the root level (depth 1) and still not equal, it means they are\n        // root pointers from different, hierarchically incomparable trees (e.g., two distinct XML documents).\n        // This is typically considered an error condition for hierarchical comparison of document nodes.\n        if (depth1 == 1) {\n            throw new JXPathException(\n                    \"Cannot compare pointers that do not belong to the same tree: '\"\n                            + p1 + \"' and '\" + p2 + \"'\");\n        }\n\n        // If not at the root, recurse up to their parents.\n        // The comparison result of parents determines the primary order.\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n        if (r != 0) {\n            return r;\n        }\n\n        // If parents are equal, compare the children.\n        // This assumes p1.parent and p2.parent are the same node and non-null.\n        // The common parent dictates the order of its direct children.\n        return p1.parent.compareChildNodePointers(p1, p2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}