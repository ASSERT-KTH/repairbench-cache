{
    "generation": "    /*\n    /**********************************************************\n    /* Validation, post-processing\n    /**********************************************************\n     */\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        // May need to resolve types for delegate-based creators:\n        JsonDeserializer<Object> delegate = null;\n        final ValueInstantiator valueInstantiator = _valueInstantiator;\n        AnnotatedWithParams delegateCreator = null;\n        JavaType delegateType = null;\n\n        if (valueInstantiator != null) {\n            if (valueInstantiator.canCreateUsingDelegate()) {\n                delegateType = valueInstantiator.getDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    ctxt.reportBadDefinition(_containerType, String.format(\n\"Invalid delegate-creator definition for %s: value instantiator (%s) returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\",\n                            _containerType, valueInstantiator.getClass().getName()));\n                }\n                delegateCreator = valueInstantiator.getDelegateCreator();\n                // [databind#2324]: make sure we allow conversion AND check parameters\n            } else if (valueInstantiator.canCreateUsingArrayDelegate()) {\n                delegateType = valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n                if (delegateType == null) {\n                    ctxt.reportBadDefinition(_containerType, String.format(\n\"Invalid delegate-creator definition for %s: value instantiator (%s) returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\",\n                            _containerType, valueInstantiator.getClass().getName()));\n                }\n                // Unlike with regular delegate, here selection of creator implies\n                // that we do NOT care about parameters; at least for now\n                delegateCreator = valueInstantiator.getArrayDelegateCreator();\n            }\n        }\n        // regardless of creator, find delegate deserializer:\n        if (delegateType != null) {\n            delegate = findDeserializer(ctxt, delegateType, property);\n        }\n\n        JsonDeserializer<?> valueDeser = _valueDeserializer;\n        final JavaType valueType = _containerType.getContentType();\n        if (valueDeser == null) {\n            // [databind#125]: May have a content converter\n            valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n            if (valueDeser == null) {\n            // And we may also need to get deserializer for String\n                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n            }\n        } else { // if directly assigned, probably not yet contextual, so:\n            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n        }\n        // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n        //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n        Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n                JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n        NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n        if (isDefaultDeserializer(valueDeser)) {\n            valueDeser = null;\n        }\n        return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}