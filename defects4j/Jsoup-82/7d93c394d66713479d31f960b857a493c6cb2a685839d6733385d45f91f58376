{
    "generation": "    static Document parseInputStream(InputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        BomCharset bomCharset = null;\n        boolean fullyRead = false;\n\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            // Make sure byte buffer is ready for decoding (rewind)\n            firstBytes.rewind();\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null; // discard initial doc, need to reparse\n            } else if (!fullyRead) {\n                // default charset, but wasn't fully read. Needs reparse.\n                doc = null;\n            }\n            // else, default charset and fully read. Initial parse is OK.\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        if (doc == null) { // If processing determined need to reparse (e.g. different charset found, BOM detected, stream not fully read initially)\n            if (charsetName == null)\n                charsetName = defaultCharset;\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            // Handle BOM offset AFTER reader creation. Original code skipped 1 byte. Let's assume this is correct in context, although suspicious.\n            if (bomCharset != null && bomCharset.offset)\n                reader.skip(1); // Note: Potentially unsafe if BOM > 1 byte. Review if tests fail.\n\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            // Set the charset used for parsing in the doc's output settings\n            doc.outputSettings().charset(charsetName);\n        }\n\n        // ** FIX START **\n        // Check if the character set used for parsing/initially set can actually be used for encoding output.\n        // If not, enforce defaultCharset output (usually UTF-8) and update meta tags.\n        Charset currentCharset = doc.charset(); // charset() is a shortcut for outputSettings().charset()\n        if (!currentCharset.canEncode()) {\n            try {\n                Charset fallbackCharset = Charset.forName(defaultCharset); // Use the configured default\n                doc.outputSettings().charset(fallbackCharset); // Update the document's output charset\n\n                // Update meta elements to reflect the change\n                // Select only meta tags that declare charset, to avoid modifying unrelated tags.\n                Elements metaElements = doc.select(\"meta[charset], meta[http-equiv=content-type]\");\n                for (Element meta : metaElements) {\n                    if (meta.hasAttr(\"charset\")) {\n                        meta.attr(\"charset\", fallbackCharset.name()); // Update <meta charset=\"...\">\n                    } else if (meta.hasAttr(\"http-equiv\") && meta.attr(\"http-equiv\").equalsIgnoreCase(\"content-type\")) {\n                        // Update <meta http-equiv=\"Content-Type\" content=\"...\">\n                        String content = meta.attr(\"content\");\n                        // Use the internal helper to find if charset exists in content\n                        String existingCharset = getCharsetFromContentType(content);\n                        if (existingCharset != null) { // Only update if charset=... was found\n                             // Replace the charset value using regex; $1 captures 'charset=' part (case-insensitive)\n                             meta.attr(\"content\", content.replaceFirst(\"(?i)(charset=)([^;]*)\", \"$1\" + fallbackCharset.name()));\n                        }\n                        // If no charset was in the content attr, we could potentially add it,\n                        // but simply updating existing declarations seems safer.\n                    }\n                }\n            } catch (IllegalCharsetNameException e) {\n                // This should not happen if defaultCharset is valid (e.g., UTF-8)\n                 throw new IllegalStateException(\"Jsoup defaultCharset (\"+defaultCharset+\") is invalid?\", e);\n            }\n        }\n        // ** FIX END **\n\n        input.close(); // Close the base input stream. Reader/wrapper will be GC'd.\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}