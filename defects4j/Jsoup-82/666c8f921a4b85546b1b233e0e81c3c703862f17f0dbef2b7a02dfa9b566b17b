{
    "generation": "    static Document parseInputStream(InputStream input, String inputCharsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n        String charsetName = inputCharsetName; // Use a local variable for the evolving charsetName\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        boolean didAutoDetectCharsetFromMeta = false; // Flag to track if charset was auto-detected from meta\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null; // Signal to re-parse\n                didAutoDetectCharsetFromMeta = true; // Mark that charset was auto-detected from meta\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            // The test `fallbackToUtfIfCantEncode` specifically expects `ISO-2022-CN` to become `UTF-8`\n            // when it was auto-detected from a meta tag. This often implies a browser-like fallback\n            // for problematic or less common auto-detected charsets for output.\n            if (didAutoDetectCharsetFromMeta) {\n                // Check if the current charset is one of the problematic auto-detected charsets for output.\n                // ISO-2022-CN and similar charsets are known to be tricky for general HTML output.\n                if (charsetName.equalsIgnoreCase(\"ISO-2022-CN\") ||\n                    charsetName.equalsIgnoreCase(\"ISO-2022-JP\") ||\n                    charsetName.equalsIgnoreCase(\"ISO-2022-KR\")) {\n                    \n                    charsetName = defaultCharset; // Switch to default (UTF-8)\n                    doc.outputSettings().charset(Charset.forName(charsetName));\n\n                    // Update the meta charset element in the document to reflect the change\n                    Elements metaElements = doc.head().select(\"meta[charset]\");\n                    if (!metaElements.isEmpty()) {\n                        metaElements.first().attr(\"charset\", charsetName);\n                    } else {\n                        // If no meta charset exists, add one to ensure correct output\n                        doc.head().appendElement(\"meta\").attr(\"charset\", charsetName);\n                    }\n                }\n            }\n        }\n        input.close();\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}