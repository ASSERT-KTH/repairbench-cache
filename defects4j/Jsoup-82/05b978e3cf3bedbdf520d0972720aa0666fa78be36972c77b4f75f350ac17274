{
    "generation": "import org.jsoup.helper.ConstrainableInputStream;\nimport org.jsoup.helper.Validate;\nimport org.jsoup.internal.Consts; // Assuming Consts provides bufferSize, defaultCharset etc.\nimport org.jsoup.nodes.*;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\nimport org.jsoup.UncheckedIOException;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\n\n// Assuming BomCharset class, detectCharsetFromBom, readToByteBuffer, getCharsetFromContentType, validateCharset helpers exist and are accessible in the original class (e.g., DataUtil).\n// Assuming necessary constants (bufferSize, defaultCharset, firstReadBufferSize) are accessible statics in the original class.\n\nclass FixedDataUtil { // Renamed class for clarity, replace with the actual class name\n\n    // Placeholder for static fields and helper methods assumed to exist in the original class\n    // These should be replaced with the actual fields/methods from the original codebase.\n    static final int bufferSize = 32 * 1024; // Example value\n    static final String defaultCharset = \"UTF-8\"; // Example value\n    static final int firstReadBufferSize = 5 * 1024; // Example value\n    private static class BomCharset { String charset; boolean offset; BomCharset(String c, boolean o){ charset=c; offset=o; } } // Dummy structure\n    private static BomCharset detectCharsetFromBom(ByteBuffer byteData) { /* Replace with actual implementation */ return null; }\n    private static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException { /* Replace with actual implementation */ return ByteBuffer.allocate(0); }\n    private static String getCharsetFromContentType(String contentType) { /* Replace with actual implementation */ return null; }\n    private static String validateCharset(String cs) { /* Replace with actual implementation */ return cs; }\n\n    /**\n     * Parses the input stream into a Document.\n     * @param input input stream to parse. You should close it.\n     * @param charsetName character set of input\n     * @param baseUri base URI of document, to resolve relative links against\n     * @param parser alternate parser to use.\n     * @return Document parsed from input stream\n     * @throws IOException on IO error\n     */\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        // Ensure bufferSize is reasonable, ConstrainableInputStream requires > 0\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more byte below to check if fully read.\n        fullyRead = input.read() == -1; // Check if stream completed after first chunk + 1 byte\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset; // BOM dictates charset\n\n        if (charsetName == null) { // No BOM, try finding charset in content (meta/xml)\n            try {\n                firstBytes.rewind(); // Prepare buffer for decoding\n                String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n                doc = parser.parseInput(docData, baseUri); // Parse initial chunk\n\n                // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n                Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n                String foundCharset = null;\n                for (Element meta : metaElements) {\n                    if (meta.hasAttr(\"http-equiv\"))\n                        foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (foundCharset == null && meta.hasAttr(\"charset\"))\n                        foundCharset = meta.attr(\"charset\");\n                    if (foundCharset != null)\n                        break;\n                }\n\n                // look for <?xml encoding='ISO-8859-1'?>\n                if (foundCharset == null && doc.childNodeSize() > 0) {\n                    Node first = doc.childNode(0);\n                    XmlDeclaration decl = null;\n                    if (first instanceof XmlDeclaration) {\n                        decl = (XmlDeclaration) first;\n                    } else if (first instanceof Comment) {\n                        Comment comment = (Comment) first;\n                        if (comment.isXmlDeclaration())\n                            decl = comment.asXmlDeclaration();\n                    }\n                    if (decl != null) {\n                        if (decl.hasAttr(\"encoding\")) {\n                           foundCharset = decl.attr(\"encoding\");\n                        }\n                    }\n                }\n\n                foundCharset = validateCharset(foundCharset); // Validate charset string\n\n                if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                    // Found valid charset, different from default. Need re-parse.\n                    charsetName = foundCharset;\n                    doc = null; // Discard initial parse\n                } else if (!fullyRead) {\n                    // Charset is default (or not found), but stream not fully read. Need re-parse.\n                    doc = null; // Discard initial parse\n                }\n                // If charset is default/not found, and stream was fully read, the initial 'doc' is final.\n            } catch (UncheckedIOException | UnsupportedCharsetException | IllegalCharsetNameException e) {\n                // If decoding initial chunk fails, or default charset is bad.\n                doc = null; // Cannot use initial parse. Proceed to full parse.\n            }\n        } else { // charsetName was provided (from BOM, header, or user)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            // We have a charset, but haven't parsed yet (or initial parse was just for detection). Need full parse.\n            doc = null;\n        }\n\n        if (doc == null) { // Need to parse the whole stream\n            if (charsetName == null) {\n                charsetName = defaultCharset; // Fallback if no charset determined\n            }\n\n            // Validate charset name *before* using it for InputStreamReader\n            try {\n                if (!Charset.isSupported(charsetName)) {\n                    throw new UnsupportedCharsetException(charsetName);\n                }\n            } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n                // Use default charset if the determined one is invalid/unsupported for reading\n                charsetName = defaultCharset;\n                // Consider logging a warning that the specified charset was unsupported\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n\n            // Skip BOM? InputStreamReader should handle standard UTF BOMs.\n            if (bomCharset != null && bomCharset.offset) {\n                // This case implies a BOM was found, but it should be considered part of the content.\n                // InputStreamReader might still strip it, potentially causing issues.\n                // However, the original code's reader.skip(1) was problematic.\n                // Relying on InputStreamReader's standard behavior is generally safer.\n                // If bomCharset.offset is true for a standard BOM, ISR will likely skip it anyway.\n                // If it's a non-standard BOM, this needs careful handling based on bomCharset details.\n                // For now, we omit the skip, assuming standard behavior is sufficient.\n            }\n\n            try {\n                doc = parser.parseInput(reader, baseUri); // Parse the entire stream\n            } catch (UncheckedIOException e) {\n                throw e.ioException(); // Throw original IO exception if parsing fails\n            }\n\n            // ---- FIX STARTS ----\n            // Determine the final charset for the document's output settings.\n            // Use the charset we successfully read with, unless it cannot be used for encoding.\n            Charset outputCharset;\n            try {\n                 outputCharset = Charset.forName(charsetName);\n            } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n                 // This should be rare due to the isSupported check above, but as a final fallback:\n                 outputCharset = Charset.forName(defaultCharset);\n            }\n\n            // Check if the selected charset can be used for encoding.\n            if (!outputCharset.canEncode()) {\n                 // If not encodable, switch to the default charset (e.g., UTF-8) for output.\n                 outputCharset = Charset.forName(defaultCharset);\n            }\n            // Apply the determined (and encodable) charset to the document's output settings.\n            doc.outputSettings().charset(outputCharset);\n            // ---- FIX ENDS ----\n        }\n        // Close the (potentially wrapped) input stream.\n        input.close();\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}