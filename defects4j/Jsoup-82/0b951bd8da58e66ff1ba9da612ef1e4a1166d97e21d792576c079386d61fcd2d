{
    "generation": "import org.jsoup.helper.Validate;\nimport org.jsoup.internal.ConstrainableInputStream;\nimport org.jsoup.nodes.*;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.select.Elements;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n// Imports assumed available or defined elsewhere:\n// static fields: defaultCharset, bufferSize, firstReadBufferSize\n// static methods: readToByteBuffer, detectCharsetFromBom, getCharsetFromContentType, validateCharset\n// classes: BomCharset, UncheckedIOException\n\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            try {\n                String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n                doc = parser.parseInput(docData, baseUri);\n\n                // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n                Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n                String foundCharset = null; // if not found, will keep utf-8 as best attempt\n                for (Element meta : metaElements) {\n                    if (meta.hasAttr(\"http-equiv\"))\n                        foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    if (foundCharset == null && meta.hasAttr(\"charset\"))\n                        foundCharset = meta.attr(\"charset\");\n                    if (foundCharset != null)\n                        break;\n                }\n\n                // look for <?xml encoding='ISO-8859-1'?>\n                if (foundCharset == null && doc.childNodeSize() > 0) {\n                    Node first = doc.childNode(0);\n                    XmlDeclaration decl = null;\n                    if (first instanceof XmlDeclaration)\n                        decl = (XmlDeclaration) first;\n                    else if (first instanceof Comment) {\n                        Comment comment = (Comment) first;\n                        if (comment.isXmlDeclaration())\n                            decl = comment.asXmlDeclaration();\n                    }\n                    if (decl != null) {\n                        if (decl.name().equalsIgnoreCase(\"xml\"))\n                            foundCharset = decl.attr(\"encoding\");\n                    }\n                }\n                foundCharset = validateCharset(foundCharset);\n                if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    doc = null; // set doc to null to trigger re-parse\n                } else if (!fullyRead) {\n                    // We need to parse the full stream, even if the charset is the default, because we only read a snippet so far.\n                    doc = null; // set doc to null to trigger re-parse\n                }\n                // If doc is not null here, it means the stream was fully read, and the charset used was the default,\n                // or the declared charset was the default. Or there was no charset declaration.\n            } catch (UncheckedIOException e) {\n                // If the input stream was closed early by the user, this is triggered.\n                 throw e.ioException();\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        if (doc == null) { // If still null, need parsing (or re-parsing) from stream.\n            if (charsetName == null)\n                charsetName = defaultCharset;\n\n            BufferedReader reader = null;\n            try {\n                // InputStreamReader is generally expected to handle BOMs for UTF-* charsets.\n                // Removed original reader.skip(1) for BOM handling as it was likely incorrect.\n                reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            // reader is automatically closed by input.close() further down\n        }\n\n        // At this point, 'doc' contains the parsed document. Finalize output settings.\n        // Determine the charset used for parsing. If we parsed the initial buffer and found no meta charset, charsetName might be null.\n        final String finalCharsetName = charsetName != null ? charsetName : defaultCharset;\n        Charset parsedCharset;\n        try {\n            parsedCharset = Charset.forName(finalCharsetName);\n        } catch (IllegalCharsetNameException e) {\n            // If the name was validated previously, this is less likely. Fallback just in case.\n            parsedCharset = Charset.forName(defaultCharset);\n        }\n        doc.outputSettings().charset(parsedCharset); // Set the output charset initially to the one used for parsing\n\n        // Fallback check: if the parsed charset cannot be used for encoding, switch to default (UTF-8) and update meta\n        if (!parsedCharset.canEncode()) {\n            try {\n                doc.outputSettings().charset(defaultCharset); // Fallback to the configured default charset\n            } catch (IllegalCharsetNameException e) {\n                // Unlikely error with defaultCharset (\"UTF-8\")\n            }\n\n            // Update meta tags to reflect the fallback charset\n            String updateCharset = doc.outputSettings().charset().name(); // e.g., \"UTF-8\"\n\n            // Update <meta charset=\"...\">\n            Elements metaElements = doc.select(\"meta[charset]\");\n            for (Element meta : metaElements) {\n                meta.attr(\"charset\", updateCharset);\n            }\n\n            // Update <meta http-equiv=\"content-type\" content=\"...\">\n            metaElements = doc.select(\"meta[http-equiv=content-type]\");\n            Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\");\n            for (Element meta : metaElements) {\n                String content = meta.attr(\"content\");\n                Matcher m = charsetPattern.matcher(content);\n                if (m.find()) {\n                    // If a charset was specified in the content attribute, update it\n                    String updatedContent = new StringBuilder(content).replace(m.start(1), m.end(1), updateCharset).toString();\n                    meta.attr(\"content\", updatedContent);\n                }\n                // Note: If content did not originally specify charset, we don't add it.\n                // This preserves the original structure as much as possible while correcting the encoding declaration.\n            }\n        }\n\n        input.close(); // Close the base input stream. Closing the wrapped ConstrainableInputStream also closes the original stream.\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}