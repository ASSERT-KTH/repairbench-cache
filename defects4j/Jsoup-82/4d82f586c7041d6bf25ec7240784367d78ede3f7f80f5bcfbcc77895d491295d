{
    "generation": "    static Document parseInputStream(@Nullable InputStream input, @Nullable String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n        @Nullable BomCharset bomCharset = null;\n\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // read first chunk to detect charset\n        fullyRead = input.read() == -1; // Check if stream completed after first read\n        input.reset();\n\n        // Look for BOM - overrides any other header or input. Does not update position.\n        bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // Determine from meta element, or <?xml env\n            firstBytes.rewind(); // Rewind buffer to read meta charset afresh\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            // Subsequent readToByteBuffer might be required if bytes representation differs vs default decode\n            // We don't yet know the HTML structure, so parsing the initial flavoursome bytes is the only way to find meta\n            // charset. If we could peek the bytes and detect meta charset without parsing, that'd be more efficient.\n\n            doc = parser.parseInput(docData, baseUri);\n\n            // Check for meta charset\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null;\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // Check for <?xml encoding declaration\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // Charset found, differs from default; update and reset for re-parse\n                charsetName = foundCharset;\n                doc = null; // Signal re-parse\n            } else if (!fullyRead) {\n                // Fully read check helps when we read the whole doc matching default charset initially\n                doc = null; // Signal re-parse with default charset\n            }\n            // If found charset is null or same as default, and fullyRead, doc is OK as is.\n        } else { // Charset specified by caller (e.g. HTTP header)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        if (doc == null) { // Needs re-parsing\n            if (charsetName == null) // If no charset specified or detected, use default\n                charsetName = defaultCharset;\n\n            input.reset(); // Back to stream start\n            if (bomCharset != null && bomCharset.offset) {\n                // If BOM detected, skip BOM bytes before reading\n                // detectCharsetFromBom updates the position of the buffer to after the BOM\n                int bomLen = firstBytes.position();\n                 if (bomLen > 0) {\n                     long skipped = input.skip(bomLen);\n                     Validate.isTrue(skipped == bomLen, \"Input stream could not be skipped as requested for BOM adjustment.\");\n                 }\n            }\n\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) { // Seen some InputReaders throw this on stream ends\n                throw e.ioException();\n            }\n            // Class uses UTF-8 by default; update meta if appropriate. Node charset update happens below\n             Charset parsedCharset = Charset.forName(charsetName);\n             doc.outputSettings().charset(parsedCharset);\n        } else {\n            // Doc parsed ok on initial pass; update charset to detected final name\n            Validate.notNull(charsetName); // Must have been set by now\n            doc.outputSettings().charset(Charset.forName(charsetName));\n        }\n\n        input.close();\n\n        // Check if the determined charset can encode, otherwise fallback to UTF-8:\n        // Note that the meta update relies on the document structure being modifiable. This may be undesirable.\n        Charset currentCharset = doc.outputSettings().charset();\n        if (!currentCharset.canEncode()) {\n            try {\n                doc.outputSettings().charset(Charset.forName(defaultCharset));\n            } catch (IllegalCharsetNameException e) {\n                Validate.fail(\"Default charset \" + defaultCharset + \" unsupported?\", e);\n            }\n\n            // Update meta elements to reflect the fallback\n            Elements metaElements = doc.select(\"meta[charset], meta[http-equiv=content-type]\");\n            Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\"); // Re-compile pattern here, or make static final\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"charset\")) {\n                    meta.attr(\"charset\", doc.outputSettings().charset().name());\n                } else if (meta.hasAttr(\"http-equiv\") && meta.attr(\"http-equiv\").equalsIgnoreCase(\"content-type\")) {\n                    String content = meta.attr(\"content\");\n                    Matcher m = charsetPattern.matcher(content);\n                    if (m.find()) {\n                        // Replace the found charset name with the new one\n                        String updatedContent = content.substring(0, m.start(1)) + doc.outputSettings().charset().name() + content.substring(m.end(1));\n                        meta.attr(\"content\", updatedContent);\n                    }\n                    // We could also add a charset if one wasn't found; but generally it's better to just update\n                    // the existing declaration.\n                }\n            }\n        }\n\n        // Ensure the document location is set (was missing in original)\n        doc.location(baseUri);\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}