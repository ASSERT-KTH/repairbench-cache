{
    "generation": "import org.apache.commons.jxpath.ri.Compiler;\nimport org.apache.commons.jxpath.ri.QName;\nimport org.apache.commons.jxpath.ri.compiler.NodeNameTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTest;\nimport org.apache.commons.jxpath.ri.compiler.NodeTypeTest;\nimport org.apache.commons.jxpath.ri.compiler.ProcessingInstructionTest;\nimport org.apache.commons.jxpath.ri.model.dom.DOMNodePointer; // Assuming this class exists and provides the helper methods\nimport org.w3c.dom.Node;\nimport org.w3c.dom.ProcessingInstruction;\n\n// Auxiliary static method assumed to exist elsewhere or be commonly available\n// private static boolean equalStrings(String s1, String s2) {\n//    return s1 == null ? s2 == null : s1.equals(s2);\n// }\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String testLocalName = testName.getName();\n            String requiredNsURI = nodeNameTest.getNamespaceURI();\n            boolean isWildcardName = nodeNameTest.isWildcard(); // testLocalName.equals(\"*\")\n            String testPrefix = testName.getPrefix();\n\n            // Handle '*' test (wildcard name, no prefix --> matches any element regardless of namespace)\n            if (isWildcardName && testPrefix == null) {\n                return true;\n            }\n\n            // Determine the node's effective namespace URI and local name\n            String nodeNsURI = DOMNodePointer.getNamespaceURI(node); // Use helper (calls node.getNamespaceURI())\n\n            // Calculate the effective local name, handling non-namespace-aware DOMs where node.getLocalName() might be null\n            String nodeEffectiveLocalName = node.getLocalName();\n            if (nodeEffectiveLocalName == null) {\n                // Fallback for non-NS aware nodes, or nodes created with createElement instead of createElementNS\n                // In this case, node.getNodeName() might return \"prefix:localName\" or just \"localName\"\n                String nodeName = node.getNodeName();\n                // We need the local part for comparison\n                int colon = nodeName.indexOf(':');\n                if (colon >= 0) {\n                    // If there's a prefix, extract the part after the colon\n                    nodeEffectiveLocalName = nodeName.substring(colon + 1);\n                } else {\n                    // Otherwise, the whole nodeName is the local name\n                    nodeEffectiveLocalName = nodeName;\n                }\n                // Note: For such nodes, nodeNsURI is typically null, which is correctly retrieved by DOMNodePointer.getNamespaceURI.\n            }\n\n            // Check local name match\n            // It matches if the test name is a wildcard (like prefix:*) or if the local names are equal.\n            boolean localNameMatches = isWildcardName || testLocalName.equals(nodeEffectiveLocalName);\n\n            if (!localNameMatches) {\n                // If local names don't match (and test wasn't a name wildcard), then this node doesn't match the test.\n                return false;\n            }\n\n            // Local name matches (or is wildcard like prefix:*)\n            // Now, check if the namespace URIs match.\n            // This correctly handles:\n            // - prefix:local (compares requiredNsURI from prefix with nodeNsURI)\n            // - prefix:* (localNameMatches was true due to isWildcardName=true, compares requiredNsURI with nodeNsURI)\n            // - localName (requiredNsURI is default NS or null, compares with nodeNsURI)\n            // - *:localName (if requiredNsURI is null, compares null with nodeNsURI - may need refinement if *:localName should match *any* NS)\n            // - '*' was handled earlier.\n            // The `equalStrings` helper correctly handles null comparisons (null URI means no namespace).\n            return equalStrings(requiredNsURI, nodeNsURI);\n\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    // NODE_TYPE_NODE test typically matches Element nodes in JXPath/DOM context.\n                    // The original code also included Document nodes, which might be correct depending on JXPath interpretation.\n                    // Retaining original logic. If only elements should match, remove `|| nodeType == Node.DOCUMENT_NODE`.\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                // Test PI target name must match the node's PI target name.\n                return testPI.equals(nodePI);\n            }\n            // If it's not a PI node, it cannot match a ProcessingInstructionTest\n             return false;\n        }\n        // Unknown test type or node type did not match test conditions\n        return false;\n    }\n\n    /**\n     * Helper function to compare strings, handling nulls.\n     * (Copied from original context for completeness within this fixed function scope,\n     * assuming it was available/accessible)\n     * @param s1 string 1\n     * @param s2 string 2\n     * @return true if strings are equal\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null) {\n            return s2 == null;\n        }\n        return s1.equals(s2);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}