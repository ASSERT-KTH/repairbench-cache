{
    "generation": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean localNameWildcard = nodeNameTest.isWildcard(); // true if testName.getName().equals(\"*\")\n            String testPrefix = testName.getPrefix();\n\n            // Case 1: XPath name test is \"*\" (matches any element, any namespace)\n            // This occurs when the QName has a local name \"*\" and no prefix (or null prefix).\n            if (localNameWildcard && testPrefix == null) {\n                return true;\n            }\n\n            // Case 2: XPath name test is \"prefix:*\" (matches any local name within a specific namespace)\n            // In this case, localNameWildcard is true, and testPrefix is non-null and not \"*\".\n            // This will be handled by the final 'if' block, where 'localNameWildcard' will be true\n            // and the namespace check will be performed.\n\n            // Case 3: XPath name test is \"*:localName\" (matches a specific local name in any namespace)\n            // In this case, testPrefix is \"*\" and localNameWildcard is false.\n            // The original logic would incorrectly apply a namespace check (typically against null),\n            // making it only match nodes in no namespace. XPath dictates it should match\n            // any node with the given local name, regardless of its namespace.\n            if (\"*\".equals(testPrefix)) {\n                return testName.getName().equals(DOMNodePointer.getLocalName(node));\n            }\n            \n            // Cases 4 & 5:\n            // Case 4: XPath name test is \"prefix:localName\" (matches specific local name and specific namespace).\n            // Case 5: XPath name test is \"localName\" (matches specific local name, in default namespace or no namespace).\n            // In these cases, localNameWildcard is false.\n            // The logic should check for local name equality AND namespace URI equality.\n            // The 'localNameWildcard' in the condition handles 'prefix:*' cases not caught above.\n            if (localNameWildcard // True for 'prefix:*'\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) { // True for 'prefix:localName' and 'localName'\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                // Compare namespace URIs. 'equalStrings' handles null/empty string equivalence.\n                return DOMNodePointer.equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                // For a processing-instruction() test without a target, testPI would be null.\n                // In that case, it should match any processing instruction.\n                // Otherwise, it should match if the targets are equal.\n                return testPI == null || testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}