{
    "generation": "    /**\n     * Test a node against a NodeTest.\n     * @param node Node to test\n     * @param test NodeTest to apply\n     * @return true if the node matches the test.\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI(); // Expected URI from test context\n            boolean wildcard = nodeNameTest.isWildcard(); // True if the local name part is '*'\n            String testPrefix = testName.getPrefix(); // Prefix used in the test (e.g., 'B')\n\n            // Test is '*' (wildcard name, no prefix constraint) - matches any element\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            // Test involves a specific local name (prefix:name or name)\n            // OR a wildcard name within a specific namespace (prefix:*)\n            // Check if local name matches, unless the test is prefix:* (wildcard name)\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n\n                // If local name matches OR test is prefix:*, compare namespaces.\n                String nodeNS = DOMNodePointer.getNamespaceURI(node); // Actual NS URI of the node\n\n                // Treat null and empty strings as equivalent for namespace URIs,\n                // as DOM might return null for no namespace, while the test context\n                // might use \"\" if a prefix was explicitly bound to \"\".\n                String testNS = namespaceURI;\n                boolean testIsEmpty = (testNS == null || testNS.length() == 0);\n                boolean nodeIsEmpty = (nodeNS == null || nodeNS.length() == 0);\n\n                if (testIsEmpty) {\n                    return nodeIsEmpty; // Match if node is also in no namespace (null or \"\")\n                }\n                if (nodeIsEmpty) { // testNS is not empty, nodeNS is empty/null\n                    return false; // Mismatch\n                }\n                // Both are non-null and non-empty, compare them.\n                return testNS.equals(nodeNS);\n            }\n            // Local name did not match (and test was not prefix:*)\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    // In DOM, ELEMENT_NODE covers what JXPath NODE_TYPE_NODE typically means in tests.\n                    // DOCUMENT_NODE is sometimes included but less common for direct step tests.\n                    // Let's stick to ELEMENT_NODE based on typical usage unless tests require Document.\n                    // Original: return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE;\n                    return nodeType == Node.ELEMENT_NODE; // More focused test, adjust if needed\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                // Original: return testPI.equals(nodePI);\n                // Use null-safe equals\n                return (testPI == null) ? (nodePI == null) : testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Helper method for null-safe string comparison.\n     * Included here for completeness if not available elsewhere.\n     * @param s1 String 1\n     * @param s2 String 2\n     * @return true if strings are equal (or both null)\n     */\n    private static boolean equalStrings(String s1, String s2) {\n        if (s1 == null) {\n            return s2 == null;\n        }\n        return s1.equals(s2);\n    }\n\n    // Note: The following classes/constants are assumed to exist from the context:\n    // import org.w3c.dom.*;\n    // import org.apache.commons.jxpath.ri.compiler.*;\n    // import org.apache.commons.jxpath.ri.QName;\n    // import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer;",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}