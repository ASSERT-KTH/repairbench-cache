{
    "generation": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n\n            // Case 1: Test is '*' (any element)\n            // This applies if the test represents a universal name test, typically QName(\"*\") where prefix is null.\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            // Case 2: Test is '*:name' (any namespace, specific local name)\n            // This means the test prefix is '*', and the name is specific (not '*').\n            // Also handles '*:*' effectively as '*' (any name in any namespace) if testName.getName() is also \"*\".\n            if (testPrefix != null && testPrefix.equals(\"*\")) {\n                // For '*:name' or '*:*', only the local name needs to match (or be wildcarded)\n                return testName.getName().equals(DOMNodePointer.getLocalName(node));\n            }\n\n            // Case 3: All other cases (non-wildcard prefix:name, or prefix:*)\n            // This covers:\n            // - 'prefix:*' (specific namespace, any local name) - wildcard is true, testPrefix is not null.\n            // - 'prefix:name' (specific namespace, specific local name) - wildcard is false.\n            // - 'name' (no prefix, no namespace) - wildcard is false, testPrefix is null.\n            if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS);\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}