{
    "generation": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        // Normalize empty prefix to null\n        if (testPrefix != null && testPrefix.length() == 0) {\n            testPrefix = null;\n        }\n\n        // A \"*\" with no prefix matches any element\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n\n        String localName = DOMNodePointer.getLocalName(node);\n        // Match either \"*\" or exact local name\n        if (wildcard || testName.getName().equals(localName)) {\n            // First try the standard DOM namespaceURI\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            // If there's no DOM-based namespace, fall back to xmlns declarations in ancestors\n            if (nodeNS == null || nodeNS.length() == 0) {\n                Node current = node;\n                while (current != null && current.getNodeType() == Node.ELEMENT_NODE) {\n                    NamedNodeMap atts = current.getAttributes();\n                    if (atts != null) {\n                        if (testPrefix == null) {\n                            // default namespace\n                            Node def = atts.getNamedItem(\"xmlns\");\n                            if (def != null) {\n                                nodeNS = def.getNodeValue();\n                                break;\n                            }\n                        } else {\n                            // prefixed namespace\n                            Node attr = atts.getNamedItem(\"xmlns:\" + testPrefix);\n                            if (attr != null) {\n                                nodeNS = attr.getNodeValue();\n                                break;\n                            }\n                        }\n                    }\n                    current = current.getParentNode();\n                }\n            }\n            return equalStrings(namespaceURI, nodeNS);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        int nodeType = node.getNodeType();\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return nodeType == Node.ELEMENT_NODE\n                   || nodeType == Node.DOCUMENT_NODE;\n            case Compiler.NODE_TYPE_TEXT:\n                return nodeType == Node.CDATA_SECTION_NODE\n                   || nodeType == Node.TEXT_NODE;\n            case Compiler.NODE_TYPE_COMMENT:\n                return nodeType == Node.COMMENT_NODE;\n            case Compiler.NODE_TYPE_PI:\n                return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest) {\n        if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n    }\n    return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}