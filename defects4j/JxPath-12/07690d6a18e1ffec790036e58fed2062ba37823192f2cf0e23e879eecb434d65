{
    "generation": "    /**\n     * Tests if the specified node matches the supplied NodeTest.\n     * Handles NodeNameTest, NodeTypeTest, and ProcessingInstructionTest.\n     *\n     * @param node The DOM Node to test.\n     * @param test The NodeTest to apply.\n     * @return true if the node matches the test, false otherwise.\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            // A null test matches any node.\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            // Node must be an Element to possibly match a NodeNameTest.\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String testLocalName = testName.getName();\n            String testPrefix = testName.getPrefix();\n            // namespaceURI is the URI associated with testPrefix in the XPath context.\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            // wildcard indicates if the test local name is '*' (e.g., prefix:*).\n            boolean wildcard = nodeNameTest.isWildcard();\n\n            // Case 1: Test is * (match any element) or *:* (treated same as *).\n            // Here, wildcard is true, testPrefix is null.\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n\n            // Get node's actual local name and namespace URI.\n            // Assumes DOM is namespace aware, these methods return correct values.\n            String nodeLocalName = DOMNodePointer.getLocalName(node);\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n\n            // Namespace comparison logic: treat null and empty string \"\" as equivalent.\n            boolean namespacesMatch;\n            if (namespaceURI == null || namespaceURI.isEmpty()) {\n                // If test expects null/empty NS, node must also have null/empty NS.\n                namespacesMatch = (nodeNS == null || nodeNS.isEmpty());\n            } else {\n                // If test expects a specific NS, node must have the exact same NS.\n                // Node NS can be null here, equals handles that correctly.\n                namespacesMatch = namespaceURI.equals(nodeNS);\n            }\n\n            // Case 2: Test is prefix:* (wildcard local name, specific namespace).\n            // Here, wildcard is true, testPrefix is not null.\n            if (wildcard) {\n                // Only the namespace needs to match.\n                return namespacesMatch;\n            }\n\n            // Case 3: Test is QName (specific local name, specific or null namespace).\n            // Here, wildcard is false. Check both local name and namespace.\n            // This covers \"prefix:localName\" and \"localName\" (where prefix is null).\n            // Use null-safe equals for local name comparison.\n            boolean localNameMatch = (testLocalName == null ? nodeLocalName == null : testLocalName.equals(nodeLocalName));\n\n            if (localNameMatch) {\n                 // If local names match, the result depends on namespace comparison.\n                 return namespacesMatch;\n            }\n\n            // Case 4: Test is *:localName (any namespace, specific local name).\n            // This case is not explicitly handled by the structure derived from the original code.\n            // Standard JXPath might represent this differently or not support it directly\n            // in NodeNameTest in this manner. Assuming it's not required based on the fix needed.\n\n            // If local names did not match for a QName test.\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                // Compiler constants are specific to JXPath's internal representation.\n                // Assuming original logic reflected the intended meaning of these constants.\n                case Compiler.NODE_TYPE_NODE : // Test 'node()' - Original logic matched ELEMENT or DOCUMENT. Keep this interpretation.\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT : // Test 'text()'\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT : // Test 'comment()'\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI : // Test 'processing-instruction()' - Matches any PI\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            // Unknown node type constant in the test.\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            // Test 'processing-instruction('target')' - Matches specific PI target.\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPITarget = ((ProcessingInstructionTest) test).getTarget();\n                String nodePITarget = ((ProcessingInstruction) node).getTarget();\n                // Use null-safe equals for comparing PI targets.\n                return java.util.Objects.equals(testPITarget, nodePITarget);\n            }\n             // Node is not a PI, so it cannot match this test.\n             return false;\n        }\n        // The test is of an unknown or unsupported type.\n        return false;\n    }\n\n    /* Assume DOMNodePointer and Compiler classes are available in the context */\n    /* Assume QName class structure and methods */\n    /* Assume Node, Element, ProcessingInstruction interfaces from org.w3c.dom */\n    /* Assume NodeTest, NodeNameTest, NodeTypeTest, ProcessingInstructionTest classes from JXPath */\n\n    // Helper methods assumed to exist based on original code:\n    // static class DOMNodePointer {\n    //    public static String getLocalName(Node node) { /* ... */ return node.getLocalName(); }\n    //    public static String getNamespaceURI(Node node) { /* ... */ return node.getNamespaceURI(); }\n    // }\n    // static class Compiler { // Constants for node types\n    //    public static final int NODE_TYPE_NODE = 1;\n    //    public static final int NODE_TYPE_TEXT = 2;\n    //    public static final int NODE_TYPE_COMMENT = 3;\n    //    public static final int NODE_TYPE_PI = 4;\n    // }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}