{
    "generation": "        void read(Tokeniser t, CharacterReader r) {\n            // previous state ensures we start with a letter. Optimize for that path.\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                // r.advance(); // bug: consumeLetterSequence already advances. removed.\n                return; // allows next state to handle characters after tag name\n            }\n\n            // If we're in ScriptDataEndTagName, the logic is different from TagName\n            // Handling for the general TagName state, but adapted slightly for ScriptDataEndTagName context\n            // based on the presence of isAppropriateEndTagToken check and dataBuffer usage.\n\n            boolean isAppropriateEndTag = t.isAppropriateEndTagToken();\n\n            if (isAppropriateEndTag && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data); // Should transition back to ScriptData state normally\n                        break;\n                    default:\n                        // appropriate end tag name, but not ended correctly.\n                        // backtrack to treat as data.\n                        // t.dataBuffer.append(c); // bug: shouldn't append current char here, anythingElse handles it. removed.\n                        r.unconsume(); // put char back for anythingElse handler to process\n                        anythingElse(t, r); // handle as data\n                        break;\n                }\n            } else {\n                // Tag name didn't match appropriate end tag, or reader empty. Treat as data.\n                 anythingElse(t, r);\n            }\n        }\n\n        // Assuming 'anythingElse' is defined elsewhere in the context (likely specific to ScriptDataEndTagName)\n        // and handles emitting \"</\" + dataBuffer content and transitioning back to the main data state (ScriptData).\n        // private void anythingElse(Tokeniser t, CharacterReader r) { ... }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}