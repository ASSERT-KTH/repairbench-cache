{
    "generation": "        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                // r.advance(); // REMOVED: consumeLetterSequence() already advances the reader.\n                return;\n            }\n\n            // Handle End-Of-File (EOF) explicitly\n            if (r.isEmpty()) {\n                t.emitEOF();\n                return;\n            }\n\n            // The following switch block was incorrectly guarded by `t.isAppropriateEndTagToken()`.\n            // These transitions (for whitespace, '/', '>') apply to both start and end tags\n            // once the tag name has been fully consumed.\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    // This default case and call to anythingElse() were present in the original code,\n                    // handling other characters after the tag name. We preserve this behavior\n                    // for unhandled characters, while ensuring critical characters (like '>') are handled correctly.\n                    t.dataBuffer.append(c);\n                    anythingElse(t, r);\n                    break;\n            }\n        }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}