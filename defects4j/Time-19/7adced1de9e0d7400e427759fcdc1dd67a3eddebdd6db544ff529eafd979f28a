{
    "generation": "/**\n * Gets the millisecond offset to subtract from local time to get UTC time.\n * This offset can be used to undo adding the offset obtained by getOffset.\n *\n * <pre>\n * millisLocal == millisUTC   + getOffset(millisUTC)\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n * </pre>\n *\n * NOTE: After calculating millisLocal, some error may be introduced. At\n * offset transitions (due to DST or other historical changes), ranges of\n * local times may map to different UTC times.\n * <p>\n * This method will return an offset suitable for calculating an instant\n * after any DST gap. For example, consider a zone with a cutover\n * from 01:00 to 01:59:<br />\n * Input: 00:00  Output: 00:00<br />\n * Input: 00:30  Output: 00:30<br />\n * Input: 01:00  Output: 02:00<br />\n * Input: 01:30  Output: 02:30<br />\n * Input: 02:00  Output: 02:00<br />\n * Input: 02:30  Output: 02:30<br />\n * <p>\n * During a DST overlap (where the local time is ambiguous) this method will return\n * the earlier instant. The combination of these two rules is to always favour\n * daylight (summer) time over standard (winter) time.\n * <p>\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n * Prior to v1.5, the DST gap behaviour was also not defined.\n *\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n * @return the millisecond offset to subtract from local time to get UTC time\n */\npublic int getOffsetFromLocal(long instantLocal) {\n    // first estimate: treat instantLocal as if it were UTC\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust and re\u2010calculate\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    // gap handling (spring\u2010forward)\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    // overlap handling (fall\u2010back) \u2013 pick the earlier instant (daylight time)\n    long prev = previousTransition(instantAdjusted);\n    if (prev < instantAdjusted) {\n        // offset just before the transition\n        int offsetBefore = getOffset(prev - 1L);\n        // offset just after the transition\n        int offsetAfter = getOffset(prev);\n        int overlap = offsetBefore - offsetAfter;\n        if (overlap > 0) {\n            long delta = instantAdjusted - prev;\n            if (delta < overlap) {\n                return offsetBefore;\n            }\n        }\n    }\n    // otherwise use the adjusted offset\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}