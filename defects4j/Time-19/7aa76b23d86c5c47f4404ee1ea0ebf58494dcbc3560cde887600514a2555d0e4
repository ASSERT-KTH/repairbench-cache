{
    "generation": "import org.joda.time.DateTimeConstants;\n\n// This method is part of the DateTimeZone class.\n// It relies on getOffset(long instantUTC), nextTransition(long instantUTC), previousTransition(long instantUTC)\n// which are abstract methods in DateTimeZone and implemented by concrete subclasses.\n// Assuming MILLIS_PER_HOUR constant is available, or can be defined.\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // Step 1: Initial estimate of the offset.\n        // offsetLocal is the offset if instantLocal were a UTC instant.\n        final int offsetLocal = getOffset(instantLocal);\n        // offsetAdjusted is the offset at the UTC time resulting from instantLocal minus offsetLocal.\n        // This often gives a good estimate for the standard offset in overlaps, or the after-gap offset in gaps.\n        final int offsetAdjusted = getOffset(instantLocal - offsetLocal);\n\n        // Step 2: Check for consistency (whether instantLocal - offsetAdjusted maps back to offsetAdjusted).\n        // This condition identifies DST gaps.\n        if (getOffset(instantLocal - offsetAdjusted) != offsetAdjusted) {\n            // instantLocal falls into a DST gap. The rule is to return the offset\n            // suitable for calculating an instant after the gap.\n            // offsetAdjusted already correctly represents this \"after-gap\" offset.\n            return offsetAdjusted;\n        }\n\n        // Step 3: If consistent, check for overlaps.\n        // The rule for overlaps is to favour daylight (summer) time, which means choosing\n        // the larger of the two possible valid offsets (resulting in an earlier UTC instant).\n        // A typical DST saving is one hour.\n        final int oneHour = DateTimeConstants.MILLIS_PER_HOUR; // Using Joda-Time constant\n\n        // Check if (offsetAdjusted + oneHour) is also a valid offset.\n        // This would be the case if offsetAdjusted is the standard offset and (offsetAdjusted + oneHour) is the daylight offset.\n        int testOffset = offsetAdjusted + oneHour;\n        if (getOffset(instantLocal - testOffset) == testOffset) {\n            return testOffset; // It's an overlap, and the larger (daylight) offset is valid. Choose it.\n        }\n\n        // Check if (offsetAdjusted - oneHour) is also a valid offset.\n        // This would be the case if offsetAdjusted is already the daylight offset and (offsetAdjusted - oneHour) is the standard offset.\n        testOffset = offsetAdjusted - oneHour;\n        if (getOffset(instantLocal - testOffset) == testOffset) {\n            // In this scenario, offsetAdjusted is the larger offset (daylight) and testOffset is the smaller (standard).\n            // The rule is to favour the larger offset, so we keep offsetAdjusted.\n            return offsetAdjusted;\n        }\n        \n        // No other consistent offset found. The initial offsetAdjusted is the correct one.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}