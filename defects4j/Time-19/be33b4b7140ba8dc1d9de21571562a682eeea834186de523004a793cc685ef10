{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // First estimate of the offset based on interpreting instantLocal as UTC\n    final int offsetLocal = getOffset(instantLocal);\n    // Adjust the instant by that offset and recalc\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    // If the two offsets differ, we're at a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // DST gap (clocks forward): favour the later (offsetLocal)\n        if (offsetLocal < offsetAdjusted) {\n            long nextLocal    = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n        // DST overlap (clocks backward): favour the larger offset (daylight)\n        return Math.max(offsetLocal, offsetAdjusted);\n    }\n\n    // No change in offset \u2013 but there may be an overlap (repeated hour)\n    long prev = previousTransition(instantAdjusted);\n    if (prev < instantAdjusted) {\n        int offsetBefore = getOffset(prev - 1);\n        int offsetAfter  = offsetAdjusted;\n        // If a backward shift occurred here, check whether instantLocal\n        // lies in the ambiguous (overlap) range\n        if (offsetBefore > offsetAfter) {\n            long startLocal = prev + offsetAfter;\n            long endLocal   = prev + offsetBefore;\n            if (instantLocal >= startLocal && instantLocal < endLocal) {\n                // In the repeated hour: choose the earlier (daylight) offset\n                return offsetBefore;\n            }\n        }\n    }\n\n    // Normal case\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}