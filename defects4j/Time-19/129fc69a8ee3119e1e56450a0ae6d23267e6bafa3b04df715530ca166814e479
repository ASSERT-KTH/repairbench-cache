{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate assumes UTC or std offset)\n        // NOTE: instantLocal is treated as a UTC instant for the first guess.\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        // instantAdjusted is potentially the correct UTC instant, calculated assuming offsetLocal was correct.\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // If the offsets differ, we are near a transition point.\n        if (offsetLocal != offsetAdjusted) {\n            // Determine the direction of the transition based on the offsets found.\n            // If offsetLocal > offsetAdjusted, it means the offset increased moving from instantAdjusted to instantLocal (a gap).\n            // Example: Gap (0 -> +1h). Transition T. instantLocal is after T, instantAdjusted is before T.\n            //          getOffset(instantLocal) = +1h (offsetAfter), getOffset(instantAdjusted) = 0 (offsetBefore). offsetLocal > offsetAdjusted.\n            // If offsetLocal < offsetAdjusted, it means the offset decreased moving from instantAdjusted to instantLocal (an overlap).\n            // Example: Overlap (+1h -> 0). Transition T. instantLocal is after T, instantAdjusted is before T.\n            //          getOffset(instantLocal) = 0 (offsetAfter), getOffset(instantAdjusted) = +1h (offsetBefore). offsetLocal < offsetAdjusted.\n\n            // Check the condition from the original code: (offsetLocal - offsetAdjusted) < 0\n            // This condition is true if offsetLocal < offsetAdjusted, which signifies an OVERLAP.\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                 // Overlap case: Offset decreased (e.g., +1h -> 0).\n                 // offsetLocal holds the offset *after* the transition (standard time).\n                 // offsetAdjusted holds the offset *before* the transition (daylight time).\n                 // Rule for overlaps: Always return the earlier offset (daylight savings time).\n                 return offsetAdjusted; // Return the 'before' offset (daylight)\n            } else {\n                 // Gap case: Offset increased (e.g., 0 -> +1h).\n                 // offsetLocal holds the offset *after* the transition.\n                 // offsetAdjusted holds the offset *before* the transition.\n                 // Rule for gaps: Return the offset *after* the transition to push the time forward.\n                 return offsetLocal; // Return the 'after' offset\n            }\n        }\n        // else: offsetLocal == offsetAdjusted.\n        // This could mean:\n        // 1. We are far from a transition.\n        // 2. We are in an overlap period, but the initial guess (instantLocal treated as UTC)\n        //    landed in the time range associated with the *later* (standard) offset.\n        // We need to check the previous transition explicitly to handle case 2.\n        else {\n            // Find the transition immediately preceding the adjusted instant (our best guess for the true UTC instant).\n            long prev = previousTransition(instantAdjusted);\n            // Ensure the transition occurred before the instant.\n            if (prev < instantAdjusted) {\n                // Get the offset values immediately before and after this previous transition.\n                int offsetBefore = getOffset(prev - 1);\n                int offsetAfter = getOffset(prev); // This should be equal to offsetAdjusted/offsetLocal.\n                // Check if there was an actual offset change at this transition.\n                if (offsetBefore != offsetAfter) {\n                    // Calculate the difference between the 'before' and 'after' offsets.\n                    int diff = offsetBefore - offsetAfter;\n                    // If diff > 0, it means the offset decreased (e.g., +1h -> 0), indicating an overlap transition.\n                    if (diff > 0) {\n                        // We've confirmed an overlap occurred at 'prev'.\n                        // Now check if the 'instantAdjusted' falls within the UTC time range\n                        // that corresponds to the ambiguous local time interval.\n                        // This UTC range starts at the transition time 'prev' and has a duration of 'diff'.\n                        // If instantAdjusted is within [prev, prev + diff), it represents an ambiguous local time.\n                        if (instantAdjusted - prev < diff) {\n                            // The instant is ambiguous due to an overlap.\n                            // Rule: Return the earlier offset (daylight savings time).\n                            return offsetBefore;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Default case: Return the offset determined after the adjustment.\n        // This is correct for:\n        // - Normal times (no recent transition).\n        // - The non-ambiguous standard time interpretation after an overlap period has fully passed\n        //   (i.e., instantAdjusted >= prev + diff).\n        // - Times just before a gap transition (where instantAdjusted < prev).\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}