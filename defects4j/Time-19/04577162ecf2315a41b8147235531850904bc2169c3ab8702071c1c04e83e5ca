{
    "generation": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else { // offsetLocal == offsetAdjusted, meaning the initial estimate seemed consistent\n            // This block handles cases where the initial simple check didn't reveal a discrepancy.\n            // This is where ambiguous times (overlaps) where the standard offset was initially picked, will land.\n            // According to the Javadoc, for overlaps, the earlier instant (favouring daylight time) should be returned.\n\n            // Check if 'instantLocal' could also map to a valid UTC time using a likely daylight saving offset.\n            // Assuming common DST saving is 1 hour (3600000ms).\n            int likelyDaylightOffset = offsetAdjusted + 3600000; // Candidate for daylight offset\n            long instantWithDaylightGuess = instantLocal - likelyDaylightOffset;\n            int actualOffsetForDaylightGuess = getOffset(instantWithDaylightGuess);\n\n            // If the daylight guess is valid (the UTC instant maps back to the daylight offset)\n            if (actualOffsetForDaylightGuess == likelyDaylightOffset) {\n                // This means 'instantLocal' maps to two valid UTC instants:\n                // 1. instantLocal - offsetAdjusted (standard time, later UTC instant)\n                // 2. instantLocal - likelyDaylightOffset (daylight time, earlier UTC instant)\n                // According to the rule \"return the earlier instant\" and \"favour daylight (summer) time\".\n                return likelyDaylightOffset;\n            }\n\n            // Fallback to the original logic for other specific overlap edge cases.\n            // This part was originally `else if (offsetLocal > 0)`.\n            // Since we are already in `else { // offsetLocal == offsetAdjusted }`,\n            // the `if (offsetLocal > 0)` is still the correct condition here.\n            if (offsetLocal > 0) {\n                long prev = previousTransition(instantAdjusted);\n                if (prev < instantAdjusted) {\n                    int offsetPrev = getOffset(prev);\n                    int diff = offsetPrev - offsetLocal;\n                    if (instantAdjusted - prev <= diff) {\n                        return offsetPrev;\n                    }\n                }\n            }\n        }\n        return offsetAdjusted;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}