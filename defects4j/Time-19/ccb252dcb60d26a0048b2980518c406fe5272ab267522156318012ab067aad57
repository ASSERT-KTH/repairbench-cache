{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset by guessing that 'instantLocal' isdey UTC\n        int guess = getOffset(instantLocal);\n        // adjust 'instantLocal' by the guess to get an estimate of the actual UTC\n        long guessUTC = instantLocal - guess;\n        int actualOffset = getOffset(guessUTC);\n    \n        // check if the guessed offset and the actual offset match\n        if (guess == actualOffset) {\n             // guess is correct, go with actualOffset\n\n             // If in an overlap period, ensure we are returning the daylight offset\n             // This occurs if we are in the second occurrence of an overlap D->S,\n             // and our calculation landed on the S offset.\n             long prevTrans = previousTransition(guessUTC);\n             if (prevTrans < guessUTC) {\n                 int offsetBefore = getOffset(prevTrans - 1);\n                 int offsetAt = getOffset(prevTrans); // Should equal actualOffset if this is the S case we need to fix\n                 if (offsetBefore > offsetAt) { // Check if it was a D->S transition\n                     long overlapDuration = offsetBefore - offsetAt;\n                     // Check if the estimated UTC instant falls within the UTC range corresponding\n                     // to the second occurrence of the duplicated local time.\n                     if (guessUTC >= prevTrans && guessUTC < (prevTrans + overlapDuration)) {\n                         // Ambiguous time, and we calculated the UTC/Offset for the *later* instant (Standard time S).\n                         // We need to return the offset for the *earlier* instant (Daylight time D).\n                         return offsetBefore; // Return D\n                     }\n                 }\n             }\n             return actualOffset; // Return the consistent offset found\n        }\n    \n        // guess was wrong, probably crossed a transition\n        // calculate the offset using the actual offset to get another estimate of the actual UTC\n        long secondGuessUTC = instantLocal - actualOffset;\n        int secondActualOffset = getOffset(secondGuessUTC);\n\n        // If the second guess differs from the first actual offset, it confirms a transition.\n        // The desired behavior is to return the offset related to the 'daylight' or 'summer' time.\n        // For gaps (S->D), return offset *after* gap (D).\n        // For overlaps (D->S), return offset for *earlier* instant (D).\n        // In both cases, this corresponds to the larger offset value.\n        if (actualOffset != secondActualOffset) {\n             return Math.max(actualOffset, secondActualOffset);\n        }\n\n        // If actualOffset == secondActualOffset, it implies the transition was handled correctly by the first adjustment.\n        // However, we still need the overlap check logic as above, applied to 'actualOffset' and 'guessUTC'.\n        // (Duplicating the overlap check from the 'if (guess == actualOffset)' block)\n        long prevTrans = previousTransition(guessUTC);\n        if (prevTrans < guessUTC) {\n            int offsetBefore = getOffset(prevTrans - 1);\n            int offsetAt = getOffset(prevTrans); // Should equal actualOffset if this is the S case\n            if (offsetBefore > offsetAt) { // Check if it was a D->S transition\n                long overlapDuration = offsetBefore - offsetAt;\n                if (guessUTC >= prevTrans && guessUTC < (prevTrans + overlapDuration)) {\n                     // Return D offset (offsetBefore) if overlap detected and we landed on S (actualOffset).\n                     // Note: This check might seem redundant if actualOffset == secondActualOffset,\n                     // but it covers edge cases where the initial guess was S during an overlap.\n                     if (actualOffset == offsetAt) { // Ensure we landed on S\n                         return offsetBefore;\n                     }\n                }\n            }\n        }\n\n        // Default case: return the offset from the first corrected estimate.\n        return actualOffset;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}