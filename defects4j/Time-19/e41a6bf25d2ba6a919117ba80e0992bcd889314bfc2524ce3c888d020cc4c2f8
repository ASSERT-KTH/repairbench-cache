{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // Determine if we are in a gap or overlap.\n            // For gaps, return offset AFTER gap.\n            // For overlaps, return offset BEFORE overlap (DST offset).\n\n            // If offsetLocal < offsetAdjusted, it implies a positive transition (Spring gap).\n            // Example: offsetLocal=0, offsetAdjusted=+1hr. Return offsetAdjusted (+1hr).\n            // If offsetLocal > offsetAdjusted, it implies a negative transition (Autumn overlap).\n            // Example: offsetLocal=+1hr, offsetAdjusted=0. Return offsetLocal (+1hr).\n            // Example: offsetLocal=0, offsetAdjusted=-1hr (unlikely TZ?). Return offsetLocal(0).\n            // In both gap and overlap cases, we want the offset corresponding to DST/summer time.\n            // Usually, the DST offset is the larger value (more positive or less negative).\n            // Exception: Chile 1990. DST offset was smaller (-4h) than standard (-3h).\n            // Joda Time policy is to favour summer time. This generally means the offset\n            // active BEFORE the autumn transition (overlap) or AFTER the spring transition (gap).\n\n            if (offsetLocal < offsetAdjusted) {\n                // Gap (e.g., 0 -> +1). offsetLocal is before, offsetAdjusted is after.\n                // Return the offset AFTER the gap.\n                return offsetAdjusted;\n            } else {\n                // Overlap (e.g., +1 -> 0). offsetLocal is after, offsetAdjusted is before? No.\n                // One of offsetLocal/offsetAdjusted is the DST offset (before), one is the standard offset (after).\n                // We need to return the DST offset (usually the larger one, active before the transition).\n                // If offsetLocal > offsetAdjusted, offsetLocal is likely DST, offsetAdjusted is Std. Return offsetLocal.\n                // If offsetLocal < offsetAdjusted (Chile case?), offsetLocal is Std, offsetAdjusted is DST. Return offsetAdjusted.\n                // The original code returned offsetAdjusted here, which was wrong for the London case (+1 > 0).\n                // We need the offset associated with the *earlier* instant, which is the DST offset.\n                // Let's check which offset applies to the earlier potential UTC instant.\n                long earlierUTC = instantLocal - Math.max(offsetLocal, offsetAdjusted);\n                if (getOffset(earlierUTC) == Math.max(offsetLocal, offsetAdjusted)) {\n                    return Math.max(offsetLocal, offsetAdjusted);\n                }\n                return Math.min(offsetLocal, offsetAdjusted); // Fallback if earlier instant check fails? Seems unlikely needed.\n                // Simpler approach based on policy: Return the offset active before the autumn transition (the larger one usually).\n                // return Math.max(offsetLocal, offsetAdjusted); // This works for London, needs checking for Chile.\n                // Let's stick to the logic: return offset BEFORE autumn transition, offset AFTER spring transition.\n                // If offsetLocal > offsetAdjusted --> Autumn overlap. Return offsetLocal (if it's the one before). Needs check.\n                // If offsetLocal < offsetAdjusted --> Spring gap. Return offsetAdjusted (the one after).\n                // The code in the 'if' block already handles the gap correctly by returning offsetAdjusted.\n                // For the 'else' block (overlap, offsetLocal > offsetAdjusted), we need the offset BEFORE the transition.\n                // Is offsetLocal or offsetAdjusted guaranteed to be the offset before?\n                // Let's reconsider the calculation:\n                // offsetLocal = getOffset(instantLocal); instantAdjusted = instantLocal - offsetLocal; offsetAdjusted = getOffset(instantAdjusted);\n                // If +1 -> 0 (London):\n                //   Assume getOffset(instantLocal=1:15) returns +1. offsetLocal=+1. instantAdjusted=0:15. offsetAdjusted=getOffset(0:15)=+1. (offsetLocal==offsetAdjusted -> goes to else block below)\n                //   Assume getOffset(instantLocal=1:15) returns 0. offsetLocal=0. instantAdjusted=1:15. offsetAdjusted=getOffset(1:15)=? (might return +1 or 0).\n                //     If offsetAdjusted = +1. Then offsetLocal(0) < offsetAdjusted(+1). Gap logic. Returns offsetAdjusted(+1). CORRECT for overlap rule (DST offset).\n                //     If offsetAdjusted = 0. Then offsetLocal(0) == offsetAdjusted(0). -> goes to else block below.\n                // So if the first check `offsetLocal != offsetAdjusted` triggers, it seems returning the larger offset works for both gap & overlap.\n                // Let's simplify to this, but it feels risky without confirming Chile edge case.\n                // return Math.max(offsetLocal, offsetAdjusted); // Covers both gap and overlap?\n                // Let's follow the original corrected logic which seemed more robust:\n                // Gap (offsetLocal < offsetAdjusted): return offsetAdjusted (offset after gap)\n                // Overlap (offsetLocal > offsetAdjusted): return offsetLocal (offset before transition - DST) - Assuming offsetLocal represents DST offset here.\n                // What if offsetLocal was Std and offsetAdjusted was DST? (offsetLocal < offsetAdjusted, but it's overlap?) Unlikely.\n                // The check (offsetLocal - offsetAdjusted) < 0 reliably identifies gaps (offset increases).\n                 if ((offsetLocal - offsetAdjusted) < 0) {\n                    // Gap: return offset AFTER gap\n                    return offsetAdjusted;\n                 } else {\n                    // Overlap: return offset BEFORE transition (DST offset)\n                    return offsetLocal;\n                 }\n            }\n        } else { // offsetLocal == offsetAdjusted\n            // Possibility 1: Not near a transition.\n            // Possibility 2: In an overlap, but calculation didn't show difference. (e.g., London case where offsetLocal=0, offsetAdjusted=0)\n            // We need to explicitly check for overlaps using previousTransition.\n            long prevTrans = previousTransition(instantAdjusted);\n            // Check if prevTrans is valid and occurred before instantAdjusted\n            if (prevTrans < instantAdjusted) {\n                int offsetPrev = getOffset(prevTrans); // Offset AFTER the transition at prevTrans\n                int offsetPrevPrev = getOffset(prevTrans - 1); // Offset BEFORE the transition at prevTrans\n                // Check if it was actually a transition where offset changed\n                if (offsetPrev != offsetPrevPrev) {\n                    // Check if it was an overlap transition (offset decreased, duration is positive)\n                    int duration = offsetPrevPrev - offsetPrev;\n                    if (duration > 0) {\n                        // Calculate the local time range of the overlap\n                        long localStart = prevTrans + offsetPrev;\n                        long localEnd = prevTrans + offsetPrevPrev; // which is localStart + duration\n                        // Check if the requested instantLocal falls within the overlap period (inclusive start, exclusive end)\n                        if (instantLocal >= localStart && instantLocal < localEnd) {\n                            // If yes, return the offset active BEFORE the transition (DST offset)\n                            return offsetPrevPrev;\n                        }\n                    }\n                }\n            }\n            // If no overlap detected, or not near a transition, return the consistent offset found.\n            return offsetAdjusted;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}