{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // if the offsets differ, we must be near a DST boundary\n        // This block handles gaps (spring forward) or specific overlap types.\n        if (offsetLocal != offsetAdjusted) {\n            // If (offsetLocal - offsetAdjusted) < 0, it means offsetLocal < offsetAdjusted.\n            // This is typical for an overlap where the initial guess picked the later (smaller) offset,\n            // but after adjustment, the earlier (larger) offset is found.\n            // Example: +2h -> +1h (overlap). `instantLocal` results in `offsetLocal=+1h`, `instantAdjusted` results in `offsetAdjusted=+2h`.\n            // Here (1h - 2h) < 0 is true. The rule is to favour the earlier (larger) offset.\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // Ensure time is after the DST gap. The javadoc implies returning an offset that moves the local time past the gap.\n                // In an overlap, we want to return the earlier instant (larger offset).\n                // The current code tries to find a transition, then returns `offsetLocal`.\n                // For an overlap, `offsetAdjusted` is typically the larger (earlier) offset in this scenario.\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetAdjusted; // Changed from offsetLocal: return the larger offset for earlier instant\n                }\n            }\n        } else if (offsetLocal == offsetAdjusted) { // Original: offsetLocal > 0. Changed to handle all consistent offsets.\n            // This block handles the case where offsetLocal and offsetAdjusted are the same.\n            // This occurs in normal periods or for overlaps where the initial guess (offsetLocal)\n            // landed on the later (standard time) side of the ambiguous period (e.g., London test).\n            // We must now check for the alternative (earlier/daylight saving) offset.\n            long prev = previousTransition(instantAdjusted);\n            // If there's a previous transition and `instantAdjusted` is after it.\n            if (prev < instantAdjusted) {\n                // Get the offset that was active *just before* this previous transition.\n                // This is typically the daylight saving offset (e.g., BST +1h).\n                int offsetPrev = getOffset(prev - 1); // Corrected to get offset *before* the transition.\n                int diff = offsetPrev - offsetLocal; // Difference between previous offset (e.g., +1h) and current offset (e.g., +0h).\n                \n                // If `instantAdjusted` is within the \"ambiguous zone\" relative to the previous transition,\n                // and the `diff` makes sense (e.g., 1 hour for typical DST).\n                // This `if` condition checks if the local time falls into the overlap window.\n                if (instantAdjusted - prev <= diff) {\n                    // This implies `instantLocal` is ambiguous and `offsetPrev` is the offset\n                    // corresponding to the earlier UTC instant (daylight saving time).\n                    return offsetPrev; // Return the daylight saving offset as per Javadoc rule.\n                }\n            }\n        }\n        return offsetAdjusted; // Default return for non-boundary or specific gap cases.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}