{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate, used only to guess approximate UTC)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // if the offsets differ, we must be near a DST boundary (usually a gap)\n        if (offsetLocal != offsetAdjusted) {\n            // If offsetLocal > offsetAdjusted, calculation crossed a gap backwards.\n            // The offset after the gap is offsetLocal.\n            // If offsetLocal < offsetAdjusted, calculation crossed a gap forwards.\n            // The offset after the gap is offsetAdjusted.\n            // The documentation requires returning the offset for the time AFTER the gap.\n            // The original code included a nextTransition check that could return offsetLocal\n            // when offsetLocal < offsetAdjusted, potentially violating the \"after gap\" rule.\n            // We simplify to always return the offset associated with the time after the gap.\n            if (offsetLocal > offsetAdjusted) {\n                return offsetLocal;\n            } else {\n                return offsetAdjusted;\n            }\n        }\n\n        // else: offsetLocal == offsetAdjusted\n        // This handles non-transition times AND overlaps where the calculation lands consistently.\n        // We need to check if this consistent offset corresponds to the *later* time in an overlap.\n        // If so, we must return the *earlier* offset (summer time).\n\n        // Find the previous transition event before the estimated UTC instant.\n        long prevTransition = previousTransition(instantAdjusted);\n        if (prevTransition < instantAdjusted) {\n            // Get the offset value that was effective *just before* that transition.\n            int offsetBeforePrev = getOffset(prevTransition - 1);\n            // Check if the offset decreased at this transition (indicating an overlap).\n            // offsetAdjusted is the offset *after* the transition.\n            if (offsetBeforePrev > offsetAdjusted) {\n                // This was an overlap transition. Calculate its duration.\n                int overlapDuration = offsetBeforePrev - offsetAdjusted;\n                // Check if the estimated UTC instant falls within the ambiguous period\n                // (i.e., within overlapDuration millis after the transition).\n                if (instantAdjusted - prevTransition <= overlapDuration) {\n                    // Yes, the calculated instant corresponds to the later mapping\n                    // of the ambiguous local time. Return the earlier offset.\n                    return offsetBeforePrev;\n                }\n            }\n        }\n\n        // Default case: No transition, or gap handled above, or overlap resolved correctly by initial calculation.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}