{
    "generation": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            } else { // This is an overlap where offsetLocal (summer) > offsetAdjusted (standard)\n                     // If the initial estimate was the summer offset, but the adjusted estimate\n                     // lands on the standard offset, it means the local time is ambiguous.\n                     // The rule is to favour daylight (summer) time.\n                return offsetLocal;\n            }\n        } else if (offsetLocal == offsetAdjusted) { // This block handles cases where the initial estimates are the same,\n                                                    // but the time might still be ambiguous (e.g., London 01:15 in fall-back).\n                                                    // The original `offsetLocal > 0` condition was too restrictive.\n            long prev = previousTransition(instantAdjusted); // The UTC instant of the previous transition\n            if (prev != -1) { // If there is a previous transition (not a fixed offset zone)\n                int offsetBeforePrev = getOffset(prev - 1); // Offset just before the transition (e.g., summer time)\n                int offsetAfterPrev = getOffset(prev);     // Offset at or after the transition (e.g., standard time)\n\n                // If this is a fall-back transition (summer to standard), it creates an overlap\n                if (offsetBeforePrev > offsetAfterPrev) {\n                    // Define the local time range that is ambiguous during this overlap.\n                    // L_overlap_start is the local time of the transition using the offset before the transition.\n                    // For London (BST to GMT): 02:00 BST -> 01:00 GMT. The ambiguous hour is 01:00 to 01:59.\n                    // UTC transition is at 00:00 UTC (which is 01:00 BST).\n                    // So, L_overlap_start = prev + offsetBeforePrev (00:00 UTC + 01:00 = 01:00 BST local)\n                    long localOverlapStart = prev + offsetBeforePrev;\n                    \n                    // L_overlap_end is the local time of the transition using the offset after the transition,\n                    // plus the duration of the offset change (the length of the repeated hour).\n                    // This is 00:00 UTC + 00:00 (GMT offset) + (01:00 - 00:00) duration = 02:00 GMT local.\n                    long localOverlapEnd = prev + offsetAfterPrev + (offsetBeforePrev - offsetAfterPrev);\n\n                    // If instantLocal falls within this ambiguous range, return the summer offset.\n                    if (instantLocal >= localOverlapStart && instantLocal < localOverlapEnd) {\n                        return offsetBeforePrev;\n                    }\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}