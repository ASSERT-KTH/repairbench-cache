{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// Assume globalPaxHeaders is a field or accessible variable:\n// Map<String, String> globalPaxHeaders;\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    // Fix based on POSIX standard for PAX format:\n    // https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        // Use globalPaxHeaders if available, otherwise start fresh.\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n\n        OuterLoop:\n        while(true){\n            int ch;\n            int len = 0;\n            int read = 0; // bytes read for the current logical record line\n            final StringBuilder lenBuffer = new StringBuilder();\n\n            // 1. Read length field (decimal digits)\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' ') { // End of length field\n                    // If buffer is empty, it means line started with ' '. Invalid.\n                    if (lenBuffer.length() == 0) {\n                        throw new IOException(\"Invalid PAX header format: Line starts with space.\");\n                    }\n                    break; // Length field successfully read, break inner loop\n                } else if (ch >= '0' && ch <= '9') {\n                    lenBuffer.append((char)ch);\n                    // Check for potential integer overflow? PAX spec doesn't mention limit,\n                    // but practically, lengths are file sizes or metadata. Assume fits in int for now.\n                    if (lenBuffer.length() > 9) { // Protection against excessively long length field\n                         try {\n                             Integer.parseInt(lenBuffer.substring(0, 9)); // Check first 9 digits\n                         } catch (final NumberFormatException e) {\n                             // Should not happen if digits, but helps detect issues early.\n                             throw new IOException(\"Invalid PAX header length: \" + lenBuffer.toString(), e);\n                         }\n                    }\n                } else {\n                    // Encountered a non-digit, non-space character.\n                    // If we haven't read any digits yet, it might be a blank line or end of PAX block.\n                    if (lenBuffer.length() == 0) {\n                        if (ch == '\\n') {\n                            // Treat as blank line, skip and continue with the next line.\n                            continue OuterLoop;\n                        }\n                        // Any other non-digit character at the start means this is not a\n                        // valid PAX header line. Assume end of PAX headers.\n                        // We consumed 'ch', which might belong to the next tar entry.\n                        // This parsing logic assumes it's called only when expecting PAX headers.\n                        // If a non-PAX line is found, stop parsing here.\n                        break OuterLoop; // Non-PAX line encountered\n                    } else {\n                        // Had digits, but then encountered non-space/non-digit before space. Invalid format.\n                        throw new IOException(\"Invalid PAX header format. Encountered character '\" + (char)ch\n                                              + \"' (\"+ch+\") after reading digits for length.\");\n                    }\n                }\n            }\n\n            // Check why the inner loop terminated\n            if (ch == -1) { // EOF encountered\n                // If we were reading digits, it's unexpected EOF.\n                if (lenBuffer.length() > 0) {\n                    throw new IOException(\"Invalid PAX header: Unexpected EOF while reading length.\");\n                }\n                // If buffer is empty, it means EOF occurred at the start of a line (or after a blank line).\n                // This is a valid end of headers.\n                break OuterLoop;\n            }\n\n            // If we are here, the inner loop broke because ch == ' '.\n            // Parse the length string.\n            try {\n                len = Integer.parseInt(lenBuffer.toString());\n            } catch (final NumberFormatException e) {\n                throw new IOException(\"Invalid PAX header length: '\" + lenBuffer.toString() + \"'\", e);\n            }\n            // POSIX: \"The length field shall be the number of octets in the record,\n            // including the trailing <newline>.\" Length must cover itself + space + key=value + newline.\n            // Smallest possible length seems to be 5 for \"5 k=\\n\".\n            if (len < 5) {\n                throw new IOException(\"Invalid PAX header length: \" + len + \" < 5\");\n            }\n\n\n            // 2. Read the rest of the record (keyword=value\\n)\n            // Bytes remaining = total length - bytes already read (length digits + space)\n            final int headerDataLen = len - read;\n            if (headerDataLen < 0) {\n                // This implies len was smaller than the number of bytes read for the length field + space,\n                // which shouldn't happen if the format is correct.\n                 throw new IOException(\"Invalid PAX header length calculation (len=\" + len + \", read=\" + read + \")\");\n            }\n\n            final byte[] headerData = new byte[headerDataLen];\n            final int got = IOUtils.readFully(i, headerData);\n            if (got != headerDataLen) {\n                 throw new IOException(\"Failed to read PAX header data. Expected \" + headerDataLen\n                                        + \" bytes, read \" + got);\n            }\n\n            // POSIX: \"The record shall be terminated by a single <newline> character.\"\n            if (headerDataLen == 0 || headerData[headerDataLen - 1] != '\\n') {\n                 // headerDataLen == 0 check is redundant due to len < 5 check earlier.\n                throw new IOException(\"Invalid PAX header format: Record does not end with newline character.\");\n            }\n\n            // 3. Parse \"keyword=value\" from headerData (excluding trailing '\\n')\n            int eqPos = -1;\n            for (int j = 0; j < headerDataLen - 1; j++) { // Scan up to byte before '\\n'\n                if (headerData[j] == '=') {\n                    eqPos = j;\n                    break;\n                }\n                // POSIX: \"The keyword shall not contain an equals sign.\"\n            }\n\n            // POSIX: \"There shall be one equals sign separating the keyword and value\"\n            // eqPos == 0 means empty keyword. eqPos == -1 means no '=' found. Both invalid.\n            if (eqPos < 1) {\n                throw new IOException(\"Invalid PAX header format: No '=' separator or empty keyword found in record.\");\n            }\n\n            final String keyword = new String(headerData, 0, eqPos, CharsetNames.UTF_8);\n\n            // Value is from after '=' to before '\\n'\n            final int valueLen = headerDataLen - eqPos - 2; // length of bytes between '=' and '\\n'\n            // valueLen can be 0 for \"k=\\n\"\n\n            final String value = new String(headerData, eqPos + 1, valueLen, CharsetNames.UTF_8);\n\n            // POSIX: \"If the value field is zero length, it shall delete any header block entry for this keyword\"\n            if (valueLen == 0) {\n                headers.remove(keyword);\n            } else {\n                headers.put(keyword, value);\n            }\n            // Finished processing this record, continue outer loop for the next one.\n        }\n\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}