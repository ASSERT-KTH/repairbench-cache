{
    "generation": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        // The 'length' field specifies the number of bytes in the remainder of the header record\n        // (including the newline).\n\n        while(true){ // Loop to parse each pax header line\n            int ch;\n            int len = 0; // This will store the value of the 'length' field (length of 'keyword=value\\n')\n            int read = 0; // total bytes read for the current line from the stream so far\n\n            // 1. Read 'length' digits and the following space\n            // This loop parses the \"length \" prefix.\n            int firstChar = i.read(); // Read the very first character of the line\n            if (firstChar == -1) { // EOF or empty stream\n                break; // No more headers\n            }\n            read++; // Count the first char\n\n            // Check if first char is a digit\n            if (firstChar < '0' || firstChar > '9') {\n                // If the first character is not a digit, it's not a valid pax header line format.\n                // This often signifies the end of the pax header block or a malformed line (like a blank line \"\\n\").\n                // To \"survive blank lines\" and other malformed entries, consume the rest of this line and continue\n                // to the next potential header line.\n                while (firstChar != -1 && firstChar != '\\n') {\n                    firstChar = i.read();\n                }\n                if (firstChar == -1) { // EOF while consuming the rest of the bad line\n                    break;\n                }\n                continue; // Skip this malformed/blank line, go to the next potential header\n            }\n\n            len = firstChar - '0'; // First digit of length\n\n            // Continue parsing remaining digits until a space is found\n            while((ch = i.read()) != -1) {\n                read++; // Accumulate total bytes read for this line\n                if (ch == ' '){\n                    break; // End of the length digits and space\n                }\n                if (ch < '0' || ch > '9') {\n                    // Non-digit character inside the length field. This indicates a malformed header line.\n                    // Consume the rest of the line and skip to the next potential header.\n                    while (ch != -1 && ch != '\\n') {\n                        ch = i.read();\n                    }\n                    if (ch == -1) { // EOF while consuming the rest of the bad line\n                        break; // Break the outer loop (no more headers)\n                    }\n                    continue; // Skip this malformed line, go to the next potential header\n                }\n                len = len * 10 + (ch - '0');\n            }\n\n            if (ch == -1) { // EOF while parsing length digits or the trailing space\n                break; // No more headers\n            }\n\n            // At this point, `len` holds the declared length of the \"keyword=value\\n\" part.\n            // `read` holds the count of bytes already consumed for the \"length \" prefix.\n            // Let's store this value, as it marks the beginning of the \"keyword=value\\n\" block.\n            final int initialReadForLengthPrefix = read;\n\n            // 2. Read 'keyword' and '='\n            final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n            boolean foundEquals = false;\n            \n            // The loop for keyword should not read beyond `len` bytes for the \"keyword=value\\n\" part.\n            // The maximum `read` for the entire line should be `initialReadForLengthPrefix + len`.\n            while(read < initialReadForLengthPrefix + len && (ch = i.read()) != -1) {\n                read++; // Accumulate total bytes read for this line\n                if (ch == '='){ // end of keyword\n                    foundEquals = true;\n                    break;\n                }\n                coll.write((byte) ch);\n            }\n\n            if (ch == -1 && read < initialReadForLengthPrefix + len) {\n                // Unexpected EOF mid-line, before the expected total bytes for `keyword=value\\n` were consumed.\n                throw new IOException(\"Unexpected EOF while parsing pax header. Expected \"\n                                      + (initialReadForLengthPrefix + len) + \" bytes total, but only read \" + read);\n            }\n\n            final String keyword = coll.toString(CharsetNames.UTF_8);\n            // `len` is the declared length of \"keyword=value\\n\".\n            // `(read - initialReadForLengthPrefix)` is the number of bytes consumed *from* the \"keyword=value\\n\" part\n            // (i.e., `length(\"keyword=\")`, or `length(\"keyword\")` if no '=' was found).\n            // The remaining bytes for `value\\n` is `len - (bytes_consumed_from_keyword_value_part)`.\n            final int restLen = len - (read - initialReadForLengthPrefix);\n\n            if (foundEquals) {\n                // Normal case: \"keyword=value\\n\" was found (or \"keyword=\\n\")\n                if (restLen == 1) { // Only NL left, meaning value is empty (e.g., `keyword=\\n`)\n                    headers.remove(keyword); // Remove this header entry\n                } else if (restLen > 1) { // `value` and `\\n` are present\n                    final byte[] rest = new byte[restLen];\n                    final int got = IOUtils.readFully(i, rest);\n                    read += got; // Account for bytes read for value from the stream\n                    if (got != restLen) {\n                        throw new IOException(\"Failed to read Paxheader value. Expected \"\n                                              + restLen + \" bytes, but read \" + got);\n                    }\n                    // Drop trailing NL from the value string\n                    final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                    headers.put(keyword, value);\n                } else { // restLen <= 0. This implies that the entire `keyword=value\\n` part was consumed\n                         // by `keyword=` and no bytes are left for `value` or `\\n`.\n                         // If `foundEquals` is true and `restLen` is 0, it means the line ended with `=`.\n                         // e.g., `10 key=` where `len` was 3. The value is implicitly empty.\n                    headers.put(keyword, \"\");\n                }\n            } else {\n                // `foundEquals` is false. No '=' was found within the `len` bytes for \"keyword=value\\n\".\n                // This implies that `(read - initialReadForLengthPrefix)` already consumed `len` bytes.\n                // So `restLen` must be 0.\n                // This means the line was like \"length keyword\\n\" or \"length \\n\" (malformed according to strict spec).\n                // The `keyword` from `coll` might contain unexpected characters or the newline.\n                // Per \"survive blank lines\", we add it as a key with an empty value, trimming the keyword.\n                headers.put(keyword.trim(), \"\");\n            }\n        }\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}