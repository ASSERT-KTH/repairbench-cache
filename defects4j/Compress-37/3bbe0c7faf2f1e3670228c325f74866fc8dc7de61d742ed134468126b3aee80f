{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Assuming CharsetNames and IOUtils are available in the context.\n// For a standalone fix, these would need to be provided or imported.\n// import org.apache.commons.compress.utils.CharsetNames;\n// import org.apache.commons.compress.utils.IOUtils;\n\nclass CharsetNames {\n    public static final String UTF_8 = \"UTF-8\";\n}\n\nclass IOUtils {\n    // Simplified version for context. Real IOUtils.readFully handles EOF differently.\n    public static int readFully(InputStream in, byte[] b) throws IOException {\n        return readFully(in, b, 0, b.length);\n    }\n\n    public static int readFully(InputStream in, byte[] b, int off, int len) throws IOException {\n        if (len < 0) {\n            throw new IndexOutOfBoundsException(\"len is negative\");\n        }\n        int n = 0;\n        while (n < len) {\n            int count = in.read(b, off + n, len - n);\n            if (count < 0) {\n                // If EOF is reached before reading 'len' bytes, return what was read.\n                // The caller will check if 'got != expected'.\n                return n;\n            }\n            n += count;\n        }\n        return n;\n    }\n}\n\n\n// The original code was part of TarArchiveInputStream.\n// This fix assumes globalPaxHeaders is a field accessible by this function.\n// For the purpose of providing only the function, we'll assume its existence or\n// provide a dummy one if it helps compilation.\n// Map<String, String> globalPaxHeaders; // Placeholder if not in scope\n\n// Placeholder for globalPaxHeaders if it's not defined in the provided snippet\n// In the actual Apache Commons Compress library, this is a field in TarArchiveInputStream.\n// private final Map<String, String> globalPaxHeaders = new HashMap<>(); // For testing purposes\n\npublic class TarArchiveInputStream_Fixed { // Class name for compilation purposes\n\n    // Assuming globalPaxHeaders is a field accessible by this function.\n    // For this context, we will use a dummy static map.\n    private static final Map<String, String> globalPaxHeaders = new HashMap<>();\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){\n            int ch;\n            int len = 0;\n            int bytesReadForPrefix = 0; // Tracks bytes read for the \"length \" part of the line\n\n            // 1. Read length digits and the following space\n            while((ch = i.read()) != -1) {\n                bytesReadForPrefix++;\n                if (ch == ' '){ // End of length digits\n                    break;\n                }\n                // Check if char is a digit to ensure valid format\n                if (ch < '0' || ch > '9') {\n                    // Malformed header: expected digit or space. Consume remainder of line and skip.\n                    // To consume the rest of the line, we could read until '\\n' or EOF.\n                    // For now, we will throw as it's a clear format violation.\n                    throw new IOException(\"Invalid PAX header. Expected digit or space, got: \" + (char)ch + \" at position \" + bytesReadForPrefix);\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF while reading length, means no more headers\n                break;\n            }\n\n            // At this point:\n            // 'len' holds the total length of the line as specified (e.g., 27 for \"27 ctime=...\")\n            // 'bytesReadForPrefix' holds the count of digits + 1 (for the space)\n\n            // Calculate how many bytes are left to read for \"keyword=value\\n\"\n            final int remainingBytesToRead = len - bytesReadForPrefix;\n\n            if (remainingBytesToRead < 0) {\n                // Malformed PAX header: stated length is less than the bytes already read for the prefix itself.\n                // This indicates a corrupt header entry.\n                throw new IOException(\"Invalid PAX header. Stated length \" + len +\n                                      \" is less than bytes already read for prefix: \" + bytesReadForPrefix);\n            }\n            \n            if (remainingBytesToRead == 0) {\n                // This means the line ends right after the \"length \" part, which is not \"keyword=value\\n\".\n                // This implies a malformed or empty header line like \"X \".\n                // Per COMPRESS-355, \"blank lines\" should be handled gracefully, likely by skipping.\n                continue; \n            }\n\n            // Read the rest of the line (keyword=value\\n) into a buffer\n            final byte[] lineRemainder = new byte[remainingBytesToRead];\n            final int got = IOUtils.readFully(i, lineRemainder);\n            if (got != remainingBytesToRead) {\n                // This indicates an unexpected EOF or stream issue before reading the full declared length.\n                throw new IOException(\"Failed to read Paxheader. Expected \"\n                                      + remainingBytesToRead\n                                      + \" bytes, read \"\n                                      + got + \" for line remainder.\");\n            }\n\n            // Now parse the lineRemainder buffer (keyword=value\\n)\n            int keywordEnd = -1; // Index of '='\n            int valueEnd = -1;   // Index of '\\n'\n\n            for (int k = 0; k < remainingBytesToRead; k++) {\n                if (lineRemainder[k] == '=' && keywordEnd == -1) {\n                    keywordEnd = k;\n                } else if (lineRemainder[k] == '\\n') {\n                    valueEnd = k;\n                    break; // Found newline, done scanning lineRemainder\n                }\n            }\n\n            // Validate the parsed line remainder: must contain '=' and '\\n' at the end.\n            if (keywordEnd == -1 || valueEnd == -1 || valueEnd != remainingBytesToRead - 1) {\n                // Malformed lineRemainder: missing '=' or missing '\\n' at the very end.\n                // This covers cases like \"3 \\n\" where '=' is absent.\n                // These lines don't conform to the \"keyword=value\\n\" format and should be skipped.\n                continue;\n            }\n\n            final String keyword = new String(lineRemainder, 0, keywordEnd, CharsetNames.UTF_8);\n            // The value starts after '=' (keywordEnd + 1) and ends before '\\n' (valueEnd).\n            final String value = new String(lineRemainder, keywordEnd + 1, valueEnd - (keywordEnd + 1), CharsetNames.UTF_8);\n\n            // According to the specification, if value is an empty string, the variable is unset.\n            if (value.isEmpty()){\n                headers.remove(keyword);\n            } else {\n                headers.put(keyword, value);\n            }\n        }\n        return headers;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}