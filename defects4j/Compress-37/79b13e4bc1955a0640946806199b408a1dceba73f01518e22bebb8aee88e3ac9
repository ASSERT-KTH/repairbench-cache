{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// The surrounding class structure is assumed to provide globalPaxHeaders\n// and the necessary imports (like the example below).\n// class SomeTarClass {\n//    private Map<String, String> globalPaxHeaders = new HashMap<>();\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    /**\n     * Parses PAX header records from the given stream until EOF is reached.\n     *\n     * <p>The format is \"%d %s=%s\\n\" where %d is the total length of the record\n     * including the length field itself, the space, keyword, '=', value, and newline.</p>\n     *\n     * <p>Blank lines (containing only a newline) or lines with leading whitespace\n     * before the length field are skipped.</p>\n     *\n     * @param i The stream to read PAX header records from.\n     * @return A map of keyword/value pairs found in the headers.\n     * @throws IOException If an I/O error occurs, or if the header format is invalid\n     *                     (e.g., malformed length, premature EOF, missing separators,\n     *                     length mismatch, value not ending in newline).\n     */\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        // Initialize with global headers, which may be overridden or removed by local headers.\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n\n        while (true) { // Outer loop continues until EOF or header sequence end\n            int ch;\n            int len = 0;\n            int lenDigits = 0;\n\n            // Skip leading non-digits (e.g., newlines/blank lines).\n            // Breaks on first digit or EOF.\n            while ((ch = i.read()) != -1 && (ch < '0' || ch > '9')) {\n                // skip\n            }\n\n            if (ch == -1) { // EOF found while skipping, indicates end of headers.\n                break;\n            }\n\n            // First digit found, initialize length.\n            len = ch - '0';\n            lenDigits = 1;\n\n            // Read subsequent digits of the length field.\n            while ((ch = i.read()) != -1) {\n                if (ch == ' ') {\n                    // Found the space separator, end of length field.\n                    break;\n                }\n                if (ch < '0' || ch > '9') {\n                    // Invalid character encountered after digits but before space.\n                    throw new IOException(\"Malformed PAX header: invalid character \" + (char) ch + \" found in length field.\");\n                }\n\n                // Accumulate length, checking for integer overflow.\n                // Use long arithmetic for intermediate check to avoid overflow during check itself.\n                long nextLen = ((long) len * 10) + (ch - '0');\n                if (nextLen > Integer.MAX_VALUE) {\n                     throw new IOException(\"Paxheader length is too long: \" + len + Character.toString((char) ch) + \"...\");\n                }\n                len = (int) nextLen;\n                lenDigits++;\n            }\n\n            // Check if EOF was reached before finding the space separator.\n            if (ch == -1) {\n                throw new IOException(\"Malformed PAX header: Unexpected EOF while reading length digits.\");\n            }\n            // At this point, ch must be ' '.\n\n            // Basic sanity check: the length must be sufficient to accommodate the minimum record structure.\n            // Minimum record: \"5 k=\\n\" (length=5, digits=1). Structure: lenDigits + ' ' + keyword(1+) + '=' + value(0+) + '\\n'\n            // Smallest possible length value is lenDigits + 4 (1 digit len, 1 char key, empty val).\n            final int minLen = lenDigits + 4;\n            if (len < minLen) {\n                 throw new IOException(\"Malformed PAX header: Length \" + len + \" is too small for measured digits \" + lenDigits + \" (min=\" + minLen + \")\");\n            }\n\n            // Account for bytes read so far: length digits + 1 space.\n            int read = lenDigits + 1;\n\n            // Read the keyword field up to the '=' separator.\n            final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n            while ((ch = i.read()) != -1) {\n                read++; // Increment bytes read for this record.\n                if (ch == '=') {\n                    // Found the '=' separator, end of keyword.\n                    break;\n                }\n                // Check if reading past the declared length 'len'. Protects against NegativeArraySizeException later.\n                if (read >= len) {\n                     throw new IOException(\"Malformed PAX header: Hit declared length (\" + len + \") before finding '=' separator.\");\n                }\n                coll.write((byte) ch);\n            }\n\n            // Check if EOF was reached or loop terminated before finding '='.\n            if (ch != '=') {\n                throw new IOException(\"Malformed PAX header: Expected '=' separator but found EOF or invalid character.\");\n            }\n\n            // Extract keyword, ensure it's not empty.\n            final String keyword = coll.toString(CharsetNames.UTF_8);\n            if (keyword.isEmpty()) {\n                throw new IOException(\"Malformed PAX header: Empty keyword found.\");\n            }\n\n            // Calculate the length of the remaining part (\"value\\n\").\n            // This must be at least 1 for the trailing newline.\n            final int restLen = len - read;\n            if (restLen < 1) {\n                 // This implies read >= len, which should have been caught earlier, but double check.\n                 throw new IOException(\"Malformed PAX header: Calculated value length is negative or zero (\" + restLen + \")\");\n            }\n\n            // Read the \"value\\n\" part fully.\n            final byte[] rest = new byte[restLen];\n            final int got = IOUtils.readFully(i, rest);\n            // Check if the expected number of bytes was actually read.\n            if (got != restLen) {\n                // This indicates an unexpected EOF or short read from the input stream.\n                throw new IOException(\"Failed to read Paxheader value. Expected \"\n                                      + restLen\n                                      + \" bytes, but only read \"\n                                      + got + \" bytes.\");\n            }\n\n            // Verify that the last byte of the record is a newline.\n            if (rest[restLen - 1] != '\\n') {\n                 throw new IOException(\"Malformed PAX header: Record does not end with a newline character.\");\n            }\n\n            // Process the entry: store keyword/value or remove keyword if value is empty.\n            if (restLen == 1) { // Only newline was present (\"keyword=\\n\") => delete keyword.\n                headers.remove(keyword);\n            } else {\n                // Extract the value string (excluding the trailing newline).\n                final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n                headers.put(keyword, value);\n            }\n            // Successfully processed one record, loop back to find the next one.\n        }\n\n        // EOF reached after skipping non-digits or after processing the last record.\n        return headers;\n    }\n\n// } // End of assumed surrounding class",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}