{
    "generation": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Each record is \"length keyword=value\\n\". We skip blank lines.\n    for (;;) {\n        int b = i.read();\n        if (b == -1) {\n            break;                // end of extended header stream\n        }\n        if (b == '\\n') {\n            continue;             // skip blank lines\n        }\n        // First byte of length must be a digit\n        if (b < '0' || b > '9') {\n            // skip until end of this line\n            while (b != -1 && b != '\\n') {\n                b = i.read();\n            }\n            continue;\n        }\n        // Parse the length field\n        int len = b - '0';\n        int read = 1;             // we've consumed one byte of the length\n        while ((b = i.read()) != -1 && b != ' ') {\n            if (b < '0' || b > '9') {\n                throw new IOException(\"Invalid PAX header length\");\n            }\n            len = len * 10 + (b - '0');\n            read++;\n        }\n        if (b == -1) {\n            break;\n        }\n        read++;                    // count the space\n\n        // Read the keyword up to '='\n        final ByteArrayOutputStream keyBuf = new ByteArrayOutputStream();\n        while ((b = i.read()) != -1 && b != '=') {\n            keyBuf.write(b);\n            read++;\n        }\n        if (b == -1) {\n            break;\n        }\n        read++;                    // count the '='\n        final String key = keyBuf.toString(CharsetNames.UTF_8);\n\n        // Remaining bytes (value + trailing newline)\n        final int rest = len - read;\n        if (rest < 0) {\n            throw new IOException(\"Invalid PAX header length \" + len\n                                  + \" is less than header name length \" + read);\n        }\n        if (rest == 1) {\n            // only a newline => remove this key\n            if (i.read() == -1) {\n                throw new IOException(\"Unexpected EOF reading PAX header\");\n            }\n            headers.remove(key);\n        } else {\n            final byte[] data = new byte[rest];\n            int got = IOUtils.readFully(i, data);\n            if (got != rest) {\n                throw new IOException(\"Failed to read Paxheader. Expected \"\n                                      + rest + \" bytes, read \" + got);\n            }\n            // drop the trailing newline\n            final String value = new String(data, 0, rest - 1, CharsetNames.UTF_8);\n            headers.put(key, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}