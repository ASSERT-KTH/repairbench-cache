{
    "generation": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// The user requested only the function. Imports might be needed depending on the context.\n// Also assumes 'globalPaxHeaders' is accessible in the scope where this function is defined (e.g., a member variable).\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    // POSIX standard: https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        // Assume globalPaxHeaders is accessible (e.g., member variable `this.globalPaxHeaders`)\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"<length> <keyword>=<value>\\n\"\n        while(true) {\n            int ch;\n            int len = 0;\n            int lenFieldBytes = 0; // Track bytes read for the length field + space\n            boolean readDigit = false; // Ensure at least one digit is read for length\n\n            // 1. Read decimal length field until space\n            while((ch = i.read()) != -1) {\n                lenFieldBytes++;\n                if (ch == ' ') { // End of length field\n                    // Check if we actually read any digits before the space.\n                    if (!readDigit) {\n                        throw new IOException(\"Invalid PAX header format: Missing length digits before space\");\n                    }\n                    break; // Found space, length field parsed.\n                }\n                // Check if the character is a digit '0'-'9'\n                if (ch < '0' || ch > '9') {\n                    // Handle unexpected non-digit character.\n                    // Check for NUL padding at the beginning of a potential record, which signals the end of headers.\n                    if (lenFieldBytes == 1 && ch == 0) {\n                        // Treat NUL as EOF for the purpose of ending the header parsing loop.\n                        ch = -1;\n                        break; // Exit length parsing loop\n                    }\n                    // Otherwise, it's a format violation.\n                    throw new IOException(\"Invalid PAX header format: Non-digit character '\" + (char) ch + \"' (\" + ch + \") found in length field\");\n                }\n                // Accumulate the length value from digits.\n                readDigit = true;\n                int digit = ch - '0';\n                // Check for potential integer overflow before multiplication/addition.\n                if (len > (Integer.MAX_VALUE - digit) / 10) {\n                    throw new IOException(\"Paxheader length exceeds Integer.MAX_VALUE\");\n                }\n                len = len * 10 + digit;\n            }\n\n            // Check why the length parsing loop ended.\n            if (ch == -1) {\n                // EOF was reached.\n                // If it was triggered by NUL padding (lenFieldBytes == 1, !readDigit), normal termination.\n                if (lenFieldBytes == 1 && !readDigit) {\n                     break; // Normal termination due to NUL padding.\n                }\n                // If nothing was read (lenFieldBytes == 0), it's a clean EOF.\n                if (lenFieldBytes == 0) {\n                    break; // Normal termination, no more headers.\n                }\n                // Otherwise, EOF occurred unexpectedly while reading the length field.\n                throw new IOException(\"Unexpected EOF while reading Paxheader length\");\n            }\n\n            // Basic validation: length must be positive for a valid record.\n            if (len == 0) {\n                throw new IOException(\"Invalid PAX header format: Length is zero\");\n            }\n\n            // Calculate the number of bytes remaining for the record (keyword=value\\n).\n            // This is the total length 'len' minus the bytes read for the length field and space.\n            final int expectedRemainingBytes = len - lenFieldBytes;\n            // The total length must be greater than the length field itself.\n            if (expectedRemainingBytes < 0) {\n                throw new IOException(\"Invalid PAX header format: length \" + len + \" is too small for length field (\" + lenFieldBytes + \" bytes)\");\n            }\n            // The remaining part must contain at least a minimal keyword, '=', and '\\n'.\n            // Smallest possible valid remaining part is \"k=\\n\" (3 bytes).\n            // \"=\\n\" (2 bytes) would imply an empty keyword, which is invalid.\n            if (expectedRemainingBytes < 2) {\n                 throw new IOException(\"Invalid PAX header format: length \" + len + \" is too small for keyword, =, and newline (remaining bytes: \" + expectedRemainingBytes + \")\");\n            }\n\n            // 2. Read the exact number of remaining bytes for the record.\n            final byte[] remainingBytes = new byte[expectedRemainingBytes];\n            final int got = IOUtils.readFully(i, remainingBytes);\n            if (got != expectedRemainingBytes) {\n                // Check if EOF was hit prematurely.\n                throw new IOException(\"Failed to read Paxheader record. Expected \"\n                                      + expectedRemainingBytes + \" bytes, read \" + got);\n            }\n\n            // 3. Parse the buffer containing \"keyword=value\\n\".\n            // Check for the mandatory trailing newline character.\n            if (remainingBytes[expectedRemainingBytes - 1] != '\\n') {\n                 throw new IOException(\"Invalid PAX header format: Record does not end with newline\");\n            }\n\n            // Find the index of the '=' separator. It must exist and not be the first character.\n            int eqIndex = -1;\n            // Search only within the part before the trailing newline.\n            for (int k = 0; k < expectedRemainingBytes - 1; k++) {\n                 if (remainingBytes[k] == '=') {\n                     eqIndex = k;\n                     break;\n                 }\n            }\n\n            // Validate the position of '='.\n            if (eqIndex == -1) { // '=' not found.\n                 throw new IOException(\"Invalid PAX header format: Missing '=' separator in record\");\n            }\n            if (eqIndex == 0) { // Keyword cannot be empty (starts at index 0, ends before '=' at eqIndex).\n                 throw new IOException(\"Invalid PAX header format: Empty keyword found\");\n            }\n\n            // Extract the keyword (bytes before '=').\n            final String keyword = new String(remainingBytes, 0, eqIndex, CharsetNames.UTF_8);\n\n            // Calculate the length of the value part (bytes between '=' and '\\n').\n            // Value starts at index eqIndex + 1.\n            // Value ends at index expectedRemainingBytes - 2 (inclusive index of last value byte).\n            // Length = (last index) - (first index) + 1\n            // Length = (expectedRemainingBytes - 2) - (eqIndex + 1) + 1 = expectedRemainingBytes - eqIndex - 2.\n            final int valueLen = expectedRemainingBytes - eqIndex - 2;\n            // Value length must be non-negative.\n            if (valueLen < 0) {\n                 // This state should ideally not be reachable if previous checks passed.\n                 throw new IOException(\"Invalid PAX header format: Malformed value segment calculation resulted in negative length \" + valueLen);\n            }\n\n            // Per the POSIX standard, a record with a zero-length value deletes the header field.\n            if (valueLen == 0) {\n                 headers.remove(keyword);\n            } else {\n                // Extract the value string.\n                final String value = new String(remainingBytes, eqIndex + 1, valueLen, CharsetNames.UTF_8);\n                headers.put(keyword, value);\n            }\n        } // End outer while(true) loop for reading records\n\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}