{
    "generation": "Map<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) {\n        // Read and skip blank lines (CR/LF)\n        int c = i.read();\n        if (c == -1) {\n            break;\n        }\n        while (c == '\\n' || c == '\\r') {\n            c = i.read();\n        }\n        if (c == -1) {\n            break;\n        }\n        // First non-blank must be a digit for length\n        if (c < '0' || c > '9') {\n            // skip to end of line\n            while (c != -1 && c != '\\n') {\n                c = i.read();\n            }\n            continue;\n        }\n        // Read length digits\n        StringBuilder lenBuf = new StringBuilder();\n        do {\n            lenBuf.append((char) c);\n            c = i.read();\n        } while (c != -1 && c >= '0' && c <= '9');\n        // Expect a space after length\n        if (c != ' ') {\n            // skip malformed line\n            while (c != -1 && c != '\\n') {\n                c = i.read();\n            }\n            continue;\n        }\n        int len;\n        try {\n            len = Integer.parseInt(lenBuf.toString());\n        } catch (NumberFormatException e) {\n            continue;\n        }\n        // Read the rest of the entry (len includes digits, space, data, newline)\n        int toRead = len - lenBuf.length() - 1;\n        if (toRead <= 0) {\n            // nothing to read or malformed; skip possible newline\n            if (toRead == 0) {\n                i.read();\n            }\n            continue;\n        }\n        byte[] entry = new byte[toRead];\n        int got = IOUtils.readFully(i, entry);\n        if (got != toRead) {\n            throw new IOException(\"Failed to read Paxheader. Expected \" + toRead + \" bytes, read \" + got);\n        }\n        // entry must end with newline\n        if (entry[toRead - 1] != '\\n') {\n            continue;\n        }\n        // Parse \"keyword=value\\n\"\n        int eq = -1;\n        for (int j = 0; j < toRead; j++) {\n            if (entry[j] == '=') {\n                eq = j;\n                break;\n            }\n        }\n        if (eq == -1) {\n            continue;\n        }\n        String keyword = new String(entry, 0, eq, CharsetNames.UTF_8);\n        if (eq + 1 == toRead - 1) {\n            // only newline \u21d2 removal\n            headers.remove(keyword);\n        } else {\n            String value = new String(entry, eq + 1, toRead - eq - 2, CharsetNames.UTF_8);\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}