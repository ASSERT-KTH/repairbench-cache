{
    "generation": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// Assume this method is part of a class where globalPaxHeaders, CharsetNames, and IOUtils are accessible.\n// The original Map globalPaxHeaders should not be modified; the method works on a copy.\nclass PaxParserUtil { // Example class structure\n    private Map<String, String> globalPaxHeaders = Map.of(); // Assume initialized appropriately\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        // Use a mutable map initialized with global headers for this specific block\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){\n            int ch;\n            int len = 0;\n            int read = 0;\n            boolean sawDigit = false;\n\n            // 1. Read record length:\n            // Stop at space, newline, or EOF. Skip lines not starting with a digit.\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' ') { // End of length field\n                    if (!sawDigit) { // Space found before any digits -> invalid format\n                        len = -1; // Mark as invalid\n                    }\n                    break; // Proceed to read keyword=value\n                }\n                if (ch == '\\n') { // Newline encountered before space -> invalid format\n                    len = -1; // Mark as invalid line\n                    break; // Skip processing this line\n                }\n                if (ch < '0' || ch > '9') {\n                    // Invalid character found in length field. Skip the rest of this line until newline.\n                    while ((ch = i.read()) != -1 && ch != '\\n') {\n                        // consume remaining characters of the invalid line\n                    }\n                    len = -1; // Mark as invalid line\n                    break; // Skip processing this line\n                }\n\n                sawDigit = true;\n                int digit = ch - '0';\n                // Check for potential integer overflow before multiplication\n                if (len > (Integer.MAX_VALUE - digit) / 10) {\n                     // Overflow would occur. Treat as invalid line. Skip rest of line.\n                    while ((ch = i.read()) != -1 && ch != '\\n') {\n                         // consume remaining characters of the invalid line\n                    }\n                    len = -1; // Mark as invalid line\n                    break; // Skip processing this line\n                }\n                // Accumulate length\n                len = len * 10 + digit;\n            }\n\n            // Check state after reading length field\n            if (ch == -1) { // EOF encountered while reading length or skipping invalid line.\n                // If sawDigit is true but no space was found, the record is truncated, but we must stop anyway.\n                break; // Exit main loop on EOF\n            }\n            if (len == -1) { // Invalid line detected (non-digit start, NL before SP, bad char, overflow, empty len field).\n                // The line was already skipped to NL or EOF hit. Continue to the next line attempt.\n                continue;\n            }\n\n            // Add a sanity limit for the total record length to prevent OutOfMemoryErrors\n            // Tar specification does not impose a strict limit, but implementations often do (e.g., related to block size).\n            // 64k should be more than enough for typical PAX headers.\n            final int MAX_PAX_RECORD_LENGTH = 65536;\n            if (len > MAX_PAX_RECORD_LENGTH) {\n                 // Skip the rest of this excessively long line until newline.\n                 while ((ch = i.read()) != -1 && ch != '\\n') {\n                     // consume\n                 }\n                 if (ch == -1) break; // EOF while skipping\n                 continue; // Try next line\n            }\n\n            // 2. Calculate and validate remaining length\n            // 'len' is the total record length (including length field, space, keyword, '=', value, '\\n')\n            // 'read' is the number of bytes consumed for the length field + space.\n            final int kvLen = len - read; // Length of the \"keyword=value\\n\" part\n\n            // Smallest possible valid record is \"5 a=\\n\" (len=5, read=2, kvLen=3).\n            // It requires at least: one char keyword, '=', '\\n'. Thus kvLen must be at least 3.\n            if (kvLen < 3) {\n                // Declared length 'len' is impossibly small or inconsistent with bytes read so far.\n                // Consume the remaining 'kvLen' bytes if non-negative to maintain stream position.\n                if (kvLen >= 0) {\n                    // Read the remaining bytes into a dummy buffer to ensure they are consumed.\n                    byte[] dummy = new byte[kvLen];\n                    int got = IOUtils.readFully(i, dummy);\n                    if (got != kvLen) {\n                         // Stream ended prematurely, which is unexpected given the declared length.\n                         throw new IOException(\"Premature end of stream reading invalid PAX header record\");\n                    }\n                } else {\n                    // len < read, which means the declared length is fundamentally inconsistent.\n                    // We cannot reliably consume kvLen bytes. Skip until the next newline for robustness.\n                     while ((ch = i.read()) != -1 && ch != '\\n') {\n                         // consume potentially bogus data following the space\n                     }\n                     if (ch == -1) break; // EOF while skipping\n                }\n                continue; // Try next line\n            }\n\n            // 3. Read the keyword=value\\n part\n            final byte[] kvBytes = new byte[kvLen];\n            final int got = IOUtils.readFully(i, kvBytes);\n            if (got != kvLen) {\n                // Stream ended unexpectedly while reading the expected data.\n                throw new IOException(\"Failed to read Paxheader. Expected \" + kvLen\n                                      + \" bytes (\" + len + \" total), read \" + got);\n            }\n\n            // 4. Validate and parse the keyword=value\\n bytes\n            // Record must end with a newline character.\n            if (kvBytes[kvLen - 1] != '\\n') {\n                 // If it doesn't end with NL, the length field was likely incorrect.\n                 throw new IOException(\"Paxheader record does not end with newline: len=\" + len);\n            }\n\n            // Find the '=' separator. Keyword must be non-empty, so '=' must be at index >= 1.\n            int eqPos = -1;\n            // Search for '=' from index 1 up to the second to last byte (before '\\n').\n            for (int j = 1; j < kvLen - 1; j++) {\n                if (kvBytes[j] == '=') {\n                    eqPos = j;\n                    break;\n                }\n            }\n\n            // Check if a valid '=' position was found.\n            if (eqPos == -1) {\n                // Invalid format: No '=' found, or keyword is empty (\"=value\\n\").\n                // Record was fully read based on 'len', so just continue to next line.\n                continue; // Try next line\n            }\n\n            // Extract keyword and value strings using UTF-8 encoding.\n            final String keyword = new String(kvBytes, 0, eqPos, CharsetNames.UTF_8);\n            // Calculate the length of the value string.\n            final int valueLen = kvLen - eqPos - 2; // Subtract 1 for '=' and 1 for '\\n'\n\n            if (valueLen < 0) {\n                // This should only happen if the record is like \"keyword=\\n\", resulting in valueLen = -1.\n                // According to the spec, an empty value field (\"keyword=\\n\") means delete the keyword.\n                 headers.remove(keyword);\n            } else {\n                final String value = new String(kvBytes, eqPos + 1, valueLen, CharsetNames.UTF_8);\n                headers.put(keyword, value);\n            }\n            // Successfully processed a header, continue the loop for the next line\n        } // End while(true)\n\n        return headers;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}