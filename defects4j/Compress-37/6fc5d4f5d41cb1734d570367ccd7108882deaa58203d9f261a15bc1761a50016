{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// Assume globalPaxHeaders is accessible, e.g., as a field in the containing class.\n// private final Map<String, String> globalPaxHeaders;\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders); // Initialize with global headers\n        // Format is \"length keyword=value\\n\"; Length is decimal number of octets in the record including trailing newline.\n\n        while (true) {\n            int ch;\n            int len = 0;\n            int readBytes = 0; // Bytes read for the current potential record header line\n\n            // 1. Read length field (digits followed by space)\n            // Skip any leading non-digit characters (like newlines from blank lines)\n            int firstByte = -1;\n            while ((ch = i.read()) != -1) {\n                if (firstByte == -1) {\n                    firstByte = ch; // Record the first byte we encounter for this record attempt\n                }\n                if (ch >= '0' && ch <= '9') {\n                    // Found the first digit of the length field\n                    readBytes++;\n                    len = ch - '0';\n                    break; // Proceed to read the rest of the length digits\n                }\n                // If it's not a digit, reset firstByte and continue scanning.\n                // This effectively skips non-digit lines/characters.\n                firstByte = -1;\n            }\n\n            if (ch == -1) { // EOF reached while looking for the first digit\n                // If firstByte was also -1, we reached EOF cleanly (empty stream or only non-digits).\n                // If firstByte != -1, EOF was hit immediately after a non-digit. Still considered clean EOF for headers.\n                break; // End of PAX headers\n            }\n\n            // Read the remaining digits of the length field.\n            while ((ch = i.read()) != -1) {\n                readBytes++;\n                if (ch == ' ') {\n                    // Found the required space separator.\n                    break; // End of length field\n                }\n                if (ch < '0' || ch > '9') {\n                    // Found a non-digit character before the space. Malformed record.\n                    throw new IOException(\"Malformed PAX header: invalid character '\" + (char)ch\n                                           + \"' found reading length digits.\");\n                }\n                // Accumulate length, checking for potential integer overflow.\n                // Use long for intermediate calculation to detect overflow.\n                long nextLen = ((long) len * 10) + (ch - '0');\n                if (nextLen > Integer.MAX_VALUE) {\n                     throw new IOException(\"Malformed PAX header: length field too large, exceeds \" + Integer.MAX_VALUE);\n                }\n                len = (int) nextLen;\n            }\n\n            if (ch != ' ') {\n                // EOF reached while reading length digits. Malformed or truncated record.\n                throw new IOException(\"Malformed PAX header: EOF reached or space not found after length field.\");\n            }\n\n            // 2. Read the \"keyword=value\\n\" part based on the parsed length 'len'.\n            // 'readBytes' currently holds the number of bytes read for the length field + the space.\n            // The remaining bytes for \"keyword=value\\n\" is 'kvLen'.\n            final int kvLen = len - readBytes;\n\n            // Check if the calculated length 'len' is plausible.\n            // It must be at least large enough to cover the length field, space, and a minimal \"k=\\n\" record part.\n            // Minimal kvLen is 3 for \"k=\\n\".\n            if (kvLen < 3) {\n                 // This could happen if len is incorrectly small in the input data.\n                 throw new IOException(\"Malformed PAX header: length \" + len + \" is too small for keyword=value\\\\n format (kvLen=\" + kvLen + \"). Needs >= 3.\");\n            }\n\n            // Read the exact number of bytes for the keyword=value\\n part.\n            final byte[] kvBytes = new byte[kvLen];\n            final int got = IOUtils.readFully(i, kvBytes);\n            if (got != kvLen) {\n                // This indicates the stream ended prematurely or the length 'len' was incorrect relative to stream content.\n                throw new IOException(\"Failed to read PAX header record. Expected \" + kvLen\n                                      + \" bytes for keyword/value part based on length field, but only got \" + got);\n            }\n\n            // 3. Parse the \"keyword=value\\n\" content read into kvBytes.\n            // The last byte must be a newline according to the standard.\n            if (kvBytes[kvLen - 1] != '\\n') {\n                 throw new IOException(\"Malformed PAX header record: does not end with newline.\");\n            }\n\n            // Find the '=' separator. It must exist and cannot be the first char (implying empty keyword).\n            int equalsPos = -1;\n            for (int j = 0; j < kvLen - 1; j++) { // Search up to the byte before the trailing newline.\n                if (kvBytes[j] == '=') {\n                    equalsPos = j;\n                    break;\n                }\n            }\n\n            // Check if '=' was found and is not the first character (position 0).\n            // equalsPos=0 implies empty keyword, which we treat as malformed.\n            // equalsPos=-1 implies no '=' found.\n            if (equalsPos < 1) {\n                 throw new IOException(\"Malformed PAX header record: missing or misplaced '=' separator (position=\" + equalsPos + \"). Keyword cannot be empty.\");\n            }\n\n            // Extract the keyword (UTF-8 encoded).\n            final String keyword = new String(kvBytes, 0, equalsPos, StandardCharsets.UTF_8);\n\n            // Calculate the length of the value part. Value is between '=' and '\\n'.\n            // valueLen = Total kvLen - length_of_keyword - length_of_='=' - length_of_'\\n'\n            final int valueLen = kvLen - equalsPos - 2;\n\n            // If valueLen is 0, it means the format was \"keyword=\\n\".\n            // According to the spec, this means delete the header entry.\n            if (valueLen == 0) {\n                headers.remove(keyword);\n            } else {\n                // Extract the value (UTF-8 encoded).\n                final String value = new String(kvBytes, equalsPos + 1, valueLen, StandardCharsets.UTF_8);\n                headers.put(keyword, value);\n            }\n            // Continue the loop to read the next PAX header record.\n        }\n\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}