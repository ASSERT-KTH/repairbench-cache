{
    "generation": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while(true){ // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean foundLen = false;\n        // Skip blank lines and parse number\n        while((ch = i.read()) != -1) {\n            if (!foundLen && ch == '\\n') {\n                // Skip blank or stray newline lines\n                continue;\n            }\n            read++;\n            if (ch == ' '){\n                foundLen = true;\n                break;\n            }\n            if (ch < '0' || ch > '9') {\n                throw new IOException(\"Non-numeric character '\" + (char)ch + \"' found in Pax header length\");\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1){ // EOF\n            break;\n        }\n        // Now parse header entry of the given \"len\"\n        // We have already read 'read' bytes for len part (including space)\n        // Read the remaining entry part (len - read bytes)\n        byte[] entry = new byte[len - read];\n        int got = IOUtils.readFully(i, entry);\n        if (got != entry.length) {\n            throw new IOException(\"Failed to read full Paxheader entry. Expected \"+entry.length+\" bytes, read \"+got);\n        }\n        // Entire header line (including trailing newline) is: <len><space><keyword>=<value>\\n\n        // So reconstruct line for parsing:\n        ByteArrayOutputStream lineBuf = new ByteArrayOutputStream();\n        // Reconstruct len part\n        String lenStr = Integer.toString(len);\n        lineBuf.write(lenStr.getBytes(CharsetNames.UTF_8), 0, lenStr.length());\n        lineBuf.write(' ');\n        lineBuf.write(entry, 0, entry.length);\n        String line = new String(lineBuf.toByteArray(), CharsetNames.UTF_8);\n        // Remove possible trailing '\\n' or '\\r\\n'\n        if (line.endsWith(\"\\r\\n\")) {\n            line = line.substring(0, line.length() - 2);\n        } else if (line.endsWith(\"\\n\")) {\n            line = line.substring(0, line.length() - 1);\n        }\n        // Now parse keyword and value\n        int eq = line.indexOf('=');\n        if (eq == -1) {\n            continue; // Malformed line, skip\n        }\n        // keyword is after the first space and up to '='\n        int space = line.indexOf(' ');\n        if (space == -1 || space >= eq) {\n            continue; // Malformed line, skip\n        }\n        String keyword = line.substring(space + 1, eq);\n        String value = line.substring(eq + 1);\n        if (value.isEmpty()) {\n            headers.remove(keyword);\n        } else {\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}