{
    "generation": "Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    while (true) {\n        // Read the first byte. Skip over any blank lines.\n        int ch = i.read();\n        if (ch == -1) {\n            break;\n        }\n        if (ch == '\\n') {\n            // Skip blank lines (which can occur in malformed pax header blocks)\n            continue;\n        }\n        // The header line should start with a digit indicating its total length.\n        if (!Character.isDigit(ch)) {\n            // If not a digit, skip the rest of the line.\n            while (ch != -1 && ch != '\\n') {\n                ch = i.read();\n            }\n            continue;\n        }\n        // Parse the length field.\n        int len = ch - '0';\n        int readBytes = 1;\n        // Read remaining digits until the space separator.\n        while (true) {\n            ch = i.read();\n            if (ch == -1) {\n                break;\n            }\n            readBytes++;\n            if (ch == ' ') {\n                break;\n            }\n            if (!Character.isDigit(ch)) {\n                throw new IOException(\"Invalid pax header format: non-digit in length field: \" + (char) ch);\n            }\n            len = len * 10 + (ch - '0');\n        }\n        if (ch == -1) {\n            break;\n        }\n        // If the parsed length is less than the bytes we\u2019ve already read, the record is bogus.\n        if (len < readBytes) {\n            continue;\n        }\n        // Read the keyword until the '=' separator.\n        final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n        while (true) {\n            ch = i.read();\n            if (ch == -1) {\n                break;\n            }\n            readBytes++;\n            if (ch == '=') {\n                break;\n            }\n            coll.write(ch);\n        }\n        if (ch == -1) {\n            break;\n        }\n        final String keyword = coll.toString(CharsetNames.UTF_8);\n        // The remaining bytes in this pax header record include the value plus a trailing newline.\n        int restLen = len - readBytes;\n        if (restLen < 0) {\n            throw new IOException(\"Invalid pax header; negative value length: \" + restLen);\n        }\n        if (restLen == 1) {\n            // If there's only one byte left then it is merely the trailing newline.\n            // A value of empty string implies removal of the header entry.\n            headers.remove(keyword);\n            // (The newline is consumed by readFully below \u2013 nothing to do here.)\n            continue;\n        }\n        // Read the remainder of the record.\n        final byte[] rest = new byte[restLen];\n        final int got = IOUtils.readFully(i, rest);\n        if (got != restLen) {\n            throw new IOException(\"Failed to read Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n        }\n        // The value is all but the trailing newline.\n        final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n        headers.put(keyword, value);\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}