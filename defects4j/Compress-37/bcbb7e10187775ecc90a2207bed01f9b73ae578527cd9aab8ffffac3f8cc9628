{
    "generation": "    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        while (true) { // read headers until EOF\n            int ch;\n            int len = 0;\n            while ((ch = i.read()) != -1 && Character.isDigit(ch)) {\n                len = len * 10 + (ch - '0');\n            }\n            if (ch == -1) { // EOF\n                break;\n            }\n            if (ch != ' ') { // invalid header line\n                throw new IOException(\"Invalid pax header line\");\n            }\n            if (len == 0) {\n                // No data beyond the space; move to next line\n                continue;\n            }\n            final byte[] data = new byte[len];\n            final int got = IOUtils.readFully(i, data);\n            if (got != len) {\n                throw new IOException(\"Failed to read Pax header. Expected \" + len + \" bytes, read \" + got);\n            }\n            final String paxLine = new String(data, CharsetNames.UTF_8);\n            final int eqIndex = paxLine.indexOf('=');\n            if (eqIndex == -1) {\n                // No '=' found; treat entire line as keyword with empty value\n                final String keyword = paxLine.trim();\n                headers.remove(keyword);\n            } else {\n                final String keyword = paxLine.substring(0, eqIndex);\n                String value = paxLine.substring(eqIndex + 1);\n                // Remove trailing newline characters\n                value = value.replaceAll(\"[\\r\\n]+$\", \"\");\n                headers.put(keyword, value);\n            }\n        }\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}