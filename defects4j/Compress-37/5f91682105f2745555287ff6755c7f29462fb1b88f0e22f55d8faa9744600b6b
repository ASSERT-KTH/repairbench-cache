{
    "generation": "Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    headerLoop: while (true) {\n        int ch;\n        int len = 0;\n        int read = 0;\n        // First, parse the length field which is a series of digits terminated by a space\n        while ((ch = i.read()) != -1) {\n            read++;\n            // If the very first character is a newline, this is a blank (empty) line \u2013 skip it.\n            if (ch == '\\n' && read == 1) {\n                // Start again with the next header record.\n                continue headerLoop;\n            }\n            if (ch == ' ') {\n                // End of the length field.\n                break;\n            }\n            // If a non-digit (and not a space) is encountered, skip to end of line.\n            if (ch < '0' || ch > '9') {\n                while ((ch = i.read()) != -1 && ch != '\\n') {\n                    // discard until newline\n                }\n                continue headerLoop;\n            }\n            len = len * 10 + (ch - '0');\n        }\n        if (ch == -1) {\n            break; // end-of-stream\n        }\n        // Now read the keyword until we hit an '='\n        final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == '=') {\n                break;\n            }\n            coll.write((byte) ch);\n        }\n        if (ch == -1) {\n            break;\n        }\n        final String keyword = coll.toString(CharsetNames.UTF_8);\n        final int restLen = len - read;\n        // We expect the header record (as given by 'len') to have the remaining text plus a trailing newline.\n        if (restLen < 1) {\n            // This record is malformed (or blank). Skip to the end of the current line.\n            while ((ch = i.read()) != -1 && ch != '\\n') {\n                // discard the rest of the line\n            }\n            continue headerLoop;\n        } else if (restLen == 1) { // nothing but the NL is left; this is a deletion marker.\n            headers.remove(keyword);\n            // Consume the trailing newline.\n            i.read();\n        } else {\n            final byte[] rest = new byte[restLen];\n            final int got = IOUtils.readFully(i, rest);\n            if (got != restLen) {\n                throw new IOException(\"Failed to read Paxheader. Expected \" + restLen + \" bytes, read \" + got);\n            }\n            // The last byte must be a newline; drop it.\n            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}