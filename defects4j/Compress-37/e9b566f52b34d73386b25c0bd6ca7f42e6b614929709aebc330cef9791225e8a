{
    "generation": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){\n            int ch;\n            int len = 0; // This will store the numeric 'length' value\n            int digitsRead = 0; // Keep track of how many characters (digits + space) we've read for the length prefix\n\n            // Read the 'length' digits and the following space\n            while((ch = i.read()) != -1) {\n                digitsRead++;\n                if (ch == ' '){ // Found the space after the length digits\n                    break;\n                }\n                if (ch < '0' || ch > '9') {\n                    // Invalid character encountered during length parsing.\n                    // This covers cases like \"7\\n\" or \"1 comment\" where a space is expected but not found.\n                    // If it's a newline and no digits were successfully parsed (meaning an empty line \"\\n\"),\n                    // it should be silently ignored.\n                    if (ch == '\\n' && digitsRead == 1 && len == 0) {\n                        continue; // Silently ignore an empty line (\"\\n\")\n                    }\n                    // For any other malformed length prefix, throw an error as it indicates invalid data.\n                    throw new IOException(\"Invalid character '\" + (char)ch + \"' in PaxHeader length at position \" + digitsRead);\n                }\n                len = len * 10 + (ch - '0');\n            }\n\n            if (ch == -1){ // EOF encountered while reading length or space\n                break; // No more headers\n            }\n\n            // At this point, `len` holds the declared length of the `keyword=value\\n` part.\n\n            // Read the `len` bytes of content (keyword=value\\n) into a byte array\n            final byte[] contentBytes = new byte[len];\n            final int got = IOUtils.readFully(i, contentBytes);\n            if (got != len) {\n                throw new IOException(\"Failed to read Paxheader. Expected \"\n                                      + len\n                                      + \" bytes, read \"\n                                      + got);\n            }\n\n            // Pax header content must end with newline.\n            // Check this unless len is 0 (which is an unusual but handled case).\n            if (len > 0 && contentBytes[len - 1] != '\\n') {\n                throw new IOException(\"Paxheader content must end with newline\");\n            }\n\n            // Handle blank lines explicitly: `1 \\n` means `len`=1, `content`=`\\n`.\n            if (len == 1 && contentBytes[0] == '\\n') {\n                continue; // Silently ignore this standard blank line\n            }\n\n            // Parse `contentBytes` to find keyword and value\n            int equalsIndexInContent = -1; // Index of '=' relative to the start of contentBytes\n            for (int j = 0; j < len; j++) {\n                if (contentBytes[j] == '=') {\n                    equalsIndexInContent = j;\n                    break;\n                }\n            }\n\n            if (equalsIndexInContent == -1) {\n                // No '=' found. This is a malformed entry (e.g., \"1 comment\" from the test case).\n                // Per COMPRESS-355 test's implicit requirement, such lines should be silently ignored.\n                continue;\n            }\n\n            // Extract keyword (from start of content to before '=')\n            final String keyword = new String(contentBytes, 0, equalsIndexInContent, CharsetNames.UTF_8);\n\n            // Extract value (from after '=' to before '\\n')\n            final int valueStart = equalsIndexInContent + 1;\n            final int valueEnd = len - 1; // Exclude the trailing newline\n\n            // If valueStart is greater than valueEnd, it indicates a malformed entry like \"key=\" (missing '\\n')\n            // or an empty/missing value portion. Given the prior `contentBytes[len-1] != '\\n'` check,\n            // `valueStart == valueEnd` is the only valid case for an empty value (`key=\\n`).\n            if (valueStart > valueEnd) {\n                // This means the value portion is ill-formed, typically implying something like \"key=\"\n                // where the newline is missing or the length is incorrect.\n                // Treat as malformed and ignore.\n                continue;\n            }\n\n            final String value = new String(contentBytes, valueStart, valueEnd - valueStart, CharsetNames.UTF_8);\n\n            // Per specification: \"If an extended header record contains a keyword that has the empty string as its value, then the existing attribute shall be deleted.\"\n            if (value.isEmpty()) {\n                headers.remove(keyword);\n            } else {\n                headers.put(keyword, value);\n            }\n        }\n        return headers;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}