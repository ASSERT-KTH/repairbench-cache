{
    "generation": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while(true){ // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean lenRead = false;\n        while((ch = i.read()) != -1) {\n            read++;\n            if (ch == '\\n' && read == 1) {\n                // Blank line (or stray newline), skip and try to read a new header line\n                break;\n            }\n            if (ch == ' '){\n                lenRead = true;\n                break;\n            }\n            if (ch < '0' || ch > '9') {\n                // If we encounter any character that's not a digit or space at this point,\n                // the header is malformed; skip this line.\n                while (ch != -1 && ch != '\\n') {\n                    ch = i.read();\n                }\n                break;\n            }\n            len = len * 10 + (ch - '0');\n        }\n        if (!lenRead) {\n            if (ch == -1) { // EOF\n                break;\n            }\n            // break to next header line (continuing the loop)\n            continue;\n        }\n        if (len <= 0) {\n            // Malformed line or blank line, skip to next header\n            // Skip the rest of this header line (len <= 0 doesn't make sense)\n            for (int skipped = 0; skipped < 512 && ch != '\\n' && ch != -1; skipped++) {\n                ch = i.read();\n            }\n            continue;\n        }\n        // We've read 'read' bytes so far: len is the full header length\n        // We got here after reading the number, space char, ch at space\n        final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n        String keyword = null;\n        boolean keywordRead = false;\n        int payloadRead = read;\n        while(payloadRead < len) {\n            ch = i.read();\n            if (ch == -1) {\n                // Unexpected EOF in the middle of a header line\n                throw new IOException(\"Failed to read Paxheader line. Unexpected EOF.\");\n            }\n            payloadRead++;\n            if (!keywordRead) {\n                if (ch == '=') {\n                    keyword = coll.toString(CharsetNames.UTF_8);\n                    coll.reset();\n                    keywordRead = true;\n                } else {\n                    coll.write(ch);\n                }\n            } else {\n                coll.write(ch);\n            }\n        }\n        if (keyword == null) {\n            // Could not parse keyword, skip this header\n            continue;\n        }\n        byte[] valueBytes = coll.toByteArray();\n        // The value ends with a newline (\\n), remove it\n        if (valueBytes.length > 0 && valueBytes[valueBytes.length - 1] == (byte) '\\n') {\n            int valueLength = valueBytes.length - 1;\n            if (valueLength == 0) {\n                headers.remove(keyword);\n            } else {\n                String value = new String(valueBytes, 0, valueLength, CharsetNames.UTF_8);\n                headers.put(keyword, value);\n            }\n        } else {\n            String value = new String(valueBytes, CharsetNames.UTF_8);\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}