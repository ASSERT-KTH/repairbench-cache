{
    "generation": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Assuming CharsetNames and IOUtils are available from the Apache Commons Compress context\n// For a standalone snippet, these would typically be imported or mocked.\n// e.g., import org.apache.commons.compress.utils.CharsetNames;\n// e.g., import org.apache.commons.compress.utils.IOUtils;\n\npublic class TarArchiveInputStream { // Assuming this class context for globalPaxHeaders\n    private final Map<String, String> globalPaxHeaders = new HashMap<>(); // Placeholder for compilation\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // loop to process multiple header entries\n            int ch;\n            int len = 0;\n            int read = 0; // bytes read for the current pax header line\n            boolean digitFound = false;\n\n            // First, parse the length field (e.g., \"123 \")\n            // This loop reads digits until a space or a newline is found.\n            // It expects a space to follow the digits for a valid header.\n            // A newline after digits is a malformed header.\n            // A newline without digits is a blank line (skipped).\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch >= '0' && ch <= '9') {\n                    len = len * 10 + (ch - '0');\n                    digitFound = true;\n                } else if (ch == ' ') { // End of length field, and space found\n                    if (!digitFound) { // e.g., \" keyword=value\"\n                        throw new IOException(\"Invalid Paxheader. Length field is empty.\");\n                    }\n                    break; // Length and space consumed, proceed to keyword\n                } else if (ch == '\\n') { // Encountered newline (e.g., \"123\\n\" or just \"\\n\")\n                    if (read == 1 && len == 0 && !digitFound) { // Case: Empty line \"\\n\"\n                        // This means an empty pax header line. The problem statement says \"survives blank lines\".\n                        // So, we just skip this line.\n                        ch = '\\n'; // Set ch to indicate it was a newline, for the outer loop's check.\n                        break; // Break from this inner loop to outer loop's checks\n                    } else { // Malformed: e.g. \"123\\n\" (missing space), or \"abc\\n\" (non-digit leading char)\n                        throw new IOException(\"Invalid Paxheader. Unexpected newline or malformed length field.\");\n                    }\n                } else { // Unexpected character (e.g., non-digit, non-space, not newline)\n                    throw new IOException(\"Invalid Paxheader. Expected digit or space but got '\" + (char)ch + \"' (ascii:\" + ch + \").\");\n                }\n            }\n\n            if (ch == -1) { // EOF encountered while parsing length or space\n                break; // Exit outer while(true) loop\n            }\n            if (ch == '\\n') { // If we broke from length parsing due to a blank line\n                continue; // Skip this iteration and try to read the next header\n            }\n\n            // At this point, `len` is the total length of the line, and `read` is the bytes consumed for \"length_string \".\n            // Next: parse keyword and value.\n            final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n            while((ch = i.read()) != -1) {\n                read++; // Accumulate bytes read for keyword and '='\n                if (ch == '='){ // end of keyword\n                    final String keyword = coll.toString(CharsetNames.UTF_8);\n\n                    // Get rest of entry (value + NL)\n                    // `len` is total length of \"length keyword=value\\n\"\n                    // `read` is total bytes consumed *up to and including* the '='.\n                    final int restLen = len - read; // Expected remaining length (value + NL)\n\n                    if (restLen < 0) {\n                        throw new IOException(\"Invalid Paxheader. Header processing exceeded declared length of \" + len + \" bytes. Read \" + read + \" bytes.\");\n                    }\n                    // The spec says \"value and a new-line character\". So `restLen` must be at least 1 (for `\\n`).\n                    if (restLen == 0) { // This means \"length keyword=\" and no newline. Malformed.\n                        throw new IOException(\"Invalid Paxheader. Value or newline is missing after keyword.\");\n                    }\n                    \n                    if (restLen == 1) { // Value is empty, only NL\n                        headers.remove(keyword);\n                        // Consume the remaining 1 byte (the newline).\n                        int nextCh = i.read();\n                        if (nextCh == -1 || nextCh != '\\n') { // Expecting newline\n                            throw new IOException(\"Invalid Paxheader. Expected newline after empty value but got EOF or other character.\");\n                        }\n                    } else { // Value present (restLen > 1)\n                        final byte[] rest = new byte[restLen];\n                        final int got = IOUtils.readFully(i, rest);\n                        if (got != restLen) {\n                            throw new IOException(\"Failed to read \"\n                                                  + \"Paxheader. Expected \"\n                                                  + restLen\n                                                  + \" bytes, read \"\n                                                  + got);\n                        }\n                        // Drop trailing NL from the value string\n                        final String value = new String(rest, 0,\n                                                  restLen - 1, CharsetNames.UTF_8);\n                        headers.put(keyword, value);\n                    }\n                    break; // Processed single header, break from inner (keyword) loop\n                } else if (ch == '\\n') { // Unexpected newline during keyword parsing\n                    throw new IOException(\"Invalid Paxheader. Unexpected newline during keyword parsing.\");\n                }\n                coll.write((byte) ch);\n            }\n\n            if (ch == -1){ // EOF encountered during keyword or '=' parsing\n                break; // Exit outer while(true) loop\n            }\n        }\n        return headers;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}