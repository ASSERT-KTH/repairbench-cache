{
    "generation": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while(true){ // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean foundLength = false;\n        while((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' '){\n                foundLength = true;\n                break;\n            }\n            // Ignore any blank lines or non-digit (skip them)\n            if (ch < '0' || ch > '9') {\n                // skip to end of line\n                while (ch != -1 && ch != '\\n') {\n                    ch = i.read();\n                }\n                break;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) { // EOF\n            break;\n        }\n        if (!foundLength) {\n            continue; // skip blank line and proceed to next\n        }\n        if (len <= 0) { // blank line or invalid length, skip it\n            // skip to end of line\n            while (ch != -1 && ch != '\\n') {\n                ch = i.read();\n            }\n            continue;\n        }\n        // Now, retrieve the rest of the record (already read 'read' bytes so far, after length)\n        final byte[] record = new byte[len - read];\n        int got = IOUtils.readFully(i, record);\n        if (got != record.length) {\n            throw new IOException(\"Failed to read Paxheader. Expected \"\n                                  + record.length + \" bytes, read \" + got);\n        }\n        // Now split at '=' (the first occurrence) for keyword, and drop trailing NL\n        int eq = -1;\n        for (int j = 0; j < record.length; j++) {\n            if (record[j] == '=') {\n                eq = j;\n                break;\n            }\n        }\n        if (eq == -1 || record.length == 0) {\n            // Malformed line (eg., blank), skip\n            continue;\n        }\n        final String keyword = new String(record, 0, eq, CharsetNames.UTF_8);\n        // Should drop the trailing NL (the last byte)\n        final String value = new String(record, eq + 1, record.length - eq - 1 - 1, CharsetNames.UTF_8);\n        if (value.length() == 0) {\n            headers.remove(keyword);\n        } else {\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}