{
    "generation": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.commons.compress.utils.CharsetNames;\nimport org.apache.commons.compress.utils.IOUtils;\n\n// Assume globalPaxHeaders is accessible and non-null in this context, as in the original code.\n// Also assume necessary imports like java.util.*, java.io.*, org.apache.commons.compress.* are available.\n\n    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\"; length is the total length of the record including the length field and newline.\n        while (true) { // Outer loop continues until EOF or non-header data is found (implicitly by caller)\n            int ch;\n            int len = 0;\n            int lenFieldBytes = 0; // Count bytes read for the length field itself (digits + space)\n            boolean malformedLine = false;\n\n            // 1. Read Length Field\n            while ((ch = i.read()) != -1) {\n                lenFieldBytes++;\n                if (ch == ' ') { // Found space, end of length field.\n                    break; // Exit length reading loop\n                }\n                // Check for potential integer overflow before processing the digit.\n                // Ensure len doesn't exceed Integer.MAX_VALUE / 10 before multiplication\n                if (len > Integer.MAX_VALUE / 10) {\n                     throw new IOException(\"Paxheader length exceeds Integer.MAX_VALUE.\");\n                }\n                int digit = ch - '0';\n                if (digit >= 0 && digit <= 9) {\n                    int newLen = len * 10 + digit;\n                    // Check for overflow again after adding the digit (detect wrap-around).\n                    if (newLen < len) {\n                        throw new IOException(\"Paxheader length exceeds Integer.MAX_VALUE.\");\n                    }\n                    len = newLen;\n                } else {\n                    // Malformed line: Non-digit, non-space found in length field.\n                    malformedLine = true;\n                    // Consume rest of the line until newline to resync for the next record.\n                    while ((ch = i.read()) != -1 && ch != '\\n') {\n                        // consume\n                    }\n                    break; // Exit length reading loop\n                }\n            }\n\n            // Check state after trying to read length field\n            if (malformedLine) { // A malformed line (e.g., blank line, non-digit) was detected and skipped\n                continue; // Try to read the next line as a PAX header\n            }\n\n            if (ch == -1) { // EOF was encountered\n                if (lenFieldBytes == 0) { // Clean EOF at the very beginning of a potential record\n                    break; // Normal end of headers block\n                }\n                // EOF after reading some length digits but before the space\n                throw new IOException(\"Premature EOF reading Paxheader length field.\");\n            }\n            // If here, loop finished because ch == ' '. Length 'len' is parsed.\n\n            // Calculate total bytes read for length field + space\n            final int headerPrefixBytes = lenFieldBytes;\n\n            // 'len' is the total size of the record, including the length field, space, keyword=value, and \\n.\n            // Calculate the size of the data part (keyword=value\\n)\n            final int dataBytes = len - headerPrefixBytes;\n\n            // Basic sanity checks for the data part length.\n            // Records like \"0 \\n\" (dataBytes=-2), \"3 a\\n\" (dataBytes=1), \"4 k=\\n\" (dataBytes=2) are invalid/malformed.\n            // A minimal valid record needs at least 3 bytes for data (e.g., \"k=\\n\").\n            if (dataBytes <= 2) {\n                 // Invalid or trivially empty record. Skip it to survive.\n                 // If dataBytes > 0, we MUST consume those bytes from the stream to stay synchronized.\n                 if (dataBytes > 0) {\n                     byte[] dummy = new byte[dataBytes];\n                     int skipped = IOUtils.readFully(i, dummy);\n                     if(skipped != dataBytes) {\n                        // If we can't even read the expected (short) data, something is very wrong.\n                        throw new IOException(\"Premature EOF reading Paxheader record (skipping short record)\");\n                     }\n                 }\n                 continue; // Skip this record and try the next line.\n            }\n\n            // 2. Read the data part (keyword=value\\n) which has length dataBytes\n            final byte[] data = new byte[dataBytes];\n            final int got = IOUtils.readFully(i, data);\n            if (got != dataBytes) {\n                // This indicates the stream ended before the promised 'len' bytes were available.\n                throw new IOException(\"Premature EOF reading Paxheader data. Expected \"\n                                      + dataBytes + \" bytes, read \" + got);\n            }\n\n            // 3. Parse \"keyword=value\\n\" from the data byte array\n            // Check that the data part ends with a newline (essential for PAX format)\n            // Note: dataBytes is guaranteed >= 3 here.\n            if (data[dataBytes - 1] != '\\n') {\n                 // The record read does not end in newline, which violates the PAX format spec.\n                 // This suggests the 'len' value was incorrect or the stream is corrupted.\n                 throw new IOException(\"Invalid PAX header record: data does not end with newline as expected.\");\n            }\n\n            // Find the '=' separator. It must exist, and keyword must not be empty.\n            int eqPos = -1;\n            // Search only up to the byte before the trailing newline\n            for (int j = 0; j < dataBytes - 1; j++) {\n                if (data[j] == '=') {\n                    eqPos = j;\n                    break;\n                }\n            }\n\n            // '=' must be found (eqPos >= 0) and keyword must be non-empty (eqPos > 0).\n            if (eqPos <= 0) {\n                // Malformed record (no '=', or empty keyword like \"=value\\n\"). Skip it silently.\n                continue;\n            }\n\n            // Extract keyword\n            final String keyword = new String(data, 0, eqPos, CharsetNames.UTF_8);\n\n            // Extract value (the part between '=' and '\\n')\n            // Value starts at index eqPos + 1\n            // Value ends at index dataBytes - 2 (inclusive)\n            // Length of value = (dataBytes - 2) - (eqPos + 1) + 1 = dataBytes - eqPos - 2\n            final int valueLen = dataBytes - eqPos - 2;\n            // Ensure valueLen is not negative (it's 0 for \"keyword=\\n\")\n            final String value = new String(data, eqPos + 1, Math.max(0, valueLen), CharsetNames.UTF_8);\n\n            // PAX specification: if the value is zero length, it deletes any existing header entry of the same name.\n            if (value.isEmpty()) {\n                headers.remove(keyword);\n            } else {\n                headers.put(keyword, value);\n            }\n            // Successfully processed one header, loop continues for the next one.\n\n        } // End outer while(true) loop\n\n        return headers;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}