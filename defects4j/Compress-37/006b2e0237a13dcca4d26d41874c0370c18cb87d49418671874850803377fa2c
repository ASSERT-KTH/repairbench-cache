{
    "generation": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while(true){ // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean foundLength = false;\n        while((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                foundLength = true;\n                break;\n            }\n            // skip if newlines before length start (blank line)\n            if (!foundLength) {\n                if ((ch >= '0') && (ch <= '9')) {\n                    len *= 10;\n                    len += ch - '0';\n                } else {\n                    // invalid char before length, skip rest of line\n                    while (ch != -1 && ch != '\\n') {\n                        ch = i.read();\n                    }\n                    break; // skip to next line\n                }\n            }\n        }\n        if (ch == -1) { // EOF\n            break;\n        }\n        if (!foundLength) {\n            continue; // skip blank line\n        }\n        int restLen = len - read;\n        if (restLen <= 0) {\n            // Skip this invalid or blank (empty length or just newline)\n            // Drain the rest of the line (should be restLen zero, already read)\n            for (int j = 0; j < restLen; j++) {\n                if (i.read() == -1) {\n                    break;\n                }\n            }\n            continue;\n        }\n\n        final ByteArrayOutputStream entryBytes = new ByteArrayOutputStream();\n        final byte[] rest = new byte[restLen];\n        final int got = IOUtils.readFully(i, rest);\n        if (got != restLen) {\n            throw new IOException(\"Failed to read Paxheader. Expected \"\n                                  + restLen + \" bytes, read \" + got);\n        }\n        entryBytes.write(rest, 0, restLen);\n\n        final String entry = entryBytes.toString(CharsetNames.UTF_8);\n\n        // Remove trailing newline, it should be there\n        if (entry.endsWith(\"\\n\")) {\n            String trimmedEntry = entry.substring(0, entry.length() - 1);\n            final int idx = trimmedEntry.indexOf('=');\n            if (idx != -1) {\n                final String keyword = trimmedEntry.substring(0, idx);\n                final String value = trimmedEntry.substring(idx + 1);\n                if (value.length() == 0) {\n                    headers.remove(keyword);\n                } else {\n                    headers.put(keyword, value);\n                }\n            }\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}