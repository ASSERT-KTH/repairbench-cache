{
    "generation": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // Process each header entry\n            int ch;\n            int len = 0; // The total length of the current entry including length field itself\n            int currentEntryBytesRead = 0; // Tracks bytes read for the current entry from the start\n            \n            // 1. Read 'length' part and the following space\n            while((ch = i.read()) != -1) {\n                currentEntryBytesRead++; // Increment for each byte read\n                if (ch == ' '){\n                    // End of 'length' part and space.\n                    // currentEntryBytesRead now holds (length of length string + 1 for space)\n                    // len holds the total length of the entry.\n                    // Proceed to read keyword=value\\n\n                    \n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    // 2. Read 'keyword' part\n                    while((ch = i.read()) != -1) {\n                        currentEntryBytesRead++; // Increment for each byte read\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            \n                            // 3. Calculate remaining length for 'value\\n'\n                            // currentEntryBytesRead now holds (length of length string + 1 for space + length of keyword + 1 for '=')\n                            final int restLen = len - currentEntryBytesRead;\n\n                            // Sanity check: restLen must be non-negative.\n                            // If it's negative, the declared 'len' was too small for the actual content read so far.\n                            if (restLen < 0) {\n                                throw new IOException(\"Malformed Paxheader. Declared length \"\n                                                      + len + \" is shorter than actual length \"\n                                                      + currentEntryBytesRead + \" already read for keyword '\"\n                                                      + keyword + \"'.\");\n                            }\n\n                            // If restLen is 1, it implies the remaining part is only the newline '\\n'.\n                            // This means the value was empty, i.e., \"keyword=\\n\".\n                            // As per spec (and common interpretation for this parser that requires '='),\n                            // an empty value should result in setting the value to an empty string.\n                            if (restLen == 1) { // only NL expected\n                                headers.put(keyword, \"\"); // Correctly handle empty value (e.g. \"key=\\n\")\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL (which is the last byte of rest)\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break; // Processed single header (keyword=value)\n                        }\n                        // Validate that ch is not a newline within keyword parsing.\n                        // Newline should only appear at the very end of the entry.\n                        if (ch == '\\n') {\n                            throw new IOException(\"Malformed Paxheader. Newline encountered before equals sign in keyword.\");\n                        }\n                        coll.write((byte) ch);\n                    }\n                    // This `break` processes single header entry (length ... value\\n) and moves to next line.\n                    break;\n                }\n                // Still parsing 'length' part\n                // Validate that ch is a digit. If not, it's a malformed header.\n                if (ch < '0' || ch > '9') {\n                    throw new IOException(\"Invalid Paxheader. Non-digit character '\" + (char)ch + \"' in length field.\");\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF encountered while reading length or keyword\n                break; // No more entries\n            }\n        }\n        return headers;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}