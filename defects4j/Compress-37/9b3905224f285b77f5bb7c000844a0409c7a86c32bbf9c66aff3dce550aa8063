{
    "generation": "// https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\nMap<String, String> parsePaxHeaders(final InputStream i)\n    throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) { // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean foundLen = false;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == '\\n' || ch == '\\r') {\n                // skip blank or empty lines\n                continue;\n            }\n            if (ch == ' ') {\n                foundLen = true;\n                break;\n            }\n            if (ch < '0' || ch > '9') {\n                // Malformed line\n                throw new IOException(\"Non-numeric character in header length: \" + ch);\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) { // EOF\n            break;\n        }\n        if (!foundLen) {\n            continue;\n        }\n        if (len <= 0) {\n            // skip empty/bogus lines\n            // read until next newline\n            while (ch != -1 && ch != '\\n') {\n                ch = i.read();\n            }\n            continue;\n        }\n        // We already read 'read' bytes for length\n        // Now, read rest of the entry (len - read bytes)\n        // For valid entries, that is keyword=value\\n\n        int remain = len - read;\n        if (remain <= 0) {\n            // skip line if length or header is malformed\n            // read until next newline\n            while (ch != -1 && ch != '\\n') {\n                ch = i.read();\n            }\n            continue;\n        }\n        byte[] headerRest = new byte[remain];\n        int got = IOUtils.readFully(i, headerRest);\n        if (got != remain) {\n            throw new IOException(\"Failed to read Paxheader. Expected \"\n                    + remain + \" bytes, read \" + got);\n        }\n        int equals = -1;\n        for (int idx = 0; idx < headerRest.length; idx++) {\n            if (headerRest[idx] == '=') {\n                equals = idx;\n                break;\n            }\n        }\n        if (equals == -1) {\n            // malformed header, skip it\n            continue;\n        }\n        String keyword = new String(headerRest, 0, equals, CharsetNames.UTF_8);\n        // drop newline at end\n        int valueLen = headerRest.length - equals - 1;\n        if (valueLen < 0) {\n            // malformed header, skip it\n            continue;\n        }\n        String value = new String(headerRest, equals + 1, valueLen, CharsetNames.UTF_8);\n        if (value.endsWith(\"\\n\")) {\n            value = value.substring(0, value.length() - 1);\n        }\n        if (keyword.length() == 0 && value.length() == 0) {\n            continue;\n        }\n        if (value.length() == 0) {\n            headers.remove(keyword);\n        } else {\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}