{
    "generation": "Map<String, String> parsePaxHeaders(final InputStream i) throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    while (true) {\n        // Skip any blank lines (or stray CR/LF) at the beginning.\n        int first = i.read();\n        while (first == '\\n' || first == '\\r') {\n            first = i.read();\n        }\n        if (first == -1) {\n            break; // end-of-file reached\n        }\n        // If the record does not start with a digit, skip the rest of the line.\n        if (first < '0' || first > '9') {\n            while ((first = i.read()) != -1 && first != '\\n') {\n                // Discard the rest of this line.\n            }\n            continue;\n        }\n\n        // At this point, we are at the beginning of a valid Pax header record.\n        // The format is: \"length keyword=value\\n\"\n        int len = first - '0';\n        int bytesRead = 1; // we've already consumed the first digit\n\n        int ch;\n        // Read the rest of the length field (digits) until a space is encountered.\n        while ((ch = i.read()) != -1) {\n            bytesRead++;\n            if (ch == ' ') {\n                break;\n            }\n            if (ch < '0' || ch > '9') {\n                throw new IOException(\"Invalid character in PAX header length: \" + (char) ch);\n            }\n            len = (len * 10) + (ch - '0');\n        }\n        if (ch == -1) {\n            break; // unexpected EOF in length field\n        }\n\n        // Read the keyword: read bytes until '=' is reached.\n        ByteArrayOutputStream keywordBuffer = new ByteArrayOutputStream();\n        while ((ch = i.read()) != -1) {\n            bytesRead++;\n            if (ch == '=') {\n                break;\n            }\n            keywordBuffer.write(ch);\n        }\n        if (ch == -1) {\n            throw new IOException(\"Unexpected EOF while reading PAX header keyword\");\n        }\n        final String keyword = keywordBuffer.toString(CharsetNames.UTF_8);\n\n        // Calculate the number of bytes remaining in the record (value + trailing newline).\n        int restLen = len - bytesRead;\n        if (restLen < 1) {\n            throw new IOException(\"Invalid PAX header record length: \" + len + \" too short\");\n        }\n        if (restLen == 1) {\n            // There is no value; only the newline remains. Consume the newline.\n            int nl = i.read();\n            if (nl == -1) {\n                throw new IOException(\"Unexpected EOF reading newline at end of PAX header record\");\n            }\n            // Remove the header (or any previously stored value from globalPaxHeaders).\n            headers.remove(keyword);\n        } else {\n            // Read the rest of the record (value plus trailing newline).\n            byte[] rest = new byte[restLen];\n            final int got = IOUtils.readFully(i, rest);\n            if (got != restLen) {\n                throw new IOException(\"Failed to read PAX header. Expected \" + restLen + \" bytes, read \" + got);\n            }\n            // Exclude the trailing newline from the value.\n            final String value = new String(rest, 0, restLen - 1, CharsetNames.UTF_8);\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}