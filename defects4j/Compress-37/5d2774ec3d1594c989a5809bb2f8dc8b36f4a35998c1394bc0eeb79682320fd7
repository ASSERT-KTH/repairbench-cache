{
    "generation": "    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            boolean hadLengthDigits = false; // Flag to ensure at least one digit was read for length\n            boolean malformedEntry = false; // Flag to indicate if current entry is malformed and needs skipping\n            \n            // Loop to read length and the following space\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){\n                    // Ensure we actually parsed a length before the space\n                    if (!hadLengthDigits) {\n                        malformedEntry = true; // No digits read for length, skip this line\n                        break;\n                    }\n                    break; // Space found, proceed to keyword\n                }\n                // If not space, it must be a digit for the length\n                if (ch < '0' || ch > '9') {\n                    malformedEntry = true; // Non-digit character in length, skip this line\n                    break;\n                }\n                hadLengthDigits = true;\n                len *= 10;\n                len += ch - '0';\n            }\n\n            if (ch == -1){ // EOF while reading length or after parsing a good entry\n                break; // Exit main loop if EOF encountered\n            }\n\n            if (malformedEntry) {\n                // If the entry is malformed (e.g., non-digit in length, or space before digits),\n                // skip the rest of the line and try the next one.\n                while ((ch = i.read()) != -1 && ch != '\\n') { /* consume */ }\n                if (ch == -1) { // Reached EOF while skipping\n                    break;\n                }\n                continue; // Process next line/entry\n            }\n\n            // At this point, we have successfully read `len` and the space after it.\n            // Now, get keyword and '='\n            final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n            boolean foundEquals = false;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '='){ // end of keyword\n                    foundEquals = true;\n                    break;\n                }\n                coll.write((byte) ch);\n            }\n            \n            if (!foundEquals) {\n                // Malformed header: no '=' found. This line is invalid.\n                // Current `ch` could be -1 (EOF) or `\\n` or another char.\n                // If `ch` is not -1, we should consume rest of the line.\n                if (ch != -1 && ch != '\\n') { // If it's not EOF or already newline, consume\n                    while ((ch = i.read()) != -1 && ch != '\\n') { /* consume */ }\n                }\n                if (ch == -1) { // Reached EOF while skipping\n                    break;\n                }\n                continue; // Process next line/entry\n            }\n\n            final String keyword = coll.toString(CharsetNames.UTF_8);\n            \n            // Get rest of entry (value + trailing newline)\n            final int restLen = len - read;\n            if (restLen < 1) { // restLen must be at least 1 (for the trailing NL)\n                // This indicates the advertised length 'len' is inconsistent with bytes read so far.\n                // This is the original NegativeArraySizeException case (if restLen < 0)\n                // or StringIndexOutOfBoundsException if restLen = 0 and (restLen - 1) is used.\n                // Skip the rest of this malformed line.\n                if (ch != -1 && ch != '\\n') { // If it's not EOF or already newline, consume\n                    while ((ch = i.read()) != -1 && ch != '\\n') { /* consume */ }\n                }\n                if (ch == -1) { // Reached EOF while skipping\n                    break;\n                }\n                continue; // Process next line/entry\n            }\n\n            if (restLen == 1) { // only NL is left, implies empty value\n                headers.remove(keyword); // Remove the key from the map as per spec for empty value\n            } else { // restLen > 1, so there is a value plus the NL\n                final byte[] rest = new byte[restLen];\n                final int got = IOUtils.readFully(i, rest);\n                if (got != restLen) {\n                    // This might happen if the stream ends prematurely, indicating truncation.\n                    // As per spec, this is an error condition.\n                    throw new IOException(\"Failed to read \"\n                                          + \"Paxheader. Expected \"\n                                          + restLen\n                                          + \" bytes, read \"\n                                          + got + \" for keyword '\" + keyword + \"'.\");\n                }\n                // Drop trailing NL (restLen - 1 bytes for the actual value)\n                final String value = new String(rest, 0,\n                                          restLen - 1, CharsetNames.UTF_8);\n                headers.put(keyword, value);\n            }\n            // A successfully processed header allows the outer while(true) loop to continue\n            // and parse the next header entry. No explicit `break` or `continue` is needed here\n            // as the loop naturally proceeds.\n        }\n        return headers;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}