{
    "generation": "Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) { // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean lenRead = false;\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                lenRead = true;\n                break;\n            }\n            if (ch < '0' || ch > '9') {\n                // Invalid character in length field: skip until NL, treat as blank/invalid line\n                while (ch != -1 && ch != '\\n') {\n                    ch = i.read();\n                }\n                // Continue to outer while loop to try to process the next line\n                continue;\n            }\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1 || !lenRead) { // EOF or line with no length\n            break;\n        }\n        if (len <= 0) {\n            // Skip invalid/blank line\n            for (int n = 1; n < read; n++) { // n = 1: already read one byte (the blank line)\n                if (i.read() == -1) {\n                    break;\n                }\n            }\n            continue;\n        }\n        // Now read (len - read) bytes, since we've read 'read' bytes so far (len includes itself)\n        final ByteArrayOutputStream entryBaos = new ByteArrayOutputStream();\n        int remain = len - read;\n        if (remain <= 0) {\n            // Blank or malformed header line, skip to next\n            for (int n = 0; n < -remain; n++) {\n                if (i.read() == -1) {\n                    break;\n                }\n            }\n            continue;\n        }\n        byte[] entry = new byte[remain];\n        int got = IOUtils.readFully(i, entry);\n        if (got != remain) {\n            throw new IOException(\"Failed to read Paxheader. Expected \"\n                                  + remain\n                                  + \" bytes, read \"\n                                  + got);\n        }\n        // The line may or may not have NL at the end (should, but let's be safe)\n        // Find '=' and split into keyword and value\n        int eq = -1;\n        for (int idx = 0; idx < entry.length; idx++) {\n            if (entry[idx] == '=') {\n                eq = idx;\n                break;\n            }\n        }\n        if (eq == -1) {\n            // No keyword found. Ignore this entry.\n            continue;\n        }\n        String keyword = new String(entry, 0, eq, CharsetNames.UTF_8);\n        // Value: skip the trailing NL\n        int valLen = entry.length - eq - 1; // drop trailing NL\n        if (valLen < 0) valLen = 0;\n        String value = new String(entry, eq + 1, valLen, CharsetNames.UTF_8);\n        // Defensive: If value ends with NL, drop it\n        if (!value.isEmpty() && value.charAt(value.length() - 1) == '\\n') {\n            value = value.substring(0, value.length() - 1);\n        }\n        if (valLen == 0) {\n            headers.remove(keyword);\n        } else {\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}