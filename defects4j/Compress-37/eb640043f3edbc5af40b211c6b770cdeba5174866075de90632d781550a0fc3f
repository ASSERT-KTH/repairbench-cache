{
    "generation": "Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n    final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n    // Format is \"length keyword=value\\n\";\n    while (true) { // get length\n        int ch;\n        int len = 0;\n        int read = 0;\n        boolean foundDigit = false;\n        // Read digits for the length\n        while ((ch = i.read()) != -1) {\n            read++;\n            if (ch == ' ') {\n                break;\n            }\n            if (ch == '\\n' || ch == '\\r') {\n                // Malformed or blank line, skip it\n                // (skip to next newline)\n                while (ch != -1 && ch != '\\n') {\n                    ch = i.read();\n                }\n                break;\n            }\n            if (ch < '0' || ch > '9') {\n                // Malformed length specifier, skip this line\n                while (ch != -1 && ch != '\\n') {\n                    ch = i.read();\n                }\n                break;\n            }\n            foundDigit = true;\n            len *= 10;\n            len += ch - '0';\n        }\n        if (ch == -1) { // EOF\n            break;\n        }\n        if (!foundDigit) {\n            // No number read; ignore blank/malformed line\n            continue;\n        }\n        // reached space after length, now read the rest\n        // If length is less than read so far, skip this malformed header\n        if (len < read || len <= 0) {\n            // Skip the remainder of the line\n            int skipLen = 0;\n            while (skipLen < 1000 && i.read() != -1) { // avoid infinite loops\n                skipLen++;\n            }\n            continue;\n        }\n        final int keywordAndValueLen = len - read;\n        final byte[] keywordAndValue = new byte[keywordAndValueLen];\n        final int got = IOUtils.readFully(i, keywordAndValue);\n        if (got != keywordAndValueLen) {\n            throw new IOException(\"Failed to read Paxheader. Expected \"\n                                  + keywordAndValueLen\n                                  + \" bytes, read \"\n                                  + got);\n        }\n        // keywordAndValue contains: keyword=value\\n\n        // Find '=' separator\n        int eq = -1;\n        for (int k = 0; k < keywordAndValueLen; k++) {\n            if (keywordAndValue[k] == '=') {\n                eq = k;\n                break;\n            }\n        }\n        if (eq == -1) {\n            // Malformed header, skip\n            continue;\n        }\n        final String keyword = new String(keywordAndValue, 0, eq, CharsetNames.UTF_8);\n        // strip newline from end\n        int end = keywordAndValueLen;\n        if (end > 0 && keywordAndValue[end-1] == '\\n') {\n            end--;\n        }\n        String value = new String(keywordAndValue, eq + 1, end - (eq + 1), CharsetNames.UTF_8);\n        if (value.length() == 0) {\n            headers.remove(keyword);\n        } else {\n            headers.put(keyword, value);\n        }\n    }\n    return headers;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}