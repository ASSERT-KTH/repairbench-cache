{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n\n        // This set will hold names of properties that should be completely ignored\n        // for deserialization (i.e., not processed, not added to builder as a settable property,\n        // and skipped if found in input JSON).\n        // A property is ignored for deserialization if:\n        // 1. It is explicitly ignored by annotation (e.g., @JsonIgnore on field/setter, or class-level @JsonIgnoreProperties).\n        // 2. OR, it has no valid deserialization accessor (setter or field).\n        // It does NOT include properties where only the getter is @JsonIgnore'd but a setter/field exists and is not ignored.\n        Set<String> ignoredForDeserialization = new HashSet<>();\n        \n        // This set temporarily holds all property names that are explicitly marked ignored\n        // by any annotation (e.g., @JsonIgnore on ANY accessor, or class-level @JsonIgnoreProperties).\n        Set<String> allExplicitlyIgnoredNames = Collections.emptySet(); \n        \n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            allExplicitlyIgnoredNames = ignorals.getIgnored(); // This includes names like \"name\" from @JsonIgnore on getName()\n        }\n\n        List<BeanPropertyDefinition> allProps = beanDesc.findProperties();\n\n        for (BeanPropertyDefinition propDef : allProps) {\n            final String propName = propDef.getName();\n            \n            // If this property name is explicitly ignored by annotation on any accessor or class-level\n            if (allExplicitlyIgnoredNames.contains(propName)) {\n                // [databind#1595] Specific case: @JsonIgnore on getter, but setter exists and is not ignored.\n                // In this scenario, the property should NOT be ignored for deserialization\n                // by means of filtering its BeanPropertyDefinition or by being added to builder.addIgnorable.\n                \n                boolean hasValidSetter = propDef.hasSetter()\n                                      && !propDef.getSetter().hasAnnotation(com.fasterxml.jackson.annotation.JsonIgnore.class);\n                boolean hasValidField = propDef.hasField()\n                                      && !propDef.getField().hasAnnotation(com.fasterxml.jackson.annotation.JsonIgnore.class);\n                \n                if (hasValidSetter || hasValidField) {\n                    // This property has a valid setter/field (which is not @JsonIgnore'd itself),\n                    // so it should NOT be ignored for deserialization.\n                    // Do nothing, i.e., don't add it to `ignoredForDeserialization`.\n                } else {\n                    // This property is explicitly ignored AND has no valid deserialization accessor,\n                    // or its accessors are also ignored. So, it should be truly ignored for deserialization.\n                    ignoredForDeserialization.add(propName);\n                }\n            }\n        }\n        \n        // Add names from our derived `ignoredForDeserialization` set to builder's ignorable list.\n        // These are properties that, if encountered in JSON, should be completely skipped during deserialization.\n        for (String propName : ignoredForDeserialization) {\n            builder.addIgnorable(propName);\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        \n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        // This block adds properties that are implicitly ignored (e.g., via `@JsonIgnore` on specific members\n        // which might not be covered by class-level `ignorals` or if `ignorals` is null).\n        // We must ensure that properties we want to deserialize (like 'name' in test case) are not added here.\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignoredFromDesc = beanDesc.getIgnoredPropertyNames();\n            if (ignoredFromDesc != null) {\n                for (String propName : ignoredFromDesc) {\n                    // Only add to builder.addIgnorable if it's truly ignored for deserialization,\n                    // as determined by our `ignoredForDeserialization` set.\n                    // This prevents adding names like \"name\" (where only getter is ignored but setter is valid)\n                    // to the ignorable list, which would cause them to be skipped during deserialization.\n                    if (ignoredForDeserialization.contains(propName)) {\n                       builder.addIgnorable(propName);\n                    }\n                }\n            }\n        }\n        \n        // Ok: let's then filter out property definitions.\n        // We pass our refined `ignoredForDeserialization` set to ensure correct filtering.\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, allProps, ignoredForDeserialization);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS; // Assuming NO_VIEWS is a predefined constant\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}