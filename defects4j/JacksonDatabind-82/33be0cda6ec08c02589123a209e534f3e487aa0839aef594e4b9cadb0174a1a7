{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        // 11-Jun-2020, tatu: Need to be careful considering possible merge/override\n        //    of value instantiator, with one possibly having different creator properties.\n        // TODO: Verify that we do use the correct one...\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // Properties from annotations (`@JsonIgnoreProperties`)\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        // Note: could also consider `beanDesc.getIgnoredPropertyNames()` maybe?\n        Set<String> ignoredByAnnot; // Names of properties explicitly ignored by annotations\n        if (ignorals != null) {\n            builder.setIgnoreUnknownProperties(ignorals.getIgnoreUnknown());\n            ignoredByAnnot = ignorals.getIgnored();\n            for (String propName : ignoredByAnnot) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignoredByAnnot = Collections.emptySet();\n        }\n\n        // Any setter handling: find method OR field -- prior to filtering props?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        // new in 2.9: support for field-based any setter\n        // NOTE! Must include field \u0905\u0928\u094d setter, if any, since they are not mutually exclusive\n        AnnotatedMember anySetterField = beanDesc.findAnySetterField();\n\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        } else if (anySetterField != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        }\n\n        // Need properties collected BEFORE filtering, to know what is potentially ignorable\n        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n\n        // Implicitly ignored properties (@JsonIgnore): only add if STILL not findable\n        // (via setter/field/constructor/getter-as-setter) AND there's no AnySetter.\n        // This is needed to avoid ignoring properties that are ignored for serialization\n        // but have a setter for deserialization. [databind#1595], [databind#1811]\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignoredViaMarker = beanDesc.getIgnoredPropertyNames();\n            if (ignoredViaMarker != null && !ignoredViaMarker.isEmpty()) {\n                HashSet<String> ignoredSet = new HashSet<>(ignoredViaMarker);\n                // Remove any ignored names that are handled by a setter, field, creator, or getter-as-setter\n                for (BeanPropertyDefinition propDef : properties) {\n                     String name = propDef.getName();\n                     if (ignoredSet.contains(name)) {\n                         // If it has a recognized mutator OR is a getter-as-setter, DO NOT ignore\n                         if (propDef.hasSetter() || propDef.hasField() || propDef.hasConstructorParameter()) {\n                            ignoredSet.remove(name);\n                         } else if (propDef.hasGetter()) {\n                            // Need to check if this getter can act as setter\n                             AnnotatedMethod getter = propDef.getGetter();\n                             // Check added for safety, see getter-as-setter logic below\n                             if (getter != null) {\n                                 Class<?> rawPropertyType = getter.getRawType();\n                                 if (Collection.class.isAssignableFrom(rawPropertyType)\n                                         || Map.class.isAssignableFrom(rawPropertyType)) {\n                                     // This is a potential getter-as-setter, don't ignore\n                                     ignoredSet.remove(name);\n                                 }\n                             }\n                         }\n                     }\n                }\n                // Add properties that are left over (implicitly ignored AND not handled) to ignorable set\n                for (String propName : ignoredSet) {\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Filter properties according to filtering rules (explicit ignoral by annotation, visibility)\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, properties, ignoredByAnnot);\n\n        // Apply modifiers\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // And then create properties for the builder\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            // Creator properties override others, but need linking (fallback) so process others first.\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                // Handle Collection/Map getters as setters if enabled\n                AnnotatedMethod getter = propDef.getGetter();\n                // Safety check: getter might be null if annotation applied to non-getter/setter/field member\n                if (getter != null) {\n                    Class<?> rawPropertyType = getter.getRawType();\n                    if (Collection.class.isAssignableFrom(rawPropertyType)\n                            || Map.class.isAssignableFrom(rawPropertyType)) {\n                        prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                    }\n                }\n            }\n\n            // [databind#318]: Make sure we include constructor parameters; they take precedence\n            // Also: no point attempting if bean is abstract\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        // Could perhaps require equality of names? Or check alias? For now, name is fine\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                // Should have creator property... mostly. Error if not? Let's assume ok for now\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    // Ensure creatorProps is not null before iterating\n                    if (creatorProps != null) {\n                        for (SettableBeanProperty cp : creatorProps) {\n                            n.add(cp.getName());\n                        }\n                    }\n                    // Report error if creator property not found, and skip this property def\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue; // Crucial: skip processing this property definition further\n                }\n\n                // If regular property (setter/field/getter-as-setter) was also found, link as fallback\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                 // And we MUST use the CreatorProperty if found\n                prop = cprop;\n                // [databind#631]: Assign index AND add CreatorProperty to builder\n                builder.addCreatorProperty(prop);\n                // We are done with this property, do NOT add via regular path\n                continue; // IMPORTANT: continue to next property definition\n            }\n\n            // Otherwise, if we got a non-creator property, add it\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS; // Assume NO_VIEWS is a static final empty Class array\n                    }\n                }\n                // one more thing before adding to builder: copy view information\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}