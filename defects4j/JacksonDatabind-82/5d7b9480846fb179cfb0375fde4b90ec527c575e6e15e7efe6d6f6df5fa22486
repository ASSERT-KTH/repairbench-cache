{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        // 29-Sep-2014, tatu: Need to ensure we have constructor parameters available.\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMember anySetter = beanDesc.findAnySetterAccessor(); // fld/method\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        } else {\n            // keep track of explicitly ignored properties\n            // 22-Jun-2017, tatu: As per [databind#1595], need to ensure we will keep setter/field info even if getter is ignored\n            Collection<String> ignoredPropts = beanDesc.getIgnoredPropertyNames();\n            if (ignoredPropts != null) {\n                for(String propName : ignoredPropts) {\n                    // note: this is ALWAYS addition, intersection of Introspector/AnnotationIntrospector results\n                     builder.addIgnorable(propName);\n                 }\n            }\n        }\n\n        // Do we have Shape specification that requires converting array to properties?\n        // 10-Jun-2016, tatu: Only applicable to classes, not interfaces/abstract types\n        final boolean isCaseInsensitive = ctxt.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n\n        // Ok: let's then filter out property definitions\n        // 22-Jun-2017, tatu: Need to be careful, couldDeserialize() check is NOT enough\n        //    to know if we have implicit/explicit ignoral. So need separate check...\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n\n            // Does it have setter? Or field? Or... ?\n            // 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n            //   we need to do linkage (as per [databind#318]), and so need to start with\n            //   other types, and only then create constructor parameter, if any.\n            AnnotatedMethod setter = propDef.getSetter();\n            if (setter != null) {\n                JavaType propertyType = setter.getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else {\n                AnnotatedField field = propDef.getField();\n                if (field != null) {\n                    JavaType propertyType = field.getType();\n                    prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n                } else {\n                    // A primary \"setter\" is the thing for actual collection/map values.\n                    // But secondary is also possible, if we could use \"getters-as-setters\".\n                    AnnotatedMethod getter = propDef.getGetter();\n                    if (getter != null) {\n                        if (useGettersAsSetters) {\n                            /* May also need to consider getters\n                             * for Map/Collection properties; but with lowest precedence\n                             */\n                            // should only consider Collections and Maps, for now?\n                            Class<?> rawPropertyType = getter.getRawType();\n                            if (Collection.class.isAssignableFrom(rawPropertyType)\n                                    || Map.class.isAssignableFrom(rawPropertyType)) {\n                                prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // [databind#1595]: Need to ensure we consider creator properties this late as well...\n            // Also: [databind#1328]: Make sure we include creator props for abstract types too!\n//            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n            if (propDef.hasConstructorParameter()) {\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                // should not be null; creator property must be passed (or exception)\n                if (cprop == null) {\n                    // 10-Jun-2016, tatu: Let's double-check using internal name as well:\n                    //    possibly we have mismatch in renaming? Or case-insensitivity needs reconciling?\n                    if (!ctxt.isEnabled(MapperFeature.FAIL_ON_INVALID_SUBTYPE)) { // [databind#2172]\n                        // For error message, use external name, then internal name, finally available creator names\n                        final String intName = propDef.getInternalName();\n                        for (SettableBeanProperty cp : creatorProps) {\n                            if (intName.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                                cprop = (CreatorProperty) cp;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (cprop == null) {\n                        // Let's consider case-insensitivity as well...\n                        if (isCaseInsensitive) {\n                            for (SettableBeanProperty cp : creatorProps) {\n                                if (name.equalsIgnoreCase(cp.getName()) && (cp instanceof CreatorProperty)) {\n                                    cprop = (CreatorProperty) cp;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if (cprop == null) {\n                        // 23-Mar-2017, tatu: Should this be an error? For now, becomes issue with\n                        //    [databind#1513], wherein `prop` might be null...\n                        // 25-Jul-2017, tatu: As per [databind#1647], needs to be reported unless trying to ignore unknown props\n                        // Let's also add bit more diagnostics for [databind#1694]\n                        List<String> n = new ArrayList<>();\n                        for (SettableBeanProperty cp : creatorProps) {\n                            n.add(cp.getName());\n                        }\n                        ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                                \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                                name, n);\n                        continue;\n                    }\n                }\n                // If we have both creator prop and regular, make latter fallback\n                if (prop != null) {\n                    // [databind#1431]: better ensure we have back-reference information available\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                // regardless of property being created, need to know about existence\n                // for purpose of handling back-references\n                continue;\n            }\n\n            // Otherwise, is it a regular property? needs name, type, mutator\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}