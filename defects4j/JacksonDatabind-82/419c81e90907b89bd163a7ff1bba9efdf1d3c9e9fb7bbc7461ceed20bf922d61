{
    "generation": "    /**\n     * Method called to figure out settable properties for the\n     * bean deserializer to use.\n     *<p>\n     * Note: designed to be overridable, and effort is made to keep interface\n     * similar between versions.\n     */\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        // 26-Oct-2015, tatu: Take into account possible defaults via `ValueInstantiator`\n        final ValueInstantiator valueInstantiator = builder.getValueInstantiator();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? valueInstantiator.getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        // 08-Mar-2017, tatu: Looks like this was wrong place to add this... moved\n        //   to `PropertyNamingStrategy`. See [databind#1541] for details.\n\n        // 18-Aug-2017, tatu: As per [databind#1728] need PropertyNamingStrategy from config\n        // 19-Aug-2017, tatu: Need ClassIntrospector.MixInResolver for Class info too. Fixed.\n\n        // 03-Feb-2018, tatu: as per [databind#1898], need to consider class annotations based on\n        //    bean type NOT bean class... mostly relevant for abstract types/impls\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getType().getRawClass(), // [databind#1898]\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        // 17-Oct-2016, tatu: Needs to be `AnnotatedMember` to support fields too\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        // If not method, maybe field?\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n\n        // [databind#1595]: remove logic that implicitly ignored properties based on @JsonIgnore\n        // on getters (or other non-setter members). Ignoral should be checked specifically\n        // against the setter/field used for deserialization. Class-level @JsonIgnoreProperties\n        // and @JsonIgnore on the specific setter/field ARE still considered.\n        /*\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetterMethod == null && anySetterField == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        */\n\n        // Finally: maybe we need to force ignoring of unknown properties?\n        // (note: this is different from ignoring known properties)\n        // 08-Nov-2015, tatu: Let's not force ignoring of unknown properties if there is\n        //    an \"any setter\"\n        if ((anySetterMethod == null) && (anySetterField == null)) {\n            boolean ignoreAny = ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n            if (ignoreAny) {\n                // 28-Jul-2020, tatu: Need to allow explicit enabling too...\n                final Set<String> explicitIgnores = builder.getIgnorablePropertyNames();\n                if (!explicitIgnores.isEmpty()) {\n                    // note: `explicitIgnores` passed is Sets.newHashSet(ignored); a mutable copy\n                    // also need copy of `propDefs` in case `mod.updateProperties()` returns same\n                    for (BeanPropertyDefinition propDef : builder.getPropertyDefs()) {\n                        explicitIgnores.remove(propDef.getName());\n                    }\n                    for (String name : explicitIgnores) {\n                        builder.addIgnorable(name);\n                    }\n                }\n            }\n        }\n\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        // 29-Aug-2017, tatu: As per [databind#1728] pass `propDefs` here too\n        // 27-Jun-2019, tatu: Use new method `filterBeanPropsForDeserialization` [databind#2347]\n        List<BeanPropertyDefinition> propDefs = filterBeanPropsForDeserialization(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n             *   we need to do linkage (as per [databind#318]), and so need to start with\n             *   other types, and only then create constructor parameter, if any.\n             */\n            if (propDef.hasSetter()) {\n                JavaType propertyType = propDef.getSetter().getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                JavaType propertyType = propDef.getField().getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* May also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    // 28-Oct-2011, tatu: [databind#35] Should NOT need to check for Include.ALWAYS;\n                    //   that's for serialization. And we don't need check for setters etc either;\n                    //   this is \"setterless\" property, handled via getter.\n                    // 08-Feb-2017, tatu: Except as per [databind#1501], need to ensure that the\n                    //    property has not been explicitly excluded with `@JsonIgnore` or similar...\n                    // NOTE! `constructSetterlessProperty()` called even for ignored property\n                    //   if there is associated Creator property.\n                    if (!propDef.isExplicitlyIgnored() || propDef.hasConstructorParameter()) {\n                        prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                    }\n                }\n            }\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        // 02-Apr-2014, tatu: Important; match name AND index (or, name OR index?)\n                        // 28-Oct-2015, tatu: Hmm. How to match? By index AND name? Or by index OR name?\n                        //   Need to consider use cases. For now, name is primary, index secondary.\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                // Well, maybe name is not primary? Let's try index?\n                if (cprop == null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (cp.getCreatorIndex() == propDef.getCreatorIndex() && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            // And let's rename this property to match parameter name, assuming it might\n                            // be different, and that constructor parameter definition is primary.\n                            // Need to create a new definition, however\n                            // 10-Jul-2018, tatu: But wait... maybe explicit name override? If so, don't force\n                            if (propDef.hasExplicitName()) {\n                                ;\n                            } else {\n                                propDef = propDef.withName(cp.getName());\n                            }\n                            // 20-Apr-2020, tatu: [databind#2705] also need to ensure property definition\n                            //   name, internal name align... ugh.\n                            //builder.changePropertyName(propDef.getName(), cp.getName());\n                            break;\n                        }\n                    }\n                }\n\n                // still not found? report problem\n                if (cprop == null) {\n                    // 02-Mar-2017, tatu: Improve error reporting, as per [databind#1557]\n                    List<String> n = new ArrayList<>();\n                    int ix = -1;\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                        if (cp.getCreatorIndex() == propDef.getCreatorIndex()) {\n                            ix = cp.getCreatorIndex();\n                        }\n                    }\n                    // 25-May-2019, tatu: Let's try to use a new reporting method; may get improved\n                    //     later on.\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s) or index #%d\",\n                            name, n, propDef.getCreatorIndex());\n                    // 26-Jun-2019, tatu: Should probably skip if we are missing the creator...\n                    continue; // problematic, skip\n                }\n\n                // 26-Oct-2015, tatu: Ensure ValueInstantiator is aware of this constructor property...\n                valueInstantiator.assignIndexesAndNames(Collections.singletonList(cprop), ctxt.getConfig());\n\n                // Ok: then, need to merge information. Or, do we? Seems like it is fine to\n                // just use CreatorProperty in place of the \"regular\" property. Let's try that:\n                // if we had property, copy metadata\n                if (prop != null) {\n                    // 09-Sep-2016, tatu: We must augment this definition with possible Ignoral settings;\n                    //   most likely due to `@JsonIgnore` annotation (but possibly also via config overrides).\n                    // 15-Sep-2017, tatu: ... actually, should perhaps do the other way around...\n                    //   retain explicit definition... ?\n                    // 23-Jun-2018, tatu: And make sure to potentially pass views from creator property too\n                    cprop.setViews(prop.getViews());\n                    cprop.setFallbackSetter(prop);\n                }\n                prop = cprop;\n                builder.addCreatorProperty(cprop);\n                // and whatever the case, continue with creator property\n                continue; // handled everything needed\n            }\n\n            // otherwise, if we got a property, add it\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}