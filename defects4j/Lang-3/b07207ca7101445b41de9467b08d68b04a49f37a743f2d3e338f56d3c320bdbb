{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assumes the following are imported or available in the same class:\n// import org.apache.commons.lang3.StringUtils;\n// Helper methods: createFloat, createDouble, createBigDecimal, createInteger, createLong, createBigInteger\n// Helper method: isDigits (implementation provided below if needed)\n\n\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n\n    // Simplified handling of hex prefixes. Let decode/BigInteger handle parsing.\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\"}; // Standard prefixes\n    int pfxLen = 0; // Detect if string starts with a standard hex prefix.\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen = pfx.length();\n            break;\n        }\n    }\n\n    if (pfxLen > 0 && pfxLen < str.length()) { // Standard hex format (0x/0X/-0x/-0X) followed by digits\n         // Try parsing using decode for Integer/Long, then fallback to BigInteger\n         try {\n             // Integer.decode handles 0x/0X and sign\n             return Integer.decode(str);\n         } catch (final NumberFormatException nfe1) {\n             try {\n                 // Long.decode handles 0x/0X and sign\n                 return Long.decode(str);\n             } catch (final NumberFormatException nfe2) {\n                 // Decode failed, likely too large for Long. Use BigInteger.\n                 String hexStr = str;\n                 boolean isNegative = false;\n                 if (str.startsWith(\"-\")) {\n                     isNegative = true;\n                     hexStr = str.substring(3); // Skip \"-0x\" or \"-0X\"\n                 } else {\n                     hexStr = str.substring(2); // Skip \"0x\" or \"0X\"\n                 }\n                 try {\n                     BigInteger result = new BigInteger(hexStr, 16);\n                     if (isNegative) {\n                         result = result.negate();\n                     }\n                     return result;\n                 } catch (final NumberFormatException nfe3) {\n                      // If BigInteger parsing fails, the format is invalid\n                      throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n             }\n         }\n    }\n\n    // Handle '#' hex format (less common, decode doesn't support)\n    if (str.startsWith(\"#\") && str.length() > 1) {\n        try {\n             return new BigInteger(str.substring(1), 16);\n         } catch (final NumberFormatException nfe) {\n              // BigInteger parsing failed\n              throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n    }\n    if (str.startsWith(\"-#\") && str.length() > 2) {\n         try {\n             return new BigInteger(str.substring(2), 16).negate();\n         } catch (final NumberFormatException nfe) {\n             // BigInteger parsing failed\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n    }\n    // At this point, str is not null, blank, or a recognized hex format.\n\n    final char lastChar = str.charAt(str.length() - 1);\n    final String numeric; // Numeric part without qualifier\n\n    boolean hasQualifier = (lastChar == 'l' || lastChar == 'L' ||\n                          lastChar == 'f' || lastChar == 'F' ||\n                          lastChar == 'd' || lastChar == 'D');\n\n    if (hasQualifier && str.length() > 1) { // Ensure qualifier is not the only char\n        numeric = str.substring(0, str.length() - 1);\n    } else {\n        numeric = str; // No qualifier or qualifier is the only char (invalid)\n        hasQualifier = false; // Treat single char qualifiers as part of the number if not hex/octal\n    }\n\n    final int decPos = numeric.indexOf('.');\n    int expPos = numeric.indexOf('e');\n    if (expPos == -1) {\n        expPos = numeric.indexOf('E');\n    }\n    boolean isDecimals = decPos > -1;\n    boolean hasExp = expPos > -1;\n\n    // Handle L/l qualifier\n    if (hasQualifier && (lastChar == 'l' || lastChar == 'L')) {\n        // Check for invalid characters or format for Long/BigInteger\n        if (isDecimals || hasExp || StringUtils.isEmpty(numeric) || (numeric.charAt(0) == '-' && numeric.length() == 1)) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // Check if numeric part contains only digits (optional leading '-')\n        boolean isValidInteger = (numeric.charAt(0) == '-' ? isDigits(numeric.substring(1)) : isDigits(numeric));\n        if (!isValidInteger) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // Try Long first, then BigInteger\n        try {\n            // Assumes createLong uses Long.valueOf/parseLong which handle decimal strings\n            return createLong(numeric);\n        } catch (final NumberFormatException nfe) {\n            // Assumes createBigInteger uses new BigInteger() which handles decimal strings\n            return createBigInteger(numeric);\n        }\n    }\n\n    // Validate exponent part if present (relevant for F/D and non-qualified)\n    if (hasExp) {\n         if (expPos + 1 >= numeric.length()) { // No digits after 'e'/'E'\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n         String expPart = numeric.substring(expPos + 1);\n         // Check exponent is valid integer (allow leading sign, must have digits)\n         boolean isValidExp = (expPart.charAt(0) == '+' || expPart.charAt(0) == '-') ? isDigits(expPart.substring(1)) : isDigits(expPart);\n         // Also check that it's not just a sign\n         if (!isValidExp || (expPart.length() == 1 && (expPart.charAt(0) == '+' || expPart.charAt(0) == '-'))) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n    }\n\n    // Handle F/f qualifier\n    if (hasQualifier && (lastChar == 'f' || lastChar == 'F')) {\n        try {\n            // Assumes createFloat uses Float.valueOf which parses standard float strings\n            final Float f = createFloat(numeric);\n            // Check for Inf/Zero using BigDecimal signum for robustness against underflow to 0\n            boolean checkZero = f.floatValue() == 0.0F;\n            boolean nonZeroInput = true; // Assume true unless BigDecimal parsing fails or confirms zero\n            if (checkZero) {\n                try {\n                     nonZeroInput = new BigDecimal(numeric).signum() != 0;\n                } catch (NumberFormatException ignore) { /* Invalid format handled below */ }\n            }\n\n            // Return Float if not Inf and not zero unless input was non-zero\n            if (!(f.isInfinite() || (checkZero && nonZeroInput))) {\n                return f;\n            }\n            // If Float is Inf/Zero or NFE, fall through to try Double/BigDecimal as per Javadoc intent\n        } catch (final NumberFormatException nfe) { /* Fall through */ }\n        // Fall through to Double/BigDecimal logic\n    }\n\n    // Handle D/d qualifier or F/f fallthrough\n    if (hasQualifier && (lastChar == 'd' || lastChar == 'D' || lastChar == 'f' || lastChar == 'F')) {\n         try {\n            // Assumes createDouble uses Double.valueOf\n            final Double d = createDouble(numeric);\n            boolean checkZero = d.doubleValue() == 0.0D;\n            boolean nonZeroInput = true;\n            if (checkZero) {\n                 try {\n                      nonZeroInput = new BigDecimal(numeric).signum() != 0;\n                 } catch (NumberFormatException ignore) { /* Invalid format handled below */ }\n            }\n            // Return Double if not Inf and not zero unless input was non-zero\n            if (!(d.isInfinite() || (checkZero && nonZeroInput))) {\n                return d;\n            }\n             // If Double is Inf/Zero or NFE, fall through to try BigDecimal\n        } catch (final NumberFormatException nfe) { /* Fall through */ }\n         // Try BigDecimal as a last resort for qualified D/d/F/f\n         try {\n             // Assumes createBigDecimal uses new BigDecimal()\n             return createBigDecimal(numeric);\n         } catch (final NumberFormatException e) {\n             // If even BigDecimal fails for an explicitly qualified number, it's invalid.\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n    }\n\n    // No qualifier: Infer type based on presence of '.', 'e'/'E' and magnitude\n    if (!isDecimals && !hasExp) { // Potential integer type\n        // Check for octal '0' prefix (ensure not '0' alone, not hex)\n        if (str.startsWith(\"0\") && str.length() > 1) {\n            boolean isOctal = true;\n            for (int i = 1; i < str.length(); i++) {\n                char c = str.charAt(i);\n                if (c < '0' || c > '7') {\n                    isOctal = false;\n                    break;\n                }\n            }\n             if (isOctal) {\n                 try {\n                     // Use decode for octal interpretation (handles sign and range)\n                      try {\n                         return Integer.decode(str);\n                     } catch (NumberFormatException nfe1) {\n                          try {\n                             return Long.decode(str);\n                         } catch (NumberFormatException nfe2) {\n                              // decode failed (likely too large), try BigInteger octal parsing\n                             if (str.startsWith(\"-\"))\n                                 // Handle negative octal like \"-0123\"\n                                 return new BigInteger(\"-\" + str.substring(2), 8);\n                             else\n                                 return new BigInteger(str.substring(1), 8); // Handle positive octal like \"0123\"\n                         }\n                     }\n                 } catch (final NumberFormatException ex) {\n                      // Javadoc: \"Integral values with a leading 0 will be interpreted as octal\"\n                      // This implies failure if it looks octal but isn't valid.\n                      throw new NumberFormatException(\"Cannot parse \" + str + \" as octal\");\n                 }\n             }\n             // If not valid octal (e.g., \"09\"), treat as decimal below.\n        }\n        // Standard decimal integer parsing: try Integer -> Long -> BigInteger\n        try {\n            // Assumes createInteger uses Integer.valueOf/parseInt for decimal\n            return createInteger(str);\n        } catch (final NumberFormatException nfe) { /* ignore */ }\n        try {\n            // Assumes createLong uses Long.valueOf/parseLong for decimal\n            return createLong(str);\n        } catch (final NumberFormatException nfe) { /* ignore */ }\n        // Assumes createBigInteger uses new BigInteger() for decimal\n        return createBigInteger(str); // Let BigInteger throw NFE if invalid format\n\n    } else { // Potential floating point type (has '.' or 'e'/'E')\n         // Try Float -> Double -> BigDecimal using the Inf/Zero check\n         try {\n             // Use full original string 'str' for floating point types\n             final Float f = createFloat(str);\n             boolean checkZero = f.floatValue() == 0.0F;\n             boolean nonZeroInput = true;\n             if (checkZero) {\n                  try {\n                       nonZeroInput = new BigDecimal(str).signum() != 0;\n                  } catch (NumberFormatException ignore) { /* Invalid format handled by createBigDecimal below */ }\n             }\n             // Return Float if valid (not Inf, not zero unless input was zero)\n             if (!(f.isInfinite() || (checkZero && nonZeroInput))) {\n                 return f;\n             }\n         } catch (final NumberFormatException nfe) { /* ignore, try Double */ }\n\n         try {\n             final Double d = createDouble(str);\n             boolean checkZero = d.doubleValue() == 0.0D;\n             boolean nonZeroInput = true;\n             if (checkZero) {\n                  try {\n                       nonZeroInput = new BigDecimal(str).signum() != 0;\n                  } catch (NumberFormatException ignore) { /* Invalid format handled by createBigDecimal below */ }\n             }\n             // Return Double if valid (not Inf, not zero unless input was zero)\n             if (!(d.isInfinite() || (checkZero && nonZeroInput))) {\n                return d;\n             }\n         } catch (final NumberFormatException nfe) { /* ignore, try BigDecimal */ }\n\n         // Fallback to BigDecimal for implicit floating point numbers\n         return createBigDecimal(str); // Let BigDecimal throw NFE if invalid format\n    }\n}\n\n/**\n * Checks if the String contains only digit characters.\n * Null or empty Strings return false.\n * Assumes Character.isDigit handles Unicode digits appropriately if required.\n * @param str the String to check\n * @return true if str contains only digit characters\n */\nprivate static boolean isDigits(final String str) {\n    if (StringUtils.isEmpty(str)) {\n        return false;\n    }\n    for (int i = 0; i < str.length(); i++) {\n        if (!Character.isDigit(str.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Assume necessary helper methods like createFloat, createDouble, etc., exist elsewhere in NumberUtils.\n// Assume StringUtils is available.",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}