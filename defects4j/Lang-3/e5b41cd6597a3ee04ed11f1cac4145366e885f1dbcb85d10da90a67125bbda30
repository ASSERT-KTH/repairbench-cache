{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assume this class is org.apache.commons.lang3.math.NumberUtils\n// Assume necessary helper methods (createFloat, createDouble, etc.) and StringUtils are available.\npublic class NumberUtilsFixed {\n\n    // Place dummy helper methods here for context if needed, or assume they exist in the actual NumberUtils class.\n    // e.g.\n    private static Float createFloat(String str) { return Float.valueOf(str); }\n    private static Double createDouble(String str) { return Double.valueOf(str); }\n    private static Integer createInteger(String str) { return Integer.decode(str); } // Use decode for hex/octal\n    private static Long createLong(String str) { return Long.decode(str); } // Use decode for hex/octal\n    private static BigInteger createBigInteger(String str) {\n        int radix = 10;\n        int pfxLen = 0;\n        boolean isNegative = str.startsWith(\"-\");\n        if (isNegative) pfxLen++;\n\n        if (str.substring(pfxLen).startsWith(\"0x\") || str.substring(pfxLen).startsWith(\"0X\")) {\n            radix = 16; pfxLen += 2;\n        } else if (str.substring(pfxLen).startsWith(\"#\")) {\n            radix = 16; pfxLen += 1;\n        } else if (str.substring(pfxLen).startsWith(\"0\") && str.length() > pfxLen + 1) {\n            // Check next char isn't '.' for octal interpretation\n            char nextChar = str.charAt(pfxLen + 1);\n            if (nextChar != '.' && Character.isDigit(nextChar)) {\n                radix = 8; // No prefix length increase needed for octal '0'\n            }\n        }\n        // Use BigInteger constructor that handles radix and sign separately for robustness\n        BigInteger val = new BigInteger(str.substring(pfxLen), radix);\n        return isNegative ? val.negate() : val;\n    }\n    private static BigDecimal createBigDecimal(String str) { return new BigDecimal(str); }\n    private static boolean isDigits(String str) {\n        if (org.apache.commons.lang3.StringUtils.isEmpty(str)) return false;\n        for (char c : str.toCharArray()) { if (!Character.isDigit(c)) return false; }\n        return true;\n    }\n    private static boolean isAllZeros(String str) {\n        if (org.apache.commons.lang3.StringUtils.isEmpty(str)) {\n            return true; // Treat null/empty mantissa/exponent as zeros\n        }\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            // Allow sign character at the start\n            if (i == 0 && (c == '-' || c == '+')) {\n                if (str.length() == 1) return false; // String contains only sign\n                continue;\n            }\n            if (c != '0') {\n                return false;\n            }\n        }\n        return true; // Found only zeros (and potentially a sign)\n    }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>, returning the smallest type that can represent\n     * the value accurately (this checks for precision loss in addition to magnitude).\n     * </p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigInteger as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        // lang-3 requirement below requires StringUtils dependency\n        if (org.apache.commons.lang3.StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n             // Hex parsing needs careful handling of length limits for Integer/Long\n             // Let createX methods handle range checks. Rely on length as a rough guide.\n            char firstSigDigit = 0; // Check first significant digit after prefix and sign\n            int hexDigits = 0;\n            boolean nonZeroDigitFound = false;\n             for(int i = pfxLen; i < str.length(); i++) {\n                 char c = str.charAt(i);\n                 if (Character.digit(c, 16) == -1) { // Make sure rest is hex digits\n                     throw new NumberFormatException(str + \" is not a valid hexadecimal number.\");\n                 }\n                 if (c != '0' && !nonZeroDigitFound) {\n                     firstSigDigit = c;\n                     nonZeroDigitFound = true;\n                 }\n                 if (nonZeroDigitFound) {\n                     hexDigits++;\n                 }\n             }\n             // If only zeros were found after prefix (e.g., \"0x000\"), hexDigits is 0. Treat as 1 digit ('0').\n             if (!nonZeroDigitFound && str.length() > pfxLen) {\n                 hexDigits = 1; // Represents the number 0\n                 firstSigDigit = '0';\n             }\n\n\n            if (hexDigits > 16) {\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) {\n                try { // Try Long first\n                    return createLong(str);\n                } catch (final NumberFormatException e) { // NOPMD If Long fails (e.g. exactly Long.MAX_VALUE + 1 as hex)\n                    return createBigInteger(str); // Fallback to BigInteger\n                }\n            }\n            // Can be Integer, Long, or BigInteger\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException e) { // NOPMD\n                 // Fallback below\n            }\n             try {\n                 return createLong(str);\n             } catch (final NumberFormatException e) { // NOPMD\n                  // Fallback below\n             }\n            // Safest fallback for hex is BigInteger if others fail range checks\n            return createBigInteger(str);\n        }\n\n        // Non-hex handling\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n\n        // Validate exponent presence and format\n        if (expPos > -1) {\n             if (expPos > str.length()) { // Prevent IOOBE\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             if (expPos + 1 >= str.length()) { // Exponent 'e'/'E' cannot be the last character\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             char charAfterExp = str.charAt(expPos + 1);\n              // Character after 'e'/'E' must be sign or digit, unless it's the type suffix at the very end\n             if (charAfterExp != '+' && charAfterExp != '-' && !Character.isDigit(charAfterExp)) {\n                  // If it's a letter, it must be the type suffix and only appear at the end\n                  if (!Character.isLetter(charAfterExp) || expPos != str.length() - 2) {\n                       throw new NumberFormatException(str + \" is not a valid number.\");\n                   }\n             }\n        }\n\n        // Parse mantissa, decimal, and exponent parts\n        if (decPos > -1) { // there is a decimal point\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos || expPos >= str.length()) { // Check order and bounds\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else { // No exponent\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else { // No decimal point\n            if (expPos > -1) { // There is an exponent\n                if (expPos >= str.length()) { // Already checked above\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else { // No decimal, no exponent\n                mant = str; // Complete string is mantissa (potentially with suffix)\n            }\n            dec = null; // No decimal part found\n        }\n\n        // Check for type suffix L,l, F,f, D,d\n        if (Character.isLetter(lastChar) && lastChar != 'e' && lastChar != 'E') {\n             // Extract exponent string correctly, excluding the suffix\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n                 exp = null;\n             }\n\n            final String numeric = str.substring(0, str.length() - 1); // String without suffix\n            // Adjust mantissa if it inadvertently included the suffix (no dec, no exp case)\n            if (decPos == -1 && expPos == -1) {\n                mant = numeric;\n            }\n             // Determine if the numeric part was effectively zero\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // Valid only if the original string structure (before suffix removal) looked like an integer\n                    if (dec == null && exp == null &&\n                        (numeric.isEmpty() || // Allow \"-L\"? No, blank handled earlier. isDigits handles empty check.\n                         numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (final NumberFormatException nfe) { // NOPMD\n                            // Fallback for values outside Long range\n                            return createBigInteger(numeric);\n                        }\n                    }\n                    // Invalid format like \"1.2L\" or \"1e5L\"\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = createFloat(numeric);\n                        // Check magnitude only for suffixed types (infinity or underflow to zero)\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                             return f; // Return Float as requested if magnitude is okay\n                        }\n                        // Fall through if check fails, try larger types per Javadoc\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                         // Fall through if parsing 'numeric' as Float fails\n                    }\n                    // $FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                     try {\n                         final Double d = createDouble(numeric);\n                         // Check magnitude only for suffixed types\n                         if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                             return d; // Return Double as requested (or from F fallback) if magnitude okay\n                         }\n                         // Fall through if check fails\n                     } catch (final NumberFormatException nfe) { // NOPMD\n                          // Fall through if parsing 'numeric' as Double fails\n                     }\n                    // $FALL-THROUGH$\n                 default : // Handles fall-through from F/f and D/d, and invalid suffixes\n                     try {\n                         // Try BigDecimal on the 'numeric' string as last resort for F/D or if suffix was invalid\n                         return createBigDecimal(numeric);\n                     } catch (final NumberFormatException e) { // NOPMD\n                         // Invalid suffix or numeric part not parseable by BigDecimal\n                         throw new NumberFormatException(str + \" is not a valid number.\");\n                     }\n            }\n        } // End of suffix handling\n\n        // No suffix case:\n        // Extract exponent string using full string length\n        if (expPos > -1 && expPos < str.length()) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n\n        if (dec == null && exp == null) { // No decimal, no exponent -> Integer types\n            // Handle octal prefix '0' (but not '0.' or just '0')\n            if (str.charAt(0) == '0' && str.length() > 1) {\n                 char secondChar = str.charAt(1);\n                 // Check if it looks like octal (digit 0-7)\n                 if (Character.digit(secondChar, 8) != -1) {\n                      try {\n                          // Use Long.decode for octal, check range for Integer\n                          Long val = Long.decode(str);\n                          if (val.longValue() >= Integer.MIN_VALUE && val.longValue() <= Integer.MAX_VALUE) {\n                              return Integer.valueOf(val.intValue());\n                          }\n                          return val;\n                      } catch (NumberFormatException nfe) { // NOPMD\n                           // Invalid octal (\"09\") or too big for Long. Fallback to BigInteger.\n                      }\n                 }\n                 // If not octal-like ('0.', '0x' handled earlier), treat as decimal Integer/Long/BigInteger below.\n            }\n\n             // Default to standard Integer/Long/BigInteger parsing\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n             // Handles decimal, failed octal (e.g. \"09\"), large numbers\n            return createBigInteger(str);\n\n        } else { // Has decimal or exponent -> Floating point types (no suffix)\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                // Try Float first\n                final Float f = createFloat(str);\n                 // Check magnitude AND precision\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    // Use BigDecimal comparison to verify precision.\n                    // Compare BigDecimal value of Float's string representation with BigDecimal value of original string.\n                    if (new BigDecimal(f.toString()).compareTo(new BigDecimal(str)) == 0) {\n                    // Using f.toString() reflects standard Float representation, which is often desired.\n                        return f;\n                    }\n                }\n            } catch (final NumberFormatException nfe) { // NOPMD\n                 // Can be from createFloat or new BigDecimal(str)\n            }\n            try {\n                // Try Double if Float failed or lost precision\n                final Double d = createDouble(str);\n                 // Check magnitude AND precision\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     // Use BigDecimal comparison to verify precision\n                     if (new BigDecimal(d.toString()).compareTo(new BigDecimal(str)) == 0) {\n                        return d;\n                     }\n                }\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // Can be from createDouble or new BigDecimal(str)\n            }\n\n            // Fallback to BigDecimal if Float/Double lose precision or magnitude\n            return createBigDecimal(str);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}