{
    "generation": "import org.apache.commons.lang3.StringUtils;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// The user requested only the fixed function. Assume necessary imports and helper methods exist.\n// We also assume the existence and correctness of isDigits, createFloat, createDouble,\n// createInteger, createLong, createBigInteger, createBigDecimal as per Apache Commons Lang context.\n\npublic static Number createNumber(final String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int pfxLen = 0;\n    for(final String pfx : hex_prefixes) {\n        if (str.startsWith(pfx)) {\n            pfxLen = pfx.length();\n            break;\n        }\n    }\n    if (pfxLen > 0) { // we have a hex number\n        // Potentially check for sign character if prefix is just '#' or '-#'?\n        // The current check seems fine if createX methods handle prefixes.\n        final int hexDigits = str.length() - pfxLen;\n        if (hexDigits > 16) { // too many for Long\n            return createBigInteger(str); // Let createBigInteger handle hex parsing\n        }\n        if (hexDigits > 8) { // too many for an int\n            return createLong(str); // Let createLong handle hex parsing\n        }\n        return createInteger(str); // Let createInteger handle hex parsing\n    }\n\n    // Standard number parsing\n    final char lastChar = str.charAt(str.length() - 1);\n    final String mant;\n    final String dec;\n    // final String exp; // Not needed directly, only its presence (expPos) and value for isAllZeros check?\n    final int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e'); // Find first 'e' or 'E'\n    if (expPos == -1) {\n        expPos = str.indexOf('E');\n    }\n\n    // Parse mantissa and decimal part based on '.' and 'e'/'E' positions\n    // This logic seems generally okay, relies on downstream parsing to catch subtle errors like \"1.e\"\n    if (decPos > -1) { // contains decimal point '.'\n        if (expPos > -1) { // also contains 'e' or 'E'\n            if (expPos < decPos) { // 'e'/'E' cannot appear before '.'\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            mant = str.substring(0, decPos);\n            dec = str.substring(decPos + 1, expPos);\n        } else { // contains '.' but no 'e'/'E'\n            mant = str.substring(0, decPos);\n            dec = str.substring(decPos + 1);\n        }\n    } else { // no decimal point '.'\n        if (expPos > -1) { // contains 'e' or 'E' but no '.'\n            mant = str.substring(0, expPos);\n            dec = null; // No decimal part\n        } else { // no '.' and no 'e'/'E' (integer format potentially)\n            mant = str;\n            dec = null;\n        }\n    }\n\n    // Calculate allZeros flag: true if mantissa and decimal part are all zeros (ignoring sign)\n    // This is used to prevent returning Float/Double if they underflow to 0.0 from a non-zero input.\n    boolean allZeros = true;\n    int mantStart = 0;\n    if (mant != null && !mant.isEmpty() && (mant.charAt(0) == '-' || mant.charAt(0) == '+')) {\n        mantStart = 1; // Skip sign character if present\n    }\n    if (mant != null) {\n        for (int i = mant.length() - 1; i >= mantStart; i--) {\n            if (mant.charAt(i) >= '1' && mant.charAt(i) <= '9') {\n                allZeros = false;\n                break;\n            }\n        }\n    }\n    // Check decimal part only if mantissa was all zeros\n    if (allZeros && dec != null) {\n        for (int i = dec.length() - 1; i >= 0; i--) {\n            if (dec.charAt(i) >= '1' && dec.charAt(i) <= '9') {\n                allZeros = false;\n                break;\n            }\n        }\n    }\n\n\n    // Handle type qualifiers (L, F, D) or general number parsing\n    if (!Character.isDigit(lastChar) && lastChar != '.') { // Potential type qualifier\n        final String numeric = str.substring(0, str.length() - 1); // String without suffix\n\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                // Valid Long format: no decimal, no exponent before suffix. Check digits.\n                if (dec == null && expPos == -1\n                    && (numeric.isEmpty() || numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        // Assume createLong handles octal prefix '0' if needed.\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                        // Fallback to BigInteger for overflow. Assume createBigInteger handles octal.\n                        return createBigInteger(numeric);\n                    }\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\"); // Invalid format for L/l suffix\n            case 'f':\n            case 'F':\n                try {\n                    final Float f = createFloat(numeric);\n                    // Use calculated allZeros flag\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f; // Return Float if not infinite and not an underflow-to-zero case\n                    }\n                    // Otherwise (Infinite or zero-underflow), fall through to try larger types\n                } catch (final NumberFormatException nfe) {\n                    // Ignore NFE (e.g., invalid format) and fall through, potentially trying Double/BigDecimal\n                }\n                //$FALL-THROUGH$ intended for overflow/underflow cases, consistent with original code structure\n            case 'd':\n            case 'D':\n                try {\n                    final Double d = createDouble(numeric);\n                    // FIX: Use d.doubleValue() instead of d.floatValue()\n                    // Use calculated allZeros flag\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d; // Return Double if not infinite and not an underflow-to-zero case\n                    }\n                     // Otherwise (Infinite or zero-underflow), fall through to try BigDecimal\n                } catch (final NumberFormatException nfe) {\n                    // Ignore NFE (e.g., invalid format) and fall through to try BigDecimal\n                }\n                // Fall through for D/d suffix if Double failed or resulted in Inf/underflow\n                // Also fall through for F/f suffix here\n                try {\n                    // Use createBigDecimal on the numeric part (without suffix)\n                    return createBigDecimal(numeric);\n                } catch (final NumberFormatException e) {\n                    // If createBigDecimal also fails, the original string with suffix is invalid\n                    // Let this NFE propagate? Or throw the generic one? Original fell through to default.\n                    // Throwing here might be clearer if BD fails after F/D request.\n                    // throw new NumberFormatException(str + \" is not a valid number.\");\n                    // Let's match original code's behavior: fall through if BD fails too.\n                }\n                //$FALL-THROUGH$\n            default:\n                // Invalid suffix character\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n    } else { // No type qualifier (or ends in '.')\n        // Handle integer types (no '.', no 'e'/'E') vs float types\n\n        if (expPos == -1 && decPos == -1) { // Looks like an Integer/Long/BigInteger\n            // Check for octal '0' prefix. Assume createInteger/Long/BigInteger handle it correctly.\n            // (Java standard decode/valueOf methods handle hex \"0x\" and octal \"0\" prefixes)\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) { /* Ignore, try next larger type */ }\n            try {\n                return createLong(str);\n            } catch (final NumberFormatException nfe) { /* Ignore, try next larger type */ }\n            // Final fallback for integer types. Assumes createBigInteger handles decimal/octal.\n            return createBigInteger(str);\n        }\n\n        // Looks like a Float/Double/BigDecimal (has '.' or 'e'/'E')\n        try {\n            final Float f = createFloat(str);\n            // Use calculated allZeros flag\n            if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                return f;\n            }\n        } catch (final NumberFormatException nfe) { /* Ignore, try next larger type */ }\n        try {\n            final Double d = createDouble(str);\n             // FIX: Use d.doubleValue() instead of d.floatValue()\n             // Use calculated allZeros flag\n            if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                return d;\n            }\n        } catch (final NumberFormatException nfe) { /* Ignore, try next larger type */ }\n\n        // Final fallback for float types\n        return createBigDecimal(str);\n    }\n}\n\n// Dummy helper methods assumed to exist in the original class\n// These are needed for the provided code snippet to be complete in isolation.\n// In the actual Apache Commons Lang library, these would be the real implementations.\nprivate static boolean isDigits(String cs) {\n    if (StringUtils.isEmpty(cs)) {\n        return false;\n    }\n    for (int i = 0; i < cs.length(); i++) {\n        if (!Character.isDigit(cs.charAt(i))) {\n            return false;\n        }\n    }\n    return true;\n}\npublic static Float createFloat(final String str) { return Float.valueOf(str); }\npublic static Double createDouble(final String str) { return Double.valueOf(str); }\npublic static Integer createInteger(final String str) { return Integer.decode(str); }\npublic static Long createLong(final String str) { return Long.decode(str); }\npublic static BigInteger createBigInteger(final String str) {\n    int pfxLen = 0;\n    int radix = 10;\n    if (str.startsWith(\"0x\") || str.startsWith(\"0X\")) {\n        pfxLen = 2; radix = 16;\n    } else if (str.startsWith(\"#\")) {\n        pfxLen = 1; radix = 16;\n    } else if (str.startsWith(\"-0x\") || str.startsWith(\"-0X\")) {\n        pfxLen = 3; radix = 16;\n    } else if (str.startsWith(\"-#\")) {\n        pfxLen = 2; radix = 16;\n    } else if (str.startsWith(\"0\") && !str.equals(\"0\") && !str.contains(\".\")) { // Check for octal\n         // Check if it's really octal (only 0-7 digits after leading 0)\n         boolean isOctal = true;\n         int start = str.startsWith(\"-\") ? 2 : 1;\n         for(int i=start; i<str.length(); ++i) {\n             if (str.charAt(i) < '0' || str.charAt(i) > '7') {\n                 isOctal = false;\n                 break;\n             }\n         }\n         if (isOctal) {\n             pfxLen = str.startsWith(\"-\") ? 1 : 0; // Keep sign if present\n             radix = 8;\n         } else {\n            pfxLen = 0; radix = 10; // Treat as decimal if not valid octal like \"09\"\n         }\n    }\n\n    if (pfxLen > 0) {\n        String num = str.substring(pfxLen);\n        BigInteger val = new BigInteger(num, radix);\n        return (str.charAt(0) == '-') ? val.negate() : val;\n    }\n    return new BigInteger(str, radix);\n}\npublic static BigDecimal createBigDecimal(final String str) { return new BigDecimal(str); }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}