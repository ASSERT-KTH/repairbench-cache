{
    "generation": "import org.apache.commons.lang3.StringUtils; // Required import\nimport java.math.BigDecimal; // Required import\nimport java.math.BigInteger; // Required import\n\n// Assume NumberUtils class context and presence/correctness of helper methods:\n// isDigits(String), isAllZeros(String)\n// createInteger(String), createLong(String), createBigInteger(String), createBigDecimal(String)\n// Specifically, createInteger/Long/BigInteger must handle decode (\"0x\", \"#\", \"0\" prefixes) correctly.\n\npublic class NumberUtils { // Renamed class for context, should be the original class name\n\n    // --- Helper Method Placeholders (Implementations Assumed) ---\n    private static boolean isDigits(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isAllZeros(final String str) {\n        if (StringUtils.isEmpty(str)) {\n            return true; // Treat empty as zero for this check\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            char c = str.charAt(i);\n            // Allow 0, sign, and decimal point\n            if (c != '0' && c != '.' && c != '+' && c != '-') {\n                return false;\n            }\n        }\n        // Check that it's not just a sign or just a decimal point\n        if (str.equals(\".\") || str.equals(\"+\") || str.equals(\"-\")) {\n            return false;\n        }\n        return true;\n    }\n\n     private static Integer createInteger(final String str) throws NumberFormatException {\n         // Assumes Integer.decode logic or equivalent prefix handling\n         if (str == null) return null;\n         try { return Integer.decode(str); } catch (NumberFormatException e) { throw new NumberFormatException(str + \" is not a valid number.\"); }\n     }\n\n     private static Long createLong(final String str) throws NumberFormatException {\n         // Assumes Long.decode logic or equivalent prefix handling\n         if (str == null) return null;\n         try { return Long.decode(str); } catch (NumberFormatException e) { throw new NumberFormatException(str + \" is not a valid number.\"); }\n     }\n\n     private static BigInteger createBigInteger(final String str) throws NumberFormatException {\n         // Assumes handles hex (\"0x\", \"#\") and sign correctly\n         if (str == null) return null;\n         int index = 0;\n         int radix = 10;\n         boolean negative = false;\n         if (str.startsWith(\"-\")) {\n             negative = true;\n             index = 1;\n         }\n         if (str.startsWith(\"0x\", index) || str.startsWith(\"0X\", index)) {\n             radix = 16;\n             index += 2;\n         } else if (str.startsWith(\"#\", index)) {\n             radix = 16;\n             index++;\n         } else if (str.startsWith(\"0\", index) && str.length() > index + 1) {\n            // Check if remaining digits are octal\n            boolean isOctal = true;\n            for (int i = index + 1; i < str.length(); i++) {\n                if (str.charAt(i) < '0' || str.charAt(i) > '7') {\n                    isOctal = false;\n                    break;\n                }\n            }\n            if (isOctal) {\n               radix = 8;\n               // Keep index pointing to the '0' as BigInteger(String, radix) expects it.\n               // Or, strip the '0' if the constructor doesn't expect it? Let's assume standard constructor needs only digits.\n               // index++; // Let's assume we strip leading 0 for octal parse\n            } // else, starts with 0 but not octal, treat as decimal (radix 10)\n         }\n\n         if (index >= str.length()) { // Just prefix/sign\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n\n         String numberPart = str.substring(index);\n         try {\n            BigInteger result;\n            if (radix == 8 && numberPart.startsWith(\"0\") && numberPart.length() > 1) {\n                 // Re-check: BigInteger constructor might not handle leading '0' for octal correctly.\n                 // Let's parse assuming it needs digits only.\n                 result = new BigInteger(numberPart, radix);\n            } else {\n                 result = new BigInteger(numberPart, radix);\n            }\n\n            return negative ? result.negate() : result;\n         } catch (NumberFormatException e) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n         }\n     }\n\n\n    private static BigDecimal createBigDecimal(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        // BigDecimal constructor handles decimal format with exponents.\n        // It does not handle hex/octal prefixes. This method should only\n        // be called with valid decimal number strings.\n        try {\n            return new BigDecimal(str);\n        } catch (NumberFormatException e) {\n            // Improve error message?\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer - or Long, if the number of digits after the\n     * prefix is more than 8 - or BigInteger if there are more than 16 digits.\n     * </p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigDecimal as appropriate.\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n\n        // Handle hex format first\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for (final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length();\n                break;\n            }\n        }\n\n        if (pfxLen > 0) {\n             // Ensure there are digits after the prefix\n            if (pfxLen == str.length()) {\n                throw new NumberFormatException(str + \" is not a valid number.\"); // e.g., \"0x\", \"#\"\n            }\n            // Use createX methods which are assumed to handle hex prefixes\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) {\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) {\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n\n        // Not hex. Check for suffix.\n        final char lastChar = str.charAt(str.length() - 1);\n        final String numeric; // String part without suffix\n        final char typeSuffix; // The suffix char (L, F, D) or 0 if none\n\n        // Check if the last character is a valid type suffix and is preceded by a digit or '.'\n        if ((lastChar == 'l' || lastChar == 'L' || lastChar == 'f' || lastChar == 'F' || lastChar == 'd' || lastChar == 'D')\n                && str.length() > 1) {\n            char beforeSuffix = str.charAt(str.length() - 2);\n            if (Character.isDigit(beforeSuffix) || beforeSuffix == '.') {\n                 numeric = str.substring(0, str.length() - 1);\n                 typeSuffix = lastChar;\n            } else {\n                 // Suffix in invalid position (e.g., \"1eL\", \"-F\"), treat string as having no suffix\n                 numeric = str;\n                 typeSuffix = 0;\n            }\n        } else {\n            numeric = str;\n            typeSuffix = 0;\n        }\n\n        // Now parse the 'numeric' string structure to determine format and validate\n        final int decPos = numeric.indexOf('.');\n        int expPos = numeric.indexOf('e');\n        if (expPos == -1) {\n            expPos = numeric.indexOf('E');\n        }\n\n        // Check for floating point format (presence of decimal or exponent)\n        boolean isFloatingPointFormat = (decPos > -1) || (expPos > -1);\n        String mantPart = numeric; // Part before decimal or exponent\n        String decPart = null;     // Part after decimal, before exponent\n        String expPart = null;     // Part after exponent\n\n        // Basic structural validation and parsing of parts for 'allZeros' check\n        if (isFloatingPointFormat) {\n            if (expPos > -1) { // Has exponent\n                if (expPos < decPos /* exponent before decimal */ ||\n                    expPos == 0 /* starts with exponent */ ||\n                    expPos == numeric.length() - 1 /* exponent has no digits */) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                expPart = numeric.substring(expPos + 1);\n                // Check exponent digits\n                char firstCharExp = expPart.charAt(0);\n                String expDigits = (firstCharExp == '+' || firstCharExp == '-') ? expPart.substring(1) : expPart;\n                if (!isDigits(expDigits) || expDigits.isEmpty()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n            }\n\n            if (decPos > -1) { // Has decimal\n                 if (numeric.equals(\".\")) { // String is just \".\"\n                      throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 mantPart = numeric.substring(0, decPos);\n                 decPart = (expPos > -1) ? numeric.substring(decPos + 1, expPos) : numeric.substring(decPos + 1);\n\n                 // Check \".e1\" case (mantissa is empty before exponent)\n                 if (mantPart.isEmpty() && expPos == decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n            } else { // No decimal, but has exponent\n                 mantPart = numeric.substring(0, expPos);\n            }\n        } else {\n             // Not floating point format (integral). Validate it's not just a sign.\n             if (numeric.length() == 1 && (numeric.charAt(0) == '-' || numeric.charAt(0) == '+')) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n             // Further validation handled by createInteger/Long/BigInteger (e.g., non-digits)\n        }\n\n        // Calculate allZeros check based on parsed parts if needed for F/D suffix or non-suffixed float path\n        boolean allZeros = false;\n        if (typeSuffix == 'f' || typeSuffix == 'F' || typeSuffix == 'd' || typeSuffix == 'D' || (typeSuffix == 0 && isFloatingPointFormat)) {\n            allZeros = isAllZeros(mantPart) && isAllZeros(decPart) && isAllZeros(expPart);\n        }\n\n\n        // --- Suffix Logic ---\n        if (typeSuffix != 0) {\n            switch (typeSuffix) {\n                case 'l' :\n                case 'L' :\n                    if (isFloatingPointFormat) { // L suffix requires integral format\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                    // 'numeric' should be a valid integer string (possibly with '0' prefix)\n                    // Let createLong handle range and decode, then fallback to BigInteger\n                    try {\n                        return createLong(numeric);\n                    } catch (final NumberFormatException nfe) {\n                         try {\n                             return createBigInteger(numeric);\n                         } catch (NumberFormatException nfe2) {\n                             throw new NumberFormatException(str + \" is not a valid number.\"); // Rethrow original if both fail\n                         }\n                    }\n\n                case 'f' :\n                case 'F' :\n                    try {\n                        // Use standard Float conversion for 'F' behavior\n                        final Float f = Float.valueOf(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f; // Precision loss acceptable with 'f' suffix\n                        }\n                        // Fall through if Float is infinite or underflowed to zero (per docs: try larger types)\n                    } catch (final NumberFormatException nfe) { /* Fall through if parsing fails */ }\n                    //$FALL-THROUGH$ // Intentional fall-through\n\n                case 'd' :\n                case 'D' :\n                    try {\n                        // Use standard Double conversion for 'D' behavior\n                        final Double d = Double.valueOf(numeric);\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d; // Precision loss acceptable with 'd' suffix\n                        }\n                         // Fall through if Double is infinite or underflowed to zero (per docs: try larger types)\n                    } catch (final NumberFormatException nfe) { /* Fall through if parsing fails */ }\n                    try {\n                        // Final attempt with BigDecimal (handles large numbers)\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) {\n                        // If all attempts fail for suffixed number\n                        throw new NumberFormatException(str + \" is not a valid number.\");\n                    }\n                 default: // Should not happen\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n\n        } // --- End Suffix Logic ---\n\n\n        // --- No Suffix Logic ---\n        if (!isFloatingPointFormat) { // Integral number string\n            // Let createX methods handle potential octal ('0' prefix) via decode\n            try {\n                return createInteger(str); // Use original string\n            } catch (final NumberFormatException nfe) { /* Ignore, try larger type */ }\n            try {\n                return createLong(str); // Use original string\n            } catch (final NumberFormatException nfe) { /* Ignore, try larger type */ }\n             // Final attempt for integral types\n             try {\n                return createBigInteger(str); // Use original string\n             } catch (NumberFormatException nfe_bi) {\n                 throw new NumberFormatException(str + \" is not a valid number.\"); // Rethrow if BigInt fails\n             }\n\n        } else { // Floating point format (has '.' or 'e'/'E') without suffix\n             // Try Float -> Double -> BigDecimal, using original checks\n             try {\n                 final Float f = Float.valueOf(str); // Use original string for parsing\n                 // Check for infinity or zero-from-non-zero\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f; // Return Float if it seems suitable\n                 }\n             } catch (final NumberFormatException nfe) { /* Ignore, try larger type */ }\n\n             try {\n                 final Double d = Double.valueOf(str); // Use original string for parsing\n                  // Check for infinity or zero-from-non-zero\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d; // Return Double if it seems suitable\n                 }\n             } catch (final NumberFormatException nfe) { /* Ignore, try larger type */ }\n\n             // Fallback to BigDecimal for precision or range issues\n             try {\n                 return createBigDecimal(str); // Use original string\n             } catch (final NumberFormatException e){\n                 // If even BigDecimal parsing fails for the original string\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}