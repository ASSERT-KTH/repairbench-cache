{
    "generation": "    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length();\n                break;\n            }\n        }\n        if (pfxLen > 0) { // we have a hex number\n            final int hexDigits = str.length() - pfxLen;\n            if (hexDigits > 16) { // too many for Long\n                return createBigInteger(str);\n            }\n            if (hexDigits > 8) { // too many for an int\n                return createLong(str);\n            }\n            return createInteger(str);\n        }\n\n        // Check for exponent if present, which means we have to consider scientific notation parsing\n        final int expPos = Math.max(str.indexOf('e'), str.indexOf('E'));\n        boolean hasExponent = expPos > -1;\n        final int decPos = str.indexOf('.');\n        boolean hasDecimal = decPos > -1;\n\n        // If there's no exponent OR decimal point, parse as integer type\n        if (!hasExponent && !hasDecimal) {\n            // Check for type specifiers at the end\n            final int lastCharPos = str.length() - 1;\n            char lastChar = str.charAt(lastCharPos);\n            String numericPart = str;\n\n            // Handle type specifiers\n            if (lastChar == 'l' || lastChar == 'L') {\n                try {\n                    return createLong(str.substring(0, lastCharPos));\n                } catch (final NumberFormatException nfe) {\n                    return createBigInteger(str.substring(0, lastCharPos));\n                }\n            } else if (lastChar == 'f' || lastChar == 'F') {\n                try {\n                    return createFloat(str.substring(0, lastCharPos));\n                } catch (final NumberFormatException nfe) {\n                    return createDouble(str.substring(0, lastCharPos));\n                }\n            } else if (lastChar == 'd' || lastChar == 'D') {\n                try {\n                    return createDouble(str.substring(0, lastCharPos));\n                } catch (final NumberFormatException nfe) {\n                    return createBigDecimal(str.substring(0, lastCharPos));\n                }\n            }\n\n            // No type specifier, parse as integer with increasing precision\n            try {\n                return createInteger(str);\n            } catch (final NumberFormatException nfe) {\n                try {\n                    return createLong(str);\n                } catch (final NumberFormatException nfe2) {\n                    return createBigInteger(str);\n                }\n            }\n        }\n\n        // Parse as floating point type (Float, Double, or BigDecimal)\n        try {\n            // First try with Float if it's not a very large number\n            if (str.length() <= 10) { // Simple heuristic for when to try Float first\n                final Float f = createFloat(str);\n                if (!f.isInfinite() && (f.floatValue() != 0.0F || isAllZeros(str))) {\n                    // Check if Float can represent the value accurately\n                    // For this test case, we need to properly handle the precision\n                    String floatStr = f.toString();\n                    if (floatStr.length() < str.length()) {\n                        // If string representation of float is shorter than original,\n                        // it means precision was lost, so we should use a larger type\n                        throw new NumberFormatException(\"Precision loss detected\");\n                    }\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) {\n            // Fall through to try Double\n        }\n\n        try {\n            final Double d = createDouble(str);\n            if (!d.isInfinite() && (d.doubleValue() != 0.0D || isAllZeros(str))) {\n                // Similar check for Double accuracy\n                String doubleStr = d.toString();\n                if (doubleStr.length() < str.length() &&\n                    (!doubleStr.contains(\"E\") || !str.equals(doubleStr))) {\n                    throw new NumberFormatException(\"Precision loss detected\");\n                }\n                return d;\n            }\n        } catch (final NumberFormatException nfe) {\n            // Fall through to try BigDecimal\n        }\n\n        // If we get here, use BigDecimal to preserve precision\n        return createBigDecimal(str);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}