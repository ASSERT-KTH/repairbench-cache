{
    "generation": "    /**\n     * Arranges the items within a container. This method is used when the\n     * container has a fixed width and a fixed height. It is protected so\n     * that subclasses (if any) can override it. This method is called by\n     * {@link #arrange(Graphics2D, RectangleConstraint)}.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth(); // Fixed width for top/bottom\n\n        // Arrange Top\n        if (this.topBlock != null) {\n            // Constraint: Fixed width w[0], height range [0, constraint.getHeight()]\n            RectangleConstraint c1 = constraint.toRangeWidth(w[0]).toRangeHeight(\n                    new Range(0.0, constraint.getHeight()));\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n\n        // Arrange Bottom\n        w[1] = w[0]; // Same fixed width as top\n        if (this.bottomBlock != null) {\n            // Constraint: Fixed width w[1], height range [0, max(0, constraint.getHeight() - h[0])]\n            // Ensure the upper bound of the range is not negative\n            double availableHeight = Math.max(0.0, constraint.getHeight() - h[0]);\n            RectangleConstraint c2 = constraint.toRangeWidth(w[1]).toRangeHeight(\n                    new Range(0.0, availableHeight));\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n\n        // Determine nominal height constraint for middle row based on fixed height logic\n        // This might be 0 if overall height constraint is NONE or if T/B already used up fixed height.\n        double h_middle_constr = Math.max(0.0, constraint.getHeight() - h[1] - h[0]);\n\n        // Arrange Left, track max middle height required\n        double h_middle_actual = 0.0;\n        if (this.leftBlock != null) {\n            // Constraint: Fixed height h_middle_constr, width range [0, constraint.getWidth()]\n            RectangleConstraint c3 = constraint.toFixedHeight(h_middle_constr).toRangeWidth(\n                    new Range(0.0, constraint.getWidth()));\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n            h_middle_actual = Math.max(h_middle_actual, size.height);\n        }\n\n        // Arrange Right, track max middle height required\n        if (this.rightBlock != null) {\n            // Constraint: Fixed height h_middle_constr, width range [0, max(0, constraint.getWidth() - w[2])]\n            // Ensure the upper bound of the width range is not negative\n            double availableWidth = Math.max(0.0, constraint.getWidth() - w[2]);\n             RectangleConstraint c4 = constraint.toFixedHeight(h_middle_constr).toRangeWidth(\n                     new Range(0.0, availableWidth));\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n            h_middle_actual = Math.max(h_middle_actual, size.height);\n        }\n\n        // Determine width for Center, ensure not negative\n        w[4] = Math.max(0.0, constraint.getWidth() - w[3] - w[2]);\n\n        // Arrange Center, track max middle height required\n        if (this.centerBlock != null) {\n            // Constraint: Fixed width w[4], fixed height h_middle_constr\n            RectangleConstraint c5 = constraint.toFixedWidth(w[4]).toFixedHeight(h_middle_constr);\n            Size2D size = this.centerBlock.arrange(g2, c5);\n            // Width w[4] is fixed by constraint c5\n            h_middle_actual = Math.max(h_middle_actual, size.height);\n        }\n\n        // Now we have final dimensions: h[0], h[1], h_middle_actual, w[2], w[3], w[4]\n        // Assign actual middle height to h[2], h[3], h[4] for bounds setting\n        h[2] = h_middle_actual;\n        h[3] = h_middle_actual;\n        h[4] = h_middle_actual;\n\n        // Set Bounds using calculated dimensions\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));\n        }\n        if (this.bottomBlock != null) {\n            // Y position depends on actual middle height h[2]\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); // Use actual middle height h[2]\n        }\n        if (this.rightBlock != null) {\n            // X position depends on left and center widths\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); // Use actual middle height h[3]\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); // Use actual middle height h[4]\n        }\n\n        // Return calculated total size: fixed width, total calculated height\n        return new Size2D(constraint.getWidth(), h[0] + h[2] + h[1]);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}