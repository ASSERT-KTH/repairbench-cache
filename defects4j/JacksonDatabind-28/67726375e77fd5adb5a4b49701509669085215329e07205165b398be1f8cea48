{
    "generation": "        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            final JsonNodeFactory nodeFactory = ctxt.getNodeFactory();\n            // NOTE: behaviour change in 2.9useppe START_OBJECT case is NOT handled here;\n            // caller is assumed to handle it. This may be revert back in future.\n            // (either that, or take JsonNodeFactory)\n            //\n            // But for now, START_OBJECT handled externally (by standard delegating deserializer),\n            // and we assume FIELD_NAME or END_OBJECT were passed\n\n            if (p.isExpectedStartObjectToken()) {\n                // 23-Jun-2020, tatu: With 2.12, we maybe should try to support this?\n                //    Need to reconsider interaction, Task-databind#2835\n                 return deserializeObject(p, ctxt, nodeFactory);\n            }\n\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            JsonToken t = p.getCurrentToken();\n            if (t == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, nodeFactory);\n            }\n            // Added check: handle case where caller consumed START_OBJECT and the object is empty.\n            if (t == JsonToken.END_OBJECT) {\n                 return nodeFactory.objectNode();\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}