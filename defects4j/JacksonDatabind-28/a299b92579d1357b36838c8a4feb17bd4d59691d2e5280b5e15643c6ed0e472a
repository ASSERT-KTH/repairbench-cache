{
    "generation": "        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            JsonToken t = p.getCurrentToken();\n\n            // Case 1: Parser is at START_OBJECT (e.g., when deserializing \"{}\")\n            if (t == JsonToken.START_OBJECT) {\n                t = p.nextToken(); // Advance to the next token, which could be FIELD_NAME or END_OBJECT\n            }\n\n            // Case 2: Parser is now at END_OBJECT (e.g., if input was \"{}\" and nextToken() moved it here)\n            // or if the deserializer was directly called with END_OBJECT as the current token (less common but possible)\n            if (t == JsonToken.END_OBJECT) {\n                return ctxt.getNodeFactory().objectNode(); // Return an empty object node for \"{}\".\n            }\n\n            // Case 3: Parser is at FIELD_NAME (e.g., for non-empty object \"{ \\\"key\\\": ... }\",\n            // either initially or after consuming START_OBJECT)\n            if (t == JsonToken.FIELD_NAME) {\n                // Delegate to the protected method that handles actual field parsing\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            \n            // For any other token, it's an unsupported input for an ObjectNode\n            throw ctxt.mappingException(ObjectNode.class, t);\n         }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}