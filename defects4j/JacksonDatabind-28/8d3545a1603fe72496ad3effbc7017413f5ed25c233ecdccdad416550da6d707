{
    "generation": "        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            // Case 1: Parser is at START_OBJECT token (e.g., `{\"a\":1}` or `{}`).\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken(); // Advance past START_OBJECT.\n                // After nextToken(), for `{}`, the current token will be END_OBJECT.\n                // For `{\"a\":1}`, the current token will be FIELD_NAME.\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // Case 2: Parser is already at END_OBJECT token.\n            // This scenario occurs when an empty object `{}` has been consumed by a caller\n            // (e.g., a delegating deserializer or a special type adapter), and the parser is\n            // left at the closing brace `}`. This is crucial for handling the `testIssue941` failure.\n            if (p.getCurrentToken() == JsonToken.END_OBJECT) {\n                // If the current token is END_OBJECT on entry, it means we are deserializing\n                // an empty object, and no further parsing is needed.\n                return ctxt.getNodeFactory().objectNode(); // Return an empty ObjectNode.\n            }\n            // Case 3: Parser is at FIELD_NAME token.\n            // This can happen if the caller has already advanced the parser past the opening\n            // brace to the first field name (e.g., for `{\"field\": \"value\"}`).\n            // The comment \"similar to FIELD_NAME\" implies this is an intended entry point.\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // For any other token, it's an unexpected input for an ObjectNode.\n            throw ctxt.mappingException(ObjectNode.class);\n         }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}