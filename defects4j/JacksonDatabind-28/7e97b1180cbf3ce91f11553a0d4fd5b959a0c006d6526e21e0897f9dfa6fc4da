{
    "generation": "        @Override\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            // Case 1: Parser is at START_OBJECT. This is the most common entry point.\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken(); // Advance past START_OBJECT to the first field name or END_OBJECT\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            // Case 2: Parser is at END_OBJECT. This means we are deserializing an empty object,\n            // and the calling deserializer has already advanced past START_OBJECT.\n            if (p.getCurrentToken() == JsonToken.END_OBJECT) {\n                // If deserializeObject is called here, and it expects to parse fields,\n                // it will correctly return an empty ObjectNode as p.nextFieldName() will return null.\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // Case 3: Parser is at FIELD_NAME. This happens if the caller (e.g., a Map deserializer)\n            // has already consumed START_OBJECT and advanced to the first field name.\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // For any other token, it's an unexpected input for an ObjectNode.\n            throw ctxt.mappingException(ObjectNode.class);\n         }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}