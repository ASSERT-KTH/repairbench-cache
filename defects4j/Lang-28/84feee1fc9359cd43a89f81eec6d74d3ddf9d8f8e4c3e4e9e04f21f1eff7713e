{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        final int seqEnd = input.length();\n        // Check sufficient length for potential entity: minimum \"&#d;\" is 4 chars\n        // Check for '&#' starting sequence\n        if (input.charAt(index) == '&' && index + 1 < seqEnd && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            // Check if there's room for at least one digit/hex char and a semicolon\n            if (start >= seqEnd) {\n                return 0;\n            }\n            boolean isHex = false;\n            char firstChar = input.charAt(start);\n\n            // Check for optional 'x' or 'X' indicating hexadecimal format\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++;\n                // Check if there's room for at least one hex digit and a semicolon after 'x'/'X'\n                if (start >= seqEnd) {\n                    return 0; // Incomplete sequence like \"&#x\"\n                }\n                isHex = true;\n            }\n\n            // Find the terminating semicolon ';'\n            int end = start;\n            while (end < seqEnd && input.charAt(end) != ';') {\n                end++;\n            }\n\n            // Check if semicolon was found and if there were digits between #/x and ;\n            if (end == seqEnd || end == start) { // Missing ';' or no digits (e.g., \"&#;\" or \"&#x;\")\n                return 0;\n            }\n\n            int entityValue;\n            try {\n                // Parse the numeric value between start and end indices\n                final CharSequence sub = input.subSequence(start, end);\n                if (isHex) {\n                    entityValue = Integer.parseInt(sub.toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(sub.toString(), 10);\n                }\n            } catch (final NumberFormatException nfe) {\n                // The sequence between #/x and ; was not a valid number in the specified base\n                return 0; // Indicate translation failure\n            }\n\n            // Convert the numeric value to char(s) and write to the output\n            try {\n                if (entityValue > 0xFFFF) {\n                    // Handle supplementary Unicode characters (codes > 0xFFFF)\n                    // Character.toChars converts the code point to its UTF-16 surrogate pair representation.\n                    // It throws IllegalArgumentException if entityValue is not a valid Unicode code point (e.g., > 0x10FFFF).\n                    out.write(Character.toChars(entityValue));\n                } else {\n                    // Handle Basic Multilingual Plane (BMP) characters (codes <= 0xFFFF)\n                    // This includes directly writing surrogate code points (U+D800-U+DFFF) if provided,\n                    // matching the behavior of the original code for BMP values.\n                    out.write(entityValue);\n                }\n            } catch (final IllegalArgumentException e) {\n                 // The parsed entityValue is not a valid Unicode code point (e.g., exceeds Character.MAX_CODE_POINT)\n                 return 0; // Indicate translation failure\n            }\n\n            // Return the total number of characters consumed from the input sequence\n            // The entity starts at 'index' and ends at 'end' (inclusive ';'). Total length is (end - index + 1).\n            return end + 1 - index;\n        }\n        // The input sequence at the given index does not start with \"&#\"\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}