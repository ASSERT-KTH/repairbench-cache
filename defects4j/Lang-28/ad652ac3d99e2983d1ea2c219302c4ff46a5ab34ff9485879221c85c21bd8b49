{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // Protect from ArrayIndexOutOfBounds and invalid entity formats\n\n        // Need at least 2 characters for \"&#\"\n        if (index + 1 >= input.length()) {\n            return 0;\n        }\n\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            // Check if there's at least one character after \"&#\" (e.g., \"&#;\" is not valid)\n            if (start >= input.length()) {\n                return 0;\n            }\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n                // Check if there's at least one character after \"&#x\" (e.g., \"&#x;\" is not valid)\n                if (start >= input.length()) {\n                    return 0;\n                }\n            }\n\n            int end = start;\n            // Protect from infinite loop or ArrayIndexOutOfBounds if ';' is not found\n            while(end < input.length() && input.charAt(end) != ';') {\n                end++;\n            }\n\n            // If ';' was not found, it's not a valid entity\n            if (end == input.length()) {\n                return 0;\n            }\n\n            // Ensure there is content between 'start' and 'end' (e.g., \"&#;\" or \"&#x;\")\n            if (start == end) {\n                return 0; // Empty entity, e.g., &#; or &#x;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0; // Not a valid number\n            }\n\n            // Fix for supplementary characters (Unicode code points > 0xFFFF)\n            // Writer.write(int) only writes the lower 16 bits (a single char), which is incorrect for supplementary characters.\n            if (Character.isValidCodePoint(entityValue)) {\n                if (entityValue > 0xFFFF) {\n                    // Convert the code point to a surrogate pair (char array)\n                    char[] chars = Character.toChars(entityValue);\n                    out.write(chars[0]); // Write the high surrogate\n                    out.write(chars[1]); // Write the low surrogate\n                } else {\n                    // For Basic Multilingual Plane (BMP) characters, the original logic is fine.\n                    out.write(entityValue);\n                }\n            } else {\n                // If the parsed entity value is not a valid Unicode code point, treat as no translation.\n                return 0;\n            }\n\n            // Calculate the number of characters consumed from the input\n            // 2 for \"&#\" + (end - start) for the numeric part + 1 for 'x' (if hex) + 1 for ';'\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}