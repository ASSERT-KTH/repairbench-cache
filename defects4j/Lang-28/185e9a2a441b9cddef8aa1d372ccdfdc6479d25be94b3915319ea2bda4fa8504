{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        final int inputLen = input.length();\n        // Check bounds for initial characters '&' and '#'\n        // Check if characters match Numeric Entity format \"&#\"\n        if (input.charAt(index) == '&' && index + 1 < inputLen && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            // Check bounds after '#'\n            if (start >= inputLen) {\n                return 0; // Input ends prematurely after \"&#\"\n            }\n\n            boolean isHex = false;\n            char firstChar = input.charAt(start);\n            // Check for optional hex marker 'x' or 'X'\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++;\n                // Check bounds after 'x'/'X'\n                if (start >= inputLen) {\n                    return 0; // Input ends prematurely after \"&#x\"\n                }\n                isHex = true;\n            }\n\n            int end = start;\n            // Find the terminating semicolon ';', checking bounds\n            while (end < inputLen && input.charAt(end) != ';') {\n                end++;\n            }\n\n            // Check if semicolon was found before the end of the input\n            if (end == inputLen || input.charAt(end) != ';') {\n                 return 0; // Malformed entity: no terminating semicolon found\n            }\n\n            // Check if there was at least one digit/hex digit between '#'/'#x' and ';'\n            if (start == end) {\n                return 0; // Malformed entity: no number present (e.g., \"&#;\", \"&#x;\")\n            }\n\n            int entityValue;\n            try {\n                CharSequence numeric = input.subSequence(start, end);\n                if (isHex) {\n                    entityValue = Integer.parseInt(numeric.toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(numeric.toString(), 10);\n                }\n            } catch (NumberFormatException nfe) {\n                // The sequence between start and end is not a valid number in the specified base\n                // or the number is too large/small for an int.\n                return 0; // Treat as untranslatable\n            }\n\n            // Check if the parsed value is a valid Unicode code point.\n            // Valid range is U+0000 to U+10FFFF.\n            if (entityValue < Character.MIN_CODE_POINT || entityValue > Character.MAX_CODE_POINT) {\n                 // The numeric value does not represent a valid Unicode code point.\n                 return 0; // Treat as untranslatable\n            }\n\n            // Convert the code point to its char representation.\n            // This handles both BMP characters (resulting in a single char)\n            // and supplementary characters (resulting in a surrogate pair - two chars).\n            final char[] chars = Character.toChars(entityValue);\n            out.write(chars);\n\n            // Return the total number of characters consumed from the input sequence.\n            // Calculation: length of \"&#\" (2)\n            //            + length of \"x\" (1 if hex, 0 otherwise)\n            //            + length of digits (end - start)\n            //            + length of \";\" (1)\n            return 2 + (isHex ? 1 : 0) + (end - start) + 1;\n        }\n        // The sequence at the current index does not start with \"&#\", so it's not a numeric entity.\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}