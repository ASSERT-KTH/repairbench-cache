{
    "generation": "import org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\n// Note: The surrounding class context is assumed to provide the 'getPrefix' helper method.\n// e.g., private static String getPrefix(Node node) { /* implementation */ }\n\n    /**\n     * Get the ns uri of the specified node.\n     * This method reliably determines the namespace URI for an element\n     * by manually walking up the DOM tree and checking xmlns attributes,\n     * which is more consistent across DOM implementations than relying\n     * solely on {@code node.getNamespaceURI()}, especially for default\n     * namespaces and empty namespace declarations (xmlns=\"\").\n     * For non-element nodes, it returns the result of {@code node.getNamespaceURI()}.\n     *\n     * @param node Node to check\n     * @return String ns uri, \"\" for the empty namespace, or null if no namespace applies.\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node == null) {\n            return null;\n        }\n\n        int type = node.getNodeType();\n\n        if (type == Node.ELEMENT_NODE) {\n            // For elements, perform manual namespace lookup by walking up the tree.\n            Element element = (Element) node;\n            // Assumes a getPrefix helper exists in the same class or context.\n            // This helper should return the prefix from the element's QName, or null if no prefix.\n            String prefix = getPrefix(element); \n            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n            Node current = element;\n            while (current != null) {\n                // Namespace declarations are only carried by ELEMENT nodes.\n                if (current.getNodeType() == Node.ELEMENT_NODE) {\n                    Element ancestor = (Element) current;\n                    // Check if the namespace declaration attribute (xmlns or xmlns:prefix) exists.\n                    Attr attr = ancestor.getAttributeNode(qname);\n                    if (attr != null) {\n                        // Found the namespace declaration attribute.\n                        // The attribute's value is the namespace URI.\n                        // This correctly handles xmlns=\"someURI\" and xmlns=\"\" (empty string URI).\n                        return attr.getValue();\n                    }\n                }\n                // Move up to the parent node to check ancestor declarations.\n                current = current.getParentNode();\n            }\n            // If the loop completes, no applicable namespace declaration was found\n            // walking up the tree from the element.\n            // If prefix was not null (e.g., \"p:foo\"), the prefix is undeclared, so the URI is null.\n            // If prefix was null (e.g., \"foo\"), there's no default namespace in scope, so the URI is null.\n            return null;\n        }\n        else if (type == Node.DOCUMENT_NODE) {\n            // If the node is a Document, delegate to finding the namespace of its document element.\n            // This matches the behavior of the original code.\n            Document doc = (Document) node;\n            Element docElement = doc.getDocumentElement();\n            // Recursively call this method on the document element.\n            // If there's no document element, getNamespaceURI(null) will correctly return null.\n            return getNamespaceURI(docElement);\n        }\n        else {\n            // For other node types (Attr, Text, CDATA, Comment, PI, etc.),\n            // their namespace URI is determined differently (e.g., attribute's namespace\n            // depends on its own prefix). We return the node's own namespace URI property\n            // as defined by the DOM specification.\n            return node.getNamespaceURI();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}