{
    "generation": "import org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\npublic class DOMNodePointer { // Assuming this is the class the method belongs to\n    /**\n     * Get the ns uri of the specified node.\n     * @param node Node to check\n     * @return String ns uri\n     */\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        // Get the standard DOM namespace URI for the node.\n        // This handles Element and Attr nodes correctly, returning null for other types.\n        String uri = node.getNamespaceURI();\n\n        // Apply specific logic only for Element nodes, where namespace resolution\n        // and 'xmlns' attribute lookups are relevant.\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            // JXPath's unprefixed XPath expressions often expect 'null' for\n            // elements that are not in any namespace, which includes elements\n            // declared with xmlns=\"\" (empty namespace).\n            if (\"\".equals(uri)) {\n                return null;\n            }\n\n            // If the standard DOM getNamespaceURI() returned null (truly non-namespaced,\n            // or sometimes due to older DOM implementations not fully reflecting xmlns attributes),\n            // or if we previously converted \"\" to null, we proceed with fallback.\n            if (uri == null) {\n                // Fallback: traverse up the parent chain to find 'xmlns' or 'xmlns:prefix' attributes.\n                // This is crucial for environments where Element.getNamespaceURI() might not\n                // fully resolve namespaces declared via attributes on ancestors, or for non-namespaced elements.\n                String prefix = getPrefix(node); // Assuming getPrefix is an accessible static helper method\n                String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n        \n                Node aNode = node;\n                while (aNode != null) {\n                    if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                        Attr attr = ((Element) aNode).getAttributeNode(qname);\n                        if (attr != null) {\n                            String attrValue = attr.getValue();\n                            // If the found attribute declares an empty namespace, return null\n                            // for JXPath compatibility with unprefixed names.\n                            return \"\".equals(attrValue) ? null : attrValue;\n                        }\n                    }\n                    aNode = aNode.getParentNode();\n                }\n                // If no namespace declaration attribute is found in the hierarchy,\n                // it's considered to be in no namespace.\n                return null;\n            }\n        }\n        \n        // For nodes that are not Elements (e.g., Attr, Text, Comment, etc.),\n        // or for Elements whose standard DOM getNamespaceURI() returned a non-null, non-empty URI,\n        // return the URI as obtained directly from the node.\n        return uri;\n    }\n\n    // Assuming getPrefix(Node node) is a static helper method in this class or accessible.\n    // This is a placeholder for the actual implementation of getPrefix.\n    // In JXPath's DOMNodePointer, this is an instance method, so this implies\n    // it needs to be made static or provided as a static helper.\n    // For the purpose of this fix, we assume it's available as a static helper.\n    private static String getPrefix(Node node) {\n        if (node.getNodeType() == Node.ELEMENT_NODE) {\n            String prefix = node.getPrefix();\n            if (prefix == null && node.getNamespaceURI() != null && !\"\".equals(node.getNamespaceURI())) {\n                // If it has a namespace but no prefix (default namespace),\n                // it might be expected to return an empty string prefix.\n                // However, for the purpose of the fallback logic, we are looking for \"xmlns\" directly.\n                // So, if the element itself has a default namespace but no prefix,\n                // we want the qname to be \"xmlns\". This happens if getPrefix returns null.\n                return null; // Ensure 'xmlns' is sought for default namespace elements\n            }\n            return prefix;\n        }\n        // For attributes, getPrefix() is also meaningful.\n        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {\n            return node.getPrefix();\n        }\n        return null;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}