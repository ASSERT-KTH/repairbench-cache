{
    "generation": "    /**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param <T> type of the points to cluster\n     * @param points the points to choose the initial centers from\n     * @param k the number of centers to choose\n     * @param random random generator to use\n     * @return the initial centers\n     */\n    private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        // Convert to list for indexed access. Make a copy as input should not be modified.\n        final List<T> pointList = new ArrayList<T>(points);\n        final int numPoints = pointList.size();\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Handle edge cases: k=0, empty points list, or k > number of points\n        if (k <= 0 || numPoints == 0) {\n            return resultSet;\n        }\n        // If k is larger than the number of points, return all points as centers\n        if (k >= numPoints) {\n            for (final T p : pointList) {\n                resultSet.add(new Cluster<T>(p));\n            }\n            return resultSet;\n        }\n\n\n        // Choose the first center uniformly at random.\n        final int firstPointIndex = random.nextInt(numPoints);\n        final T firstPoint = pointList.get(firstPointIndex);\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        // Keep track of points already selected.\n        final boolean[] selected = new boolean[numPoints];\n        selected[firstPointIndex] = true;\n\n        // Cache the squared distance to the nearest center for each point.\n        final double[] minDistSquared = new double[numPoints];\n\n        // Initialize with distance squared to the first center.\n        for (int i = 0; i < numPoints; i++) {\n            if (i != firstPointIndex) {\n                final double d = firstPoint.distanceFrom(pointList.get(i));\n                minDistSquared[i] = d * d;\n            } else {\n                minDistSquared[i] = 0.0; // Distance to self is 0\n            }\n        }\n\n\n        while (resultSet.size() < k) {\n            // Sum the minimum distances squared for sampling for non-selected points\n            double distSqSum = 0.0;\n            for (int i = 0; i < numPoints; i++) {\n                if (!selected[i]) {\n                    distSqSum += minDistSquared[i];\n                }\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)^2.\n\n            final T nextCenter;\n            final int nextCenterIndex; // Keep track of the index as well\n\n            if (distSqSum == 0) {\n                // This happens when all remaining points are identical to centers already chosen.\n                // Choose the first available point, breaking ties deterministically.\n                // Kmeans++ paper suggests choosing randomly in this case. Let's stick to first available.\n                int foundIndex = -1;\n                for (int i = 0; i < numPoints; i++) {\n                    if (!selected[i]) {\n                        foundIndex = i;\n                        break;\n                    }\n                }\n                // If no unselected point is found (should not happen based on loop condition), break.\n                if (foundIndex == -1) {\n                    break;\n                }\n                nextCenterIndex = foundIndex;\n                nextCenter = pointList.get(nextCenterIndex);\n\n            } else {\n                // Standard K-means++ sampling: choose point proportional to minDistSquared\n                final double r = random.nextDouble() * distSqSum;\n                double cumulativeSum = 0.0;\n                int foundIndex = -1;\n                for (int i = 0; i < numPoints; i++) {\n                    if (!selected[i]) {\n                        cumulativeSum += minDistSquared[i];\n                        // The check should be >= for correctness, covering r=0 and potential floating point issues\n                        if (cumulativeSum >= r) {\n                            foundIndex = i;\n                            break;\n                        }\n                    }\n                }\n\n                // Handle edge case where cumulativeSum might not exactly reach distSqSum due to floating point errors,\n                // or r is exactly distSqSum. Pick the last considered non-selected point.\n                if (foundIndex == -1) {\n                   for (int i = numPoints - 1; i >= 0; i--) {\n                       if (!selected[i]) {\n                           foundIndex = i;\n                           break;\n                       }\n                   }\n                }\n\n                // If still not found, something is wrong, break.\n                if (foundIndex == -1) {\n                   break;\n                }\n                nextCenterIndex = foundIndex;\n                nextCenter = pointList.get(nextCenterIndex);\n            }\n\n            // Add the chosen point to the centers.\n            resultSet.add(new Cluster<T>(nextCenter));\n            selected[nextCenterIndex] = true;\n\n            // Optimization: Update minDistSquared comparing only against the newly added center.\n            // This is valid because min(d(p, C union {c_new})^2) = min( min(d(p, C)^2), d(p, c_new)^2 ).\n            if (resultSet.size() < k) { // No need to update if it's the last center\n                for (int i = 0; i < numPoints; i++) {\n                    if (!selected[i]) {\n                        final double d = nextCenter.distanceFrom(pointList.get(i));\n                        final double dSquared = d * d;\n                        // Check for potential underflow/NaN before comparison\n                        if (dSquared < minDistSquared[i]) {\n                            minDistSquared[i] = dSquared;\n                        }\n                    }\n                }\n            }\n        }\n\n        return resultSet;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}