{
    "generation": "@Override\npublic boolean apply(Node n) {\n  // When the node is null it means, we reached the implicit return\n  // where the function returns (possibly without a return statement)\n  if (n == null) {\n    return false;\n  }\n\n  // We only care about calls to functions that\n  // pass one of the dependent variable to a non-side-effect free\n  // function.\n  if ((n.isCall() && NodeUtil.functionCallHasSideEffects(n)) ||\n      (n.isNew() && NodeUtil.constructorCallHasSideEffects(n))) {\n    return true;\n  }\n\n  // Do NOT traverse into FOR_IN LHS (the first child of FOR_IN). \"a in b\"\n  // has side effects if a or b are objects (due to property access semantics),\n  // but the assignment itself is not a side-effectful use like a function call.\n  // So, for code like \"var x = a in b\", we should allow inlining x,\n  // unless x is used in a function call, etc, in which case we forbid inlining.\n  if (n.isForIn()) {\n    // Only visit the NODE representing the source (rhs) and the body;\n    // do not traverse into the target (lhs) child.\n    Node rhs = n.getSecondChild();\n    Node body = n.getChildCount() > 2 ? n.getChildAtIndex(2) : null;\n    if (rhs != null && apply(rhs)) {\n      return true;\n    }\n    if (body != null && apply(body)) {\n      return true;\n    }\n    return false;\n  }\n\n  for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}