{
    "generation": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null; // Reached central directory or extended descriptor\n        }\n        // If this is not a local file header signature, then it should be an error\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            // Throw an exception so the caller knows there was a problem\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            // If data descriptor is present, CRC, compressed size, and uncompressed size\n            // are set later, so skip the corresponding fields in the local file header.\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n\n        if (fileNameLen < 0) {\n            throw new IOException(\"Invalid entry name length\");\n        }\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        // CESU-8 consideration: even if the GPBF is not set, the entry may encode the name using CESU-8\n        // Tika-2295: mayCheckUTF8 flag is related to Central Directory, not LFH. Use hasUTF8Flag from LFH.\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        if (extraLen < 0) {\n            throw new IOException(\"Invalid extra field length\");\n        }\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        // If the compressed size is not known, and it's DEFLATED or BZIP2,\n        // we might need to wrap the stream in a way that supports streams of unknown length.\n        // However, BoundedInputStream is used elsewhere, implying we might rely on reading\n        // until the data descriptor or the next entry header.\n\n        // Ensure the input stream is correctly prepared based on the entry's compression method.\n        // Note: BoundedInputStream is crucial for methods where the compressed size is known,\n        // to prevent reading into the next entry's data.\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            long compressedSize = current.entry.getCompressedSize();\n             if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                 current.in = new UnshrinkingInputStream(new BoundedInputStream(in, compressedSize));\n             } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                 current.in = new ExplodingInputStream(\n                         current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                         current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                         new BoundedInputStream(in, compressedSize));\n             } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                 current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, compressedSize));\n             }\n             // For STORED and DEFLATED, the handling might be done elsewhere or integrated\n             // with the data descriptor logic if applicable. If no special stream is needed\n             // but size is known, BoundedInputStream might still be relevant.\n             // Consider adding cases or default handling as needed.\n        }\n        // Note: Deflate handling might occur implicitly or require explicit setup if not covered above.\n        // If using a data descriptor, the actual stream wrapping might need to wait until the descriptor is read.\n\n        entriesRead++;\n        return current.entry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}