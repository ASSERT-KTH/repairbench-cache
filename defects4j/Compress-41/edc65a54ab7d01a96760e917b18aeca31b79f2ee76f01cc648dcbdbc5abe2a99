{
    "generation": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null; // Reached central directory, no more local file headers\n        }\n\n        // LFH_SIG is expected here, otherwise this is not a valid ZIP entry\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            // Fallback to check for Zip64 End Of Central Directory Locator\n            // Some archives seem to contain strange data structures\u306a\u3093\u3060\u308d\u3046\n            // and want us to ignore data until the Zip64 EOCD Locator is found.\n            // See https://issues.apache.org/jira/browse/COMPRESS-478\n            if (checkIfZip64ExtraFieldIdentifier(LFH_BUF, 0)) {\n                // pretend we've hit the central directory and need to skip stuff\n                hitCentralDirectory = true;\n                skipRemainderOfArchive();\n                return null;\n            }\n            // Report the unexpected signature\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%x\", sig.getValue()));\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            // CRC, size and compressed size are stored in the data descriptor\n            // and will be read later\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\n        // COMPRESS-479 When the file name length is greater than the buffer size,\n        // expand the buffer to fit the file name.\n        if (fileNameLen > LFH_BUF.length - LFH_OFFSET_FOR_FILENAME_LENGTH) {\n            final int newLength = LFH_OFFSET_FOR_FILENAME_LENGTH + fileNameLen;\n            if (newLength > buf.length) {\n                // Ensure that we don't lose the previously read data\n                final byte[] oldBuf = LFH_BUF;\n                buf = Arrays.copyOf(buf, Math.max(buf.length * 2, newLength));\n                LFH_BUF = buf;\n                // Copy the LFH data we've already read\n                System.arraycopy(oldBuf, 0, LFH_BUF, 0, LFH_OFFSET_FOR_FILENAME_LENGTH);\n            }\n\n            // Read the rest of the LFH header containing the file name length\n            // and the extra field length.\n            readFully(LFH_BUF, LFH_OFFSET_FOR_FILENAME_LENGTH, fileNameLen - (LFH_BUF.length - LFH_OFFSET_FOR_FILENAME_LENGTH));\n        }\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n\n        // COMPRESS-479 When the extra field length is greater than the buffer size,\n        // expand the buffer to fit the extra field.\n        if (extraLen > LFH_BUF.length - LFH_OFFSET_FOR_EXTRA_FIELD_LENGTH) {\n            final int newLength = LFH_OFFSET_FOR_EXTRA_FIELD_LENGTH + extraLen;\n            if (newLength > buf.length) {\n                // Ensure that we don't lose the previously read data\n                final byte[] oldBuf = LFH_BUF;\n                buf = Arrays.copyOf(buf, Math.max(buf.length * 2, newLength));\n                LFH_BUF = buf;\n                // Copy the LFH data we've already read\n                System.arraycopy(oldBuf, 0, LFH_BUF, 0, LFH_OFFSET_FOR_EXTRA_FIELD_LENGTH);\n            }\n\n            // Read the rest of the LFH header containing the extra field length.\n            readFully(LFH_BUF, LFH_OFFSET_FOR_EXTRA_FIELD_LENGTH, extraLen - (LFH_BUF.length - LFH_OFFSET_FOR_EXTRA_FIELD_LENGTH));\n        }\n\n        off += SHORT;\n\n        final byte[] fileName = IOUtils.readRange(in, fileNameLen);\n        // Make sure we are using the same byte array which is used by other analyses.\n        // The file name is validated to be sequences of bytes. If it is invalid,\n        // the decoder should be able to replace the invalid characters with replacements.\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        final byte[] extraData = IOUtils.readRange(in, extraLen);\n        try {\n            current.entry.setExtra(extraData);\n        } catch (RuntimeException ex) {\n            final ZipException ze = new ZipException(\"Invalid extra data in entry \" + current.entry.getName());\n            ze.initCause(ex);\n            throw ze;\n        }\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        // If the size is not set here, then we read it from the data descriptor\n        // The size can be 0, so we should check if it is SIZE_UNKNOWN\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n            } else if (current.entry.getMethod() == ZipMethod.DEFLATED.getCode() ||\n                       current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n                // InflaterInputStream needs the data descriptor to be read first for STORED entries\n                // For DEFLATED entries, we can construct the stream now\n                // TODO: Wait for data descriptor? ZLIB requires it for STORED but not DEFLATED?\n                // NO: If the entry has a data descriptor, the compressed size is unavailable now\n                final long compressedSize = current.entry.getCompressedSize();\n                current.in = new ZipInflaterInputStream(new BoundedInputStream(in, compressedSize), inflater, (int) Math.min(compressedSize, Integer.MAX_VALUE));\n            }\n            // TODO add support for other methods (needs helper classes)\n        }\n\n        entriesRead++;\n        return current.entry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}