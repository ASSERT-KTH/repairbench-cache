{
    "generation": "    /**\n     * Reads the next ZIP file entry locally stored data.\n     *\n     * @throws IOException on error\n     * @return the entry just read\n     */\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null; // Reach end of stream, which is expected.\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n\n        // Check for signatures that indicate the end of entries (CFH or AED)\n        // See Bugzilla 50939\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            // The flag hitCentralDirectory is set. The check at the beginning\n            // of this method will ensure the next call returns null.\n            // This call should also return null, as we haven't found a new LFH.\n            return null;\n        }\n\n        // Not CFH/AED, so ensure it is LFH.\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            // Found an unexpected signature. The archive is either corrupt,\n            // or unexpected data appears before the first LFH.\n            // Previously returned null, which masked the error. Throwing an exception is correct.\n            throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", sig.getValue()));\n        }\n\n        // It is a Local File Header. Proceed with parsing.\n        int off = WORD; // Skip LFH signature (already read)\n        current = new CurrentEntry();\n\n        final int versionNeededToExtract = ZipShort.getValue(LFH_BUF, off); // Version needed to extract\n        off += SHORT;\n        current.entry.setPlatform((versionNeededToExtract >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n        // We don't store versionNeededToExtract itself in ZipArchiveEntry.\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off); // General purpose bit flag\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off)); // Compression method\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off)); // Last modified time/date\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null; // Uncompressed, Compressed sizes\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off)); // CRC-32\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off); // Compressed size\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off); // Uncompressed size\n            off += WORD;\n        } else {\n            // CRC, Compressed size, Uncompressed size are zero or placeholder\n            // They will be read from the data descriptor later.\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off); // File name length\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off); // Extra field length\n        off += SHORT;\n\n        // Read file name\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        // Store the decoded name and the raw name bytes (for potential Unicode extra field processing)\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        // Read extra field data\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData); // Parse and store extra fields\n\n        // If UTF-8 flag is not set and we are configured to use Unicode extra fields,\n        // try to extract name and comment from them.\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        // Process Zip64 extra field if present. This might update the size/cSize\n        // if the LFH values were ZipLong.ZIP64_MAGIC.\n        processZip64Extra(size, cSize);\n\n        // If sizes weren't updated by Zip64 extra field processing and there's no data descriptor,\n        // set them from the LFH values (which must not have been ZipLong.ZIP64_MAGIC).\n        if (!current.hasDataDescriptor) {\n            if (current.entry.getCompressedSize() == ArchiveEntry.SIZE_UNKNOWN && cSize != null) {\n                current.entry.setCompressedSize(cSize.getValue());\n            }\n            if (current.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN && size != null) {\n                current.entry.setSize(size.getValue());\n            }\n        }\n        // If there is a data descriptor, sizes remain unknown until closeEntry reads it.\n\n        // Setup the input stream wrapper ('current.in') for specific compression methods\n        // that need a dedicated wrapper stream, but only if the compressed size is known.\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            // Use BoundedInputStream to prevent reading past the end of this entry's data.\n            BoundedInputStream bounded = new BoundedInputStream(in, current.entry.getCompressedSize());\n            if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n                current.in = new UnshrinkingInputStream(bounded);\n            } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        bounded);\n            } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n                current.in = new BZip2CompressorInputStream(bounded);\n            }\n            // For STORED and DEFLATED, the main read() method likely handles reading\n            // from 'in' (potentially using 'inf'), possibly respecting the bound implicitly.\n            // So, current.in is left null for those cases based on the original snippet's structure.\n        }\n        // else: Compressed size is unknown (because of data descriptor). Stream setup is likely\n        // handled differently, possibly within the read() method.\n\n        entriesRead++;\n        return current.entry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}