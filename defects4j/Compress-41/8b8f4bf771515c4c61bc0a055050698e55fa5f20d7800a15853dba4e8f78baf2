{
    "generation": "    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(LFH_BUF);\n\n        if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null; // Return null as we've hit the central directory\n        }\n\n        // If we are seeing the LFH signature then process the entry\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            // If we are here then we have already processed the first entry (if firstEntry was true).\n            // If first entry was not processed then an error would have been thrown by readFirstLocalFileHeader.\n            // Either the LFH signature is not present, or is incorrect.\n            // Throw an exception, rather than return null, if the signature is incorrect.\n            // Null indicates that the end of the stream has been reached.\n            // See https://issues.apache.org/jira/browse/COMPRESS-161\n            //\n            // Could be Zip64 data descriptor signature. If so, read as data descriptor.\n            // See https://issues.apache.org/jira/browse/COMPRESS-386\n            if (sig.equals(ZipLong.DD_SIG)) {\n                 // Data descriptor signature - Should only happen in streaming zip archives\n                 // Not expecting data descriptor signature here. Log debug message and return null?\n                 // Or should we throw an exception? It is unexpected after all! Let's throw for now.\n                 throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", sig.getValue()));\n             }\n\n            // If we get here then the signature is neither LFH, CFH, AED or DD. This is illegal.\n             throw new ZipException(String.format(\"Unexpected record signature: 0x%x\", sig.getValue()));\n        }\n\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n            off += WORD;\n\n            cSize = new ZipLong(LFH_BUF, off);\n            off += WORD;\n\n            size = new ZipLong(LFH_BUF, off);\n            off += WORD;\n        } else {\n            // Crc, CSize, Size will be read from the data descriptor\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(LFH_BUF, off);\n        off += SHORT;\n\n\n        if (fileNameLen < 0){\n            throw new IOException(\"Found invalid filename length \" + fileNameLen + \" in LFH\");\n        }\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        // UTF-8 encoding is handled by Hutool, we just need to set the name\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        if (extraLen < 0){\n            throw new IOException(\"Found invalid extra-field length \" + extraLen + \" in LFH\");\n        }\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        try {\n            current.entry.setExtra(extraData);\n        } catch (RuntimeException ex) {\n            final ZipException ze = new ZipException(\"Invalid extra data in entry \" + current.entry.getName());\n            ze.initCause(ex);\n            throw ze;\n        }\n\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        // If the size is unknown and we're using encryption then\n        // the size may be stored in the extra data segment. Decryption requires the size.\n        // See: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT section 6.1.8\n        // If the size is still unknown have another go at recalculating the size.\n        if (current.entry.getSize() == ArchiveEntry.SIZE_UNKNOWN) {\n            processMaybeZip64ExtraAfterEncryption();\n        }\n\n\n        // Apply encryption transformations as necessary. Note that these do not change the\n        // underlying input stream, but rather wrap it. Note that decrypt() can change the size of the stream.\n        // See: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT section 6.1.8\n        current.in = applyZipCryptoTransform(current.entry);\n\n        // Some methods expect the stream size for the entry. Bzip2 is one.\n        // See https://issues.apache.org/jira/browse/COMPRESS-460\n        final InputStream bis = current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN ?\n            new BoundedInputStream(current.in, current.entry.getCompressedSize()) : current.in;\n\n\n        if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            current.in = new UnshrinkingInputStream(bis);\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            try {\n                current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        bis);\n            } catch (final IllegalArgumentException ex) {\n                throw new IOException(\"bad IMPLODE data\", ex);\n            }\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            current.in = new BZip2CompressorInputStream(bis);\n        } else if (current.entry.getMethod() == ZipMethod.LZMA.getCode()) {\n            current.in = buildLZMAInputStream(current.entry, bis);\n        } else if (current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n            current.in = new Deflate64CompressorInputStream(bis);\n        } else if (current.entry.getMethod() == ZipMethod.XZ.getCode()) {\n            current.in = buildXZInputStream(current.entry, bis);\n        } else if (current.entry.getMethod() == ZipMethod.ZSTANDARD.getCode()) {\n            current.in = buildZStandardInputStream(current.entry, bis);\n        }\n        // InflaterInputStream requires that the stream size is known for DEFLATED entries\n        // that use data descriptors. For other cases the stream size is only used for reporting\n        // the progress of decompression - so the potentially inaccurate value from the LFH is OK.\n        // Need to check for specific Bitmask? Need to add method to ZipArchiveEntry?\n        // Assume that the compressed size from the LFH is correct\n        // Needs testing! ZipeEntry.getCopmressedSize is not the correct value here!\n        // compressed size from LFH or Zip64 extra field might be zero!\n        // If compression method == UNKNOWN (= -1 ?) then an error must be thrown - how do we do this?\n\n        entriesRead++;\n        return current.entry;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}