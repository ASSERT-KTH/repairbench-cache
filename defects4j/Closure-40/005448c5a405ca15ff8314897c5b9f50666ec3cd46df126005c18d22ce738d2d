{
    "generation": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            // Use getName to ensure that the name is defined.\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        }\n        // NOTE: Object literal keys are handled by the GETPROP case below.\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n        // NOTE: The right side of the assignment is handled by the generic\n        // cases below.\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        // Record call sites for certain functions (e.g., goog.inherits).\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n             refNodes.add(new ClassDefiningFunctionNode(\n                 name, n, parent, parent.getParent()));\n          }\n        }\n        // NOTE: Arguments are handled by the generic cases below.\n\n      } else if (parent != null && parent.isExprResult()) {\n        // Record references. Unqualified names used as expressions\n        // are EXPR_RESULT children. Other names are handled by GETPROP.\n        if (n.isName()) {\n          // Make sure we are not recording function declarations, which are\n          // handled above. Check that the parent's parent is not a function\n          // or that the name is not the function name.\n          if (!parent.getParent().isFunction() || n != parent.getParent().getFirstChild()) {\n            // Make sure we are not recording 'eval' or 'arguments' which are\n            // special.\n             if (!\"eval\".equals(n.getString()) && !\"arguments\".equals(n.getString())) {\n               NameInformation ns = createNameInformation(t, n, parent);\n               if (ns != null) {\n                 recordSet(ns.name, n); // Record the reference.\n               }\n             }\n          }\n        }\n      } else if (n.isGetProp()) {\n        // Record references for qualified names.\n        NameInformation ns = createNameInformation(t, n, parent);\n        if (ns != null) {\n          // recordSet is used to record both sets and references for properties.\n          // Later analysis determines the type of reference.\n          recordSet(ns.name, n);\n        }\n      }\n      // NOTE: No specific handling for NAME nodes needed here other than the\n      // EXPR_RESULT case, because NAME nodes are typically children of other\n      // nodes (like GETPROP, ASSIGN, CALL, VAR) that are already handled.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}