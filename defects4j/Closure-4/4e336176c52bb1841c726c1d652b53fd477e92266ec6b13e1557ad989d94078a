{
    "generation": "/**\n * Resolve the referenced type within the enclosing scope.\n */\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n  // Track whether we're already resolving this type to detect cycles and prevent recursion.\n  if (isResolving) {\n    // If we're already resolving, we've hit an inheritance cycle.\n    handleTypeCycle(t);\n    return registry.isLastGeneration() ? getReferencedType() : this;\n  }\n\n  // Guard against recursion by setting the resolving flag.\n  isResolving = true;\n  try {\n    // Try to resolve via the registry first.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      finishPropertyContinuations();\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    // If not resolved by registry, try to resolve via properties.\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  } finally {\n    // Always clear the resolving flag to allow future valid resolutions.\n    isResolving = false;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}