{
    "generation": "  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // If the type has already been resolved, return its referenced type.\n    // This prevents unnecessary re-resolution and is the base case for recursion.\n    if (isResolved()) {\n      return getReferencedType();\n    }\n\n    // If this type is currently in the process of being resolved,\n    // it indicates a cyclic dependency. Report the cycle and return\n    // `this` to break the recursion and prevent a StackOverflowError.\n    // This is the critical check for handling type cycles during resolution.\n    if (isResolving()) {\n      handleTypeCycle(t);\n      return this;\n    }\n\n    // Mark this type as currently resolving to detect future cycles.\n    setResolving(true);\n    try {\n      // TODO(user): Investigate whether it is really necessary to keep two\n      // different mechanisms for resolving named types, and if so, which order\n      // makes more sense. Now, resolution via registry is first in order to\n      // avoid triggering the warnings built into the resolution via properties.\n      boolean resolved = resolveViaRegistry(t, enclosing);\n\n      // Check for implicit prototype cycles immediately after registry resolution.\n      // This is distinct from the direct resolution cycle caught by `isResolving()`.\n      if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n      }\n\n      if (resolved) {\n        // If resolution via registry was successful, finalize the resolution.\n        // The `super.resolveInternal` call from `ProxyObjectType` manages setting\n        // the `referencedType` and the `resolved` flag based on the `resolve` method.\n        super.resolveInternal(t, enclosing);\n        finishPropertyContinuations();\n        return registry.isLastGeneration() ?\n            getReferencedType() : this;\n      }\n\n      // If not resolved via registry, try resolution via properties.\n      resolveViaProperties(t, enclosing);\n      // Check for implicit prototype cycles after property resolution.\n      if (detectImplicitPrototypeCycle()) {\n        handleTypeCycle(t);\n      }\n\n      // Finalize the resolution, potentially setting the `resolved` flag.\n      super.resolveInternal(t, enclosing);\n      // The `isResolved()` check here reflects whether the resolution via properties\n      // or `super.resolveInternal` successfully marked the type as resolved.\n      if (isResolved()) {\n        finishPropertyContinuations();\n      }\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    } finally {\n      // Ensure the resolving flag is reset when resolution completes or fails,\n      // to allow for re-resolution if needed (e.g., in a different generation)\n      // and to prevent false cycle detections.\n      setResolving(false);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}