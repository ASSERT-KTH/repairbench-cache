{
    "generation": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n  // First, try registry-based resolution.\n  boolean resolved = resolveViaRegistry(t, enclosing);\n  // Catch any immediate prototype-cycle errors.\n  if (detectImplicitPrototypeCycle()) {\n    handleTypeCycle(t);\n  }\n\n  if (resolved) {\n    // Finish resolving extends/implements on the referenced constructor/interface.\n    super.resolveInternal(t, enclosing);\n\n    // Additional cycle detection: catch direct self-implements and mixed extends/implements loops.\n    JSType ref = getReferencedType();\n    // toMaybeFunctionType() returns non-null only for function/constructor/interface types\n    FunctionType ctor = ref.toMaybeFunctionType();\n    if (ctor != null) {\n      // If there is no explicit @extends, only look for a direct self-implement loop.\n      FunctionType sup = ctor.getSuperClassConstructor();\n      if (sup == null) {\n        for (JSType iface : ctor.getImplementedInterfaces()) {\n          FunctionType implCtor = iface.toMaybeFunctionType();\n          if (implCtor == ctor) {\n            // direct implements-of-self\n            handleTypeCycle(t);\n            break;\n          }\n        }\n      } else {\n        // Mixed extends/implements cycle detection via BFS\n        java.util.Deque<FunctionType> queue = new java.util.ArrayDeque<FunctionType>();\n        java.util.Set<FunctionType> visited = new java.util.HashSet<FunctionType>();\n        queue.add(ctor);\n        visited.add(ctor);\n        boolean foundCycle = false;\n        while (!queue.isEmpty() && !foundCycle) {\n          FunctionType curr = queue.removeFirst();\n          // follow the explicit extends edge\n          FunctionType e = curr.getSuperClassConstructor();\n          if (e != null) {\n            if (!visited.add(e)) {\n              foundCycle = true;\n              break;\n            }\n            queue.add(e);\n          }\n          // follow all implements edges\n          for (JSType iface : curr.getImplementedInterfaces()) {\n            FunctionType ic = iface.toMaybeFunctionType();\n            if (ic != null) {\n              if (!visited.add(ic)) {\n                foundCycle = true;\n                break;\n              }\n              queue.add(ic);\n            }\n          }\n        }\n        if (foundCycle) {\n          handleTypeCycle(t);\n        }\n      }\n    }\n\n    finishPropertyContinuations();\n    return registry.isLastGeneration() ? getReferencedType() : this;\n  }\n\n  // Fallback to property-based resolution.\n  resolveViaProperties(t, enclosing);\n  if (detectImplicitPrototypeCycle()) {\n    handleTypeCycle(t);\n  }\n\n  super.resolveInternal(t, enclosing);\n  if (isResolved()) {\n    finishPropertyContinuations();\n  }\n  return registry.isLastGeneration() ? getReferencedType() : this;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}