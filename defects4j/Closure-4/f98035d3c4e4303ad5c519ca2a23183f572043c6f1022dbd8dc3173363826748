{
    "generation": "  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n\n    // Try to resolve via the registry.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n\n    // Check for cycles after the first resolution attempt.\n    // It's important to do this even if resolution succeeded, as the registry\n    // resolution might have completed the type definition in a way that reveals\n    // a cycle.\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    // If registry resolution succeeded, we're mostly done.\n    if (resolved) {\n      super.resolveInternal(t, enclosing); // Mark as resolved in the base class.\n      finishPropertyContinuations();\n      // Return the resolved type if possible, otherwise return this proxy.\n      // If a cycle was handled, getReferencedType() should reflect that.\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    // If registry resolution failed, attempt property resolution.\n    // Crucially, check for cycles *before* calling resolveViaProperties,\n    // as this call can trigger recursive resolution that leads to StackOverflowError\n    // on cyclic definitions if the cycle isn't detected beforehand.\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n      // If a cycle is detected here, we assume handleTypeCycle marks the type\n      // appropriately (e.g., as an error type or breaks the cycle) so that\n      // resolveViaProperties below won't recurse infinitely.\n      // We proceed with resolveViaProperties even if a cycle is detected,\n      // matching the original code's behavior of attempting resolution\n      // after handling the cycle.\n    }\n\n    // Attempt resolution via properties (handling inheritance, interfaces, etc.).\n    resolveViaProperties(t, enclosing);\n\n    // We don't need a cycle check *after* resolveViaProperties here, because\n    // the check *before* the call should have caught any cycles detectable\n    // at that point. If resolveViaProperties itself introduces or reveals\n    // a cycle structure not detectable before, that might indicate a deeper issue,\n    // but this fix addresses the immediate StackOverflowError cause.\n\n    // Mark as resolved in the base class. This needs to happen regardless of\n    // whether property resolution succeeded, as resolveInternal needs to be\n    // called for bookkeeping.\n    super.resolveInternal(t, enclosing);\n\n    // Finish property continuations only if the type is now considered resolved\n    // (either through registry or properties).\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n\n    // Return the resolved type if possible, otherwise return this proxy.\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}