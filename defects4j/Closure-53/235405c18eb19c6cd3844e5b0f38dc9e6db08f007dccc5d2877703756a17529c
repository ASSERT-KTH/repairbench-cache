{
    "generation": "private void replaceAssignmentExpression(Var v, Reference ref, Map<String, String> varmap) {\n    // Compute all of the assignments necessary\n    List<Node> nodes = new ArrayList<>();\n    Node val = ref.getAssignedValue();\n    blacklistVarReferencesInTree(val, v.scope);\n    Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n    Set<String> all = new LinkedHashSet<>(varmap.keySet());\n    for (Node key = val.getFirstChild(); key != null; key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n    }\n\n    // Add assignments for variables not present in the object literal\n    for (String var : all) {\n        nodes.add(new Node(Token.ASSIGN, Node.newString(Token.NAME, varmap.get(var)), NodeUtil.newUndefinedNode(null)));\n    }\n\n    // Ensure the expression evaluates to true\n    nodes.add(new Node(Token.TRUE));\n\n    // Build the replacement expression\n    Node replacement = buildCommaExpression(nodes);\n\n    // Replace the original assignment\n    Node replace = ref.getParent();\n    replacement.copyInformationFromForTree(replace);\n\n    if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(replace, NodeUtil.newExpr(replacement));\n    } else {\n        replace.getParent().replaceChild(replace, replacement);\n    }\n}\n\nprivate Node buildCommaExpression(List<Node> nodes) {\n    if (nodes.isEmpty()) {\n        return new Node(Token.TRUE);\n    }\n    Node result = nodes.remove(nodes.size() - 1);\n    while (!nodes.isEmpty()) {\n        Node next = nodes.remove(nodes.size() - 1);\n        result = new Node(Token.COMMA, next, result);\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}