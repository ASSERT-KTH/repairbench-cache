{
    "generation": "    /**\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n     * Note that the resulting expression will always evaluate to\n     * true, as would the x = {...} expression.\n     * This handles the following cases:\n     * var x = {a: 1, b: 2}      => var x$a = 1, x$b = 2; (true is implicit)\n     * var x = {}               => [removed]\n     * x = {a: 1, b: 2}          => x$a = 1, x$b = 2, true\n     * x = {}                   => true\n     * return {a: 1, b: 2}       => return (x$a = 1, x$b = 2, true)\n     * fn({a: 1, b: 2})          => fn((x$a = 1, x$b = 2, true))\n     * fn({})                   => fn(true)\n     */\n    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary from the object literal properties.\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue(); // This is the OBJECTLIT node.\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> keysInLiteral = Sets.newHashSet();\n\n      // Iterate over properties in the object literal\n      Node nextKey;\n      for (Node key = val.getFirstChild(); key != null; key = nextKey) {\n         nextKey = key.getNext(); // Get next before potentially removing value node\n         // Handle only simple string properties for this optimization\n         // Assumes rewriteObjectLiteral already handled computed/getter/setter props.\n         if (key.isStringKey()) {\n             String keyName = key.getString();\n             // Check if this property is needed for inlining (i.e., is in varmap)\n             if (varmap.containsKey(keyName)) {\n                 // Avoid issues with duplicate keys, only process the first one.\n                 if (keysInLiteral.add(keyName)) {\n                     Node value = key.removeFirstChild(); // Removes value and detaches it\n                     // TODO(user): Copy type information.\n                     nodes.add(\n                       new Node(Token.ASSIGN,\n                                Node.newString(Token.NAME, varmap.get(keyName)), value));\n                 } else {\n                     // Duplicate key encountered, already processed. Detach the value.\n                      if (key.hasChildren()) {\n                         key.removeFirstChild();\n                      }\n                 }\n             } else {\n                // Property key not in varmap (e.g., not read later), ignore. Detach value if present.\n                 if (key.hasChildren()) {\n                    key.removeFirstChild();\n                 }\n             }\n         } else {\n            // Should not happen if rewriteObjectLiteral ran first.\n            throw new IllegalStateException(\"Unexpected OBJECTLIT child: \" + key + \". Parent: \" + val);\n         }\n      }\n\n      // Add assignments for properties that were expected (in varmap, thus read elsewhere)\n      // but were not present in the literal. These should be assigned 'undefined'.\n      Set<String> expectedKeys = Sets.newLinkedHashSet(varmap.keySet());\n      expectedKeys.removeAll(keysInLiteral); // Remove keys found in the literal\n      for (String keyName : expectedKeys) {\n        // TODO(user): Better source information.\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(keyName)),\n                   NodeUtil.newUndefinedNode(null))); // Assign undefined\n      }\n\n      Node replacement;\n      boolean hasAssignments = !nodes.isEmpty();\n\n      // The replacement expression must evaluate to true, like the original {}.\n      // Add a TRUE node to the list of expressions to be joined by commas.\n      nodes.add(new Node(Token.TRUE));\n\n      // Build the replacement node (a COMMA sequence or just TRUE).\n      if (nodes.size() == 1) {\n          // Only the TRUE node was added (no assignments needed).\n          replacement = nodes.get(0); // Just TRUE\n          Preconditions.checkState(!hasAssignments, \"Should not have assignments if only TRUE node exists\");\n      } else {\n          // Build COMMA tree: COMMA(assign1, COMMA(assign2, ... COMMA(assignN, TRUE)))\n          // Start from the last node (TRUE) and work backwards.\n          replacement = nodes.get(nodes.size() - 1);\n          for (int i = nodes.size() - 2; i >= 0; i--) {\n              replacement = new Node(Token.COMMA, nodes.get(i), replacement);\n          }\n      }\n\n      // Replace the original node (VAR's parent, ASSIGN's parent, or OBJECTLIT's parent).\n      Node nodeToReplace = ref.getParent();\n      Node parent = nodeToReplace.getParent();\n      replacement.copyInformationFromForTree(nodeToReplace);\n\n      if (nodeToReplace.isVar()) {\n          // Original was 'var v = {...}'\n          if (!hasAssignments) {\n              // If no assignments were needed (e.g., var x = {}), remove the VAR declaration entirely.\n              NodeUtil.removeChild(parent, nodeToReplace);\n          } else {\n              // Replace 'var v = {...}' with 'assign1, assign2, ..., true;'\n              // The comma expression must be wrapped in an EXPR_RESULT for a statement context.\n              Node exprNode = NodeUtil.newExpr(replacement);\n              parent.replaceChild(nodeToReplace, exprNode);\n              // Copy source info from the original VAR statement to the new expression statement.\n              exprNode.copyInformationFrom(nodeToReplace);\n          }\n          compiler.reportCodeChange();\n      } else if (nodeToReplace.isAssign()) {\n          // Original was 'lhs = {...}'\n          // Replace the ASSIGN node directly with the comma expression.\n          parent.replaceChild(nodeToReplace, replacement);\n          compiler.reportCodeChange();\n      } else {\n          // The reference's parent wasn't VAR or ASSIGN.\n          // This implies the object literal was used directly in an expression, e.g., fn({...}).\n          // In this case, the node to replace is the OBJECTLIT itself (ref.getNode()).\n          Node objectLitNode = ref.getNode();\n          Preconditions.checkState(objectLitNode == val, \"Reference node should be the object literal value\");\n          nodeToReplace.replaceChild(objectLitNode, replacement); // Replace child within parent expression\n          compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}