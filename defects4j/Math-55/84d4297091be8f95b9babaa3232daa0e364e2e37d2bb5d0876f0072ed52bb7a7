{
    "generation": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      // we have to compute the cross product in a way that avoids\n      // cancellation problems that occur when the vectors are almost\n      // parallel (co-linear or anti-parallel). The following formula\n      // was found in Kahan lecture\n      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n      final double ax = v1.x;\n      final double ay = v1.y;\n      final double az = v1.z;\n      final double bx = v2.x;\n      final double by = v2.y;\n      final double bz = v2.z;\n\n      final double x = ay * bz - az * by;\n      final double y = az * bx - ax * bz;\n      final double z = ax * by - ay * bx;\n\n      if ((x == 0.0) && (y == 0.0) && (z == 0.0)) {\n          // the vectors are co-linear or anti-parallel, we use an alternate formula\n          final double a2 = ax * ax + ay * ay + az * az;\n          final double b2 = bx * bx + by * by + bz * bz;\n          final double ab = ax * bx + ay * by + az * bz;\n          final double s = FastMath.sqrt(a2 * b2 - ab * ab);\n          return new Vector3D(s, v1, -s, v2);\n      } else {\n          return new Vector3D(x, y, z);\n      }\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}