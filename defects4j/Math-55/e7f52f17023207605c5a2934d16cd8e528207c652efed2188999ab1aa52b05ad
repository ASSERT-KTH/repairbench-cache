{
    "generation": "import org.apache.commons.math.util.FastMath; // Assuming Vector3D uses this or similar math utilities\n// Assuming Vector3D class has methods like getX(), getY(), getZ(), getNormSq(), getNorm(), scalarMultiply()\n// and a constructor Vector3D(double x, double y, double z), and a constant Vector3D.ZERO.\n\n  /** Compute the cross-product of two vectors.\n   * Implements the robust algorithm from Kahan's paper \"Computing Cross-Products and Rotations\n   * in 2- and 3-Dimensional Euclidean Spaces\" combining normalization and orthogonalization\n   * to improve handling of scaling issues and cases with nearly parallel vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      // Get the norms squared\n      double norm1Sq = v1.getNormSq();\n      double norm2Sq = v2.getNormSq();\n\n      // Get the norms\n      double norm1 = FastMath.sqrt(norm1Sq);\n      double norm2 = FastMath.sqrt(norm2Sq);\n\n      // Handle zero vectors\n      // Use a tolerance to avoid issues with tiny norms leading to large inverse norms\n      final double epsilon = 1e-10; // A small tolerance for checking zero norm\n      if (norm1 < epsilon || norm2 < epsilon) {\n          return Vector3D.ZERO;\n      }\n\n      // Normalize the vectors\n      double invNorm1 = 1.0 / norm1;\n      double invNorm2 = 1.0 / norm2;\n      double u1x = v1.getX() * invNorm1;\n      double u1y = v1.getY() * invNorm1;\n      double u1z = v1.getZ() * invNorm1;\n      double u2x = v2.getX() * invNorm2;\n      double u2y = v2.getY() * invNorm2;\n      double u2z = v2.getZ() * invNorm2;\n\n      // Compute rho = u1 . u2 (cosine of angle between vectors)\n      double rho = u1x * u2x + u1y * u2y + u1z * u2z;\n\n      // Compute p = u1 - rho * u2 (component of u1 orthogonal to u2)\n      // This calculation is more stable when u1 and u2 are nearly parallel\n      double pX = u1x - rho * u2x;\n      double pY = u1y - rho * u2y;\n      double pZ = u1z - rho * u2z;\n\n      // Compute cross product q = p x u2\n      // Since p is orthogonal to u2, this cross product is well-behaved.\n      double qX = pY * u2z - pZ * u2y;\n      double qY = pZ * u2x - pX * u2z;\n      double qZ = pX * u2y - pY * u2x;\n\n      // Final result is scaled by the original norms: (norm1 * norm2) * q\n      // Compute scale factor carefully to avoid intermediate overflow/underflow if possible,\n      // though standard multiplication is usually sufficient here.\n      double scale = norm1 * norm2;\n\n      return new Vector3D(scale * qX, scale * qY, scale * qZ);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}