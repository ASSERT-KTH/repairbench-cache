{
    "generation": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      // short\u2010circuit if v2 is zero\n      final double x2 = v2.x;\n      final double y2 = v2.y;\n      final double z2 = v2.z;\n      final double norm2 = x2 * x2 + y2 * y2 + z2 * z2;\n      if (norm2 == 0.0) {\n          return new Vector3D(0.0, 0.0, 0.0);\n      }\n\n      // precondition v1 = v3 + rho * v2 so that v3 = v1 - rho * v2 is small\n      final double x1 = v1.x;\n      final double y1 = v1.y;\n      final double z1 = v1.z;\n      double dot = x1 * x2 + y1 * y2 + z1 * z2;\n      double rho = dot / norm2;\n\n      // quantize rho to an 8\u2010bit approximation to avoid cancellation\n      if (rho != 0.0) {\n          int exp = FastMath.getExponent(rho);\n          double mant = FastMath.scalb(rho, -exp);      // bring to [1,2)\n          long   m    = FastMath.round(mant * 256.0);   // round to nearest 1/256\n          mant = m / 256.0;\n          rho  = FastMath.scalb(mant, exp);\n      }\n\n      // compute the \"small\" component v3 = v1 - rho * v2\n      double x3 = x1 - rho * x2;\n      double y3 = y1 - rho * y2;\n      double z3 = z1 - rho * z2;\n\n      // now do the cross\u2010product of v3 with v2\n      return new Vector3D(\n          y3 * z2 - z3 * y2,\n          z3 * x2 - x3 * z2,\n          x3 * y2 - y3 * x2\n      );\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}