{
    "generation": "import org.apache.commons.math.util.FastMath; // Assuming FastMath is available in the environment\n\npublic class Vector3D { // Class header implicitly assumed as only method is provided\n\n    // Assuming Vector3D has public final double x, y, z fields, or equivalent getters\n    public final double x;\n    public final double y;\n    public final double z;\n\n    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n        // The original code was a direct, numerically unstable cross product.\n        // This fix implements the Kahan-style preconditioning described in the comments,\n        // which is crucial for reducing cancellation errors when vectors are nearly parallel\n        // or have components of vastly different magnitudes (as in the cancellation test).\n\n        double x1 = v1.x;\n        double y1 = v1.y;\n        double z1 = v1.z;\n        double x2 = v2.x;\n        double y2 = v2.y;\n        double z2 = v2.z;\n\n        // Rescale both vectors without losing precision.\n        // This ensures their norms are of the same order of magnitude before\n        // computing the dot products for rho, preventing potential overflows or underflows.\n        double s  = FastMath.max(FastMath.max(FastMath.abs(x1), FastMath.abs(y1)), FastMath.abs(z1));\n        s = FastMath.max(s, FastMath.max(FastMath.max(FastMath.abs(x2), FastMath.abs(y2)), FastMath.abs(z2)));\n\n        if (s > 1.0) {\n            x1 /= s; y1 /= s; z1 /= s;\n            x2 /= s; y2 /= s; z2 /= s;\n        }\n\n        // We reduce cancellation errors by preconditioning,\n        // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n        // v3 without loss of precision. See Kahan lecture\n        // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n        // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n        // Compute rho as an 8-bit approximation of v1.v2 / v2.v2.\n        // This specific bit-masking is part of the Kahan's algorithm for robustness.\n        final double b1 = x1 * x2 + y1 * y2 + z1 * z2; // Scaled dot product v1.v2\n        final double b2 = x2 * x2 + y2 * y2 + z2 * z2; // Scaled squared norm of v2\n        final double rho = b1 / b2;\n\n        // Truncate rho to 8 bits of mantissa precision.\n        // This ensures that r * v2_scaled can be computed accurately\n        // relative to v1_scaled, making the subtraction v1_scaled - r * v2_scaled stable.\n        final double r = Double.longBitsToDouble((Double.doubleToLongBits(rho) & 0xFFFFFFF800000000L));\n\n        // Compute v3 = v1_scaled - r * v2_scaled.\n        // This intermediate vector's components are typically much smaller,\n        // reducing subsequent cancellation issues.\n        final double x3 = x1 - r * x2;\n        final double y3 = y1 - r * y2;\n        final double z3 = z1 - r * z2;\n\n        // Compute the cross product from v3 and v2_scaled instead of v1_scaled and v2_scaled.\n        // Mathematically, v1 ^ v2 = (v3 + r*v2) ^ v2 = v3 ^ v2.\n        // Numerically, this calculation is more accurate for near-parallel vectors.\n        // Finally, multiply by the original scaling factor 's' to restore the correct magnitude.\n        return new Vector3D((y3 * z2 - z3 * y2) * s, (z3 * x2 - x3 * z2) * s, (x3 * y2 - y3 * x2) * s);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}