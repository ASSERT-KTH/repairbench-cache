{
    "generation": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    // When v1 and v2 are nearly parallel cancellation can occur.\n    // To reduce cancellation errors we \u201cprecondition\u201d by replacing v1 with v1'\n    // so that v1\u2032 = v1 \u2013 \u03c1 v2, with \u03c1 chosen as an 8\u2010bit rounded value of (v1\u00b7v2)/(v2\u00b7v2).\n    // In addition we \u201cequalize\u201d the vector norms if they differ by scaling the vector\n    // with the larger norm (and later undoing the scaling).\n    \n    // First, get the Euclidean norms.\n    double norm1 = v1.getNorm();\n    double norm2 = v2.getNorm();\n    if (norm1 == 0 || norm2 == 0) {\n        return new Vector3D(0, 0, 0);\n    }\n    \n    // Scale the vectors so that they become of comparable magnitude.\n    // If their norms differ, multiply the vector with the larger norm by a factor\n    // so that after scaling both have the same norm. (We must later \u201cundo\u201d this factor.)\n    Vector3D u1 = v1;\n    Vector3D u2 = v2;\n    double scaleFactor = 1.0;\n    if (norm1 < norm2) {\n        // Scale v2 down to the norm of v1.\n        scaleFactor = norm1 / norm2;\n        u2 = v2.scalarMultiply(scaleFactor);\n    } else if (norm2 < norm1) {\n        // Scale v1 down to the norm of v2.\n        scaleFactor = norm2 / norm1;\n        u1 = v1.scalarMultiply(scaleFactor);\n    }\n    \n    // Compute the dot products using the scaled vectors.\n    double dot22 = u2.x * u2.x + u2.y * u2.y + u2.z * u2.z;\n    double dot12 = u1.x * u2.x + u1.y * u2.y + u1.z * u2.z;\n    double r = dot12 / dot22;\n    \n    // Compute an 8-bit approximation of r.\n    double rho = Math.rint(r * 256) / 256;\n    \n    // Apply the preconditioning: form u1' = u1 - rho * u2.\n    Vector3D u1prime = new Vector3D(u1.x - rho * u2.x,\n                                    u1.y - rho * u2.y,\n                                    u1.z - rho * u2.z);\n    \n    // Compute the cross product from u1prime and u2.\n    // Because u1\u2032 \u00d7 u2  = (v1 \u2212 \u03c1v2) \u00d7 v2 = v1 \u00d7 v2.\n    double cpX = u1prime.y * u2.z - u1prime.z * u2.y;\n    double cpY = u1prime.z * u2.x - u1prime.x * u2.z;\n    double cpZ = u1prime.x * u2.y - u1prime.y * u2.x;\n    Vector3D cp = new Vector3D(cpX, cpY, cpZ);\n    \n    // Undo the rescaling if one vector was scaled.\n    if (norm1 < norm2 || norm2 < norm1) {\n        cp = cp.scalarMultiply(1.0 / scaleFactor);\n    }\n    \n    return cp;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}