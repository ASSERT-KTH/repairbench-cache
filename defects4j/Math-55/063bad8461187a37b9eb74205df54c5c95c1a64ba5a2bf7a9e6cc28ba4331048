{
    "generation": "import org.apache.commons.math.util.FastMath;\n\n  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      // This implementation uses Kahan's cross product for improved numerical accuracy,\n      // especially when vectors are nearly parallel. The traditional formula\n      // suffers from catastrophic cancellation errors in such cases.\n      //\n      // The core idea is to compute (v1 - rho * v2) x v2, which is mathematically\n      // equivalent to v1 x v2. Here, rho is chosen in a way that allows the\n      // (v1 - rho * v2) term to be computed with high relative precision.\n      // Specifically, we pick a coordinate of v2 with the largest absolute value\n      // to serve as a stable divisor.\n\n      final double x1 = v1.x;\n      final double y1 = v1.y;\n      final double z1 = v1.z;\n      final double x2 = v2.x;\n      final double y2 = v2.y;\n      final double z2 = v2.z;\n\n      // Determine which component of v2 is largest in magnitude.\n      // This component will be used as the scaling factor to form 'rho'\n      // in a way that minimizes precision loss.\n      if (FastMath.abs(x2) >= FastMath.abs(y2) && FastMath.abs(x2) >= FastMath.abs(z2)) {\n          // If x2 is the largest component of v2, compute intermediate values\n          // based on v3 = v1 - (x1/x2) * v2. The x-component of v3 will be zero.\n          final double ry1 = y1 - (x1 / x2) * y2;\n          final double rz1 = z1 - (x1 / x2) * z2;\n          // The cross product (v3 x v2) then becomes:\n          // X component: v3.y * v2.z - v3.z * v2.y = ry1 * z2 - rz1 * y2\n          // Y component: v3.z * v2.x - v3.x * v2.z = rz1 * x2 - 0 * z2 = rz1 * x2\n          // Z component: v3.x * v2.y - v3.y * v2.x = 0 * y2 - ry1 * x2 = -ry1 * x2\n          return new Vector3D(ry1 * z2 - rz1 * y2,\n                              rz1 * x2,\n                              -ry1 * x2);\n      } else if (FastMath.abs(y2) >= FastMath.abs(x2) && FastMath.abs(y2) >= FastMath.abs(z2)) {\n          // If y2 is the largest component of v2, compute intermediate values\n          // based on v3 = v1 - (y1/y2) * v2. The y-component of v3 will be zero.\n          final double rx1 = x1 - (y1 / y2) * x2;\n          final double rz1 = z1 - (y1 / y2) * z2;\n          // The cross product (v3 x v2) then becomes:\n          // X component: v3.y * v2.z - v3.z * v2.y = 0 * z2 - rz1 * y2 = -rz1 * y2\n          // Y component: v3.z * v2.x - v3.x * v2.z = rz1 * x2 - rx1 * z2\n          // Z component: v3.x * v2.y - v3.y * v2.x = rx1 * y2 - 0 * x2 = rx1 * y2\n          return new Vector3D(-rz1 * y2,\n                              rz1 * x2 - rx1 * z2,\n                              rx1 * y2);\n      } else {\n          // If z2 is the largest component of v2, compute intermediate values\n          // based on v3 = v1 - (z1/z2) * v2. The z-component of v3 will be zero.\n          final double rx1 = x1 - (z1 / z2) * x2;\n          final double ry1 = y1 - (z1 / z2) * z2;\n          // The cross product (v3 x v2) then becomes:\n          // X component: v3.y * v2.z - v3.z * v2.y = ry1 * z2 - 0 * y2 = ry1 * z2\n          // Y component: v3.z * v2.x - v3.x * v2.z = 0 * x2 - rx1 * z2 = -rx1 * z2\n          // Z component: v3.x * v2.y - v3.y * v2.x = rx1 * y2 - ry1 * x2\n          return new Vector3D(ry1 * z2,\n                              -rx1 * z2,\n                              rx1 * y2 - ry1 * x2);\n      }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}