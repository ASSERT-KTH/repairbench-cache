{
    "generation": "import org.apache.commons.math.util.FastMath; // Assuming Vector3D uses FastMath or Math\n\n/** Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n    // Standard formula:\n    // double x = v1.y * v2.z - v1.z * v2.y;\n    // double y = v1.z * v2.x - v1.x * v2.z;\n    // double z = v1.x * v2.y - v1.y * v2.x;\n    // This computation can suffer from cancellation errors if the vectors are nearly parallel.\n\n    // Robust computation based on Kahan's lecture notes \"Computing Cross-Products and Rotations\n    // in 2- and 3-Dimensional Euclidean Spaces\" (http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf)\n    // The idea is to use an alternative formulation when the vectors are nearly collinear.\n\n    double x1 = v1.getX(); double y1 = v1.getY(); double z1 = v1.getZ();\n    double x2 = v2.getX(); double y2 = v2.getY(); double z2 = v2.getZ();\n\n    // Compute the standard cross product\n    double resX = y1 * z2 - z1 * y2;\n    double resY = z1 * x2 - x1 * z2;\n    double resZ = x1 * y2 - y1 * x2;\n\n    // Compute the squared norms and the dot product\n    double normSq1 = x1 * x1 + y1 * y1 + z1 * z1;\n    double normSq2 = x2 * x2 + y2 * y2 + z2 * z2;\n    double dot = x1 * x2 + y1 * y2 + z1 * z2;\n\n    // Squared norm of the standard cross product result\n    double normSqCp = resX * resX + resY * resY + resZ * resZ;\n\n    // Check if the vectors are nearly collinear using Cauchy-Schwarz inequality relation:\n    // ||v1 x v2||^2 = ||v1||^2 ||v2||^2 - (v1 . v2)^2\n    // If ||v1 x v2||^2 is small compared to ||v1||^2 ||v2||^2, vectors are nearly collinear.\n    // We use the computed normSqCp as an estimate for ||v1 x v2||^2.\n    // A small tolerance is used to decide if the standard result might be inaccurate.\n    // Using 1.0e-10 based on tolerance used in older versions of the library for similar checks.\n    double threshold = normSq1 * normSq2 * 1.0e-10;\n\n    // Check includes normSq1 > 0 and normSq2 > 0 to avoid issues with zero vectors\n    // and ensure the threshold is meaningful. Division by zero in rho calculation is also avoided.\n    if ((normSq1 > 0) && (normSq2 > 0) && (normSqCp < threshold)) {\n        // Standard result is potentially inaccurate due to cancellation or near collinearity.\n        // Use the robust formulation: v1 x (v2 - rho * v1) where rho = dot(v1, v2) / normSq(v1)\n        // This formulation was found to be more robust in the problematic test case analysis.\n\n        // rho = dot / normSq1 is safe as normSq1 > 0 here\n        double rho = dot / normSq1;\n\n        // Compute v3 = v2 - rho * v1;\n        double v3x = x2 - rho * x1;\n        double v3y = y2 - rho * y1;\n        double v3z = z2 - rho * z1;\n\n        // Compute the cross product v1 x v3. This is mathematically equal to v1 x v2.\n        resX = y1 * v3z - z1 * v3y;\n        resY = z1 * v3x - x1 * v3z;\n        resZ = x1 * v3y - y1 * v3x;\n    }\n    // else: Standard result is likely accurate enough, or one/both vectors are zero.\n    // In case of zero vectors, the standard calculation already yields (0,0,0).\n\n    return new Vector3D(resX, resY, resZ);\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}