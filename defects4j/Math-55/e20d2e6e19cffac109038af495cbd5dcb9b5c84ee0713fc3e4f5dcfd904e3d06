{
    "generation": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n      // This implementation is based on the robust cross-product algorithm\n      // described in \"Computing Cross-Products and Rotations in 2- and\n      // 3-Dimensional Euclidean Spaces\" by W. Kahan (available at\n      // http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf),\n      // and as implemented in Apache Commons Math 3.x.\n\n      final double x1 = v1.x;\n      final double y1 = v1.y;\n      final double z1 = v1.z;\n\n      final double x2 = v2.x;\n      final double y2 = v2.y;\n      final double z2 = v2.z;\n\n      // Compute the naive cross product. This is susceptible to cancellation.\n      final double cX = y1 * z2 - z1 * y2;\n      final double cY = z1 * x2 - x1 * z2;\n      final double cZ = x1 * y2 - y1 * x2;\n\n      // Compute dot products required for Kahan's algorithm.\n      final double dp = x1 * x2 + y1 * y2 + z1 * z2; // v1 . v2\n      final double vv = x2 * x2 + y2 * y2 + z2 * z2; // v2 . v2\n\n      // If v2 is essentially a zero vector, the cross product is zero.\n      // A small threshold is used to account for floating-point inaccuracies near zero.\n      if (vv < 1.0e-20) { // Using a threshold slightly larger than Double.MIN_VALUE squared for safety\n          return new Vector3D(0.0, 0.0, 0.0);\n      }\n\n      // Compute rho: this value represents the scalar projection of v1 onto v2.\n      // v1 - rho * v2 will be a vector orthogonal to v2.\n      final double rho = dp / vv;\n\n      // Compute w = v1 - rho * v2.\n      // This transformation helps in avoiding cancellation errors when v1 and v2 are nearly parallel.\n      final double wX = x1 - rho * x2;\n      final double wY = y1 - rho * y2;\n      final double wZ = z1 - rho * z2;\n\n      // Compute the cross product (w x v2).\n      // This computation is often more accurate for components that would otherwise suffer\n      // from cancellation in the naive calculation.\n      final double dX = wY * z2 - wZ * y2;\n      final double dY = wZ * x2 - wX * z2;\n      final double dZ = wX * y2 - wY * x2;\n\n      // Select the components for the final result.\n      // Kahan's strategy is to pick the component from the naive calculation\n      // that has the largest absolute magnitude (as it's usually less affected by relative error),\n      // and the other two components from the corrected (w x v2) calculation.\n      final double cXA = FastMath.abs(cX);\n      final double cYA = FastMath.abs(cY);\n      final double cZA = FastMath.abs(cZ);\n\n      if (cXA > cYA) {\n          if (cXA > cZA) {\n              // cX is the largest component, so keep it and use dY, dZ.\n              return new Vector3D(cX, dY, dZ);\n          } else {\n              // cZ is the largest component, so keep it and use dX, dY.\n              return new Vector3D(dX, dY, cZ);\n          }\n      } else {\n          if (cYA > cZA) {\n              // cY is the largest component, so keep it and use dX, dZ.\n              return new Vector3D(dX, cY, dZ);\n          } else {\n              // cZ is the largest component, so keep it and use dX, dY.\n              return new Vector3D(dX, dY, cZ);\n          }\n      }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}