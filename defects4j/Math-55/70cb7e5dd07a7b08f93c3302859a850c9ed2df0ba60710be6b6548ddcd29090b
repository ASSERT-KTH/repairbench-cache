{
    "generation": "import org.apache.commons.math.util.FastMath; // Assuming FastMath is available and used for math functions\n\n/** Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n    // Kahan's algorithm for robust cross product\n    // See: http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n    // We reduce cancellation errors by preconditioning:\n    // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n    // v3 without loss of precision. Then v1 ^ v2 = v3 ^ v2.\n\n    // 1. Handle zero vectors explicitly.\n    // If either vector is a zero vector, their cross product is the zero vector.\n    // Using normSq() is more robust than checking against 0.0 directly for floating point numbers\n    // and avoids a square root calculation.\n    if (v1.getNormSq() == 0.0 || v2.getNormSq() == 0.0) {\n        return new Vector3D(0, 0, 0);\n    }\n\n    // 2. Compute rho as an approximation of v1.v2 / v2.v2.\n    // The dotProduct methods are assumed to be sufficient for this approximation\n    // within the context of this specific robust algorithm.\n    final double dotV1V2 = v1.dotProduct(v2);\n    final double dotV2V2 = v2.dotProduct(v2);\n\n    // If dotV2V2 is very small (v2 is effectively zero after potential scaling,\n    // though this should ideally be caught by the initial zero check),\n    // handle it to prevent division by zero or large 'rho' from numerical noise.\n    // However, the initial check covers the strict zero case. If dotV2V2 is non-zero\n    // but tiny due to floating point error, it implies v2 is very close to zero,\n    // and a robust algorithm would yield a zero cross product or something close.\n    // For this specific Kahan variant, proceed as rho will naturally be huge,\n    // which the v3 transformation is designed to handle.\n    final double rho = dotV1V2 / dotV2V2;\n\n    // 3. Compute v3 = v1 - rho * v2.\n    // This step reduces the component of v1 parallel to v2, making v3 more orthogonal to v2.\n    // The \"without loss of precision\" implies that the principle of this transformation\n    // leads to a more accurate final result, rather than requiring compensated arithmetic\n    // for these intermediate subtractions themselves (which would be much more complex).\n    final double v3x = v1.getX() - rho * v2.getX();\n    final double v3y = v1.getY() - rho * v2.getY();\n    final double v3z = v1.getZ() - rho * v2.getZ();\n\n    // 4. Compute the cross product from v3 and v2 instead of v1 and v2.\n    // This final calculation is numerically more stable due to v3's orthogonality to v2.\n    return new Vector3D(v3y * v2.getZ() - v3z * v2.getY(),\n                        v3z * v2.getX() - v3x * v2.getZ(),\n                        v3x * v2.getY() - v3y * v2.getX());\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}