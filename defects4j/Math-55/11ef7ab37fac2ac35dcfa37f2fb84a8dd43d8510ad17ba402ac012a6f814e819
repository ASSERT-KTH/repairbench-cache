{
    "generation": "  /** Compute the cross-product of two vectors.\n   * @param v1 first vector\n   * @param v2 second vector\n   * @return the cross product v1 ^ v2 as a new Vector\n   */\n  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n      // Rescale vectors to avoid overflow/underflow\n      final double s1 = computeScaleFactor(v1);\n      final double s2 = computeScaleFactor(v2);\n\n      final double scaledX1 = v1.x * s1;\n      final double scaledY1 = v1.y * s1;\n      final double scaledZ1 = v1.z * s1;\n\n      final double scaledX2 = v2.x * s2;\n      final double scaledY2 = v2.y * s2;\n      final double scaledZ2 = v2.z * s2;\n\n      // Compute dot products\n      final double dotV1V2 = scaledX1 * scaledX2 + scaledY1 * scaledY2 + scaledZ1 * scaledZ2;\n      final double dotV2V2 = scaledX2 * scaledX2 + scaledY2 * scaledY2 + scaledZ2 * scaledZ2;\n\n      if (dotV2V2 == 0.0) {\n          return new Vector3D(0, 0, 0);\n      }\n\n      // Compute rho and round to 8 bits\n      double rho = dotV1V2 / dotV2V2;\n      rho = Math.rint(rho * 256.0) / 256.0;\n\n      // Compute v3 = v1 - rho * v2\n      final double scaledX3 = scaledX1 - rho * scaledX2;\n      final double scaledY3 = scaledY1 - rho * scaledY2;\n      final double scaledZ3 = scaledZ1 - rho * scaledZ2;\n\n      // Compute cross product of v3 and v2\n      final double crossX = scaledY3 * scaledZ2 - scaledZ3 * scaledY2;\n      final double crossY = scaledZ3 * scaledX2 - scaledX3 * scaledZ2;\n      final double crossZ = scaledX3 * scaledY2 - scaledY3 * scaledX2;\n\n      // Apply inverse scaling\n      final double invScale = 1.0 / (s1 * s2);\n      return new Vector3D(crossX * invScale, crossY * invScale, crossZ * invScale);\n  }\n\n  /** Compute scaling factor to avoid overflow/underflow. */\n  private static double computeScaleFactor(final Vector3D v) {\n      final double xAbs = Math.abs(v.x);\n      final double yAbs = Math.abs(v.y);\n      final double zAbs = Math.abs(v.z);\n      final int expX = xAbs == 0 ? Integer.MIN_VALUE : Math.getExponent(xAbs);\n      final int expY = yAbs == 0 ? Integer.MIN_VALUE : Math.getExponent(yAbs);\n      final int expZ = zAbs == 0 ? Integer.MIN_VALUE : Math.getExponent(zAbs);\n      final int maxExp = Math.max(expX, Math.max(expY, expZ));\n      return maxExp > Integer.MIN_VALUE ? Math.scalb(1.0, -maxExp) : 1.0;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}