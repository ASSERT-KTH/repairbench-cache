{
    "generation": "import org.apache.commons.math.geometry.Vector3D; // Assuming Vector3D class is available\n// Make sure necessary fields/methods like getX(), getY(), getZ(), dotProduct(), getNormSq(), ZERO exist.\n\n/** Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n    // Use Kahan's algorithm for robust cross product computation\n    // to mitigate cancellation errors with nearly parallel vectors.\n    // As described in the original comments, we compute v3 = v1 - rho * v2,\n    // where rho = (v1 . v2) / (v2 . v2), and then the cross product is v3 x v2.\n    // See Kahan paper \"Computing Cross-Products and Rotations...\" p. 15\n    // http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n    // Components of v1\n    double x1 = v1.getX();\n    double y1 = v1.getY();\n    double z1 = v1.getZ();\n\n    // Components of v2\n    double x2 = v2.getX();\n    double y2 = v2.getY();\n    double z2 = v2.getZ();\n\n    // Calculate dot products\n    // Using instance methods for potentially better precision/handling if they exist\n    double dot12 = v1.dotProduct(v2);\n    double dot22 = v2.getNormSq();\n\n    // If v2 is the zero vector, the cross product is the zero vector.\n    // Handles division by zero for rho calculation.\n    // Comparing floating point with == 0 can be tricky, but NormSq should be non-negative.\n    // If dot22 is extremely small but non-zero, rho could become very large.\n    // The subsequent calculations involving v3 are designed to handle this.\n    if (dot22 == 0) {\n        // Consider using a small tolerance epsilon instead of == 0 if needed,\n        // but for norm squared, == 0 is usually sufficient to check for zero vector.\n        return Vector3D.ZERO; // Assuming Vector3D.ZERO is (0,0,0) constant\n    }\n\n    // Calculate rho = (v1 . v2) / (v2 . v2)\n    double rho = dot12 / dot22;\n\n    // Compute components of v3 = v1 - rho * v2\n    // This step subtracts the projection of v1 onto v2 from v1,\n    // effectively making v3 orthogonal to v2 in calculation, reducing cancellation.\n    double x3 = x1 - rho * x2;\n    double y3 = y1 - rho * y2;\n    double z3 = z1 - rho * z2;\n\n    // Compute cross product v3 x v2\n    // Mathematically equivalent to v1 x v2, but often numerically more stable\n    // when v1 and v2 are nearly collinear.\n    double cx = y3 * z2 - z3 * y2;\n    double cy = z3 * x2 - x3 * z2;\n    double cz = x3 * y2 - y3 * x2;\n\n    return new Vector3D(cx, cy, cz);\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}