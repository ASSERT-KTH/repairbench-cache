{
    "generation": "// In com.fasterxml.jackson.databind.type.TypeFactory\n\n/**\n * Internal helper for constructing a class-based JavaType.\n * This version fixes a bug where non\u2010generic classes were never wired\n * with their superclass/interfaces if they came from the cache.\n */\nprotected JavaType _fromClass(Class<?> rawType,\n                              TypeBindings bindings,\n                              JavaType superClass,\n                              JavaType[] superInterfaces,\n                              boolean asStatic)\n{\n    // 1) check cache first to avoid repeated work\n    final Object key = _typeCache.key(rawType, bindings, superClass, superInterfaces, asStatic);\n    JavaType cached = _typeCache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n\n    // 2) if no type parameters, fast\u2010path simple type\n    if (!bindings.hasTypeVariables()) {\n        // ensure we compute the real superclass if not already passed in\n        JavaType sc = superClass;\n        if (sc == null) {\n            Class<?> parent = rawType.getSuperclass();\n            if (parent != null) {\n                sc = _fromClass(parent,\n                                TypeBindings.create(this, parent),\n                                null, null, asStatic);\n            }\n        }\n        // ensure we compute real interfaces if not already passed in\n        JavaType[] si = superInterfaces;\n        if (si == null) {\n            Class<?>[] ifcs = rawType.getInterfaces();\n            if (ifcs.length > 0) {\n                si = new JavaType[ifcs.length];\n                for (int i = 0; i < ifcs.length; ++i) {\n                    si[i] = _fromClass(ifcs[i],\n                                      TypeBindings.create(this, ifcs[i]),\n                                      null, null, asStatic);\n                }\n            }\n        }\n        // build and cache the resulting simple type\n        JavaType result = new SimpleType(rawType, bindings, sc, si, asStatic);\n        _typeCache.put(key, result);\n        return result;\n    }\n\n    // 3) otherwise handle generic/recursive cases in the full routine\n    return _fromClass2(rawType, bindings, superClass, superInterfaces, asStatic, key);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}