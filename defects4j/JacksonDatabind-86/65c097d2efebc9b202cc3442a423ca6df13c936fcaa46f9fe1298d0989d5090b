{
    "generation": "public JavaType constructType(Type type) {\n    // Existing implementation start\n    JavaType result;\n\n    // Check if we already have this type in cache\n    if (type instanceof Class<?>) {\n        Class<?> cls = (Class<?>) type;\n        // First try to find from cache (may be incomplete)\n        result = _typeCache.get(cls);\n        if (result != null) {\n            // Verify completeness if it's a recursive type\n            if (result.isRecursive()) {\n                RecursiveTypeHander handler = new RecursiveTypeHander(this);\n                result = handler.resolveed(result);\n            }\n            return result;\n        }\n\n        // Construct eagerly if not found in cache\n        result = _fromClass(_typeSource,\n                cls, cls.getTypeParameters(),\n                getBindingsForTypeParameters(cls));\n    } else if (type instanceof ParameterizedType) {\n        ParameterizedType pt = (ParameterizedType) type;\n        Class<?> rawClass = (Class<?>) pt.getRawType();\n        // Similar handling for ParameterizedType\n        result = _fromParamType(_typeSource,\n                pt, rawClass, pt.getActualTypeArguments());\n    } else if (type instanceof JavaType) {\n        return (JavaType) type;\n    } else {\n        result = _fromAny(_typeSource, type, null);\n    }\n\n    // Ensure recursive types are properly resolved\n    if (result.isRecursive()) {\n        RecursiveTypeHander handler = new RecursiveTypeHander(this);\n        result = handler.resolveRecursive(result);\n    }\n\n    // Cache the result if it's a class type (most common case)\n    if (type instanceof Class<?> && !result.incomplete()) {\n        _typeCache.put((Class<?>) type, result);\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}