{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.util.List;\n\n/**\n * Type that is used to denote a recursive type reference; used to break\n * cycles during type resolution.\n *<p>\n * NOTE: since 2.7, this class is NOT exposed via public API, and is\n * only used internally.\n */\npublic class ResolvedRecursiveType extends ReferenceType\n{\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Actual type that this is resolved to.\n     */\n    protected JavaType _referencedType;\n\n    public ResolvedRecursiveType(Class<?> erased, TypeBindings bindings) {\n        // We do not pass 'referencedType' (anchor type) in constructor, but will set it\n        // using `setResolvedType()` once recursive resolution has completed.\n        // Therefore, null for superclass and superinterfaces as well, initially.\n        super(erased, bindings, null, null, null, null, false);\n    }\n\n    public void setResolvedType(JavaType refType) {\n        if (_referencedType != null) {\n            throw new IllegalStateException(\"Recursive type already resolved to \"+_referencedType);\n        }\n        _referencedType = refType;\n    }\n\n    /*\n    /**********************************************************\n    /* Overrides for common JavaType methods\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getSuperClass() {\n        // [databind#1647]: Need to delegate to the *actual* resolved type, not\n        // the 'anchor type' of the superclass (ReferenceType) as that is initialized to null\n        // in this specific usage of ReferenceType constructor.\n        if (_referencedType != null) {\n            return _referencedType.getSuperClass();\n        }\n        // If not yet resolved, fall back to super implementation, which will return null\n        // because superclass was passed as null in constructor.\n        return super.getSuperClass();\n    }\n\n    @Override\n    public List<JavaType> getInterfaces() {\n        if (_referencedType != null) {\n            return _referencedType.getInterfaces();\n        }\n        return super.getInterfaces();\n    }\n\n    @Override\n    public JavaType getContentType() {\n        if (_referencedType != null) {\n            return _referencedType.getContentType();\n        }\n        return null;\n    }\n\n    @Override\n    public JavaType getKeyType() {\n        if (_referencedType != null) {\n            return _referencedType.getKeyType();\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isContainerType() {\n        return _referencedType != null && _referencedType.isContainerType();\n    }\n\n    // [databind#1647]: Also ensure equality and hash codes reflect the actual resolved type\n    @Override\n    public String toString() {\n        if (_referencedType != null) {\n            return _referencedType.toString();\n        }\n        return super.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n        \n        // [databind#1647]: If resolved, compare by actual type; otherwise by nominal type + bindings\n        if (_referencedType != null) {\n            return _referencedType.equals(((ResolvedRecursiveType) o)._referencedType);\n        }\n        // NOTE: this case only happens if `equals` called before resolution;\n        // should be based on nominal type + bindings\n        return super.equals(o);\n    }\n\n    @Override // Important for TypeFactory caching\n    public int hashCode() {\n        if (_referencedType != null) {\n            return _referencedType.hashCode();\n        }\n        return super.hashCode();\n    }\n\n    /*\n    /**********************************************************\n    /* Abstract method implementations (from ReferenceType)\n    /**********************************************************\n     */\n\n    // Remaining methods from ReferenceType which need to delegate to `_referencedType` if set\n    // or provide a default for placeholder state.\n    // NOTE: Many of these are already handled by `ReferenceType`'s default implementation,\n    // but some might need explicit override if `ReferenceType`'s `_referencedType` (anchor type)\n    // is null or different from `ResolvedRecursiveType`'s `_referencedType`.\n\n    // The provided `ReferenceType` in Jackson 2.9/2.10 source has `_referencedType` initialized\n    // in its constructor and its `getSuperClass` and `getInterfaces` methods *already* delegate\n    // to that `_referencedType`.\n    // The key insight is that `ResolvedRecursiveType`'s constructor passes `null` for that\n    // `_referencedType` (anchor type) of the `ReferenceType` base class.\n    // So, `ResolvedRecursiveType` *must* override these methods to use *its own* `_referencedType`.\n\n    // This section includes other overrides for correctness, though `getSuperClass()`\n    // was the direct cause of the test failures.\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        if (_referencedType != null) {\n            return _referencedType.refine(rawType, bindings, superClass, superInterfaces);\n        }\n        // Fallback for when not yet resolved (unlikely to be called in this state for refine)\n        return new ResolvedRecursiveType(rawType, bindings); // or other appropriate fallback\n    }\n\n    // Other methods that might need to be overridden for full delegation transparency\n    // (e.g., `hasGenericTypes`, `containedTypeCount`, `containedType`, `findSuperType`, etc.)\n    // are often handled by `ReferenceType` or `SimpleType` or `TypeBase` if they\n    // correctly delegate to the underlying class, or if their functionality does not\n    // depend on the `_referencedType` itself.\n    // The core fix addresses the hierarchy and property resolution issues.\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}