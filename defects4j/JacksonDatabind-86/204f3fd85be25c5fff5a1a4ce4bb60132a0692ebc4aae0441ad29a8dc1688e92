{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\n// Class definition and other methods are omitted for brevity\n\npublic class SimpleType extends TypeBase\n{\n    private static final long serialVersionUID = 1L;\n\n    // Mappings to formal type parameters (if any)\n    // (NOTE: was transient in 1.x)\n    /**\n     * Type parameters of the class represented by this type instance.\n     */\n    protected final JavaType[] _typeParameters;\n\n    /**\n     * Contained types; possibly needed for type resolution\n     * (for example, content type of arrays)\n     */\n    protected final JavaType[] _containedTypes;\n\n    /**\n     * Specific handler (serializer, deserializer) to use for handling instances of this type.\n     * @since 2.9\n     */\n    protected final Object _valueHandler;\n\n    /**\n     * Specific handler (serializer, deserializer) to use for handling instances of this type.\n     * @since 2.9\n     */\n    protected final Object _typeHandler;\n\n    /**\n     * @since 2.9\n     */\n    protected final boolean _asStatic;\n\n    /**\n     * Lazily resolved references to super-classes (if any), class hierarchy.\n     * Does not include type itself.\n     *\n     * @since 2.7\n     */\n    protected HierarchicType _superClass;\n\n    /**\n     * Lazily resolved references to implemented interfaces, class hierarchy.\n     * Does not include type itself.\n     *\n     * @since 2.7\n     */\n    protected HierarchicType[] _interfaces;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Constructor only used by {@link TypeFactory}.\n     *\n     * @since 2.7 -- remove final to allow mocking (for testing, mostly)\n     */\n    protected SimpleType(Class<?> cls) {\n        // We trust caller here, that class is not Collection, Map, Array or Enum\n        this(cls, TypeBindings.emptyBindings(), null, null);\n    }\n\n    /**\n     * @since 2.9 -- changed to public to allow usage by {@link ResolvedRecursiveType}\n     */\n    public SimpleType(TypeBase base, JavaType[] typeParams) {\n        super(base);\n        _typeParameters = typeParams;\n        // 10-Oct-2015, tatu: Not 100% sure this is needed but... let's try it.\n        _containedTypes = typeParams;\n        _valueHandler = base.getValueHandler();\n        _typeHandler = base.getTypeHandler();\n        _asStatic = base.isAsStatic();\n    }\n\n    /**\n     * Primary constructor for new types.\n     *\n     * @since 2.7\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts)\n    {\n        this(cls, bindings, superClass, superInts, null, null, false);\n    }\n\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, Object valueHandler, Object typeHandler,\n            boolean asStatic)\n    {\n        this(cls, bindings, superClass, superInts, cls.hashCode(),\n                valueHandler, typeHandler, asStatic);\n    }\n\n    /**\n     * @since 2.7\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts, int extraHash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, extraHash, valueHandler, typeHandler, asStatic);\n        // Should we try to figure out type parameters? Yes.\n        if (bindings.isEmpty()) {\n            _typeParameters = NO_TYPES;\n        } else {\n            _typeParameters = bindings.typeParameterArray();\n        }\n        // Contained types are type parameters AND super-types (if any)\n        // NOTE: only need direct super-type if it has type parameters\n        if (superClass == null) {\n            _containedTypes = _typeParameters;\n        } else {\n            // ... also, should super-types be added? For now, let's not unless type itself\n            // is generic...\n            if (superClass.hasContentType()) {\n                _containedTypes = new JavaType[_typeParameters.length+1];\n                System.arraycopy(_typeParameters, 0, _containedTypes, 0, _typeParameters.length);\n                _containedTypes[_typeParameters.length] = superClass;\n            } else {\n                _containedTypes = _typeParameters;\n            }\n        }\n        _valueHandler = valueHandler;\n        _typeHandler = typeHandler;\n        _asStatic = asStatic;\n    }\n\n    /**\n     * Constructor used when creating handling-specific subtypes\n     *\n     * @since 2.7\n     */\n    protected SimpleType(Class<?> cls, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInts,\n            JavaType[] typeParams, JavaType[] containedTypes,\n            HierarchicType hSuperClass, HierarchicType[] hInterfaces,\n            int hash,\n            Object valueHandler, Object typeHandler, boolean asStatic)\n    {\n        super(cls, bindings, superClass, superInts, hash,\n                valueHandler, typeHandler, asStatic);\n        _typeParameters = typeParams;\n        _containedTypes = containedTypes;\n        _superClass = hSuperClass;\n        _interfaces = hInterfaces;\n    }\n\n    /**\n     * @since 2.7\n     */\n    public static SimpleType constructUnsafe(Class<?> cls) {\n        // 16-May-2016, tatu: Not sure if this is required (or makes sense);\n        //   but needed to resolve [databind#1239] at least temporarily\n        return new SimpleType(cls, null, null, null, null, null, false);\n    }\n\n    /**\n     * @since 2.8\n     */\n    public SimpleType withHandlersFrom(JavaType src) {\n        // Let super class decide on basics:\n        JavaType type = super.withHandlersFrom(src);\n        // but then need to re-create hierarchic types, if any:\n        JavaType srcSuperClass = src.getSuperClass();\n        HierarchicType h = null;\n        if (srcSuperClass != null) {\n            // Sanity check: if LHS has super class, must be same...\n            if (_superClass != null && _superClass.getRawClass() == srcSuperClass.getRawClass()) {\n                h = _superClass.deepCloneWithoutSubclass();\n                srcSuperClass.setHierarchy(h);\n                // Not sure if this is needed but...\n                h.setSuperType(srcSuperClass.getSuperType());\n            }\n        }\n        // same for interfaces\n        // Hmmh. Actually, this may require re-construction of types, due to\n        // possible self-references. Let's punt for now, worry if it becomes\n        // actual problem. Note that issue is with potential definitions of\n        // Serializers/Deserializers that refer back to type being defined...\n        return type;\n    }\n\n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        // Can not change main type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; cannot call withContentType()\");\n    }\n\n    @Override\n    public SimpleType withTypeHandler(Object h)\n    {\n        if (_typeHandler == h) {\n            return this;\n        }\n        // 19-Mar-2016, tatu: Must re-create type since these are immutable;\n        //    could be extracted but code is simple enough:\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _hash,\n                _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so is no-op; can return this:\n        return this;\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n        if (h == _valueHandler) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _hash,\n                h, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public SimpleType withStaticTyping() {\n        return _asStatic ? this :\n            new SimpleType(_class, _bindings, _superClass, _superInterfaces, _hash,\n                    _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        // 21-Sep-2017, tatu: For recursive types, this may be called at a point where\n        //    super-class/interfaces are not yet resolved. If so, should not try to\n        //    use them, but rather keep existing references.\n\n        // TODO: Tatu-> Improve to check _superClass, _superInterfaces?\n\n        return null;\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Should we check that subclass is actual subclass of current class?\n        // Better not to, to keep checks cheap\n        // 18-Mar-2010, tatu: Except if class is final, can not narrow:\n        if (_class == subclass) {\n            return this;\n        }\n\n        // Must re-evaluate type parameters, bindings\n        // 24-Aug-2016, tatu: This check seems wrong; should rather check whether subclass\n        //    itself requires bindings... Need to reconsider. But for now keep as is.\n        if (!_class.isAssignableFrom(subclass)) {\n             // This check should perhaps be done earlier... but let's start by\n             // adding it here. If this is called, assumptions are that subclass\n             // IS a subtype, but let's double-check? Or is this just wrong?\n            return new SimpleType(subclass, _bindings, this, _superInterfaces, _hash,\n                    _valueHandler, _typeHandler, _asStatic);\n        }\n        // Otherwise, need to figure out bindings, if any?\n\n        // TODO: this is guesswork; may need revisiting, fixing\n        // 14-Aug-2015, tatu: Ok perhaps we do need to resolve...\n        Class<?> next = subclass.getSuperclass();\n        if (next == _class) { // direct check that given subclass is direct subclass\n            // apparently yes. In this case, create new instance, but need to\n            // ensure type parameters from this type are carried over.\n            // How about super-interfaces? Let's assume for now that they do not change\n            return new SimpleType(subclass, _bindings, this, _superInterfaces, _hash,\n                    _valueHandler, _typeHandler, _asStatic);\n        }\n        // If not direct subclass, need to traverse up; we can start from subclass's superclass\n        if (next != null && _class.isAssignableFrom(next)) {\n            // and get super type down to here:\n            JavaType nextType = _narrow(next);\n            return new SimpleType(subclass, _bindings, nextType, _superInterfaces, _hash,\n                    _valueHandler, _typeHandler, _asStatic);\n        }\n        // and interfaces are similar deal\n        Class<?>[] ifcs = subclass.getInterfaces();\n        for (Class<?> ifc : ifcs) {\n            if (ifc == _class) {\n                return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _hash,\n                        _valueHandler, _typeHandler, _asStatic);\n            }\n            if (_class.isAssignableFrom(ifc)) {\n                JavaType nextType = _narrow(ifc);\n                return new SimpleType(subclass, _bindings, null, new JavaType[] { nextType }, _hash,\n                        _valueHandler, _typeHandler, _asStatic);\n            }\n        }\n        // but if nothing works, just need to create basic type:\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _hash,\n                _valueHandler, _typeHandler, _asStatic);\n        // ... and this is just wrong, but should not occur.\n        // throw new IllegalArgumentException(\"Internal error: Should not attempt to narrow \"+this+\" to subclass \"+subclass.getName());\n    }\n\n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return (_containedTypes == null) ? 0 : _containedTypes.length;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        if (_containedTypes == null || index < 0 || index >= _containedTypes.length) {\n            return null;\n        }\n        return _containedTypes[index];\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        // TODO: should use TypeBindings information?\n        return null;\n    }\n\n    @Override\n    public JavaType getSuperClass() {\n        // 18-Sep-2017, tatu: Need to be careful here, check for recursive type\n        if (_superClass != null && _superClass instanceof ResolvedRecursiveType) {\n            JavaType actual = ((ResolvedRecursiveType) _superClass).getSelfReferencedType();\n            // Sanity check: self-reference *must* exist, right?\n            // Actually.. maybe not? Need to return placeholder, otherwise\n            // certain things will break. Seems counter-intuitive perhaps...\n            if (actual != null) {\n                return actual;\n            }\n        }\n        return _superClass;\n    }\n\n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n\n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb) {\n        _classSignature(_class, sb, false);\n        int count = (_typeParameters == null) ? 0 : _typeParameters.length;\n        if (count > 0) {\n            sb.append('<');\n            for (int i = 0; i < count; ++i) {\n                sb = _typeParameters[i].getGenericSignature(sb);\n            }\n            sb.append('>');\n        }\n        sb.append(';');\n        return sb;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.7\n     */\n    @Override\n    public void setHierarchy(HierarchicType h) {\n        _superClass = h;\n    }\n\n    /**\n     * @since 2.7\n     */\n    @Override\n    public void setInterfaces(HierarchicType[] i) {\n        _interfaces = i;\n    }\n\n    /**\n     * @since 2.7\n     */\n    @Override\n    public HierarchicType getHierarchy() {\n        return _superClass;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    /**\n     * @since 2.7\n     */\n    protected void _resolveHierarchy() {\n        // 21-Sep-2017, tatu: As per [databind#1647], need to be careful, avoid cyclic resolution\n        HierarchicType sup = _findSuperClass(_class.getGenericSuperclass(), this);\n        setHierarchy(sup);\n        // ... and interfaces\n        setInterfaces(_findSuperInterfaces(_class.getGenericInterfaces(), this, sup));\n    }\n\n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(40);\n        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        SimpleType other = (SimpleType) o;\n\n        // Classes must be identical...\n        if (other._class != this._class) return false;\n\n        // And bindings must be identical as well:\n        return _bindings.equals(other._bindings);\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}