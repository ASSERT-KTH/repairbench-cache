{
    "generation": "public JavaType constructType(Class<?> type) {\n    TypeBindings typeBindings = null;\n    if (_typeBindings == null) {\n        _typeBindings = new TypeBindings();\n    }\n    Class<?> erasedClass = type;\n    if (type instanceof Class<?>) {\n        erasedClass = (Class<?>) type;\n    } else {\n        erasedClass = type instanceof ParameterizedType ?\n                (Class<?>) ((ParameterizedType) type).getRawType() :\n                null;\n    }\n    if (erasedClass == null) {\n        return null;\n    }\n    JavaType superClassType = getType(erasedClass.getSuperclass());\n\n    // Merge bean properties from all superclasses\n    BeanPropertyMap beanProperties = buildBeanPropertyMap(erasedClass);\n    JavaType currentSuper = superClassType;\n    while (currentSuper != null && currentSuper != JavaType.OBJECT_TYPE) {\n        BeanPropertyMap superBeanProperties = currentSuper.getBeanProperties();\n        if (superBeanProperties != null) {\n            beanProperties.merge(superBeanProperties);\n        }\n        currentSuper = currentSuper.getSuperClass();\n    }\n\n    // Continue with constructing the type...\n    // (rest of the code for constructing the type)\n}\n\n// Helper method to build bean properties by traversing all superclasses\nprivate BeanPropertyMap buildBeanPropertyMap(Class<?> erasedClass) {\n    BeanPropertyMap properties = new BeanPropertyMap();\n    // Collect properties from this class and all superclasses\n    for (Class<?> cls = erasedClass; cls != Object.class; cls = cls.getSuperclass()) {\n        BeanInfo beanInfo = Introspector.getBeanInfo(cls);\n        for (PropertyDescriptor pd : beanInfo.getPropertyDescriptors()) {\n            String propName = pd.getName();\n            if (isAccessible(pd)) {\n                properties.put(propName, new BeanProperty(propName, pd));\n            }\n        }\n    }\n    return properties;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}