{
    "generation": "// Method in class com.fasterxml.jackson.databind.type.TypeFactory\n// NOTE: Signature changed in 2.9 from `_fromClass(ClassStack, Class<?>, TypeBindings)`\n// to `_fromClass(Class<?>, TypeBindings)`\n@Override\nprotected JavaType _fromClass(Class<?> cl, TypeBindings bindings)\n{\n    // First: maybe we have already seen this type?\n    JavaType type = _findWellKnownSimple(cl);\n    if (type != null) {\n        return type;\n    }\n\n    // Two-phase lookup: first using exact Class, then resolving\n    // hierarchy. Need to be careful with locking...\n\n    // 16-Aug-2016, tatu: Need to use `getCacheKey()` to handle possible bindings\n    final String key = bindings.getCacheKey(cl);\n    type = _typeCache.get(key);\n\n    if (type != null) {\n        // 13-May-2017, tatu: Important: self-refs must be handled regardless of cache find:\n        if (type.isContainerType() && type.isReferenceType()) { // includes recursive types\n            // Ugh. This gets tricky. Two basic cases. Let's assume exact match is fine,\n            // for now. NOTE: Used to check binding equality if `raw == cl`, but that\n            // does not seem right. Leave for future work if that needs re-consideration\n        }\n        return type;\n    }\n\n    // 15-May-2017, tatu: Required for [databind#1577], [databind#1647]\n    ResolvedRecursiveType selfRef = null;\n    boolean processing = _isProcessing(cl);\n\n    // 19-May-2017, tatu: As per [databind#1647], need to handle the case where\n    //    look-up fails even if it's \u03cc\u03c7\u03b9 recursive look-up...\n    if (processing) {\n        // We are actively processing this type: recursive reference\n        selfRef = new ResolvedRecursiveType(cl, bindings);\n        //Important: MUST cache the placeholder BEFORE resolving supertypes etc:\n        _typeCache.put(key, selfRef);\n    } else {\n        _setProcessing(cl);\n    }\n\n    // If we had already started resolving this type, must return placeholder\n    if (selfRef != null) {\n        return selfRef;\n    }\n\n    try {\n        // Ok, no recursive self-reference (yet?), must resolve\n        type = _constructType(cl, bindings);\n\n        // Need to take type parameters into account, resolve super-class and super-interfaces.\n        if (!type.isPrimitive() && !type.isArray()) {\n            // 13-May-2017, tatu: Super-class/interfaces may be complex, need context\n            // Need ClassStack, but let's create it only now if needed?\n            type = _resolveSuperClass(new ClassStack(cl), type, bindings);\n            type = _resolveSuperInterfaces(new ClassStack(cl), type, bindings);\n            // 13-May-2017, tatu: One more thing; need to also ensure hierarchy\n            //    is fully resolved BEFORE caching the type.\n            // 06-Dec-2017, tatu: But... only do this for `SimpleType`?\n            if (type.isSimpleType()) {\n                if (type.getSuperClass() == null) {\n                    Class<?> raw = type.getRawClass();\n                    // Should not happen for Object, but check just in case:\n                    if (raw != Object.class) {\n                        // assign Object.class if there is no explicit super class...\n                        // except for interfaces. And annotation types (which are interfaces too)\n                        if (!raw.isInterface()) {\n                            JavaType objectType = _fromClass(Object.class, TypeBindings.emptyBindings());\n                            ((SimpleType) type).setSuperClass(objectType);\n                        }\n                    }\n                }\n            }\n        }\n        // Anything added to cache now? If so, is it what we have?\n        JavaType t = _typeCache.put(key, type);\n        if (t != null && t != selfRef) { // yikes! Should not happen... but\n            // Let's NOT try to resolve twice. Probably fine?\n            // 29-Mar-2017, tatu: Actually should probably complain... ? Or maybe self-ref?\n            // 06-Dec-2017, tatu: Not sure if this can actually happen anymore. Hope not.\n            /*\n             System.err.printf(\"Internal error: type resolved (%s) different instance than cached (%s) for key '%s'\\n\",\n             type, t, key);\n             */\n             // 16-Jan-2018, tatu: Actually, one case is possible: if we recursively call\n             //    this method, we may have added placeholder which is then resolved.\n             //    Need to double-check details, but this seems plausible.\n             //    Let's not throw Exception quite yet.\n        }\n        return type;\n    } finally {\n        _removeProcessing(cl);\n\n        // 19-May-2017, tatu: Any recursive types to resolve?\n        if (selfRef != null) {\n            // 06-Dec-2017, tatu: Maybe need to use ClassStack? Seems like it should not be needed,\n            //    recursive references are resolved using cache lookups.\n             JavaType resolved = _typeCache.get(key);\n             if (resolved == null) { // should not happen but\n                 // 10-Jan-2018, tatu: Let's try to resolve again just in case? For some reason,\n                 //   placeholder was perhaps (?) evicted? Or resolution failed?\n                 resolved = _constructType(cl, bindings);\n                 // 16-Jan-2018, tatu: As per notes above, super-type/interface resolution is needed too\n                 resolved = _resolveSuperClass(new ClassStack(cl), resolved, bindings);\n                 resolved = _resolveSuperInterfaces(new ClassStack(cl), resolved, bindings);\n\n                 // And we may need to re-populate SimpleType's super type as well\n                 if (resolved.isSimpleType()) {\n                     if (resolved.getSuperClass() == null) {\n                         Class<?> raw = resolved.getRawClass();\n                         if (raw != Object.class) {\n                             if (!raw.isInterface()) {\n                                 JavaType objectType = _fromClass(Object.class, TypeBindings.emptyBindings());\n                                 ((SimpleType) resolved).setSuperClass(objectType);\n                             }\n                         }\n                     }\n                 }\n                 _typeCache.put(key, resolved);\n             }\n             // sanity check, should always be the resolved version\n             if (resolved != selfRef) {\n                 selfRef.setReference(resolved);\n             }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}