{
    "generation": "protected JavaType _fromClass(Class<?> clz, TypeBindings context, \n                              RecursiveTypeBindings typeBindings)\n{\n    // 18-Apr-2019, tatu: Not certain whether we should try to \"resolveSelf\" or not.\n    //   One difference would be between \"untyped\" (simple class) and fully typed\n    //   recursive type; although both seem to require similar handling.\n    //   For now, let's pass `false` as seems to work\n    JavaType selfRef = _findRecursiveType(clz, context, typeBindings, false);\n    if (selfRef != null) {\n        return selfRef;\n    }\n    // First: do we have an instance?\n    JavaType result = _typeCache.find(clz);\n    if (result != null) {\n        return result;\n    }\n\n    // If not, need to start from superclasses/interfaces\n    // 25-Jan-2019, tatu: as per [databind#2197], need to pre-emptively add placeholder\n    //   for recursive type (if any)\n    JavaType superClass;\n    JavaType[] superInterfaces;\n\n    // Ok: let's build it\n    if (typeBindings == null) {\n        typeBindings = new RecursiveTypeBindings(this, clz);\n    } else {\n        typeBindings = typeBindings.child(clz);\n    }\n    synchronized (typeBindings) {\n        superClass = _fromAny(typeBindings, clz.getSuperclass(), typeBindings);\n        superInterfaces = _resolveTypeBindings(typeBindings, clz.getGenericInterfaces());\n        result = new SimpleType(this, clz, typeBindings, superClass, superInterfaces);\n        // 25-Jan-2019, tatu: Need to add placeholder for recursive type (if any)...\n        if (!typeBindings.isEmpty()) {\n            JavaType placeholder = typeBindings.asPlaceholderJavaType(clz);\n            placeholder.setValue(result);\n        }\n    }\n    return _typeCache.add(clz, result);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}