{
    "generation": "// In TypeFactory.java, replace the old \u201c_fromParametrizedType\u201d (or similarly named) method\n// with this version.  The only behavioral change is to refuse the raw\u2010type cache shortcut\n// when there *are* type arguments, so that \u201cSub extends Base<Sub>\u201d really builds a\n// Base<Sub> JavaType instead of reusing a pre\u2010cached raw Base<>.\n\n@Override\nprotected JavaType _fromParametrizedType(ParameterizedType ptype,\n                                         TypeBindings parentBindings,\n                                         JavaType contextType,\n                                         JavaType refType,\n                                         int depth)\n{\n    Class<?> raw = (Class<?>) ptype.getRawType();\n\n    // 1) Recursion\u2010placeholder?  If so, return it\n    JavaType recursive = _incompleteTypes.get(raw);\n    if (recursive != null) {\n        return recursive;\n    }\n\n    // 2) Raw\u2010type cache: only reuse if there are NO actual type arguments\n    JavaType cached = _typeCache.get(raw);\n    if (cached != null && (ptype.getActualTypeArguments() == null\n                           || ptype.getActualTypeArguments().length == 0))\n    {\n        return cached;\n    }\n\n    // 3) Otherwise we must build a fresh ParameterizedType instance\n    //    (same as original code after the cache\u2010check)\n    TypeVariable<?>[] vars = raw.getTypeParameters();\n    JavaType[] typeArgs;\n    if (vars.length == 0) {\n        typeArgs = NO_TYPES;\n    } else {\n        Type[] args = ptype.getActualTypeArguments();\n        typeArgs = new JavaType[vars.length];\n        for (int i = 0; i < vars.length; ++i) {\n            Type arg = (i < args.length ? args[i] : vars[i]);\n            typeArgs[i] = _constructType(arg, parentBindings, contextType, null, depth+1);\n        }\n    }\n\n    // 4) Bind and register placeholder before resolving supertypes\n    TypeBindings newBindings = TypeBindings.create(raw, vars, typeArgs, this);\n    SimpleType result = new SimpleType(raw, newBindings,\n                                       /*superClass*/null,\n                                       /*superInterfaces*/null,\n                                       _valueHandler, _typeHandler, false);\n    _incompleteTypes.put(raw, result);\n\n    // 5) Resolve superclass\n    Type sup = raw.getGenericSuperclass();\n    if (sup != null) {\n        JavaType supType = _constructType(sup, newBindings, result, null, depth+1);\n        result.setSuperClass(supType);\n    }\n\n    // 6) Resolve interfaces\n    Type[] ifaces = raw.getGenericInterfaces();\n    if (ifaces != null && ifaces.length > 0) {\n        List<JavaType> l = new ArrayList<>(ifaces.length);\n        for (Type intf : ifaces) {\n            l.add(_constructType(intf, newBindings, result, null, depth+1));\n        }\n        result.setInterfaces(l);\n    }\n\n    // 7) Finish up: remove placeholder, cache, and resolve any pending recursion\n    _incompleteTypes.remove(raw);\n    _typeCache.put(raw, result);\n    _resolveSelfReferences();\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}