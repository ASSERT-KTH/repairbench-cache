{
    "generation": "// In TypeFactory.java, replace your existing _fromClass(...) with this corrected version:\n\n@Override\nprotected JavaType _fromClass(Class<?> raw,\n                              TypeBindings binding,\n                              JavaType superClass,\n                              JavaType[] superInterfaces)\n{\n    // 1) check cache only for \"simple\" (no generics, no explicit supertypes) calls\n    boolean canCache = binding.isEmpty()\n                       && superClass == null\n                       && (superInterfaces == null || superInterfaces.length == 0);\n    if (canCache) {\n        JavaType cached = _typeCache.get(raw);\n        if (cached != null) {\n            return cached;\n        }\n    }\n\n    // 2) recursion\u2010detection (unchanged from Jackson)\n    if (_classStack == null) {\n        _classStack = new LinkedList<>();\n    } else {\n        for (ClassStackEntry entry : _classStack) {\n            if (entry.raw == raw) {\n                ResolvedRecursiveType rec = new ResolvedRecursiveType(raw, binding);\n                entry.recursiveTypes.add(rec);\n                return rec;\n            }\n        }\n    }\n    ClassStackEntry curr = new ClassStackEntry(raw, binding, superClass, superInterfaces);\n    _classStack.add(curr);\n\n    try {\n        // 3) resolve superclass by reflection if not provided\n        if (superClass == null) {\n            Type gen = raw.getGenericSuperclass();\n            if (gen != null) {\n                superClass = _constructType(gen, binding);\n            }\n        }\n        // 4) resolve interfaces by reflection if not provided\n        if (superInterfaces == null) {\n            Type[] ints = raw.getGenericInterfaces();\n            if (ints != null && ints.length > 0) {\n                superInterfaces = new JavaType[ints.length];\n                for (int i = 0; i < ints.length; ++i) {\n                    superInterfaces[i] = _constructType(ints[i], binding);\n                }\n            } else {\n                superInterfaces = NO_TYPES;\n            }\n        }\n\n        // 5) construct the result, making sure to pass in the\n        //    resolved superClass/superInterfaces even for raw types\n        final JavaType result;\n        if (binding.isEmpty() && superClass == null && superInterfaces.length == 0) {\n            // truly \"plain\" class, no generics, no supertypes\n            result = new SimpleType(raw);\n        } else if (binding.isEmpty()) {\n            // raw class but *has* a superclass or interfaces\n            result = new SimpleType(raw, TypeBindings.emptyBindings(),\n                                    superClass, superInterfaces);\n        } else {\n            // parameterized class\n            result = new ParameterizedType(raw, binding,\n                                           superClass, superInterfaces);\n        }\n\n        // 6) complete recursion linkages\n        _classStack.removeLast();\n        if (!curr.recursiveTypes.isEmpty()) {\n            for (ResolvedRecursiveType placeholder : curr.recursiveTypes) {\n                placeholder.setReference(result);\n            }\n        }\n\n        // 7) cache if appropriate\n        if (canCache) {\n            _typeCache.put(raw, result);\n        }\n        return result;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\n            \"Failed to resolve type for class \" + raw.getName() + \": \" + e.getMessage(), e);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}