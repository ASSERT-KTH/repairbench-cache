{
    "generation": "    @Override\n    public JavaType getSuperClass() {\n        if (_referencedType != null) {\n            return _referencedType.getSuperClass();\n        }\n        // Call to resolve may be expensive, however, so only call if necessary;\n        // and possibly only once as well. Needs synchronization? (hope not)\n        // 11-Oct-2017, tatu: As per [databind#1647], may need to resolve non-recursively;\n        //   hopefully won't choke. NOTE: requires TypeBindings to refer back to TypeFactory\n        // NOTE: fields are NOT final, sideboarded using visible-after-construction,\n        // so theoretically could see null reference lecteur... an edge case for now.\n        if (_superClass == null) {\n            TypeBindings bindings = getBindings();\n            if (bindings != null) {\n                 TypeFactory tf = bindings.getTypeFactory();\n                 if (tf != null) {\n                     // Note: MUST pass 'null' ClassStack, to avoid infinite recursion\n                     try {\n                        _superClass = tf._resolveSuperClass(_raw, bindings);\n                     } catch (IllegalArgumentException e) {\n                        // 20-Mar-2021, tatu: [databind#3088]: Need to catch issue with trying to make\n                        //    java.lang.Record the supertype... doesn't work, needs to be Object.\n                        //    Only occurs on broken JDKs (14?), but work around it.\n                        // Ideally would be more specific, closer to `tf._mapJavaLangObject()`, but\n                        // maybe this is safer. Needs to be JavaType for 'Object', specifically\n                        if (_raw.getSuperclass() == null) { // which would indicate Object\n                            _superClass = tf.constructType(Object.class);\n                        } else {\n                            throw e;\n                        }\n                     }\n                 }\n             }\n            // If resolution failed, still null; We're fine with that? Or should perhaps\n            // assign Object.class equivalent? For now, leave as is\n            // (unless we hit that Record issue)\n        }\n        return _superClass;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}