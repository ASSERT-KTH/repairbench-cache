{
    "generation": "protected JavaType _resolveSuperType(JavaType type, Type parentRef) {\n    // First: do not try to resolve recursive types; we can't fully resolve\n    // those, and trying to resolve partly is just going to lead to problems\n    // (as in [databind#1607])\n    if (parentRef != null) {\n        if (_isDescendant(type, parentRef)) {\n            return TypeFactory.unknownType();\n        }\n    }\n    try {\n        // 26-Jun-2019, tatu: This used to be called for all types, but it seems\n        //    that only recursive (or self-referencing) types need this, so let's\n        //    try to limit call to those. Trying to fix [databind#2468]\n        if (type.isContainerType() || type.isReferenceType()) {\n            type = type.getContentType();\n        }\n\n        // First things first: we can't do much with unresolved types, so\n        // need to resolve before proceeding\n        if (type.isJavaLangObject()) {\n            // No super types for \"Object\" (or, should we return Object itself?)\n            return null;\n        }\n        JavaType superType = type.getSuperClass();\n        if (superType != null) {\n            // As per [databind#1647], may need to try resolving generic type\n            // parameters; and as per [databind#2468] need to allow possibility\n            // of recursive type, too\n            superType = _fromAny(parentRef, superType, _typeBindings);\n        }\n        return superType;\n    } catch (StackOverflowError e) {\n        // 26-Sep-2016, tatu: Occasionally we get into recursive resolution, and\n        //    while it's generally sign of a problem (and will be caught elsewhere)\n        //    it is possible (see [databind#1418]) so for now just ignore and\n        //    return `null`\n        return null;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}