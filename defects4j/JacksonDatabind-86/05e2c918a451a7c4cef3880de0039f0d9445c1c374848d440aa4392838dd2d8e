{
    "generation": "@Override\npublic JavaType constructType(Type type, TypeBindings context) {\n    // First, check if it's in cache\n    JavaType cached = _typeCache.get(type);\n    if (cached != null) {\n        return cached;\n    }\n\n    // Before resolving, create placeholder in case of recursive/reference types\n    if (type instanceof Class<?>) {\n        Class<?> raw = (Class<?>) type;\n        if (raw == Object.class) {\n            return _unknownType();\n        }\n    }\n\n    ResolvedRecursiveType recursiveType = new ResolvedRecursiveType(null, context);\n    // Put placeholder\n    _typeCache.put(type, recursiveType);\n\n    JavaType result;\n    try {\n        if (type instanceof Class<?>) {\n            result = _fromClass(null, (Class<?>) type, context);\n        } else if (type instanceof ParameterizedType) {\n            result = _fromParamType(context, (ParameterizedType) type);\n        } else if (type instanceof GenericArrayType) {\n            result = _fromArrayType(context, (GenericArrayType) type);\n        } else if (type instanceof TypeVariable<?>) {\n            result = _fromVariable(context, (TypeVariable<?>) type);\n        } else if (type instanceof WildcardType) {\n            result = _fromWildcard(context, (WildcardType) type);\n        } else {\n            throw new IllegalArgumentException(\"Unrecognized Type: \" + type);\n        }\n    } finally {\n        // Replace placeholder with resolved JavaType instance even if failed with exception\n        _typeCache.put(type, recursiveType.getReferent() != null ? recursiveType.getReferent() : recursiveType);\n    }\n\n    if (recursiveType.getReferent() == null || recursiveType.getReferent() == recursiveType) {\n        recursiveType.setReference(result);\n        _typeCache.put(type, result);\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}