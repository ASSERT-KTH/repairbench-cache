{
    "generation": "    // Ensure that when super class is constructed after, it updates any existing subclass types\n    public JavaType constructType(Class<?> cls) {\n        // Check if this class is already being processed\n        if (_cached & (1 << cls.hashCode() % 64)) {\n            return new RecursiveType();\n        }\n        _cached |= (1 << cls.hashCode() % 64);\n\n        JavaType type = _typeCache.get(cls);\n        if (type != null) {\n            return type;\n        }\n\n        // Create a new JavaType instance\n        JavaType newType = new JavaType(cls, this, null, null);\n        _typeCache.put(cls, newType);\n\n        // Construct the super class type\n        Class<?> superClass = cls.getSuperclass();\n        if (superClass != null && superClass != Object.class) {\n            JavaType superType = constructType(superClass);\n            newType.setSuperClass(superType);\n        }\n\n        // Check if any existing types have this class as their super class and need updating\n        for (JavaType existingType : _allTypes) {\n            if (existingType.getSuperClass() instanceof RecursiveType &&\n                ((RecursiveType) existingType.getSuperClass()).getRawClass() == cls) {\n                existingType.setSuperClass(newType);\n            }\n        }\n\n        // Also, check any cached types that might have this as super class\n        for (Class<?> c : _typeCache.keySet()) {\n            JavaType t = _typeCache.get(c);\n            if (t.getSuperClass() instanceof RecursiveType &&\n                ((RecursiveType) t.getSuperClass()).getRawClass() == cls) {\n                t.setSuperClass(newType);\n            }\n        }\n\n        return newType;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}