{
    "generation": "protected JavaType _findSuperType(JavaType type, Class<?> rawTarget)\n{\n    // When we get the initial call, we can't find the\n    // super class yet so let's return `null` to indicate that:\n    if (type == null || type.getRawClass() == rawTarget) {\n        return null;\n    }\n    // We either have the target or a different super class. In both cases,\n    // that type should be registered with the type factory so that it\n    // can be resolved by `_typeFromId`:\n    JavaType superType = type.getSuperClass();\n    if (superType == null) {\n        // Type does not have a super class so there is no more types\n        // to check:\n        return null;\n    }\n    Class<?> rawSuperClass = superType.getRawClass();\n    if (rawSuperClass == rawTarget) {\n        return superType;\n    }\n    // Must be a different super class so let's mark that id in the\n    // type factory and check if that super class is our target:\n    String superTypeId = idFrom(superType);\n    if (_typeFactory.hasSharedType(superTypeId)) {\n        return null;\n    }\n    _typeFactory.addSharedType(superType, superTypeId);\n    JavaType found = _findSuperType(superType, rawTarget);\n    if (found != null) {\n        // We've found the target super class, let's rebuild the types.\n        // If the super class of found type is found in type factory, use that:\n        // if not found, pass a null as the parent: \n        JavaType parentType = found.getSuperClass() == null ? null : _typeFactory._typeFromId(idFrom(found));\n        JavaType resolvedType = ResolvedRecursiveType.forBogusClass(\n                _typeFactory, rawSuperClass, parentType, idFrom(type));\n        // Need to also create all intermediate types:\n        JavaType currType = type;\n        while (currType.getSuperClass() != null) {\n            Class<?> currRawType = currType.getRawClass();\n            if (currRawType == rawSuperClass) {\n                break;\n            }\n            JavaType nextType = ResolvedRecursiveType.forBogusClass(\n                    _typeFactory, currRawType, resolvedType, idFrom(currType));\n            // Need to ensure we replace it as a registered type for\n            // case of caching:\n            _typeFactory.addSharedType(nextType, idFrom(currType));\n            resolvedType = nextType;\n            currType = currType.getSuperClass();\n        }\n    }\n    return found;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}