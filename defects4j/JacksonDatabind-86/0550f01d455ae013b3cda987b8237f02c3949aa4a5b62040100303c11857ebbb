{
    "generation": "    /**\n     * @param stack Call stack used for resolving types; MUST be passed down\n     *   when calling {@link #_fromAny}\n     * @since 2.9\n     */\n    protected HierarchicType _findSuperTypeChain(ClassStack stack, Class<?> rawCurrent, TypeBindings context)\n    {\n        // Note: context MUST be passed here, for type variable resolution\n\n        // Trivial check first: maybe we have already seen it?\n        HierarchicType ht = stack.find(rawCurrent);\n        if (ht != null) {\n            return ht;\n        }\n\n        // Argument checks done by caller, shouldn't need any further checking\n\n        HierarchicType selfType = new HierarchicType(rawCurrent);\n        stack.push(selfType);\n        try {\n            // Then check super-class, if any\n            // 18-Aug-2015, tatu: Super-class is easy, but interfaces are more complex,\n            //    as they need to be registered using NameCanonicalizer, to avoid\n            //    duplicate interface definitions.\n            Class<?> parent = rawCurrent.getSuperclass();\n            if (parent != null) {\n                 // Pass the stack down!\n                 HierarchicType sup = _findSuperTypeChain(stack, parent, context);\n                 selfType.setSuperType(sup);\n            }\n\n            // Then interfaces, if any\n            Class<?>[] ifs = rawCurrent.getInterfaces();\n            if (ifs != null && ifs.length > 0) {\n                // Need to ensure we will only represent each unique interface type once\n                // (duplicate definitions are possible, esp. with generic types)\n                // So, let's use a Set to ensure this.\n                // 28-Jun-2017, tatu: As per [databind#1661], need to use LinkedHashSet\n                //   to maintain order of declarations.\n                java.util.LinkedHashSet<HierarchicType> ifts = new java.util.LinkedHashSet<HierarchicType>(ifs.length);\n                for (int i = 0, len = ifs.length; i < len; ++i) {\n                    // Pass the stack down!\n                    HierarchicType ift = _findSuperTypeChain(stack, ifs[i], context);\n                    if (ifts.add(ift)) { // true if it was first time seeing this interface\n                         // any significance?\n                    }\n                }\n                selfType.setInterfaces(new java.util.ArrayList<>(ifts));\n            }\n\n            // And finally, fully resolve type bindings\n            _resolveSuperTypes(stack, selfType, context);\n        } finally {\n            stack.pop();\n        }\n        return selfType;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}