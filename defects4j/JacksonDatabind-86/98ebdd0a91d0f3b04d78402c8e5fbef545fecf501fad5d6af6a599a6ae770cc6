{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\n\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n// Note: This is only the _fromClass method.\n// It assumes the surrounding TypeFactory class and its helper methods/fields\n// (like _knownClass, _constructType, _fromAny, _typeCache, TypeBindings, ClassKey, ResolvedRecursiveType, etc.)\n// are correctly defined elsewhere in the TypeFactory class.\n\n// The issue \"databind#1647\" specifically relates to ensuring ResolvedRecursiveType's\n// _referencedType is properly set and propagated through the cache.\npublic class TypeFactory {\n\n    // ... (existing fields and other methods of TypeFactory) ...\n\n    /**\n     * Helper method used to construct {@link JavaType} for a Class.\n     * Needs to be able to handle recursive types correctly.\n     *\n     * @param context Stack used for cycle detection (can be null for initial call)\n     * @param rawType The raw class to construct type for\n     * @param bindings Type bindings for this class (e.g., from generic supertypes)\n     * @return Constructed {@link JavaType}\n     */\n    protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)\n    {\n        // 1. Check for basic/canonical types first (optimization)\n        JavaType result = _knownClass(rawType);\n        if (result != null) {\n            return result;\n        }\n\n        // 2. Check cache\n        ClassKey key = new ClassKey(rawType);\n        result = _typeCache.get(key);\n        \n        // Fix for [databind#1647]: If we find a `ResolvedRecursiveType` in the cache,\n        // we must ensure that if it's already fully resolved, we return its `_referencedType`.\n        // If it's a placeholder (`_referencedType` is null), we proceed to finish its resolution.\n        if (result != null) {\n            if (result instanceof ResolvedRecursiveType) {\n                JavaType actual = ((ResolvedRecursiveType) result).getReferencedType();\n                if (actual != null) {\n                    // It's already fully resolved, return the actual type.\n                    return actual;\n                }\n                // Else: `actual` is null. This means the `ResolvedRecursiveType` is a\n                // placeholder that is currently being built (by an earlier call\n                // in the current stack, or a concurrent thread).\n                // We should not return the incomplete placeholder; instead,\n                // we'll proceed to finish the resolution.\n            } else {\n                // Not a recursive type, just a fully resolved type from cache.\n                return result;\n            }\n        }\n\n        // 3. Not in cache (or an unresolved ResolvedRecursiveType placeholder): start new resolution.\n        // Create a placeholder `ResolvedRecursiveType` and put it into the cache immediately.\n        // This prevents infinite recursion for truly recursive types and acts as a marker.\n        ResolvedRecursiveType refType = new ResolvedRecursiveType(rawType, bindings);\n        _typeCache.put(key, refType);\n\n        JavaType actualType = null;\n        try {\n            // Push current type onto stack for cycle detection (if `context` is used for this)\n            // ClassStack newContext = (context == null) ? new ClassStack(rawType) : context.child(rawType);\n\n            // Step A: Resolve superclass\n            JavaType superClass = null;\n            Class<?> superclass = rawType.getSuperclass();\n            if (superclass != null) {\n                // Recursively call _fromClass for superclass.\n                // Bindings are adjusted for the supertype context.\n                superClass = _fromClass(null /* or newContext */, superclass, bindings.forSupertype(rawType));\n            }\n\n            // Step B: Resolve interfaces\n            JavaType[] superInterfaces = NO_TYPES; // Assuming NO_TYPES is a predefined empty array\n            Type[] ifaces = rawType.getGenericInterfaces();\n            if (ifaces != null && ifaces.length > 0) {\n                superInterfaces = new JavaType[ifaces.length];\n                for (int i = 0; i < ifaces.length; ++i) {\n                    superInterfaces[i] = _fromAny(null /* or newContext */, ifaces[i], bindings.forSupertype(rawType));\n                }\n            }\n\n            // Step C: Construct the \"real\" JavaType based on resolved components\n            // _constructType method is responsible for creating concrete JavaType instances\n            // (e.g., SimpleType, CollectionType, MapType, etc.).\n            actualType = _constructType(rawType, bindings, superClass, superInterfaces);\n\n            // 4. Critical fix for [databind#1647]:\n            // The `ResolvedRecursiveType` placeholder that we put in the cache needs to\n            // be updated to reference the fully constructed `actualType`.\n            refType.setReference(actualType);\n\n            // 5. Update the cache with the fully resolved `actualType`, replacing the placeholder.\n            // This ensures subsequent direct lookups for `rawType` get the complete type,\n            // not the `ResolvedRecursiveType` wrapper.\n            // This atomic replacement helps with concurrent access.\n            _typeCache.put(key, actualType);\n\n            return actualType;\n        } finally {\n            // Clean up: if an exception occurred during construction (actualType is null),\n            // remove the placeholder to avoid leaving an incomplete type in the cache.\n            // Use remove(key, value) for atomic removal if supported by ConcurrentHashMap\n            // to prevent removing a type that was concurrently replaced by another thread.\n            if (actualType == null) {\n                _typeCache.remove(key, refType); \n            }\n            // Pop current type from stack (if `context` is used)\n            // if (newContext != null) newContext.pop();\n        }\n    }\n\n    // ... (other methods of TypeFactory, including the dummy ones provided in thought process,\n    //      or actual Jackson TypeFactory implementation) ...\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}