{
    "generation": "// In TypeFactory.java, adjust caching so that cached types are only\n// returned when we're at the root level (i.e. context==null), not\n// when building nested supertypes/interfaces.\nprotected JavaType _constructType(Type type,\n                                  ClassStack context,\n                                  JavaType referencedType,\n                                  boolean asStatic)\n{\n    if (type instanceof Class<?>) {\n        Class<?> raw = (Class<?>) type;\n        // remember whether this is the root\u2010level call\n        boolean root = (context == null);\n\n        // recursion detection\n        if (root) {\n            context = new ClassStack(raw);\n        } else {\n            if (context.contains(raw)) {\n                // self\u2010reference placeholder\n                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(raw, referencedType);\n                context.addSelfReference(selfRef);\n                return selfRef;\n            }\n            context = context.child(raw);\n        }\n\n        // only pull from the cache if we're at the root; nested\n        // calls for supertypes/interfaces must rebuild\n        ClassKey key = new ClassKey(raw);\n        JavaType cached = _typeCache.get(key);\n        if (cached != null && root) {\n            return cached;\n        }\n\n        // build super\u2010class\n        JavaType superClass = null;\n        Type genSup = raw.getGenericSuperclass();\n        if (genSup != null) {\n            superClass = _constructType(genSup, context, referencedType, asStatic);\n        }\n\n        // build interfaces\n        Type[] genIfs = raw.getGenericInterfaces();\n        JavaType[] interfaces = null;\n        if (genIfs != null && genIfs.length > 0) {\n            interfaces = new JavaType[genIfs.length];\n            for (int i = 0; i < genIfs.length; ++i) {\n                interfaces[i] = _constructType(genIfs[i], context, referencedType, asStatic);\n            }\n        }\n\n        // bindings for raw\n        TypeBindings bindings = _bindings.forClass(raw);\n\n        // create the actual type\n        SimpleType result = new SimpleType(raw, bindings, superClass, interfaces);\n\n        // resolve any recursive placeholders that pointed here\n        context.resolveSelfReferences(result);\n\n        // cache the new type (only one instance per raw class & bindings)\n        _typeCache.put(key, result);\n\n        return result;\n    }\n    // ... handle other Type implementations (ParameterizedType, array, etc.)\n    return _constructOther(type, context, referencedType, asStatic);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}