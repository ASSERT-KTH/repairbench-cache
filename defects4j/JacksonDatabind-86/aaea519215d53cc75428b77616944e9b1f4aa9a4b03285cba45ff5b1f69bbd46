{
    "generation": "// In TypeFactory.java, replace the old _fromClass(...) with this fixed version:\n\nprotected JavaType _fromClass(Class<?> raw, TypeBindings bindings,\n                              JavaType superClass, JavaType[] interfaces)\n{\n    // 1) detect recursion first, so that self\u2010references in generic super\u2010types\n    //    will bind to a placeholder rather than returning a stale cached type\n    ClassStack.Node entry = _classStack.find(raw);\n    if (entry != null) {\n        // recursive reference: return a placeholder\n        ResolvedRecursiveType placeholder = new ResolvedRecursiveType(raw, bindings);\n        entry.addSelfReference(placeholder);\n        return placeholder;\n    }\n\n    // 2) now check cache; if we already built this exact combination, reuse it\n    SimpleTypeKey key = new SimpleTypeKey(raw, bindings, superClass, interfaces);\n    JavaType cached = _typeCache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n\n    // 3) no recursion and not in cache, so build a fresh type\n    _classStack = _classStack.child(raw);\n    JavaType result;\n    try {\n        // ensure the super\u2010class is resolved\n        JavaType scls = superClass;\n        if (scls == null) {\n            Class<?> parent = raw.getSuperclass();\n            if (parent != null) {\n                scls = _fromClass(parent, TypeBindings.create(parent, null));\n            }\n        }\n        // ensure any interfaces are resolved\n        JavaType[] ifaces = interfaces;\n        if (ifaces == null) {\n            Class<?>[] rawIfaces = raw.getInterfaces();\n            int len = rawIfaces.length;\n            ifaces = new JavaType[len];\n            for (int i = 0; i < len; i++) {\n                ifaces[i] = _fromClass(rawIfaces[i], TypeBindings.create(rawIfaces[i], null));\n            }\n        }\n        // build the actual SimpleType (or other base type)\n        result = _buildSimple(raw, bindings, scls, ifaces);\n\n        // if any placeholders were created for this raw class, link them now\n        ClassStack.Node resolvedEntry = _classStack.find(raw);\n        if (resolvedEntry != null) {\n            resolvedEntry.resolveSelfReferences(result);\n        }\n    } finally {\n        // pop the stack\n        _classStack = _classStack.parent();\n    }\n\n    // 4) cache for future reuse\n    _typeCache.put(key, result);\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}