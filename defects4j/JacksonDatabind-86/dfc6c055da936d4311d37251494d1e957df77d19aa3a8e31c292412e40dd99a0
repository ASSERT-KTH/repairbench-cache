{
    "generation": "    protected JavaType _fromClass(Class<?> rawType, TypeBindings bindings, ClassStack context)\n    {\n        // 1. Initial cache lookup (optimistic check against fully resolved types)\n        JavaType result = _typeCache.get(rawType);\n        if (result != null) {\n            return result;\n        }\n\n        // 2. Check for recursive type resolution\n        // Add to context stack; if it returns a placeholder, it means we have a recursive dependency.\n        context = new ClassStack(rawType, context);\n        _PlaceholderForClass ph = context.add(rawType);\n\n        // If 'ph' is not null, it means 'rawType' is already on the stack, indicating a recursive call.\n        // We create a `ResolvedRecursiveType` as a placeholder and link it to the placeholder in the stack.\n        // This placeholder will be resolved later.\n        if (ph != null) {\n            result = new ResolvedRecursiveType(rawType, bindings);\n            ph.resolve(result); // Link the placeholder in the stack to this new ResolvedRecursiveType\n        } else {\n            // Not a recursive call (yet); create the base type instance based on rawType\n            if (rawType.isArray()) {\n                // For arrays, component type might be recursive\n                result = ArrayType.construct(_fromClass(rawType.getComponentType(), null, context), bindings);\n            } else if (rawType.isPrimitive()) {\n                result = PrimitiveType.construct(rawType);\n            } else { // Regular class\n                // _constructSimpleType creates a SimpleType or other basic type.\n                // It does NOT set super-classes/interfaces yet.\n                result = _constructSimpleType(rawType, bindings, context);\n            }\n        }\n\n        // --- Start of fix for databind#1647 ---\n        // Crucially, super-class and super-interfaces must be resolved and set *before*\n        // attempting to resolve generic parameters (`_resolveTypeParameters`).\n        // This ensures that the type's hierarchy is correctly established even if `result`\n        // is a `ResolvedRecursiveType` placeholder.\n\n        // Resolve and set super-class\n        Class<?> superClassRaw = rawType.getSuperclass();\n        if (superClassRaw != null && superClassRaw != Object.class) {\n            // Recursively resolve the super-class type. Pass the same context\n            // to detect nested recursion in the super-type chain.\n            result._superClass = _fromClass(superClassRaw,\n                    // NOTE: use empty bindings if rawType is not generic, or specific bindings\n                    // if superclass is generic AND its parameters are bound by current `rawType`'s parameters.\n                    // For the given tests, `Base` and `Sub` are non-generic, so empty bindings are fine.\n                    // For more complex cases, `bindings` needs to be propagated or translated correctly.\n                    TypeBindings.emptyBindings(), // simplified for this specific bug context\n                    context);\n        }\n\n        // Resolve and set super-interfaces\n        Class<?>[] superInterfacesRaw = rawType.getInterfaces();\n        if (superInterfacesRaw != null && superInterfacesRaw.length > 0) {\n            result._superInterfaces = new JavaType[superInterfacesRaw.length];\n            for (int i = 0; i < superInterfacesRaw.length; ++i) {\n                // Recursively resolve each super-interface type.\n                result._superInterfaces[i] = _fromClass(superInterfacesRaw[i],\n                        TypeBindings.emptyBindings(), // simplified\n                        context);\n            }\n        }\n        // --- End of fix for databind#1647 ---\n\n        // Now, after super-class and super-interfaces are set, resolve generic type parameters.\n        // This method might modify 'result' if it was a `ResolvedRecursiveType` placeholder,\n        // finalizing its type information.\n        result = _resolveTypeParameters(rawType, bindings, result);\n\n        // 3. Cache the fully resolved type (only if not a placeholder that's still being resolved)\n        // If 'ph' was null, it means this was the initial request for 'rawType', so we cache the fully resolved type.\n        if (ph == null) {\n            _typeCache.put(rawType, result);\n        }\n\n        // Remove from context stack (important to unmark for future resolutions)\n        context.resolve(rawType);\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}