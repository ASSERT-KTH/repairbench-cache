{
    "generation": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      // Fix: Allow GETELEM for prototype assignments like Foo.prototype['bar'] = ...\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && (n.getType() == Token.GETPROP || n.getType() == Token.GETELEM) // Changed this line\n          ) {\n        // We want to exclude the assignment itself from the usage list\n\n        // Check if the base of the property access (n.getFirstChild()) is a GETPROP node\n        // e.g., For Foo.prototype.bar, n is GETPROP(bar), n.getFirstChild() is GETPROP(prototype)\n        // e.g., For Foo.prototype['bar'], n is GETELEM('bar'), n.getFirstChild() is GETPROP(prototype)\n        Node base = n.getFirstChild();\n        boolean isBaseGetProp = base != null && base.getType() == Token.GETPROP;\n\n        if (isBaseGetProp) {\n          // Get the property name node from the base GETPROP (e.g., \"prototype\")\n          // base.getFirstChild() is the object (e.g., Foo)\n          // base.getFirstChild().getNext() should be the property name (e.g., \"prototype\")\n          // Alternatively, base.getLastChild() should also work.\n          Node prototypeNameNode = base.getLastChild(); // Using getLastChild is slightly more robust\n\n          // Check if the property name is indeed the string \"prototype\"\n          if (prototypeNameNode != null && prototypeNameNode.getType() == Token.STRING &&\n              prototypeNameNode.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}