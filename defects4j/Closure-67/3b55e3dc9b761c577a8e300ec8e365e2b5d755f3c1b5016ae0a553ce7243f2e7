{
    "generation": "    private boolean isPrototypePropertyAssign(Node assign) {\n      Node n = assign.getFirstChild();\n      // Check if the left-hand side of the assignment is a property access (GETPROP or GETELEM).\n      // Examples: `e.prototype.method1` (GETPROP) or `e.prototype['alias1']` (GETELEM).\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n          && (n.getType() == Token.GETPROP || n.getType() == Token.GETELEM)\n          ) {\n        // We want to exclude the assignment itself from the usage list.\n        // Check if the object of the property access (n.getFirstChild()) is itself a GETPROP node.\n        // This targets patterns like `someObject.prototype.property` or `someObject.prototype['property']`.\n        // The `n.getFirstChild()` part would be `someObject.prototype`.\n        boolean isChainedProperty =\n            n.getFirstChild().getType() == Token.GETPROP;\n\n        if (isChainedProperty) {\n          // If `n.getFirstChild()` is `someObject.prototype` (a GETPROP node):\n          // - `n.getFirstChild().getFirstChild()` gets `someObject`.\n          // - `.getNext()` from `someObject` gets the property accessed on `someObject`,\n          //   which should be the \"prototype\" string.\n          Node child = n.getFirstChild().getFirstChild().getNext();\n\n          // Ensure `child` is not null and is the \"prototype\" string.\n          if (child != null && child.getType() == Token.STRING &&\n              child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}