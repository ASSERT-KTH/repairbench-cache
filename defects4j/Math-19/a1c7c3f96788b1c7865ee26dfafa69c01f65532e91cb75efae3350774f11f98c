{
    "generation": "import org.apache.commons.math3.exception.DimensionMismatchException;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NumberIsTooLargeException; // Added import\nimport org.apache.commons.math3.exception.OutOfRangeException;\nimport org.apache.commons.math3.exception.MathUnsupportedOperationException;\n\n// Assuming this class has the necessary fields (boundaries, inputSigma) and methods (getStartPoint, getLowerBound, getUpperBound).\n\n    /**\n     * Checks dimensions and values of boundaries and inputSigma if defined.\n     */\n    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n        final int dimension = init.length; // Use dimension consistently\n\n        // Checks whether there is at least one finite bound value.\n        // This logic assumes lB and uB are either both null or both non-null and correctly sized.\n        boolean hasFiniteBounds = false;\n        if (lB != null && uB != null) { // Original code implies bounds are checked together\n             // Check dimensions (added for robustness, matches later checks)\n             if (lB.length != dimension) {\n                 throw new DimensionMismatchException(lB.length, dimension);\n             }\n             if (uB.length != dimension) {\n                 throw new DimensionMismatchException(uB.length, dimension);\n             }\n\n            for (int i = 0; i < dimension; i++) {\n                if (!Double.isInfinite(lB[i]) ||\n                    !Double.isInfinite(uB[i])) {\n                    hasFiniteBounds = true;\n                    break;\n                }\n            }\n            // Checks whether there is at least one infinite bound value.\n            boolean hasInfiniteBounds = false;\n            if (hasFiniteBounds) {\n                for (int i = 0; i < dimension; i++) {\n                    if (Double.isInfinite(lB[i]) ||\n                        Double.isInfinite(uB[i])) {\n                        hasInfiniteBounds = true;\n                        break;\n                    }\n                }\n\n                if (hasInfiniteBounds) {\n                    // If there is at least one finite bound, none can be infinite,\n                    // because mixed cases are not supported by the current code.\n                    throw new MathUnsupportedOperationException();\n                } else { // All bounds are finite\n                    // Convert API to internal handling of boundaries.\n                    boundaries = new double[2][];\n                    boundaries[0] = lB;\n                    boundaries[1] = uB;\n\n                    // Abort early if the normalization will overflow (cf. \"encode\" method).\n                    // ---- FIX START ----\n                    for (int i = 0; i < dimension; i++) {\n                        final double range = uB[i] - lB[i];\n                        // Check if the range calculation overflows to infinity.\n                        if (range == Double.POSITIVE_INFINITY) {\n                            // Throw exception as expected by testBoundaryRangeTooLarge\n                            throw new NumberIsTooLargeException(range, Double.MAX_VALUE, false);\n                        }\n                         // Optional: Check for underflow or negative range if lB > uB is possible?\n                         // if (range == Double.NEGATIVE_INFINITY) { ... }\n                         // if (uB[i] < lB[i]) { throw new NumberIsTooSmallException... }\n                         // Sticking to the minimal fix for the reported bug.\n                    }\n                    // ---- FIX END ----\n                }\n            } else { // No finite bounds found (implies all bounds are infinite)\n                // Convert API to internal handling of boundaries.\n                boundaries = null; // Treat as unbounded\n            }\n        } else { // Case where lB or uB (or both) is null\n            // Convert API to internal handling of boundaries.\n            boundaries = null; // Treat as unbounded\n        }\n\n\n        if (inputSigma != null) {\n            // Check dimension of inputSigma\n            if (inputSigma.length != dimension) {\n                throw new DimensionMismatchException(inputSigma.length, dimension);\n            }\n            for (int i = 0; i < dimension; i++) {\n                // Check positivity of sigma values\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                // Check sigma relative to boundaries range, if boundaries are set (finite)\n                if (boundaries != null) {\n                    // Calculate range again - note: guaranteed not to be +INF due to the fix above.\n                    final double range = boundaries[1][i] - boundaries[0][i];\n                    if (inputSigma[i] > range) {\n                        throw new OutOfRangeException(inputSigma[i], 0, range);\n                    }\n                }\n            }\n        }\n\n        // It's also important to check if the initial point 'init' is within the bounds.\n        // This check might exist elsewhere or should be added for completeness.\n        // Example check:\n        if (lB != null) {\n            // Ensure dimension match if not checked earlier\n            if (lB.length != dimension) throw new DimensionMismatchException(lB.length, dimension);\n            for (int i = 0; i < dimension; i++) {\n                 if (init[i] < lB[i]) {\n                     throw new OutOfRangeException(init[i], lB[i], (uB == null) ? Double.POSITIVE_INFINITY : uB[i]);\n                 }\n            }\n        }\n        if (uB != null) {\n            // Ensure dimension match if not checked earlier\n            if (uB.length != dimension) throw new DimensionMismatchException(uB.length, dimension);\n             for (int i = 0; i < dimension; i++) {\n                 if (init[i] > uB[i]) {\n                     throw new OutOfRangeException(init[i], (lB == null) ? Double.NEGATIVE_INFINITY : lB[i], uB[i]);\n                 }\n             }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}