{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType == null) {\n        // If the type is unknown, we cannot check visibility.\n        return;\n    }\n\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility\n    // information. Start search from the superclass prototype if it's an override.\n    ObjectType ownerObjectType = isOverride ? objectType.getImplicitPrototype() : objectType;\n    JSDocInfo docInfo = null;\n    ObjectType foundVisibilityObjectType = null; // Type where property with visibility was found\n    for (; ownerObjectType != null;\n         ownerObjectType = ownerObjectType.getImplicitPrototype()) {\n      docInfo = ownerObjectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        foundVisibilityObjectType = ownerObjectType;\n        break;\n      }\n    }\n\n    if (foundVisibilityObjectType == null) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean sameInput =\n        t.getInput().getName().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    // Use the type where visibility was found for reporting and checks\n    JSType ownerType = normalizeClassType(foundVisibilityObjectType);\n\n    if (isOverride) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Check overriding private property\n      if (visibility == Visibility.PRIVATE) {\n        if (!sameInput) {\n          // Overriding a private property from a different file.\n          // Report PRIVATE_OVERRIDE if the overriding definition is also private (Test 8)\n          // Report BAD_PRIVATE_PROPERTY_ACCESS otherwise (Test 6)\n          // This distinguishes attempt to override private with explicitly private (override error)\n          // from attempt to override private with default/public (access error).\n          if (overridingVisibility == Visibility.PRIVATE) {\n               compiler.report(\n                   t.makeError(getprop, PRIVATE_OVERRIDE,\n                       foundVisibilityObjectType.toString()));\n          } else {\n               compiler.report(\n                   t.makeError(getprop,\n                       BAD_PRIVATE_PROPERTY_ACCESS,\n                       propertyName,\n                       validator.getReadableJSTypeName(\n                           getprop.getFirstChild(), true)));\n          }\n        } else {\n          // Overriding a private property in the same file. Still illegal.\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  foundVisibilityObjectType.toString()));\n        }\n      } else if (overridingVisibility != Visibility.INHERITED && // Check visibility mismatch for non-private\n                 overridingVisibility != visibility) {\n          // Allow @protected override of @public in same file as a common pattern\n          // if the overriding class is a subtype of the owner class.\n          boolean allowProtectedOverrideOfPublic =\n              visibility == Visibility.PUBLIC &&\n              overridingVisibility == Visibility.PROTECTED &&\n              sameInput && currentClass != null && ownerType != null &&\n              currentClass.isSubtype(ownerType); // Added subclass check\n\n          if (!allowProtectedOverrideOfPublic) {\n              compiler.report(\n                  t.makeError(getprop, VISIBILITY_MISMATCH,\n                      visibility.name(), foundVisibilityObjectType.toString(),\n                      overridingVisibility.name()));\n          }\n      }\n      // If none of the above conditions hit, the override is allowed (e.g. protected by subclass, public)\n    } else { // Not an override\n      if (sameInput) {\n        // private/protected access is always allowed in the same file.\n        return;\n      }\n\n      // Check access rules for accesses outside the defining file\n      if (visibility == Visibility.PRIVATE) {\n          // Check if we're accessing from a different class context\n          // currentClass is the 'this' context of the current scope,\n          // ownerType is the class where the property is defined.\n          // Private access outside the defining file is disallowed if the accessing\n          // context class is different from the defining class, unless it's a\n          // valid constructor access.\n          if (currentClass == null || ownerType.differsFrom(currentClass)) {\n              if (!isValidPrivateConstructorAccess(parent)) {\n                  compiler.report(\n                      t.makeError(getprop,\n                          BAD_PRIVATE_PROPERTY_ACCESS,\n                          propertyName,\n                          validator.getReadableJSTypeName(\n                              getprop.getFirstChild(), true)));\n              }\n          }\n          // If currentClass is the same as ownerType, access is allowed implicitly by not reporting error.\n      } else if (visibility == Visibility.PROTECTED) {\n          // Protected access from outside file allowed only if in a subclass.\n          // currentClass is null in global scope, so check isSubtype only works if inside a class method.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n              compiler.report(\n                  t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                      propertyName,\n                      validator.getReadableJSTypeName(\n                          getprop.getFirstChild(), true)));\n          }\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}