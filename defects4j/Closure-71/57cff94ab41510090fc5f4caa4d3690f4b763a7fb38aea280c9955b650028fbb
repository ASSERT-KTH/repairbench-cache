{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    // Determine the type of the object whose property is being accessed.\n    // This `initialObjectType` will be the type of the receiver (e.g., `SubFoo` for `this.bar_`\n    // within a `SubFoo` constructor, or `SubFoo.prototype` for `SubFoo.prototype.bar_`).\n    ObjectType initialObjectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (initialObjectType == null) {\n      return; // No type information available, assume visibility is not restricted.\n    }\n\n    // Find the original property definition and its JSDocInfo.\n    // The `getProperty` method inherently traverses the prototype chain for prototype properties\n    // and looks up instance properties on the class chain for instance properties.\n    Property originalProperty = initialObjectType.getProperty(propertyName);\n    JSDocInfo docInfo = null;\n    JSType ownerType = null; // Stores the JSType where the property was originally declared.\n\n    if (originalProperty != null) {\n      docInfo = originalProperty.getJSDocInfo();\n      ownerType = originalProperty.getDeclaringType();\n    }\n\n    if (docInfo == null || docInfo.getVisibility() == Visibility.INHERITED) {\n      // If no explicit visibility modifier was found, or it's inherited,\n      // it means the property is effectively public or its visibility is not restricted.\n      return;\n    }\n\n    // At this point, docInfo is not null and has a specific visibility (e.g., PRIVATE, PROTECTED).\n    Visibility visibility = docInfo.getVisibility();\n    // Check if the access is in the same input (file) as the property's declaration.\n    boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName());\n    // Normalize the owner type to its class representation (e.g., Foo.prototype -> Foo).\n    ownerType = normalizeClassType(ownerType);\n\n    // Determine if this is an override attempt. An override occurs when the property\n    // is on the left-hand side of an assignment, implying a re-definition.\n    // The `t.inGlobalScope()` check was removed to correctly identify instance property\n    // overrides within constructors/methods.\n    boolean isOverride = parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop;\n\n    if (isOverride) {\n      // This is an assignment that might be overriding an existing property.\n      JSDocInfo overridingInfo = parent.getJSDocInfo();\n      Visibility overridingVisibility = overridingInfo == null ?\n          Visibility.INHERITED : overridingInfo.getVisibility();\n\n      // Rule 1: Cannot override a private property from a different input (file).\n      // If the original property is private and we are in a different file:\n      if (visibility == Visibility.PRIVATE) {\n        if (!sameInput) {\n          // If the overriding property has no explicit JSDoc (i.e., its visibility is INHERITED),\n          // this is considered a \"bad private property access\" because it implicitly tries\n          // to make a private property public, which is not allowed.\n          if (overridingVisibility == Visibility.INHERITED) {\n            compiler.report(\n                t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          } else {\n            // If the overriding property has an explicit JSDoc (e.g., @private),\n            // but it's still attempting to override a private property from a different file,\n            // it's a specific \"private override\" error.\n            compiler.report(\n                t.makeError(getprop, PRIVATE_OVERRIDE,\n                    ownerType.toString()));\n          }\n        }\n      } else if (overridingVisibility != Visibility.INHERITED &&\n                 overridingVisibility != visibility) {\n        // Rule 2: If the overriding property specifies a visibility, it must match\n        // the original property's visibility, unless the original is private.\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), ownerType.toString(),\n                overridingVisibility.name()));\n      }\n    } else { // This is a normal property access (not an override attempt).\n      if (sameInput) {\n        // Accesses within the same file are always allowed, regardless of visibility.\n        return;\n      } else if (visibility == Visibility.PRIVATE) {\n        // Private access is not allowed outside the file unless within the same enclosing class.\n        // `currentClass` is the JSType of the class context for the current traversal.\n        if (currentClass == null || ownerType.differsFrom(currentClass)) {\n          // Special case for private constructors:\n          if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      } else if (visibility == Visibility.PROTECTED) {\n        // Protected property access rules:\n        // 1) Allowed in the same file (already handled by `sameInput` check).\n        // 2) Allowed when overriding the property in a subclass (handled by `isOverride` block).\n        // 3) Allowed when accessing the property from inside a subclass.\n        // We only need to check for case 3 here: if `currentClass` is a subtype of `ownerType`.\n        if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n          compiler.report(\n              t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}