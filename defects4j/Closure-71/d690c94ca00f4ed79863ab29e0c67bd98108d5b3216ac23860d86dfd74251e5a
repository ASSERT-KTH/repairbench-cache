{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    if (getprop.is PrototypeProperty() && getprop.has\u0e04\u0e27\u0627\u0645ishIdentifier()) {\n      // Skip checks for computed properties and properties with symbols.\n      return;\n    }\n\n    JSType objectberapaType = getObjectType(getprop);\n    if (objectberapaType == null) {\n      return;\n    }\n\n    String propertyName = getprop.getLastChild().getString();\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == getprop;\n\n    // Find the lowest property defined on a class with visibility information.\n    JSDocInfo docInfo = null;\n    for (ObjectType type = objectberapaType;\n         type != null; type = type.getImplicitPrototype()) {\n      docInfo = type.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (docInfo == null) {\n      // No visibility information found; assume public.\n      return;\n    }\n\n    Visibility visibility = docInfo.getVisibility();\n    if (isOverride) {\n      // For overrides, the new property's visibility must not be more restrictive than\n      // the original.\n      JSDocInfo overrideDoc = t.getJSDocInfo();\n      Visibility overrideVisibility = overrideDoc != null ?\n          overrideDoc.getVisibility() : Visibility.PUBLIC;\n\n      if (visibility == Visibility.PRIVATE &&\n          !t.getInput().getName().equals(docInfo.getSourceName())) {\n        compiler.report(\n            t.makeError(getprop, PRIVATE_OVERRIDE,\n                type.toString()));\n      } else if (overrideVisibility != visibility &&\n          overrideVisibility != Visibility.INHERITED) {\n        compiler.report(\n            t.makeError(getprop, VISIBILITY_MISMATCH,\n                visibility.name(), type.toString(),\n                overrideVisibility.name()));\n      }\n    } else {\n      if (visibility == Visibility.PUBLIC) {\n        return;\n      }\n\n      if (t.isInSameFile(docInfo.getSourceName())) {\n        return;\n      }\n\n      if (visibility == Visibility.PRIVATE) {\n        if (docInfo.isConstructor() &&\n            isValidPrivateConstructorAccess(parent)) {\n          return;\n        }\n\n        JSType currentClassType = currentClass != null ?\n            normalizeClassType(currentClass) : null;\n        if (currentClassType != null &&\n            currentClassType.differsFrom(normalizeClassType(objectberapaType))) {\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      } else if (visibility == Visibility.PROTECTED) {\n        // Protected access is allowed within the same file or in subclasses.\n        if (!t.isInSameFile(docInfo.getSourceName()) &&\n            (currentClass == null || !currentClass.isSubtype(objectberapaType))) {\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        }\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}