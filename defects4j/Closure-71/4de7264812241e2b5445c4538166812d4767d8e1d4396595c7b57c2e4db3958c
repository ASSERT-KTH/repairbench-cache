{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    Node objectNode = getprop.getFirstChild();\n    Node propertyNode = getprop.getLastChild();\n    // We only check string properties.\n    if (!propertyNode.isString()) {\n      return;\n    }\n    String propertyName = propertyNode.getString();\n    JSType objectJsType = objectNode.getJSType();\n    ObjectType objectType = ObjectType.cast(dereference(objectJsType));\n\n    // Sometimes the object type is unknown/null, check this case\n    if (objectType == null) {\n      // If the type is BOT, we are probably accessing a property of an object\n      // lit or an array lit. Let it slide.\n      if (objectJsType != null && objectJsType.isBottomObject()) {\n          return;\n      }\n      // Or maybe the object type is null because it refers to an objectlit\n      // that is missing its definition?\n      ObjectType maybeType = ObjectType.cast(objectJsType);\n      if (maybeType != null && maybeType.isObjectLitPrototype()) {\n          return;\n      }\n      // Other types (like unions) are checked in CheckConformance\n      return;\n    }\n\n    // Check if this is an assignment that might be an override.\n    // This includes assignments to 'this.prop' and assignments to 'Class.prototype.prop'.\n    boolean isPotentialOverride = parent.isAssign() &&\n                                  parent.getFirstChild() == getprop &&\n                                  (objectNode.isThis() ||\n                                   (objectNode.isGetProp() && // e.g., Foo.prototype\n                                    objectNode.getLastChild().getString().equals(\"prototype\")));\n\n\n    // Find the property definition directly on the object's type or its prototype chain.\n    JSDocInfo definingDocInfo = null; // JSDoc on the type being accessed or its direct prototypes\n    ObjectType definingType = null;   // Type where definingDocInfo was found\n\n    // Search the instance type and its prototype chain first.\n    ObjectType searchType = objectType;\n    while (searchType != null && !searchType.isUnknownType() && definingType == null) {\n       definingDocInfo = searchType.getOwnPropertyJSDocInfo(propertyName);\n       if (definingDocInfo != null && definingDocInfo.getVisibility() != Visibility.INHERITED) {\n          definingType = searchType;\n          // Found the definition specific to this type/instance chain.\n          break;\n       }\n       // Continue search up the prototype chain.\n       searchType = searchType.getImplicitPrototype();\n    }\n\n    // Find the property definition on the superclass chain, but *only* if this looks\n    // like an override attempt. Start search from the *original* objectType's implicit prototype.\n    JSDocInfo inheritedDocInfo = null; // JSDoc on the nearest superclass defining the property\n    ObjectType inheritedType = null;   // Type where inheritedDocInfo was found\n\n    if (isPotentialOverride) {\n        ObjectType searchSuperType = objectType.getImplicitPrototype();\n        while (searchSuperType != null && !searchSuperType.isUnknownType()) {\n             inheritedDocInfo = searchSuperType.getOwnPropertyJSDocInfo(propertyName);\n             if (inheritedDocInfo != null && inheritedDocInfo.getVisibility() != Visibility.INHERITED) {\n                  inheritedType = searchSuperType;\n                  break; // Found nearest inherited definition with visibility\n             }\n             searchSuperType = searchSuperType.getImplicitPrototype();\n        }\n    }\n\n    // If no inherited property found for an override, it's not really an override check w.r.t visibility.\n    if (isPotentialOverride && inheritedType == null) {\n        isPotentialOverride = false;\n    }\n\n    // Determine which definition to prioritize for checks.\n    // If overriding, check the inherited property's visibility first.\n    // If not overriding, check the definition found on the object's direct type hierarchy.\n    JSDocInfo checkDocInfo = isPotentialOverride ? inheritedDocInfo : definingDocInfo;\n    ObjectType ownerType = isPotentialOverride ? inheritedType : definingType;\n\n    // If there's no property with visibility info to check against, return.\n    if (checkDocInfo == null) {\n       // If 'definingDocInfo' exists but 'checkDocInfo' is null (because it wasn't an override\n       // or the superclass didn't define the prop), we should still check the visibility\n       // of the property being accessed/defined on the current type.\n       if (definingDocInfo != null) {\n            checkDocInfo = definingDocInfo;\n            ownerType = definingType;\n            // Ensure we don't perform override-specific checks later if super didn't define it.\n            isPotentialOverride = false;\n       } else {\n           // No property found with visibility information anywhere relevant.\n           return;\n       }\n    }\n\n    // We must have found a property with visibility info to check.\n    Visibility visibility = checkDocInfo.getVisibility();\n    String sourceName = checkDocInfo.getSourceName();\n\n    // ownerType should be non-null here if checkDocInfo is non-null, based on search logic.\n\n    boolean sameInput = sourceName != null && sourceName.equals(t.getInput().getName());\n\n    // Get the current class type for context checking. Use normalizeClassType on the type of 'this'.\n    // This might be null if not inside a class method/constructor.\n    JSType currentClass = normalizeClassType(t.getScope().getTypeOfThis());\n\n    // Check 1: Private Access Violation\n    if (visibility == Visibility.PRIVATE && !sameInput) {\n        JSType ownerClassType = normalizeClassType(ownerType); // Class where checkDocInfo is defined\n\n        // Check if accessed from within the same class structure. Use isEquivalentTo for class comparison.\n        boolean accessWithinOwnerClass = currentClass != null && ownerClassType != null &&\n                                         currentClass.isEquivalentTo(ownerClassType);\n\n        if (!accessWithinOwnerClass) {\n             // Allow access to private constructors via specific patterns\n             if (!(checkDocInfo.isConstructor() && isValidPrivateConstructorAccess(parent))) {\n                 // Report PRIVATE_OVERRIDE if it was an override attempt of a private member across files/classes.\n                 // Report BAD_PRIVATE_PROPERTY_ACCESS for other invalid private accesses.\n                 DiagnosticType error = isPotentialOverride ? PRIVATE_OVERRIDE : BAD_PRIVATE_PROPERTY_ACCESS;\n                 String definedOwnerTypeName = ownerClassType != null ? ownerClassType.toString() : ownerType.toString();\n\n                 if (error == BAD_PRIVATE_PROPERTY_ACCESS) {\n                    compiler.report(\n                       t.makeError(getprop, error, propertyName, definedOwnerTypeName));\n                 } else { // PRIVATE_OVERRIDE just takes the class name where it was defined\n                    compiler.report(\n                       t.makeError(getprop, error, definedOwnerTypeName));\n                 }\n                 return; // Report error and stop\n             }\n        }\n    }\n\n    // Check 2: Protected Access Violation\n    else if (visibility == Visibility.PROTECTED && !sameInput) {\n       JSType ownerClassType = normalizeClassType(ownerType); // Class where checkDocInfo is defined\n\n       // Protected access is allowed if we're in the same file (already excluded by !sameInput)\n       // or if we are in a subclass of the owner class.\n       boolean accessFromSubclass = currentClass != null && ownerClassType != null &&\n                                    currentClass.isSubtype(ownerClassType);\n\n       if (!accessFromSubclass) {\n           // Use the type name where the property was defined for the error message.\n           String definedOwnerTypeName = ownerClassType != null ? ownerClassType.toString() : ownerType.toString();\n           compiler.report(\n               t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS,\n                   propertyName,\n                   definedOwnerTypeName));\n           return; // Report error and stop\n       }\n    }\n\n\n    // Check 3: Override Visibility Mismatch\n    // This check should only happen if it IS an override AND basic access was allowed by checks above.\n    if (isPotentialOverride) {\n        // We need the visibility of the overriding property (definingDocInfo from the subtype).\n        // If the subtype didn't have its own definition, treat its visibility as INHERITED.\n        Visibility overridingVisibility = (definingDocInfo == null) ?\n            Visibility.INHERITED : definingDocInfo.getVisibility();\n\n        // Compare with the visibility of the overridden property ('visibility' from checkDocInfo/inheritedDocInfo)\n        if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) {\n             JSType ownerClassType = normalizeClassType(ownerType); // The super class type\n             String ownerClassTypeName = ownerClassType != null ? ownerClassType.toString() : ownerType.toString();\n            compiler.report(\n                t.makeError(getprop, VISIBILITY_MISMATCH,\n                    visibility.name(), ownerClassTypeName,\n                    overridingVisibility.name()));\n        }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}