{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   * @param parent The parent of the getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?  We allow overrides at top-level (prototype\n      // assignments) or in a subclass constructor (this.prop_ = ...).\n      boolean isOverride = parent.getType() == Token.ASSIGN\n          && parent.getFirstChild() == getprop\n          && (t.inGlobalScope()\n              || (getprop.getFirstChild().isThis() && currentClass != null));\n\n      // If it's an override, start looking one level up the chain.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n\n      // Find the lowest property defined on a class with visibility info.\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // No visibility specified => public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n\n      if (isOverride) {\n        // We're in an ASSIGN that's overriding a superclass property.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null\n            ? Visibility.INHERITED\n            : overridingInfo.getVisibility();\n\n        // (1) Cannot override a private property from another file.\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          if (overridingVisibility == Visibility.INHERITED) {\n            // No @private on the override => bad private access.\n            compiler.report(\n                t.makeError(getprop,\n                    BAD_PRIVATE_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          } else {\n            // Marked @private but still overriding across files.\n            compiler.report(\n                t.makeError(getprop,\n                    PRIVATE_OVERRIDE,\n                    objectType.toString()));\n          }\n        }\n        // (2) If the override has a visibility annotation, it must match.\n        else if (overridingVisibility != Visibility.INHERITED\n            && overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop,\n                  VISIBILITY_MISMATCH,\n                  visibility.name(),\n                  objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        // Normal property access.\n        if (sameInput) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (visibility == Visibility.PRIVATE\n            && (currentClass == null\n                || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor()\n              && isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n          // private access is not allowed outside the file or class.\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          // Protected: same file, override, or subclass method.\n          if (currentClass == null\n              || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,\n                    BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}