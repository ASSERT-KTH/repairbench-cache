{
    "generation": "  /**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */\n  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Check if this is an assignment to the property, which might be an override.\n      boolean isPotentialOverride =\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the JSDoc defining the property *being overridden*, if any.\n      // This search must start from the prototype chain to find the inherited property.\n      JSDocInfo overriddenDocInfo = null;\n      ObjectType overriddenOwnerType = null;\n      // Start search from the immediate prototype of the object type.\n      ObjectType searchType = objectType.getImplicitPrototype();\n      for (; searchType != null;\n           searchType = searchType.getImplicitPrototype()) {\n        overriddenDocInfo = searchType.getOwnPropertyJSDocInfo(propertyName);\n        if (overriddenDocInfo != null &&\n            overriddenDocInfo.getVisibility() != Visibility.INHERITED) {\n          overriddenOwnerType = searchType;\n          break; // Found the first inherited definition with visibility.\n        }\n      }\n\n      // Perform override checks if this is an assignment and an inherited property was found.\n      if (isPotentialOverride && overriddenOwnerType != null) {\n        Visibility overriddenVisibility = overriddenDocInfo.getVisibility();\n        // Normalize to the class type for error messages.\n        JSType overriddenOwnerClassType = normalizeClassType(overriddenOwnerType);\n        boolean overriddenInSameInput = t.getInput().getName().equals(overriddenDocInfo.getSourceName());\n\n        // Determine the visibility of the overriding assignment, if any is specified.\n        JSDocInfo overridingInfo = parent.getJSDocInfo(); // JSDoc on the ASSIGN node.\n        // Also check getprop node itself for JSDoc (e.g. /** @private */ this.foo = ...;)\n        if (overridingInfo == null) {\n          overridingInfo = getprop.getJSDocInfo();\n        }\n        // TODO(lharker): Consider checking JSDoc on the RHS function expression too.\n\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        // Check (a): Attempting to override a private property from a different file.\n        if (overriddenVisibility == Visibility.PRIVATE && !overriddenInSameInput) {\n          // This is disallowed. Report PRIVATE_OVERRIDE.\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  // Use the owner type's display name in the error message.\n                  overriddenOwnerClassType != null ? overriddenOwnerClassType.toString() : \"{unknown}\"));\n          return; // Don't perform other checks if this rule is violated.\n        }\n        // Check (b): Visibility mismatch between override and overridden property.\n        // An explicit visibility annotation must match the overridden visibility.\n        else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != overriddenVisibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  overriddenVisibility.name(),\n                  overriddenOwnerClassType != null ? overriddenOwnerClassType.toString() : \"{unknown}\",\n                  overridingVisibility.name()));\n          return; // Don't perform other checks if visibility mismatches.\n        }\n        // Fallthrough: If override checks pass, proceed to access checks.\n      }\n\n      // Access Check:\n      // Find the *first* definition with visibility, starting from the object type itself.\n      // This determines the visibility context for the *access* itself (read or write).\n      JSDocInfo effectiveDocInfo = null;\n      ObjectType effectiveOwnerType = null;\n      ObjectType accessSearchType = objectType;\n      for (; accessSearchType != null;\n           accessSearchType = accessSearchType.getImplicitPrototype()) {\n        effectiveDocInfo = accessSearchType.getOwnPropertyJSDocInfo(propertyName);\n        if (effectiveDocInfo != null &&\n            effectiveDocInfo.getVisibility() != Visibility.INHERITED) {\n          effectiveOwnerType = accessSearchType;\n          break; // Found the first definition with visibility for access check.\n        }\n      }\n\n      // If no visible property definition found anywhere up the chain, it's implicitly public.\n      if (effectiveOwnerType == null) {\n        return; // Access allowed.\n      }\n\n      // Perform access check based on the effective visibility found.\n      Visibility effectiveVisibility = effectiveDocInfo.getVisibility();\n      // Normalize to the class type for checks and error messages.\n      JSType effectiveOwnerClassType = normalizeClassType(effectiveOwnerType);\n      boolean effectiveInSameInput = t.getInput().getName().equals(effectiveDocInfo.getSourceName());\n      // Get the current class context of the access.\n      JSType currentClass = normalizeClassType(this.currentClass);\n\n      // Access Rule 1: Access is always allowed within the same file.\n      if (effectiveInSameInput) {\n        return;\n      }\n\n      // Access Rule 2: Private properties accessed from a different file.\n      if (effectiveVisibility == Visibility.PRIVATE) {\n         // Allow specific cases like super() calls accessing private constructors.\n         if (effectiveDocInfo.isConstructor() &&\n             isValidPrivateConstructorAccess(parent)) {\n           return;\n         }\n\n         // Private properties are only accessible within the same file. Since 'effectiveInSameInput'\n         // is false, this access is invalid.\n         // Report BAD_PRIVATE_PROPERTY_ACCESS for reads or writes that reach this point.\n         // (Invalid overrides were caught earlier).\n         compiler.report(\n             t.makeError(getprop,\n                 BAD_PRIVATE_PROPERTY_ACCESS,\n                 propertyName,\n                 validator.getReadableJSTypeName(\n                     getprop.getFirstChild(), true))); // Name of the object type being accessed\n         return;\n      }\n\n      // Access Rule 3: Protected properties accessed from a different file.\n      if (effectiveVisibility == Visibility.PROTECTED) {\n        // Protected properties are accessible in subclasses. Check if the current\n        // context is a subclass of the class where the protected property was defined.\n        if (currentClass == null || effectiveOwnerClassType == null ||\n            !currentClass.isSubtype(effectiveOwnerClassType)) {\n          // Access is not from within a subclass. Report error.\n          compiler.report(\n              t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true))); // Name of the object type being accessed\n        }\n        // else: Access is allowed (from subclass).\n      }\n      // Implicitly public properties have no access restrictions here.\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}