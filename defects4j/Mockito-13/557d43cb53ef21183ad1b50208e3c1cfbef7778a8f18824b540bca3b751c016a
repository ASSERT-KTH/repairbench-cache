{
    "generation": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n                mockingProgress.getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n\n    // try to pull out a verification-mode (if someone called verify() before)\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n            mockingProgress.getArgumentMatcherStorage(), invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        // if this is the correct mock under verification, do the verify and return\n        if (verificationMode instanceof MockAwareVerificationMode\n                && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n            VerificationDataImpl data =\n                new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n            verificationMode.verify(data);\n            return null;\n        } else {\n            // invocation was on a different mock \u2013 re\u2010add the mode so the real verify() can happen later\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n\n    // no verification => record for stubbing or execute stub/default answer\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing =\n        new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        // for spies/partial mocks we need to reset in case the real method\n        // triggered more calls to self\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}