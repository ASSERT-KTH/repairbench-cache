{
    "generation": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()\n        if (verificationMode != null) {\n            // If verification is ongoing, decide if this invocation is the target.\n\n            // We need to check if verification was started on the correct mock\n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            // Explanation:\n            //   verify(mockTwo).doStuff(mockOne.doOtherStuff());\n            //   When 'mockOne.doOtherStuff()' is evaluated, it invokes the handler on mockOne. But verification is intended for mockTwo.\n            //   So we need to ignore this invocation from verification criteria (otherwise mockOne might be verified).\n            //   We need to differentiate between invocations intended for verification and invocations related evaluation of arguments.\n            //   Hence, we should check the instance of the mock.\n            if (verificationMode instanceof MockAwareVerificationMode) {\n                MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n                // Check if the verified mock is the same as the mock reacting to this invocation.\n                if (mockAwareVerificationMode.getMock() == invocation.getMock()) {\n                    // Verification is for the current mock. Proceed with verification.\n                    VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                    verificationMode.verify(data);\n                    return null; // Verification finished, no need to check stubs.\n                } else {\n                    // Invocation happened on a different mock than the one being verified.\n                    // This means the invocation is likely part of argument evaluation for the verify() call.\n                    // We must 'undecorate' the verification mode and continue, allowing the invocation\n                    // on the other mock to proceed (e.g., return a stubbed value).\n                    mockingProgress.verificationStarted(verificationMode); // Put the verification mode back\n                    // Continue below to handle the invocation (find stubbed answer / call real method).\n                }\n            } else {\n                // Not a MockAware mode (e.g., standard times(1), never()).\n                // Perform verification directly. This assumes Mockito's internal state correctly tracks the target mock for verification.\n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                verificationMode.verify(data);\n                return null; // Verification handled.\n            }\n        }\n\n        // If we are here, it means:\n        // - No verification was in progress (verificationMode == null)\n        // - OR verification was in progress, but it was MockAware for a different mock (and mode was restored).\n        // Now, handle potential stubbing reporting and finding/executing answers.\n\n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}