{
    "generation": "private int peekNumber() throws IOException {\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n\n    int i = 0;\n\n    charactersOfNumber:\n    for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n\n        char c = buffer[p + i];\n        switch (c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    if (c == '0') {\n                        value = 0;\n                        negative = negative; // Preserve the negative for \"-0\"\n                    } else {\n                        value = - (c - '0'); // Accept first digit\n                    }\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0 && c == '0') {\n                        // Consecutive zeros after non-zero are allowed\n                        value *= 10;\n                    } else if (c == '0' && (value == 0 || value == -0)) {\n                        value = -0; // Maintain -0 for subsequent digits\n                    } else {\n                        value *= 10;\n                        value -= (c - '0');\n                    }\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n                            || (value == MIN_INCOMPLETE_INTEGER && value <= Long.MIN_VALUE);\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (negative || value != Long.MIN_VALUE)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n            || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}