{
    "generation": "import org.apache.commons.math.exception.MathInternalError; // Used in default switch cases\nimport org.apache.commons.math.util.FastMath; // Used for abs and max\nimport org.apache.commons.math.analysis.solvers.AllowedSolution; // Assuming enum exists\n// Assuming RegulaFalsiSolver.Method enum exists and other necessary imports/context\n\n    /** {@inheritDoc} */\n    @Override\n    protected final double doSolve() {\n        // Get initial bounds and function values.\n        final double min = getMin();\n        final double max = getMax();\n        double x0 = min;\n        double x1 = max;\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // Keep track of initial function values for side specification for AllowedSolution.\n        final double initialF0 = f0;\n        final double initialF1 = f1;\n\n        // If one of the bounds is the exact root, return it.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Flags to track which side was retained in the previous step, for Illinois/Pegasus.\n        boolean stagnantLeft = false; // True if x1 was retained (not updated) in the previous step.\n        boolean stagnantRight = false; // True if x0 was retained (not updated) in the previous step.\n\n        // Main iteration loop.\n        while (true) {\n            // Calculate the next approximation using the Regula Falsi formula.\n            // Division by zero is avoided because f0 * f1 < 0 implies f0 != f1.\n            final double x = x1 - (f1 * (x1 - x0)) / (f1 - f0);\n            final double fx = computeObjectiveValue(x);\n\n            // Check for exact root.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the interval [x0, x1] and function values f0, f1.\n            if (fx * f1 < 0) {\n                // Root is in (x, x1). Update x0. x1 is retained.\n                final double oldF0 = f0; // Store f0 for potential Pegasus calculation.\n                x0 = x;\n                f0 = fx;\n\n                // Check if the retained endpoint x1 was also retained previously.\n                if (stagnantLeft) {\n                    // Apply modification to the function value of the stagnant endpoint f1.\n                    switch (method) { // Assuming 'method' is an accessible enum field\n                        case ILLINOIS:\n                            f1 *= 0.5;\n                            break;\n                        case PEGASUS:\n                            // Factor uses value at replaced endpoint (oldF0) and new point (fx).\n                            if (oldF0 + fx == 0) { // Avoid division by zero.\n                                f1 *= 0.5; // Fallback to Illinois step.\n                            } else {\n                                f1 *= oldF0 / (oldF0 + fx);\n                            }\n                            break;\n                         default:\n                            // REGULA_FALSI or others: No modification.\n                    }\n                }\n                // Set stagnation flags for next iteration: x1 was retained, x0 was updated.\n                stagnantLeft = true;\n                stagnantRight = false;\n            } else {\n                // Root is in (x0, x). Update x1. x0 is retained (implies f0 * fx < 0).\n                final double oldF1 = f1; // Store f1 for potential Pegasus calculation.\n                x1 = x;\n                f1 = fx;\n\n                // Check if the retained endpoint x0 was also retained previously.\n                if (stagnantRight) {\n                    // Apply modification to the function value of the stagnant endpoint f0.\n                    switch (method) { // Assuming 'method' is an accessible enum field\n                        case ILLINOIS:\n                            f0 *= 0.5;\n                            break;\n                        case PEGASUS:\n                             // Factor uses value at replaced endpoint (oldF1) and new point (fx).\n                             if (oldF1 + fx == 0) { // Avoid division by zero.\n                                 f0 *= 0.5; // Fallback to Illinois step.\n                             } else {\n                                 f0 *= oldF1 / (oldF1 + fx);\n                             }\n                            break;\n                         default:\n                            // REGULA_FALSI or others: No modification.\n                    }\n                }\n                // Set stagnation flags for next iteration: x0 was retained, x1 was updated.\n                stagnantRight = true;\n                stagnantLeft = false;\n            }\n\n            // Check convergence criteria.\n\n            // 1. Check function value convergence.\n            // Consider the endpoint whose function value is closer to zero.\n            final double absF0 = FastMath.abs(f0);\n            final double absF1 = FastMath.abs(f1);\n            final double currentX = (absF0 < absF1) ? x0 : x1;\n            final double currentF = (absF0 < absF1) ? f0 : f1;\n\n            if (FastMath.abs(currentF) <= ftol) {\n                // Found a point with function value within tolerance.\n                // Return the best available point satisfying the AllowedSolution condition.\n                return selectResult(x0, f0, x1, f1, initialF0, initialF1, allowed);\n            }\n\n            // 2. Check interval convergence.\n            // Use the latest estimate x1 for relative tolerance, consistent with original code.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) {\n                // Interval is small enough.\n                // Return the best available point satisfying the AllowedSolution condition.\n                return selectResult(x0, f0, x1, f1, initialF0, initialF1, allowed);\n            }\n        } // End while loop\n    }\n\n    /**\n     * Selects the final result based on the AllowedSolution criteria.\n     *\n     * @param x0 Lower bound of the final interval.\n     * @param f0 Function value at x0.\n     * @param x1 Upper bound of the final interval.\n     * @param f1 Function value at x1.\n     * @param initialF0 Function value at the initial lower bound.\n     * @param initialF1 Function value at the initial upper bound.\n     * @param allowed The AllowedSolution criterion.\n     * @return The chosen result (x0 or x1).\n     */\n    private double selectResult(double x0, double f0, double x1, double f1,\n                                double initialF0, double initialF1,\n                                AllowedSolution allowed) {\n\n        final boolean f0Satisfies = checkAllowed(f0, initialF0, initialF1, allowed);\n        final boolean f1Satisfies = checkAllowed(f1, initialF0, initialF1, allowed);\n\n        if (f0Satisfies && f1Satisfies) {\n            // Both endpoints satisfy the criteria, return the one closer to zero.\n            return (FastMath.abs(f0) < FastMath.abs(f1)) ? x0 : x1;\n        } else if (f0Satisfies) {\n            // Only x0 satisfies.\n            return x0;\n        } else if (f1Satisfies) {\n            // Only x1 satisfies.\n            return x1;\n        } else {\n            // Neither endpoint satisfies the criteria (e.g., LEFT_SIDE requested, but both\n            // f0 and f1 have the sign of initialF1). This indicates an issue or edge case.\n            // As a fallback, return the endpoint with the function value closer to zero,\n            // as it's the best approximation found in terms of function value.\n            return (FastMath.abs(f0) < FastMath.abs(f1)) ? x0 : x1;\n        }\n    }\n\n    /**\n     * Helper function to check if a function value satisfies the AllowedSolution criteria.\n     *\n     * @param fx Function value to check.\n     * @param initialF0 Function value at the initial lower bound.\n     * @param initialF1 Function value at the initial upper bound.\n     * @param allowed The AllowedSolution criterion.\n     * @return True if fx satisfies the criteria.\n     */\n    private boolean checkAllowed(double fx, double initialF0, double initialF1, AllowedSolution allowed) {\n         switch (allowed) {\n             case ANY_SIDE:\n                 return true;\n             case LEFT_SIDE:\n                 // Check if sign matches initial lower bound's sign (or if fx is zero).\n                 // Product is positive if signs match, negative if they differ. Zero if fx is zero.\n                 return fx == 0 || (fx > 0 && initialF0 > 0) || (fx < 0 && initialF0 < 0);\n             case RIGHT_SIDE:\n                 // Check if sign matches initial upper bound's sign (or if fx is zero).\n                 return fx == 0 || (fx > 0 && initialF1 > 0) || (fx < 0 && initialF1 < 0);\n             case BELOW_SIDE:\n                 return fx <= 0;\n             case ABOVE_SIDE:\n                 return fx >= 0;\n             default:\n                 // Should not happen.\n                 throw new MathInternalError();\n         }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}