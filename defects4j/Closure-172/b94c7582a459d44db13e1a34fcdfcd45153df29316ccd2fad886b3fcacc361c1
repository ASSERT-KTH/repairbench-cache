{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n\n      // Handle assignments to 'prototype' properties specifically.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          // Determine the node representing the base object (e.g., 'a' in 'a.prototype = ...')\n          Node baseObjectNode = null;\n          Node propertyDefiningNode = n; // Assume n represents the property access/definition initially\n\n          // Adjust propertyDefiningNode if 'n' is the assignment/var node itself\n          if (n.isAssign()) {\n              propertyDefiningNode = n.getFirstChild();\n          } else if (n.isName() && n.getParent().isVar()) {\n              // 'n' is the NAME node in a VAR declaration. This isn't typically a GETPROP.\n              // If VAR is like 'var ns.prop = value;', propertyDefiningNode should be 'ns.prop'.\n              // However, 'var ns.prop' isn't valid JS. Assume direct assignments for prototype.\n          }\n\n          // Check if the propertyDefiningNode is indeed a GETPROP for 'prototype'\n          if (propertyDefiningNode.isGetProp() &&\n              propertyDefiningNode.getString().equals(\"prototype\")) {\n              baseObjectNode = propertyDefiningNode.getFirstChild();\n          }\n\n          if (baseObjectNode != null) {\n              JSType objectType = baseObjectNode.getJSType();\n              if (objectType != null) {\n                  objectType = objectType.restrictByNotNullOrUndefined();\n                  // Only treat prototype assignment as DECLARATION if base is Constructor/Interface\n                  if (objectType.isConstructor() || objectType.isInterface()) {\n                      return false; // Declared\n                  }\n              }\n          }\n          // Otherwise (base is not Ctor/Iface, or type unknown, or not a direct assignment to GETPROP),\n          // treat as INFERRED. This covers the test case a.prototype where a is Object.\n          return true; // Inferred\n      }\n\n\n      // --- Original logic for non-prototype properties ---\n\n      if (valueType == null) {\n        return true; // Inferred if no type info\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Check JSDoc for explicit type, enum, const with known type, or function declaration\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      // Special handling for function assignments without sufficient JSDoc info\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n          // Function assignments without explicit type info might still be declarations\n          // if they haven't been declared before and aren't in conditional blocks etc.\n\n          if (info != null) {\n             // This case should have been handled by the JSDoc check above, making inferred=false.\n             // Defensively return false if we somehow get here.\n             return false; // Function with JSDoc implies declaration.\n          } else if (qName != null && !scope.isDeclared(qName, false)) {\n              // Determine the LValue node and the containing statement node more reliably\n              Node lValueNode = n;\n              Node ownerNode = n.getParent();\n\n              if (n.isAssign()) {\n                  lValueNode = n.getFirstChild();\n                  ownerNode = n;\n              } else if (n.isName() && n.getParent().isVar()) {\n                  lValueNode = n;\n                  ownerNode = n.getParent();\n              } else if (n.isGetProp() && n.getParent().isAssign() && n.getParent().getFirstChild() == n) {\n                  lValueNode = n;\n                  ownerNode = n.getParent();\n              } else {\n                  // If n is NAME on RHS or other complex cases, try to find owning statement\n                 ownerNode = n;\n                 while(ownerNode.getParent() != null && !NodeUtil.isStatementBlock(ownerNode.getParent()) && !ownerNode.getParent().isScript()){\n                     ownerNode = ownerNode.getParent();\n                 }\n              }\n\n              // Check qualified name status on the LValue\n              if (lValueNode.isQualifiedName() && lValueNode.isUnscopedQualifiedName()) {\n\n                    // Check if this is in a conditional block by looking up from the owner node's parent.\n                    for (Node current = ownerNode.getParent();\n                         current != null && !(current.isScript() || current.isFunction());\n                         current = current.getParent()) {\n                        if (NodeUtil.isControlStructure(current)) {\n                            return true; // Inferred in control structure\n                        }\n                    }\n\n                    // Check if this is assigned in an inner scope & not escaped.\n                    AstFunctionContents contents =\n                        getFunctionAnalysisResults(scope.getRootNode());\n                    if (contents == null ||\n                        !contents.getEscapedQualifiedNames().contains(qName)) {\n                       // Not declared, not in control structure, not escaped? Treat as declaration.\n                      return false; // Declared\n                    }\n                    // Otherwise, it remains inferred (escaped or contents unavailable)\n              }\n          }\n      } // end if(inferred && rhsValue is function)\n\n      return inferred; // Return the final inferred status\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}