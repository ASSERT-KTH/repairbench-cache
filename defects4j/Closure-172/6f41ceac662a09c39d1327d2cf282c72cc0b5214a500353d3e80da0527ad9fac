{
    "generation": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared,\n      // EXCEPT when the prototype property is assigned on an instance\n      // (like `a.prototype = ...`), not on a global/constructor (like `Foo.prototype = ...`).\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        // Only consider not inferred if qName is a declaration on a nominal type\n        // Do a basic check: if the qualified name has just one dot (e.g. \"Foo.prototype\")\n        // and the first part is a capitalized name (heuristic for constructor),\n        // consider it declared. Otherwise, inferred.\n        int idx = qName.lastIndexOf('.');\n        if (idx > 0) {\n          String lhs = qName.substring(0, idx);\n          // If this is a simple string like \"Foo\", not \"x.prototype\"\n          if (Character.isUpperCase(lhs.codePointAt(0)) && lhs.indexOf('.') < 0) {\n            return false;\n          }\n        }\n        // Otherwise, inferred (e.g. a.prototype, b.prototype)\n        return true;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}