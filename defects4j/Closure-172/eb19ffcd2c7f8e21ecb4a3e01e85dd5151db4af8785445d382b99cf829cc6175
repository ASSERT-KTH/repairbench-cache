{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Handle assignments to 'prototype' property specifically.\n      if (qName != null && qName.endsWith(\".prototype\") && n.isGetProp()) {\n          Node ownerNode = n.getFirstChild();\n          if (ownerNode != null) {\n              JSType ownerType = ownerNode.getJSType();\n              if (ownerType != null) {\n                  // If owner is the native Object type (and not known to be a constructor/interface),\n                  // treat assignment to prototype as inferred. This handles `obj.prototype = ...`\n                  // where obj is a generic Object, preventing false conflicts like issue 1024.\n                  // We check isNativeObjectType specifically to target the {Object} type from the test.\n                  if (ownerType.isNativeObjectType() && !ownerType.isConstructor() && !ownerType.isInterface()) {\n                      return true; // Inferred\n                  }\n\n                  // If owner is definitely a constructor or interface, this is a declaration.\n                  if (ownerType.isConstructor() || ownerType.isInterface()) {\n                      return false; // Not inferred (Declaration)\n                  }\n              }\n          }\n          // Fall through for other cases (unknown owner type, other object types, etc.)\n          // This allows the general heuristics below to apply. The original code\n          // would have returned false here unconditionally for any '.prototype' assignment.\n      }\n\n      // General heuristics (JSDoc, function assignments)\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          // If we have JSDoc info, but it didn't meet the criteria above\n          // (like @type, @enum, @const, @export), treat function assignments\n          // as declarations.\n           return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred, UNLESS they are\n          // local variables that don't escape the scope.\n          // TODO(nicksantos): This heuristic is weird. Re-visit.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n             // Not escaped, potentially a local function definition. Treat as declared.\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}