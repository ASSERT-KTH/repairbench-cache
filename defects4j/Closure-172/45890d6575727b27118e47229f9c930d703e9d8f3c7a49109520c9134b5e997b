{
    "generation": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared,\n      // but not for arbitrary objects\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        // Only treat as declared if this is a constructor prototype\n        Node parent = n.getParent();\n        if (parent != null && parent.isObjectLit()) {\n          // For object literals, we'll handle via type inference\n        } else {\n          boolean isConstructorPrototype = false;\n          if (n.getParent() != null && n.getParent().isAssign()) {\n            Node lhs = n.getParent().getFirstChild();\n            if (lhs.isGetProp() && \"prototype\".equals(lhs.getLastChild().getString())) {\n              JSType type = getType(lhs.getFirstChild());\n              if (type != null && type.isFunctionType()) {\n                isConstructorPrototype = true;\n              }\n            }\n          }\n          if (isConstructorPrototype) {\n            return false;\n          }\n        }\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}