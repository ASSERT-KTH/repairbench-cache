{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      // Handle assignments like MyConstructor.prototype = ...\n      // This addresses issue 1024 by distinguishing constructor prototypes\n      // from assignments to obj.prototype where obj is not a constructor.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        if (n != null && n.isGetProp()) {\n            Node ownerNode = n.getFirstChild();\n            // Make sure ownerNode is not null, which might happen for detached nodes\n            if (ownerNode == null) {\n              return true; // Cannot determine owner, assume inferred\n            }\n            JSType ownerType = ownerNode.getJSType();\n            if (ownerType != null) {\n                ownerType = ownerType.restrictByNotNullOrUndefined();\n                // Check if owner is a constructor or interface type.\n                boolean ownerIsConstructorOrInterface = false;\n                if (ownerType.isFunctionType()) {\n                    FunctionType fnType = ownerType.toMaybeFunctionType();\n                    if (fnType != null && (fnType.isConstructor() || fnType.isInterface())) {\n                       ownerIsConstructorOrInterface = true;\n                    }\n                // Checking isNominalConstructorOrInterface handles built-in constructors like Object.\n                } else if (ownerType.isNominalConstructorOrInterface()) {\n                   FunctionType fnType = ownerType.toMaybeFunctionType();\n                   // Ensure it's actually the constructor function, not an instance type.\n                   // For example, 'Object' is a constructor, but an instance {Object} is not.\n                   if (fnType != null && fnType.isConstructor()) {\n                       ownerIsConstructorOrInterface = true;\n                   }\n                }\n\n                if (ownerIsConstructorOrInterface) {\n                    // It's MyConstructor.prototype or Object.prototype, treat as declared.\n                    return false;\n                }\n            }\n            // Otherwise (e.g., owner is instance like {Object}, or unknown type),\n            // treat assignment as inferred. This handles issue 1024 where\n            // assignments like obj.prototype = {} should be inferred.\n            return true;\n        } else {\n           // If not a GETPROP (unlikely for x.prototype unless computed),\n           // conservatively treat as inferred.\n           return true;\n        }\n      }\n\n      // ---- Regular Inference Logic ----\n      // Based on JSDoc\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      // Special handling for function literals without JSDoc.\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        // Generally, function assignments are declarations unless in specific contexts.\n        if (info != null) {\n          // Should have been caught above, but confirms not inferred.\n          return false;\n        } else if (n != null && !scope.isDeclared(qName, false) &&\n                   // Make sure n isn't detached and has a parent.\n                   n.getParent() != null &&\n                   n.isUnscopedQualifiedName()) { // Check for simple qualified names like a.b.c\n\n          // Check if assigned inside a control structure (if, for, while etc.) -> inferred.\n          for (Node current = n.getParent();\n               // Check current != null as getParent() can return null.\n               current != null && !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if assigned in an inner scope and escapes -> inferred.\n          // Otherwise (global scope, or inner scope but doesn't escape) -> declared.\n          // Use NodeUtil to find scope root, as scope.getScope(n) might be too broad.\n          Node scopeRoot = NodeUtil.getEnclosingFunction(n);\n          // Check if the assignment occurs within a function scope (not global).\n          if (scopeRoot != null && scopeRoot.isFunction()) {\n              AstFunctionContents contents = getFunctionAnalysisResults(scopeRoot);\n              // If analysis is available and name is known to escape this scope -> inferred.\n              if (contents != null && contents.getEscapedQualifiedNames().contains(qName)) {\n                  return true;\n              } else {\n                  // Does not escape or analysis unavailable -> declared (local to this function).\n                  return false;\n              }\n          } else {\n            // In global scope (or scope analysis failed), treat as declared.\n            return false;\n          }\n        } else if (n != null && n.isName() && scope.isDeclared(qName, false)) {\n            // If it's a simple name re-assignment in the same scope, treat it as non-inferred.\n            // Example: function f() { var x = function() {}; x = function() {}; }\n            // The second assignment should not be inferred.\n            return false;\n        }\n      }\n      return inferred; // Return the final inferred status.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}