{
    "generation": "/**\n * Determines whether a qualified name is inferred.\n * NOTE(nicksantos): Determining whether a property is declared or not\n * is really really obnoxious.\n *\n * The problem is that there are two (equally valid) coding styles:\n *\n * (function() {\n *   /* The authoritative definition of goog.bar. /\n *   goog.bar = function() {};\n * })();\n *\n * function f() {\n *   goog.bar();\n *   /* Reset goog.bar to a no-op. /\n *   goog.bar = function() {};\n * }\n *\n * In a dynamic language with first-class functions, it's very difficult\n * to know which one the user intended without looking at lots of\n * contextual information (the second example demonstrates a small case\n * of this, but there are some really pathological cases as well).\n *\n * The current algorithm checks if either the declaration has\n * JsDoc type information, or @const with a known type,\n * or a function literal with a name we haven't seen before.\n */\nprivate boolean isQualifiedNameInferred(\n    String qName, Node n, JSDocInfo info,\n    Node rhsValue, JSType valueType) {\n  if (valueType == null) {\n    return true;\n  }\n\n  // Prototypes of constructors and interfaces are always declared,\n  // UNLESS the qualified name is of the form \"<param>.prototype\"\n  // (i.e., the prototype property of a function parameter), in which\n  // case the assignment should always be inferred.\n  if (qName != null && qName.endsWith(\".prototype\")) {\n    Node target = n.getFirstChild();\n    if (target != null && target.isGetProp()) {\n      Node owner = target.getFirstChild();\n      if (owner != null && owner.isName() && owner.getOriginalName() != null) {\n        boolean isParam = false;\n        Node maybeFunction = n;\n        while (maybeFunction != null && !maybeFunction.isFunction()) {\n          maybeFunction = maybeFunction.getParent();\n        }\n        if (maybeFunction != null && maybeFunction.isFunction()) {\n          Node params = maybeFunction.getSecondChild();\n          for (Node param = params.getFirstChild(); param != null; param = param.getNext()) {\n            if (param.isName() && param.getString().equals(owner.getString())) {\n              isParam = true;\n              break;\n            }\n          }\n        }\n        if (isParam) {\n          return true;\n        }\n      }\n    }\n    // Regular prototype assignment, not to a parameter's prototype property.\n    return false;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (isConstantSymbol(info, n) && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    if (info != null) {\n      return false;\n    } else if (!scope.isDeclared(qName, false) &&\n        n.isUnscopedQualifiedName()) {\n\n      // Check if this is in a conditional block.\n      // Functions assigned in conditional blocks are inferred.\n      for (Node current = n.getParent();\n           !(current.isScript() || current.isFunction());\n           current = current.getParent()) {\n        if (NodeUtil.isControlStructure(current)) {\n          return true;\n        }\n      }\n\n      // Check if this is assigned in an inner scope.\n      // Functions assigned in inner scopes are inferred.\n      AstFunctionContents contents =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (contents == null ||\n          !contents.getEscapedQualifiedNames().contains(qName)) {\n        return false;\n      }\n    }\n  }\n  return inferred;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}