{
    "generation": "private boolean isQualifiedNameInferred(\n    String qName, Node n, JSDocInfo info,\n    Node rhsValue, JSType valueType) {\n  if (valueType == null) {\n    return true;\n  }\n\n  // Normally, prototypes of constructors and interfaces are always declared.\n  // However, if the left\u2010side is something like a parameter (an Object, not a function)\n  // then its \u201c.prototype\u201d property should be treated as inferred.\n  if (qName != null && qName.endsWith(\".prototype\")) {\n    Node left = n.getFirstChild();\n    if (left != null) {\n      JSType leftType = left.getJSType();\n      if (leftType != null && leftType.isFunctionType()) {\n        return false;\n      }\n    }\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (isConstantSymbol(info, n) && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  // For function literal assignments, normally we may switch a property from inferred\n  // to declared (if the function escapes).  But we do not want to do that on a\n  // prototype property when its owner isn\u2019t a constructor.\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    if (qName != null && qName.endsWith(\".prototype\")) {\n      Node left = n.getFirstChild();\n      if (left == null || left.getJSType() == null ||\n          !left.getJSType().isFunctionType()) {\n        // For non-constructor prototype assignments, leave it inferred.\n        return inferred;\n      }\n    }\n    if (info != null) {\n      return false;\n    } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n      // If the assignment occurs in a control structure, keep it inferred.\n      for (Node current = n.getParent();\n           !(current.isScript() || current.isFunction());\n           current = current.getParent()) {\n        if (NodeUtil.isControlStructure(current)) {\n          return true;\n        }\n      }\n\n      // If assigned in an inner scope, the qualified name is inferred.\n      AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n      if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n        return false;\n      }\n    }\n  }\n  return inferred;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}