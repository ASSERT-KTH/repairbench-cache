{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      // Check the owner node of the GETPROP.\n      // We assume that 'n' is the GETPROP node for prototype assignments.\n      if (qName != null && qName.endsWith(\".prototype\") && n.isGetProp()) {\n          Node ownerNode = n.getFirstChild();\n          if (ownerNode != null) {\n              JSType ownerType = ownerNode.getJSType();\n              // If the owner is specifically a constructor or interface type,\n              // then this assignment is defining its prototype, hence \"declared\".\n              if (ownerType != null && ownerType.isNominalConstructorOrInterface()) {\n                 // This is the defining site for the prototype, so it's declared.\n                 return false;\n              } else {\n                 // Otherwise, it's just a property named \"prototype\" on some other type\n                 // (like a generic Object parameter, as in issue 1024).\n                 // Treat this assignment as inferred, allowing flexibility.\n                 return true;\n              }\n          }\n          // Fall through if ownerNode/ownerType is null, or n is not GETPROP.\n          // This case seems less likely for typical prototype assignments.\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          // If it has JSDoc, it's explicitly declared.\n          return false;\n        } else if (n.isUnscopedQualifiedName() && !scope.isDeclared(qName, false)) {\n          // If it's an unqualified name or rooted in a name that is not locally\n          // defined, check if the assignment is in a conditional block or an inner scope.\n          // Those are inferred. Otherwise, this is likely the defining declaration.\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               current != null && !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          // We check this by seeing if the name is escaped by the current function.\n          Scope functionScope = scope.getFunctionScope();\n          if (functionScope != null) {\n            AstFunctionContents contents =\n                getFunctionAnalysisResults(functionScope.getRootNode());\n            if (contents != null &&\n                contents.getEscapedQualifiedNames().contains(qName)) {\n              return true;\n            }\n          }\n\n          // If none of the above conditions met (no JSDoc, not conditional, not inner scope),\n          // and it's the first time we see this function assigned to this qname,\n          // consider it a declaration.\n          return false;\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}