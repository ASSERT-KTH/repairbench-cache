{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      // However, this should only apply to *qualified* names where the base\n      // is a global constructor or interface. For local variables or arbitrary\n      // expressions, the prototype should be inferred.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          Node base = n.getFirstChild();\n          JSType baseType = null;\n\n          if (base.isName()) {\n              // If the base is a simple name (e.g., 'MyClass', 'a')\n              Var var = scope.getVar(base.getString());\n              // Check if it's a global variable. Local variables/parameters\n              // like 'a' in 'a.prototype' are not considered declared here.\n              if (var != null && var.isGlobal()) {\n                  baseType = var.getType();\n              }\n          } else if (base.isGetProp() || base.isGetElem()) {\n              // If the base is a qualified name (e.g., 'goog.Foo') or property access\n              baseType = base.getJSType();\n          }\n\n          // If the base's type is a constructor or interface, then its prototype is declared.\n          if (baseType != null && baseType.isFunctionType()) {\n              FunctionType fnType = baseType.toMaybeFunctionType();\n              if (fnType != null && (fnType.isConstructor() || fnType.isInterface())) {\n                  return false; // This is a declared prototype (e.g., goog.Foo.prototype)\n              }\n          }\n          // If we reach here, it means the prototype is not from a declared constructor/interface\n          // (e.g., local.prototype, or a global non-constructor.prototype, or type not resolvable).\n          // In these cases, it should be inferred, so we proceed without returning false.\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}