{
    "generation": "import com.google.javascript.jscomp.AnalyzePrototypeProperties.AstFunctionContents;\nimport com.google.javascript.jscomp.FunctionTypeBuilder;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\n\n// NOTE: This code snippet assumes it's part of a class that provides\n// context like 'scope', 'getJSType(Node)', 'isConstantSymbol(JSDocInfo, Node)',\n// and 'getFunctionAnalysisResults(Node)', similar to TypeCheck.java.\n\n\n    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      // Check if this is an assignment to a prototype property.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          Node baseObjectNode = null;\n          // This logic primarily handles assignment `a.prototype = ...` where 'n' is ASSIGN.\n          if (n.isAssign() && n.getFirstChild().isGetProp()) {\n              Node getPropNode = n.getFirstChild();\n              // We already checked qName ends with \".prototype\", but double-check the node property name.\n              if (\".prototype\".equals(getPropNode.getString())) {\n                  baseObjectNode = getPropNode.getFirstChild();\n              }\n          }\n          // TODO(b/196436498): Handle other declaration forms like VAR `var ns.C.prototype = {}`\n          // if necessary. This might require more context or changes to qName resolution.\n\n          if (baseObjectNode != null) {\n              // Use getJSType from TypeCheck context to find the type of the base object.\n              JSType baseType = getJSType(baseObjectNode);\n              // Check if the type is known and is a function type.\n              // Unknown types or non-function types shouldn't trigger the declaration rule.\n              if (baseType != null && !baseType.isUnknownType() && baseType.isFunctionType()) {\n                   FunctionType fnType = baseType.toMaybeFunctionType();\n                   // If the base object is a constructor or interface, then assigning\n                   // to its prototype is a declaration.\n                   if (fnType != null && (fnType.isConstructor() || fnType.isInterface())) {\n                       // Mark as declared\n                       return false;\n                   }\n              }\n              // If baseType is not a known constructor/interface (e.g., it's Object,\n              // unknown, null, or not a function type), then don't treat this\n              // .prototype assignment as a special declaration. Fall through to the\n              // general inference rules below.\n          } else {\n              // If we couldn't identify the base object node reliably (e.g., complex qName\n              // in VAR decl, or 'n' is not ASSIGN), fall through to the general logic.\n              // This prevents incorrectly marking assignments like `obj.prototype = ...`\n              // (where obj is not a constructor) as declared based only on the suffix.\n          }\n      }\n\n      // General inference rules based on JSDoc, value type, scope, etc.\n      boolean inferred = true;\n      if (info != null) {\n        // This assignment has JSDoc info. Check if it declares a type.\n        inferred = !(info.hasType() // @type\n            || info.hasEnumParameterType() // @enum\n            // @const with a known type (excluding unknown)\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            // @interface or @constructor (handled by FunctionTypeBuilder)\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      // Additional checks, especially for function assignments without JSDoc\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          // Original code had this: if JSDoc is present but didn't meet the\n          // criteria above (e.g., just @param), assigning a function is still\n          // considered a declaration. Keep this behavior for now.\n          return false;\n        } else {\n          // Function assignment without JSDoc. Check scope and usage.\n          // Need the L-value node (the thing being assigned to), e.g., NAME or GETPROP.\n          Node lValueNode = n.isAssign() ? n.getFirstChild() :\n                           (NodeUtil.isNameDeclaration(n) ? n : null); // Handle VAR/LET/CONST NAME etc.\n\n          // Check if the name was already declared in the current scope.\n          // If it was already declared, this assignment is likely not the declaration itself.\n          // NOTE: The second arg to isDeclared means \"search up the scope chain\".\n          if (!scope.isDeclared(qName, false)) {\n            // Check if the L-value is a qualified name (potentially global or namespace member)\n            // and is defined in a place that looks like a declaration (not inside loops/ifs).\n            if (lValueNode != null && NodeUtil.isQualifiedName(lValueNode) &&\n                lValueNode.isUnscopedQualifiedName()) {\n\n              // Check if this is in a conditional block.\n              // Functions assigned in conditional blocks are inferred.\n              for (Node current = n.getParent();\n                   current != null && !(current.isScript() || current.isFunction());\n                   current = current.getParent()) {\n                if (NodeUtil.isControlStructure(current)) {\n                  // Assignment is inside if/loop/etc., treat as inferred.\n                  return true;\n                }\n              }\n\n              // Check if this is assigned in an inner scope using escape analysis.\n              // Functions assigned in inner scopes that don't escape might be declarations for that scope.\n              AstFunctionContents contents =\n                  getFunctionAnalysisResults(scope.getRootNode());\n              // If escape analysis results are available AND the qualified name does NOT escape...\n              if (contents != null && !contents.getEscapedQualifiedNames().contains(qName)) {\n                 // Function doesn't escape, isn't in control structure, has no JSDoc,\n                 // isn't already declared -> treat as a declaration.\n                return false;\n              }\n              // If it escapes, or analysis unavailable, assume inferred (fall through).\n            }\n          }\n        }\n      }\n      // If none of the conditions for declaration were met, it's inferred.\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}