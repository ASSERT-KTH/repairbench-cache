{
    "generation": "    /**\n     * Determines whether a qualified name is inferred.\n     * NOTE(nicksantos): Determining whether a property is declared or not\n     * is really really obnoxious.\n     *\n     * The problem is that there are two (equally valid) coding styles:\n     *\n     * (function() {\n     *   /* The authoritative definition of goog.bar. /\n     *   goog.bar = function() {};\n     * })();\n     *\n     * function f() {\n     *   goog.bar();\n     *   /* Reset goog.bar to a no-op. /\n     *   goog.bar = function() {};\n     * }\n     *\n     * In a dynamic language with first-class functions, it's very difficult\n     * to know which one the user intended without looking at lots of\n     * contextual information (the second example demonstrates a small case\n     * of this, but there are some really pathological cases as well).\n     *\n     * The current algorithm checks if either the declaration has\n     * JsDoc type information, or @const with a known type,\n     * or a function literal with a name we haven't seen before.\n     */\n    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      // If the value type is unknown, we can't know the type, so we infer it.\n      // If the value type is null, we are defining the symbol for the first time.\n      // If it's defined in an extern, we know the type. Otherwise, we don't.\n      if (valueType == null || valueType.isUnknownType()) {\n        // TODO(nicksantos): This is wrong. Null value types should be treated\n        // like other values. Let the type checker worry about the wrong type.\n        if (n != null && n.isFromExterns()) { // Added null check for safety\n           // If this is an extern, the type is declared.\n           return false;\n        } else if (n != null && NodeUtil.isNamespaceDecl(n)) { // Added null check for safety\n          // A namespace declaration implies that the type is declared.\n          return false;\n        } else {\n          return true;\n        }\n      }\n\n      // Removed the special case for \".prototype\" here, as it caused\n      // assignments to obj.prototype (where obj is not a known constructor\n      // type like Object) to be incorrectly treated as declared. See issue 1024.\n      // Prototypes of actual constructors or interfaces might be handled\n      // implicitly by the JSDoc checks or other logic.\n      /*\n      // Prototypes of constructors and interfaces are always declared.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n          return false;\n      }\n      */\n\n      boolean inferred = true;\n      if (info != null) {\n        // Explicit JSDoc type declarations mean the property is declared.\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            // A constant with a known type is declared.\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType()\n                // TODO(johnlenz): Should isBottomObjectType be included?\n                && !valueType.isBottomObjectType() // Except for {bottom}\n                && !valueType.isAllType()) // and {*}\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      // Function assignments are treated as declarations if they are\n      // the first assignment to that qualified name in that scope, and\n      // the function is not anonymous, and it's not in conditional code.\n      // This primarily targets unscoped qualified names like `a.b.c = function() {}`.\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n           // This means JSDoc exists but didn't explicitly declare a type, enum,\n           // function type, or const with known type. The original code treats\n           // *any* JSDoc on a function assignment as making it 'declared'.\n           // Keep this behavior for now.\n          return false;\n        } else if (scope != null && // Added null check\n                   !scope.isDeclared(qName, false) &&\n                   n != null && n.isUnscopedQualifiedName()) { // Added null check\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               current != null && !(current.isScript() || current.isFunction()); // Added null check\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true; // Inferred in control structure\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred if they escape.\n          Node rootNode = scope.getRootNode();\n          if (rootNode != null) { // Added null check\n              AstFunctionContents contents =\n                  getFunctionAnalysisResults(rootNode);\n              // If the name doesn't escape the current function, treat it as declared.\n              if (contents == null ||\n                  !contents.getEscapedQualifiedNames().contains(qName)) {\n                return false; // Declared\n              }\n              // Otherwise (escaped or analysis failed), it remains inferred (falls through).\n          } else {\n             // Cannot perform analysis, assume inferred\n          }\n        }\n        // If it's not an unscoped qualified name (like a.prototype = function...)\n        // or if it was escaped, or if it was already declared in scope,\n        // we don't change 'inferred' here.\n      }\n\n      // Return the final 'inferred' status.\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}