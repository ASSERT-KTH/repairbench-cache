{
    "generation": "private boolean isQualifiedNameInferred(\n    String qName, Node n, JSDocInfo info, Node rhsValue, JSType valueType) {\n  if (valueType == null) {\n    return true;\n  }\n\n  // If this is an assignment to a property ending in \".prototype\", then\n  // we normally want to treat it as declared only if it\u2019s the prototype of\n  // a constructor (or interface). Otherwise (for example, when the qualifier\n  // is a parameter of type Object) we want to treat the assignment as inferred\n  // so that type mismatch warnings do not occur.\n  if (qName != null && qName.endsWith(\".prototype\")) {\n    if (n != null && n.isGetProp()) {\n      Node left = n.getFirstChild();\n      if (left != null && left.getJSType() != null &&\n          left.getJSType().isFunctionType()) {\n        // The left side is a constructor (or interface), so its prototype\n        // is always declared.\n        return false;\n      }\n    }\n    // If we get here, we are not assigning to a constructor\u2019s prototype.\n    // We do not want to force a declared type here.\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (isConstantSymbol(info, n) && valueType != null && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred && rhsValue != null && rhsValue.isFunction()) {\n    // When a function literal is assigned, normally we make it declared\n    // if it is not in a conditional block or inner (escaped) scope.\n    // However, if we are assigning to a .prototype property on a non-constructor,\n    // we always want the assignment to be inferred.\n    if (qName != null && qName.endsWith(\".prototype\")) {\n      return inferred;\n    }\n    if (info != null) {\n      return false;\n    } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) {\n      // Check if this is in a conditional block.\n      for (Node current = n.getParent();\n           !(current.isScript() || current.isFunction());\n           current = current.getParent()) {\n        if (NodeUtil.isControlStructure(current)) {\n          return true;\n        }\n      }\n      // Check if this is assigned in an inner scope.\n      AstFunctionContents contents = getFunctionAnalysisResults(scope.getRootNode());\n      if (contents == null || !contents.getEscapedQualifiedNames().contains(qName)) {\n        return false;\n      }\n    }\n  }\n\n  return inferred;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}