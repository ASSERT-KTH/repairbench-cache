{
    "generation": "    private boolean isQualifiedNameInferred(\n        String qName, Node n, JSDocInfo info,\n        Node rhsValue, JSType valueType) {\n      if (valueType == null) {\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      // EXCEPTION: If the qualified name is not a top-level static property,\n      // e.g., not X.prototype, but a.prototype in a function, it's still inferred.\n      if (qName != null && qName.endsWith(\".prototype\")) {\n        // If the prototype property is not a static property (i.e. the root of the qName is not a global name)\n        // It's inferred if the left value is not a global or static prototype assignment.\n        // For example, a.prototype = ... where a is a parameter, not a constructor/class.\n        if (n.isGetProp()) {\n          Node target = n.getFirstChild();\n          // If target is not a NAME (i.e. it's a param, like a in function f(a))\n          // treat it as inferred.\n          if (!target.isName()) {\n            return true;\n          }\n        }\n        // Also check cases where prototype is assigned from a parameter or local variable.\n        // If 'a' is a parameter of the current function, treat as inferred\n        // since it's not a class-style prototype.\n        // To do that, walk up the scope to see if 'a' is a param\n        Node target = n.isGetProp() ? n.getFirstChild() : null;\n        if (target != null && target.isName()) {\n          String targetName = target.getString();\n          Node func = NodeUtil.getEnclosingFunction(n);\n          if (func != null) {\n            Node paramList = func.getSecondChild();\n            for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) {\n              if (param.isName() && param.getString().equals(targetName)) {\n                return true;\n              }\n            }\n          }\n        }\n        // Otherwise, treat constructor/interface prototype as declared.\n        return false;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (isConstantSymbol(info, n) && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        if (info != null) {\n          return false;\n        } else if (!scope.isDeclared(qName, false) &&\n            n.isUnscopedQualifiedName()) {\n\n          // Check if this is in a conditional block.\n          // Functions assigned in conditional blocks are inferred.\n          for (Node current = n.getParent();\n               !(current.isScript() || current.isFunction());\n               current = current.getParent()) {\n            if (NodeUtil.isControlStructure(current)) {\n              return true;\n            }\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents contents =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (contents == null ||\n              !contents.getEscapedQualifiedNames().contains(qName)) {\n            return false;\n          }\n        }\n      }\n      return inferred;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}