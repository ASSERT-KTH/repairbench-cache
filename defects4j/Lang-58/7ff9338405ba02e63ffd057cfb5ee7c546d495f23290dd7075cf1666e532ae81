{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\n\n// Assuming StringUtils and other helper methods like createInteger, createLong, createBigInteger,\n// createFloat, createDouble, createBigDecimal, isAllZeros, isDigits are defined/accessible\n// within the context of the original class (e.g., NumberUtils).\n\npublic static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear\n        // to be in specification of class. OS X Java parses it to\n        // a wrong value.\n        // Returning null as per original code's behavior.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        // Handle hexadecimal numbers.\n        // Let's assume createInteger/createLong/createBigInteger can handle hex format.\n        // We try them in increasing order of size.\n        try {\n             // Need to handle potential NumberFormatException if createInteger/Long cannot parse hex\n             // or if the hex value is out of range for Integer/Long.\n             // A more robust way might involve BigInteger directly for hex.\n             // For now, follow the pattern of trying smaller types first.\n             // Let's assume createInteger handles hex (e.g., via Integer.decode).\n             return createInteger(str);\n         } catch (NumberFormatException nfe) {\n             // If createInteger fails (e.g., too large, or doesn't handle hex), try Long.\n             try {\n                 // Assume createLong handles hex (e.g., via Long.decode).\n                 return createLong(str);\n             } catch (NumberFormatException nfe2) {\n                 // If createLong fails, try BigInteger.\n                 // Assume createBigInteger handles hex (e.g., via new BigInteger(str.substring(prefixLen), 16)).\n                 return createBigInteger(str);\n             }\n         }\n    }\n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    // Corrected calculation for exponent position ('e' or 'E')\n    int expPos = str.indexOf('e');\n    if (expPos == -1) {\n        expPos = str.indexOf('E');\n    }\n\n    // Pre-validation for common invalid formats\n    if (decPos > -1 && expPos > -1 && expPos < decPos) {\n        // Exponent 'e'/'E' cannot appear before decimal '.'\n        throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n    // Trailing ., e/E, or sign is invalid\n    if (str.endsWith(\".\") || str.endsWith(\"e\") || str.endsWith(\"E\") ||\n        str.endsWith(\"+\") || str.endsWith(\"-\")) {\n         throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n    // Check for empty exponent part (e.g., \"1e\", \"1e+\", \"1e-\")\n    if (expPos > -1) {\n        String expPart = str.substring(expPos + 1);\n        if (expPart.isEmpty()) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        // Check if exponent part consists of optional sign and digits\n        char firstExpChar = expPart.charAt(0);\n        String expDigits;\n        if (firstExpChar == '+' || firstExpChar == '-') {\n            expDigits = expPart.substring(1);\n        } else {\n            expDigits = expPart;\n        }\n        // Exponent digits must not be empty and must contain only digits\n        if (expDigits.length() == 0 || !StringUtils.isDigits(expDigits)) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    }\n\n\n    if (Character.isLetter(lastChar) && lastChar != 'e' && lastChar != 'E') {\n        // String potentially ends with a type qualifier L, F, D\n        String numeric = str.substring(0, str.length() - 1); // The part before the qualifier\n\n        // Use the numeric part for parsing and checks\n        int numDecPos = numeric.indexOf('.');\n        int numExpPos = numeric.indexOf('e');\n        if (numExpPos == -1) {\n            numExpPos = numeric.indexOf('E');\n        }\n\n        // Extract mantissa and exponent from the numeric part for the allZeros check\n        String numMant, numExp;\n        if (numDecPos > -1) {\n             if (numExpPos > -1) {\n                 numMant = numeric.substring(0, numExpPos); // Mantissa includes decimal for check\n                 numExp = numeric.substring(numExpPos + 1);\n             } else {\n                 numMant = numeric; // Mantissa includes decimal\n                 numExp = null;\n             }\n        } else { // No decimal in numeric part\n             if (numExpPos > -1) {\n                 numMant = numeric.substring(0, numExpPos);\n                 numExp = numeric.substring(numExpPos + 1);\n             } else {\n                 numMant = numeric; // No decimal, no exponent\n                 numExp = null;\n             }\n        }\n        boolean allZeros = isAllZeros(numMant) && isAllZeros(numExp);\n\n        switch (lastChar) {\n            case 'l':\n            case 'L':\n                // Long/BigInteger format requires no decimal point and no exponent in the numeric part.\n                if (numDecPos == -1 && numExpPos == -1) {\n                    // Validate the numeric part as a standard integer (optional sign, digits)\n                    boolean isPotentialInt = numeric.length() > 0;\n                    if (isPotentialInt) {\n                        char firstChar = numeric.charAt(0);\n                        if (firstChar == '-') {\n                            isPotentialInt = numeric.length() > 1 && StringUtils.isDigits(numeric.substring(1));\n                        } else if (firstChar == '+') { // Allow leading '+'\n                            isPotentialInt = numeric.length() > 1 && StringUtils.isDigits(numeric.substring(1));\n                        } else {\n                            isPotentialInt = StringUtils.isDigits(numeric);\n                        }\n                    }\n\n                    if (isPotentialInt) {\n                        try {\n                            // Assume createLong handles optional '+' sign if needed.\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            // Fall through to BigInteger if Long overflows or format invalid for Long but ok for BigInt\n                        }\n                        // Assume createBigInteger handles optional '+' sign if needed.\n                        return createBigInteger(numeric); // Let it throw NFE if format is truly invalid\n                    }\n                }\n                // If format constraints (no dec/exp, valid integer) are not met\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n            case 'f':\n            case 'F':\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    // Check for infinity or zero representations losing precision\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore NFE, try Double\n                }\n                // Fall through\n            case 'd':\n            case 'D':\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    // Corrected check: use d.doubleValue()\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                     // ignore NFE, try BigDecimal\n                }\n                try {\n                    // If Float/Double were not suitable, try BigDecimal for precision.\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // If BigDecimal also fails, the number format is invalid for F/D type.\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n\n            default:\n                // Last character is a letter but not a valid type qualifier (L, F, D) or e/E.\n                throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n    } else {\n        // Last char is not a letter (likely a digit, or caught by earlier checks if invalid like '.')\n        // Treat as number without type qualifier. Use the original string 'str' for parsing.\n\n        // Extract mantissa and exponent from the full string for the allZeros check\n        if (decPos > -1) {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos); // Mantissa includes decimal\n                exp = str.substring(expPos + 1);\n            } else {\n                mant = str; // Mantissa includes decimal\n                exp = null;\n            }\n        } else { // No decimal\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n                exp = str.substring(expPos + 1);\n            } else {\n                mant = str; // No decimal, no exponent\n                exp = null;\n            }\n        }\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n\n        // Determine type based on presence of decimal or exponent in the original string 'str'\n        if (decPos == -1 && expPos == -1) {\n            // No decimal, no exponent -> Must be Integer, Long, or BigInteger\n\n            // Pre-validate format before attempting parsing\n             boolean isPotentialInt = str.length() > 0;\n             if (isPotentialInt) {\n                 char firstChar = str.charAt(0);\n                 if (firstChar == '-') {\n                     isPotentialInt = str.length() > 1 && StringUtils.isDigits(str.substring(1));\n                 } else if (firstChar == '+') {\n                     isPotentialInt = str.length() > 1 && StringUtils.isDigits(str.substring(1));\n                 } else {\n                     isPotentialInt = StringUtils.isDigits(str);\n                 }\n             }\n             if (!isPotentialInt) {\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n             }\n\n            // Try parsing in increasing order of size\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore and try next larger type\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore and try next larger type\n            }\n            return createBigInteger(str); // Let it throw NFE if invalid\n\n        } else {\n            // Has decimal or exponent -> Must be Float, Double, or BigDecimal\n            // Try parsing in increasing order of precision/range\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore and try next larger type\n            }\n            try {\n                Double d = createDouble(str);\n                // Corrected check: use d.doubleValue()\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore and try next larger type\n            }\n            return createBigDecimal(str); // Let it throw NFE if invalid\n        }\n    }\n}\n\n// Dummy helper methods assumed to exist in the actual context (e.g., in NumberUtils class)\n// These would need proper implementation.\nprivate static Integer createInteger(String str) { /* actual implementation needed */ return Integer.decode(str); }\nprivate static Long createLong(String str) { /* actual implementation needed */ return Long.decode(str); }\nprivate static BigInteger createBigInteger(String str) { /* actual implementation needed */\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        int index = str.startsWith(\"-\") ? 3 : 2;\n        return new BigInteger(str.substring(index), 16); // Basic hex handling\n    }\n    return new BigInteger(str);\n}\nprivate static Float createFloat(String str) { /* actual implementation needed */ return Float.valueOf(str); }\nprivate static Double createDouble(String str) { /* actual implementation needed */ return Double.valueOf(str); }\nprivate static BigDecimal createBigDecimal(String str) { /* actual implementation needed */ return new BigDecimal(str); }\n\n// Assume StringUtils.isBlank and StringUtils.isDigits are available and correct.\n\n// Helper method to check if a string represents zero conceptually for float/double precision checks.\n// This needs to align with the original intent. A simple check for non-'0' digits might suffice.\nprivate static boolean isAllZeros(String str) {\n    if (str == null) {\n        return true; // Treat null as effectively zero for this check\n    }\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        // Check for any digit 1-9\n        if (c >= '1' && c <= '9') {\n            return false;\n        }\n    }\n    // Contains only '0', signs, decimal points, 'e', 'E', etc.\n    return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}