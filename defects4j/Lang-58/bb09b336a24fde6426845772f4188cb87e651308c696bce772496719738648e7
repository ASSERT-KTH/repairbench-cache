{
    "generation": "    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>First, the value is examined for a type qualifier on the end\n     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n     * will be interpreted as a hexadecimal integer.  Values with leading\n     * <code>0</code>'s will not be interpreted as octal.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear\n            // to be in specification of class. OS X Java parses it to\n            // a wrong value.\n            return null; // Should this be an error? Code changed below to throw.\n            // throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }\n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        // LANG-342 sensitivity to locales\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1; // Avoid Locale dependent parsing\n\n        // Detect if 'e'/'E' appears before '.' or multiple times\n        if (expPos > -1) {\n            if (expPos > str.length() -1) { // Avoids IndexOutOfBoundsException for \"1e\"\n                 throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            int firstExpPos = str.toLowerCase().indexOf('e');\n            if (firstExpPos != str.toLowerCase().lastIndexOf('e')) { // Check for multiple 'e'/'E'\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            if (decPos > -1 && expPos < decPos) { // Check if 'e' appears before '.'\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n\n        if (decPos > -1) {\n            if (expPos > -1) {\n                // Already checked expPos >= decPos above\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        // Check for invalid trailing characters after determining parts\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                // Check that characters after exponent marker and before type specifier are valid\n                // (optional sign and digits)\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                // If no exponent found, 'exp' should be null when a type specifier exists\n                 exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1); // Part before the type suffix\n            boolean allZeros = isAllZeros(mant) && isAllZeros(dec); // Check mantissa and decimal part for zeros\n            // Note: 'exp' might have its own zeros, but the original allZeros didn't check 'dec' properly\n            // Correcting allZeros check to be more relevant to F/D precision check.\n            if (exp != null) { // Add exponent check to allZeros if exponent exists\n                allZeros = allZeros && isAllZeros(exp);\n            }\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // Long type requested. Must not have decimal or exponent.\n                    // 'numeric' must be a valid integer (optional sign, digits).\n                    if (dec == null && exp == null && numeric != null && !numeric.isEmpty()) {\n                        boolean isNegative = numeric.charAt(0) == '-';\n                        int startIndex = isNegative ? 1 : 0;\n\n                        // Ensure there's at least one digit after the potential sign.\n                        if (startIndex < numeric.length()) {\n                            boolean allDigits = true;\n                            for (int i = startIndex; i < numeric.length(); i++) {\n                                if (!Character.isDigit(numeric.charAt(i))) {\n                                    allDigits = false;\n                                    break;\n                                }\n                            }\n\n                            if (allDigits) {\n                                try {\n                                    return createLong(numeric);\n                                } catch (NumberFormatException nfe) {\n                                    // Input is valid integer format but too big for Long, treat as BigInteger\n                                    return createBigInteger(numeric);\n                                }\n                            }\n                            // If non-digits found after sign, fall through to throw exception\n                        }\n                        // If only a sign ('-'), fall through to throw exception\n                    }\n                    // If format conditions (no dec/exp, valid integer string) are not met, throw exception.\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = createFloat(numeric); // Use 'numeric' which excludes the suffix\n                        // Check for overflow/underflow and precision loss\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            // If Float is finite and represents the number accurately\n                            // (avoid returning 0.0f for non-zero strings like \"0.00000001F\")\n                            return f;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number format and fall through\n                    }\n                    // Fall through intended for cases where Float lacks precision or overflows\n                    // Let Double or BigDecimal handle it. Note: Original code fell through to D case.\n                    // Let's keep that behavior.\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = createDouble(numeric); // Use 'numeric' which excludes the suffix\n                        // Check for overflow/underflow and precision loss\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            // If Double is finite and represents the number accurately\n                           return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                         // ignore the bad number format and fall through\n                    }\n                    try {\n                         // If Float/Double failed or lacked precision, try BigDecimal\n                        return createBigDecimal(numeric); // Use 'numeric' which excludes the suffix\n                    } catch (NumberFormatException e) {\n                        // If BigDecimal also fails (should be rare for valid numeric part), fall through\n                    }\n                    // Fall through to default exception if all attempts fail\n                default :\n                    // If suffix is not l, L, f, F, d, D\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            // Last character is a digit (or '.')\n            // User doesn't have a preference on the return type (no suffix)\n            if (expPos > -1 && expPos < str.length()) {\n                exp = str.substring(expPos + 1); // Exponent runs to the end\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                // Must be an Integer, Long, or BigInteger\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str); // Should succeed if basic format is valid\n\n            } else {\n                 // Must be a Float, Double, or BigDecimal\n                 boolean allZeros = isAllZeros(mant) && isAllZeros(dec); // Check mantissa and decimal part\n                 if (exp != null) { // Add exponent check if exponent exists\n                     allZeros = allZeros && isAllZeros(exp);\n                 }\n\n                 try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                     // ignore the bad number\n                }\n\n                return createBigDecimal(str); // Should succeed if basic format is valid\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}