{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = null; // Declared here for broader scope\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    // According to original code logic, check charset attribute only if http-equiv doesn't specify charset\n                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                        try {\n                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                foundCharset = meta.attr(\"charset\");\n                            }\n                        } catch (IllegalCharsetNameException e) {\n                            // charset is unsupported, leave foundCharset as null\n                            foundCharset = null;\n                        }\n                    }\n                } else if (meta.hasAttr(\"charset\")) { // Only check charset if http-equiv is not present\n                    try {\n                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n                             foundCharset = meta.attr(\"charset\");\n                         }\n                     } catch (IllegalCharsetNameException e) {\n                         // charset is unsupported, leave foundCharset as null\n                         foundCharset = null;\n                     }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset; // Update the charset name\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null; // Set doc to null to trigger re-parse\n                }\n            }\n            // If charsetName is still null, we should use the default charset.\n            // This might be because no meta tag was found, or the found charset was the default one.\n             if (charsetName == null) {\n                 charsetName = defaultCharset;\n             }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            // doc is null here, will be parsed below.\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        // This check needs to happen after decoding potentially happens above.\n        // It might override the detected or supplied charset if a BOM is present.\n        if (docData != null && docData.length() > 0 && docData.charAt(0) == 65279) { // Check for BOM\n            byteData.rewind();\n            // Re-decode using the default charset (UTF-8) as BOM implies UTF-8\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1); // Remove the BOM character\n            charsetName = defaultCharset; // BOM dictates UTF-8\n            doc = null; // *** FIX: Ensure doc is null so that it will be re-parsed with the BOM removed ***\n        }\n        \n        if (doc == null) {\n            // Parse the string document data. This happens if:\n            // 1. Charsetname was specified originally.\n            // 2. Charsetname was null, but a meta tag specified a different charset, requiring re-decode.\n            // 3. A BOM was found, requiring re-decode and removal.\n            doc = parser.parseInput(docData, baseUri);\n            // Set the document charset to the determined one\n            doc.outputSettings().charset(charsetName);\n        } else {\n            // If doc is not null here, it means charsetName was null, we parsed with defaultCharset,\n            // and no different meta charset was found, and no BOM was found.\n            // We still need to set the charset on the document.\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}