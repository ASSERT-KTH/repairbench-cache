{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n// Added surrounding class structure and helper method for context\nclass DataUtil {\n    // Assume defaultCharset and charsetPattern are defined elsewhere in the actual class\n    static final String defaultCharset = \"UTF-8\";\n    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\");\n\n    /**\n     * Extracts the charset name from a meta tag's content attribute. Copied from original context for completeness.\n     * @param contentType e.g. \"text/html;charset=gb2312\"\n     * @return \"gb2312\" or null if not found\n     */\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\"); // Sometimes incorrectly includes charset= part\n             // Prioritize supported canonical name, as browsers do: http://www.w3.org/TR/html5/syntax.html#determining-the-character-encoding\n            if (charset.length() > 0) {\n                try {\n                    // java.nio canonicalises some names incorrectly. Check common ones manually.\n                    if (charset.equalsIgnoreCase(\"gb2312\") || charset.equalsIgnoreCase(\"gbk\")) {\n                        charset = \"gb18030\"; // Use superset\n                    } else if (charset.equalsIgnoreCase(\"shift_jis\")) {\n                        charset = \"windows-31j\"; // \"SJIS is not supported. Use windows-31j instead\". Not entirely correct, but generally better.\n                    }\n                    // return canonical name if supported\n                    if (Charset.isSupported(charset)) return Charset.forName(charset).name();\n                    charset = charset.toUpperCase(); // Try upper case, like http://www.iana.org/assignments/character-sets/character-sets.xhtml\n                    if (Charset.isSupported(charset)) return Charset.forName(charset).name();\n                } catch (IllegalCharsetNameException e) {\n                    // if runtime environment doesn't support it, forget it. Win.\n                }\n            }\n        }\n        return null;\n    }\n\n\n    // todo - this is getting gnarly. needs a rewrite.\n    // Fixed version of parseByteData\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData = null;\n        Document doc = null;\n        String foundCharset = null; // Charset determined by BOM or meta tag\n\n        // *** Determine the charset. Priority: BOM > Specified > Meta tag > Default ***\n\n        // 1. Check for BOM. Takes precedence over everything.\n        byteData.mark();\n        byte[] bom = new byte[3];\n        if (byteData.remaining() >= 3) {\n            byteData.get(bom);\n            if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n                foundCharset = defaultCharset; // UTF-8 BOM found\n                charsetName = defaultCharset; // BOM dictates charset as UTF-8, overrides any specified charset\n                // Position buffer after BOM. Subsequent operations will use data after BOM.\n            } else {\n                byteData.reset(); // Not a UTF-8 BOM, reset position to beginning\n            }\n        } else {\n            byteData.reset(); // Not enough bytes for BOM, reset position\n        }\n\n        if (charsetName == null) { // No charset specified by caller (and no BOM found). Autodetect from meta.\n            // We need to tentatively decode with defaultCharset to find meta tags.\n            byteData.mark(); // Mark position before tentative decode\n            try {\n                docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            } catch (Exception e) {\n                // If initial decode fails, maybe due to wrong charset, we can't search for meta.\n                // Let caller handle exception, or return null/empty doc? For now, rethrow.\n                 throw new RuntimeException(\"Could not decode using default charset \" + defaultCharset, e);\n            }\n\n            // Parse tentatively to find meta tags\n            doc = parser.parseInput(docData, baseUri); // Pass the decoded string\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String metaCharset = null;\n\n            if (meta != null) { // Found a meta tag, try to get charset\n                if (meta.hasAttr(\"http-equiv\")) {\n                    metaCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                    // Per HTML5 spec, if http-equiv is present, charset may be in content, or meta may have charset attr\n                }\n                if (metaCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        metaCharset = meta.attr(\"charset\");\n                        if (Charset.isSupported(metaCharset)) {\n                            // confirmed supported\n                        } else {\n                            // try canonical name\n                            metaCharset = Charset.forName(metaCharset).name();\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        metaCharset = null; // Treat invalid charset attribute as no charset found\n                    }\n                }\n            }\n\n            if (metaCharset != null && metaCharset.length() != 0 && !metaCharset.equals(defaultCharset)) {\n                // Found a non-default charset in meta tag. Re-decode if supported.\n                metaCharset = metaCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                foundCharset = metaCharset; // Record the found charset\n                try {\n                    if (Charset.isSupported(foundCharset)) {\n                        charsetName = foundCharset; // Use the found charset\n                        byteData.reset(); // Rewind to before the tentative decode\n                        docData = Charset.forName(charsetName).decode(byteData).toString(); // Decode again with correct charset\n                        doc = null; // Discard tentative parse, needs re-parsing\n                    } else {\n                        // Found charset in meta, but it's not supported. Stick with default tentative parse.\n                        charsetName = defaultCharset;\n                        // doc is already parsed with defaultCharset\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    // Treat invalid charset name found in meta same as unsupported\n                    charsetName = defaultCharset;\n                    // doc is already parsed with defaultCharset\n                }\n            } else {\n                 // No meta tag found, or meta charset is empty/default/unsupported/invalid. Keep tentative parse.\n                 charsetName = defaultCharset;\n                 // doc is already parsed with defaultCharset\n            }\n        } else { // Charset *was* specified by caller, or BOM was found (overriding caller).\n            // If BOM found, charsetName is now defaultCharset and byteData is positioned after BOM.\n            // If only caller specified, byteData is at start. We need to ensure full buffer is read.\n            if (foundCharset == null) { // True if BOM was NOT found, and charsetName was specified by caller.\n                byteData.rewind(); // Ensure we read the whole buffer from the start.\n            }\n            // Decode using the determined charset (caller spec or BOM-determined UTF-8)\n            // Note: If BOM was found, decode starts *after* the BOM bytes.\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            try {\n                 docData = Charset.forName(charsetName).decode(byteData).toString();\n            } catch (Exception e) {\n                // Handle decode error\n                throw new RuntimeException(\"Could not decode using charset \" + charsetName, e);\n            }\n            doc = null; // Needs parsing\n        }\n\n        // *** Final Parse ***\n        if (doc == null) {\n            // Happens if:\n            // 1. Charset specified by caller (BOM or no BOM).\n            // 2. BOM detected (charsetName initially null).\n            // 3. Meta tag found different, supported charset (charsetName initially null, no BOM).\n\n            // docData should contain the correctly decoded string. If BOM was present, it was handled\n            // either by starting decode after BOM bytes, or by parser handling initial BOM char if caller specified charset.\n            // Jsoup's parser (CharacterReader) consumes BOM character \\uFEFF if present at start of string input.\n            // So we don't need manual stripping like the original buggy code attempted.\n\n            // Ensure docData is not null before parsing\n            if (docData == null) {\n                 // Should not happen in current logic flow, but as fallback:\n                 return Document.createShell(baseUri); // Return empty doc\n            }\n\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the output charset\n        // charsetName should hold the final determined charset (Caller > BOM > Meta > Default)\n        doc.outputSettings().charset(charsetName);\n        return doc;\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}