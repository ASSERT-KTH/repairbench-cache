{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        final String defaultCharset = Parser.DEFAULT_CHARSET; // Assumption: UTF-8\n\n        // ***** Metalista fix starts *****\n        // Maintain position for potential rewind/reset later\n        byteData.mark();\n        // ***** Metalista fix ends *****\n\n\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // 1. Decode tentatively using default charset\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            // 2. Parse tentatively\n            doc = parser.parseInput(docData, baseUri);\n            // 3. Check meta tags\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String foundCharset = null; // Use a separate variable for found charset\n            if (meta != null) {\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                // Look for HTML5 meta charset, prefer it if found\n                if (meta.hasAttr(\"charset\")) {\n                    String charsetAttr = meta.attr(\"charset\");\n                    if (charsetAttr != null && charsetAttr.length() > 0) {\n                         try {\n                             if (Charset.isSupported(charsetAttr)) {\n                                 foundCharset = charsetAttr; // Prefer this if supported\n                             }\n                         } catch (IllegalCharsetNameException e) {\n                             // ignore illegal name\n                         }\n                    }\n                }\n\n                // 4. If a potentially different charset found, clean and validate it\n                if (foundCharset != null && foundCharset.length() != 0) {\n                    // Clean quotes possibly added by Content-Type parser\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                     try {\n                         if (Charset.isSupported(foundCharset)) {\n                             // It's supported. Check if different from default.\n                             if (!foundCharset.equalsIgnoreCase(defaultCharset)) {\n                                 // Different and supported. Need to re-decode.\n                                 charsetName = foundCharset; // Update the effective charset name\n                                 // ***** Metalista fix starts *****\n                                 byteData.reset(); // Rewind to marked position\n                                 // ***** Metalista fix ends *****\n                                 docData = Charset.forName(charsetName).decode(byteData).toString();\n                                 doc = null; // Force re-parse later\n                             } else {\n                                 // Found charset is same as default. Stick with initial parse.\n                                 // Set charsetName to reflect this.\n                                 charsetName = defaultCharset;\n                             }\n                         } else {\n                              // Found charset is not supported. Stick with initial parse.\n                              // Set charsetName to reflect this.\n                              charsetName = defaultCharset;\n                         }\n                     } catch (IllegalCharsetNameException e) {\n                         // Found charset is illegal. Stick with initial parse.\n                         // Set charsetName to reflect this.\n                         charsetName = defaultCharset;\n                     }\n                } else {\n                    // No charset found in meta. Stick with initial parse.\n                    // Set charsetName to reflect this.\n                    charsetName = defaultCharset;\n                }\n            } else {\n                 // No meta tags found. Stick with initial parse.\n                 // Set charsetName to reflect this.\n                 charsetName = defaultCharset;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            // doc remains null, will be parsed later\n        }\n\n        // 5. BOM Check (needs to happen *after* initial decode/meta check)\n        // docData holds the data decoded with either specified, meta-detected, or default charset.\n        if (docData.length() > 0 && docData.charAt(0) == 65279) { // Check for UTF-8 BOM 0xFEFF\n            // ***** Metalista fix starts *****\n            byteData.reset(); // Rewind buffer to start\n            // ***** Metalista fix ends *****\n            docData = Charset.forName(defaultCharset).decode(byteData).toString(); // Re-decode FULLY as UTF-8\n            docData = docData.substring(1); // Strip BOM\n            charsetName = defaultCharset; // BOM overrides any prior charset determination\n            doc = null; // <<< FIX 1: Force re-parse with BOM-stripped UTF-8 data\n        }\n\n        // 6. Final Parse if needed\n        if (doc == null) {\n            // Happens if:\n            // - charsetName was explicitly provided (and no BOM found)\n            // - charsetName was null, meta tag specified a *different* supported charset\n            // - BOM was found (forces doc=null)\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // 7. Set output charset\n        // Ensure charsetName reflects the final used charset (might have been forced to defaultCharset by BOM or if auto-detect found nothing/default)\n        if (charsetName == null) {\n            // If null here, it means specified charset was null, and no meta tags were found or processed successfully.\n            // Should default to UTF-8 as per initial tentative parse.\n             charsetName = defaultCharset;\n        }\n        doc.outputSettings().charset(charsetName); // <<< FIX 2: Always set the output charset based on determined input charset\n\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}