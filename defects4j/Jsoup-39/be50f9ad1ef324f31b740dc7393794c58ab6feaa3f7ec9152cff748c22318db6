{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n// Stub for defaultCharset and getCharsetFromContentType for context\nimport static org.jsoup.helper.DataUtil.defaultCharset;\nimport static org.jsoup.helper.DataUtil.getCharsetFromContentType;\n\n\nclass DataUtilFixed {\n    // Note: Removed the original todo comment as the function is rewritten.\n    // Added stubs for defaultCharset and getCharsetFromContentType for compilation context if run standalone.\n    // In the actual Jsoup codebase, these would refer to the existing members/methods.\n    // static final String defaultCharset = \"UTF-8\"; // Example definition\n    // static String getCharsetFromContentType(String contentType) { return null; } // Example definition\n\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData = null;\n        Document doc = null; // The final document\n        Document tempDoc = null; // Temp document for meta charset detection\n        String finalCharset = null; // Determined charset\n        boolean bomFound = false;\n\n        byteData.mark(); // Mark position before any decoding attempt\n\n        // 1. Check for UTF-8 BOM. Takes precedence over everything. (EF BB BF)\n        if (byteData.remaining() >= 3) {\n            byte[] bomBytes = new byte[3];\n            byteData.get(bomBytes);\n            if (bomBytes[0] == (byte) 0xEF && bomBytes[1] == (byte) 0xBB && bomBytes[2] == (byte) 0xBF) {\n                finalCharset = defaultCharset; // BOM dictates UTF-8\n                bomFound = true;\n                // Buffer position is now correctly after BOM bytes. Continue to decode below.\n            } else {\n                byteData.reset(); // Not a BOM, rewind to marked position for full decode\n            }\n        } else {\n             // Not enough bytes to be a BOM, rewind for full decode\n             byteData.reset();\n        }\n\n        if (bomFound) {\n            // Decode remaining data (after BOM) as UTF-8\n            try {\n                 docData = Charset.forName(finalCharset).decode(byteData).toString();\n            } catch (UnsupportedCharsetException e) {\n                 // Should not happen for defaultCharset (UTF-8)\n                 throw new RuntimeException(e);\n            }\n        } else if (charsetName != null) {\n             // 2. Charset explicitly provided by caller (or HTTP header), no BOM.\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n             try {\n                 docData = Charset.forName(charsetName).decode(byteData).toString();\n                 finalCharset = charsetName;\n             } catch (UnsupportedCharsetException e) {\n                 // Pass this exception up: the specified charset was invalid.\n                 throw e;\n             }\n        } else {\n             // 3. No BOM, no charset provided - attempt to detect from meta tag.\n             try {\n                 // 3a. Decode tentatively using default charset (UTF-8). Reset buffer afterwards for potential re-decode.\n                 final String tentativeDocData = Charset.forName(defaultCharset).decode(byteData).toString();\n                 byteData.reset(); // Reset buffer to marked position for potential re-decode with detected charset\n\n                 // 3b. Parse tentatively to find meta tag. This is expensive, but necessary.\n                 tempDoc = parser.parseInput(tentativeDocData, baseUri);\n\n                 // 3c. Look for <meta> tag with charset info\n                 // todo: HTML5 specifies precedence: BOM > http-equiv > charset attr > default\n                 Element meta = tempDoc.selectFirst(\"meta[http-equiv=content-type], meta[charset]\");\n                 if (meta != null) {\n                     String foundCharset = null;\n                     // Check http-equiv first\n                     if (meta.hasAttr(\"http-equiv\")) {\n                         foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                     }\n                     // If not found, check charset attribute (HTML5)\n                     if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                         try {\n                             if (Charset.isSupported(meta.attr(\"charset\"))) {\n                                 foundCharset = meta.attr(\"charset\");\n                             }\n                         } catch (IllegalCharsetNameException e) {\n                             // Ignore invalid charset names specified in meta\n                             foundCharset = null;\n                         }\n                     }\n\n                     // 3d. If meta tag found a different charset, and it's supported, use it.\n                     if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                         // Clean the found charset name (some sites add quotes etc)\n                         foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                         // Check it's supported (again, after cleaning)\n                         if (Charset.isSupported(foundCharset)) {\n                             finalCharset = foundCharset;\n                             // Meta charset differs from default and is supported, needs re-decode.\n                             // Buffer position was reset earlier. Now decode with the correct charset.\n                             docData = Charset.forName(finalCharset).decode(byteData).toString();\n                             tempDoc = null; // Discard the temp document parsed with default charset\n                         } else {\n                             // Found charset in meta, but it's not supported. Stick with default.\n                             finalCharset = defaultCharset;\n                             docData = tentativeDocData; // Use the data decoded with default charset\n                             // Keep the tempDoc parsed with default charset (though reparsing below is safer)\n                             tempDoc = null; // Safer to reparse docData decoded with defaultCharset\n                         }\n                     } else {\n                          // Meta found but is default, invalid, or missing charset info. Stick with default.\n                          finalCharset = defaultCharset;\n                          docData = tentativeDocData; // Use the data decoded with default charset\n                          // Keep the tempDoc parsed with default charset (though reparsing below is safer)\n                          tempDoc = null; // Safer to reparse docData decoded with defaultCharset\n                     }\n                 } else {\n                      // 3e. No meta tag found. Stick with default charset.\n                      finalCharset = defaultCharset;\n                      docData = tentativeDocData; // Use the data decoded with default charset\n                      // Keep the tempDoc parsed with default charset (though reparsing below is safer)\n                      tempDoc = null; // Safer to reparse docData decoded with defaultCharset\n                 }\n             } catch (UnsupportedCharsetException e) {\n                 // Should not happen with defaultCharset\n                 throw new RuntimeException(e);\n             }\n        }\n\n        // Ensure docData is set (should always be, unless UnsupportedCharsetException)\n        if (docData == null) {\n            // If we get here, there was a problem reading the data. The UnsupportedCharsetException may have been thrown.\n            // Or bomFound was true, but the decode failed? (Shouldn't happen for UTF-8). Let's assume docData exists.\n            // Consider adding a Validate.notNull(docData) here? Or handle error case more explicitly.\n            // For now, proceed assuming docData is valid if no exception was thrown.\n        }\n\n        // 4. Parse the string using the final determined charset ONLY IF we haven't already parsed it correctly\n        //    (which happens if we used the tentatively parsed doc for meta-detection and stuck with default charset)\n        //    It's generally safer and cleaner to *always* re-parse here from the final docData string.\n        //    The performance cost of potentially parsing twice (once for meta, once final) is acceptable.\n        doc = parser.parseInput(docData, baseUri);\n\n\n        // 5. Set the determined charset on the document's output settings.\n        if (finalCharset == null) {\n             // Should have been set by now, but fall back just in case.\n             finalCharset = defaultCharset;\n        }\n        doc.outputSettings().charset(finalCharset);\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}