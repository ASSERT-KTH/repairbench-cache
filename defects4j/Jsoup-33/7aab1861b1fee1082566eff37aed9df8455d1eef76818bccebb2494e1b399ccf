{
    "generation": "    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name(), settings); // Get Tag object, taking into account preservation settings\n\n        if (startTag.isSelfClosing()) {\n            // Known tags that are required to be empty (e.g. <hr>, <br>) or unknown tags (<foo />), are treated as empty elements:\n            if (tag.isEmpty() || tag.isSelfClosing() || !tag.isKnownTag()) { // second check handles tags like <meta>, <base> which are self-closing in spec\n                Element el = insertEmpty(startTag);\n                // We specifically do not add to stack here, and do not emit an end tag token.\n                return el;\n            } else {\n                // Known tags that are not definitionally empty treated as <tag></tag> when specified as self-closing.\n                // E.g. <div />, <script />. Insert the tag, push to stack, and then immediately process an end tag.\n                Element el = new Element(tag, baseUri, startTag.attributes);\n                insert(el); // Insert element, add to parent, push onto stack.\n                tokeniser.transition(TokeniserState.Data); // comments on original emit suggest potential state issues\n                tokeniser.emit(new Token.EndTag(el.tagName()));  // Now emit the close tag, which will be processed immediately\n                return el;\n            }\n        } else {\n            // Standard opening tag.\n            Element el = new Element(tag, baseUri, startTag.attributes);\n            insert(el); // Insert element, add to parent, push onto stack.\n            return el;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}