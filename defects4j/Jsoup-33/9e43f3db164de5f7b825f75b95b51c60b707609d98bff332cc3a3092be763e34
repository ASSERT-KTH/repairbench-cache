{
    "generation": "    Element insert(Token.StartTag startTag) {\n        // This method is primarily called for tags that are NOT spec-defined empty (e.g., img, br, hr)\n        // because those are handled earlier by HtmlTreeBuilder.process(token) directly via insertEmpty.\n\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n        \n        if (startTag.isSelfClosing()) {\n            // This startTag token ends with '/>'.\n            // This applies to: <div/>, <a/>, <script/>, <foo/>\n\n            Element el = new Element(tag, baseUri, startTag.attributes);\n            currentElement().appendChild(el); // Add element as a child of the current element.\n\n            if (!tag.isKnownTag()) { // This is an unknown tag, e.g., <foo/>. It should remain self-closing.\n                // It's already appended as a leaf node. No further stack manipulation is needed.\n                return el;\n            } else { \n                // This is a known tag, but not spec-defined empty (e.g., <div>, <a>, <script>).\n                // In HTML, these are NOT self-closing. A tag like <div/> should be interpreted as <div></div>.\n                // We need to add it to the stack and then immediately pop it to effectively close it.\n                stack.add(el); // Push the element onto the stack.\n                popStackToClose(el); // Immediately pop it off the stack, treating it as self-closed.\n                return el;\n            }\n        }\n        \n        // This path is for tags that are NOT self-closing in the input token,\n        // AND are NOT spec-defined empty tags (e.g., <div>, <a>, <foo>).\n        // These are standard block elements that remain open until their corresponding end tag.\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insert(el); // Normal insertion: adds to current parent and pushes to stack.\n        return el;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}