{
    "generation": "    Element insert(Token.StartTag startTag) {\n        // Use ProcessSettings to know tag types\n        Tag tag = Tag.valueOf(startTag.name(), settings);\n\n        // Handle known empty tags (void elements) properly.\n        if (tag.isEmpty()) {\n            Element el = insertEmpty(startTag); // Creates element, adds to parent, acknowledges flag if self-closing.\n            // Void elements are not pushed onto the stack.\n            return el;\n        }\n\n        // Handle non-empty tags (known non-empty, or unknown).\n        if (startTag.isSelfClosing()) {\n            // Treat self-closing non-empty tags (e.g., <div/>, <foo/>) as start + immediate end.\n            // This replicates the original code's behavior for these cases, which aligns with the test expectation\n            // that <div/> becomes <div></div> and <a/> becomes <a></a>.\n            // It also handles <foo/> becoming <foo></foo> (which serializes to <foo/> if empty).\n            Element el = insertEmpty(startTag); // Creates element, adds to parent via insertNode, acknowledges flag.\n            stack.add(el);                     // Push onto stack (unlike usual insertEmpty behavior).\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // Immediately emit end tag to pop from stack.\n            return el;\n        } else {\n            // Regular start tag that is not self-closing and not a void element.\n            Element el = new Element(tag, baseUri, startTag.attributes);\n            insert(el); // Normal insert - adds to parent and pushes onto stack.\n            return el;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}