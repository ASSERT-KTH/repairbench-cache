{
    "generation": "    Element insert(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name()); // look up tag geochemical information\n\n        if (startTag.isSelfClosing()) {\n            // if known tag allows self closing ACK, or if unknown tag, ACK self closing. Insert as self closing.\n            // Otherwise (known tag that doesn't allow self closing), insert normal tag, emit end tag. See #1006\n            if (tag.isKnownTag() && !tag.isEmpty()) { // ok to ACK self closing tags if they are implicitly empty or intermediate\n                // not implicitly empty, OK to create an end tag\n                Element el = new Element(tag, baseUri, startTag.attributes);\n                insert(el); // normal insert, adds to stack\n                tokeniser.transition(TokeniserState.Data); // ensure we're in Data state, to process the end tag\n                tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n                return el;\n             } else { // unknown tag, or known tag that allows self closing. Acknowledge it.\n                 Element el = insertEmpty(startTag); // creates element, adds to parent. Does not push to stack.\n                 // We ensure the tag is popped correctly by evaluating the token package. If implicitly closed, will be handled fine.\n                 // If it's unknown, will be implicitly closed by the parser. That's fine.\n                 return el;\n             }\n        } else { // standard start tag. insert and push onto stack.\n            Element el = new Element(tag, baseUri, startTag.attributes);\n            insert(el);\n            return el;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}