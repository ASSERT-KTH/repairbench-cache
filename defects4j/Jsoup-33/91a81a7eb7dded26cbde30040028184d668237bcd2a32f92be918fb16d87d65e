{
    "generation": "    Element insert(Token.StartTag startTag) {\n        // Get the Tag object for the start tag's name.\n        // 'settings' is typically a field of the HtmlTreeBuilder class.\n        Tag tag = Tag.valueOf(startTag.name(), settings); \n\n        // Case 1: The tag is a known void element (e.g., <img>, <br>).\n        // These elements are implicitly self-closing and do not have children or explicit end tags.\n        // Regardless of whether the input startTag itself had '/>' (e.g., <img/>) or not (e.g., <img>),\n        // we process it as a void element.\n        if (tag.isSelfClosing()) {\n            // `insertEmpty` creates the element and appends it. It does NOT add it to the stack.\n            return insertEmpty(startTag);\n        }\n\n        // Case 2: The tag is a non-void element (e.g., <div>, <p>, <a>, <script>).\n        // These elements normally require an an opening and a closing tag.\n        // Create the element and insert it normally.\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insert(el); // This calls the HtmlTreeBuilder's insert(Element el) method.\n                    // This method will append the element and push it onto the stack\n                    // because el.tag().isSelfClosing() is false (it's not a void element).\n\n        // If this non-void element was self-closed in the input (e.g., <div />),\n        // we need to immediately generate an end tag to close it, effectively converting <div /> to <div></div>.\n        if (startTag.isSelfClosing()) {\n            tokeniser.emit(new Token.EndTag(el.tagName()));\n        }\n        return el;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}