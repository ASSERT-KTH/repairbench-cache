{
    "generation": "    /**\n     * Get the current solution.\n     * <p>\n     * {@link #solve} should be called first for this to be the optimal solution.\n     * </p>\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n        final int n = getOriginalNumDecisionVariables();\n        final double[] coefficients = new double[n];\n\n        /*\n         * If the decision variables were allowed to go negative, we shifted\n         * them all by the same amount to keep the tableau non\u2010negative.\n         * Find that shift (the most negative basic value) so we can undo it.\n         */\n        double mostNegative = 0;\n        if (!restrictToNonNegative) {\n            final int offset = getNumObjectiveFunctions();\n            final int rhsCol = getRhsOffset();\n            for (int i = 0; i < n; i++) {\n                Integer row = getBasicRow(offset + i);\n                if (row != null) {\n                    double v = getEntry(row, rhsCol);\n                    if (v < mostNegative) {\n                        mostNegative = v;\n                    }\n                }\n            }\n        }\n\n        /*\n         * Now extract each original variable.  If it is basic, take its\n         * RHS value; otherwise it is zero.  Then undo the shift if needed.\n         */\n        final int offset = getNumObjectiveFunctions();\n        final int rhsCol = getRhsOffset();\n        for (int i = 0; i < n; i++) {\n            Integer row = getBasicRow(offset + i);\n            double v = (row == null ? 0.0 : getEntry(row, rhsCol));\n            coefficients[i] = restrictToNonNegative ? v : (v - mostNegative);\n        }\n\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}