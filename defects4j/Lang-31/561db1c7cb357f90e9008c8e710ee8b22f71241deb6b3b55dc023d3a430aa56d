{
    "generation": "import java.util.HashSet;\nimport java.util.Set;\n// Assuming ArrayUtils and isEmpty are accessible from within StringUtils or properly imported\n// org.apache.commons.lang3.ArrayUtils is needed for ArrayUtils.isEmpty\n\n// Dummy imports for compilation if standalone, remove if part of actual StringUtils\n// class StringUtils {\n//     public static boolean isEmpty(CharSequence cs) { return cs == null || cs.length() == 0; }\n// }\n// class ArrayUtils {\n//     public static boolean isEmpty(char[] array) { return array == null || array.length == 0; }\n// }\n\npublic class StringUtils {\n    /**\n     * <p>Checks if the CharSequence contains any character in the given\n     * set of characters.</p>\n     *\n     * <p>A <code>null</code> CharSequence will return <code>false</code>.\n     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n     *\n     * <pre>\n     * StringUtils.containsAny(null, *)                = false\n     * StringUtils.containsAny(\"\", *)                  = false\n     * StringUtils.containsAny(*, null)                = false\n     * StringUtils.containsAny(*, [])                  = false\n     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n     * StringLangs.containsAny(\"aba\", ['z'])           = false\n     * </pre>\n     *\n     * @param cs  the CharSequence to check, may be null\n     * @param searchChars  the chars to search for, may be null\n     * @return the <code>true</code> if any of the chars are found,\n     * <code>false</code> if no match or null input\n     * @since 2.4\n     */\n\tpublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\t\tif (isEmpty(cs) || org.apache.commons.lang3.ArrayUtils.isEmpty(searchChars)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Convert searchChars to a set of code points for efficient lookup.\n\t\t// This correctly handles supplementary characters in searchChars.\n\t\tSet<Integer> searchCodePoints = new HashSet<>();\n\t\tfor (int i = 0; i < searchChars.length; i++) {\n\t\t\tchar ch = searchChars[i];\n\t\t\tif (Character.isHighSurrogate(ch) && i + 1 < searchChars.length && Character.isLowSurrogate(searchChars[i+1])) {\n\t\t\t\t// Found a surrogate pair, add the full code point\n\t\t\t\tsearchCodePoints.add(Character.toCodePoint(ch, searchChars[i+1]));\n\t\t\t\ti++; // Skip the low surrogate as it's already processed\n\t\t\t} else {\n\t\t\t\t// Not a surrogate pair or an unpaired surrogate, treat as a single char/code point\n\t\t\t\tsearchCodePoints.add((int) ch);\n\t\t\t}\n\t\t}\n\n\t\t// Iterate through the CharSequence by code points and check for matches\n\t\tint csLength = cs.length();\n\t\tfor (int i = 0; i < csLength; ) {\n\t\t\tint codePoint = Character.codePointAt(cs, i);\n\t\t\tif (searchCodePoints.contains(codePoint)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ti += Character.charCount(codePoint); // Move to the next code point\n\t\t}\n\n\t\treturn false;\n\t}\n\n    // Assuming isEmpty is defined elsewhere in StringUtils, e.g.:\n    private static boolean isEmpty(CharSequence cs) {\n        return cs == null || cs.length() == 0;\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}