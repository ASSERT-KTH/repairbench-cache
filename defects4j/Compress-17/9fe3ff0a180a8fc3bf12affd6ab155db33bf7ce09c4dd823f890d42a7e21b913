{
    "generation": "    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long result = 0;\n        int end = offset + length;\n\n        if (length < 2) {\n            throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n        }\n\n        int start = offset;\n\n        // Skip leading spaces\n        while (start < end && buffer[start] == ' ') {\n            start++;\n        }\n\n        if (start >= end) {\n            return 0L;\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Determine the actual end, considering trailing space or NUL and an additional one\n        int trailingIndex = end - 1;\n        while (trailingIndex >= start && (buffer[trailingIndex] == 0 || buffer[trailingIndex] == ' ')) {\n            trailingIndex--;\n        }\n        int newEnd = trailingIndex + 1;\n\n        int digits = newEnd - start;\n        if (digits == 0) {\n            return 0L;\n        }\n\n        if (digits > 12) { // Since 2^40 is larger than Long.MAX_VALUE, limit to 12 digits for octal\n            throw new IllegalArgumentException(\"Octal string too long: \" + digits + \" digits\");\n        }\n\n        for (int i = start; i < newEnd; i++) {\n            byte currentByte = buffer[i];\n            if (currentByte < '0' || currentByte > '7') {\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, i, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0');\n        }\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}