{
    "generation": "/**\n * Parse an octal (or base-256) number from a buffer.\n *\n * Leading spaces or NULs are ignored. Trailing spaces or NULs are ignored.\n * If the first byte has its high bit set, the field is treated as\n * a two's-complement big-endian binary number.\n * If the field is entirely NULs, returns 0.\n *\n * @param buffer The buffer from which to parse.\n * @param offset The offset into the buffer from which to parse.\n * @param length The maximum number of bytes to parse - must be at least 2 bytes.\n * @return The long value of the octal or binary string.\n * @throws IllegalArgumentException if an invalid byte is detected.\n */\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    int start = offset;\n    int end = offset + length;\n\n    // Detect base-256 (binary) format: high bit set in first byte\n    if ((buffer[start] & 0x80) != 0) {\n        long val = 0;\n        for (int i = start; i < end; i++) {\n            val = (val << 8) | (buffer[i] & 0xFF);\n        }\n        // sign-extend to 64 bits\n        int bits = (end - start) * 8;\n        val = (val << (64 - bits)) >> (64 - bits);\n        return val;\n    }\n\n    // ASCII octal: skip leading NULs and spaces\n    while (start < end && (buffer[start] == 0 || buffer[start] == ' ')) {\n        start++;\n    }\n    // skip trailing NULs and spaces\n    while (end > start && (buffer[end - 1] == 0 || buffer[end - 1] == ' ')) {\n        end--;\n    }\n\n    long result = 0;\n    for (int i = start; i < end; i++) {\n        byte b = buffer[i];\n        if (b < '0' || b > '7') {\n            throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, i, b));\n        }\n        result = (result << 3) + (b - '0');\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}