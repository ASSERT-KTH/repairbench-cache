{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // Fix for infinite loop when nextLineTabStop is too large CLI-154 / CLI-162 investigation\n        if (nextLineTabStop >= width)\n        {\n            // Prevent padding from being wider than the line\n            nextLineTabStop = width - 1;\n        }\n\n        // Prepare padding for subsequent lines\n        final String padding = createPadding(nextLineTabStop);\n        // Use a variable for the remainder text processing\n        String remainder = text.substring(pos).trim();\n\n        // Loop while there is remaining text\n        while (remainder.length() > 0)\n        {\n            // Pad the remainder for processing for the current line\n            text = padding + remainder; // Reuse text variable for current line processing\n            pos = findWrapPos(text, width, 0); // Find wrap position in the padded text\n\n            if (pos == -1)\n            {\n                // Append the final padded line (trimmed) and exit\n                sb.append(rtrim(text));\n                // Exit the loop and function\n                return sb;\n            }\n\n            // The following condition forced the wrap position to the line width\n            // if the wrap position was calculated to be the last char of padding.\n            // This could cause words to be split incorrectly or unnecessarily.\n            // Removed as part of fix for CLI-162.\n            // if ( (text.length() > width) && (pos == nextLineTabStop - 1) )\n            // {\n            //     pos = width;\n            // }\n\n            // Append the wrapped chunk of the padded line\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n            // Update remainder for the next iteration\n            remainder = text.substring(pos).trim();\n        }\n        // This return statement should be logically unreachable if the loop terminates correctly via returns.\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}