{
    "generation": "    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        // Find the wrap position for the very first line.\n        // This first line is not indented by nextLineTabStop as per typical HelpFormatter behavior.\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1) // If the text fits on a single line\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n\n        // Append the first line segment, trimmed of trailing whitespace, followed by a newline.\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // Ensure nextLineTabStop is valid to prevent infinite loops.\n        if (nextLineTabStop >= width)\n        {\n            nextLineTabStop = width - 1;\n        }\n\n        // Create the padding string for all subsequent lines.\n        final String padding = createPadding(nextLineTabStop);\n\n        // Prepare the remaining text for the first iteration of the loop.\n        // It starts after the break point (pos + 1) and any leading/trailing whitespace is trimmed.\n        text = text.substring(pos + 1).trim(); \n\n        // Loop to process all subsequent lines.\n        while (true)\n        {\n            // For the current iteration, we need to consider the text with its padding.\n            String currentLineCandidate = padding + text;\n            \n            // Find the wrap position within this padded text.\n            pos = findWrapPos(currentLineCandidate, width, 0);\n\n            if (pos == -1) // If the current segment (with padding) fits on one line\n            {\n                sb.append(currentLineCandidate); // Append it and we're done.\n                return sb;\n            }\n            \n            // Special handling for edge cases where the wrap point might be within the padding\n            // or exactly at the start of the actual content after padding.\n            if ( (currentLineCandidate.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width; // Force the wrap at the defined 'width'.\n            }\n\n            // Append the wrapped portion of the current line (including its padding and content),\n            // trimmed of trailing whitespace, followed by a newline.\n            sb.append(rtrim(currentLineCandidate.substring(0, pos))).append(defaultNewLine);\n\n            // Prepare 'text' for the *next* iteration. This 'text' will be the unpadded\n            // remainder of the current line segment, starting after its break point (pos + 1).\n            text = currentLineCandidate.substring(pos + 1).trim(); \n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}