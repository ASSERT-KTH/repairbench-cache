{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line (this is the content width, not total line width).\n     * @param nextLineTabStop The position on the next line for the first tab (this is the indent length).\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        // Create the padding string that will be prepended to all lines generated by this function.\n        // nextLineTabStop is interpreted as the length of this padding.\n        String linePadding = createPadding(nextLineTabStop);\n\n        // Find the wrap position for the *initial* text.\n        // 'text' here is the original input string, so 'width' (content width) applies directly.\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1) // If the entire text fits on one line (considering the content width)\n        {\n            // Append the line padding and the trimmed text.\n            sb.append(linePadding).append(rtrim(text));\n            return sb;\n        }\n\n        // Append the first wrapped line: padding + content + newline.\n        sb.append(linePadding).append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // Adjust nextLineTabStop for subsequent lines if it makes the content width effectively zero or negative.\n        // If nextLineTabStop is adjusted, the linePadding needs to be re-created to reflect the change.\n        if (nextLineTabStop >= width)\n        {\n            // Ensure there is at least one character space after padding for content.\n            nextLineTabStop = width - 1;\n            // Re-create padding as nextLineTabStop might have been adjusted.\n            linePadding = createPadding(nextLineTabStop);\n        }\n\n        while (true)\n        {\n            // For subsequent lines, the 'text' is composed of the padding and the remaining content.\n            // trim() removes leading/trailing whitespace from the substring which might occur if findWrapPos broke at a space.\n            text = linePadding + text.substring(pos).trim();\n\n            // Now, findWrapPos must operate on this 'padded text'.\n            // The effective total width for this padded text is 'width + nextLineTabStop'.\n            // 'width' is the content width, and 'nextLineTabStop' is the padding length.\n            pos = findWrapPos(text, width + nextLineTabStop, 0);\n\n            if (pos == -1) // Remaining text fits on current padded line\n            {\n                sb.append(text); // 'text' already has padding\n                return sb;\n            }\n\n            // Special handling: if findWrapPos returns a position within the padding (or just before content starts),\n            // and the overall line is too long, force the break at the 'total width' boundary.\n            // This prevents lines that are essentially just padding or wrap too early, losing content space.\n            // 'pos == nextLineTabStop - 1' means findWrapPos found a break right at the end of the padding.\n            // 'text.length() > width + nextLineTabStop' means the line content, even with padding, is too long.\n            if ( (text.length() > width + nextLineTabStop) && (pos == nextLineTabStop - 1) )\n            {\n                pos = width + nextLineTabStop; // Force break at the total line width.\n            }\n\n            // Append the current wrapped line.\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}