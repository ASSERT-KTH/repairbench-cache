{
    "generation": "    /**\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     * \n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     */\n    public Fraction reduce() {\n        // Special case: numerator is zero, return the canonical ZERO instance\n        // unless this fraction is already structurally equal to ZERO (0/1).\n        if (numerator == 0) {\n            return equals(Fraction.ZERO) ? this : Fraction.ZERO;\n        }\n\n        int n = numerator;\n        int d = denominator;\n        boolean signChangeNeeded = false; // Flag to track if normalization changed the sign representation\n\n        // Ensure denominator is positive for the canonical reduced form.\n        // If denominator is negative, flip signs of both numerator and denominator.\n        if (d < 0) {\n            // Check for potential overflow before negating.\n            // This matches the overflow check in Fraction.negate().\n            if (n == Integer.MIN_VALUE || d == Integer.MIN_VALUE) {\n                 throw new ArithmeticException(\"overflow: can't negate fraction\");\n            }\n            n = -n;\n            d = -d;\n            signChangeNeeded = true; // Sign normalization occurred, may require a new instance\n        }\n\n        // Calculate the greatest common divisor of the absolute values.\n        // d is guaranteed to be positive here.\n        int gcd = greatestCommonDivisor(Math.abs(n), d);\n\n        // If the gcd is 1 and no sign change was needed for normalization,\n        // the fraction is already in its simplest, normalized form. Return this.\n        if (gcd == 1 && !signChangeNeeded) {\n             return this;\n        }\n        \n        // Otherwise, create and return the new reduced fraction instance.\n        // Use the potentially sign-flipped numerator (n) and the positive denominator (d),\n        // both divided by the gcd.\n        return Fraction.getFraction(n / gcd, d / gcd);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}