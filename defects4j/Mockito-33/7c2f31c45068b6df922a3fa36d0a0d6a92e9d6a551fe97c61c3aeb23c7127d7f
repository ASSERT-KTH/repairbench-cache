{
    "generation": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        \t/* Avoid unnecessary cloning */\n        // Method.equals() is too strict for method matching, especially with generics,\n        // bridge methods, and polymorphism (overriding/implementing).\n        // It checks the declaring class and sometimes the return type, which can differ\n        // for semantically equivalent methods.\n\n        // A method is considered \"the same\" if:\n        // 1. Their names are identical.\n        // 2. Their parameter types are identical.\n        // 3. Their declaring classes are either the same, or one is assignable from the other\n        //    (e.g., an interface or superclass method being implemented/overridden).\n        // This approach handles bridge methods and covariant return types implicitly,\n        // as it focuses on the method's signature (name and parameter types)\n        // and class hierarchy, rather than strict Method object equality.\n        return m1.getName().equals(m2.getName())\n                && java.util.Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes())\n                && (m1.getDeclaringClass().equals(m2.getDeclaringClass())\n                    || m1.getDeclaringClass().isAssignableFrom(m2.getDeclaringClass())\n                    || m2.getDeclaringClass().isAssignableFrom(m1.getDeclaringClass()));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}