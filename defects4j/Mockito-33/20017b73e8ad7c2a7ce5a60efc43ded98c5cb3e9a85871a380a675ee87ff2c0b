{
    "generation": "    public boolean hasSameMethod(Invocation candidate) {        \n        // not using method.equals() for 1 good reason:\n        // sometimes java generates forwarding methods (bridge methods) when generics are in play\n        // or when dealing with covariant return types or methods implemented from interfaces/abstract classes.\n        // The standard Method.equals() is too strict for matching logical methods in these scenarios.\n        \n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        // 1. If methods are strictly equal, they are the same.\n        if (m1.equals(m2)) {\n            return true;\n        }\n\n        // 2. Check if method names are different. If so, they cannot be the same logical method.\n        if (!m1.getName().equals(m2.getName())) {\n            return false;\n        }\n\n        // 3. Check if parameter types are different. If so, they cannot be the same logical method.\n        Class<?>[] params1 = m1.getParameterTypes();\n        Class<?>[] params2 = m2.getParameterTypes();\n        if (!java.util.Arrays.equals(params1, params2)) {\n            return false;\n        }\n\n        // At this point, method names and parameter types are identical.\n        // Method.equals() returned false, implying either the declaring class or return type differs.\n\n        // 4. Handle bridge methods:\n        //    If one method is a bridge method and they share the same signature (name + parameter types),\n        //    they often represent the same logical method. This is common with generics.\n        if (m1.isBridge() || m2.isBridge()) {\n            return true;\n        }\n\n        // 5. Handle covariant return types or methods overridden/implemented across class hierarchies:\n        //    If neither is a bridge method, but their declaring classes are related by inheritance/implementation,\n        //    and their return types are compatible (e.g., one is a subtype of the other),\n        //    they are considered the same logical method.\n        Class<?> dc1 = m1.getDeclaringClass();\n        Class<?> dc2 = m2.getDeclaringClass();\n\n        if (dc1.isAssignableFrom(dc2) || dc2.isAssignableFrom(dc1)) {\n            // If declaring classes are related, check return type compatibility.\n            // For example, if A.getFoo() returns Foo and B.getFoo() returns Bar (where Bar extends Foo),\n            // then Foo.isAssignableFrom(Bar) is true.\n            if (m1.getReturnType().isAssignableFrom(m2.getReturnType()) ||\n                m2.getReturnType().isAssignableFrom(m1.getReturnType())) {\n                return true;\n            }\n        }\n\n        // If none of the above conditions met, they are not considered the same logical method\n        // for the purpose of stubbing or verification.\n        return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}