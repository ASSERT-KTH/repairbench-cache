{
    "generation": "public boolean hasSameMethod(Invocation candidate) {        \n    //not using method.equals() for 1 good reason:\n    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n\n    // Bridge methods are generated at bytecode level to implement generic interfaces.\n    // For example, List<T> implements Iterable<T> and at bytecode level, List will have 2 methods:\n    //   Iterator<T> iterator() // defined at List interface\n    //   Iterator iterator() // defined at Iterable interface, which is a bridge method to the above method\n    // Bridge methods are 'equal' to the method they are 'bridging' to.\n    if (m1.isBridge() != m2.isBridge()) {\n        // If one is bridge and the other is not, replace the bridge method with the bridged one.\n        // This is so that the comparison of methods is done on the actual method being bridged to.\n        if (m1.isBridge()) {\n            m1 = findBridgedMethod(m1);\n        } else {\n            m2 = findBridgedMethod(m2);\n        }\n    }\n\n    /* Avoid unnecessary cloning */\n    return m1.equals(m2);\n}\n\n// Helper method to find the bridged method\nprivate Method findBridgedMethod(Method bridgeMethod) {\n    // Get all methods of the declaring class\n    Method[] methods = bridgeMethod.getDeclaringClass().getDeclaredMethods();\n    for (Method method : methods) {\n        if (bridgeMethod != method && !method.isBridge() && bridgeMethod.getName().equals(method.getName())\n                && Arrays.equals(bridgeMethod.getParameterTypes(), method.getParameterTypes())) {\n            return method;\n        }\n    }\n    return bridgeMethod; // Return the original method if no bridged method is found\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}