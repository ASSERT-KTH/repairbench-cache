{
    "generation": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        /* Avoid unnecessary cloning */\n        // The original comment correctly points out that Method.equals() is too strict for\n        // scenarios involving generics, bridge methods, or polymorphic calls (overriding/implementing methods).\n        // Method.equals() requires the declaring class to be the same, which is not always desired\n        // when comparing an invoked method (e.g., from a subclass) to a stubbed/verified method\n        // (e.g., from an interface or superclass).\n\n        // If the methods are strictly equal, they definitely match.\n        if (m1.equals(m2)) {\n            return true;\n        }\n\n        // Otherwise, perform a more lenient comparison suitable for mockito.\n        // 1. Method names must be identical.\n        if (!m1.getName().equals(m2.getName())) {\n            return false;\n        }\n\n        // 2. Parameter types (raw types) must be identical and in the same order.\n        Class<?>[] params1 = m1.getParameterTypes();\n        Class<?>[] params2 = m2.getParameterTypes();\n        if (params1.length != params2.length) {\n            return false;\n        }\n        for (int i = 0; i < params1.length; i++) {\n            if (!params1[i].equals(params2[i])) {\n                return false;\n            }\n        }\n        \n        // At this point, method names and raw parameter types match.\n        // The only remaining difference for Method.equals() to return false is the declaring class.\n        // We consider them the \"same method\" if one method is an override/implementation of the other,\n        // which means one's declaring class is assignable from the other's.\n        // This handles cases like:\n        // - Invocation on `MyList.iterator()` matching a stub/verify on `Iterable.iterator()`.\n        // - Bridge methods generated by the JVM for covariant return types or generic type erasure.\n        return m1.getDeclaringClass().isAssignableFrom(m2.getDeclaringClass())\n               || m2.getDeclaringClass().isAssignableFrom(m1.getDeclaringClass());\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}