{
    "generation": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        // The original code was using m1.equals(m2) which is insufficient for generic and polymorphic calls.\n        // Method.equals() requires the same declaring class, which is not always true for\n        // logically equivalent methods in an inheritance hierarchy or involving bridge methods.\n        \n        // First, check for exact method equality (same declaring class, name, and parameter types)\n        if (m1.equals(m2)) {\n            return true;\n        }\n\n        // If not an exact match, check if one method overrides the other.\n        // This covers cases where methods have the same signature (name and parameter types)\n        // but different declaring classes in an inheritance hierarchy, or when bridge methods\n        // are involved due to type erasure in generics.\n        // MethodUtil.isOverridden checks if the first method argument overrides the second.\n        // We check in both directions (m1 overrides m2, or m2 overrides m1) to cover all scenarios\n        // where two logically same methods might be represented by different Method objects\n        // due to polymorphism or generics (e.g., when casting an object to an interface type).\n        return org.mockito.internal.util.reflection.MethodUtil.isOverridden(m1, m2) \n            || org.mockito.internal.util.reflection.MethodUtil.isOverridden(m2, m1);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}