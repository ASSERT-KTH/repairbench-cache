{
    "generation": "import java.lang.reflect.Method;\nimport java.util.Arrays;\nimport org.mockito.invocation.Invocation; // Assuming Invocation comes from here or a similar package\n\n// Assume this method is part of a class that has access to an 'invocation' field/variable of type Invocation.\n// For example:\n// class SomeMatcher {\n//     private final Invocation invocation;\n//     public SomeMatcher(Invocation invocation) { this.invocation = invocation; }\n//     ...\n// }\n\n    public boolean hasSameMethod(Invocation candidate) {\n        // not using method.equals() for 1 good reason:\n        // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        // The original code below contradicts this comment and was the source of the bug.\n        // return m1.equals(m2); // Original buggy line\n\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n\n        // Shortcut for identical Method objects\n        if (m1 == m2) {\n            return true;\n        }\n\n        // Standard equality check (based on declaring class, name, parameter types)\n        if (m1.equals(m2)) {\n            return true;\n        }\n\n        // Handle bridge methods / generic forwarding:\n        // Check if methods have the same name and same erased parameter types.\n        // Method.getParameterTypes() returns erased types, which is suitable for comparison\n        // across potential bridge methods generated due to type erasure.\n        if (!m1.getName().equals(m2.getName())\n                || !Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes())) {\n            // If names or erased parameter types differ, they cannot be the same method\n            // in the context of bridge methods/overrides.\n            return false;\n        }\n\n        // If names and erased params match, but m1.equals(m2) is false,\n        // it might be due to bridge methods or methods declared in different\n        // classes within an inheritance hierarchy (e.g., interface method vs implementation method).\n        // Check if the declaring classes are related (one assignable from the other).\n        // This considers one method potentially overriding the other, possibly via a bridge method.\n        Class<?> declaringClass1 = m1.getDeclaringClass();\n        Class<?> declaringClass2 = m2.getDeclaringClass();\n\n        return declaringClass1.isAssignableFrom(declaringClass2)\n                || declaringClass2.isAssignableFrom(declaringClass1);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}