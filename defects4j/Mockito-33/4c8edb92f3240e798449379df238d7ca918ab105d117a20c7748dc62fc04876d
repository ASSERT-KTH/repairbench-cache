{
    "generation": "public boolean hasSameMethod(Invocation candidate) {        \n    // not using method.equals() for 1 good reason:\n    // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n\n    if (m1.equals(m2)) {\n        return true;\n    }\n\n    // Match on declaring class compatibility, name, and parameter types\n    if (m1.getName().equals(m2.getName())) {\n        Class<?>[] params1 = m1.getParameterTypes();\n        Class<?>[] params2 = m2.getParameterTypes();\n\n        if (params1.length == params2.length) {\n            boolean paramsMatch = true;\n            for (int i = 0; i < params1.length; i++) {\n                if (!params1[i].equals(params2[i])) {\n                    paramsMatch = false;\n                    break;\n                }\n            }\n            if (paramsMatch) {\n                // Allow forwarders: if one is a bridge and the other is not, but they otherwise match\n                if (m1.isBridge() || m2.isBridge()) {\n                    return true;\n                }\n                // Also match if one is a method override of the other\n                if (m1.getDeclaringClass().isAssignableFrom(m2.getDeclaringClass())\n                        || m2.getDeclaringClass().isAssignableFrom(m1.getDeclaringClass())) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}