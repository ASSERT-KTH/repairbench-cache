{
    "generation": "    public boolean hasSameMethod(Invocation candidate) {\n        // not using method.equals() for 1 good reason:\n        // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n\n        // Bridge methods have the same name and parameter count but may differ\n        // in parameter types (due to erasure), return type signature, or declaring class\n        // compared to the method being bridged.\n        // Method.equals() is too strict and returns false for bridge/bridged pairs\n        // because it checks for exact parameter types and declaring class.\n        // Comparing by name and parameter count is a reliable way to identify\n        // the \"same\" method semantically in the context of mocking generic methods,\n        // especially across inheritance hierarchies with generics.\n        if (!m1.getName().equals(m2.getName())) {\n            return false;\n        }\n\n        // Check parameter count equality\n        if (m1.getParameterTypes().length != m2.getParameterTypes().length) {\n            return false;\n        }\n\n        // If name and parameter count match, consider the methods equivalent\n        // for the purpose of matching invocations, accommodating bridge methods.\n        // A more sophisticated check could involve comparing parameter types more deeply\n        // (e.g., after type erasure or checking assignability), but comparing\n        // name and count handles the common bridge method cases correctly.\n        return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}