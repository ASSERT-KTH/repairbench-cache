{
    "generation": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (!right.isNumber()) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    // The original loop incorrectly iterated up to intIndex - 1, and also assigned\n    // 'elem' in a way that would pick the *previous* element if the loop continued.\n    // This caused issues especially for index 0 and for correctly finding the Nth element.\n\n    Node current = left.getFirstChild();\n    Node elemToReplace = null; // This will hold the node found at the target index within the array literal\n    Node actualValueNode = null; // This will be the node that ultimately replaces the GETELEM expression\n\n    // Iterate through the children of the array literal to find the node at `intIndex`.\n    // The `Node` structure for array literals includes `EMPTY` nodes for holes (e.g., `[,]` has an `EMPTY` child).\n    for (int i = 0; i <= intIndex; i++) {\n        if (current == null) {\n            // We have iterated past all explicit children of the array literal\n            // before reaching the target index. This means the index is out of bounds.\n            error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n            return n;\n        }\n\n        if (i == intIndex) {\n            // Found the node corresponding to the target index.\n            elemToReplace = current;\n            break; // Exit the loop, as we found our target\n        }\n\n        current = current.getNext(); // Move to the next child\n    }\n\n    // At this point, `elemToReplace` should contain the node at `intIndex`.\n    // The `current == null` check inside the loop should have already handled\n    // cases where the index is out of bounds, so `elemToReplace` should not be null here.\n    // This check serves as a safeguard.\n    if (elemToReplace == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    // If the element found is an EMPTY node (e.g., for `[,10][0]`),\n    // replace it with an explicit `undefined` node (`void 0`).\n    if (elemToReplace.isEmpty()) {\n      actualValueNode = NodeUtil.newUndefinedNode(elemToReplace);\n    } else {\n      // If it's a non-empty node, remove it from the array literal.\n      // This is crucial for correctness, especially if the node has side-effects\n      // (e.g., `x = [0, foo()][1]`) or its parent chain needs to be consistent\n      // after it's moved out of the array literal.\n      left.removeChild(elemToReplace);\n      actualValueNode = elemToReplace;\n    }\n\n    // Replace the entire GETELEM node (`n`) with the `actualValueNode`.\n    n.getParent().replaceChild(n, actualValueNode);\n    reportCodeChange();\n    return actualValueNode;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}