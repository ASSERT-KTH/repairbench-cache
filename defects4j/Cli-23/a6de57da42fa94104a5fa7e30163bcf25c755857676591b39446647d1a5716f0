{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text)); // Apply rtrim to the whole text if it fits\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            int lastPos = pos; // Stores the wrap position from the previous iteration\n            \n            // Prepare the text for the current line:\n            // - text.substring(pos) gets the remaining text after the previous wrap point.\n            // - .trim() removes any leading/trailing whitespace from this remaining part.\n            // - padding + ... prepends the necessary indentation for the new line.\n            text = padding + text.substring(pos).trim();\n            \n            // Find the wrap position for the current line within the specified width\n            pos = findWrapPos(text, width, 0);\n\n            // CLI-162 fix: If findWrapPos returns 0 (meaning no natural break point found)\n            // and the 'text' is still longer than 'width', we must force a hard wrap\n            // at 'width' characters. This prevents an infinite loop where 'pos' remains 0\n            // and no progress is made because a single \"word\" or un-wrappable sequence\n            // (possibly including padding) is too long for the line.\n            if (pos == 0 && text.length() > width)\n            {\n                pos = width; // Force a hard wrap to ensure progress\n            }\n\n            if (pos == -1) // If the remaining 'text' (with padding) fits entirely on the current line\n            {\n                sb.append(rtrim(text)); // Append the whole remaining text, applying rtrim\n                return sb; // Exit the loop\n            } \n            // This condition catches any other scenarios where no progress is being made.\n            // 'pos == lastPos' indicates that findWrapPos is returning the same value\n            // (either 0 or some other fixed position) for effectively the same remaining string.\n            // If the code reaches this point, it means the earlier 'pos=width' fix didn't resolve it,\n            // or it's a different kind of stuck situation.\n            // To prevent an infinite loop or a RuntimeException, append the remaining text and exit.\n            else if (pos == lastPos)\n            {\n                // Append the current 'text' (which is the un-wrappable remainder, potentially with padding)\n                // and then return. Only append if there's actual content.\n                if (text.length() > 0) {\n                    sb.append(rtrim(text)); // Apply rtrim to the remaining text\n                }\n                return sb; // Exit the loop to avoid hanging\n            }\n\n            // If a valid wrap position 'pos' was found (and not stuck),\n            // append the wrapped segment and a new line.\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}