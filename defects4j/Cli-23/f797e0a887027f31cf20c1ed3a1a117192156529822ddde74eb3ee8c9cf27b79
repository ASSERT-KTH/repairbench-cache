{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int start = 0;\n        final int length = text.length();\n\n        // Find the wrap pos for the first line (no padding)\n        int pos = findWrapPos(text, width, start);\n\n        if (pos == -1)\n        {\n            // Text fits on one line or is shorter than width\n            sb.append(rtrim(text));\n            return sb;\n        }\n\n        // Append the first line\n        sb.append(rtrim(text.substring(start, pos))).append(defaultNewLine);\n        // The next line should begin after the position returned by findWrapPos.\n        start = pos; \n\n        // Padding for subsequent lines\n        final String padding = createPadding(nextLineTabStop);\n\n        while (start < length)\n        {\n            // Trim leading whitespace from the start of the remaining text.\n            // This mimics the original `text.substring(pos).trim()` behavior for subsequent lines.\n            while (start < length && text.charAt(start) == ' ') {\n                start++;\n            }\n            // If only whitespace was left\n            if (start >= length) {\n                break;\n            }\n\n            // Construct the potentially padded line for measurement\n            String lineToMeasure = padding + text.substring(start);\n\n            // Find the wrap position within this potentially padded line,\n            // searching from the beginning of this constructed line.\n            pos = findWrapPos(lineToMeasure, width, 0);\n\n            if (pos == -1)\n            {\n                // The rest of the text fits on one line (with padding)\n                sb.append(rtrim(lineToMeasure));\n                start = length; // Consider all text processed\n                break;\n            }\n\n            // Calculate the number of actual text characters from the original string ('text')\n            // that are included up to the wrap position 'pos' in 'lineToMeasure'.\n            // This is the amount by which 'start' should advance in the original string.\n            int delta = pos - padding.length();\n\n            // If the calculated wrap position 'pos' is within the padding portion of \n            // 'lineToMeasure', or if it implies that no characters from the original\n            // text 'text' would be consumed (delta <= 0). This can happen if:\n            // a) width <= nextLineTabStop (padding length)\n            // b) findWrapPos calculation results in a break within the padding\n            // In such cases, continuing the loop normally would likely lead to an\n            // infinite loop because 'start' would not advance.\n            if (delta <= 0)\n            {\n                 // To prevent an infinite loop, we stop wrapping and append the \n                 // remainder of the original text (prefixed by the required padding)\n                 // onto a new line. This might result in a line longer than 'width', \n                 // but it avoids the crash/loop.\n                 // Append the padded remaining text. Need rtrim() in case original text had trailing spaces.\n                 sb.append(padding).append(rtrim(text.substring(start))); \n                 start = length; // Mark all text as processed\n                 break; // Exit the loop\n            }\n\n            // We have a valid wrap point 'pos' in 'lineToMeasure'.\n            // Append the wrapped part of the line (substring from lineToMeasure).\n            sb.append(rtrim(lineToMeasure.substring(0, pos))).append(defaultNewLine);\n\n            // Advance the start position in the original text by the number of \n            // characters ('delta') that were consumed from it for this wrapped line.\n            start += delta;\n        }\n\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}