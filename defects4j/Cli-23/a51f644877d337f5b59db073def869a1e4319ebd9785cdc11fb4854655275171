{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        // First line: no padding\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1) // text fits on one line without wrapping\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        // 'text' now holds the remaining content from the first line, trimmed of leading/trailing spaces\n        text = text.substring(pos).trim();\n\n        // Keep track of the length of 'text' to detect infinite loops\n        // This 'text' represents the *actual content* that needs to be wrapped, without padding.\n        int lastTextLength = text.length();\n\n        while (true)\n        {\n            if (text.isEmpty())\n            {\n                return sb;\n            }\n\n            // Calculate the effective width available for the actual content\n            // after accounting for the padding.\n            int effectiveWidth = width - padding.length();\n            \n            // If the effective width is zero or negative, it means the padding\n            // alone consumes all available line width or more. In this case,\n            // we cannot wrap the actual content meaningfully.\n            // We append the padding, then truncate the remaining text to fit\n            // the remaining (possibly zero) space, and then terminate.\n            if (effectiveWidth <= 0) {\n                sb.append(padding); // Append the full padding\n                // Calculate the actual content length to append, ensuring it's not negative\n                int contentToAppendLength = Math.max(0, width - padding.length());\n                if (text.length() > contentToAppendLength) {\n                    sb.append(text.substring(0, contentToAppendLength));\n                } else {\n                    sb.append(text);\n                }\n                // No further wrapping possible for this text segment\n                return sb; \n            }\n            \n            // Find wrap position within the *remaining content* (text), using the effective width.\n            // 'pos' is now relative to the 'text' variable (the actual content).\n            pos = findWrapPos(text, effectiveWidth, 0);\n\n            if (pos == -1) // Remaining 'text' fits on one padded line\n            {\n                sb.append(padding).append(text); // Append padding + full text\n                return sb;\n            }\n            \n            // Append the padded and wrapped line segment\n            sb.append(padding).append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n            \n            // Update 'text' for the next iteration: the remaining content after this wrap.\n            text = text.substring(pos).trim();\n\n            // Check for progress: if the length of the actual remaining content\n            // is not strictly decreasing, it indicates an unresolvable wrap problem\n            // (e.g., a single word longer than effectiveWidth) which would lead to an infinite loop.\n            // As per original logic (and CLI-162's implicit intent), throw an exception.\n            if (text.length() >= lastTextLength) {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n            }\n            lastTextLength = text.length();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}