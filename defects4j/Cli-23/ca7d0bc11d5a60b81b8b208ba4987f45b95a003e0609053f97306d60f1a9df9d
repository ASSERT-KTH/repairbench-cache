{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        if (text == null || text.isEmpty()) {\n            return sb;\n        }\n\n        int pos = findNextWrapPos(text, width, 0, nextLineTabStop);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space\n        // characters\n        final String padding = createPadding(nextLineTabStop);\n        String remainingText = text.substring(pos).trim();\n\n        while (!remainingText.isEmpty())\n        {\n            if (padding.length() + remainingText.length() <= width) {\n                sb.append(padding).append(remainingText);\n                break;\n            }\n\n            pos = findNextWrapPos(padding + remainingText, width, 0, nextLineTabStop);\n            if (pos == -1) {\n                sb.append(padding).append(remainingText);\n                break;\n            }\n\n            // Adjust position to remove padding length (since we're adding it back)\n            int relativePos = pos - padding.length();\n            if (relativePos <= 0) {\n                // If we can't even fit the padding + first word, force a break\n                relativePos = findFirstSpace(remainingText);\n                if (relativePos == -1) {\n                    // No spaces found, force a break at width minus padding\n                    relativePos = width - padding.length();\n                    if (relativePos <= 0) {\n                        relativePos = 1; // Minimum break position\n                    }\n                }\n            }\n\n            pos = padding.length() + relativePos;\n\n            // Ensure we don't get stuck in an infinite loop\n            if (pos <= padding.length()) {\n                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + remainingText);\n            }\n\n            String lineToAdd = padding + rtrim(remainingText.substring(0, relativePos));\n            sb.append(lineToAdd).append(defaultNewLine);\n            remainingText = remainingText.substring(relativePos).trim();\n        }\n\n        return sb;\n    }\n\n    // Helper method to find wrap position with improved logic\n    private int findNextWrapPos(String text, int width, int startPos, int nextLineTabStop) {\n        if (startPos >= text.length()) {\n            return -1;\n        }\n\n        int lastSpace = -1;\n        int pos = startPos;\n        int maxPos = Math.min(startPos + width, text.length());\n\n        // Handle case where the padding itself might be longer than width\n        int effectiveWidth = width - nextLineTabStop;\n        if (effectiveWidth <= 0) {\n            effectiveWidth = width; // best effort if padding is too large\n        }\n\n        // If this is a continuation line with padding, we need to account for it\n        boolean hasPadding = text.startsWith(createPadding(nextLineTabStop));\n        int adjustedWidth = hasPadding ? width : effectiveWidth;\n\n        int currentLineStart = hasPadding ? nextLineTabStop : 0;\n\n        // Find the best wrap position within our adjusted width\n        while (pos < maxPos) {\n            char c = text.charAt(pos);\n            if (Character.isWhitespace(c)) {\n                lastSpace = pos;\n            }\n            pos++;\n        }\n\n        // If we found a space within our target width, use it\n        if (lastSpace != -1 && lastSpace < maxPos) {\n            return lastSpace + 1; // +1 to include the space in the previous line\n        }\n\n        // If we didn't find a space within width, try to find one soon after\n        if (lastSpace == -1 && maxPos < text.length()) {\n            // Look for the next space after our max position\n            while (pos < text.length()) {\n                char c = text.charAt(pos);\n                if (Character.isWhitespace(c)) {\n                    return pos + 1;\n                }\n                pos++;\n\n                // Don't search too far beyond our width limit\n                if (pos > maxPos + 20) {\n                    break;\n                }\n            }\n        }\n\n        // If no space found at all, return the max position (force a break)\n        if (maxPos < text.length()) {\n            return maxPos;\n        }\n\n        return -1;\n    }\n\n    // Helper method to find first space\n    private int findFirstSpace(String text) {\n        for (int i = 0; i < text.length(); i++) {\n            if (Character.isWhitespace(text.charAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}