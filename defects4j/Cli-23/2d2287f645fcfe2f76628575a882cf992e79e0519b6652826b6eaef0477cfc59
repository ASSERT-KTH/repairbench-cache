{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     * <p>\n     * This method handles wrapping of the text across lines, respecting\n     * the specified width and indenting subsequent lines by the\n     * specified tab stop.\n     * </p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters available for the text per line.\n     * @param nextLineTabStop The position on the next line for the first character\n     *                        after the padding (indention).\n     * @param text The text to be rendered. Must not be {@code null}.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        // Handle the first line (no padding)\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            // Text fits on one line\n            sb.append(rtrim(text));\n            return sb;\n        }\n\n        // Append the first line\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // The remainder of the text for subsequent lines, trimmed\n        String remainder = text.substring(pos).trim();\n\n        // Create padding string for subsequent lines\n        // Guard against negative or zero nextLineTabStop values\n        final String padding = (nextLineTabStop <= 0) ? \"\" : createPadding(nextLineTabStop);\n\n\n        // Loop while there's text remaining to be wrapped\n        while (remainder.length() > 0)\n        {\n            // Prefix the remaining text with padding\n            String paddedRemainder = padding + remainder;\n\n            // Find the wrap position in the padded line.\n            // Important: The search for wrap position starts *after* the padding,\n            // ensuring that we wrap the actual content, not the padding itself.\n            // This prevents infinite loops if a long word follows the padding.\n            pos = findWrapPos(paddedRemainder, width, padding.length());\n\n            if (pos == -1)\n            {\n                // The remaining text fits on the current line (with padding).\n                sb.append(paddedRemainder);\n                // No more remainder, exit the loop\n                break; \n            }\n            else\n            {\n                // Append the part of the padded line that fits.\n                sb.append(rtrim(paddedRemainder.substring(0, pos))).append(defaultNewLine);\n                // Update the remainder for the next iteration, trimming leading space.\n                remainder = paddedRemainder.substring(pos).trim();\n            }\n        }\n        // All text has been appended.\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}