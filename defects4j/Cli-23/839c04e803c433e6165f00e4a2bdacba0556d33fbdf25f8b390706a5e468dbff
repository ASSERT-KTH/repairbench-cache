{
    "generation": "    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                             int nextLineTabStop, String text)\n    {\n        int currentPos = 0; // Position in the original text\n        final int textLength = text.length();\n\n        // Handle first line (no padding)\n        int pos = findWrapPos(text, width, currentPos);\n\n        if (pos == -1) // Text fits on one line or is empty\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n\n        // Append the first line\n        sb.append(rtrim(text.substring(currentPos, pos))).append(defaultNewLine);\n        currentPos = pos; // Advance position in original text\n\n        // Prepare padding for subsequent lines\n        // Ensure padding is not longer than width, cause problems otherwise\n        final String padding = createPadding(Math.min(nextLineTabStop, width));\n\n\n        while (currentPos < textLength) // Loop while there's text remaining\n        {\n             // Skip leading whitespace in the remaining text before adding padding\n            while (currentPos < textLength && Character.isWhitespace(text.charAt(currentPos))) {\n                currentPos++;\n            }\n            // Check if we reached the end after skipping whitespace\n            if (currentPos >= textLength) {\n                break; // No more actual text\n            }\n\n            // Construct the text potentially wrapping for this line, including padding\n            String lineToWrap = padding + text.substring(currentPos);\n\n            // Find wrap position in this padded line\n            pos = findWrapPos(lineToWrap, width, 0);\n\n            if (pos == -1) // Rest fits on the line\n            {\n                // Append the remaining text (padded)\n                sb.append(rtrim(lineToWrap));\n                currentPos = textLength; // Mark as finished\n                break; // Exit loop\n            }\n            else\n            {\n                 // We need to break the line at 'pos' relative to 'lineToWrap'\n                 // Calculate how many characters from the *original* text segment were included before the break\n                 // This is the length of the content part: pos - padding.length()\n                 int originalCharsConsumed = pos - padding.length();\n\n                 // Handle potential issue: If break ('pos') is within or before the padding,\n                 // or if no actual characters from the original text would be consumed.\n                 if (originalCharsConsumed <= 0)\n                 {\n                     // This can happen if the first word is too long and findWrapPos returns 'width',\n                     // but 'width' is less than or equal to padding.length().\n                     // Or if findWrapPos returns a position within the padding itself (which shouldn't happen after trim).\n\n                     // Try to force break at width, ensuring it's after padding and within bounds\n                     pos = Math.min(width, lineToWrap.length()); // Break at width or end of line\n                     originalCharsConsumed = pos - padding.length(); // Recalculate consumed chars\n\n                     // If still no progress possible (width <= padding or line ends within padding)\n                     if (originalCharsConsumed <= 0) {\n                          // Cannot make progress. Append the rest of the line and stop to avoid infinite loop.\n                          sb.append(rtrim(lineToWrap));\n                          currentPos = textLength;\n                          break;\n                     }\n                 }\n\n                 // Append the wrapped line segment (from lineToWrap)\n                 sb.append(rtrim(lineToWrap.substring(0, pos))).append(defaultNewLine);\n\n                 // Advance position in the original text by the number of non-padding chars consumed\n                 currentPos += originalCharsConsumed;\n            }\n        }\n        return sb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}