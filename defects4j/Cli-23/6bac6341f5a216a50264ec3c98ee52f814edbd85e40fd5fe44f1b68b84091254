{
    "generation": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space\n    // characters\n    final String padding = createPadding(nextLineTabStop);\n\n    String remainingText = text.substring(pos).trim();\n    while (!remainingText.isEmpty())\n    {\n        String line = padding + remainingText;\n        pos = findWrapPos(line, width, padding.length());\n\n        if (pos == -1)\n        {\n            sb.append(line);\n            break;\n        }\n\n        // If we're not making progress (pos <= padding length),\n        // it means the remaining text is too long to fit even after padding\n        if (pos <= padding.length())\n        {\n            // Append as much as we can (width characters minus padding)\n            int availableWidth = width - padding.length();\n            if (availableWidth <= 0)\n            {\n                // If padding is longer than width, append padding and take width=0\n                sb.append(padding);\n                // Then take as much as we can (width characters at a time)\n                while (remainingText.length() > 0)\n                {\n                    int chunkSize = Math.min(width, remainingText.length());\n                    sb.append(remainingText.substring(0, chunkSize)).append(defaultNewLine);\n                    remainingText = remainingText.substring(chunkSize);\n                    if (!remainingText.isEmpty())\n                    {\n                        sb.append(padding);\n                    }\n                }\n                break;\n            }\n\n            // Take as much as fits in the remaining space\n            int takeLength = Math.min(availableWidth, remainingText.length());\n            sb.append(padding).append(remainingText.substring(0, takeLength)).append(defaultNewLine);\n            remainingText = remainingText.substring(takeLength).trim();\n            continue;\n        }\n\n        if (pos == padding.length() && remainingText.length() > width - padding.length())\n        {\n            // Special case where we have a very long word that can't be broken\n            int maxLength = width - padding.length();\n            if (maxLength > 0)\n            {\n                sb.append(padding);\n                // Split the remaining text into chunks of maxLength\n                int start = 0;\n                while (start < remainingText.length())\n                {\n                    int end = Math.min(start + maxLength, remainingText.length());\n                    sb.append(remainingText.substring(start, end));\n                    if (end < remainingText.length())\n                    {\n                        sb.append(defaultNewLine).append(padding);\n                    }\n                    start = end;\n                }\n                break;\n            }\n        }\n\n        sb.append(rtrim(line.substring(0, pos))).append(defaultNewLine);\n        remainingText = line.substring(pos).trim();\n    }\n\n    return sb;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}