{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the offset corresponding to the daylight savings time instance.\n     * The combination of these two rules (gap and overlap) is to always favour\n     * daylight (summer) time over standard (winter) time. This is achieved by\n     * returning the larger potential offset (less negative or more positive).\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // Calculate offset based on an estimate using local instant as UTC (first iteration)\n        // This provides a starting point but is not intrinsically correct for offset calculation.\n        final int offsetGuess = getOffset(instantLocal);\n        final long utcGuess1 = instantLocal - offsetGuess;\n        final int offsetResult1 = getOffset(utcGuess1); // Offset for first estimated UTC\n\n        // Calculate offset based on the previous estimate (second iteration)\n        final long utcGuess2 = instantLocal - offsetResult1;\n        final int offsetResult2 = getOffset(utcGuess2); // Offset for second estimated UTC\n\n        // Check if iteration converged\n        if (offsetResult1 == offsetResult2) {\n            // Iteration converged. Check if instantLocal falls into a gap or overlap.\n            // Find the transition relevant to the estimated UTC time utcGuess2.\n            // Add 1 to handle cases where utcGuess2 is exactly the transition time.\n            long trans = previousTransition(utcGuess2 + 1);\n            \n            // Get the offsets around this transition.\n            int offsetBefore = getOffset(trans - 1);\n            int offsetAfter = getOffset(trans);\n\n            // If the converged offset isn't one of the transition offsets, something is unusual\n            // (e.g., zone has fixed offset, or instant is far from transition).\n            // Return the converged offset as the best guess.\n            if (offsetResult2 != offsetBefore && offsetResult2 != offsetAfter) {\n                 return offsetResult2;\n            }\n\n            // Determine the alternative offset involved in the transition.\n            int offsetAlt = (offsetResult2 == offsetBefore) ? offsetAfter : offsetBefore;\n\n             // If the alternative offset is the same (transition has zero duration or zone has fixed offset),\n             // there is no ambiguity.\n             if (offsetAlt == offsetResult2) {\n                 return offsetResult2;\n             }\n\n            // Check if the alternative offset is also a valid mapping for instantLocal.\n            // A valid mapping means that `local - offset` yields a UTC instant\n            // whose offset *is* `offset`.\n            boolean isValidAlt = (getOffset(instantLocal - offsetAlt) == offsetAlt);\n\n            if (isValidAlt) {\n                // Ambiguous overlap: Both offsetResult2 and offsetAlt are valid mappings.\n                // Rule: Favour DST (return the larger offset).\n                return Math.max(offsetResult2, offsetAlt);\n            } else {\n                // Not an overlap. Check if the converged offset mapping is valid.\n                boolean isValidConverged = (getOffset(instantLocal - offsetResult2) == offsetResult2);\n                if (isValidConverged) {\n                    // Unique mapping for converged offset. Return it.\n                    return offsetResult2;\n                } else {\n                     // Gap: Neither offset mapping is valid for this instantLocal.\n                     // Rule: Favour DST (return the larger offset).\n                     return Math.max(offsetResult2, offsetAlt);\n                }\n            }\n        } else {\n            // Iteration did not converge (offsetResult1 != offsetResult2).\n            // This typically indicates ambiguity near a transition (gap or overlap).\n            // Rule: Favour DST (return the larger offset).\n            // The two different offsets should be the ones defining the transition.\n            return Math.max(offsetResult1, offsetResult2);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}