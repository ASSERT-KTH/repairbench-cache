{
    "generation": "    public int getOffsetFromLocal(long instantLocal) {\n        // Get the initial offset estimate by treating instantLocal as UTC (incorrect, but starting point)\n        final int offsetLocal = getOffset(instantLocal);\n        // Adjust the instant to UTC using the initial estimate\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // Check if the initial and adjusted offsets differ (indicating a possible DST boundary)\n        if (offsetLocal != offsetAdjusted) {\n            // If the offset decreased, check transitions to handle DST gap\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else {\n            // Check if the previous millisecond has a different offset (indicating DST overlap)\n            if (instantAdjusted > Long.MIN_VALUE) {\n                int offsetBefore = getOffset(instantAdjusted - 1);\n                if (offsetBefore > offsetAdjusted) {\n                    // In overlap, return the earlier offset (summer time)\n                    return offsetBefore;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}