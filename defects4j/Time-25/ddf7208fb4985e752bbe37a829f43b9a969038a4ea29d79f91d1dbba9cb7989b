{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // Calculate a preliminary UTC instant and associated offset.\n        // We use instantLocal as a first guess for the UTC instant, which is crude but necessary.\n        final int offsetGuess1 = getOffset(instantLocal);\n        final long utcGuess1 = instantLocal - offsetGuess1;\n        final int offsetGuess2 = getOffset(utcGuess1); // Offset at the first estimated UTC instant\n\n        // Recalculate UTC instant using the improved offset estimate.\n        final long utcGuess2 = instantLocal - offsetGuess2;\n        final int offsetGuess3 = getOffset(utcGuess2); // Offset at the second estimated UTC instant\n\n        // If the offsets match after the second guess, we have potentially found the correct offset.\n        if (offsetGuess2 == offsetGuess3) {\n            // This is the standard case, or the standard offset during an overlap.\n            // Check for overlap: find the transition immediately preceding the calculated UTC instant.\n            // Add 1 to handle case where utcGuess2 is exactly on a transition boundary.\n            long prevTrans = previousTransition(utcGuess2 + 1);\n            // Check if prevTrans is valid and not the same as utcGuess2 if utcGuess2 was exactly on the transition\n            if (prevTrans != Long.MIN_VALUE && prevTrans < utcGuess2 + 1) {\n                int offsetBefore = getOffset(prevTrans - 1); // Offset active just before the transition\n                // If the offset before the transition was different (and larger, indicating DST -> Standard)\n                if (offsetBefore > offsetGuess2) {\n                    // Check if instantLocal could validly map to this earlier (DST) period.\n                    long testUTCBefore = instantLocal - offsetBefore;\n                    // Verify this hypothetical instant is valid (its offset matches offsetBefore)\n                    // and it falls before the transition.\n                    if (testUTCBefore < prevTrans && getOffset(testUTCBefore) == offsetBefore) {\n                        // Yes, it's an overlap. Rule is to return the earlier (DST) offset.\n                        return offsetBefore;\n                    }\n                }\n            }\n            // No overlap detected, or the consistent offset found is correct.\n            return offsetGuess2;\n        } else {\n            // If offsetGuess2 != offsetGuess3, we are likely in a transition gap.\n            // instantLocal represents a non-existent local time.\n            // Rule: Return the offset suitable for calculating an instant *after* the gap.\n            // The offset after the gap corresponds to the later time, which has the larger offset value.\n            // (e.g., gap from +0 to +1, return +1; gap from -5 to -4, return -4)\n            return Math.max(offsetGuess2, offsetGuess3);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}