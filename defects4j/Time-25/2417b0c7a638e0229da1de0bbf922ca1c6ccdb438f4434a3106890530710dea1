{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // First guess using the provided instant.\n    int offsetLocal = getOffset(instantLocal);\n    // Adjust the instant using that offset.\n    long instantAdjusted = instantLocal - offsetLocal;\n    int offsetAdjusted = getOffset(instantAdjusted);\n    \n    // If both estimates agree, there is no transition effect.\n    if (offsetLocal == offsetAdjusted) {\n        return offsetLocal;\n    }\n    \n    // Otherwise we have two candidate offsets.\n    // Define the candidate UTC instants:\n    //   candidate A: using offsetLocal -> utcA = instantLocal - offsetLocal\n    //   candidate B: using offsetAdjusted -> utcB = instantLocal - offsetAdjusted\n    //\n    // In an overlap (fall-back), both utcA and utcB lie in the same offset period,\n    // so nextTransition(utcA) equals nextTransition(utcB). In that case we want the\n    // earlier instant \u2013 which is achieved by subtracting the larger offset.\n    // In a gap (spring-forward), the two instants will fall on different sides of the\n    // transition, so nextTransition(utcA) != nextTransition(utcB). Then we must choose\n    // the offset which produces a UTC instant on or after the gap (i.e. the smaller offset).\n    \n    int maxOffset = Math.max(offsetLocal, offsetAdjusted);\n    int minOffset = Math.min(offsetLocal, offsetAdjusted);\n    long utcFromMax = instantLocal - maxOffset;\n    long utcFromMin = instantLocal - minOffset;\n    \n    if (nextTransition(utcFromMax) == nextTransition(utcFromMin)) {\n        // Overlap scenario: choose the maximum offset (favour daylight time).\n        return maxOffset;\n    } else {\n        // Gap scenario: choose the minimum offset to push the UTC instant forward.\n        return minOffset;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}