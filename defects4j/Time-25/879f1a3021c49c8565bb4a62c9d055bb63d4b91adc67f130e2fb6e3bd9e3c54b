{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // First guess: treat instantLocal numerically as a UTC instant to get an initial offset.\n        final int offsetFirstGuess = getOffset(instantLocal);\n        \n        // Adjust instantLocal using this guess to get a first UTC estimate.\n        final long instantUTCFirstGuess = instantLocal - offsetFirstGuess;\n        \n        // Get the actual offset at this UTC estimate.\n        final int offsetActualAtFirstGuess = getOffset(instantUTCFirstGuess);\n        \n        // If the initial guess offset differs from the actual offset at the derived UTC,\n        // it implies we're near a transition.\n        if (offsetFirstGuess != offsetActualAtFirstGuess) {\n            // Case 1: DST Gap (e.g., clocks spring forward, local time period doesn't exist)\n            // This happens if offsetFirstGuess (e.g., +2h) is smaller than offsetActualAtFirstGuess (e.g., +3h).\n            // This is `offsetFirstGuess - offsetActualAtFirstGuess < 0` for positive offsets.\n            if ((offsetFirstGuess - offsetActualAtFirstGuess) < 0) {\n                // The desired behavior for a gap is to return the offset applicable *after* the gap.\n                // We check if the UTC instant derived from the first guess and the UTC instant\n                // derived from the adjusted offset are on opposite sides of a transition.\n                long nextTransitionFromFirst = nextTransition(instantUTCFirstGuess);\n                long nextTransitionFromActual = nextTransition(instantLocal - offsetActualAtFirstGuess);\n                \n                if (nextTransitionFromFirst != nextTransitionFromActual) {\n                    // This means instantLocal is in the gap. Return the offset that applies *after* the gap.\n                    return offsetActualAtFirstGuess;\n                }\n            }\n            // Case 2: Overlap where the first guess was wrong (less common with this initial guess method)\n            // If the first guess already provided the summer offset (e.g., +4h) and the actual for the derived UTC\n            // gave the standard offset (e.g., +3h), this means `offsetFirstGuess > offsetActualAtFirstGuess`.\n            // The specification states to \"favour daylight (summer) time over standard (winter) time.\"\n            // In this scenario, `offsetFirstGuess` would be the preferred summer offset.\n            return offsetFirstGuess;\n        }\n\n        // If offsets are the same (offsetFirstGuess == offsetActualAtFirstGuess), it's either:\n        // 1. Normal time (no transition nearby).\n        // 2. A DST overlap where the initial guess (treating instantLocal as UTC) already landed\n        //    on the standard time part of the overlap (e.g., Moscow 2007-10-28 02:30 scenario).\n        //    In this case, offsetActualAtFirstGuess (+03:00) is returned, but +04:00 is desired.\n        \n        // To handle case 2, we explicitly check for the \"earlier instant\" (daylight saving) rule.\n        // We probe a UTC instant that is one hour earlier than our current UTC estimate.\n        // This is a common heuristic to find the alternate offset in an overlap, assuming typical 1-hour DST.\n        final int offsetCandidateForEarlierTime = getOffset(instantUTCFirstGuess - 3600000L); // 3600000ms = 1 hour\n        \n        // If this candidate offset is different from the one we currently have AND\n        // if applying this candidate offset to instantLocal *also* produces a valid UTC instant\n        // whose actual offset matches the candidate offset itself, then we have an ambiguity.\n        if (offsetCandidateForEarlierTime != offsetActualAtFirstGuess) {\n            if (getOffset(instantLocal - offsetCandidateForEarlierTime) == offsetCandidateForEarlierTime) {\n                // Both offsetActualAtFirstGuess (likely standard) and offsetCandidateForEarlierTime (likely daylight)\n                // are valid for instantLocal. This is an ambiguous local time during an overlap.\n                // \"favour daylight (summer) time over standard (winter) time.\"\n                // For positive offsets, daylight saving time has a larger value.\n                return Math.max(offsetActualAtFirstGuess, offsetCandidateForEarlierTime);\n            }\n        }\n\n        // If no special case (gap or ambiguous overlap) was identified, return the adjusted offset.\n        return offsetActualAtFirstGuess;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}