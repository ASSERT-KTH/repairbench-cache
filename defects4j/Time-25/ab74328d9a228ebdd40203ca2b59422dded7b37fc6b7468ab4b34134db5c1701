{
    "generation": "@Override\npublic int getOffsetFromLocal(long instantLocal) {\n    // First estimate of the offset, treating instantLocal as if it were UTC\n    final int offsetLocal = getOffset(instantLocal);\n    // Adjust the instant by subtracting that estimate to get a provisional UTC instant\n    final long instantAdjusted = instantLocal - offsetLocal;\n    // Re\u2010fetch the offset for the provisional UTC instant\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    // If the two offsets differ, we must be right at a DST boundary (gap or overlap)\n    if (offsetLocal != offsetAdjusted) {\n        // --- DST\u2010gap case (spring forward): offset jumps up ---\n        if (offsetLocal < offsetAdjusted) {\n            // If the two nextTransition() calls differ, we're in the gap\n            long nextLocal    = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                // In a gap we always favour the later offsetLocal\n                return offsetLocal;\n            }\n        }\n        // Otherwise (or if not in a gap) return the adjusted offset\n        return offsetAdjusted;\n    }\n\n    // --- Possible DST overlap (fall back): offsets are equal but local time may be ambiguous ---\n    // Look for the last transition before our provisional UTC instant\n    long prev = previousTransition(instantAdjusted);\n    // Offsets immediately before and after that transition\n    int offsetBefore = getOffset(prev - 1);\n    int offsetAfter  = getOffset(prev + 1);\n\n    // If the offset decreased at that transition, we have an overlap window\n    if (offsetAfter < offsetBefore) {\n        // Compute the local\u2010time interval of the overlap\n        long overlapStart = prev + offsetAfter;\n        long overlapEnd   = prev + offsetBefore;\n        // If our local instant falls into that window, choose the earlier (larger) offset\n        if (instantLocal >= overlapStart && instantLocal < overlapEnd) {\n            return offsetBefore;\n        }\n    }\n\n    // In all other cases, return the adjusted offset\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}