{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    // if the offsets are the same, not in a transition\n    if (offsetLocal == offsetAdjusted) {\n        return offsetAdjusted;\n    }\n\n    // detect transition: determine which offset is LATER (\"summer\") offset\n    // during autumn overlaps, offsetLocal is often the standard (earlier) offset\n    int offsetAfter = Math.max(offsetLocal, offsetAdjusted);\n\n    // determine if instantLocal corresponds to offsetAfter or offsetBefore\n    long transitionInstant = nextTransition(instantAdjusted);\n    if (transitionInstant == instantAdjusted) {\n        // unlikely, but defensively choose later offset\n        return offsetAfter;\n    }\n\n    // recalc next transition boundaries in local time\n    long transitionLocalByAdjusted = transitionInstant + offsetAdjusted;\n    long transitionLocalByLocal = nextTransition(instantLocal - offsetLocal) + offsetLocal;\n\n    // We want to select the offset associated with times at or before the transition,\n    // favoring the later/summertime offset during overlaps\n    if (transitionLocalByAdjusted == transitionLocalByLocal) {\n        // transition boundary agrees, so pick the later offset\n        return offsetAfter;\n    }\n\n    // pick the offset corresponding to the later one\n    return offsetAfter;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}