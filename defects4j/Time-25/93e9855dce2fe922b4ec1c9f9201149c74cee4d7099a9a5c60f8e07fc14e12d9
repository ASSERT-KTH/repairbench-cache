{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // First get the offset based on the local instant.\n    int offset1 = getOffset(instantLocal);\n    long utcCandidate1 = instantLocal - offset1;\n    // Recalculate the offset using the adjusted instant.\n    int offset2 = getOffset(utcCandidate1);\n    \n    // If both offsets are the same, there's no transition in effect.\n    if (offset1 == offset2) {\n        return offset1;\n    }\n    \n    // Determine the boundaries from below using both offsets.\n    long trans1 = nextTransition(instantLocal - offset1);\n    long trans2 = nextTransition(instantLocal - offset2);\n    \n    /*\n     * There are two cases:\n     *\n     * 1. Overlap (typically in a fall-back situation):\n     *    Both adjusted instants lie in the same transition gap.\n     *    In an overlap the two valid offsets differ, and we choose the larger one,\n     *    which corresponds to the earlier UTC instant.\n     *\n     * 2. Gap (typically in a spring-forward):\n     *    The two adjusted instants lie on different sides of the DST gap.\n     *    In a gap we want to map the local instant to a UTC instant on or after the gap,\n     *    so we choose the smaller offset.\n     */\n    if (trans1 == trans2) {\n        // Overlap: return the larger (i.e. more positive) offset.\n        return Math.max(offset1, offset2);\n    } else {\n        // Gap: return the smaller offset.\n        return Math.min(offset1, offset2);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}