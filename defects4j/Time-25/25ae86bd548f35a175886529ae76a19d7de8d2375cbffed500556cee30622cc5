{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        // This 'getOffset' takes a UTC instant, so 'instantLocal' is treated as a UTC instant\n        // for an initial guess. For ambiguous local times, it often defaults to the standard offset.\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // A common DST saving is 1 hour (3600000 milliseconds).\n        // The Javadoc states:\n        // 1. For DST gaps, return the offset suitable for calculating an instant *after* the gap.\n        // 2. For DST overlaps, favour daylight (summer) time, which means the *earlier* UTC instant.\n        // Both rules imply selecting the *larger* of the two possible offsets for an ambiguous local time,\n        // or the offset that applies *after* a gap.\n\n        // Test for an offset that is 1 hour greater than the current 'offsetAdjusted'.\n        // This covers common DST transitions (both gaps and overlaps) where the other\n        // valid offset is 1 hour different.\n        final int ONE_HOUR_MILLIS = 3600000;\n        final int possibleAlternativeOffset = offsetAdjusted + ONE_HOUR_MILLIS;\n        \n        // If 'instantLocal' mapped with 'possibleAlternativeOffset' gives a UTC instant\n        // for which 'getOffset' returns 'possibleAlternativeOffset', then this alternative\n        // offset is a valid interpretation of 'instantLocal' and is the preferred one.\n        if (getOffset(instantLocal - possibleAlternativeOffset) == possibleAlternativeOffset) {\n            // This 'possibleAlternativeOffset' would be the daylight offset in an overlap,\n            // or the after-gap offset in a gap. In both cases, this aligns with the Javadoc's preference.\n            return possibleAlternativeOffset;\n        }\n\n        // If the 1-hour alternative check did not return, then 'offsetAdjusted' is the most suitable offset.\n        // This handles cases where there are no transitions, or where the first calculated offset was already correct.\n        // The original `if (offsetLocal != offsetAdjusted)` block and its nested logic are superseded\n        // by this more robust and simplified approach that aligns with the Javadoc rules.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}