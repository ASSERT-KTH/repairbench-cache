{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate).\n        // This is often the offset for the UTC instant corresponding to `instantLocal` if `instantLocal` were a UTC time.\n        final int offsetLocal = getOffset(instantLocal);\n\n        // Adjust instantLocal using the estimate and recalc the offset.\n        // This attempts to find the UTC instant assuming `offsetLocal` is the correct offset for `instantLocal`.\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // If the initial and adjusted offsets differ, we are near a DST boundary (gap or overlap).\n        if (offsetLocal != offsetAdjusted) {\n            // Case 1: DST Gap (spring forward, e.g., 01:00 to 01:59:59.999 does not exist).\n            // offsetLocal (pre-gap offset) is smaller than offsetAdjusted (post-gap offset).\n            // Example: +0h to +1h -> (0 - 1h) < 0\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // The documentation states: \"return an offset suitable for calculating an instant after any DST gap.\"\n                // This means we should return the offset that applies *after* the gap, which is `offsetAdjusted`.\n                return offsetAdjusted;\n            } else {\n                // Case 2: DST Overlap (fall back, local time repeats).\n                // offsetLocal (daylight offset) is larger than offsetAdjusted (standard offset).\n                // Example: +4h to +3h -> (4h - 3h) > 0\n                // The documentation states: \"always favour daylight (summer) time over standard (winter) time.\"\n                // This implies returning the larger offset (`offsetLocal` in this branch).\n                // We need to confirm that `instantLocal` genuinely corresponds to a valid UTC time using `offsetLocal`.\n                if (getOffset(instantLocal - offsetLocal) == offsetLocal) {\n                    return offsetLocal; // Prefer the larger (daylight) offset if it's valid.\n                }\n                // If for some reason instantLocal - offsetLocal doesn't yield offsetLocal, fallback to standard offset.\n                return offsetAdjusted;\n            }\n        }\n\n        // If offsetLocal == offsetAdjusted, it means either:\n        // 1. It's a non-transition time, and the offset is straightforward.\n        // 2. It's an overlap, but the initial `getOffset(instantLocal)` already resolved to the *standard* offset\n        //    (i.e., the later UTC instant for an ambiguous local time). This is the case that caused the Moscow test failures.\n        // We need to check if `instantLocal` can also map to an *earlier* UTC time with a larger (daylight) offset.\n\n        // Probe for a common DST saving, typically 1 hour (3600000 milliseconds).\n        // This heuristic is often used to check for the 'other' possible offset in an overlap.\n        final int commonDaylightSavings = 3600000;\n        \n        // Try calculating a 'daylight' offset candidate by adding typical DST savings to the standard offset.\n        final int candidateDaylightOffset = offsetAdjusted + commonDaylightSavings;\n        \n        // Calculate the UTC instant if `instantLocal` were to use this candidate daylight offset.\n        final long instantAdjustedToDaylightCandidate = instantLocal - candidateDaylightOffset;\n        \n        // Check if this `candidateDaylightOffset` is actually the correct offset for `instantAdjustedToDaylightCandidate`.\n        // Also, ensure that this candidate offset is indeed larger than the `offsetAdjusted` (which is likely the standard offset here).\n        if (getOffset(instantAdjustedToDaylightCandidate) == candidateDaylightOffset && candidateDaylightOffset > offsetAdjusted) {\n            // If both conditions are met, it means `instantLocal` is ambiguous (in an overlap),\n            // and `candidateDaylightOffset` represents the earlier UTC instant (daylight time).\n            // According to the rule \"favour daylight (summer) time\", we should return this larger offset.\n            return candidateDaylightOffset;\n        }\n\n        // Default case: If no special overlap or gap scenario is detected (or if the daylight probe didn't confirm),\n        // return the initially determined and adjusted offset.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}