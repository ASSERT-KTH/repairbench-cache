{
    "generation": "    public int getOffsetFromLocal(long instantLocal) {\n        // 1. First estimate: Interprets instantLocal (local time) as a UTC instant to get an initial offset.\n        //    For Moscow 02:30 local in fall-back: instantLocal as UTC (02:30 UTC) would have +03:00 offset. So, offsetLocal = +03:00.\n        //    For London 01:30 local in spring-forward: instantLocal as UTC (01:30 UTC) would have +01:00 offset. So, offsetLocal = +01:00.\n        final int offsetLocal = getOffset(instantLocal); \n\n        // 2. Adjust instantLocal using the first estimate and recalculate the offset.\n        //    For Moscow: instantAdjusted = (02:30 local) - (+03:00) = 23:30 UTC (prev. day).\n        //    Offset at 23:30 UTC is +04:00 (daylight). So, offsetAdjusted = +04:00.\n        //    For London: instantAdjusted = (01:30 local) - (+01:00) = 00:30 UTC.\n        //    Offset at 00:30 UTC is +00:00 (standard). So, offsetAdjusted = +00:00.\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // 3. If offsets differ, it's a DST boundary.\n        if (offsetLocal != offsetAdjusted) { \n            // This branch handles both gaps and overlaps.\n\n            // Condition: (offsetLocal - offsetAdjusted) < 0\n            // This means offsetLocal is smaller than offsetAdjusted.\n            // Moscow: (+03:00 - +04:00) = -1h < 0. This branch is taken for overlaps.\n            // London: (+01:00 - +00:00) = +1h > 0. This branch is NOT taken for gaps.\n            if ((offsetLocal - offsetAdjusted) < 0) { \n                // This block is for DST Overlaps (Fall-back), e.g., Moscow.\n                // At this point: offsetLocal is +03:00 (standard), offsetAdjusted is +04:00 (daylight).\n                // Javadoc requires favoring daylight: return +04:00 (offsetAdjusted).\n                // Original logic:\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                // The problem arises here: if nextLocal != nextAdjusted, it returns offsetLocal (+03:00).\n                // This explains the Moscow test failures where +04:00 was expected but +03:00 was returned.\n                // This condition incorrectly returns the standard offset.\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal; \n                }\n            }\n            // If the inner 'if' was not taken (either because not an overlap, or nextLocal == nextAdjusted for overlap)\n            // or for gaps (London example), the code falls through to:\n        }\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}