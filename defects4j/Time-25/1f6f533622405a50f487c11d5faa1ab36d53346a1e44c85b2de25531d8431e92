{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // First guess: treat the input as if it were UTC to get an initial offset\n    int offsetLocal = getOffset(instantLocal);\n    // Convert that guess back to UTC\n    long instantAdjusted = instantLocal - offsetLocal;\n    // Get the real offset at that UTC instant\n    int offsetAdjusted = getOffset(instantAdjusted);\n    // Start with the adjusted offset as the default result\n    int result = offsetAdjusted;\n\n    // Examine the previous transition around the adjusted UTC instant\n    long prev = previousTransition(instantAdjusted);\n    if (prev != instantAdjusted) {\n        int before = getOffset(prev - 1);\n        int after  = getOffset(prev + 1);\n        if (before != after) {\n            if (before < after) {\n                // Gap: clocks jumped forward\n                long localStart = prev + before;\n                long localEnd   = prev + after;\n                if (instantLocal >= localStart && instantLocal < localEnd) {\n                    // Invalid local time, choose the later offset (after the gap)\n                    return after;\n                }\n            } else {\n                // Overlap: clocks rolled back\n                long localStart = prev + after;\n                long localEnd   = prev + before;\n                if (instantLocal >= localStart && instantLocal < localEnd) {\n                    // Ambiguous local time, choose the earlier instant (larger offset)\n                    return before;\n                }\n            }\n        }\n    }\n\n    // Examine the next transition around the adjusted UTC instant\n    long next = nextTransition(instantAdjusted);\n    if (next != instantAdjusted) {\n        int before = getOffset(next - 1);\n        int after  = getOffset(next + 1);\n        if (before != after) {\n            if (before < after) {\n                // Gap: clocks jumped forward\n                long localStart = next + before;\n                long localEnd   = next + after;\n                if (instantLocal >= localStart && instantLocal < localEnd) {\n                    return after;\n                }\n            } else {\n                // Overlap: clocks rolled back\n                long localStart = next + after;\n                long localEnd   = next + before;\n                if (instantLocal >= localStart && instantLocal < localEnd) {\n                    return before;\n                }\n            }\n        }\n    }\n\n    // No special case, return the adjusted offset\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}