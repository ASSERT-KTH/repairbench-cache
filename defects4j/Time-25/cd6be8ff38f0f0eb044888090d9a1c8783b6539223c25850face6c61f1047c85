{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // First estimate using the naive UTC\u2010based offset\n    final int offsetLocal = getOffset(instantLocal);\n    // Apply that estimate to get a candidate UTC instant\n    final long instantAdjusted = instantLocal - offsetLocal;\n    // Recalculate the offset based on the candidate UTC instant\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    if (offsetLocal != offsetAdjusted) {\n        // We\u2019re near a DST boundary: either a gap or an overlap\n        int diff = offsetLocal - offsetAdjusted;\n        if (diff < 0) {\n            // DST gap (spring forward): favour the later offset to land\n            // after the missing local interval\n            long nextLocal    = nextTransition(instantAdjusted);\n            long nextAdjusted= nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        } else {\n            // DST overlap (fall back) detected by differing offsets:\n            // favour the earlier instant (i.e. the larger, DST offset)\n            return offsetLocal;\n        }\n    } else {\n        // Offsets are equal under naive mapping\u2014could still be an overlap\n        // Find the last transition before our candidate UTC instant\n        long trans = previousTransition(instantAdjusted + 1);\n        int before = getOffset(trans - 1);\n        int after  = getOffset(trans + 1);\n        // A downward jump in the offset indicates an overlap\n        if (before > after) {\n            long overlapStartLocal = trans + after;\n            long overlapEndLocal   = trans + before;\n            // If our local instant falls in that ambiguous window,\n            // pick the earlier occurrence (the larger, DST offset)\n            if (instantLocal >= overlapStartLocal && instantLocal < overlapEndLocal) {\n                return before;\n            }\n        }\n    }\n    // Default: no special case, return the refined offset\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}