{
    "generation": "    import org.joda.time.DateTimeConstants;\n\n    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        // This initial guess treats `instantLocal` as if it were a UTC instant\n        // to find an approximate offset.\n        final int offsetLocal = getOffset(instantLocal);\n        \n        // adjust instantLocal using the estimate to get a candidate UTC instant,\n        // then recalculate the offset at this estimated UTC instant.\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // If the two calculated offsets differ, we are near a DST boundary.\n        if (offsetLocal != offsetAdjusted) {\n            // Case 1: DST Gap (e.g., Spring Forward, 01:00 becomes 02:00 local, skipping 01:xx)\n            // `offsetLocal` (standard offset, e.g., +1) is less than `offsetAdjusted` (daylight offset, e.g., +2).\n            // (offsetLocal - offsetAdjusted) < 0\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // Javadoc says for gaps: \"return an offset suitable for calculating an instant after any DST gap.\"\n                // Example: \"Input: 01:00 Output: 02:00\". This means the *larger* (daylight) offset should be returned.\n                // `offsetAdjusted` typically represents this larger offset.\n                return offsetAdjusted;\n            }\n            // Case 2: DST Overlap (e.g., Fall Back, 02:00 occurs twice local, first +4 then +3)\n            // `offsetLocal` (daylight offset, e.g., +4) is greater than `offsetAdjusted` (standard offset, e.g., +3).\n            // (offsetLocal - offsetAdjusted) > 0 (implicitly handled by the `else` block)\n            else {\n                // Javadoc says for overlaps: \"always favour daylight (summer) time over standard (winter) time.\"\n                // `offsetLocal` in this branch is likely the daylight offset. We should prefer it if it's consistent.\n                if (getOffset(instantLocal - offsetLocal) == offsetLocal) {\n                    return offsetLocal;\n                }\n                // If `offsetLocal` (daylight) is not consistent (e.g., `instantLocal` is numerically past the actual daylight period in UTC),\n                // fall back to `offsetAdjusted` (standard).\n                return offsetAdjusted;\n            }\n        }\n        \n        // If `offsetLocal == offsetAdjusted`, the initial two-step iteration converged.\n        // This covers normal times and also the problematic overlap scenario (like Moscow Autumn)\n        // where the initial `getOffset(instantLocal)` and subsequent `getOffset(instantAdjusted)`\n        // both resolve to the *standard* offset, failing to pick the daylight offset as per the rule.\n        // We need to explicitly check for this ambiguous overlap case.\n        \n        // Check if `instantLocal` could also map consistently to a 'daylight' offset\n        // that is typically 1 hour different from the current `offsetAdjusted` (which is assumed to be standard).\n        // This is done by estimating a UTC instant one hour earlier than the current `instantAdjusted`\n        // and checking if its offset is consistent with `instantLocal`.\n        \n        // Try an alternative offset, assuming a 1-hour difference typical for DST.\n        // `instantAdjusted + DateTimeConstants.MILLIS_PER_HOUR` would try an instant 1 hour *later* in UTC,\n        // `instantAdjusted - DateTimeConstants.MILLIS_PER_HOUR` would try an instant 1 hour *earlier* in UTC.\n        // For overlaps, the desired daylight time is the one that occurred *earlier* in UTC.\n        // So, we calculate an alternative offset using a UTC instant that is one hour \"behind\" `instantAdjusted`\n        // relative to the standard/daylight difference.\n        \n        // This `offsetAlternative` represents the offset that would apply to `instantLocal` if it\n        // were interpreted with the *other* (e.g., daylight) offset in an overlap.\n        final int offsetAlternative = getOffset(instantLocal - (offsetAdjusted + DateTimeConstants.MILLIS_PER_HOUR));\n        \n        // If this alternative offset consistently maps back to `instantLocal` (meaning `instantLocal - offsetAlternative` gives `offsetAlternative`),\n        // AND if this `offsetAlternative` is numerically \"larger\" (more positive or less negative) than `offsetAdjusted`\n        // (which implies it's the daylight offset in common DST rules), then we prefer it.\n        if (getOffset(instantLocal - offsetAlternative) == offsetAlternative && offsetAlternative > offsetAdjusted) {\n            return offsetAlternative;\n        }\n        \n        // If no special DST handling applied or the explicit daylight check for overlap didn't find a better match,\n        // return the initially converged `offsetAdjusted`.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}