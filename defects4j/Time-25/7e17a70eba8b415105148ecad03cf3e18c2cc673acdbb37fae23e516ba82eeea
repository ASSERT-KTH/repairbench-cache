{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // If the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // If the offsets differ, this indicates a transition point.\n\n            // Check if we are in a gap interval. This happens if\n            // instantAdjusted (calculated using the initial offset guess)\n            // is before the transition, but the 'real' instant is after.\n            // If getOffset(instantLocal - offsetAdjusted) == offsetLocal,\n            // it implies that offsetLocal is the offset before the transition\n            // and offsetAdjusted is the offset after the transition.\n            if (getOffset(instantLocal - offsetAdjusted) == offsetLocal) {\n                // Gap: offsetLocal is before, offsetAdjusted is after. Return offsetAdjusted.\n                // Overlap: offsetLocal is before (DST), offsetAdjusted is after (STD). Return offsetLocal (DST).\n                // Determine if it's a gap or overlap based on which offset is larger.\n                 if (offsetLocal < offsetAdjusted) {\n                    // Gap (Standard -> DST): offsetLocal is Standard, offsetAdjusted is DST.\n                    // Return the offset after the gap (DST).\n                    return offsetAdjusted;\n                 } else {\n                    // Overlap (DST -> Standard): offsetLocal is DST, offsetAdjusted is Standard.\n                    // Return the offset for the earlier instant (DST).\n                    return offsetLocal;\n                 }\n            }\n             // If getOffset(instantLocal - offsetAdjusted) != offsetLocal,\n             // it implies offsetAdjusted is the offset before the transition\n             // and offsetLocal is the offset after the transition.\n             else {\n                 // Gap: offsetAdjusted is before, offsetLocal is after. Return offsetLocal.\n                 // Overlap: offsetAdjusted is before (DST), offsetLocal is after (STD). Return offsetAdjusted (DST).\n                 // Determine if it's a gap or overlap based on which offset is larger.\n                 if (offsetAdjusted < offsetLocal) {\n                     // Gap (Standard -> DST): offsetAdjusted is Standard, offsetLocal is DST.\n                     // Return the offset after the gap (DST).\n                     return offsetLocal;\n                 } else {\n                     // Overlap (DST -> Standard): offsetAdjusted is DST, offsetLocal is Standard.\n                     // Return the offset for the earlier instant (DST).\n                     return offsetAdjusted;\n                 }\n             }\n             // Simplified logic based on documentation for v2.0 onwards:\n             // For gaps, return offset after gap (larger offset).\n             // For overlaps, return offset of earlier instant (DST/larger offset).\n             // Thus, always return the larger offset.\n             // return Math.max(offsetLocal, offsetAdjusted); // Potential simplification\n        }\n        // If offsets are the same, the adjusted offset is correct.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}