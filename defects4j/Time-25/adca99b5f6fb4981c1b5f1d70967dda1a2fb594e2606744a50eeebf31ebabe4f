{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // Gap scenario. offsetLocal is offset before gap, offsetAdjusted is offset after gap.\n                // Check if recalculating the instant using offsetAdjusted causes a shift\n                // in the next transition time. If so, assume offsetAdjusted is incorrect\n                // for this local time and return offsetLocal instead (original logic).\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n                // Otherwise fall through to return offsetAdjusted (offset after gap)\n            } else {\n                // Overlap scenario identified by offsetLocal > offsetAdjusted.\n                // offsetLocal is the offset before transition (DST),\n                // offsetAdjusted is the offset after transition (STD).\n                // Return offsetLocal as per Javadoc (favour earlier instant / DST).\n                return offsetLocal;\n            }\n        }\n        \n        // If offsetLocal == offsetAdjusted, or if gap logic fell through.\n        // We must still check for an overlap ambiguity where the initial guess\n        // using instantLocal as UTC might have coincidentally picked the standard time offset.\n        \n        // Calculate the UTC instant based on the consistent offset 'offsetAdjusted'.\n        long instantUTC = instantLocal - offsetAdjusted;\n        // Find the timestamp of the last transition strictly before this UTC instant.\n        // Use 'true' for strictly previous, ensuring we don't get the transition instant itself.\n        long trans = previousTransition(instantUTC, true);\n        if (trans != Long.MIN_VALUE) { // Check if a previous transition exists.\n            // Get the offset that was active right before this transition.\n            int offsetBefore = getOffset(trans - 1);\n            // Check if the offset actually changed at this transition.\n            if (offsetBefore != offsetAdjusted) {\n                // If the offset changed, check if the local time 'instantLocal'\n                // could also have occurred validly with this 'offsetBefore'.\n                long instantUTCAlt = instantLocal - offsetBefore;\n                // Verify that this alternative UTC instant has the correct offset ('offsetBefore')\n                // AND that it occurred before the transition time 'trans'. This ensures it's the first occurrence.\n                if (getOffset(instantUTCAlt) == offsetBefore && instantUTCAlt < trans) {\n                    // Ambiguous local time (overlap) confirmed.\n                    // Return the offset associated with the earlier instant (DST).\n                    return offsetBefore;\n                }\n            }\n        }\n\n        // Default case: Return the consistent offset 'offsetAdjusted'.\n        // This applies if it's not near a transition, after a gap (where next transitions matched),\n        // or the second occurrence in an overlap (where the alternative check failed).\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}