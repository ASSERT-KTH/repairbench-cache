{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        // This initial estimate treats instantLocal as a UTC instant, which can be problematic\n        // during transitions, especially overlaps where it often defaults to the standard offset.\n        final int offsetLocal = getOffset(instantLocal);\n        \n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        \n        // If the initial estimate matches the re-calculated offset, it means we found a stable\n        // offset. This could be the correct one, or it could be the standard offset during an overlap.\n        if (offsetLocal == offsetAdjusted) {\n            // Check for overlap: see if the local time also maps to a valid UTC time using the *previous* offset.\n            // This happens when the clock falls back, e.g., from +04:00 to +03:00.\n            // `instantAdjusted` is a UTC instant. We look at the transition immediately before it.\n            long prevTransition = previousTransition(instantAdjusted);\n            \n            // If prevTransition is not the same as instantAdjusted, there was a transition.\n            if (prevTransition != instantAdjusted) {\n                // Get the offset just before the previous transition. This would be the daylight offset.\n                int offsetBeforePrevTransition = getOffset(prevTransition - 1); \n                \n                // If the offset before the previous transition is greater than the current `offsetAdjusted`,\n                // it implies a fall-back (overlap) transition, e.g., +04:00 (daylight) to +03:00 (standard).\n                if (offsetBeforePrevTransition > offsetAdjusted) {\n                    // Test if this daylight offset is also valid for `instantLocal`.\n                    long instantDaylightUTC = instantLocal - offsetBeforePrevTransition;\n                    int offsetAtDaylightUTC = getOffset(instantDaylightUTC);\n                    \n                    // If the daylight offset is consistent for the calculated UTC instant,\n                    // and it's larger (favours daylight/summer time), then return it.\n                    if (offsetAtDaylightUTC == offsetBeforePrevTransition) {\n                        return offsetBeforePrevTransition;\n                    }\n                }\n            }\n            // If no overlap requiring daylight preference was found, or if the daylight offset wasn't valid,\n            // return the initially found stable offset (which is the standard offset for this local time).\n            return offsetAdjusted;\n\n        } else { // offsetLocal != offsetAdjusted, we are near a DST boundary (a gap)\n            // This block handles gaps (spring forward), e.g., +01:00 to +02:00.\n            // The condition `(offsetLocal - offsetAdjusted) < 0` means `offsetLocal < offsetAdjusted`.\n            // This is typical for a spring forward where `offsetLocal` (before gap) is smaller than `offsetAdjusted` (after gap).\n            // The rule for gaps is to return the offset that maps to an instant *after* the gap.\n            // The existing logic implicitly returns `offsetLocal` (the before-gap offset) if it helps map to the after-gap time,\n            // by checking if the next transition from `instantLocal - offsetAdjusted` differs from `instantLocal - offsetLocal`.\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n            // If it's not a gap, or the gap logic didn't return, return the adjusted offset.\n            return offsetAdjusted;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}