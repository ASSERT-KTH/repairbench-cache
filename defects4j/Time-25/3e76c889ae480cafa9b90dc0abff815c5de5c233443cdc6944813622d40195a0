{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // Check if we are in a DST overlap period\n        if (isOverlapping(instantLocal, offsetLocal, offsetAdjusted)) {\n            // Return the later offset (summer time)\n            return offsetLocal;\n        } else if (isGap(instantLocal, offsetLocal, offsetAdjusted)) {\n            // We need to ensure that time is always after the DST gap\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // Find the next transition after the gap\n                long nextTransition = nextTransition(instantAdjusted + offsetAdjusted);\n                // Adjust instantLocal to be just after the gap\n                instantLocal = nextTransition + offsetLocal;\n                // Recalculate the offset\n                return getOffset(instantLocal);\n            }\n        }\n    }\n    return offsetAdjusted;\n}\n\nprivate boolean isOverlapping(long instantLocal, int offsetLocal, int offsetAdjusted) {\n    // Check if the local time is within the overlap period\n    long startOverlap = getOverlapStart(instantLocal);\n    long endOverlap = getOverlapEnd(instantLocal);\n    return instantLocal >= startOverlap && instantLocal < endOverlap;\n}\n\nprivate boolean isGap(long instantLocal, int offsetLocal, int offsetAdjusted) {\n    // Check if the local time is within the gap period\n    long startGap = getGapStart(instantLocal);\n    long endGap = getGapEnd(instantLocal);\n    return instantLocal >= startGap && instantLocal < endGap;\n}\n\nprivate long getOverlapStart(long instantLocal) {\n    // Implementation to get the start of the overlap period\n    // This is specific to the time zone and its rules\n    // For example, in Moscow's case, it might be 2007-10-28T02:00:00\n}\n\nprivate long getOverlapEnd(long instantLocal) {\n    // Implementation to get the end of the overlap period\n    // This is specific to the time zone and its rules\n    // For example, in Moscow's case, it might be 2007-10-28T03:00:00\n}\n\nprivate long getGapStart(long instantLocal) {\n    // Implementation to get the start of the gap period\n    // This is specific to the time zone and its rules\n    // For example, in Moscow's case, it might be 2007-10-28T02:00:00\n}\n\nprivate long getGapEnd(long instantLocal) {\n    // Implementation to get the end of the gap period\n    // This is specific to the time zone and its rules\n    // For example, in Moscow's case, it might be 2007-10-28T03:00:00\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}