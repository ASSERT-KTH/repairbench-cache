{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // First estimate offset and adjust\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    // 1) Detect an overlap (when clocks go back) and choose the earlier offset (the larger one)\n    //    f = u + getOffset(u); in an overlap getOffset drops, so f zig-zags backwards.\n    //    The overlap interval in local time is [t + newOffset, t + oldOffset).\n    long candidateUTC = instantLocal - offsetAdjusted;\n    long prevTrans = previousTransition(candidateUTC);\n    if (prevTrans != candidateUTC) {\n        int offsetBefore = getOffset(prevTrans - 1);\n        int offsetAfter = getOffset(prevTrans);\n        if (offsetBefore > offsetAfter) {\n            long overlapStart = prevTrans + offsetAfter;\n            long overlapEnd   = prevTrans + offsetBefore;\n            if (instantLocal >= overlapStart && instantLocal < overlapEnd) {\n                // return the earlier instant's offset (offsetBefore), which is the larger/DST offset\n                return offsetBefore;\n            }\n        }\n    }\n\n    // 2) Handle a gap (when clocks go forward) as before\n    if (offsetLocal != offsetAdjusted && offsetLocal < offsetAdjusted) {\n        long nextLocal    = nextTransition(instantAdjusted);\n        long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n        if (nextLocal != nextAdjusted) {\n            return offsetLocal;\n        }\n    }\n\n    // 3) Normal case\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}