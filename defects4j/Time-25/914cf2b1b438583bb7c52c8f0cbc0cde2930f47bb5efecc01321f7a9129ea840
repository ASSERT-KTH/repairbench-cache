{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // We are clearly in a transition period where the initial guess was wrong.\n            // Check if we are in a gap transition (e.g. spring forward)\n            // Gap: offsetLocal is offset before gap, offsetAdjusted is offset after gap. offsetLocal < offsetAdjusted.\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // Javadoc: \"return an offset suitable for calculating an instant after any DST gap\" -> offsetAdjusted\n                // However, the original code included this check. It implies that offsetLocal should be\n                // returned if the transition that instantAdjusted maps forward to is different from the transition\n                // that (instantLocal - offsetAdjusted) maps forward to. This indicates that instantLocal falls\n                // around another transition just after the gap. Let's retain this logic from the original code.\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal; // Return offset before gap\n                }\n                // Otherwise fall through to return offsetAdjusted (offset after gap).\n            } else {\n                // Overlap transition (e.g. fall back). offsetLocal > offsetAdjusted.\n                // Javadoc: \"During a DST overlap... return the earlier instant... favour daylight time\".\n                // The earlier instant corresponds to the offset *before* the transition, which is offsetLocal (the daylight offset).\n                return offsetLocal; // Return the daylight offset (offset before transition)\n            }\n        } else {\n            // If offsetLocal == offsetAdjusted, it might be correct,\n            // OR it might be an overlap where the initial guess resolved incorrectly to the standard offset.\n            // Check for this specific overlap case where the initial calculation stabilized on the 'later' (standard) offset.\n            long instantUTC = instantAdjusted; // Best estimate of UTC = instantLocal - offsetAdjusted\n            long prevTrans = previousTransition(instantUTC);\n            // Ensure the previous transition is valid and occurred before our estimated UTC.\n            if (prevTrans < instantUTC) {\n                int offsetBefore = getOffset(prevTrans - 1);\n                int offsetAfter = getOffset(prevTrans); // This should be equal to offsetAdjusted\n                // Check if it was an overlap transition (offset decreases, DST -> Standard)\n                if (offsetBefore > offsetAfter) {\n                    // Calculate the local time range of the overlap.\n                    // The overlap period starts locally at the transition time + the *later* offset (standard).\n                    long overlapStartLocal = prevTrans + offsetAfter;\n                    // The overlap period ends locally at the transition time + the *earlier* offset (daylight).\n                    long overlapEndLocal = prevTrans + offsetBefore;\n                    // If the input local time falls within this ambiguous range...\n                    if (instantLocal >= overlapStartLocal && instantLocal < overlapEndLocal) {\n                        // ...then we should have returned the earlier offset (DST offset).\n                        return offsetBefore;\n                    }\n                }\n            }\n        }\n        // Default case: return the calculated offsetAdjusted.\n        // This covers:\n        // - Non-transition times.\n        // - Gaps (where the nextTransition check passes).\n        // - Overlaps where the initial guess correctly identified the DST offset,\n        //   or where the explicit check above didn't trigger.\n        return offsetAdjusted;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}