{
    "generation": "public int getOffsetFromLocal(long instantLocal) {\n    // first estimate\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust using the estimate and recalc\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n\n    // handle DST gap (spring forward) if offsets differ and we are in the gap\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal    = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n\n    // handle DST overlap (fall back) \u2013 pick the earlier occurrence (daylight time)\n    final long utc = instantLocal - offsetAdjusted;\n    final long prevTrans = previousTransition(utc);\n    if (prevTrans != utc) {\n        int offsetBefore = getOffset(prevTrans - 1);\n        int offsetAfter  = getOffset(prevTrans);\n        // if the zone stepped back, there is an overlap\n        if (offsetBefore > offsetAfter) {\n            // compute the local overlap interval\n            long localAfter  = prevTrans + offsetAfter;\n            long localBefore = prevTrans + offsetBefore;\n            if (instantLocal >= localAfter && instantLocal < localBefore) {\n                return offsetBefore;\n            }\n        }\n    }\n\n    // otherwise return the normal adjusted offset\n    return offsetAdjusted;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}