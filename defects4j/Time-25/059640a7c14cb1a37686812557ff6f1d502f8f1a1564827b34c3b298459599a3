{
    "generation": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset guess at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n\n        // If the offsets match, we are not near a transition or the guess was correct.\n        if (offsetLocal == offsetAdjusted) {\n            return offsetAdjusted;\n        }\n\n        // We are near a transition. Check if both offsets can produce the same local time.\n        // utc1 = instantLocal - offsetLocal\n        // local1 = utc1 + getOffset(utc1)\n        long utc1 = instantLocal - offsetLocal;\n        // Recheck offset at utc1 as it might differ from offsetAdjusted if zone rules changed near instantLocal\n        int offsetAtUtc1 = getOffset(utc1);\n        boolean localWorks = (utc1 + offsetAtUtc1 == instantLocal);\n\n        // utc2 = instantLocal - offsetAdjusted\n        // local2 = utc2 + getOffset(utc2)\n        long utc2 = instantLocal - offsetAdjusted;\n        // Recheck offset at utc2 as it might differ from offsetAdjusted if zone rules changed near instantLocal - offsetLocal\n        int offsetAtUtc2 = getOffset(utc2);\n        boolean adjustedWorks = (utc2 + offsetAtUtc2 == instantLocal);\n\n        if (localWorks && adjustedWorks) {\n            // Overlap detected: Both offsets produce the given local time.\n            // Return the earlier instant's offset (Daylight Saving Time).\n            // DST offset is the larger offset (less negative or more positive).\n            return Math.max(offsetLocal, offsetAdjusted);\n        } else if (localWorks) {\n             // Gap detected: Only offsetLocal works. offsetAdjusted implies the instant is in the gap.\n             // Return the offset for the time *before* the gap (Standard Time).\n             // Standard offset is the smaller offset (more negative or less positive).\n            return offsetLocal; // offsetLocal is the one that worked. Return it. (it implies standard time for a gap)\n        } else if (adjustedWorks) {\n             // Gap detected: Only offsetAdjusted works. offsetLocal implies the instant is in the gap.\n             // Return the offset for the time *before* the gap (Standard Time).\n             // Standard offset is the smaller offset (more negative or less positive).\n             // Since adjustedWorks=true, utc2 is a valid instant. offsetAtUtc2 is its offset.\n             // We need the offset that corresponds to standard time across the transition.\n             // If offsetAdjusted > offsetLocal, offsetLocal is the standard offset.\n             // If offsetAdjusted < offsetLocal, offsetAdjusted is the standard offset? No, DST->STD overlap, not gap.\n             // For a gap (STD->DST), offsetLocal will be the standard offset.\n             // So return offsetLocal which is std offset.\n             return offsetLocal;\n        } else {\n            // Neither offset combination works. This case is theoretically impossible for valid zones and instants,\n            // but as a fallback, favour DST, which corresponds to the largest offset.\n            // This matches the overlap behaviour.\n            return Math.max(offsetLocal, offsetAdjusted);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}