{
    "generation": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            // Get step interval from interpolator\n            final double t0_step = interpolator.getPreviousTime();\n            final double t1      = interpolator.getCurrentTime();\n            forward = interpolator.isForward(); // Integration direction\n\n            // Determine number of sub-intervals and step size h\n            final int    n;\n            final double h;\n            // Check step size only if maxCheckInterval is positive; otherwise, check only the endpoint\n            // Also handle case where t1 == t0_step to avoid division by zero\n            if (maxCheckInterval > 0 && t1 != t0_step) {\n                n = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0_step) / maxCheckInterval));\n                h = (t1 - t0_step) / n;\n            } else {\n                n = 1;\n                h = t1 - t0_step; // h can be 0 if t1 == t0_step\n            }\n\n            double ta = t0_step;\n            interpolator.setInterpolatedTime(ta);\n            // Evaluate g at the start of the step interval [t0_step, t1]\n            double ga = handler.g(ta, interpolator.getInterpolatedState());\n\n            for (int i = 0; i < n; ++i) {\n\n                // Evaluate handler value at the end of the sub-step tb\n                // Use t1 for the last endpoint to avoid potential floating point overshoot/undershoot\n                final double tb = (i == n - 1) ? t1 : t0_step + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // Check for events occurrence: sign change between ga and gb\n                // Use != comparison for robustness against zero values (detects crossing zero)\n                if ((ga >= 0) != (gb >= 0)) {\n                    // There is a sign change: an event is expected during this sub-step [ta, tb]\n\n                    // Determine variation direction, with respect to the integration direction, using ga and gb\n                    increasing = gb >= ga;\n\n                    // Define the function for the root finder, evaluating g(t) using the interpolator\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                // Wrap exceptions to fit UnivariateRealFunction interface\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n\n                    // Use Brent method to find the root (event time)\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence); // Set accuracy based on event state's convergence\n                    solver.setMaximalIterationCount(maxIterationCount); // Set max iterations based on event state\n\n                    // Find the root within the sub-interval [ta, tb] or [tb, ta] depending on direction\n                    // BrentSolver requires the interval endpoints to have different signs, which\n                    // the condition (ga >= 0) != (gb >= 0) ensures (unless both are exactly 0).\n                    final double root = forward ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n\n                    // Check if the found root is the same as the last known event time (within convergence)\n                    if (!Double.isNaN(previousEventTime) && (Math.abs(root - previousEventTime) <= convergence)) {\n                        // Root is too close to the previous event time, likely a duplicate detection. Ignore it.\n                        // Advance to the next sub-interval for checking\n                        ta = tb;\n                        ga = gb;\n                        continue; // Continue to the next sub-interval\n                    }\n\n                    // We have found a new event candidate time. Store it.\n                    pendingEventTime = root;\n                    pendingEvent = true;\n\n                    // Check if the proposed step end time (t1) is very close to this event time\n                    if (Math.abs(t1 - pendingEventTime) <= convergence) {\n                        // The step ends precisely at the event time. The step is acceptable.\n                        // Return false to indicate the step should be accepted.\n                        return false;\n                    } else {\n                        // The step crosses the event time but does not end there.\n                        // The step must be rejected so the integrator can shorten it to end at the event.\n                        // Return true to indicate the step should be rejected.\n                        return true;\n                    }\n\n                } else {\n                    // No sign change detected in this sub-interval [ta, tb].\n                    // Advance the start point and value for the next sub-interval check.\n                    ta = tb;\n                    ga = gb;\n                }\n            } // End of sub-interval loop\n\n            // No event was detected during the entire step interval [t0_step, t1].\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            // Return false to indicate the step is acceptable (no event needing step rejection).\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            // Handle exceptions potentially thrown by the UnivariateRealFunction wrapper\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                // Unwrap and rethrow specific exceptions declared by the method\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                // Unwrap and rethrow specific exceptions declared by the method\n                throw (EventException) cause;\n            }\n            // Wrap other causes or the FunctionEvaluationException itself in an EventException\n            throw new EventException(e);\n        } catch (org.apache.commons.math.ConvergenceException e) {\n            // Handle convergence exception specifically from the Brent solver\n            // This exception is declared in the method signature.\n            throw new ConvergenceException(e);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}