{
    "generation": "import org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.analysis.solvers.BrentSolver;\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.sampling.StepInterpolator;\nimport java.lang.Math; // For nextafter, abs, ceil\n\n// No other imports seem necessary based on the original code and the fix.\n\n// Class definition and other methods are omitted\n\n    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n            if (Math.abs(dt) < convergence) {\n                // we cannot select a time range shorter than convergence\n                return false;\n            }\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(dt) / maxCheckInterval));\n            final double h  = dt / n;\n\n            double ta = t0;\n            double ga = g0;\n\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence: sign change relative to the beginning of the *step* (t0)\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this substep [ta, tb]\n\n                    // create a function wrapper for the G function\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (ConvergenceException e) {\n                                // It is not clear how ConvergenceException can be triggered within handler.g\n                                // but we wrap it for safety, following the original pattern.\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n\n                    // Define interval endpoints for solver, ensuring tMin < tMax\n                    double tMin = ta;\n                    double tMax = tb;\n                    double gMin = ga;\n                    double gMax = gb;\n                    if (!forward) { // Integration is backward\n                        tMin = tb; tMax = ta;\n                        gMin = gb; gMax = ga;\n                    }\n\n                    // Adjust interval if endpoints have zero values, to ensure bracketing for the solver.\n                    if (gMin == 0.0) {\n                        // Avoid starting search from a known root. Move start slightly into the interval.\n                        double tMinOrig = tMin;\n                        tMin = Math.nextafter(tMin, tMax);\n                        // Check if interval became invalid\n                        if (tMin >= tMax) {\n                             // Cannot create a positive-width interval. The sub-step is tiny.\n                             // Skip this sub-step as no root can be reliably found.\n                             ta = tb; ga = gb; continue;\n                        }\n                        gMin = f.value(tMin);\n                        // If gMin is still 0, the function is likely flat zero - solver cannot work.\n                        if (gMin == 0.0) {\n                            throw new ConvergenceException(\"Function seems to be zero near event time {0}\", tMinOrig);\n                        }\n                    }\n                    if (gMax == 0.0) {\n                        // Avoid ending search at a known root. Move end slightly into the interval.\n                        double tMaxOrig = tMax;\n                        tMax = Math.nextafter(tMax, tMin);\n                         // Check if interval became invalid\n                         if (tMax <= tMin) {\n                            // Cannot create a positive-width interval.\n                            ta = tb; ga = gb; continue;\n                         }\n                        gMax = f.value(tMax);\n                         // If gMax is still 0, the function is likely flat zero.\n                        if (gMax == 0.0) {\n                            throw new ConvergenceException(\"Function seems to be zero near event time {0}\", tMaxOrig);\n                        }\n                    }\n\n                    // After potential shifts for zero endpoints, check bracketing again.\n                    if ((gMin > 0) == (gMax > 0)) {\n                        // Signs are the same. This implies a problem unless it's the known corner case.\n                        // Corner case: ta == t0 is a previous root, and g0Positive is misleading relative to gb.\n                        // It happens if the previous step search landed exactly on the root, and g0 was set to 0.\n                        // The check g0Positive ^ (gb >= 0) might pass, but ga=0, gb has the 'wrong' sign for bracketing.\n                        boolean cornerCase = (ta == t0 && !Double.isNaN(previousEventTime) && Math.abs(ta - previousEventTime) <= convergence);\n\n                        if (cornerCase) {\n                             // The interval start ta was the root found previously. ga is 0.\n                             // We must shift ta slightly towards tb to see if the function changes sign as expected.\n                             double ta_orig = ta; // Original start of sub-interval (previous root)\n\n                             // Shift ta slightly into the interval [ta, tb] or [tb, ta]\n                             ta = Math.nextafter(ta_orig, tb);\n\n                             // Check if shift was effective and didn't jump over tb\n                             if (ta == ta_orig || (forward && ta >= tb) || (!forward && ta <= tb)) {\n                                 // Shift failed or interval too small\n                                 throw new ConvergenceException(\"Cannot shift start of interval in corner case at time {0}\", ta_orig);\n                             }\n                             ga = f.value(ta); // Recompute ga at the shifted point\n                             if (ga == 0.0) { // Still zero after shift? Problematic function.\n                                 throw new ConvergenceException(\"Function is zero after shifting start of interval in corner case at time {0}\", ta_orig);\n                             }\n\n                             // Re-assign solver variables based on the shifted ta/ga\n                             // Note: tb and gb remain the same.\n                             if (forward) {\n                                tMin = ta; tMax = tb; gMin = ga; gMax = gb;\n                             } else {\n                                tMin = tb; tMax = ta; gMin = gb; gMax = ga;\n                             }\n\n                             // Check bracketing one last time after corner case shift\n                             if ((gMin > 0) == (gMax > 0)) {\n                                   // Even after shifting away from the problematic start point, no bracket found.\n                                   // This indicates the g0Positive ^ (gb>=0) check was misleading, function might be tangent.\n                                   throw new ConvergenceException(\"Cannot bracket root even after trying corner case fix. g({0})={1}, g({2})={3}\", tMin, gMin, tMax, gMax);\n                             }\n                             // Bracketing holds now, proceed to solver below.\n                         } else {\n                             // Not the specific corner case, but signs are the same.\n                             // This should not happen if g0Positive ^ (gb >= 0) was true and ga, gb are non-zero.\n                             throw new ConvergenceException(\"Interval endpoints do not bracket the root despite sign change detection relative to previous event. g({0})={1}, g({2})={3}\", tMin, gMin, tMax, gMax);\n                         }\n                    }\n\n                    // Determine the crossing direction based on the final interval ends gMin/gMax.\n                    // This is needed for stepAccepted() later.\n                    // gMax corresponds to tMax, gMin to tMin, and tMax > tMin. g increases if gMax >= gMin.\n                    increasing = gMax >= gMin;\n\n                    // Solve for the root in the (potentially adjusted) bracketing interval [tMin, tMax]\n                    final double root = solver.solve(f, tMin, tMax);\n\n                    // Check if the found root is the same as the previous event\n                    if (!Double.isNaN(previousEventTime) && (Math.abs(root - previousEventTime) <= convergence)) {\n                        // Root is essentially the previous event; ignore it and proceed to next sub-interval.\n                        // Update the start of the next sub-interval.\n                        ta = tb;\n                        ga = gb;\n                        // Do NOT change g0Positive here. It reflects the state at t0.\n                    } else {\n                        // Found a new event (or the first event).\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // This step ends precisely at an event we previously detected\n                            // but couldn't accept (because the step was rejected). Now we can accept it.\n                            return false; // Accept the step.\n                        }\n                        // We found a new event before the end of the proposed step t1.\n                        // Store it and reject the step.\n                        pendingEvent = true;\n                        return true; // Reject the step.\n                    }\n\n                } else {\n                    // no sign change detected in this substep using g0Positive: regular advance\n                    ta = tb;\n                    ga = gb;\n                }\n            } // End of sub-interval loop\n\n            // no event detected during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            // Handle exceptions potentially wrapped by the function evaluation\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            } else if ((cause != null) && (cause instanceof ConvergenceException)) {\n                 throw (ConvergenceException) cause;\n            }\n            // Wrap other exceptions from function evaluation (like potential RuntimeException)\n            throw new EventException(e);\n        } catch (ConvergenceException ce) {\n             // Catch convergence exceptions potentially thrown directly by the solver\n             throw ce;\n        }\n\n    } // End of evaluateStep method",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}