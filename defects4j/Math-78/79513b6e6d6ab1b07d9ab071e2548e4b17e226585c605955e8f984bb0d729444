{
    "generation": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                // The condition `g0Positive ^ (gb >= 0)` checks for sign change from the overall step start (t0) to the current substep end (tb).\n                // This might lead to bracketing issues if g(t0) is 0 and the actual sign changes later (or there's a numerical drift).\n                // We need to ensure that the actual interval endpoints for the solver have strictly opposite signs.\n                if (g0Positive ^ (gb >= 0)) {\n                    // There is a sign change from t0 to tb, so an event is expected.\n                    // We need to establish a bracketing interval [solverA, solverB] for the root solver.\n                    double solverA = ta;\n                    double solverB = tb;\n                    boolean bracketingEnsured = false; // Flag to know if bracketing is fixed for the solver\n\n                    // Case 1: ga (g(ta)) is near zero AND ta is effectively the previous event time.\n                    // This means `ta` is an event point. We need to look for the *next* event.\n                    // To do this, we slightly shift `solverA` past `ta` to get a non-zero starting point.\n                    if (Math.abs(ga) < convergence && Math.abs(ta - previousEventTime) < convergence) {\n                        final double tinyShift = Math.copySign(convergence, h); // Shift in the direction of integration\n                        interpolator.setInterpolatedTime(ta + tinyShift);\n                        final double gAtShiftedTa = handler.g(ta + tinyShift, interpolator.getInterpolatedState());\n                        \n                        // If after the shift, there's no sign change between g(shifted_ta) and g(tb),\n                        // it means the event at ta was already handled, and no new event was found in this sub-interval.\n                        if (!((gAtShiftedTa >= 0) ^ (gb >= 0))) {\n                             ta = tb;\n                             ga = gb;\n                             continue; // Skip to next iteration of loop as no event found in this substep\n                        }\n                        // Otherwise, use the shifted ta for the solver's lower bound to ensure bracketing.\n                        solverA = ta + tinyShift;\n                        bracketingEnsured = true;\n                    }\n                    \n                    // Case 2: `g0Positive ^ (gb >= 0)` was true, but the actual `g(ta)` and `g(tb)` have the same sign.\n                    // This can happen if `g0Positive` is true because `g(t0)` was 0, but `g(ta)` (at a slightly different `ta`)\n                    // became non-zero with the same sign as `gb`.\n                    // This means there is no actual sign change (and thus no event) within `[ta, tb]`.\n                    // This check is performed only if not already handled by Case 1.\n                    if (!bracketingEnsured) {\n                        interpolator.setInterpolatedTime(solverA); // Ensure interpolator is at solverA for g(solverA) evaluation\n                        if ((handler.g(solverA, interpolator.getInterpolatedState()) >= 0) == (gb >= 0)) {\n                            // If signs are the same, there's no event in this substep.\n                            ta = tb;\n                            ga = gb;\n                            continue; // Skip to next iteration of loop\n                        }\n                    }\n\n                    // variation direction, with respect to the integration direction\n                    // This line remains as it uses the current ga and gb values for the trend.\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    \n                    // Pass the potentially adjusted `solverA` to the solver to ensure proper bracketing.\n                    final double root = (solverA <= solverB) ? solver.solve(f, solverA, solverB) : solver.solve(f, solverB, solverA);\n                    \n                    // The following checks compare the found root against the original `ta` (start of substep)\n                    // and `previousEventTime` to determine if a new event was found or an old one re-detected.\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}