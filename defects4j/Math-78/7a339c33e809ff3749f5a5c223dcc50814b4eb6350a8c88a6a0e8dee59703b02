{
    "generation": "import org.apache.commons.math.ConvergenceException;\nimport org.apache.commons.math.FunctionEvaluationException;\nimport org.apache.commons.math.analysis.UnivariateRealFunction;\nimport org.apache.commons.math.analysis.solvers.BrentSolver;\nimport org.apache.commons.math.ode.DerivativeException;\nimport org.apache.commons.math.ode.sampling.StepInterpolator;\n// Assuming EventException, handler, t0, g0, previousEventTime, convergence, maxCheckInterval,\n// pendingEventTime, pendingEvent, increasing, forward are accessible member fields/methods.\nimport org.apache.commons.math.util.FastMath;\n\n    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n\n             // Ensure step is large enough to evaluate potential events\n             if (FastMath.abs(dt) < FastMath.ulp(t0) + FastMath.ulp(t1)) {\n                 // Step size is numerically zero, cannot evaluate.\n                 pendingEvent     = false;\n                 pendingEventTime = Double.NaN;\n                 return false;\n             }\n\n            final int    n  = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n            final double h  = dt / n;\n\n            double ta = t0;\n            double ga = g0;\n\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep interval [ta, tb]\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence using values ga and gb at the start and end of the sub-step\n                if (((ga >= 0) ^ (gb >= 0)) && ga != gb) { // Check for sign change; also exclude ga=gb=0 case.\n                    // Sign change detected in the interval [ta, tb]. Find the root.\n\n                    // variation direction, with respect to the integration direction\n                    increasing = (gb >= ga);\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                // Wrap exceptions type FunctionEvaluationException expects\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                // Wrap exceptions type FunctionEvaluationException expects\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n\n                    double root;\n                    // Check if ta coincides with a previous event time\n                    boolean pastEventAtTa = !Double.isNaN(previousEventTime) && (FastMath.abs(ta - previousEventTime) <= convergence);\n\n                    // Handle cases where BrentSolver might fail due to g=0 at interval endpoints\n                    if (ga == 0.0 && pastEventAtTa) {\n                        // g(ta)=0 and ta is the previous event time.\n                        // The sign changed gb!=0, so g is crossing zero at ta.\n                        // We must search for the *next* root in (ta, tb].\n                        // Shift ta slightly into the interval to avoid BrentSolver issue at ga=0.\n                        final double smallShift = FastMath.max(convergence * 0.5, FastMath.ulp(ta) * 100); // Use a small, significant shift\n                        double ta_shifted = forward ? (ta + smallShift) : (ta - smallShift);\n\n                        // Ensure ta_shifted is strictly between ta and tb, otherwise skip search\n                        if (forward ? (ta_shifted < tb) : (ta_shifted > tb)) {\n                            interpolator.setInterpolatedTime(ta_shifted);\n                            double ga_shifted = handler.g(ta_shifted, interpolator.getInterpolatedState());\n\n                            // If the shifted interval brackets the root, solve it.\n                            if (ga_shifted * gb < 0) {\n                                root = (ta_shifted <= tb) ? solver.solve(f, ta_shifted, tb) : solver.solve(f, tb, ta_shifted);\n                            } else {\n                                // Root must be at ta, or between ta and shifted point, or tangent, etc.\n                                // Cannot reliably find another root. Treat as root = ta.\n                                // This root value (ta) will be ignored by later logic because pastEventAtTa is true.\n                                root = ta;\n                            }\n                        } else {\n                            // Interval [ta, tb] too small to shift reliably. Treat as root = ta.\n                            root = ta;\n                        }\n                    } else if (ga == 0.0) {\n                        // Event detected exactly at ta, and it's not the previous event time.\n                        root = ta;\n                    } else if (gb == 0.0) {\n                        // Event detected exactly at tb.\n                        root = tb;\n                    } else {\n                        // Standard case: ga and gb are non-zero with opposite signs. Solve [ta, tb].\n                         root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    }\n\n\n                    // Process the root: ignore if it's the same as the previous event time.\n                    if (Double.isNaN(previousEventTime) || (FastMath.abs(previousEventTime - root) > convergence)) {\n                        // Root is considered a new event (distinct from the previous one).\n                        pendingEventTime = root;\n                        if (pendingEvent && (FastMath.abs(t1 - pendingEventTime) <= convergence)) {\n                            // This step ends exactly on an event we were already pending. Accept the step.\n                            return false;\n                        }\n                        // Found a new event before the end of the proposed step t1. Reject the step.\n                        pendingEvent = true;\n                        return true;\n                    }\n                    // else: Root is the same as previous event time (within convergence). Ignore it.\n                    // This occurs if root=ta was chosen in the (ga == 0.0 && pastEventAtTa) case,\n                    // or if root=tb and tb happened to be the previousEventTime,\n                    // or if the solver found the previousEventTime again.\n                    // Continue checking the rest of the step by proceeding to the next sub-interval.\n\n                } // end if (sign change detected)\n\n                // Update start of next sub-interval\n                ta = tb;\n                ga = gb;\n\n            } // End of loop over sub-steps\n\n            // No *new* event detected during the whole step evaluation\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            // Handle exceptions potentially wrapped by the UnivariateRealFunction\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            } else if ((cause != null) && (cause instanceof ConvergenceException)) {\n                 // Should BrentSolver wrap ConvergenceException in FunctionEvaluationException? Unlikely.\n                 // If it did, unwrap it here.\n                 throw (ConvergenceException) cause;\n             }\n            // Wrap other/unexpected FunctionEvaluationExceptions as EventExceptions\n            throw new EventException(e);\n        } catch (ConvergenceException e) {\n            // Catch ConvergenceException directly from solver.solve if not wrapped (most likely case)\n            // This indicates an issue locating the root.\n            throw e;\n        }\n        // Other declared exceptions (DerivativeException, EventException) might be thrown\n        // directly by handler.g or interpolator calls outside the UnivariateRealFunction wrapper.\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}