{
    "generation": "    /** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step (this implies the step should be\n     * rejected)\n     * @exception DerivativeException if the interpolator fails to\n     * compute the switching function somewhere within the step\n     * @exception EventException if the switching function\n     * cannot be evaluated\n     * @exception ConvergenceException if an event cannot be located\n     */\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            // n is the number of substeps based on maxCheckInterval.\n            // The step [t0, t1] is divided into n substeps.\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            // tSubStart and gSubStart represent the time and g-value at the beginning of the current substep.\n            // They are initialized with t0 and g0 (from the start of the overall step).\n            // They will be updated at the end of each iteration to become tSubEnd and gSubEnd.\n            double tSubStart = t0;\n            double gSubStart = g0;\n            boolean gSubStartPositive = (g0 >= 0);\n\n            // Handle the case where the starting point t0 is exactly an event point.\n            // If g0 is zero and it's either the first event ever, or the previously handled event,\n            // we should effectively start searching *after* this event point to find subsequent events.\n            if (g0 == 0 && (Double.isNaN(previousEventTime) || Math.abs(t0 - previousEventTime) <= convergence)) {\n                // Shift the effective start point of the first substep slightly past t0.\n                tSubStart += (interpolator.isForward() ? convergence : -convergence);\n                // Update interpolator's time and re-evaluate g at the new start point.\n                interpolator.setInterpolatedTime(tSubStart);\n                gSubStart = handler.g(tSubStart, interpolator.getInterpolatedState());\n                gSubStartPositive = (gSubStart >= 0);\n            }\n\n\n            for (int i = 0; i < n; ++i) {\n\n                // Calculate the end time of the current substep.\n                // tSubEnd should be t0 + (i+1)*h. For the last substep, ensure it matches t1 precisely.\n                double tSubEnd = t0 + (i + 1) * h;\n                if (i == n - 1) {\n                    tSubEnd = t1; // Ensure the last substep ends exactly at t1 to avoid floating point issues.\n                }\n\n                interpolator.setInterpolatedTime(tSubEnd);\n                final double gSubEnd = handler.g(tSubEnd, interpolator.getInterpolatedState());\n                boolean gSubEndPositive = (gSubEnd >= 0);\n\n                // Check for event occurrence within the current substep [tSubStart, tSubEnd].\n                // A sign change means an event might have occurred.\n                if (gSubStartPositive ^ gSubEndPositive) {\n                    // A sign change is detected, meaning an event is expected.\n\n                    // Determine the direction of variation of g(t) over this substep.\n                    increasing = gSubEnd >= gSubStart;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n\n                    // Find the root using the Brent solver within the current substep [tSubStart, tSubEnd].\n                    // BrentSolver requires function values at endpoints to have strictly opposite signs.\n                    // The `if (gSubStartPositive ^ gSubEndPositive)` check already ensures they are \"different\".\n                    // However, if one is exactly zero, this is not strictly opposite, and BrentSolver might fail.\n                    // The initial adjustment of tSubStart (if g0 == 0) addresses the main problem case.\n                    final double root = (tSubStart <= tSubEnd) ? solver.solve(f, tSubStart, tSubEnd) : solver.solve(f, tSubEnd, tSubStart);\n\n                    // Check if the found root is either a past event already accounted for, or a new event.\n                    if ((Math.abs(root - tSubStart) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // We have either found nothing or found (again ?) a past event. We ignore it.\n                        // Advance to the end of this substep for the next iteration.\n                        tSubStart = tSubEnd;\n                        gSubStart = gSubEnd;\n                        gSubStartPositive = gSubEndPositive;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        // This is a new event or an event that has moved significantly.\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // We were already waiting for this event which was found during a previous\n                            // call for a step that was rejected. This step must now be accepted\n                            // since it properly ends exactly at the event occurrence.\n                            return false;\n                        }\n                        // Either we were not waiting for the event or it has moved, so the step must be rejected.\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // No sign change within this substep: no event for now.\n                    // Advance to the end of this substep for the next iteration.\n                    tSubStart = tSubEnd;\n                    gSubStart = gSubEnd;\n                    gSubStartPositive = gSubEndPositive;\n                }\n            }\n\n            // No event found during the whole step.\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}