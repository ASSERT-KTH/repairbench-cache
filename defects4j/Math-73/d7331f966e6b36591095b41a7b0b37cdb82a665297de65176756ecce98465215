{
    "generation": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // check that at least one subinterval brackets a root\n    if (yMin * yMax > 0 && yMin * yInitial > 0 && yMax * yInitial > 0) {\n        throw new IllegalArgumentException(\n            \"Function values at endpoints and initial do not have different signs. No bracketing.\");\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yMin * yInitial < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    // reduce interval if min and max bracket the root\n    if (yMin * yMax < 0) {\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n    }\n\n    // if none of the above, the function values all have same sign and we already threw exception before, but safety\n    throw new IllegalArgumentException(\n        \"Function values at endpoints and initial do not have different signs. No bracketing.\");\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}