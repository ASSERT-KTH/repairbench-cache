{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n\n        // On the very first iteration compute the scaling of the problem\n        // from the *original* jacobian, before we do any QR decompositions.\n        if (firstIteration) {\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = 0;\n                for (int i = 0; i < rows; ++i) {\n                    double v = jacobian[i][k];\n                    dk += v * v;\n                }\n                dk = FastMath.sqrt(dk);\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                diag[k] = dk;\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n            }\n            xNorm = FastMath.sqrt(xNorm);\n            delta = (xNorm == 0) ?\n                    initialStepBoundFactor :\n                    initialStepBoundFactor * xNorm;\n        }\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        qrDecomposition();\n\n        // compute Q^T * residuals\n        qTy(residuals);\n\n        // now that Q^T * residuals is done we don't need Q any more;\n        // let 'jacobian' contain the R matrix (in the original column order).\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            // <--- FIX: use diagR[k], not diagR[pk] --->\n            jacobian[k][pk] = diagR[k];\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = FastMath.max(maxCosine,\n                                             FastMath.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = FastMath.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop: adjust lmPar until we get a sufficiently good step\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmp = residuals;\n            residuals = oldRes;\n            oldRes    = tmp;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = FastMath.sqrt(lmNorm);\n            if (firstIteration) {\n                delta = FastMath.min(delta, lmNorm);\n            }\n\n            // evaluate at x + p\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // actual reduction\n            double actRed = -1;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1 - r * r;\n            }\n\n            // predicted reduction and directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dj = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dj;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 /= pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of actual to predicted\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmpRatio =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmpRatio < 0.1)) {\n                    tmpRatio = 0.1;\n                }\n                delta = tmpRatio * FastMath.min(delta, 10 * lmNorm);\n                lmPar /= tmpRatio;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta *= 2;\n                lmPar *= 0.5;\n            }\n\n            // successful iteration?\n            if (ratio >= 1.0e-4) {\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double d = diag[k] * point[k];\n                    xNorm += d * d;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n            } else {\n                // restore\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmp      = residuals;\n                residuals = oldRes;\n                oldRes    = tmp;\n            }\n\n            // check for convergence\n            if (checker == null) {\n                if (((FastMath.abs(actRed) <= costRelativeTolerance) &&\n                     (preRed <=    costRelativeTolerance) &&\n                     (ratio <= 2.0)) ||\n                    (delta <= parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n\n            // stringent tolerances\n            if ((FastMath.abs(actRed) <= 2.2204e-16 &&\n                 preRed <=        2.2204e-16 &&\n                 ratio <=         2.0)) {\n                throw new OptimizationException(\n                    LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                    costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\n                    LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                    parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\n                    LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                    orthoTolerance);\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}