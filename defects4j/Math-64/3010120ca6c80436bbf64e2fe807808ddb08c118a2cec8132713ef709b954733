{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        VectorialPointValuePair previous = current;\n\n        // compute the jacobian at the current point\n        updateJacobian();\n        // on the first iteration, scale the point using the norms of the jacobian columns\n        if (firstIteration) {\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                diag[k] = dk;\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n            }\n            xNorm = Math.sqrt(xNorm);\n            delta = (xNorm == 0) ?\n                    initialStepBoundFactor :\n                    (initialStepBoundFactor * xNorm);\n        }\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        qrDecomposition();\n\n        // compute Q^T * residuals\n        qTy(residuals);\n        // now we don't need Q, so jacobian holds R except the diagonals\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        // check orthogonality between J columns and the residuals\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary for subsequent iterations\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop: adjust LM parameter until a successful step is found\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the current point and cost\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter lmPar and direction lmDir\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the candidate step and its norm\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj]  = oldX[pj] + lmDir[pj];\n                double s   = diag[pj] * lmDir[pj];\n                lmNorm    += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // if this is the very first iteration, bound delta by lmNorm\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at the trial point\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // actual reduction (relative in terms of sum of squares)\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // predicted reduction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj    = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2    = previousCost * previousCost;\n            coeff1       /= pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of actual to predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update step bound and lmPar\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration\n            if (ratio >= 1.0e-4) {\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xk = diag[k] * point[k];\n                    xNorm    += xk * xk;\n                }\n                xNorm = Math.sqrt(xNorm);\n            } else {\n                // restore the previous state\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n\n            // convergence check\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                     (preRed <= costRelativeTolerance) &&\n                     (ratio <= 2.0)) ||\n                    (delta <= parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n\n            // stringent tolerance checks\n            if ((Math.abs(actRed) <= 2.2204e-16) &&\n                (preRed <= 2.2204e-16) &&\n                (ratio <= 2.0)) {\n                throw new OptimizationException(\n                    LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                    costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\n                    LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                    parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\n                    LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                    orthoTolerance);\n            }\n\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}