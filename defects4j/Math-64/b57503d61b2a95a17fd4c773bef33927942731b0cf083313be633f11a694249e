{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows]; // Should be objective.length or rows? Assuming rows is correct.\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost(); // Updates cost, objective, and residuals fields\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        // current holds the point and objective vector (residuals)\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current; // Save previous state.\n            updateJacobian(); // Compute Jacobian at current point\n            qrDecomposition(); // Compute QR decomp of Jacobian, updates jacobian[][], diagR[], jacNorm[], permutation[]\n\n            // compute Q^T.res\n            // qTy modifies 'residuals' in-place to hold Q^T * residuals_old\n            // where residuals_old are the residuals from the 'previous' state.\n            qTy(previous.getValueReference()); // Use objective from 'previous' state as input to qTy\n\n            // Store Q^T.res in work1, as 'residuals' field might be needed later\n            // or modified unexpectedly. Assuming qTy modifies its input.\n            // Let's assume qTy MODIFIES the input array 'residuals'.\n            // We need the residuals from the 'previous' state for qTy.\n            // Let's make a copy before calling qTy, or pass previous.getValueReference() if qTy doesn't modify it.\n            // Assuming qTy *modifies* its input argument 'y' to store Q^T*y.\n            // We need Q^T * objective_previous for LM parameter calculation.\n            // Let's store it in work1.\n            System.arraycopy(previous.getValueReference(), 0, work1, 0, rows);\n            qTy(work1); // work1 now holds Q^T * objective_previous\n\n            // now jacobian contains R in its upper part, Q is defined implicitly\n            // copy R diagonal into jacobian (just to be sure?)\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * point[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality: max(|(J^T*r)_j| / (||J_j|| * ||r||)) = max(|(R^T*Q^T*r)_j| / (||J_j|| * ||r||))\n            double maxCosine = 0;\n            if (cost != 0) { // cost = ||r_old||^2 = previousCost\n                double currentResidualsNorm = Math.sqrt(cost);\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj]; // ||J_j||\n                    if (s != 0) {\n                        // Compute sum = (R^T * (Q^T*r))_j = sum_{i=0}^{j} R_ij * (Q^T*r)_i\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += jacobian[i][pj] * work1[i]; // R_ij * (Q^T*r)_i from work1\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * currentResidualsNorm)); // Fixed denominator\n                    }\n                }\n            } // If cost is 0, maxCosine remains 0.\n\n            if (maxCosine <= orthoTolerance) {\n                return current; // Converged (gradient is orthogonal to residuals)\n            }\n\n            // rescale diag based on max encountered column norms\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // inner loop - search for a step\n            double preRed = 0; // Declare here for use in convergence check\n            double dirDer = 0; // Declare here for use in convergence check\n            double actRed = -1.0; // Declare here for use in convergence check\n\n            // The state (point, cost, objective) corresponds to 'previous'.\n            // work1 holds Q^T * objective_previous.\n            System.arraycopy(objective, 0, oldRes, 0, rows); // Store objective_previous in oldRes for restoration\n\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state parameters before trying a step\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = point[pj]; // Save current point parameters (should be same as previous.getPoint())\n                }\n                double previousCost = cost; // Save current cost (should be same as previous.getValue()^2 norm)\n\n                // determine the Levenberg-Marquardt parameter and direction lmDir = p\n                // uses qy = work1 = Q^T*objective_previous\n                determineLMParameter(work1, delta, diag, lmDir, work2, work3); // lmDir holds p, work2/work3 are temps\n\n                // compute the new point: x_new = x_old + p = oldX + lmDir\n                // and the norm of the scaled step ||D*p|| = ||D*lmDir||\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    // point[pj] = oldX[pj] + lmDir[pj]; // Use p directly: x_new = x_old + p\n                    // Original code negated lmDir. Let's assume determineLMParameter returns p and we add it.\n                    // Reverting to original negation logic just in case it was intentional:\n                     lmDir[pj] = -lmDir[pj];\n                     point[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj]; // Use negated p for norm\n                    lmNorm  += s * s;\n                }\n                lmNorm = Math.sqrt(lmNorm);\n\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at the new point x_new\n                updateResidualsAndCost(); // Updates cost = ||r_new||^2, objective = r_new.\n                current = new VectorialPointValuePair(point, objective); // Create pair for the new state\n\n                // compute the scaled actual reduction: (||r_old||^2 - ||r_new||^2) / ||r_old||^2\n                actRed = -1.0;\n                if (previousCost > 1e-20) { // Use standard formula for reduction in sum of squares\n                    actRed = 1.0 - cost / previousCost;\n                } else if (cost == 0) {\n                    actRed = 1.0;\n                } // Otherwise actRed remains -1.0 (failure)\n\n\n                // compute the scaled predicted reduction: (||J*p||^2 + 2*lmPar*||D*p||^2) / ||r_old||^2\n                // Use p = -lmDir (since lmDir was negated above)\n                for (int j = 0; j < solvedCols; ++j) { // work2 = R * (-lmDir) = R*p\n                    int pj = permutation[j];\n                    double dirJ = -lmDir[pj]; // Use p = -lmDir\n                    work2[j] = 0; // Use work2 as temp for R*p\n                    for (int i = 0; i <= j; ++i) {\n                        work2[i] += jacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work2[j] * work2[j]; // coeff1 = ||R*p||^2 = ||J*p||^2\n                }\n                double pc2 = previousCost; // Denominator is ||r_old||^2\n                preRed = 0; // Initialize preRed\n                dirDer = 0; // Initialize dirDer\n                ratio = 0; // Initialize ratio\n                if (pc2 > 1e-20) { // Avoid division by zero\n                     coeff1 = coeff1 / pc2;\n                     // lmNorm was computed using negated lmDir, so it's ||D*(-p)|| = ||D*p||. Okay.\n                     double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                     preRed = coeff1 + 2 * coeff2;\n                     dirDer = -(coeff1 + coeff2);\n                     ratio = (preRed == 0) ? 0 : (actRed / preRed);\n                } // If previousCost was tiny, ratio remains 0 (failure).\n\n                // update the step bound delta, lmPar\n                if (ratio <= 0.25) { // Step failed or poor\n                    double tmp = 0.5; // Default factor\n                    if (actRed < 0) { // Cost increased, use adaptive factor\n                        // Ensure dirDer is safe before division\n                        if (dirDer + 0.5 * actRed != 0) {\n                            tmp = 0.5 * dirDer / (dirDer + 0.5 * actRed);\n                        }\n                    }\n                    if ((cost >= previousCost) || (tmp < 0.1)) { // If cost increased or factor too small\n                         tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp; // Increase lmPar\n                } else if ((lmPar == 0) || (ratio >= 0.75)) { // Step good\n                    delta = 2 * lmNorm; // Increase delta based on step norm\n                    lmPar *= 0.5; // Decrease lmPar\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) { // SUCCESS\n                    firstIteration = false;\n                    // Update xNorm using the new point\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n\n                    // ** MOVED CONVERGENCE CHECK HERE (Primary Fix) **\n                    if (checker==null) {\n                        if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                            (preRed <= costRelativeTolerance) &&\n                            (ratio <= 2.0)) ||\n                           (delta <= parRelativeTolerance * xNorm)) {\n                           return current; // Return NEW successful state\n                       }\n                    } else {\n                         // Use previous state and current (new successful) state\n                        if (checker.converged(getIterations(), previous, current)) {\n                            return current; // Return NEW successful state\n                        }\n                    }\n\n                    // Check stringent ftol\n                    if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                        throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                costRelativeTolerance);\n                    }\n                    // Break inner loop on success\n                     break; // Exit the inner loop for ratio\n\n                } else { // FAILURE\n                    // Restore state to previous state (before this inner step)\n                    cost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        point[pj] = oldX[pj];\n                    }\n                    // Restore objective array from saved oldRes\n                    System.arraycopy(oldRes, 0, objective, 0, rows);\n                    // Note: 'current' still holds the failed state, but won't be returned or used further.\n                    // The state fields (point, cost, objective) are now reset to 'previous' state values.\n                }\n\n                // Check stringent xtol (using delta and xNorm from last success)\n                // Add epsilon to xNorm to avoid division by zero / issue when xNorm is 0\n                if (delta <= 2.2204e-16 * (xNorm + 2.2204e-16)) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                            parRelativeTolerance);\n                }\n                 // Inner loop continues if ratio < 1.0e-4\n\n            } // End inner loop\n\n             // Check stringent gtol convergence outside inner loop\n             if (maxCosine <= 2.2204e-16)  {\n                  throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n             }\n\n            // Prepare for next outer iteration: 'current' should reflect the state after successful inner loop\n            // The 'current' variable was updated inside the inner loop on the last (successful) step evaluation.\n            // If inner loop finished successfully, 'current' holds the latest successful state.\n\n        } // End outer loop\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}