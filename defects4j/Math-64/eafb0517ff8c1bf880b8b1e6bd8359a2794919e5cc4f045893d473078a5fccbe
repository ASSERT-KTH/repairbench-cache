{
    "generation": "import java.util.Arrays; // Make sure this import is present or use full qualifier\n\n// The following code assumes the context of the AbstractLeastSquaresOptimizer class\n// and that necessary fields (rows, cols, point, objective, residuals, cost, jacobian,\n// solvedCols, diagR, jacNorm, beta, permutation, lmDir, lmPar, initialStepBoundFactor,\n// costRelativeTolerance, parRelativeTolerance, orthoTolerance, checker) and methods\n// (updateResidualsAndCost, updateJacobian, qrDecomposition, qTy, determineLMParameter,\n// incrementIterationsCounter, getIterations, setCost) are available.\n\n    /** {@inheritDoc} */\n    @Override\n    protected VectorialPointValuePair doOptimize()\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        // arrays shared with the other private methods\n        solvedCols  = Math.min(rows, cols);\n        diagR       = new double[cols];\n        jacNorm     = new double[cols];\n        beta        = new double[cols];\n        permutation = new int[cols];\n        lmDir       = new double[cols]; // Stores step p'\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[cols];\n        double[] oldX    = new double[cols];\n        double[] oldRes  = new double[rows];\n        double[] work1   = new double[cols];\n        double[] work2   = new double[cols];\n        double[] work3   = new double[cols];\n\n        // evaluate the function at the starting point and calculate its norm\n        updateResidualsAndCost();\n\n        // outer loop\n        lmPar = 0;\n        boolean firstIteration = true;\n        // Use fields 'point' and 'objective' directly for the current state\n        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n        while (true) {\n            incrementIterationsCounter();\n\n            // compute the Q.R. decomposition of the jacobian matrix\n            VectorialPointValuePair previous = current; // State before this iteration\n            updateJacobian(); // Updates jacobian field based on current point field\n            qrDecomposition(); // Updates jacobian, permutation, diagR fields\n\n            // compute Qt.res\n            // Store current residuals (f(x_k)) temporarily for qTy and saving later\n            double[] currentResiduals = residuals.clone();\n            qTy(residuals); // residuals field now holds Q^T * f(x_k)\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                jacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) { dk = 1.0; }\n                    double xk = dk * point[k]; // Use current point field\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = Math.sqrt(xNorm);\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (cost != 0) { // Use cost field = ||f(x_k)||\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            // Use residuals field which holds Q^T*f(x_k)\n                            sum += jacobian[i][pj] * residuals[i]; // R_ij * (Q^T*res)_i\n                        }\n                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                setCost(cost);\n                return current; // Return last accepted point\n            }\n\n            // rescale diag if necessary\n            for (int j = 0; j < cols; ++j) {\n                diag[j] = Math.max(diag[j], jacNorm[j]);\n            }\n\n            // Store Q^T*f(x_k) (currently in residuals) into oldRes for inner loop usage\n            System.arraycopy(residuals, 0, oldRes, 0, rows);\n            // Restore residuals field to f(x_k) for calculating change later if needed,\n            // though maybe not strictly necessary as cost is saved. Let's proceed without this for now.\n\n            // inner loop - Adjust step size until cost reduction is acceptable\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state of the current point (x_k)\n                System.arraycopy(point, 0, oldX, 0, cols); // Save accepted point x_k\n                double previousCost = cost; // Save cost ||f(x_k)||\n\n                // determine the Levenberg-Marquardt parameter and step p'\n                // This method computes p' and stores it in the lmDir field.\n                // It uses R (in jacobian), Q^T*res (in oldRes), delta, diag.\n                // It also computes lmPar.\n                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n                // compute the trial point x_trial = x_k + P*p' and the norm of the step p'\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    // FIX 1: Removed negation. lmDir is assumed to hold p' directly from determineLMParameter.\n                    // lmDir[pj] = -lmDir[pj]; // Removed this line\n                    point[pj] = oldX[pj] + lmDir[pj]; // Update point field to trial point x_trial\n                    double s = diag[pj] * lmDir[pj]; // diag[pj] * p'_j\n                    lmNorm  += s * s; // lmNorm^2 = || D P p' ||^2\n                }\n                lmNorm = Math.sqrt(lmNorm);\n\n                if (firstIteration) {\n                    delta = Math.min(delta, lmNorm);\n                }\n\n                // evaluate the function at the trial point x_trial (now in 'point' field)\n                // This updates fields: residuals, objective, cost based on trial point\n                updateResidualsAndCost();\n                // 'cost' field now holds ||f(x_trial)||\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * cost < previousCost) { // Compare ||f(x_trial)|| with ||f(x_k)||\n                    double r = cost / previousCost;\n                    actRed = 1.0 - r * r; // (||f(x_k)||^2 - ||f(x_trial)||^2) / ||f(x_k)||^2\n                }\n\n                // compute the scaled predicted reduction\n                // Need work1 = R * p' where p' is in lmDir field\n                // FIX 2: Correct calculation of work1 = R * p'\n                Arrays.fill(work1, 0.0); // Initialize work1 = 0\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double pPrimeJ = lmDir[pj]; // p'_j from lmDir field\n                    // work1[j] = 0; // FIX 2: Removed this line\n                    for (int i = 0; i <= j; ++i) { // R_ij = jacobian[i][pj]\n                        work1[i] += jacobian[i][pj] * pPrimeJ; // work1_i += R_ij * p'_j\n                    }\n                }\n                // work1 now holds R * p'\n\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j]; // || R p' ||^2\n                }\n                double pc2 = previousCost * previousCost; // ||f(x_k)||^2\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2; // lambda * || D P p' ||^2 / pc2\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound delta and lmPar\n                if (ratio <= 0.25) { // Step too big or bad reduction\n                    double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n                } else { // Good reduction (ratio > 0.25)\n                     // If lmPar == 0, avoid division by zero further down. Check not needed here.\n                    if ((lmPar == 0) || (ratio >= 0.75)) { // Very good reduction, increase trust region\n                       delta = 2 * lmNorm;\n                       lmPar *= 0.5;\n                    }\n                    // If 0.25 < ratio < 0.75, delta and lmPar remain unchanged.\n                }\n\n                // check if step was accepted\n                if (ratio >= 1.0e-4) {\n                    // Successful iteration:\n                    // 'point', 'objective', 'residuals', 'cost' fields hold the accepted state (x_{k+1})\n                    // Update the 'current' VectorialPointValuePair to reflect the accepted state\n                    current = new VectorialPointValuePair(point, objective);\n\n                    firstIteration = false; // Update xNorm using the accepted point\n                    xNorm = 0;\n                    for (int k = 0; k < cols; ++k) {\n                        double xK = diag[k] * point[k];\n                        xNorm    += xK * xK;\n                    }\n                    xNorm = Math.sqrt(xNorm);\n\n                    // Check convergence using 'previous' (x_k) and 'current' (x_{k+1})\n                    if (checker != null) {\n                         if (checker.converged(getIterations(), previous, current)) {\n                             setCost(cost); return current;\n                         }\n                    } else { // Default convergence check\n                         if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                              (preRed <= costRelativeTolerance) &&\n                              (ratio <= 2.0)) ||\n                             (delta <= parRelativeTolerance * xNorm)) {\n                             setCost(cost); return current;\n                         }\n                    }\n\n                    // Check termination conditions based on stringent tolerances\n                    if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                         throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n                    }\n\n                } else {\n                    // Failed iteration: Restore state to x_k\n                    // Restore point field from oldX\n                    System.arraycopy(oldX, 0, point, 0, cols);\n                    // Restore cost field from previousCost\n                    cost = previousCost;\n                    // Restore residuals field to f(x_k)? Not strictly needed if cost is restored and\n                    // qTy is performed on the correct residuals at start of outer loop.\n                    // 'current' pair remains pointing to the state from 'previous' iteration.\n                }\n\n                // More termination checks (check regardless of success?)\n                if (delta <= 2.2204e-16 * xNorm) {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n                }\n\n                // Inner loop condition is ratio < 1.0e-4. If ratio >= 1.0e-4, loop terminates.\n            } // End inner loop\n\n            // If we exit the inner loop, it means ratio >= 1.0e-4, step was accepted.\n            // Proceed to next outer iteration (update jacobian etc.)\n        } // End outer loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}