{
    "generation": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        // Simplified version, check backwards up stack from current node position.\n        final int bottom = stack.size() - 1;\n        // Don't walk too far up the tree. Limits the search to prevent hangs or excessive stack use on deep trees.\n        // Calculate the lowest index ('top') to search to. It's the current position ('bottom') minus the max search depth,\n        // but not less than 0. The number of elements searched is bottom - top + 1. We want this to be at most MaxScopeSearchDepth.\n        // So, bottom - top + 1 <= MaxScopeSearchDepth  =>  top >= bottom - MaxScopeSearchDepth + 1\n        final int top = bottom >= MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth + 1 : 0;\n\n        for (int pos = bottom; pos >= top; pos--) {\n            final String elName = stack.get(pos).nodeName();\n            if (inSorted(elName, targetNames))\n                return true; // Found a target element in scope.\n            if (inSorted(elName, baseTypes))\n                return false; // Found a base scope boundary element, stop search.\n            if (extraTypes != null && inSorted(elName, extraTypes))\n                return false; // Found an extra scope boundary element, stop search.\n        }\n        // Reachable if target not found within scope limit, or stack is empty.\n        return false;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}