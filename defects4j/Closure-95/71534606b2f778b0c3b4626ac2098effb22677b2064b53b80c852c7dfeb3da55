{
    "generation": "    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name.\n     *\n     * @param n The defining NAME or GETPROP node.\n     * @param parent The {@code n}'s parent.\n     * @param type The variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     * @param inferred Whether the type is inferred.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Validate node types.\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION\n                || parent.getType() == Token.VAR\n                || parent.getType() == Token.LP\n                || parent.getType() == Token.CATCH);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP\n                && (parent.getType() == Token.ASSIGN\n                    || parent.getType() == Token.EXPR_RESULT));\n      }\n\n      String variableName = n.getQualifiedName();\n      // getQualifiedName() can return null for anonymous functions expressions\n      // assigned to properties.\n      if (variableName == null) {\n        return;\n      }\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // Determine the scope where the variable should be declared.\n      Scope scopeToDeclareIn = scope; // Default to current scope\n      if (n.getType() == Token.GETPROP) {\n        Node rootNode = n.getFirstChild();\n        // If the root of the qualified name is a simple name, find its scope.\n        if (rootNode.getType() == Token.NAME) {\n          String rootVarName = rootNode.getString();\n          Var rootVar = scope.getVar(rootVarName); // Find root variable in scope chain\n          if (rootVar != null && rootVar.getScope() != null) {\n            // Declare in the scope where the root name is defined.\n            scopeToDeclareIn = rootVar.getScope();\n          }\n          // If root var is not found or has no scope (e.g., synthetic), 'ns' in 'ns.foo'\n          // might be undeclared. TypeCheck should warn. We'll declare 'ns.foo'\n          // in the current scope (default).\n        }\n        // If root is not a NAME (e.g., `getObj().foo`, `this.foo`), declare in current scope.\n      }\n\n      CompilerInput input = compiler.getInput(sourceName);\n      JSType typeToDeclare = type;\n      if (inferred && typeToDeclare == null) {\n        typeToDeclare = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n\n      // Check if the variable already exists in the target scope's declaration list.\n      Var existingVar = scopeToDeclareIn.getVar(variableName);\n      boolean varExistsInTargetScope =\n          existingVar != null && existingVar.getScope() == scopeToDeclareIn;\n\n      if (varExistsInTargetScope) {\n        // Variable already exists in the target scope. Handle update/redeclaration.\n\n        if (n.getType() == Token.NAME) {\n          // NAME redeclaration (e.g., var x; var x; or var x; /** @type {string} */ var x;)\n          // The validator ensures that this is either a harmless redeclaration\n          // (e.g. var x; var x = 3) or issues a warning.\n          validator.expectUndeclaredVariable(\n              sourceName, n, parent, existingVar, variableName, typeToDeclare);\n\n          // If valid (e.g. var redeclaration), update type if new type isn't inferred,\n          // unless existing type was already declared.\n          boolean updateType = false;\n          if (!inferred) {\n             updateType = true; // Always update with a declared type\n          } else if (existingVar.isTypeInferred()) {\n             updateType = true; // Update if both are inferred\n          }\n\n          if (updateType) {\n             existingVar.setType(typeToDeclare);\n             if (input != null) { // Input might be null for synthetic nodes\n                 existingVar.setInput(input);\n             }\n             // Note: We don't update the declaration node for redeclarations.\n             if (scopeToDeclareIn.isGlobal()) {\n                updateGlobalVarDefinition(variableName, typeToDeclare, inferred, input);\n                if (typeToDeclare instanceof FunctionType) {\n                    declarePrototype(n, variableName, (FunctionType) typeToDeclare, scopeToDeclareIn, input);\n                }\n             }\n          }\n          // Ensure node type matches final var type\n          setDeferredType(n, existingVar.getType());\n\n        } else { // n.getType() == Token.GETPROP\n          // Property assignment (e.g., ns.foo = ...)\n          JSType oldType = existingVar.getType();\n          boolean updateType = false;\n          if (!inferred) {\n            // Always update if new type is declared.\n            updateType = true;\n          } else if (existingVar.isTypeInferred() || oldType == null) {\n            // Update if new type is inferred and old type was null or inferred.\n            updateType = true;\n          }\n\n          if (updateType) {\n            existingVar.setType(typeToDeclare);\n            // Don't update the var's defining node/scope, just the type and input.\n             if (input != null) { // Input might be null for synthetic nodes\n                 existingVar.setInput(input);\n             }\n            if (scopeToDeclareIn.isGlobal()) {\n              updateGlobalVarDefinition(variableName, typeToDeclare, inferred, input);\n              if (typeToDeclare instanceof FunctionType) {\n                declarePrototype(n, variableName, (FunctionType) typeToDeclare, scopeToDeclareIn, input);\n              }\n            }\n          }\n          // Set node type for consistency, using the final type on the var.\n          setDeferredType(n, existingVar.getType());\n        }\n\n      } else {\n        // Variable does not exist in the target scope's declaration list (or exists only in ancestor).\n        // Declare it new in scopeToDeclareIn.\n        setDeferredType(n, typeToDeclare); // Set type for the node first\n        scopeToDeclareIn.declare(variableName, n, typeToDeclare, input, inferred);\n        Var newVar = scopeToDeclareIn.getVar(variableName); // Get the newly declared var\n\n        if (scopeToDeclareIn.isGlobal()) {\n           // Ensure the var is associated with the input defining it\n           // This is important for externs tracking.\n           if (newVar != null && input != null) {\n             newVar.setInput(input);\n           }\n           updateGlobalVarDefinition(variableName, typeToDeclare, inferred, input);\n           if (typeToDeclare instanceof FunctionType) {\n             declarePrototype(n, variableName, (FunctionType) typeToDeclare, scopeToDeclareIn, input);\n           }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}