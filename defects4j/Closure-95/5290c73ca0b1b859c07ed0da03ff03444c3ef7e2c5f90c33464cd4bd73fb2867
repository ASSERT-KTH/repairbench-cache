{
    "generation": "    /**\n     * Defines a typed variable. The defining node will be annotated with the\n     * variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is\n     * inferred.\n     *\n     * Slots may be any variable or any qualified name in the global scope.\n     *\n     * @param n the defining NAME or GETPROP node.\n     * @param parent the {@code n}'s parent.\n     * @param type the variable's type. It may be {@code null} if\n     *     {@code inferred} is {@code true}.\n     */\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      // Note: This method is only called by NodeTraversal when traversing the AST specified by the\n      // second argument to the compiler.process method. It is not called during traversals of externs\n      // ASTs.\n\n      // Preconditions check that the type is non-null if the type is not inferred.\n      // If the type is inferred, it may be null.\n      // TODO(b/148231795): Make the type non-nullable and require callers to pass UNKNOWN_TYPE.\n      Preconditions.checkArgument(inferred || type != null);\n\n      // If the type is inferred and null, make it UNKNOWN for internal consistency, although\n      // the declaration logic might handle this as well.\n      if (inferred && type == null) {\n        type = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n\n      boolean isFunctionDecl = parent.getType() == Token.FUNCTION;\n      boolean isVarDecl = parent.getType() == Token.VAR;\n      boolean isCatchDecl = parent.getType() == Token.CATCH;\n      boolean isLPDecl = parent.getType() == Token.LP; // Function parameters\n\n      // Only allow declarations of NAMEs and qualified names (GETPROP in assignment/expr).\n      boolean definingName = n.getType() == Token.NAME;\n      boolean definingGetprop = n.getType() == Token.GETPROP;\n      if (definingName) {\n        Preconditions.checkArgument(\n            isFunctionDecl || isVarDecl || isLPDecl || isCatchDecl);\n      } else {\n        Preconditions.checkArgument(\n            definingGetprop &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n\n      String variableName = n.getQualifiedName();\n      // getQualifiedName() can return null for invalid ASTs.\n      Preconditions.checkArgument(variableName != null && !variableName.isEmpty());\n\n      // Determine the scope in which the variable should be declared.\n      Scope scopeToDeclareIn = scope;\n      if (definingGetprop) {\n        Node rootNode = NodeUtil.getRootOfQualifiedName(n);\n        if (rootNode.isName()) {\n          String rootName = rootNode.getString();\n          // Find the variable for the root of the qualified name. This searches up the scope chain.\n          Var rootVar = scope.getVar(rootName);\n          // Declare in the global scope if the root object is implicitly\n          // or explicitly global. A variable is implicitly global if it's\n          // not declared in the current scope chain.\n          if (rootVar == null && !scope.isDeclared(rootName, true)) {\n            // Implicitly global.\n            scopeToDeclareIn = scope.getGlobalScope();\n          } else if (rootVar != null && rootVar.isGlobal()) {\n            // Explicitly global.\n            scopeToDeclareIn = rootVar.getScope(); // Should be the global scope.\n          }\n          // Otherwise, the root is local, or complex. Declare in the current scope (the default).\n        }\n        // TODO(nicksantos): Handle the case where the root node is complex,\n        // e.g., (a || {}).foo = 1;. Currently declared in the current scope.\n      }\n\n      // Check for redeclaration in the chosen scope.\n      // We check only the specific scope, not the whole chain (false argument).\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        // If it's declared in this scope, it's a duplicate declaration error or violation.\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        // Set the JSType on the defining node if the type is explicitly declared.\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n\n        // Declare the variable in the determined scope.\n        CompilerInput input = compiler.getInput(sourceName);\n        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        // Retrieve the newly declared variable to get its final type and inferred status.\n        Var declaredVar = scopeToDeclareIn.getVar(variableName);\n        // The type might be refined during declaration (e.g., if null was passed for inferred).\n        JSType declaredType = declaredVar.getType();\n        if (declaredType == null) {\n          // This case should ideally not happen if 'type' was handled correctly above\n          // or if 'declare' ensures a type. Defaulting to UNKNOWN just in case.\n          declaredType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n        }\n        boolean isDeclaredInferred = declaredVar.isInferred();\n\n        // Also declare on the global 'this' object if the variable was declared\n        // in the global scope. This ensures properties defined on the global 'this'\n        // (like 'window' or global functions/vars) are updated.\n        if (scopeToDeclareIn.isGlobal()) {\n          // Should update global 'this' for global VAR/FUNCTION declarations\n          // and for assignments to properties of global objects.\n          boolean shouldDeclareOnGlobalThis = definingName && (isVarDecl || isFunctionDecl);\n          if (shouldDeclareOnGlobalThis || definingGetprop) {\n            ObjectType globalThis =\n                typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n            boolean isExtern = input.isExtern();\n            if (isDeclaredInferred) {\n              globalThis.defineInferredProperty(variableName, declaredType, isExtern);\n            } else {\n              globalThis.defineDeclaredProperty(variableName, declaredType, isExtern);\n            }\n          }\n        }\n\n        // If the declared variable is a function type in the global scope,\n        // also declare its 'prototype' property.\n        if (scopeToDeclareIn.isGlobal() && declaredType.isFunctionType()) {\n          FunctionType fnType = declaredType.toMaybeFunctionType();\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            // The 'prototype' property is implicitly declared. We mark it as inferred\n            // unless there's an explicit superclass other than Object.\n            boolean prototypeMarkedDeclared = superClassCtor != null &&\n                !superClassCtor.getInstanceType().isEquivalentTo(getNativeType(OBJECT_TYPE));\n            scopeToDeclareIn.declare(\n                variableName + \".prototype\",\n                n, // Source node is the function name/prop node\n                fnType.getPrototype(),\n                input,\n                !prototypeMarkedDeclared); // Inferred if not marked declared\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}