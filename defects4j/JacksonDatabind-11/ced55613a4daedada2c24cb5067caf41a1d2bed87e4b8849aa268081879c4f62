{
    "generation": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n            // We could also try to resolve bounds, but without context that seems unlikely\n            // to work? Or resolution of bounds works without context? Let's assume current\n            // code is fine for now\n        }\n        // Ok: here's where context might come in handy!\n        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n         *   unresolved type variables to handle some cases where bounds\n         *   are enough. Let's hope it does not hide real fail cases.\n         */\n        // But first: maybe context has binding? Or, perhaps we are resolving recursive type?\n        JavaType actualType = context.findType(name);\n        if (actualType != null) {\n            return actualType;\n        }\n\n        // If not found, must use bounds. May require recursion for recursive bounds,\n        // so need placeholder.\n\n        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n         *   bound: but the problem is that this can occur for generic \"base\"\n         *   method, overridden by sub-class. If so, we will want to ignore\n         *   current type (for method) since it will be masked.\n         */\n\n        Type[] bounds = type.getBounds();\n\n        // Variable without bounds is not possible, comes back as Object.class\n        if (bounds == null || bounds.length == 0) { // But just in case\n             // Per JLS, type variables always have at least one bound (implicitly Object)\n             // But, to be safe, return unknown if reflection returns nothing.\n            return _unknownType();\n        }\n\n        /* 29-Jan-2010, tatu: One more problem are recursive types\n         *   (T extends Comparable<T>). Need to add \"placeholder\"\n         *   for resolution to catch those.\n         */\n        // Add placeholder to handle recursive bounds, BEFORE resolving bound.\n        context._addPlaceholder(name);\n\n        // MUST resolve bound AFTER adding placeholder, so that recursive\n        // references will find placeholder via `context.findType(name)`\n        JavaType boundType = _constructType(bounds[0], context);\n\n        // Finally, resolve the placeholder type, completing the loop for recursive definitions\n        // and providing a concrete type for unbound variables based on the bound.\n        // Placeholders are stored in `context`, accessed via `findType`.\n        JavaType placeholder = context.findType(name);\n        // 14-Jun-2024, tatu: This is the fix for #728 and possibly #609:\n        //   placeholder must be resolved to the bound type if it was not resolved\n        //   during construction of the bound type (which only occurs for recursive types).\n        if (placeholder instanceof ResolvedRecursiveType) {\n            ResolvedRecursiveType rrt = (ResolvedRecursiveType) placeholder;\n            // Resolve the placeholder to the bound type. This handles both recursive\n            // types (where boundType might contain the placeholder itself) and\n            // non-recursive types (where resolving to the bound provides the\n            // necessary concrete type).\n            rrt.setReference(boundType);\n        } else if (placeholder == null) { // sanity check, should not occur if _addPlaceholder worked\n             throw new IllegalStateException(\"Internal error: Failed to find placeholder for type variable '\"+name+\"'\");\n        }\n        // else: if placeholder is NOT ResolvedRecursiveType, it means something else\n        // resolved the variable name concurrently? Or context has been updated?\n        // This path seems unlikely given the initial findType check and placeholder logic.\n        // If it occurs, the original 'actualType' should probably have been returned initially.\n\n        // And return the actual bound type resolved.\n        return boundType;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}