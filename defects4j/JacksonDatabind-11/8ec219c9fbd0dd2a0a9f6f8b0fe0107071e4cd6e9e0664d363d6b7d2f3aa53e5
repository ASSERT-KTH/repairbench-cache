{
    "generation": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                // Variable already resolved (either concretely or as a placeholder for recursion)\n                return actualType;\n            }\n            \n            // If actualType is null, the variable is not yet resolved in this context.\n            // We need to resolve it based on its bounds.\n            // First, add a placeholder to prevent infinite recursion for cyclic type variables\n            // (e.g., T extends Comparable<T>). This placeholder will typically be _unknownType().\n            context._addPlaceholder(name); \n\n            Type[] bounds = type.getBounds();\n            JavaType resolvedBoundType;\n            if (bounds.length == 0) {\n                // If no bounds are specified, it implicitly extends Object.\n                // We treat this as an unknown type, which often resolves to Object.class.\n                resolvedBoundType = _unknownType();\n            } else {\n                // Resolve the first bound recursively using the same context.\n                // This will get the effective type for the variable based on its constraints.\n                resolvedBoundType = _constructType(bounds[0], context);\n            }\n\n            // Crucially, after resolving the bound, the type variable 'name' is now resolved\n            // to 'resolvedBoundType'. We must bind this final resolution to the context\n            // so that subsequent lookups for 'name' within this TypeBindings instance\n            // return 'resolvedBoundType' instead of the temporary placeholder.\n            context._bind(name, resolvedBoundType);\n            \n            return resolvedBoundType;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}