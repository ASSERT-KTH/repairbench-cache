{
    "generation": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            JavaType boundType = _fromBounds(type.getBounds(), null);\n            if (boundType == null || boundType.equals(Object.class)) {\n                return _unknownType();\n            }\n            return boundType;\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                return actualType;\n            }\n            // If not found in context, fall back to bounds\n            return _fromBounds(type.getBounds(), context);\n        }\n    }\n\n    private JavaType _fromBounds(Type[] bounds, TypeBindings context) {\n        if (bounds.length == 0) {\n            return _unknownType();\n        }\n        // Use the first bound as the primary type\n        Type firstBound = bounds[0];\n        if (firstBound instanceof Class) {\n            return _constructType(firstBound, context);\n        } else if (firstBound instanceof TypeVariable) {\n            return _fromVariable((TypeVariable<?>) firstBound, context);\n        } else if (firstBound instanceof ParameterizedType) {\n            return _fromParameterizedType((ParameterizedType) firstBound, context);\n        } else {\n            // Fallback to unknown type if bound type is not supported\n            return _unknownType();\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}