{
    "generation": "    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n    {\n        final String name = type.getName();\n        // 19-Mar-2015: Without context, all we can check are bounds.\n        if (context == null) {\n            // And to prevent infinite loops, now need this:\n            return _unknownType();\n        } else {\n            // Ok: here's where context might come in handy!\n            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n             *   unresolved type variables to handle some cases where bounds\n             *   are enough. Let's hope it does not hide real fail cases.\n             */\n            JavaType actualType = context.findType(name);\n            if (actualType != null) {\n                return actualType;\n            }\n        }\n\n        /* 14-Jun-2015, tatu: Let's rewrite steps initiated by [databind#609], as\n         *  part of potentially related [databind#728]. Objective is to avoid\n         *  using recursive type resolution, which gets very confusing.\n         *  Ideal would be to use deferred resolution -- something Collection/Map types\n         *  do -- but that seems like too big a change initially.\n         *\n         *  There are multiple issues: first, should we block type variables for all\n         *  kinds of types, or just specific ones? And second, should we try to\n         *  find \"better\" bounds, or just use the first one? Current thinking is to\n         *  try to use bounds if no direct match is found; and this is needed to\n         *  resolve non-parameterized generic types like `List l = new ArrayList<String>()`.\n         *  Issue is that this may prevent detection of invalid types in more exotic\n         *  cases. Test `TestGenericsLimits` tries to verify some of potentially\n         *  problematic cases.\n         */\n        // Hmmh. Ok, this is another case where we may need to consider recursive\n        // types. Let's add a check here:\n        if (context.hasUnresolved(name)) { // usually means recursive definition\n             return _unknownType();\n        }\n\n        /* And before trying to resolve bounds, let's add temporary binding\n         * to handle recursive definitions like <T extends Comparable<T>>.\n         * NOTE! Need to use TypeBindings, not just generic types, to make\n         * this work: context is required.\n         */\n        TypeBindings newBindings = context.withAdditionalBinding(name, _unknownType());\n\n        Type[] bounds = type.getBounds();\n        // With type variables we must use bound information. Theoretically this gets tricky,\n        // as there may be multiple bounds (\"... extends A & B\"); and optimally we might\n        // want to choose the best match. Also, bounds are optional; but default is 'Object'.\n        // Let's just use the first bound for now (if !null).\n        // [#771]: Should not perhaps use `Object.class` as bound. But for now...\n        if (bounds == null || bounds.length == 0) { // sanity check, shouldn't occur per JVM spec\n             // I think this might be possible if signature is corrupt; if so, return Object/unknown\n            // TBD: Maybe return `Object.class` bound type?\n            return _unknownType();\n        }\n        // And resolve first bound using extended bindings\n        return _constructType(bounds[0], newBindings);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}