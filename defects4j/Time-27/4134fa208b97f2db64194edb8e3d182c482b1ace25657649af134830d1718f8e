{
    "generation": "    //-----------------------------------------------------------------------\n    /**\n     * Creates a formatter from the builder.\n     * <p>\n     * This method is thread-safe.\n     *\n     * @param elementPairs  the pairs of elements, not null\n     * @param notPrinter  whether the formatter must not be a printer\n     * @param notParser  whether the formatter must not be a parser\n     * @return the formatter, not null\n     * @throws IllegalStateException if the builder produces neither a printer nor a parser\n     */\n    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        // The special handling for a leading separator in the original code was flawed\n        // as it incorrectly returned a PeriodFormatter containing only the separator,\n        // discarding subsequent elements. This handling was removed in later versions\n        // of Joda-Time. The createComposite method correctly handles separators\n        // in any position.\n        // int size = elementPairs.size(); // No longer needed here\n        // --- Removed faulty block ---\n        // if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n        //     Separator sep = (Separator) elementPairs.get(0);\n        //     if (elementPairs.get(1) == null) { // Check was different in original joda-time but block was flawed anyway\n        //         throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        //     }\n        //     PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n        //     sep = sep.finish(f.getPrinter(), f.getParser());\n        //     return new PeriodFormatter(sep, sep); // Incorrectly returned only separator\n        // }\n        // --- End of removed block ---\n\n        // Always use createComposite to build the printer and parser chain.\n        Object[] comp = createComposite(elementPairs);\n\n        // Construct the PeriodFormatter based on the composite results and flags.\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}