{
    "generation": "  @Override\n  public void process(Node externs, Node root) {\n    // Collect information about declarations potentially shadowing built-ins (like arguments)\n    // and other variable checks.\n    NodeTraversal.traverse(compiler, root, this);\n\n    // Remove duplicate declarations found during the traversal. This needs to happen\n    // before potentially renaming variables, as renaming might obscure the duplication\n    // or interfere with the logic for removing declarations shadowing built-ins like 'arguments'.\n    removeDuplicateDeclarations(root);\n\n    // Make local names unique if required. This needs to run after initial checks\n    // and duplicate removal but before subsequent passes that might rely on unique names.\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      // Note: Renaming should be applied to both externs and root to ensure\n      // consistency, even though duplicates are only removed from root.\n      // However, the original code traversed roots for renaming, so we keep that pattern.\n      t.traverseRoots(externs, root);\n    }\n\n    // Propagate constant annotations. This pass typically runs after variable checks\n    // and normalization steps.\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}