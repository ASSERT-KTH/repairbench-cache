{
    "generation": "@Override\npublic void process(Node externs, Node root) {\n  // First run the usual traversal on this pass\n  NodeTraversal.traverse(compiler, root, this);\n\n  // Optionally make locals unique\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n    NodeTraversal t = new NodeTraversal(compiler, renamer);\n    t.traverseRoots(externs, root);\n  }\n\n  // Remove any duplicate var\u2010declarations\n  removeDuplicateDeclarations(root);\n\n  // Special\u2010case: drop any \"var arguments = \u2026\" (it only shadows the real arguments object)\n  NodeTraversal dropArgs = new NodeTraversal(\n    compiler,\n    new NodeTraversal.Callback() {\n      @Override\n      public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n        return true;\n      }\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isVar()) {\n          for (Node child = n.getFirstChild(); child != null; ) {\n            Node next = child.getNext();\n            if (child.isName() && \"arguments\".equals(child.getString())) {\n              // pull off the initializer\n              Node init = child.getFirstChild();\n              // if there was one, turn it into an assignment statement\n              if (init != null) {\n                Node assign = IR.assign(\n                    IR.name(\"arguments\").srcref(child),\n                    init.cloneTree())\n                  .srcref(child);\n                Node expr = IR.exprResult(assign).srcref(child);\n                parent.addChildBefore(expr, n);\n                compiler.reportCodeChange();\n              }\n              // remove the var\u2010declaration of \"arguments\"\n              n.removeChild(child);\n              compiler.reportCodeChange();\n            }\n            child = next;\n          }\n          // if that was the only var in the statement, drop the now\u2010empty VAR node\n          if (!n.hasChildren()) {\n            parent.removeChild(n);\n            compiler.reportCodeChange();\n          }\n        }\n      }\n    }\n  );\n  dropArgs.traverseRoots(externs, root);\n\n  // Finally propagate any @const annotations\n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(externs, root);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}