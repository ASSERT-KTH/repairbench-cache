{
    "generation": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n\n    // Fix for Issue 115: 'var arguments' declaration inside a function block\n    // should be transformed into an an assignment or removed if it has no initializer.\n    // This is necessary because 'arguments' is a special keyword, and its redeclaration\n    // as a local variable can lead to unexpected behavior and should be transformed\n    // by the compiler to refer to the implicit 'arguments' object.\n    NodeTraversal.traverse(compiler, root, new NodeTraversal.AbstractPostOrderCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            // We are looking for VAR nodes whose parent is a function block.\n            if (n.isVar() && parent != null && NodeUtil.isFunctionBlock(parent)) {\n                // Iterate through declared names in this VAR statement.\n                // A VAR node can declare multiple variables, e.g., 'var a, b = 1;'.\n                Node currentVarDecl = n.getFirstChild();\n                while (currentVarDecl != null) {\n                    Node nextVarDecl = currentVarDecl.getNext(); // Store next before potential detachment\n\n                    // Check if this is the 'arguments' variable declaration.\n                    // The 'arguments' variable itself is a NAME node.\n                    if (currentVarDecl.isName() && \"arguments\".equals(currentVarDecl.getString())) {\n                        Node initializer = currentVarDecl.getFirstChild(); // The value assigned to 'arguments'\n\n                        if (initializer != null) {\n                            // Case: 'var arguments = value;' -> 'arguments = value;'\n                            // Create an ASSIGN node: arguments = initializer\n                            Node assign = new Node(Token.ASSIGN,\n                                Node.newString(Token.NAME, \"arguments\").copyInformationFrom(currentVarDecl),\n                                initializer.detach()); // Detach initializer from original VAR_DECL_NAME\n\n                            // Create an EXPR_RESULT node to wrap the ASSIGN node.\n                            Node exprResult = new Node(Token.EXPR_RESULT, assign);\n                            exprResult.copyInformationFrom(n); // Copy source info from original VAR node\n\n                            // If 'var arguments' was the only declaration in its VAR node,\n                            // replace the entire VAR node. Otherwise, insert before the VAR node.\n                            if (n.hasOneChild()) { // 'var arguments = value;'\n                                parent.replaceChild(n, exprResult);\n                            } else { // 'var arguments = value;, otherVar;'\n                                parent.addChildBefore(exprResult, n);\n                                n.removeChild(currentVarDecl); // Remove 'arguments' from the VAR node\n                            }\n                            compiler.reportChangeToEnclosingScope(exprResult);\n                        } else {\n                            // Case: 'var arguments;' -> remove it, as it's redundant.\n                            // The implicit arguments object is always available.\n                            if (n.hasOneChild()) { // If it's just 'var arguments;'\n                                parent.removeChild(n);\n                            } else { // If it's 'var arguments, otherVar;'\n                                n.removeChild(currentVarDecl);\n                            }\n                            compiler.reportChangeToEnclosingScope(parent);\n                        }\n                    }\n                    currentVarDecl = nextVarDecl;\n                }\n            }\n        }\n    });\n\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}