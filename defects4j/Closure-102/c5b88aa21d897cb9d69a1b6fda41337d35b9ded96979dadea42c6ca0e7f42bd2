{
    "generation": "@Override\npublic void process(Node externs, Node root) {\n  // First do the normal traversal for this pass.\n  NodeTraversal.traverse(compiler, root, this);\n\n  // Optionally make local names unique.\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n    NodeTraversal t = new NodeTraversal(compiler, renamer);\n    t.traverseRoots(externs, root);\n  }\n\n  // FIX FOR ISSUE 115: In SIMPLE_OPTIMIZATIONS, drop a \"var arguments = \u2026;\"\n  // since \"arguments\" is already a local, and \"var arguments\" is redundant.\n  if (compiler.getOptions().getCompilationLevel()\n        == CompilationLevel.SIMPLE_OPTIMIZATIONS) {\n    NodeTraversal.traverse(\n        compiler, root,\n        new NodeTraversal.AbstractPostOrderCallback() {\n          @Override\n          public void visit(NodeTraversal t, Node n, Node parent) {\n            // Look for a VAR statement whose sole declaration is \"arguments\"\n            // with an initializer.\n            if (n.isVar()\n                && n.hasOneChild()\n                && n.getFirstChild().isName()\n                && \"arguments\".equals(n.getFirstChild().getString())\n                && n.getFirstChild().hasOneChild()) {\n              // Detach the initializer.\n              Node varNameNode = n.getFirstChild();\n              Node init = varNameNode.removeFirstChild();\n              // Build `arguments = <init>;`\n              Node lhs = new Node(Token.NAME, \"arguments\")\n                  .useSourceInfoIfMissingFromForTree(varNameNode);\n              Node assign = new Node(Token.ASSIGN, lhs, init)\n                  .useSourceInfoIfMissingFromForTree(n);\n              Node expr = new Node(Token.EXPR_RESULT, assign)\n                  .useSourceInfoIfMissingFromForTree(n);\n              // Replace the VAR node with our new assignment.\n              parent.replaceChild(n, expr);\n              compiler.reportChangeToEnclosingScope(expr);\n            }\n          }\n        });\n  }\n\n  // Now remove any duplicate var-declarations (the existing logic).\n  removeDuplicateDeclarations(root);\n\n  // And finally propagate constant annotations.\n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(externs, root);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}