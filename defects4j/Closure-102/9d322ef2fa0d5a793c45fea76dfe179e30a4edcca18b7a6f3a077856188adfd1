{
    "generation": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n\n    // Fix for Issue 115: Handle `var arguments` declarations.\n    // The `arguments` object is implicitly available in functions, so explicit `var arguments`\n    // is redundant and can cause issues with optimizations or renaming.\n    // It should be transformed into a plain assignment if it has an initial value,\n    // or removed if it's a bare declaration.\n    NodeTraversal.traverse(compiler, root, new NodeTraversal.AbstractPostOrderCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isVar() && n.hasOneChild()) {\n          Node nameNode = n.getFirstChild();\n          if (nameNode.isName() && \"arguments\".equals(nameNode.getString())) {\n            Node varNode = n;\n            Node valueNode = nameNode.removeFirstChild(); // Get the assigned value, if any\n\n            if (valueNode != null) {\n              // Transform `var arguments = X;` into `arguments = X;`\n              Node nameForAssign = compiler.createNode(Token.NAME, \"arguments\");\n              nameForAssign.copyInformationFrom(nameNode); // Copy source info\n\n              Node assign = compiler.createNode(Token.ASSIGN, nameForAssign, valueNode);\n              assign.copyInformationFrom(varNode); // Copy source info from the original VAR node\n\n              Node exprResult = compiler.createNode(Token.EXPR_RESULT, assign);\n              exprResult.copyInformationFrom(varNode); // Copy source info from the original VAR node\n\n              varNode.replaceWith(exprResult);\n              t.reportCodeChange();\n            } else {\n              // Transform `var arguments;` by simply removing the VAR node,\n              // as 'arguments' is already implicitly declared.\n              varNode.detachFromParent();\n              t.reportCodeChange();\n            }\n          }\n        }\n      }\n    });\n\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}