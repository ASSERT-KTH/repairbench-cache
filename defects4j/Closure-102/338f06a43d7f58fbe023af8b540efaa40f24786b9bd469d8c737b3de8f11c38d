{
    "generation": "@Override\npublic void process(Node externs, Node root) {\n  // Normal normalization & optional unique\u2010renaming\n  NodeTraversal.traverse(compiler, root, this);\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n    NodeTraversal t = new NodeTraversal(compiler, renamer);\n    t.traverseRoots(externs, root);\n  }\n\n  // Special\u2010case: drop the redundant hoisted \"var arguments\" at the top\n  // of any function, leaving only the assignment that Normalize generated.\n  NodeTraversal argRemover =\n      new NodeTraversal(compiler, new NodeTraversal.Callback() {\n    @Override\n    public boolean shouldTraverse(NodeTraversal nt, Node n, Node parent) {\n      return true;\n    }\n    @Override\n    public void visit(NodeTraversal nt, Node n, Node parent) {\n      if (n.isFunction()) {\n        Node body = n.getLastChild();\n        Node first = body.getFirstChild();\n        if (first != null && first.isVar()) {\n          Node varNode = first;\n          for (Node child = varNode.getFirstChild(); child != null;) {\n            Node next = child.getNext();\n            if (child.isName() && \"arguments\".equals(child.getString())) {\n              varNode.removeChild(child);\n            }\n            child = next;\n          }\n          if (varNode.getFirstChild() == null) {\n            body.removeChild(varNode);\n          }\n        }\n      }\n    }\n  });\n  argRemover.traverseRoots(externs, root);\n\n  // Finish up\n  removeDuplicateDeclarations(root);\n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(externs, root);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}