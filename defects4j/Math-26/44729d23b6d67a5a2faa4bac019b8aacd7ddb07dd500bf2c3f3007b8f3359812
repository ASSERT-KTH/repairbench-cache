{
    "generation": "import org.apache.commons.math3.exception.MathIllegalStateException; // Assuming this or similar is the base class\nimport org.apache.commons.math3.exception.util.LocalizedFormats; // Assuming used by FractionConversionException\nimport org.apache.commons.math3.util.FastMath;\n\n// Note: The FractionConversionException class is assumed to be defined elsewhere\n// and capable of handling the constructor calls used below.\n// The fields this.numerator and this.denominator are assumed to exist in the enclosing class.\n\n    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge or calculation resulted in integer overflow.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        // Define integer limits for clarity and use in checks\n        final long minInt = Integer.MIN_VALUE;\n        final long maxInt = Integer.MAX_VALUE;\n\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n\n        // Check if the initial integer part of the value falls outside the range of a standard Java int.\n        // If it does, it cannot be represented as the numerator of a Fraction with denominator 1.\n        if (a0 < minInt || a0 > maxInt) {\n            // Throw an exception indicating overflow for the initial integer approximation.\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // Handle the case where the value is very close to an integer.\n        // If the absolute difference between the value and its floor is less than epsilon,\n        // consider it an integer and avoid the continued fraction iteration.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            // The initial check ensures a0 fits within int range.\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        // Initialize the state for the continued fraction algorithm.\n        // The convergents p_n/q_n are generated iteratively.\n        // p0/q0 represents p_(-1)/q_(-1) = 1/0 (by convention)\n        long p0 = 1;\n        long q0 = 0;\n        // p1/q1 represents p_0/q_0 = a_0/1\n        // a0 was already checked to be within the int range.\n        long p1 = a0;\n        long q1 = 1;\n\n        // Variables to store the next convergent p_n/q_n (p2/q2 in the code)\n        long p2 = 0; // Initialized, will be calculated in the first iteration\n        long q2 = 1; // Initialized, will be calculated in the first iteration (denominator should always be positive)\n\n        int n = 0; // Iteration counter\n        boolean stop = false; // Flag to control the loop termination\n        do {\n            ++n; // Increment iteration count\n\n            // Calculate the next term a_n (represented by a1 in the code)\n            // r0 represents r_{n-1}, a0 represents a_{n-1}\n            // r_n = 1.0 / (r_{n-1} - a_{n-1})\n            double r1 = 1.0 / (r0 - a0);\n            // Check for potential infinity, which might occur due to precision issues if r0 is extremely close to a0.\n             if (Double.isInfinite(r1)) {\n                // This scenario indicates a problem, possibly that the value could not be represented further.\n                // The original code didn't explicitly handle this. Throwing an exception seems appropriate.\n                // Using the p1/q1 values represents the last valid state.\n                 // Note: FractionConversionException might need a specific constructor or message for this.\n                 // Using the p2/q2 signature might align better with the other overflow check,\n                 // but p2/q2 were not successfully computed. Let's use p1/q1.\n                throw new FractionConversionException(value, p1, q1); // Indicate failure based on last good convergent.\n            }\n\n            // a_n = floor(r_n)\n            long a1 = (long)FastMath.floor(r1);\n\n            // Calculate the next convergent p_n/q_n using the recurrence relations:\n            // p_n = a_n * p_{n-1} + p_{n-2}\n            // q_n = a_n * q_{n-1} + q_{n-2}\n            // (Here, p2/q2 corresponds to p_n/q_n, p1/q1 to p_{n-1}/q_{n-1}, p0/q0 to p_{n-2}/q_{n-2})\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n\n            // Check if the calculated numerator (p2) or denominator (q2) exceeds the Integer limits.\n            // If they do, the resulting fraction cannot be stored in int fields.\n            if (p2 < minInt || p2 > maxInt || q2 < minInt || q2 > maxInt) {\n                 // Throw an exception indicating overflow, using the values that caused it.\n                 // This mimics the original code's intent for overflow conditions.\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            // Calculate the double value of the current convergent p2/q2 to check against epsilon.\n            double convergent = (double)p2 / (double)q2;\n\n            // Check the stopping conditions for the loop:\n            // - Have we reached the maximum allowed iterations? (Checked after the loop exits)\n            // - Is the current convergent close enough to the target value (within epsilon)?\n            // - Has the denominator q2 grown larger than or equal to maxDenominator?\n            // The loop continues ONLY if maxIterations is not reached AND the approximation is not good enough AND the denominator is still below the limit.\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                // None of the stopping conditions met, update the state for the next iteration.\n                // Shift the convergents: (p0, q0) takes values of (p1, q1); (p1, q1) takes values of (p2, q2)\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                // Update r and a for the next term calculation: r_{n} becomes r0, a_{n} becomes a0 for the next loop start.\n                r0 = r1;\n                a0 = a1;\n            } else {\n                // A stopping condition is met (epsilon reached, q2 limit reached, or maxIterations will be checked post-loop).\n                stop = true;\n            }\n        } while (!stop);\n\n        // After the loop terminates, check if it was due to reaching the maximum iteration count.\n        if (n >= maxIterations) {\n            // If so, convergence failed within the allowed iterations.\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        // The loop stopped either because the epsilon condition was met or because q2 >= maxDenominator.\n        // Now, decide which convergent represents the best result according to the rules:\n        // Use the last computed convergent (p2/q2) if its denominator (q2) is strictly less than maxDenominator.\n        // Otherwise, fall back to the previous convergent (p1/q1).\n        if (q2 < maxDenominator) {\n            // The check inside the loop ensures p2 and q2 are within the int range. Casting is safe.\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            // Use the previous convergent p1/q1 because q2 >= maxDenominator.\n            // p1 and q1 were validated in the previous iteration (or initially for a0/1). Casting is safe.\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}