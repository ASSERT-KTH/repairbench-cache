{
    "generation": "    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge or overflowed.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        // Check if initial integer part overflows int limits (magnitude check)\n        // Use FastMath.abs(double) to handle Long.MIN_VALUE correctly\n        if (FastMath.abs((double)a0) > overflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            // Ensure a0 fits in int before assigning (magnitude check)\n            // This check is slightly redundant due to the check above, but safe.\n            if (a0 < Integer.MIN_VALUE || a0 > Integer.MAX_VALUE) {\n                 throw new FractionConversionException(value, a0, 1l);\n            }\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        // Initializing p2/q2 here is not strictly necessary as they are calculated first in loop\n        // But set them to a valid state (e.g. p1/q1) in case loop terminates immediately\n        long p2 = p1;\n        long q2 = q1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double rk = r0 - a0; // Remainder\n\n            // Check if remainder is negligible, indicating exact convergence at p1/q1\n            // Using a threshold smaller than machine epsilon for doubles might be appropriate\n            // Using Double.MIN_NORMAL ensures we don't divide by zero or subnormal numbers near zero.\n            if (FastMath.abs(rk) < Double.MIN_NORMAL) {\n                 stop = true;\n                 // Keep p1/q1 as the result; ensure p2/q2 don't override this if loop breaks.\n                 // Setting p2/q2 = p1/q1 ensures the post-loop logic correctly selects p1/q1 if needed.\n                 p2 = p1;\n                 q2 = q1;\n                 break; // Exit loop as we've reached the exact fraction p1/q1\n            }\n\n            double r1 = 1.0 / rk;\n            long a1 = (long)FastMath.floor(r1);\n\n            // Calculate the next convergent p2/q2\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n\n            // Check for potential overflow in long intermediate calculations (signed)\n            // A simpler check is to verify the result against int limits.\n            // Check if calculated p2 or q2 overflow int limits (magnitude check)\n            // q2 should always be positive and increasing in this algorithm.\n            // Check for negative q2 first, which indicates long overflow during calculation.\n            if (q2 < 0) {\n                 throw new FractionConversionException(\"Denominator negative overflow\", value, p2, q2);\n            }\n            // Check if p2 or q2 magnitude exceeds Integer.MAX_VALUE\n            if (FastMath.abs((double)p2) > overflow || q2 > overflow) {\n                // This convergent p2/q2 exceeds int limits.\n                // The algorithm must stop. The previous convergent p1/q1 is the best candidate\n                // if it's within maxDenominator. If we throw here, we lose p1/q1.\n                // Let's set stop = true, and let the logic after loop decide.\n                // The check `q2 < maxDenominator` after the loop will fail, selecting p1/q1.\n                 stop = true;\n                 // Avoid throwing exception here, let post-loop logic handle selection.\n                 // Set p2/q2 values to indicate overflow occurred? Not necessary.\n            }\n\n            if (!stop) {\n                // Check termination conditions using the valid convergent p2/q2\n                double convergent = (double)p2 / (double)q2;\n                if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                    // Convergent is valid and does not meet stop criteria, continue\n                    p0 = p1;\n                    p1 = p2;\n                    q0 = q1;\n                    q1 = q2;\n                    a0 = a1;\n                    r0 = r1;\n                } else {\n                    // Stop: maxIterations reached, OR epsilon condition met, OR q2 >= maxDenominator\n                    stop = true;\n                }\n            }\n        } while (!stop);\n\n        // Check if maxIterations was reached as the primary reason for stopping\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        // Loop finished before maxIterations. Decide result.\n        if (q2 < maxDenominator) {\n            // Use p2/q2 if it's within denominator limit.\n            // Need to ensure p2/q2 didn't overflow int limits.\n            // The check inside the loop handles the overflow condition by setting stop = true.\n            // If stop was set due to overflow, q2 would likely be > overflow, leading to the else branch.\n            // But if p2 overflowed while q2 was still small, this branch might be taken. Check again.\n            if (FastMath.abs((double)p2) > overflow || q2 > overflow) {\n                 // Overflow occurred for p2/q2, fall back to p1/q1\n                 // This implies the overflow check inside loop should perhaps have thrown directly?\n                 // Let's trust the logic flow for now: if overflow stopped loop, use p1/q1 via else branch.\n                 // If we reach here, p2/q2 should be valid.\n            } else {\n                // p2/q2 is the candidate result (met epsilon or loop broke early) and fits int limits.\n                 this.numerator = (int) p2;\n                 this.denominator = (int) q2;\n                 return; // Added return here\n            }\n        }\n\n        // If q2 >= maxDenominator OR if p2/q2 overflowed (and caused loop to stop), use p1/q1.\n        // Safety checks for p1/q1 overflow (should be redundant but safe).\n        if (q1 == 0) { // Should be impossible here as q1 starts at 1 and grows\n             throw new FractionConversionException(\"Internal error: q1 is zero\", value, p1, q1);\n        }\n        // Check magnitude of p1/q1 against int limits.\n        if (FastMath.abs((double)p1) > overflow || q1 > overflow) {\n             // If the previous convergent p1/q1 itself overflows, throw exception.\n             throw new FractionConversionException(\"Overflow trying to return previous convergent\", value, p1, q1);\n        }\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}