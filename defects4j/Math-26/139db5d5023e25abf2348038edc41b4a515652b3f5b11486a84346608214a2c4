{
    "generation": "    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge or overflowed.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE; // Positive limit for int numerator/denominator\n        long minflow = Integer.MIN_VALUE; // Negative limit for int numerator\n\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n\n        // Initial check: If the integer part itself overflows int, throw exception.\n        // Use || instead of && for check a0 < minflow vs a0 > overflow\n        if (a0 > overflow || a0 < minflow) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // Handle the case of 'almost integer' values.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            // Value is close enough to the integer part a0.\n            // a0 is already checked to be within int limits.\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        // Initialization: p1/q1 is the previous convergent, p2/q2 is the current one.\n        long p0 = 1; // Represents p_{k-2}\n        long q0 = 0; // Represents q_{k-2}\n        long p1 = a0; // Represents p_{k-1} (starts with k=1, so p0 / convergent 0)\n        long q1 = 1; // Represents q_{k-1} (starts with k=1, so q0 / convergent 0)\n        long p2 = 0; // Represents p_k (convergent for iteration k)\n        long q2 = 1; // Represents q_k (convergent for iteration k)\n\n        int n = 0; // Iteration counter\n        boolean stop = false; // Loop control flag\n        boolean overflowed = false; // Flag for overflow in the calculation of p2/q2\n\n        do {\n            ++n;\n            // Calculate next term a_n\n            // Handle potential division by zero or very small denominator\n            double r0_a0_diff = r0 - a0;\n            // A check like `if (r0_a0_diff == 0.0)` might be needed if not handled by `almost integer` check\n            // Or check for very small values that might lead to infinity/NaN\n            if (r0_a0_diff == 0.0) { // Should be caught by initial 'almost integer' check, but safeguard\n                 break; // Stop if value was exact integer after all\n            }\n            double r1 = 1.0 / r0_a0_diff;\n            long a1 = (long)FastMath.floor(r1);\n\n            // Calculate next convergent p_n / q_n\n            // Need to check for potential overflow in the intermediate multiplication a1 * p1 or a1 * q1\n            // Using BigInteger or checking intermediate results might be more robust,\n            // but sticking to long arithmetic requires checking the final result carefully.\n            long p2_next = (a1 * p1) + p0;\n            long q2_next = (a1 * q1) + q0;\n\n            // Check for overflow against int limits for the result p2_next, q2_next\n            if (p2_next > overflow || p2_next < minflow || q2_next > overflow || q2_next <= 0) {\n                // According to MATH-181, on overflow, we should use the previous convergent.\n                overflowed = true;\n                stop = true; // Stop iteration, p1/q1 holds the last valid convergent\n            } else {\n                // No overflow, current convergent p2/q2 is potentially valid\n                p2 = p2_next;\n                q2 = q2_next;\n\n                // Check termination conditions using the current convergent p2/q2\n                double convergent = (double)p2 / (double)q2;\n\n                // Stop if max iterations reached OR convergent is close enough OR denominator exceeds limit\n                if (n >= maxIterations || FastMath.abs(convergent - value) <= epsilon || q2 >= maxDenominator) {\n                    stop = true;\n                }\n\n                // If not stopping, update history (p0, q0, p1, q1, a0, r0) for the next iteration\n                if (!stop) {\n                    p0 = p1; p1 = p2;\n                    q0 = q1; q1 = q2;\n                    a0 = a1;\n                    r0 = r1;\n                }\n            }\n        } while (!stop);\n\n        // Handle results after loop termination\n\n        // If max iterations reached without converging sufficiently (and without overflow causing stop earlier)\n        // Match original behavior: throw exception if n >= maxIterations caused the loop to stop.\n        if (n >= maxIterations && !overflowed) {\n            // Check if the loop truly stopped because n hit maxIterations,\n            // rather than achieving convergence on the last iteration.\n            // The original code threw unconditionally if n >= maxIterations. We match this.\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        // Decide which convergent to return: (p1, q1) or (p2, q2).\n        // Use previous convergent (p1, q1) if:\n        // - an overflow occurred calculating p2/q2 (overflowed = true)\n        // - the denominator q2 of the current convergent meets or exceeds maxDenominator\n        //   (Note: this means we prefer p1/q1 even if q2 == maxDenominator)\n        if (overflowed || q2 >= maxDenominator) {\n            // Sanity check p1, q1 (they should be the last valid ones calculated)\n            // Check against int limits before casting.\n            if (p1 > overflow || p1 < minflow || q1 > overflow || q1 <= 0) {\n                // If the supposedly \"safe\" previous convergent is also out of bounds, throw overflow.\n                throw new FractionConversionException(value, p1, q1);\n            }\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        } else {\n            // Use current convergent (p2, q2).\n            // We know it's within int limits (overflowed is false)\n            // and q2 < maxDenominator.\n            // And either error <= epsilon or n < maxIterations.\n            // p2/q2 were checked for overflow before being assigned, safe to cast.\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}