{
    "generation": "import org.apache.commons.math3.exception.MathArithmeticException; // Assuming this might be used elsewhere or by the exception\nimport org.apache.commons.math3.exception.util.LocalizedFormats; // Assuming this might be used elsewhere or by the exception\nimport org.apache.commons.math3.util.FastMath; // Assuming this is the intended FastMath class\n\n// Added dummy Exception class definition for context, assuming similar structure\nclass FractionConversionException extends Exception {\n    public FractionConversionException(double value, int maxIterations) {\n        super(\"Failed to converge for value: \" + value + \" within \" + maxIterations + \" iterations\");\n    }\n    public FractionConversionException(double value, long p, long q) {\n        super(\"Overflow trying to convert \" + value + \" to fraction (\" + p + \"/\" + q + \")\");\n    }\n}\n\n// Added dummy Fraction class definition for context\nclass Fraction {\n    private int numerator;\n    private int denominator;\n\n    // Constructor signature matches the provided buggy code\n    /**\n     * Create a fraction given the double value and either the maximum error\n     * allowed or the maximum number of denominator digits.\n     * <p>\n     *\n     * NOTE: This constructor is called with EITHER\n     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n     *     (that way the maxDenominator has no effect).\n     * OR\n     *   - a valid maxDenominator value and the epsilon value set to zero\n     *     (that way epsilon only has effect if there is an exact match before\n     *     the maxDenominator value is reached).\n     * </p><p>\n     *\n     * It has been done this way so that the same code can be (re)used for both\n     * scenarios. However this could be confusing to users if it were part of\n     * the public API and this constructor should therefore remain PRIVATE.\n     * </p>\n     *\n     * See JIRA issue ticket MATH-181 for more details:\n     *\n     *     https://issues.apache.org/jira/browse/MATH-181\n     *\n     * @param value the double value to convert to a fraction.\n     * @param epsilon maximum error allowed.  The resulting fraction is within\n     *        {@code epsilon} of {@code value}, in absolute terms.\n     * @param maxDenominator maximum denominator value allowed.\n     * @param maxIterations maximum number of convergents\n     * @throws FractionConversionException if the continued fraction failed to\n     *         converge or overflowed.\n     */\n    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n\n        // Check initial integer part for overflow using magnitude.\n        // Use comparisons to avoid Long.MIN_VALUE issue with FastMath.abs()\n        if (a0 > overflow || a0 < -overflow) {\n            throw new FractionConversionException(value, a0, 1L);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n             // Ensure the integer value fits in int. Check magnitude.\n             // Redundant due to the check above, but ensures safety.\n             if (a0 > overflow || a0 < -overflow) {\n                 throw new FractionConversionException(value, a0, 1L);\n             }\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0; // p1 is safe due to checks above\n        long q1 = 1;\n\n        long p2 = 0; // Will be updated in loop before use\n        long q2 = 1; // Will be updated in loop before use\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            // Handle potential infinite results (e.g., if value is exact fraction)\n            if (Double.isNaN(r1)) {\n                 throw new FractionConversionException(value, Long.MAX_VALUE, Long.MAX_VALUE); // Indicate failure for NaN/unexpected state\n            }\n            // If r1 is infinite, floor(r1) gives Long.MAX_VALUE\n            long a1 = (long)FastMath.floor(r1);\n\n            // Calculate next convergent candidates p2/q2 using standard long arithmetic\n            long p2_candidate = (a1 * p1) + p0;\n            long q2_candidate = (a1 * q1) + q0;\n\n            // Check for Long overflow resulting in non-positive q2.\n            // Mathematically, q_n must be positive for n >= 1.\n            // A non-positive value indicates long overflow during calculation.\n            if (q2_candidate <= 0) {\n                // Signal overflow, indicating q2 became too large or wrapped around.\n                // Use the potentially corrupted p2_candidate and signal q2 overflowed.\n                throw new FractionConversionException(value, p2_candidate, Long.MAX_VALUE);\n            }\n\n            // Check if the calculated candidates exceed Integer range (int overflow)\n            // Use comparisons for magnitude check to handle Long.MIN_VALUE correctly.\n            boolean p2_intOverflow = p2_candidate > overflow || p2_candidate < -overflow;\n            // q2_candidate is known to be > 0 here.\n            boolean q2_intOverflow = q2_candidate > overflow;\n\n            if (p2_intOverflow || q2_intOverflow) {\n                // This convergent exceeds Integer limits, throw exception\n                throw new FractionConversionException(value, p2_candidate, q2_candidate);\n            }\n\n            // No overflows detected for this convergent, assign candidates to p2, q2\n            p2 = p2_candidate;\n            q2 = q2_candidate;\n\n            // Check termination conditions using the valid p2, q2\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                // Not stopping: update history for next iteration\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                // Stop condition met (maxIterations, epsilon proximity, or q2 >= maxDenominator)\n                stop = true;\n            }\n        } while (!stop);\n\n        // After loop execution\n\n        if (n >= maxIterations) {\n            // Stopped due to maximum iterations limit\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        // Stopped due to epsilon or maxDenominator.\n        // Determine which convergent to return.\n        // The check inside the loop ensures that p2/q2 never exceeds Integer limits unless an exception is thrown.\n        // The check inside the loop uses q2 < maxDenominator to continue.\n        // If the loop terminates, it's either because n >= maxIterations (handled above),\n        // OR FastMath.abs(convergent - value) <= epsilon (epsilon met),\n        // OR q2 >= maxDenominator (denominator limit met).\n\n        if (q2 < maxDenominator) {\n            // If q2 is still less than maxDenominator, it means the loop stopped because the epsilon\n            // condition was met (or maxIterations was reached just before this check, but that's handled above).\n            // In this case, p2/q2 is the convergent that satisfied the condition.\n            // p2 and q2 have already passed the overflow checks.\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            // If q2 >= maxDenominator, the loop stopped because the denominator limit was reached.\n            // Per the algorithm's behavior, we should return the *previous* convergent (p1/q1)\n            // as it was the last one whose denominator was below the limit.\n            // p1 and q1 hold values that passed the overflow check in the previous iteration.\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}