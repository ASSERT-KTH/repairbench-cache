{
    "generation": "    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         */\n        // Basic conditions for non-cachable deserializers\n        if (_valueTypeDeserializer != null) {\n            return false;\n        }\n        if (_ignorableProperties != null) {\n            return false;\n        }\n        // As per [databind#735] and later fixes, also need to consider injectables\n        if (_injectables != null) {\n            return false;\n        }\n\n        // As per comment, check for properties that have custom value or key deserializers.\n        // Such properties often require contextualization, making the BeanDeserializer non-cachable globally.\n        if (_beanProperties != null) {\n            for (SettableBeanProperty prop : _beanProperties) {\n                // If a property has a custom value or key deserializer,\n                // the BeanDeserializer should not be cached globally\n                // as its contextualization depends on runtime context.\n                if (prop.hasValueDeserializer() || prop.hasKeyDeserializer()) {\n                    return false;\n                }\n            }\n        }\n        // Also check back references, if they might have custom deserializers that affect caching\n        if (_backRefs != null) {\n            for (SettableBeanProperty prop : _backRefs) {\n                if (prop.hasValueDeserializer() || prop.hasKeyDeserializer()) {\n                    return false;\n                }\n            }\n        }\n        \n        // If none of the above conditions are met, the deserializer is considered cachable.\n        return true;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}