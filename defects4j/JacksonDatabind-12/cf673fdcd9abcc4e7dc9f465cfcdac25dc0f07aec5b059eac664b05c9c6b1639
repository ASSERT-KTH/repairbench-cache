{
    "generation": "    /**\n     * Turns out that these are expensive enough to create so that caching\n     * does make sense.\n     *<p>\n     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n     * a value type deserializer; this caused an issue with 2.4.4 of\n     * JAXB Annotations (failing a test).\n     * It is also possible that some other settings could make deserializers\n     * un-cacheable; but on the other hand, caching can make a big positive\n     * difference with performance... so it's a hard choice.\n     * Additions based on [databind#735] and general complexity (Object Id, etc).\n     * \n     * @since 2.4.4\n     */\n    @Override\n    public boolean isCachable() {\n        /* As per [databind#735], existence of value or key deserializer (only passed\n         * if annotated to use non-standard one) should also prevent caching.\n         * Further, existence of Object Id, any-setter or back-reference\n         * properties also make bean deserializers non-cachable.\n         */\n        // NOTE: logic updated to include checks for ObjectIdReader, AnySetter, BackReferenceProperty\n        return (_valueTypeDeserializer == null)\n                && (_ignorableProperties == null)\n                // [databind#735]: Should also check for key/value custom deserializers?\n                // If so, that state is not available here in builder; has to be checked\n                // elsewhere? For now, let's add other known reasons for non-cachability:\n                && (_objectIdReader == null)\n                && (_backRefProperties == null)\n                && (_anySetter == null)\n        ;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}