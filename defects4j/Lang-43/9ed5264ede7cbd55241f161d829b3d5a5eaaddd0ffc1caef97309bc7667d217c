{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex(); // Original position at method entry\n        char[] c = pattern.toCharArray(); // Convert once for efficient char access\n\n        // This block handles the case where appendQuotedString is called with pos\n        // pointing to the second character of an escaped quote, e.g., the second '\\'' in \"''\"\n        // The caller (ExtendedMessageFormat.applyPattern) consumes the first quote and then\n        // calls this method with pos pointing to the character immediately after it.\n        // If that character is also a quote, and escaping is on, it signifies an escaped quote.\n        if (escapingOn && start < pattern.length() && c[start] == QUOTE) {\n            next(pos); // Consume the second '\n            // If appendTo is not null, append a single quote to represent the escaped quote.\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n\n        // `lastHold` is the start index of the current segment of characters to be appended.\n        // `pos.getIndex()` is the current character being examined in the pattern.\n        int lastHold = pos.getIndex();\n\n        // Loop through the characters in the pattern starting from the current position.\n        // The loop continues as long as `pos.getIndex()` is within the bounds of the pattern.\n        // `pos.getIndex()` is advanced by `next(pos)` or `pos.setIndex()`.\n        for ( ; pos.getIndex() < pattern.length(); ) {\n            // Check for an escaped quote sequence, e.g., \"''\"\n            // Ensure there are enough characters left in the pattern to form an ESCAPED_QUOTE\n            if (escapingOn && (pos.getIndex() + ESCAPED_QUOTE.length()) <= pattern.length() &&\n                pattern.charAt(pos.getIndex()) == QUOTE &&\n                pattern.charAt(pos.getIndex() + 1) == QUOTE) {\n\n                // Append the characters collected since `lastHold` up to the current escaped quote.\n                // Then append a single quote to represent the escaped quote.\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(QUOTE);\n                }\n                \n                // Advance position past the entire escaped quote sequence (e.g., past both 's in '')\n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex(); // Update `lastHold` to the new current position\n                continue; // Continue to the next character after the escaped quote\n            }\n\n            // Check the current character at `pos.getIndex()`\n            switch (c[pos.getIndex()]) {\n            case QUOTE: // Found the closing quote of the quoted string\n                // Calculate the length of the segment to append (characters from `lastHold`\n                // up to, but not including, the closing quote).\n                int len = pos.getIndex() - lastHold;\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, len);\n                }\n                next(pos); // Consume the closing quote\n                return appendTo; // Return the StringBuffer, as the quoted string is consumed\n            default: // Regular character inside the quoted string\n                next(pos); // Just advance the position\n            }\n        }\n        // If the loop finishes, it means a closing quote was not found before the end of the pattern.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}