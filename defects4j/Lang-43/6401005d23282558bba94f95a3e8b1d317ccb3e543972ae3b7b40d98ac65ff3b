{
    "generation": "    /**\n     * Consume a quoted string (including the quotes), adding the\n     * literal content (with '' -> ' mapping) to <code>appendTo</code>.\n     * Assumes pos points to the opening quote.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position (at the opening quote)\n     * @param appendTo optional StringBuffer to append the content\n     * @param escapingOn whether to process escaped quotes ('') inside.\n     *                   In MessageFormat, '' is always escaped, inside or outside quotes.\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) { // assuming escapingOn is true for '' rule\n\n        int startQuoteIndex = pos.getIndex();\n        // Method assumes caller ensures pattern.charAt(startQuoteIndex) == QUOTE\n\n        char[] c = pattern.toCharArray();\n        // Start reading content *after* the opening quote\n        int lastHold = startQuoteIndex + 1;\n\n        // Find the closing quote, handling '' escapes along the way\n        for (int i = lastHold; i < pattern.length(); i++) {\n            if (escapingOn && c[i] == QUOTE) {\n                // Found a quote - check if it's an escaped quote ('') or closing quote\n                if (i + 1 < pattern.length() && c[i + 1] == QUOTE) {\n                    // It's an escaped quote ('')\n                    if (appendTo != null) {\n                        // Append the segment of text before the escaped quote\n                        appendTo.append(c, lastHold, i - lastHold);\n                        // Append a single literal quote character\n                        appendTo.append(QUOTE);\n                    }\n                    // Advance index past the second quote of the pair\n                    i++;\n                    // Update lastHold to start accumulating after the escaped quote\n                    lastHold = i + 1;\n                } else {\n                    // It's the closing quote\n                    if (appendTo != null) {\n                        // Append the final segment of text before the closing quote\n                        appendTo.append(c, lastHold, i - lastHold);\n                    }\n                    // Set the ParsePosition to be *after* the closing quote\n                    pos.setIndex(i + 1);\n                    return appendTo; // Successfully parsed quoted string\n                }\n            }\n            // else: c[i] is not a quote or escaping is off, treat as regular character. Continue loop.\n            // However, the original logic structure implies that if escaping is OFF,\n            // the first quote encountered simply terminates the string. Let's refine:\n\n            else if (!escapingOn && c[i] == QUOTE) {\n                 // If escaping is off, the first quote encountered is the closing quote\n                 if (appendTo != null) {\n                     appendTo.append(c, lastHold, i - lastHold);\n                 }\n                 pos.setIndex(i + 1);\n                 return appendTo;\n            }\n            // else: c[i] is just a regular char in the string. Continue loop.\n        }\n\n        // If the loop completes without finding a closing quote\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string starting at position \" + startQuoteIndex);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}