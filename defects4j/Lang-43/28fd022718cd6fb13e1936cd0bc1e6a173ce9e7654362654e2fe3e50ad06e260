{
    "generation": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    int length = pattern.length();\n\n    // If escaping is turned off, treat a single quote as a literal and consume it\n    if (!escapingOn) {\n        if (appendTo != null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + 1);\n        return appendTo;\n    }\n\n    // Handle escaped quote outside of a quoted string: two single\u2010quotes => one literal quote\n    if (start + ESCAPED_QUOTE.length() <= length\n            && pattern.startsWith(ESCAPED_QUOTE, start)) {\n        if (appendTo != null) {\n            appendTo.append(QUOTE);\n        }\n        pos.setIndex(start + ESCAPED_QUOTE.length());\n        return appendTo;\n    }\n\n    // Otherwise this is the start of a quoted literal: consume until the matching quote\n    int i = start + 1;\n    while (i < length) {\n        char ch = pattern.charAt(i);\n        if (ch == QUOTE) {\n            // An escaped quote inside a quoted string (\u201c''\u201d => \u201c\u2018\u201d)\n            if (i + 1 < length && pattern.charAt(i + 1) == QUOTE) {\n                if (appendTo != null) {\n                    appendTo.append(QUOTE);\n                }\n                i += 2;\n                continue;\n            }\n            // A single quote ends the quoted string\n            pos.setIndex(i + 1);\n            return appendTo;\n        }\n        // Ordinary character inside quoted string\n        if (appendTo != null) {\n            appendTo.append(ch);\n        }\n        i++;\n    }\n\n    // If we get here, there was no closing quote\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + start);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}