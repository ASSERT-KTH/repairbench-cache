{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     *\n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        final char[] charArray = pattern.toCharArray(); // Convert to char array once for efficient access\n\n        // Handle the case where the current position starts with an escaped quote ''\n        // This is crucial for fixing LANG-477. If it's an escaped quote,\n        // we append a single quote and advance the position past both quotes.\n        // Check bounds explicitly to prevent StringIndexOutOfBoundsException.\n        if (escapingOn && start + ESCAPED_QUOTE.length() <= pattern.length() &&\n            charArray[start] == QUOTE && charArray[start + 1] == QUOTE) {\n            if (appendTo != null) {\n                appendTo.append(QUOTE);\n            }\n            pos.setIndex(start + ESCAPED_QUOTE.length()); // Advance past the '' sequence\n            return appendTo;\n        }\n\n        // If not an escaped quote, assume this is the start of a quoted string.\n        // The calling context (e.g., ExtendedMessageFormat.appendFormat) sets pos\n        // to point to the opening quote. So, we consume this initial quote.\n        next(pos); // Advance past the opening quote\n\n        int lastHold = pos.getIndex(); // Mark the beginning of the actual content to append\n\n        // Loop through the string from the current position, looking for the closing quote\n        // or other escaped quotes within the content.\n        while (pos.getIndex() < pattern.length()) {\n            // Check for escaped quotes within the string (e.g., 'it''s' where '' is inside)\n            // Use charArray and explicit bounds check for efficiency and safety.\n            if (escapingOn && pos.getIndex() + ESCAPED_QUOTE.length() <= pattern.length() &&\n                charArray[pos.getIndex()] == QUOTE && charArray[pos.getIndex() + 1] == QUOTE) {\n                if (appendTo != null) {\n                    // Append the characters accumulated since lastHold before the escaped quote\n                    appendTo.append(charArray, lastHold, pos.getIndex() - lastHold);\n                    // Append the single quote that represents the escaped ''\n                    appendTo.append(QUOTE);\n                }\n                // Advance position past the two characters of the escaped quote\n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex(); // Update lastHold to the new position\n                continue; // Continue parsing from the new position\n            }\n\n            // Check for the closing quote of the entire quoted string\n            if (charArray[pos.getIndex()] == QUOTE) {\n                if (appendTo != null) {\n                    // Append any remaining characters before the closing quote\n                    appendTo.append(charArray, lastHold, pos.getIndex() - lastHold);\n                }\n                next(pos); // Advance past the closing quote\n                return appendTo; // Successfully parsed and appended the quoted string\n            }\n\n            // If it's neither an escaped quote nor the closing quote, it's a regular\n            // character that is part of the quoted string content. Just advance the position.\n            next(pos);\n        }\n\n        // If the loop finishes without finding a closing quote, it means the string is unterminated.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}