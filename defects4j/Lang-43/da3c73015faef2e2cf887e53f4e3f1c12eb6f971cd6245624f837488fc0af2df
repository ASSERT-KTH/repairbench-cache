{
    "generation": "import java.text.ParsePosition; // Assuming ParsePosition is from java.text\n\n// Assuming QUOTE and ESCAPED_QUOTE are constants defined elsewhere, like:\n// private static final char QUOTE = '\\'';\n// private static final String ESCAPED_QUOTE = \"''\";\n\npublic class ExtendedMessageFormat { // Assuming this class context for constants\n\n    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray(); // Convert to char array once for efficiency\n\n        // Ensure the current position actually points to an opening quote.\n        // The method's Javadoc implies this.\n        if (start >= pattern.length() || c[start] != QUOTE) {\n            throw new IllegalArgumentException(\n                    \"Expected a quoted string starting with QUOTE at position \" + start);\n        }\n\n        // Handle the special case where the string starts with an escaped quote (e.g., \"''\").\n        // This is interpreted as a single literal quote.\n        // For example, if pattern is \"''s\" and pos is 0, this block handles the \"''\".\n        // It consumes \"''\" and appends a single \"'\".\n        if (escapingOn && pattern.startsWith(ESCAPED_QUOTE, start)) {\n            pos.setIndex(start + ESCAPED_QUOTE.length()); // Advance past \"''\"\n            return appendTo == null ? null : appendTo.append(QUOTE); // Append a single quote and return.\n        }\n\n        // Consume the opening quote character.\n        // For example, if pattern is \"'test'\", pos moves from index of first \"'\" to index of 't'.\n        pos.setIndex(start + 1);\n        int lastHold = pos.getIndex(); // 'lastHold' tracks the start of the current segment to append.\n\n        // Loop through the pattern to find the closing quote or other special characters.\n        while (pos.getIndex() < pattern.length()) {\n            // Check for an escaped quote (e.g., \"''\") within the string.\n            if (escapingOn && pattern.startsWith(ESCAPED_QUOTE, pos.getIndex())) {\n                // Append the characters accumulated since lastHold, up to the current position.\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    appendTo.append(QUOTE); // Append the single quote represented by \"''\"\n                }\n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length()); // Advance past the \"''\"\n                lastHold = pos.getIndex(); // Update lastHold to the new current position\n            } \n            // Check for the closing quote character.\n            else if (c[pos.getIndex()] == QUOTE) {\n                // Append any remaining characters before the closing quote.\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                }\n                pos.setIndex(pos.getIndex() + 1); // Advance past the closing quote.\n                return appendTo; // Successfully parsed and appended the quoted string.\n            } \n            // Default case: It's a regular character within the quoted string.\n            else {\n                pos.setIndex(pos.getIndex() + 1); // Just advance the position.\n            }\n        }\n\n        // If the loop finishes without finding a closing quote, the string is unterminated.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}