{
    "generation": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    // If an escaped quote (two consecutive quotes) is at the start, consume it and return a single quote.\n    if (escapingOn && pattern.startsWith(ESCAPED_QUOTE, start)) {\n        pos.setIndex(start + ESCAPED_QUOTE.length());\n        return appendTo == null ? null : appendTo.append(QUOTE);\n    }\n    // Otherwise, the quote marks the beginning of a quoted literal.\n    // Skip the opening quote.\n    pos.setIndex(start + 1);\n    int lastHold = pos.getIndex();\n    while (pos.getIndex() < pattern.length()) {\n        // Handle an escaped quote inside the quoted string.\n        if (escapingOn && pattern.startsWith(ESCAPED_QUOTE, pos.getIndex())) {\n            if (appendTo != null) {\n                // Append what we have seen so far (up to but not including the escaped quote)\n                appendTo.append(pattern, lastHold, pos.getIndex());\n                appendTo.append(QUOTE);\n            }\n            pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length());\n            lastHold = pos.getIndex();\n        } else {\n            char ch = pattern.charAt(pos.getIndex());\n            if (ch == QUOTE) { // Found the closing quote.\n                pos.setIndex(pos.getIndex() + 1);\n                if (appendTo != null) {\n                    // Append the text between the opening and closing quotes.\n                    appendTo.append(pattern, lastHold, pos.getIndex() - 1);\n                }\n                return appendTo;\n            } else {\n                pos.setIndex(pos.getIndex() + 1);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}