{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex(); // Store the starting position of the quoted string (the opening quote)\n\n        // The original code had a problematic early return here:\n        // if (escapingOn && c[start] == QUOTE) {\n        //     return appendTo == null ? null : appendTo.append(QUOTE);\n        // }\n        // This condition incorrectly handled a single quote at the start as an escaped quote,\n        // appended only one quote, and most critically, did NOT advance the ParsePosition.\n        // This led to an infinite loop in the calling method (e.g., ExtendedMessageFormat.applyPattern)\n        // when it re-processed the same unadvanced position, resulting in an OutOfMemoryError.\n\n        // A quoted string always starts with a quote, which must be consumed to advance parsing.\n        // This function's responsibility is to consume the *entire* quoted string,\n        // including its opening and closing quotes, and any internal escaped quotes.\n\n        // Consume the opening quote character.\n        next(pos); // Advance position past the initial QUOTE. 'pos' now points to the content or the next char.\n\n        int lastHold = pos.getIndex(); // Marks the beginning of the current segment to append\n        char[] c = pattern.toCharArray(); // Convert pattern to char array once for efficient character access\n\n        // Iterate through the pattern, starting immediately after the opening quote.\n        // The loop continues as long as 'pos' is within the pattern bounds.\n        for (; pos.getIndex() < pattern.length(); ) {\n            // Check for an escaped quote (e.g., \"''\") if escaping is enabled.\n            // This check is performed efficiently using charAt to avoid repeated substring creation.\n            // Ensure there are at least two characters remaining for an escaped quote sequence.\n            if (escapingOn && (pos.getIndex() + 1 < pattern.length()) &&\n                c[pos.getIndex()] == QUOTE && c[pos.getIndex() + 1] == QUOTE) {\n                \n                // Append the characters accumulated since 'lastHold'\n                // This appends content between the last 'lastHold' and the current 'pos.getIndex()'.\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    // Append a single QUOTE to represent the escaped '' sequence\n                    appendTo.append(QUOTE); \n                }\n                \n                // Advance position past the two characters of the escaped quote (e.g., \"''\").\n                // ESCAPED_QUOTE.length() is 2.\n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length()); \n                lastHold = pos.getIndex(); // Update 'lastHold' for the next segment after the escaped quote\n                continue; // Continue to the next iteration of the loop\n            }\n\n            // Check if the current character is the closing quote\n            if (c[pos.getIndex()] == QUOTE) {\n                // Append any remaining characters before the closing quote\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                }\n                next(pos); // Consume the closing quote by advancing 'pos'\n                return appendTo; // Successfully parsed the quoted string and return\n            }\n\n            // If it's neither an escaped quote nor the closing quote, it's a regular content character.\n            next(pos); // Consume the character by advancing 'pos'\n        }\n\n        // If the loop finishes without finding a closing quote, the quoted string is unterminated.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}