{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray(); // Convert to char array once for efficiency\n\n        // Check if the current position starts with an escaped quote sequence, e.g., \"''\"\n        // This handles cases like `it''s` where `pos` is at the first quote of `''`.\n        if (escapingOn && start + ESCAPED_QUOTE.length() <= pattern.length() &&\n            pattern.substring(start, start + ESCAPED_QUOTE.length()).equals(ESCAPED_QUOTE)) {\n            \n            // Advance position past the escaped quote sequence (e.g., past both ' in '')\n            pos.setIndex(start + ESCAPED_QUOTE.length());\n            // Append a single literal quote\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n\n        // If we are here, it means we are at the beginning of a quoted string like \"'test'\".\n        // The character at 'start' is the opening quote. Consume it.\n        // The original code was missing `next(pos)` here for actual quoted strings,\n        // which would leave `pos` stuck at the opening quote, leading to incorrect parsing.\n        next(pos); \n        int lastHold = pos.getIndex(); // lastHold marks the beginning of the literal content *after* the opening quote.\n\n        // Loop to find the closing quote or escaped quotes within the string.\n        // We use a for(;;) infinite loop and explicitly break out with return or throw.\n        for (;;) {\n            // Check for end of pattern before finding closing quote\n            if (pos.getIndex() >= pattern.length()) {\n                throw new IllegalArgumentException(\n                        \"Unterminated quoted string at position \" + start);\n            }\n\n            // Check for escaped quote sequence within the string (e.g., \"''\" inside \"'abc''def'\")\n            if (escapingOn && pos.getIndex() + ESCAPED_QUOTE.length() <= pattern.length() &&\n                pattern.substring(pos.getIndex(), pos.getIndex() + ESCAPED_QUOTE.length()).equals(ESCAPED_QUOTE)) {\n                \n                // Append the characters collected since lastHold up to the current position (before the escaped quote)\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    appendTo.append(QUOTE); // Then append a single literal quote\n                }\n                \n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length()); // Advance past the escaped quote sequence\n                lastHold = pos.getIndex(); // Update lastHold to the new position (after the escaped quote)\n                continue; // Continue scanning from the new position\n            }\n\n            // Get the character at the current parse position\n            char currentChar = c[pos.getIndex()];\n\n            if (currentChar == QUOTE) {\n                // Found the closing quote of the string.\n                // Append any remaining content before this closing quote.\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                }\n                next(pos); // Consume the closing quote\n                return appendTo; // Return the buffer\n            } else {\n                // Regular character, just consume it and continue to the next character.\n                next(pos);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}