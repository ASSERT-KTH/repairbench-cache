{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        // The 'start' variable here is for the error message, indicating where the quoted string began.\n        // 'pos.getIndex()' upon entry points to the first character *after* the opening quote.\n        int start = pos.getIndex(); \n        char[] c = pattern.toCharArray();\n\n        // The initial 'if' block from the original code was problematic.\n        // When appendQuotedString is called, pos.getIndex() is already past the opening quote.\n        // If c[start] is a QUOTE, it implies an escaped quote (e.g., 'foo''''bar'),\n        // and the loop below is designed to handle this correctly.\n        // Removing this prevents incorrect early returns and inconsistent position updates.\n\n        int lastHold = pos.getIndex(); // Marks the beginning of the segment to append to appendTo\n\n        // Loop while the current parsing position is within the pattern bounds.\n        // All position advances are handled via 'pos' directly, avoiding synchronization issues.\n        while (pos.getIndex() < pattern.length()) {\n            // Check if the current segment starts with an escaped quote 'ESCAPED_QUOTE' (i.e., '').\n            // This check only applies if escaping is currently \"on\" for the context (e.g., within a format argument).\n            if (escapingOn && pattern.substring(pos.getIndex()).startsWith(ESCAPED_QUOTE)) {\n                // Found an escaped quote 'EO_ESCAPE'\n                // Append the characters accumulated since 'lastHold' to 'appendTo'.\n                if (appendTo != null) {\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    appendTo.append(QUOTE); // Append the single unescaped quote character.\n                }\n                // Advance 'pos' past the entire 'ESCAPED_QUOTE' sequence (two quotes).\n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex(); // Update 'lastHold' to the new current position.\n                // No 'continue' needed, the loop condition will be re-evaluated naturally.\n            } else {\n                // Not an escaped quote, so process the current character.\n                switch (c[pos.getIndex()]) {\n                case QUOTE: // Found a closing quote.\n                    // Append any remaining characters before the closing quote.\n                    if (appendTo != null) {\n                        appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    }\n                    next(pos); // Consume the closing quote.\n                    return appendTo; // The quoted string is fully consumed, return.\n                default: // Regular character.\n                    next(pos); // Consume the character and advance 'pos'.\n                    // 'lastHold' remains the same as we are still accumulating characters for the current segment.\n                }\n            }\n        }\n        // If the loop finishes without finding a closing quote, the string is unterminated.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}