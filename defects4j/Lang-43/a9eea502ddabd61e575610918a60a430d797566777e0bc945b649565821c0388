{
    "generation": "    /**\n     * Consume a quoted string, adding it to <code>appendTo</code> if\n     * specified.\n     * \n     * @param pattern pattern to parse\n     * @param pos current parse position\n     * @param appendTo optional StringBuffer to append\n     * @param escapingOn whether to process escaped quotes\n     * @return <code>appendTo</code>\n     */\n    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray(); // Convert once to char array for efficient character access\n\n        // The QUOTE character is used to delimit quoted strings, and a double QUOTE (escaped quote)\n        // represents a literal QUOTE character within a quoted string or even as a literal sequence.\n        // This function is called when `pos.getIndex()` points to a QUOTE.\n        // We need to differentiate between an opening QUOTE of a string, and an escaped QUOTE (like `''`).\n\n        // Handle the case where the current position is an escaped quote (e.g., \"''\").\n        // This allows patterns like \"it''s\" to parse \"''\" as a single literal quote.\n        // If escaping is on and the current character and the next character are both QUOTE,\n        // it means we've found an escaped quote, not the start of a quoted string.\n        if (escapingOn && start + ESCAPED_QUOTE.length() <= pattern.length() &&\n            c[start] == QUOTE && c[start + 1] == QUOTE) {\n            if (appendTo != null) {\n                appendTo.append(QUOTE); // Append a single literal QUOTE\n            }\n            pos.setIndex(start + ESCAPED_QUOTE.length()); // Advance past both quotes in \"''\"\n            return appendTo; // Processing of this escaped quote is complete.\n        }\n\n        // If the code reaches here, it means c[start] is the opening QUOTE of a quoted string.\n        // Consume the opening quote. `pos` now points to the first character *inside* the quoted string.\n        next(pos);\n        int lastHold = pos.getIndex(); // `lastHold` marks the start of the current segment of characters to append.\n\n        while (pos.getIndex() < pattern.length()) {\n            // Check for an escaped quote \"''\" within the quoted string.\n            // This is distinct from the initial check above which handles \"''\" as a standalone literal.\n            if (escapingOn && pos.getIndex() + 1 < pattern.length() &&\n                c[pos.getIndex()] == QUOTE && c[pos.getIndex() + 1] == QUOTE) {\n                // Found an escaped quote \"''\"\n                if (appendTo != null) {\n                    // Append characters accumulated since `lastHold` up to the current position (before \"''\")\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                    appendTo.append(QUOTE); // Append the single literal quote for \"''\"\n                }\n                pos.setIndex(pos.getIndex() + ESCAPED_QUOTE.length()); // Advance past \"''\"\n                lastHold = pos.getIndex(); // Reset `lastHold` to the new current position\n            } else if (c[pos.getIndex()] == QUOTE) {\n                // Found the closing quote of the string\n                if (appendTo != null) {\n                    // Append any remaining characters from `lastHold` up to the current position (before the closing quote)\n                    appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                }\n                next(pos); // Consume the closing quote.\n                return appendTo; // The quoted string has been successfully consumed.\n            } else {\n                // Regular character: part of the quoted string content, just advance position.\n                next(pos);\n            }\n        }\n        // If the loop finishes, it means we reached the end of the pattern without finding a closing quote.\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}