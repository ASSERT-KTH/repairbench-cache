{
    "generation": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        // The original code checked n.getParent().isVar().\n        // This implicitly excluded function declarations and parameters, etc.\n        // The test testNonAliasLocal includes 'function f() {}' which\n        // implies function declarations that are not aliases should also cause an error.\n        // The comments indicate that parameters and bleeding functions\n        // already get a BAD_PARAMETERS error, implying they should not\n        // get GOOG_SCOPE_NON_ALIAS_LOCAL.\n        //\n        // By checking v.isLocal() (for var, let, const) or v.isFunction(),\n        // we correctly target the variables that should be considered\n        // \"non-alias locals\" while respecting the exclusions for parameters\n        // and bleeding functions (which are typically global or specifically exposed).\n        if (v.isLocal() || v.isFunction()) {\n          // Check if it's an alias assignment (e.g., var x = goog.foo.bar;)\n          // An alias must have an initializer that is a qualified name.\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = scope.getVar(name);\n            aliases.put(name, aliasVar);\n\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n          } else {\n            // It's a local variable (var/let/const) or a function declaration,\n            // but not an alias. Report it as a non-alias local.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n      }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}