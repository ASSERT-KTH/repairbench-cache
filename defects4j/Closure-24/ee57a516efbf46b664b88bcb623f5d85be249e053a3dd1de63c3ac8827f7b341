{
    "generation": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNameNode(); // The NAME node (e.g., 'x' in var x = ...)\n        Node parent = n.getParent();\n\n        // Ignore declarations that are not directly in the scope body.\n        // Check if the parent's parent is the scope root (BLOCK node).\n        Node grandparent = parent.getParent();\n        if (grandparent == null || !grandparent.isBlock() || grandparent != scope.getRootNode()) {\n          continue;\n        }\n\n        // Ignore function parameters (handled by different checks)\n        if (parent.isParamList()) {\n          continue;\n        }\n\n        // Ignore the implicit 'arguments' variable\n        if (n.getString().equals(\"arguments\")) {\n            continue;\n        }\n\n        // Bleeding functions are handled elsewhere (according to original comments)\n        if (v.isBleedingFunction()) {\n            continue;\n        }\n\n        // Now, determine if it's a valid alias declaration or should be reported.\n        boolean isAliasDefinition = false;\n        if (parent.isVar()) {\n          Node value = n.getFirstChild(); // The assigned value (if any)\n          if (value != null && value.isQualifiedName()) {\n            // It's a var declaration assigned a qualified name. This is a potential alias.\n            String name = n.getString();\n            Var aliasVar = v; // Same as scope.getVar(name)\n            Node initialValue = aliasVar.getInitialValue();\n\n            // Verify the initial value node matches the value node we found.\n            // Also check if getQualifiedName() returns non-null.\n            if (initialValue == value) {\n                String qualifiedName = initialValue.getQualifiedName();\n                if (qualifiedName != null) {\n                    // It's a confirmed alias.\n                    isAliasDefinition = true;\n                    aliases.put(name, aliasVar);\n                    transformation.addAlias(name, qualifiedName);\n                }\n            }\n          }\n          // If it's a VAR but not a confirmed alias, it's an error.\n          // The !isAliasDefinition check below handles this.\n        }\n        // Function declarations (`function f() {}`) are not valid aliases\n        // and other direct declarations (like let/const if supported) are also not aliases.\n\n        // Report error if it's a variable declared directly in the scope\n        // that is not a valid alias definition.\n        if (!isAliasDefinition) {\n          // Only report for VAR and FUNCTION nodes, as other types like\n          // parameters or catch variables are already filtered out.\n          // Class declarations might need explicit handling if they become common.\n          if (parent.isVar() || parent.isFunction()) {\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}