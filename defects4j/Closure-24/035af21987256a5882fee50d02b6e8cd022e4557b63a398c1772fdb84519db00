{
    "generation": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode(); // The NAME node (e.g., 'x' in var x = ...)\n        Node parent = n.getParent(); // The declaration node (e.g., VAR or FUNCTION)\n\n        // Skip parameters of the scope function, they get BAD_PARAMETERS error.\n        if (v.isParam()) {\n          continue;\n        }\n\n        // Skip bleeding functions (var fn = function() {}), they get BAD_PARAMETERS error.\n        // Per comments in original code.\n        if (v.isBleedingFunction()) {\n          continue;\n        }\n\n        // Check local variable declarations: var or function\n        if (parent.isVar()) {\n          Node valueNode = n.getFirstChild(); // RHS of assignment, or null for 'var x;'\n\n          // Check if it's a valid alias: var name = qualified.name;\n          if (valueNode != null && valueNode.isQualifiedName()) {\n            String name = n.getString();\n            String qualifiedName = valueNode.getQualifiedName();\n\n            // Ensure qualifiedName is not null (defensive check)\n            // and that the alias doesn't shadow a global Confirmation variable.\n            if (qualifiedName != null) {\n              // Record the valid alias\n              aliases.put(name, v);\n              transformation.addAlias(name, qualifiedName);\n            } else {\n              // Should not happen if isQualifiedName is true, but report if it does.\n              report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n            }\n          } else {\n            // Not a valid alias (var x = 10; var x; var x = funcRef;)\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        } else if (parent.isFunction() && n == parent.getFirstChild()) {\n          // Function declaration: function f() {} is not an alias\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n        // We ignore other kinds of variables (like catch) here, assuming they\n        // are either irrelevant or handled by other checks. The goal is to\n        // distinguish valid aliases from invalid local declarations (var/function).\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}