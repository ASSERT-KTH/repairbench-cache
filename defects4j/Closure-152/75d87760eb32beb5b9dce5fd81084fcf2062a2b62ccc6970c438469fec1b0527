{
    "generation": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  // Bug fix: handle UnionType cases properly\n  JSType resolvedThis = safeResolve(typeOfThis, t, scope);\n  if (resolvedThis.isUnionType()) {\n    UnionType union = resolvedThis.toMaybeUnionType();\n    if (union.isPartitioned()) {\n      // Try to extract object-type components from the union\n      List<ObjectType> objectComponents = new ArrayList<>();\n      for (JSType alt : union.getAlternates()) {\n        if (alt.isObjectType()) {\n          objectComponents.add((ObjectType) alt);\n        }\n      }\n      if (!objectComponents.isEmpty()) {\n        // If there are object components, use them (or a union of them)\n        if (objectComponents.size() == 1) {\n          typeOfThis = objectComponents.get(0);\n        } else {\n          // If multiple object types, create a union of just the object types\n          typeOfThis = new UnionType(objectComponents, false);\n        }\n      } else {\n        // If no object components, fall back to a warning (to be handled upstream)\n        typeOfThis = getNativeType(ObjectType.class);\n      }\n    } else {\n      // If not partitioned, just keep as union (upstream will handle warning)\n      typeOfThis = union;\n    }\n  } else {\n    typeOfThis = (ObjectType) resolvedThis;\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}