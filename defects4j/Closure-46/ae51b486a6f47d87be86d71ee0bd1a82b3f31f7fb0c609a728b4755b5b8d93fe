{
    "generation": "  @Override\n  public JSType getLeastSupertype(JSType that) {\n    // If 'that' is not a record type, delegate to the superclass implementation.\n    // This handles cases where 'this' is a RecordType but 'that' is another kind of JSType.\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n\n    // At this point, both 'this' (the current RecordType) and 'that' (the input JSType)\n    // are known to be RecordTypes.\n\n    // If 'this' is a subtype of 'that', then 'that' is the least general type that is a supertype of both.\n    // Example: this = {a: number, b: string}, that = {a: number}.\n    // Here, 'this' is a subtype of 'that' (as 'that' has fewer properties or more general property types).\n    // The least supertype of {a: number, b: string} and {a: number} is {a: number}.\n    if (this.isSubtype(that)) {\n      return that;\n    }\n\n    // If 'that' is a subtype of 'this', then 'this' is the least general type that is a supertype of both.\n    // Example: this = {a: number}, that = {a: number, b: string}.\n    // Here, 'that' is a subtype of 'this'.\n    // The least supertype of {a: number} and {a: number, b: string} is {a: number}.\n    if (that.isSubtype(this)) {\n      return this;\n    }\n\n    // If neither type is a subtype of the other, they do not have a direct supertype-subtype relationship.\n    // In this case, the least common supertype is typically their union.\n    // Example: this = {a: number, b: string}, that = {d: number, e: string}.\n    // The least supertype is ({a: number, b: string}|{d: number, e: string}).\n    return registry.createUnionType(this, that);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}