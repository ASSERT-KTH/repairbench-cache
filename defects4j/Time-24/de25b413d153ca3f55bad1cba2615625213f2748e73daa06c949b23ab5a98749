{
    "generation": "    /**\n     * Computes the parsed datetime by setting the saved fields.\n     * This method is idempotent, but it is not thread-safe.\n     *\n     * @param resetFields false by default, but when true, unsaved field values are cleared\n     * @param text optional text being parsed, to be included in any error message\n     * @return milliseconds since 1970-01-01T00:00:00Z\n     * @throws IllegalArgumentException if any field is out of range\n     * @since 1.3\n     */\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        // Fields are sorted by duration magnitude (largest first).\n        sort(savedFields, count);\n\n        // This block handles cases where the first sorted field implies a default year is needed,\n        // typically when no year or weekyear is explicitly parsed.\n        // It recursively calls computeMillis after adding the default year.\n        if (count > 0) {\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            // This condition is true if 'first' is a field with duration between days and months (inclusive),\n            // e.g., week, day, hour, minute, second, millis.\n            // It suggests that no year or month field was the \"largest\" (first in sorted order).\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n\n        // Collect specific field types for special handling.\n        // This is crucial for handling ISO week-date ambiguities when combined with month/day.\n        SavedField yearField = null;\n        SavedField monthField = null;\n        SavedField dayField = null;\n        SavedField weekYearFld = null;\n        SavedField weekOfWeekYearFld = null;\n        SavedField dayOfWeekFld = null;\n\n        java.util.List<SavedField> simpleFields = new java.util.ArrayList<SavedField>();\n\n        for (int i = 0; i < count; i++) {\n            SavedField field = savedFields[i];\n            DateTimeFieldType type = field.iField.getType();\n            if (type == DateTimeFieldType.year()) {\n                yearField = field;\n            } else if (type == DateTimeFieldType.monthOfYear()) {\n                monthField = field;\n            } else if (type == DateTimeFieldType.dayOfMonth()) {\n                dayField = field;\n            } else if (type == DateTimeFieldType.weekyear()) {\n                weekYearFld = field;\n            } else if (type == DateTimeFieldType.weekOfWeekyear()) {\n                weekOfWeekYearFld = field;\n            } else if (type == DateTimeFieldType.dayOfWeek()) {\n                dayOfWeekFld = field;\n            } else {\n                simpleFields.add(field); // fields like hour, minute, second etc.\n            }\n        }\n        \n        // Prioritize ISO week-date fields if a weekyear (xxxx), weekOfWeekyear (ww), or dayOfWeek (e/E)\n        // was explicitly parsed. This addresses the common ambiguity when 'ww' interacts\n        // with 'MM' across year boundaries in the ISO week-date system.\n        if (weekYearFld != null || weekOfWeekYearFld != null || dayOfWeekFld != null) {\n            // Use current millis as a base, which might already contain time fields or a default year.\n            long tempMillis = millis;\n\n            // 1. Apply weekyear or calendar year first.\n            if (weekYearFld != null) {\n                tempMillis = weekYearFld.set(tempMillis, resetFields);\n            } else if (yearField != null) {\n                tempMillis = yearField.set(tempMillis, resetFields);\n            }\n            \n            // 2. Apply weekOfWeekyear. If not specified, default to week 1 if a year/weekyear is present.\n            if (weekOfWeekYearFld != null) {\n                tempMillis = weekOfWeekYearFld.set(tempMillis, resetFields);\n            } else {\n                // If weekyear or year was parsed, default week to 1 if not explicitly set.\n                if (weekYearFld != null || yearField != null) {\n                    tempMillis = iChrono.weekOfWeekyear().set(tempMillis, 1);\n                }\n            }\n\n            // 3. Apply dayOfWeek. If not specified, default to MONDAY if a year/weekyear/week is present.\n            if (dayOfWeekFld != null) {\n                tempMillis = dayOfWeekFld.set(tempMillis, resetFields);\n            } else {\n                // If weekyear/year/week are set, default day of week to MONDAY.\n                if (weekYearFld != null || yearField != null) { // This condition implicitly covers if weekOfWeekYearFld was used.\n                    tempMillis = iChrono.dayOfWeek().set(tempMillis, org.joda.time.DateTimeConstants.MONDAY);\n                }\n            }\n            \n            // 4. Apply month and day fields as adjustments to the established week-date.\n            // This order prevents month/day from incorrectly shifting the year.\n            if (monthField != null) {\n                tempMillis = monthField.set(tempMillis, resetFields);\n            }\n            if (dayField != null) {\n                tempMillis = dayField.set(tempMillis, resetFields);\n            }\n            \n            // 5. Finally, apply all other simple fields (hours, minutes, seconds, milliseconds).\n            // These fields were already sorted correctly by duration.\n            for (SavedField field : simpleFields) {\n                tempMillis = field.set(tempMillis, resetFields);\n            }\n            millis = tempMillis; // Update the final milliseconds\n        } else {\n            // If no week-related fields were explicitly parsed (i.e., not using xxxx-ww-e patterns),\n            // then apply all fields in their default sorted order (largest duration first).\n            try {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, resetFields);\n                }\n            } catch (IllegalFieldValueException e) {\n                if (text != null) {\n                    e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                }\n                throw e;\n            }\n        }\n        \n        // Timezone offset handling (original logic)\n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}