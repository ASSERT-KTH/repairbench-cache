{
    "generation": "public long computeMillis(boolean resetFields, String text) {\n    // Clone the saved fields array if it is shared\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n\n    //\n    // BEGIN PATCH: Treat a 'yyyy' + 'ww' combination as if it were 'xxxx' + 'ww',\n    // so that week\u2010of\u2010weekyear uses the parsed year as its weekyear context.\n    //\n    DateTimeField yearField = DateTimeFieldType.year().getField(iChrono);\n    DateTimeField weekyearField = DateTimeFieldType.weekyear().getField(iChrono);\n    DateTimeField weekOfWeekyearField = DateTimeFieldType.weekOfWeekyear().getField(iChrono);\n\n    boolean hasYear = false;\n    boolean hasWeekyear = false;\n    boolean hasWeekOfWeekyear = false;\n    int yearValue = iDefaultYear;\n\n    // Scan the saved fields\n    for (int j = 0; j < count; j++) {\n        SavedField sf = savedFields[j];\n        DateTimeField f = sf.iField;\n        if (f == yearField) {\n            hasYear = true;\n            yearValue = sf.iValue;\n        } else if (f == weekyearField) {\n            hasWeekyear = true;\n        } else if (f == weekOfWeekyearField) {\n            hasWeekOfWeekyear = true;\n        }\n    }\n\n    // If the user supplied a year\u2010of\u2010era and a week\u2010of\u2010weekyear, but no explicit weekyear,\n    // remove the year\u2010of\u2010era field and inject a weekyear field in its place, then re\u2010run.\n    if (hasYear && hasWeekOfWeekyear && !hasWeekyear) {\n        // remove all year\u2010of\u2010era savedFields\n        int pos = 0;\n        for (int j = 0; j < count; j++) {\n            SavedField sf = savedFields[j];\n            if (sf.iField != yearField) {\n                savedFields[pos++] = sf;\n            }\n        }\n        iSavedFieldsCount = pos;\n        // now save the parsed year as a weekyear\n        saveField(DateTimeFieldType.weekyear(), yearValue);\n        // recurse to re\u2010sort & apply\n        return computeMillis(resetFields, text);\n    }\n    //\n    // END PATCH\n    //\n\n    // Original month/day injection logic\n    sort(savedFields, count);\n    if (count > 0) {\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int j = 0; j < count; j++) {\n            millis = savedFields[j].set(millis, resetFields);\n            resetFields = false;\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n\n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n\n    return millis;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}