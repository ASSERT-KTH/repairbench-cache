{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      // If already processed, return.\n      // This ensures idempotency if called multiple times (e.g., recursively).\n      if (replacementNode != null) {\n        return;\n      }\n\n      // Ensure parent namespace is processed first if this namespace declaration\n      // needs to be moved to the minimumModule. This is crucial for inserting\n      // this namespace relative to its parent.\n      if (firstModule != minimumModule && candidateDefinition == null) {\n        int indexOfDot = namespace.indexOf('.');\n        if (indexOfDot != -1) {\n          ProvidedName parentName =\n              providedNames.get(namespace.substring(0, indexOfDot));\n          // The parent *must* exist in the map, either explicitly provided or implicitly created.\n          Preconditions.checkNotNull(parentName, \"Parent namespace %s not found for %s\", namespace.substring(0, indexOfDot), namespace);\n\n          // If the parent hasn't been processed yet (its replacementNode is null),\n          // process it now recursively.\n          if (parentName.replacementNode == null) {\n            parentName.replace(); // This recursive call will handle the parent.\n\n            // After the recursive call returns, the parent's replacementNode must have been set.\n            Preconditions.checkNotNull(parentName.replacementNode,\n                \"Recursive parent replace call failed to set replacement node for %s (parent of %s)\",\n                parentName.namespace, namespace);\n          }\n          // If parentName.replacementNode was already non-null, the parent was already processed.\n        }\n      }\n\n      // Base case: 'goog' is predefined. ProcessClosurePrimitives handles this by setting\n      // candidateDefinition to the goog object node. firstNode is null for 'goog'.\n      if (firstNode == null) {\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Case 1: Handle duplicate definition (goog.provide + user definition exists)\n      if (candidateDefinition != null && explicitNode != null) {\n        // Remove the goog.provide() call node if it's still in the AST.\n        if (explicitNode.getParent() != null) {\n          explicitNode.detachFromParent();\n          compiler.reportCodeChange();\n        }\n\n        // Default replacement is the user's definition.\n        replacementNode = candidateDefinition;\n\n        // If the user definition is an EXPR_RESULT (like 'ns = value;' or 'ns.sub = value;'),\n        // we might need to transform it (e.g., to 'var ns = value;').\n        if (candidateDefinition.isExprResult()) {\n          // Mark the expression node as potentially defining a namespace part.\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n\n          // Check if it's an assignment.\n          if (assignNode.isAssign()) {\n            Node nameNode = assignNode.getFirstChild(); // The L-value (NAME or GETPROP)\n\n            if (nameNode.isName()) {\n              // It's an assignment to a simple name: 'name = value;'\n              // Convert it to a VAR declaration: 'var name = value;'\n              Node valueNode = nameNode.getNext(); // The R-value\n\n              // Detach children from the original ASSIGN node.\n              assignNode.detachChildren();\n              // Build the NAME node structure for the VAR (NAME -> value).\n              nameNode.addChildToFront(valueNode == null ? IR.empty() : valueNode);\n              // Create the new VAR node.\n              Node varNode = IR.var(nameNode);\n\n              // Copy source info and JSDoc from original EXPR_RESULT/ASSIGN to new VAR/NAME.\n              varNode.copyInformationFrom(candidateDefinition);\n              JSDocInfo jsDocInfo = candidateDefinition.getJSDocInfo() != null ?\n                  candidateDefinition.getJSDocInfo() : assignNode.getJSDocInfo();\n              varNode.setJSDocInfo(jsDocInfo);\n              // Copy JSDoc to NAME node as well? Often useful for type checking.\n              nameNode.setJSDocInfo(jsDocInfo);\n\n              // Replace the original EXPR_RESULT node with the new VAR node.\n              Node parent = candidateDefinition.getParent();\n              if (parent != null) {\n                  parent.replaceChild(candidateDefinition, varNode);\n                  compiler.reportCodeChange();\n                  replacementNode = varNode; // The replacement is the new VAR node.\n              } else {\n                  // Should not happen if candidateDefinition was from the AST.\n                  // Log error or handle? For now, just point replacementNode to varNode.\n                   replacementNode = varNode;\n              }\n            } else if (nameNode.isGetProp()) {\n              // It's an assignment to a property: 'ns.sub = value;'\n              // Keep it as is. The EXPR_RESULT node is the correct structure.\n              // Ensure JSDoc is associated with the EXPR_RESULT node if needed.\n              // replacementNode is already set to candidateDefinition.\n            }\n            // Else: Other assignment types? (e.g., destructuring) Not typically used for namespaces.\n          }\n          // Else: EXPR_RESULT node doesn't contain ASSIGN? Unusual.\n        }\n        // Else: candidateDefinition is not an EXPR_RESULT (e.g., already a VAR, FUNCTION). Use as is.\n        // replacementNode is already set to candidateDefinition.\n\n      } else {\n        // Case 2: No duplicate definition (implicit namespace or only goog.provide)\n        // Create a declaration node (e.g., 'var ns = {};' or 'ns.sub = {};').\n        replacementNode = createDeclarationNode();\n\n        // Remove the original goog.provide() call node if it existed and is still in the tree.\n        // Do this *before* adding the new node, especially if insertion is relative to firstNode.\n        Node nodeToInsertBefore = firstNode;\n        if (explicitNode != null && explicitNode.getParent() != null) {\n            // If the node we plan to insert before *is* the goog.provide call,\n            // update our reference to be the node *after* the goog.provide call.\n            if (explicitNode == firstNode) {\n                nodeToInsertBefore = firstNode.getNext();\n            }\n            explicitNode.detachFromParent();\n            compiler.reportCodeChange();\n        }\n\n        // Insert the newly created declaration node into the AST.\n        if (firstModule == minimumModule) {\n          // Place in the module where the namespace first appeared.\n          Node insertParent = firstNode.getParent(); // Parent of the original first reference.\n          if (insertParent != null) {\n              // Add the new node before the first usage/reference (or adjusted nodeToInsertBefore).\n              insertParent.addChildBefore(replacementNode, nodeToInsertBefore);\n              compiler.reportCodeChange();\n          } // else: Parent is somehow null? Cannot insert. Error state.\n        } else {\n          // Namespace was implicitly provided across modules. Place it in the common ancestor module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Top-level implicit namespace (e.g., \"apps\"). Add to the start of minimumModule.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToFront(replacementNode); // ToFront is suitable for declarations.\n            compiler.reportCodeChange();\n          } else {\n            // Nested implicit namespace (e.g., \"apps.foo\"). Add after the parent's declaration node.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            // Parent and its replacement node must exist due to the recursive check/call at the function start.\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode, \"Parent namespace %s has no replacement node for %s\", parentName.namespace, namespace);\n\n            Node parentNode = parentName.replacementNode;\n            Node insertionPoint = parentNode.getParent(); // The node containing the parent's declaration.\n            Preconditions.checkState(insertionPoint != null, \"Parent node %s is not in the AST for %s\", parentNode.toStringTree(), namespace);\n\n            // Add the new node right after the parent's node.\n            insertionPoint.addChildAfter(replacementNode, parentNode);\n            compiler.reportCodeChange();\n          }\n        }\n        // Note: explicitNode detachment moved earlier for safety.\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}