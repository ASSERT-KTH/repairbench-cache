{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog') or cases where the name is implicitly provided\n        // by a definition created before the first goog.provide.\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol. (e.g., goog.provide('a'); var a = {};)\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent(); // Remove the goog.provide call.\n\n        // Does this need a VAR keyword? Check if the definition is assign-based.\n        replacementNode = candidateDefinition;\n        // Check if the candidate is an EXPR_RESULT node (like `a = {};` or `a.b = {};`)\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild(); // e.g., ASSIGN\n          // Check if it's a simple assignment to a NAME, like `a = {}`\n          if (assignNode.isAssign()) {\n             Node nameNode = assignNode.getFirstChild(); // The LHS of the assign\n             if (nameNode.isName()) {\n               // Need to convert 'name = value;' (EXPR_RESULT) to 'var name = value;' (VAR)\n               Node valueNode = nameNode.getNext(); // The RHS\n               assignNode.removeChild(nameNode);\n               assignNode.removeChild(valueNode);\n               nameNode.addChildToFront(valueNode); // NAME node now has value as child\n               Node varNode = new Node(Token.VAR, nameNode); // Create VAR(NAME(VALUE))\n               varNode.copyInformationFrom(candidateDefinition); // Copy source pos info\n\n               // Replace the original EXPR_RESULT node with the new VAR node.\n               Node parent = candidateDefinition.getParent();\n               parent.replaceChild(candidateDefinition, varNode);\n\n               // Transfer JSDoc from the original expression statement's assign node\n               nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n               replacementNode = varNode; // Update our reference\n             }\n          }\n        }\n        // We detached a node and potentially replaced another.\n        compiler.reportCodeChange();\n\n      } else { // No duplicate definition: Need to create a declaration.\n        replacementNode = createDeclarationNode(); // e.g., 'var ns = {}' or 'ns.sub = {}'\n\n        // Determine where to insert the new declaration node.\n        if (firstModule == minimumModule) {\n          // First occurrence was in the earliest module involved in the namespace path.\n          // Insert the declaration right before the first occurrence node (usually the goog.provide).\n          Preconditions.checkNotNull(firstNode, \"Expected firstNode for non-implicit provide\");\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // First occurrence was NOT in the earliest module (minimumModule).\n          if (explicitNode != null) {\n            // This name was EXPLICITLY provided in this later module (firstModule).\n            // The declaration belongs in this module (firstModule).\n            // Insert before the goog.provide statement (which is firstNode).\n            Preconditions.checkNotNull(firstNode);\n            // If explicitNode exists, it implies a goog.provide, which should be the first node.\n            Preconditions.checkState(explicitNode == firstNode,\n                \"Explicit node is not the first node for namespace %s\", namespace);\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n          } else {\n            // This name was IMPLICITLY provided (needed for a child namespace like 'a' in 'a.b.c').\n            // The declaration must be hoisted to the minimumModule.\n            int indexOfDot = namespace.lastIndexOf('.'); // Get parent namespace: \"a.b\" for \"a.b.c\"\n            Node insertionScript = compiler.getNodeForCodeInsertion(minimumModule);\n\n            if (indexOfDot == -1) {\n              // An implicit root namespace? This is unusual if firstModule != minimumModule.\n              // It might happen if the root was implicitly created by a child in a later module.\n              // Hoist to minimum module, add to back as a fallback strategy.\n              compiler.reportWarning(\n                  ProcessClosurePrimitives.INVALID_PROVIDE_NAMESPACE, // Use a suitable warning type\n                  namespace);\n              insertionScript.addChildToBack(replacementNode);\n            } else {\n              // Implicit nested namespace. Insert into minimumModule.\n              // Try to insert AFTER the parent's node within minimumModule for correct ordering.\n              ProvidedName parentName =\n                  providedNames.get(namespace.substring(0, indexOfDot));\n              Preconditions.checkNotNull(parentName,\n                  \"Parent namespace %s should have been provided\",\n                  namespace.substring(0, indexOfDot));\n\n              Node parentNode = parentName.replacementNode;\n\n              // Check if parentNode exists and is already placed in the target script.\n              if (parentNode != null && parentNode.getParent() == insertionScript) {\n                 // Insert after the parent node.\n                 insertionScript.addChildAfter(replacementNode, parentNode);\n              } else {\n                 // Parent node not found in the target script yet (either null, or not yet moved).\n                 // Add to the end of the target script. Relies on execution order or\n                 // subsequent processing to ensure parent exists before child usage.\n                 insertionScript.addChildToBack(replacementNode);\n              }\n            }\n          }\n        }\n\n        // Remove the original goog.provide() statement if this name was explicitly provided.\n        // Note: If candidateDefinition was not null, explicitNode was detached earlier.\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n\n        // Report change as we've inserted a new node and potentially detached the explicitNode.\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}