{
    "generation": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.common.base.Preconditions; // Ensure this import is present\n\n// Assuming NodeUtil is accessible and other class members like compiler,\n// firstNode, explicitNode, candidateDefinition, minimumModule, namespace,\n// providedNames, replacementNode, firstModule, isNamespace() are in scope.\n\n// Private helper method to extract the name/getprop node from a declaration/assignment statement.\nprivate Node getActualNameNode(Node declarationNode) {\n    if (declarationNode == null) {\n        return null;\n    }\n    if (declarationNode.isVar()) {\n        // For 'var name = value;', returns the 'name' (VAR_DECL child of VAR)\n        return declarationNode.getFirstChild();\n    } else if (NodeUtil.isExpressionNode(declarationNode)) {\n        // For 'name = value;' or 'name.prop = value;', returns 'name' or 'name.prop'\n        Node assignNode = declarationNode.getFirstChild(); // Should be an ASSIGN node\n        if (assignNode != null && assignNode.isAssign()) {\n            return assignNode.getFirstChild(); // Should be the NAME or GETPROP node\n        }\n    } else if (declarationNode.isFunction()) {\n        // For 'function name() {}', returns 'name'\n        return declarationNode.getFirstChild(); // Should be a NAME node\n    }\n    // If the node itself is a NAME or GETPROP (less common for replacementNode, but safe check)\n    if (declarationNode.isName() || declarationNode.isGetProp()) {\n        return declarationNode;\n    }\n    return null;\n}\n\n    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        // Ensure IS_NAMESPACE is set on the relevant node if it's a namespace\n        if (this.isNamespace() && replacementNode != null) {\n            Node nameNode = getActualNameNode(replacementNode);\n            if (nameNode != null) {\n                nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            }\n        }\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        replacementNode = candidateDefinition;\n\n        // Ensure Node.IS_NAMESPACE is set on the relevant name node if this is a namespace.\n        // The original code was incorrect: it set it on the statement node itself\n        // (EXPR_RESULT) and only for simple names, missing GETPROP and VAR cases.\n        if (this.isNamespace()) {\n            Node nameNode = getActualNameNode(replacementNode);\n            if (nameNode != null) {\n                nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            }\n        }\n\n        // Check if the definition needs to be converted to a VAR declaration\n        // (e.g., 'x = 1;' becoming 'var x = 1;')\n        if (NodeUtil.isExpressionNode(candidateDefinition)) { // Only applies if candidateDefinition is an EXPR_RESULT statement\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild(); // This is the NAME or GETPROP node\n          if (nameNode.getType() == Token.NAME) { // Only if the assignee is a simple name (not a property)\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode); // 'nameNode' now acts as a VAR_DECL\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition); // Copy source info, etc.\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode); // Replace original expression statement with VAR statement\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo()); // Transfer JSDoc\n            compiler.reportCodeChange();\n            replacementNode = varNode; // Update replacementNode to the new VAR node\n            // Node.IS_NAMESPACE was already handled above by getActualNameNode, no need to repeat.\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        // Ensure Node.IS_NAMESPACE is set on the relevant name node if this is a namespace.\n        // This is crucial for newly created declarations if createDeclarationNode() doesn't do it.\n        if (this.isNamespace()) {\n            Node nameNode = getActualNameNode(replacementNode);\n            if (nameNode != null) {\n                nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            }\n        }\n\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine (for top-level names).\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent(); // Remove the original goog.provide/goog.require call\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}