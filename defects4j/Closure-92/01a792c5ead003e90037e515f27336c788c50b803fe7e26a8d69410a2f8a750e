{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n\n        // Ensure parent namespaces are provided and their nodes are placed.\n        // This is done *before* placing the current replacementNode,\n        // as its placement might depend on the parent's replacementNode.\n        int indexOfDot = namespace.indexOf('.');\n        if (indexOfDot != -1) {\n          ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));\n          Preconditions.checkNotNull(parentName);\n          // If parent's replacement node isn't set, ensure it is by recursively\n          // calling replace() on the parent.\n          if (parentName.replacementNode == null) {\n              parentName.replace();\n          }\n          Preconditions.checkNotNull(parentName.replacementNode); // Parent node must exist now.\n        }\n\n        // Determine where to place the 'replacementNode'.\n        if (explicitNode != null) {\n            // Case 1: This is an explicit goog.provide statement.\n            // Per the regression test for bug 261, the definition should stay\n            // in the module of the explicit provide (firstNode's module).\n            // It replaces or is placed directly before the original goog.provide statement.\n            firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n            // Case 2: This is an implicitly provided name (e.g., 'apps.foo' for 'apps.foo.bar.B').\n            // These names are generated because a descendant was explicitly provided.\n            // The placement logic needs to respect module boundaries and hoisting rules.\n            if (firstModule == minimumModule || indexOfDot == -1) {\n                // If the implicit provide shares the minimum module with its first usage,\n                // or it's a root name implicitly provided, place it at the back of the minimum module.\n                // This covers cases where 'foo' is implicitly provided by 'foo.bar' and 'foo'\n                // is the new root of the name in the minimum module.\n                // Or if it's a dotted name but firstModule == minimumModule, it means\n                // it's already in the \"correct\" module and should just follow its parent.\n                if (indexOfDot == -1) { // Root implicit name\n                    compiler.getNodeForCodeInsertion(minimumModule)\n                        .addChildToBack(replacementNode);\n                } else { // Dotted implicit name AND firstModule == minimumModule\n                    ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot));\n                    parentName.replacementNode.getParent().addChildAfter(\n                        replacementNode, parentName.replacementNode);\n                }\n            } else {\n                // This case: Implicit dotted name (e.g., 'apps.foo', 'apps.foo.bar')\n                // AND its 'firstModule' is different from its 'minimumModule' (e.g., M1 vs M0).\n                // Per bug 261, these intermediate definitions should NOT be hoisted to the minimum module.\n                // They should remain in their 'firstModule'.\n                // A simple placement is to add it to the back of the 'firstModule' module's root.\n                // More precise placement might involve finding the last existing provided name in that module\n                // to insert after. For now, addChildToBack is sufficient for this test case.\n                compiler.getNodeForCodeInsertion(firstModule)\n                    .addChildToBack(replacementNode);\n            }\n        }\n\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}