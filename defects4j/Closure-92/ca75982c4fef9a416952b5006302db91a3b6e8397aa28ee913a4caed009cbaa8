{
    "generation": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n\n    String[] parts = namespace.split(\"\\\\.\");\n    Node current = replacementNode;\n    for (int i = 1; i < parts.length; i++) {\n      Node child = current.getFirstChild();\n      if (child == null || child.getType() != Token.OBJECT_PATTERN) {\n        Node newObj = new Node(Token.OBJECT_PATTERN);\n        newObj.addChildToFront(new Node(Token STRING, \"'\" + parts[i] + \"]', parts[i]));\n        newObj.addChildToFront(new Node(Token.NAME, parts[i]));\n        current.addChildToBack(newObj);\n        current = newObj;\n      } else {\n        String currentPart = child.getLastChild().getString();\n        if (!currentPart.equals(parts[i])) {\n          Node newObj = new Node(Token.OBJECT_PATTERN);\n          newObj.addChildToFront(new Node(Token.NAME, parts[i]));\n          current.addChildToBack(newObj);\n          current = newObj;\n        } else {\n          current = child;\n        }\n      }\n    }\n\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      int indexOfDot = namespace.indexOf('.');\n      if (indexOfDot == -1) {\n        compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n      } else {\n        String parentNamespace = namespace.substring(0, indexOfDot);\n        ProvidedName parentName = providedNames.get(parentNamespace);\n        Preconditions.checkNotNull(parentName);\n        Preconditions.checkNotNull(parentName.replacementNode);\n        parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode);\n      }\n    }\n\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}