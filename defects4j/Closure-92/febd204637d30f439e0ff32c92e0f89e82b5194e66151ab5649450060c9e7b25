{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        // It might not have a candidate definition (if it's implicit)\n        // but we still need to assign replacementNode. Let ProcessProvides pass handle it.\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a definition and an explicit provide.\n      if (candidateDefinition != null && explicitNode != null) {\n        // We have both an explicit goog.provide and a definition.\n        // We prefer the definition, but we need to modify it if it's\n        // not a var declaration.\n\n        explicitNode.detachFromParent(); // Remove the goog.provide() call\n        compiler.reportCodeChange();\n\n        replacementNode = candidateDefinition; // Use the existing definition node\n\n        // Mark the existing node as a namespace. Do this before potential VAR conversion.\n        if (NodeUtil.isExpressionNode(replacementNode)) { // ns.child = {}; (as EXPR_RESULT) or ns = {}\n            replacementNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assign = replacementNode.getFirstChild();\n            if (assign != null && assign.isAssign()) {\n                Node lhs = assign.getFirstChild();\n                // Mark the root object in the namespace chain, e.g., 'a' in a.b.c = {};\n                if (lhs != null && lhs.isGetProp()) {\n                   Node root = lhs;\n                   while(root.isGetProp()) { root = root.getFirstChild(); }\n                   if (root.isName()) { root.putBooleanProp(Node.IS_NAMESPACE, true); }\n                }\n            }\n        } else if (replacementNode.isVar()) { // var ns = {};\n            replacementNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node nameNode = replacementNode.getFirstChild();\n            if (nameNode != null && nameNode.isName()) {\n                nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            }\n        }\n\n        // If the definition is an assignment like \"ns = value\",\n        // convert it to \"var ns = value;\".\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          Node assignNode = candidateDefinition.getFirstChild(); // Should be ASSIGN\n          Node nameNode = assignNode.getFirstChild(); // NAME or GETPROP\n          // Check if it's a simple assignment (NAME = ...)\n          if (nameNode.isName()) {\n            // Convert EXPR_RESULT(ASSIGN(NAME, VALUE)) to VAR(NAME(VALUE))\n            Node valueNode = nameNode.getNext();\n            // Detach NAME and VALUE from ASSIGN\n            assignNode.detachChildren();\n            // Attach VALUE to NAME\n            nameNode.addChildToFront(valueNode);\n            // Create VAR node\n            Node varNode = new Node(Token.VAR, nameNode);\n            // Copy position and JSDoc info\n            varNode.copyInformationFrom(candidateDefinition);\n            // Copy JSDoc from the original assign node if it had one (VAR node JSDoc is on NAME node).\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            // Mark the new var node and name node as namespace\n            varNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n\n            // Replace the original EXPR_RESULT node with the new VAR node\n            candidateDefinition.getParent().replaceChild(candidateDefinition, varNode);\n            compiler.reportCodeChange();\n            replacementNode = varNode; // Update replacement node to the new VAR\n          }\n        }\n      } else if (candidateDefinition == null) {\n        // No definition found. Create a declaration node.\n        replacementNode = createDeclarationNode(); // Assume this returns VAR or EXPR_RESULT(ASSIGN)\n\n        // Mark the newly created node as namespace\n        if (replacementNode.isVar()) {\n            replacementNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node nameNode = replacementNode.getFirstChild();\n            if (nameNode != null && nameNode.isName()) {\n                nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            }\n        } else if (NodeUtil.isExpressionNode(replacementNode)) {\n            replacementNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assign = replacementNode.getFirstChild();\n             if (assign != null && assign.isAssign()) {\n                 Node lhs = assign.getFirstChild();\n                 // Mark the root object in the namespace chain, e.g., 'a' in a.b.c = {};\n                 if (lhs != null && lhs.isGetProp()) {\n                    Node root = lhs;\n                    while(root.isGetProp()) { root = root.getFirstChild(); }\n                    if (root.isName()) { root.putBooleanProp(Node.IS_NAMESPACE, true); }\n                 }\n             }\n        }\n\n        // Insert the new declaration statement.\n        if (firstModule == minimumModule) {\n          // Add declaration to the first module where the name appeared.\n          // Insert before the node that triggered this name's appearance.\n          Preconditions.checkNotNull(firstNode, \"firstNode cannot be null for %s\", namespace);\n          Node parent = firstNode.getParent();\n          Preconditions.checkNotNull(parent, \"parent cannot be null for %s\", firstNode);\n          // Insert before the statement containing firstNode.\n          parent.addChildBefore(replacementNode, firstNode);\n        } else {\n          // Implicitly provided in multiple modules or first module is not\n          // the common ancestor. Add declaration to the common ancestor module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Add `var ns = {};` to the end of the script in the minimum module.\n            compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode);\n          } else {\n            // Add `ns.child = {};` after the parent's declaration `var ns = {};`\n            // or `ns.parent = {};`.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName, \"Parent namespace %s does not exist\", namespace.substring(0, indexOfDot));\n            // The parent should have already been processed due to TreeMap iteration order\n            Preconditions.checkNotNull(parentName.replacementNode, \"Parent namespace %s has not been processed yet\", parentName.namespace);\n\n            Node parentStatementNode = parentName.replacementNode; // This is the VAR or EXPR_RESULT node for the parent.\n            // Ensure parentStatementNode is indeed a statement node.\n            Preconditions.checkState(NodeUtil.isStatement(parentStatementNode),\n                \"Parent replacement node is not a statement: %s\", parentStatementNode);\n            Preconditions.checkNotNull(parentStatementNode.getParent(),\n                \"Parent statement node %s has no parent\", parentStatementNode);\n\n            parentStatementNode.getParent().addChildAfter(replacementNode, parentStatementNode);\n          }\n        }\n\n        // Detach the explicit provide statement if it existed (and wasn't detached above).\n        // This happens if candidateDefinition was null but explicitNode was not.\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange(); // Report the insertion/detach\n\n      } else {\n        // Case: candidateDefinition != null && explicitNode == null\n        // A definition exists, but it wasn't explicitly provided.\n        // Use the existing definition. No code modifications or insertions needed.\n        replacementNode = candidateDefinition;\n         // Ensure the existing definition is marked as a namespace\n        if (NodeUtil.isExpressionNode(replacementNode)) { // ns.child = {}; (as EXPR_RESULT) or ns = {}\n            replacementNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node assign = replacementNode.getFirstChild();\n             if (assign != null && assign.isAssign()) {\n                 Node lhs = assign.getFirstChild();\n                 // Mark the root object in the namespace chain, e.g., 'a' in a.b.c = {};\n                 if (lhs != null && lhs.isGetProp()) {\n                    Node root = lhs;\n                    while(root.isGetProp()) { root = root.getFirstChild(); }\n                    if (root.isName()) { root.putBooleanProp(Node.IS_NAMESPACE, true); }\n                 } else if (lhs != null && lhs.isName()) {\n                     // Also mark the NAME node itself if it's a simple ns = {} case.\n                     lhs.putBooleanProp(Node.IS_NAMESPACE, true);\n                 }\n             }\n        } else if (replacementNode.isVar()) { // var ns = {};\n            replacementNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            Node nameNode = replacementNode.getFirstChild();\n            if (nameNode != null && nameNode.isName()) {\n                nameNode.putBooleanProp(Node.IS_NAMESPACE, true);\n            }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}