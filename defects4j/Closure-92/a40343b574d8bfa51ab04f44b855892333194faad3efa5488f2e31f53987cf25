{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        // replacementNode is already set by ProcessClosurePrimitives.handleProvide\n        Preconditions.checkNotNull(replacementNode);\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol. Example: goog.provide('foo'); var foo = {};\n      // Or: goog.provide('foo'); foo = {}; <-- This needs conversion\n      if (candidateDefinition != null && explicitNode != null) {\n        // Remove the goog.provide() call\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        replacementNode = candidateDefinition; // Assume existing definition is the replacement\n\n        // If the existing definition is an unqualified assignment expression,\n        // convert it to a VAR declaration.\n        // e.g., convert \"foo = 1;\" to \"var foo = 1;\"\n        if (NodeUtil.isExpressionNode(candidateDefinition)) { // Check if node is EXPR_RESULT\n          Node assignNode = candidateDefinition.getFirstChild();\n          if (assignNode != null && assignNode.isAssign()) {\n            Node nameNode = assignNode.getFirstChild(); // LHS of assignment\n            if (nameNode.isName()) { // Check if LHS is a simple name (e.g., \"foo\")\n              // Convert \"name = value;\" to \"var name = value;\"\n              Node valueNode = nameNode.getNext(); // RHS of assignment\n\n              // Detach children from the original ASSIGN node\n              assignNode.detachChildren();\n\n              // Create the new NAME node for the VAR, attaching the value\n              // Reuse the original NAME node to preserve information\n              Node varNameNode = nameNode;\n              varNameNode.addChildToFront(valueNode); // NAME(value)\n\n              // Create the new VAR node\n              Node varNode = IR.var(varNameNode); // Create VAR(NAME(value))\n\n              // Copy source location from original EXPR_RESULT to new VAR node\n              varNode.copyInformationFrom(candidateDefinition);\n              // Copy JSDoc from the original ASSIGN node to the NAME node inside VAR\n              varNameNode.setJSDocInfo(assignNode.getJSDocInfo());\n\n              // Replace the original EXPR_RESULT node with the new VAR node\n              Node parent = candidateDefinition.getParent();\n              Preconditions.checkNotNull(parent, \"Parent cannot be null\");\n              parent.replaceChild(candidateDefinition, varNode);\n              compiler.reportCodeChange();\n\n              // Update the replacement node to point to the newly created VAR node\n              replacementNode = varNode;\n            }\n            // else: If it's a GETPROP assignment (e.g., a.b = 1;), we don't convert\n            // it to a VAR. We just leave the assignment as is.\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        // Create a declaration node (e.g., \"var ns;\" or \"parent.ns = {};\").\n        replacementNode = createDeclarationNode();\n\n        if (firstModule == minimumModule) {\n          // Insert the declaration in the first module where the namespace was\n          // provided. Place it before the provide statement.\n          Preconditions.checkNotNull(firstNode, \"Expected firstNode for provide in minimum module\");\n          Node parent = firstNode.getParent();\n          Preconditions.checkNotNull(parent, \"Parent of firstNode cannot be null\");\n          parent.addChildBefore(replacementNode, firstNode);\n        } else {\n          // Namespace was provided or used in multiple modules. Hoist the\n          // declaration to the lowest common ancestor module ('minimumModule').\n          // Add the declaration to the end of the script in that module.\n          // This ensures that parent namespaces declarations will appear\n          // before child namespace declarations within this module,\n          // assuming ProcessClosurePrimitives processes namespaces in a\n          // prefix-based order (e.g., 'a' before 'a.b').\n          Node addingRoot = compiler.getNodeForCodeInsertion(minimumModule);\n          addingRoot.addChildToBack(replacementNode);\n        }\n\n        if (explicitNode != null) {\n          // Remove the original goog.provide() call if it hasn't been removed already.\n          if (explicitNode.getParent() != null) {\n            explicitNode.detachFromParent();\n          }\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}