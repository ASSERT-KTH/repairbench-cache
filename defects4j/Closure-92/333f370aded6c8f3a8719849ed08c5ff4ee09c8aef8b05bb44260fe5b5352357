{
    "generation": "    /**\n     * Replace the provide statement.\n     *\n     * If we're providing a name with no definition, then create one.\n     * If we're providing a name with a duplicate definition, then make sure\n     * that definition becomes a declaration.\n     */\n    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        // We might need to create a declaration for goog if it isn't defined.\n        // If the candidate definition is null, we know that goog isn't defined.\n        // This should be handled by the PROCESS_PROVIDES pass.\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        // We need to be very careful here, because the definition might be\n        // constant, and we're just referring to it.\n        // See http://b/issue?id=1809446\n        // We use the candidate definition as the replacement node,\n        // which has the correct original name associated with it.\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          if (assignNode.isAssign()) {\n            Node nameNode = assignNode.getFirstChild();\n            if (nameNode.isName()) {\n              // Need to convert this assign to a var declaration.\n              Node valueNode = nameNode.getNext();\n              assignNode.removeChild(nameNode);\n              assignNode.removeChild(valueNode);\n              nameNode.addChildToFront(valueNode);\n              Node varNode = new Node(Token.VAR, nameNode);\n              varNode.copyInformationFromForTree(candidateDefinition);\n              if (candidateDefinition.getJSDocInfo() != null) {\n                  varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n              } else {\n                  nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n              }\n              candidateDefinition.getParent().replaceChild(\n                  candidateDefinition, varNode);\n              compiler.reportCodeChange();\n              replacementNode = varNode;\n            }\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition,\n        // or where the duplication is implicit. Create a new declaration.\n        replacementNode = createDeclarationNode();\n\n        // Determine where to insert the new declaration.\n        if (firstModule == minimumModule) {\n          // The first place the name appeared is in the module\n          // where we want to declare it. Declare it right before that first use.\n          Preconditions.checkNotNull(firstNode, \"Expected firstNode to be non-null\");\n          Node parent = firstNode.getParent();\n          // If the parent is null, it means the node has already been detached\n          // perhaps by the processing of a duplicate definition.\n          // In this case, we should insert into the minimum module's script.\n          if (parent == null) {\n             compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n             parent.addChildBefore(replacementNode, firstNode);\n          }\n\n        } else {\n          // The name needs to be declared in a module that is an ancestor of\n          // the module where it first appeared (firstModule).\n          // This happens when a name is implicitly provided by provides\n          // in multiple modules.\n          // We insert the declaration at the end of the minimum module's script.\n          // This avoids ordering problems with parent namespace declarations.\n          compiler.getNodeForCodeInsertion(minimumModule)\n              .addChildToBack(replacementNode);\n        }\n\n        // Remove the explicit goog.provide call if there was one and it hasn't\n        // been removed already.\n        if (explicitNode != null && explicitNode.getParent() != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}