{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        String[] headerRecord = null;\n\n        final String[] formatHeader = this.format.getHeader();\n\n        // Determine the source of the header record:\n        // 1. If formatHeader is null (e.g., CSVFormat.withHeader() was called without arguments),\n        //    the header should be read from the first line of the file.\n        // 2. If formatHeader is an empty array (e.g., CSVFormat.withHeader(new String[0]) was called),\n        //    the header should also be read from the first line of the file.\n        // 3. Otherwise (formatHeader is a non-empty array), the header is predefined in the format.\n\n        if (formatHeader == null || formatHeader.length == 0) {\n            // Cases 1 & 2: Read header from the first record in the file\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            } else {\n                // No record found (e.g., empty file), so no header.\n                // As per Javadoc, return null if the format has no header.\n                return null;\n            }\n        } else {\n            // Case 3: Header is predefined in the format.\n            if (this.format.getSkipHeaderRecord()) {\n                // If a header is defined in the format AND we are supposed to skip the first record,\n                // it means the first record in the file is ignored.\n                // (Note: CSVFormat.withHeader(String...) usually sets skipHeaderRecord to false,\n                // so this branch is typically taken only if skipHeaderRecord was explicitly set true).\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n\n        // At this point, headerRecord should be populated if a header was found or defined.\n        // If headerRecord is null, it means no records were found when expected (handled above by returning null).\n        // If we reach here, headerRecord is expected to be non-null.\n\n        // Build the name to index mappings\n        if (headerRecord != null) { // This check is mostly for robustness, should be true if we didn't return null above\n            hdrMap = new LinkedHashMap<String, Integer>();\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n\n                // Check for duplicate headers. If ignoreEmptyHeaders is true, allow duplicate empty headers.\n                // This condition correctly prevents throwing IllegalArgumentException for duplicate empty headers\n                // when ignoreEmptyHeaders is true.\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n        // If headerRecord was null (which should have been handled by returning null earlier), hdrMap would remain null.\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}