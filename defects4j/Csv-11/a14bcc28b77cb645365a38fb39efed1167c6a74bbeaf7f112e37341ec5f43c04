{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n\n        // Determine if a header should be processed.\n        // A header is processed if:\n        // 1. User explicitly provided header names (formatHeader != null).\n        // 2. The format implies that the first record is a header (skipHeaderRecord is true).\n        //    CSVFormat.withHeader() (without arguments) sets skipHeaderRecord to true internally.\n        if (formatHeader != null || this.format.getSkipHeaderRecord()) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n            String[] headerRecord = null;\n\n            // Determine the actual header record to use for mapping.\n            if (formatHeader != null && formatHeader.length > 0) {\n                // Case: User provided specific header names (e.g., withHeader(\"A\", \"B\"))\n                // If the format also specifies to skip the header record from the file, consume it now.\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord(); // Consume the header line from the input stream\n                }\n                headerRecord = formatHeader; // Use the provided header names for the map\n            } else {\n                // Case: User specified 'withHeader()' (no arguments) or 'withHeader(new String[0])'.\n                // In these cases, 'formatHeader' is null (or an empty array), and 'skipHeaderRecord' is true.\n                // The header must be read from the first line of the file.\n                final CSVRecord nextRecord = this.nextRecord(); // This consumes the first record (the header)\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n                // If nextRecord is null, headerRecord remains null, which will be handled by the next if (headerRecord != null) check.\n            }\n\n            // Build the name to index mappings from the determined headerRecord\n            if (headerRecord != null) { // Ensure we have a header record to process\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean emptyHeader = header.trim().isEmpty();\n\n                    if (emptyHeader && this.format.getIgnoreEmptyHeaders()) {\n                        // If the header is empty and empty headers should be ignored, skip this entry completely.\n                        continue;\n                    }\n\n                    // Check for duplicate names among the headers that are being mapped.\n                    // An IllegalArgumentException is thrown if a duplicate is found.\n                    if (hdrMap.containsKey(header)) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}