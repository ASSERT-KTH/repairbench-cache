{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n\n        // A header map should be initialized if the format specifies that a header record is present.\n        // This is indicated by getSkipHeaderRecord() being true, which is set by withHeader() variants.\n        if (this.format.getSkipHeaderRecord()) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader == null) {\n                // Header is to be read from the first line of the file (e.g., withHeader() called without arguments).\n                // This implicitly skips the header record.\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n                // If nextRecord is null, headerRecord remains null, leading to an empty hdrMap, which is fine.\n            } else {\n                // Header was provided explicitly by the format (e.g., withHeader(\"A\", \"B\")).\n                // Since getSkipHeaderRecord() is true, the first line of the file (which would be data) needs to be skipped.\n                this.nextRecord(); // Skip the first data record.\n                headerRecord = formatHeader; // Use the header provided in the format.\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n\n                    // Handle potential NPE if 'header' is null (e.g., due to withNullString(\"\"))\n                    final boolean emptyHeader;\n                    if (header == null) {\n                        emptyHeader = true;\n                    } else {\n                        emptyHeader = header.trim().isEmpty();\n                    }\n\n                    final boolean containsHeader = hdrMap.containsKey(header);\n\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\n                    // If ignoreEmptyHeaders is true and the header is empty (or null), do not add it to the map.\n                    if (this.format.getIgnoreEmptyHeaders() && emptyHeader) {\n                        // Do nothing, effectively ignoring this header.\n                    } else {\n                        hdrMap.put(header, Integer.valueOf(i));\n                    }\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}