{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            // Use LinkedHashMap to preserve order\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                // Header specified explicitly, may need to skip record\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            // Note: headerRecord can be null if the file is empty and the header is read from the file\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    // Check if header is null or empty (due to null string or empty field).\n                    // Note: A header can be null if withNullString(\"\") is used and a field is empty.\n                    final boolean emptyOrNullHeader = header == null || header.trim().isEmpty();\n                    \n                    // Determine whether to ignore this header\n                    final boolean ignoreHeader = emptyOrNullHeader && this.format.getIgnoreEmptyHeaders();\n\n                    // Add header to map if it is not ignored\n                    if (!ignoreHeader) {\n                        // Check for duplicates only among headers that are not ignored.\n                        if (hdrMap.containsKey(header)) {\n                            // Duplicate header name found. However, allow duplicates if specified.\n                            // Note: The original duplicate check logic implicitly assumed allowDuplicateHeaders was false.\n                            // Let's refine this check based on the format setting (assuming it exists or defaults to false).\n                            // Assuming !this.format.getAllowDuplicateHeaders() is the default/intended behavior here.\n                            // If duplicates are allowed, the last occurrence wins. The check might need adjustment\n                            // if getAllowDuplicateHeaders is true, but for fixing the NPE and ignoreEmptyHeaders,\n                            // throwing on non-ignored duplicates seems correct based on the original code's exception message.\n                            throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                    \"\\\" in \" + Arrays.toString(headerRecord));\n                        }\n                        hdrMap.put(header, Integer.valueOf(i));\n                    }\n                }\n            }\n        }\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}