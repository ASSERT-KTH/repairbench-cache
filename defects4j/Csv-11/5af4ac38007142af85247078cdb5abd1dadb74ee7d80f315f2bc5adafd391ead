{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] configuredHeader = this.format.getHeader(); // Explicitly configured header\n\n        if (configuredHeader != null) {\n            // Header defined explicitly in the format\n            hdrMap = new LinkedHashMap<>();\n            String[] headerRecord = configuredHeader;\n\n            // Build map from configured header\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                // Check for null/empty header, respecting ignoreEmptyHeaders setting\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n                if (emptyHeader && this.format.getIgnoreEmptyHeaders()) {\n                    continue; // Skip ignored header\n                }\n\n                // Check for duplicates, respecting allowDuplicateHeaders setting\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader && !this.format.getAllowDuplicateHeaders()) {\n                    throw new IllegalArgumentException(\n                            \"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n\n                // Add mapping if it's the first time encountering this header name or duplicates are allowed.\n                // If duplicates allowed, the first occurrence takes precedence.\n                if (!containsHeader) {\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        } else if (this.format.getSkipHeaderRecord()) {\n            // Header is not configured, but we need to read it from the stream\n            // because skipHeaderRecord is true (e.g., set by withHeader())\n            final CSVRecord firstRecord = this.nextRecord(); // Read the first record\n            if (firstRecord != null) {\n                hdrMap = new LinkedHashMap<>();\n                String[] headerRecord = firstRecord.values(); // Get the values from the first record\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    // Check for null/empty header, respecting ignoreEmptyHeaders setting\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (emptyHeader && this.format.getIgnoreEmptyHeaders()) {\n                        continue; // Skip ignored header\n                    }\n\n                    // Check for duplicates, respecting allowDuplicateHeaders setting\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    if (containsHeader && !this.format.getAllowDuplicateHeaders()) {\n                         throw new IllegalArgumentException(\n                                \"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n\n                    // Add mapping if it's the first time encountering this header name or duplicates are allowed.\n                    // If duplicates allowed, the first occurrence takes precedence.\n                    if (!containsHeader) {\n                        hdrMap.put(header, Integer.valueOf(i));\n                    }\n                }\n            }\n        }\n\n        // If no header is configured and skipHeaderRecord is false, hdrMap remains null.\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}