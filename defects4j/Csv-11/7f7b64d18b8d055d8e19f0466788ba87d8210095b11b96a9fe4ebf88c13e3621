{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        // Check if header handling is specified by the format\n        if (!this.format.getSkipHeaderRecord()) {\n            // No header defined or expected, return null\n            return null;\n        }\n\n        // Header is expected, initialize the map\n        final Map<String, Integer> hdrMap = new LinkedHashMap<>();\n        String[] headerRecord = null;\n        final String[] formatHeader = this.format.getHeader(); // Get explicitly defined header, if any\n\n        if (formatHeader == null) {\n            // Header is defined by the first record, read it\n            // Note: Subsequent records might define different headers, iterator() may return them.\n            final CSVRecord firstRecord = this.nextRecord();\n            if (firstRecord != null) {\n                headerRecord = firstRecord.values();\n            }\n            // Note: If firstRecord is null (empty input), headerRecord remains null.\n        } else {\n            // Header is explicitly defined by formatHeader.\n            // We still need to consume the first record from the input if skipHeaderRecord is true.\n            // Since we are in this block, getSkipHeaderRecord() is true.\n            // Consume the actual header line from the input file/stream\n            final CSVRecord nextRecord = this.nextRecord();\n            // TODO: Should we check that the actual header matches the expected header (formatHeader)? currently ignored.\n            //       This check could be expensive for large files.\n            // Note: If the input stream is empty or does not contain the header record,\n            //       nextRecord() might return null. This seems acceptable as we use the formatHeader anyway.\n            headerRecord = formatHeader; // Use the explicitly defined header\n        }\n\n        // build the name to index mappings\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                // Check for null or empty headers, respecting the ignoreEmptyHeaders setting.\n                final boolean emptyHeader = header == null || header.trim().isEmpty();\n\n                // Check for duplicates, ignoring empty headers if requested\n                final boolean containsHeader = hdrMap.containsKey(header);\n                if (containsHeader && (!emptyHeader || !this.format.getIgnoreEmptyHeaders())) {\n                    // Throw if duplicate AND (it's not empty OR we don't ignore empty)\n                    // Equivalent to: Throw if duplicate AND NOT (it is empty AND we ignore empty)\n                     throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                             \"\\\" in \" + Arrays.toString(headerRecord));\n                 }\n\n                // Add the mapping. If it's a duplicate empty header and ignoreEmptyHeaders=true,\n                // this will overwrite the previous entry for the empty header.\n                // If it's empty/null and ignoreEmptyHeaders=true, it's added (unless it was a non-ignorable duplicate).\n                 hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n        // If headerRecord was null (e.g., empty file when reading header), return the empty hdrMap.\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}