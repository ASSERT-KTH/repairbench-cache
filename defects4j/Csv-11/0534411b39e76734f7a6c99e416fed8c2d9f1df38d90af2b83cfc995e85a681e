{
    "generation": "    /**\n     * Initializes the name to index mapping if the format defines a header.\n     *\n     * @return null if the format has no header.\n     * @throws IOException if there is a problem reading the header or skipping the first record\n     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null; // Will be initialized if a header is found/defined.\n        String[] headerRecord = null;       // The actual array of header names to be mapped.\n\n        final String[] formatHeader = this.format.getHeader(); // This can be null (withHeader()) or an array (withHeader(String...)).\n\n        // Determine the source of the header record:\n        // 1. If formatHeader is null, it means the header should be read from the first record of the file.\n        // 2. If formatHeader is an empty array, per Javadoc, it means records are parsed with a default header (i.e., no header map).\n        // 3. If formatHeader is a non-empty array, it's the explicit header to be used.\n        if (formatHeader == null) { // Case: CSVFormat.withHeader() was called (implicit header from file)\n            if (this.format.getSkipHeaderRecord()) {\n                // If skipping the header record, and no explicit header is defined, then no header map is created.\n                this.nextRecord(); // Consume (skip) the first record.\n                // headerRecord remains null, so hdrMap will not be created.\n            } else {\n                // Read the first record from the file to use as the header.\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            }\n        } else if (formatHeader.length > 0) { // Case: CSVFormat.withHeader(\"A\", \"B\", ...) (explicit non-empty header)\n            if (this.format.getSkipHeaderRecord()) {\n                // If skipping the header record, consume the first record from the file.\n                this.nextRecord();\n            }\n            // Use the explicitly provided header for mapping.\n            headerRecord = formatHeader;\n        } else { // Case: formatHeader.length == 0 (explicit empty header, i.e., CSVFormat.withHeader(new String[0]))\n            // Per Javadoc: \"When the header is null or empty, the records are parsed with the default header.\"\n            // This implies no name-to-index mapping (hdrMap remains null).\n            if (this.format.getSkipHeaderRecord()) {\n                // Still skip the first record if configured, even if no header map is being built.\n                this.nextRecord();\n            }\n            // headerRecord remains null, so hdrMap will not be created, which is consistent with \"default header\".\n        }\n\n        // Build the name-to-index mappings if a headerRecord array was determined.\n        if (headerRecord != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n                final boolean emptyHeader = header.trim().isEmpty();\n\n                // Check for duplicate headers based on format configuration.\n                // Duplicates are disallowed unless the header is empty and ignoreEmptyHeaders is true.\n                if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                            \"\\\" in \" + Arrays.toString(headerRecord));\n                }\n                hdrMap.put(header, Integer.valueOf(i));\n            }\n        }\n        return hdrMap;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}