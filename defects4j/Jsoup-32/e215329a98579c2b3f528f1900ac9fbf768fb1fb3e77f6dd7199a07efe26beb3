{
    "generation": "    @Override\n    public Element clone() {\n        // Get the class names from the original Element *before* performing the clone.\n        // This ensures we capture the current set of classes to be transferred.\n        Set<String> classNamesToTransfer = this.classNames();\n\n        // Perform the standard cloning process provided by the superclass (Node).\n        // Node.clone() handles the cloning of attributes via attributes.clone().\n        // However, due to the transient nature of the 'classNames' field in Attributes,\n        // the cloned attributes object might still share the same ClassAttributeSet instance\n        // with the original if it was already initialized.\n        Element clone = (Element) super.clone();\n\n        // To ensure the cloned Element has its own independent ClassAttributeSet:\n        // 1. Explicitly clear the \"class\" attribute on the clone. This will force\n        //    the internal 'classNames' cache (transient field) in `clone.attributes` to be set to null.\n        //    This effectively invalidates any shared reference to the original's ClassAttributeSet.\n        clone.attributes().put(\"class\", \"\");\n\n        // 2. Add back the original class names to the clone.\n        //    When `clone.classNames()` is called later, because its cache is now null,\n        //    a *new* ClassAttributeSet will be created for the clone, making it independent.\n        if (!classNamesToTransfer.isEmpty()) {\n            clone.addClass(classNamesToTransfer.toArray(new String[0]));\n        }\n\n        return clone;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}