{
    "generation": "private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    FunctionType ct = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n\n    // Backwards inference: propagate parameter types to arguments\n    // (only applies to the call as performed; do not update the declared\n    // type of the function)\n    Node arg = constructor.getNext();\n    if (ct != null && ct.isConstructor()) {\n      Node param = ct.getParametersNode().getFirstChild();\n      while (arg != null && param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType == null && param.getType() == com.google.javascript.rhino.Token.NAME && param.hasChildren()) {\n          // Optional, destructuring or default param: get its child\n          paramType = param.getFirstChild().getJSType();\n        }\n        if (paramType != null) {\n          updateTypeOfArgument(arg, paramType, scope);\n        }\n        arg = arg.getNext();\n        param = param.getNext();\n      }\n    }\n\n    // Traverse arguments after inference, so updated types are correct in scope\n    for (Node argNode = constructor.getNext(); argNode != null; argNode = argNode.getNext()) {\n      scope = traverse(argNode, scope);\n    }\n    return scope;\n}\n\n// Helper to update the type of the argument, propagating backwards inference.\nprivate void updateTypeOfArgument(Node arg, JSType paramType, FlowScope flowScope) {\n    JSType argType = arg.getJSType();\n    if (argType != null && !paramType.isUnknownType() && !paramType.equals(argType)) {\n      JSType resolvedType = paramType;\n      // Merge to get the most specific type that can satisfy both.\n      // (optional, implementation-specific)\n      arg.setJSType(resolvedType);\n      // Optionally, update the variable's type in the flow scope, if appropriate.\n      if (arg.isName()) {\n        flowScope.inferSlotType(arg.getString(), resolvedType);\n      }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}