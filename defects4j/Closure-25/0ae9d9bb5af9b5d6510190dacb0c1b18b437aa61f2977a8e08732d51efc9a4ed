{
    "generation": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null; // This will hold the inferred type of the 'new' expression itself.\n    FunctionType ct = null; // This will hold the constructor's FunctionType.\n\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType(); // Get the instance type if it's a valid constructor.\n        }\n      }\n    }\n\n    // Traverse arguments. This is where backwards inference for parameters happens.\n    int argIndex = 0;\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext(), argIndex++) {\n      JSType expectedParamType = null;\n      // If we have a valid constructor function type, get its expected parameter types.\n      if (ct != null && ct.isConstructor()) {\n        List<JSType> paramTypes = ct.getParameterTypes();\n        if (argIndex < paramTypes.size()) {\n          expectedParamType = paramTypes.get(argIndex);\n        } else if (ct.isVarargs()) {\n          // For varargs, get the type of the elements in the varargs array.\n          expectedParamType = ct.toMaybeFunctionType().getRestOfParametersType();\n        }\n      }\n\n      // If an expected type for this argument was found, set it temporarily for backwards inference.\n      if (expectedParamType != null) {\n        // `setExpectedType` is a method of the TypeInferencer class (or its superclass)\n        // that allows associating an expected type with a Node for the current traversal.\n        setExpectedType(arg, expectedParamType);\n      }\n      scope = traverse(arg, scope); // Traverse the argument. The `traverse` method will use the expected type.\n      // Clean up the expected type annotation after traversal to avoid leaking state.\n      if (expectedParamType != null) {\n        clearExpectedType(arg);\n      }\n    }\n\n    // Set the JSType of the 'new' expression itself.\n    // If 'type' is still null, it means the constructor was not a recognized constructor function,\n    // and its type will implicitly be treated as unknown or a default object type.\n    n.setJSType(type);\n\n    return scope;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}