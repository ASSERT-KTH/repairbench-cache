{
    "generation": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null; // This will be the instance type inferred for the 'new' expression itself\n    FunctionType ct = null; // This will hold the constructor's FunctionType\n\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n\n    // After determining the constructor's function type, we can infer\n    // the types of its arguments using backwards inference.\n    // This is similar to how arguments are handled in traverseCall.\n    if (ct != null) {\n      ImmutableList<JSType> paramTypes = ct.getParameters();\n      Node currentArg = constructor.getNext();\n      int i = 0;\n      for (; currentArg != null; currentArg = currentArg.getNext(), i++) {\n        JSType paramType = i < paramTypes.size() ? paramTypes.get(i) : null;\n\n        // Create a child scope for traversing each argument to isolate its\n        // inference effects on the outer scope until it's finalized.\n        scope = traverse(currentArg, scope.createChildScope());\n\n        // Infer properties on the argument based on the expected parameter type.\n        // This is crucial for backwards inference (e.g., testBackwardsInferenceNew).\n        scope = inferPropertyTypes(currentArg, paramType, scope);\n\n        // Constrain the value with undefined if the parameter allows it.\n        if (paramType != null && !paramType.isUnknownType()) {\n          scope = constrainValueWithUndefined(currentArg, paramType, scope);\n        }\n      }\n    } else {\n      // Fallback: If we couldn't determine a function type for the constructor,\n      // just traverse the arguments without specific type information.\n      for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n        scope = traverse(arg, scope);\n      }\n    }\n    return scope;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}