{
    "generation": "private FlowScope traverseNew(Node n, FlowScope scope) {\n  Node constructor = n.getFirstChild();\n  // First do the usual forward traversal of the constructor expression.\n  scope = traverse(constructor, scope);\n\n  // Figure out the return (instance) type of the new-expression.\n  JSType constructorType = constructor.getJSType();\n  JSType type = null;\n  FunctionType ct = null;\n  if (constructorType != null) {\n    constructorType = constructorType.restrictByNotNullOrUndefined();\n    if (constructorType.isUnknownType()) {\n      type = getNativeType(UNKNOWN_TYPE);\n    } else {\n      ct = constructorType.toMaybeFunctionType();\n      if (ct == null && constructorType instanceof FunctionType) {\n        // If constructorType is a NoObjectType, toMaybeFunctionType returns null,\n        // but NoObjectType implements FunctionType so we can cast it.\n        ct = (FunctionType) constructorType;\n      }\n      if (ct != null && ct.isConstructor()) {\n        type = ct.getInstanceType();\n      } else {\n        // Not a real constructor, disable backward\u2010inference.\n        ct = null;\n      }\n    }\n  }\n  n.setJSType(type);\n\n  // --- Begin backward inference of the constructor arguments ---\n  // If we know the FunctionType of the constructor, pull its declared\n  // parameter types and use them to refine each argument's type.\n  if (ct != null) {\n    Node arg = constructor.getNext();\n    for (JSType paramType : ct.getParameters()) {\n      if (arg == null) {\n        break;\n      }\n      if (paramType != null) {\n        if (arg.isName()) {\n          // e.g. new F(y)  ==>  refine y to have the declared paramType\n          scope = scope.inferQualifiedName(arg.getString(), paramType);\n        } else if (arg.isGetProp()) {\n          // e.g. new F(obj.prop)  ==>  refine obj.prop to paramType\n          Node owner = arg.getFirstChild();\n          String propName = arg.getLastChild().getString();\n          if (owner.isName()) {\n            scope = scope.inferQualifiedProp(owner.getString(), propName, paramType);\n          }\n        }\n      }\n      arg = arg.getNext();\n    }\n  }\n  // --- End backward inference ---\n\n  // Finally traverse all the argument subexpressions themselves.\n  for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n    scope = traverse(arg, scope);\n  }\n  return scope;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}