{
    "generation": "  private FlowScope traverseNew(Node n, FlowScope scope) {\n\n    Node constructor = n.getFirstChild();\n    // Evaluate the constructor expression.\n    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null; // The type produced by the 'new' expression\n    FunctionType ct = null; // The FunctionType of the constructor\n\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        // If the constructor type is unknown, the result is unknown.\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        // Check if it's a function type.\n        ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType instanceof FunctionType) {\n          // Handle cases like NoObjectType which implement FunctionType\n          // but aren't returned by toMaybeFunctionType.\n          ct = (FunctionType) constructorType;\n        }\n\n        // Check if it's actually a constructor.\n        if (ct != null && ct.isConstructor()) {\n          // Determine the type of the instance created by the 'new' expression.\n          type = ct.getInstanceType();\n        } else {\n          // If it's not a constructor, we can't determine the instance type,\n          // and we also cannot do backward inference on arguments. Reset ct.\n          ct = null;\n          // TODO(b/116442988): Consider warning about invalid constructor usage.\n          // Result type remains null (may become unknown later in the flow).\n        }\n      }\n    }\n\n    // Set the JSType of the NEW node itself.\n    n.setJSType(type);\n\n    // Evaluate arguments, applying backward inference where possible.\n    Node arg = constructor.getNext();\n    if (ct != null) {\n      // We have a valid constructor type, attempt backward inference.\n      Node param = ct.getParametersNode() == null ? null : ct.getParametersNode().getFirstChild();\n      while (arg != null) {\n        // Determine the type of the parameter corresponding to this argument.\n        JSType paramType = getNativeType(UNKNOWN_TYPE); // Default if no parameter found or for var_args\n        if (param != null) {\n          JSType pType = param.getJSType();\n          if (pType != null) {\n            paramType = pType;\n          }\n          // Advance to the next parameter for the next iteration.\n          param = param.getNext();\n        }\n        // TODO(johnlenz): Handle var_args parameters more accurately.\n\n        // Evaluate the argument expression itself first.\n        scope = traverse(arg, scope);\n\n        // Apply backward-inference constraints from the parameter type to the argument.\n        // We only perform this inference if we have a meaningful parameter type.\n        if (paramType != null && !paramType.isUnknownType()) {\n          // Use traverseAssignLHS to apply the parameter type constraint to the argument node.\n          // This is analogous to assigning the argument to a variable of the parameter type.\n          // It updates the scope and potentially refines the argument node's type if 'arg'\n          // refers to a variable, property, object literal, etc., enabling backward inference.\n          scope = traverseAssignLHS(scope, arg, paramType);\n        }\n\n        // Advance to the next argument.\n        arg = arg.getNext();\n      }\n    } else {\n      // If the constructor type was invalid or unknown,\n      // simply traverse the arguments without attempting backward inference.\n      while (arg != null) {\n        scope = traverse(arg, scope);\n        arg = arg.getNext();\n      }\n    }\n\n    return scope;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}