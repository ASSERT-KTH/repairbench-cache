{
    "generation": "    /**\n     * Estimate a first guess of the amplitude and angular frequency.\n     * This method assumes that the {@link #sortObservations()} method\n     * has been called previously.\n     *\n     * @throws ZeroException if the abscissa range is zero.\n     * @throws MathIllegalStateException when the guessing procedure cannot\n     * produce sensible results.\n     */\n    private void guessAOmega() {\n        // initialize the sums for the linear model between the two integrals\n        double sx2 = 0;\n        double sy2 = 0;\n        double sxy = 0;\n        double sxz = 0;\n        double syz = 0;\n\n        double currentX = observations[0].getX();\n        double currentY = observations[0].getY();\n        double f2Integral = 0;\n        double fPrime2Integral = 0;\n        final double startX = currentX;\n        for (int i = 1; i < observations.length; ++i) {\n            // one step forward\n            final double previousX = currentX;\n            final double previousY = currentY;\n            currentX = observations[i].getX();\n            currentY = observations[i].getY();\n\n            // update the integrals of f^2 and f'^2\n            // considering a linear model for f (and therefore constant f')\n            final double dx = currentX - previousX;\n            final double dy = currentY - previousY;\n            final double f2StepIntegral =\n                dx * (previousY * previousY +\n                      previousY * currentY +\n                      currentY * currentY) / 3;\n            final double fPrime2StepIntegral = dy * dy / dx;\n\n            final double x = currentX - startX;\n            f2Integral      += f2StepIntegral;\n            fPrime2Integral += fPrime2StepIntegral;\n\n            sx2 += x * x;\n            sy2 += f2Integral * f2Integral;\n            sxy += x * f2Integral;\n            sxz += x * fPrime2Integral;\n            syz += f2Integral * fPrime2Integral;\n        }\n\n        // compute the amplitude and pulsation coefficients\n        double c1 = sy2 * sxz - sxy * syz;\n        double c2 = sxy * sxz - sx2 * syz;\n        double c3 = sx2 * sy2 - sxy * sxy;\n\n        // if either ratio is negative, no sensible harmonic guess can be made\n        if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n            throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_ESTIMATE_INITIAL_PARAMETERS);\n        }\n\n        a     = FastMath.sqrt(c1 / c2);\n        omega = FastMath.sqrt(c2 / c3);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}