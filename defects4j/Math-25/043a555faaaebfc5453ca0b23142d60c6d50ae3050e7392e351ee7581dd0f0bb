{
    "generation": "    /**\n     * Estimate a first guess of the amplitude and angular frequency.\n     * This method assumes that the {@link #sortObservations()} method\n     * has been called previously.\n     *\n     * @throws ZeroException if the abscissa range is zero.\n     * @throws MathIllegalStateException when the guessing procedure cannot\n     * produce sensible results.\n     */\n    private void guessAOmega() {\n        // initialize the sums for the linear model between the two integrals\n        double sx2 = 0;\n        double sy2 = 0;\n        double sxy = 0;\n        double sxz = 0;\n        double syz = 0;\n\n        double currentX = observations[0].getX();\n        double currentY = observations[0].getY();\n        double f2Integral = 0;\n        double fPrime2Integral = 0;\n        final double startX = currentX;\n        for (int i = 1; i < observations.length; ++i) {\n            // one step forward\n            final double previousX = currentX;\n            final double previousY = currentY;\n            currentX = observations[i].getX();\n            currentY = observations[i].getY();\n\n            // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n            // considering a linear model for f (and therefore constant f')\n            final double dx = currentX - previousX;\n            final double dy = currentY - previousY;\n            final double f2StepIntegral =\n                dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n            final double fPrime2StepIntegral = dy * dy / dx;\n\n            final double x = currentX - startX;\n            f2Integral += f2StepIntegral;\n            fPrime2Integral += fPrime2StepIntegral;\n\n            sx2 += x * x;\n            sy2 += f2Integral * f2Integral;\n            sxy += x * f2Integral;\n            sxz += x * fPrime2Integral;\n            syz += f2Integral * fPrime2Integral;\n        }\n\n        // compute the amplitude and pulsation coefficients\n        double c1 = sy2 * sxz - sxy * syz;\n        double c2 = sxy * sxz - sx2 * syz;\n        double c3 = sx2 * sy2 - sxy * sxy;\n\n        // The new logic is to throw an exception if the computed coefficients are invalid.\n        // This guards against ill-conditioned data (see MATH-844).\n        boolean badCoefficients = false;\n        if (c2 == 0 || c3 == 0) {\n            badCoefficients = true;\n        } else if ((c1 / c2 < 0) || (c2 / c3 < 0) || Double.isNaN(c1 / c2) || Double.isNaN(c2 / c3)\n                || Double.isInfinite(c1 / c2) || Double.isInfinite(c2 / c3)) {\n            badCoefficients = true;\n        }\n\n        if (badCoefficients) {\n            final int last = observations.length - 1;\n            // Range of the observations, assuming that the\n            // observations are sorted.\n            final double xRange = observations[last].getX() - observations[0].getX();\n            if (xRange == 0) {\n                throw new ZeroException();\n            }\n\n            // Additional safeguard - if even this fallback block is not valid, throw\n            if (observations.length < 2) {\n                throw new MathIllegalStateException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE, observations.length, 2);\n            }\n            double yMin = Double.POSITIVE_INFINITY;\n            double yMax = Double.NEGATIVE_INFINITY;\n            for (int i = 1; i < observations.length; ++i) {\n                final double y = observations[i].getY();\n                if (y < yMin) {\n                    yMin = y;\n                }\n                if (y > yMax) {\n                    yMax = y;\n                }\n            }\n            a = 0.5 * (yMax - yMin);\n            omega = 2 * Math.PI / xRange;\n\n            // If this fallback still fails (e.g., amplitude is 0), throw.\n            if (a == 0 || Double.isNaN(a) || Double.isNaN(omega) || Double.isInfinite(a) || Double.isInfinite(omega)) {\n                throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_GUESS_HARMONIC_PARAMETERS);\n            }\n        } else {\n            // In some ill-conditioned cases (cf. MATH-844), the guesser\n            // procedure cannot produce sensible results.\n            double amp = FastMath.sqrt(c1 / c2);\n            double omg = FastMath.sqrt(c2 / c3);\n            // If the result is not valid, throw instead of proceeding.\n            if (Double.isNaN(amp) || Double.isNaN(omg) ||\n                Double.isInfinite(amp) || Double.isInfinite(omg) ||\n                amp == 0 || omg == 0) {\n                throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_GUESS_HARMONIC_PARAMETERS);\n            }\n            a = amp;\n            omega = omg;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}