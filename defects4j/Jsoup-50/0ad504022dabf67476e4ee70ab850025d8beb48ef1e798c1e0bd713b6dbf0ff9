{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // Assuming defaultCharset is a static final String \"UTF-8\" in the surrounding class.\n        // For self-containment in this snippet, I'll define it here.\n        final String defaultCharset = \"UTF-8\"; \n\n        // 1. Look for BOM - overrides any other header or input\n        String bomCharset = null;\n        int bomLength = 0;\n\n        // Peek at the first few bytes to detect BOM\n        // Check for BOMs in order of longest first (UTF-32, then UTF-8, then UTF-16)\n        if (byteData.remaining() >= 4) { \n            byte b1 = byteData.get(0);\n            byte b2 = byteData.get(1);\n            byte b3 = byteData.get(2);\n            byte b4 = byteData.get(3);\n\n            if (b1 == (byte) 0x00 && b2 == (byte) 0x00 && b3 == (byte) 0xFE && b4 == (byte) 0xFF) { // UTF-32BE\n                bomCharset = \"UTF-32BE\";\n                bomLength = 4;\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE && b3 == (byte) 0x00 && b4 == (byte) 0x00) { // UTF-32LE\n                bomCharset = \"UTF-32LE\";\n                bomLength = 4;\n            } else if (b1 == (byte) 0xEF && b2 == (byte) 0xBB && b3 == (byte) 0xBF) { // UTF-8 BOM\n                bomCharset = \"UTF-8\";\n                bomLength = 3;\n            } else if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) { // UTF-16BE\n                bomCharset = \"UTF-16BE\";\n                bomLength = 2;\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) { // UTF-16LE\n                bomCharset = \"UTF-16LE\";\n                bomLength = 2;\n            }\n        } else if (byteData.remaining() >= 3) { // Check for UTF-8 only if < 4 bytes\n            byte b1 = byteData.get(0);\n            byte b2 = byteData.get(1);\n            byte b3 = byteData.get(2);\n            if (b1 == (byte) 0xEF && b2 == (byte) 0xBB && b3 == (byte) 0xBF) {\n                bomCharset = \"UTF-8\";\n                bomLength = 3;\n            }\n        } else if (byteData.remaining() >= 2) { // Check for UTF-16 BOMs only if < 3 bytes\n            byte b1 = byteData.get(0);\n            byte b2 = byteData.get(1);\n            if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) { // UTF-16BE\n                bomCharset = \"UTF-16BE\";\n                bomLength = 2;\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) { // UTF-16LE\n                bomCharset = \"UTF-16LE\";\n                bomLength = 2;\n            }\n        }\n\n        if (bomCharset != null) {\n            charsetName = bomCharset; // BOM overrides any other specified charset\n            byteData.position(bomLength); // Advance buffer past BOM for decoding\n        }\n\n        // Flag to track if an initial decode/parse happened for meta charset detection\n        boolean initialParseForMeta = false;\n\n        // 2. Determine final charsetName if not set by BOM or provided\n        if (charsetName == null) { // no BOM, no specified charset, try to detect from meta\n            byteData.rewind(); // Ensure buffer is at start for initial decode if BOM wasn't handled\n            \n            // Decode with defaultCharset to find meta tag\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            initialParseForMeta = true; // Mark that an initial parse/decode happened\n\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                // Assuming getCharsetFromContentType is a static helper method available in scope\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // ignore, assume no charset found\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset; // Meta charset found, use it\n                } else {\n                    charsetName = defaultCharset; // No useful meta charset found, stick with default\n                }\n            } else { // No meta tag found, stick with default\n                charsetName = defaultCharset;\n            }\n        } else { // charsetName was provided (and possibly overridden by BOM earlier)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            // If BOM was found, byteData.position is already advanced.\n            // If no BOM was found, ensure byteData is at the beginning for decoding.\n            if (bomCharset == null) {\n                byteData.rewind();\n            }\n        }\n\n        // 3. Perform final decode of byteData using the determined charsetName\n        // This ensures docData is always correctly generated for the final parse.\n        // The old problematic UNICODE_BOM check is removed as BOMs are handled at byte level.\n        if (doc == null || (initialParseForMeta && !charsetName.equalsIgnoreCase(defaultCharset))) {\n            // Case 1: doc is null (e.g., BOM was found, or charsetName was provided initially) -> needs a fresh decode.\n            // Case 2: doc was parsed once (for meta scan), but now needs re-parsing due to different charset\n            byteData.rewind(); // Always rewind to start for the full decode\n            if (bomLength > 0) { // If BOM was detected, skip it again\n                byteData.position(bomLength);\n            }\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            doc = null; // Mark doc for re-parsing\n        }\n        // Else: doc is not null, initialParseForMeta is true, and charsetName IS defaultCharset.\n        // In this scenario, `docData` from the initial meta scan is already correct, and `doc` is also valid.\n\n        // 4. Final parse if needed, and set output charset\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n        }\n        doc.outputSettings().charset(charsetName); // Always set output charset\n\n        return doc;\n    }\n\n    // This helper method is usually part of DataUtil.java.\n    // Providing a placeholder implementation to ensure the code is self-contained and compilable.\n    // In a real Jsoup context, this would be properly implemented with regex.\n    private static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        java.util.regex.Matcher m = java.util.regex.Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\").matcher(contentType);\n        if (m.find()) {\n            return m.group(1).trim();\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}