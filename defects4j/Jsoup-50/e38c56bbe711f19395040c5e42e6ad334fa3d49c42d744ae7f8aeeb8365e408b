{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    String detectedCharset = null;\n\n    // BOMs: http://en.wikipedia.org/wiki/Byte_order_mark\n    // UTF-8 BOM: EF BB BF\n    // UTF-16 BE BOM: FE FF\n    // UTF-16 LE BOM: FF FE\n    // UTF-32 BE BOM: 00 00 FE FF\n    // UTF-32 LE BOM: FF FE 00 00\n\n    byteData.mark();\n    if (byteData.remaining() >= 4) {\n        int b0 = byteData.get(0) & 0xFF;\n        int b1 = byteData.get(1) & 0xFF;\n        int b2 = byteData.get(2) & 0xFF;\n        int b3 = byteData.get(3) & 0xFF;\n\n        if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {\n            detectedCharset = \"UTF-8\";\n            byteData.position(3);\n        } else if (b0 == 0xFE && b1 == 0xFF) {\n            detectedCharset = \"UTF-16BE\";\n            byteData.position(2);\n        } else if (b0 == 0xFF && b1 == 0xFE) {\n            // distinguish UTF-16LE from UTF-32LE (which would be FF FE 00 00)\n            if (b2 == 0x00 && b3 == 0x00) {\n                detectedCharset = \"UTF-32LE\";\n                byteData.position(4);\n            } else {\n                detectedCharset = \"UTF-16LE\";\n                byteData.position(2);\n            }\n        } else if (b0 == 0x00 && b1 == 0x00 && b2 == 0xFE && b3 == 0xFF) {\n            detectedCharset = \"UTF-32BE\";\n            byteData.position(4);\n        } else {\n            byteData.position(0);\n        }\n    } else if (byteData.remaining() >= 3) {\n        int b0 = byteData.get(0) & 0xFF;\n        int b1 = byteData.get(1) & 0xFF;\n        int b2 = byteData.get(2) & 0xFF;\n        if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {\n            detectedCharset = \"UTF-8\";\n            byteData.position(3);\n        } else {\n            byteData.position(0);\n        }\n    } else if (byteData.remaining() >= 2) {\n        int b0 = byteData.get(0) & 0xFF;\n        int b1 = byteData.get(1) & 0xFF;\n        if (b0 == 0xFE && b1 == 0xFF) {\n            detectedCharset = \"UTF-16BE\";\n            byteData.position(2);\n        } else if (b0 == 0xFF && b1 == 0xFE) {\n            detectedCharset = \"UTF-16LE\";\n            byteData.position(2);\n        } else {\n            byteData.position(0);\n        }\n    } else {\n        byteData.position(0);\n    }\n\n    if (detectedCharset != null) {\n        charsetName = detectedCharset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData.asReadOnlyBuffer()).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                // Remove BOM again if present for the newly detected encoding\n                ByteBuffer copy = byteData.asReadOnlyBuffer();\n                if (copy.remaining() >= 4) {\n                    int c0 = copy.get(0) & 0xFF;\n                    int c1 = copy.get(1) & 0xFF;\n                    int c2 = copy.get(2) & 0xFF;\n                    int c3 = copy.get(3) & 0xFF;\n                    if (c0 == 0xEF && c1 == 0xBB && c2 == 0xBF) copy.position(3);\n                    else if (c0 == 0xFE && c1 == 0xFF) copy.position(2);\n                    else if (c0 == 0xFF && c1 == 0xFE) {\n                        if (c2 == 0x00 && c3 == 0x00) copy.position(4);\n                        else copy.position(2);\n                    } else if (c0 == 0x00 && c1 == 0x00 && c2 == 0xFE && c3 == 0xFF) copy.position(4);\n                    else copy.position(0);\n                } else if (copy.remaining() >= 3) {\n                    int c0 = copy.get(0) & 0xFF;\n                    int c1 = copy.get(1) & 0xFF;\n                    int c2 = copy.get(2) & 0xFF;\n                    if (c0 == 0xEF && c1 == 0xBB && c2 == 0xBF) copy.position(3);\n                    else copy.position(0);\n                } else if (copy.remaining() >= 2) {\n                    int c0 = copy.get(0) & 0xFF;\n                    int c1 = copy.get(1) & 0xFF;\n                    if (c0 == 0xFE && c1 == 0xFF) copy.position(2);\n                    else if (c0 == 0xFF && c1 == 0xFE) copy.position(2);\n                    else copy.position(0);\n                } else copy.position(0);\n\n                docData = Charset.forName(foundCharset).decode(copy).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData.asReadOnlyBuffer()).toString();\n    }\n\n    // Don't check for UNICODE_BOM anymore, handled above\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        if (charsetName != null)\n            doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}