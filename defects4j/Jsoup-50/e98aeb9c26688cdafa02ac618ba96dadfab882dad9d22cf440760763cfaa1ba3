{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    String actualCharset = charsetName;\n    boolean hasBom = false;\n\n    // First check for BOM to determine charset\n    CharsetDecoder decoder = null;\n    try {\n        byteData.mark();\n        Charset bomCharset = detectCharsetFromBom(byteData);\n        if (bomCharset != null) {\n            actualCharset = bomCharset.name();\n            hasBom = true;\n        }\n        byteData.reset();\n    } catch (Exception e) {\n        // If error detecting BOM, proceed with original charset\n    }\n\n    // If charset still not determined, fall back to meta tag detection\n    if (actualCharset == null) {\n        // First attempt with default charset to read meta tags\n        byteData.mark();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        byteData.reset();\n\n        // Look for meta charset declaration\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                actualCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                doc = null;\n            }\n        }\n        if (doc != null && docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            // If we found a BOM after initial parsing, we need to re-parse with correct charset\n            actualCharset = defaultCharset;\n            doc = null;\n        }\n    }\n\n    // Now parse with the correct charset (whether from BOM, meta tag, or provided)\n    if (actualCharset != null) {\n        try {\n            // Use charset-specific decoder that handles BOM properly\n            Charset charset = Charset.forName(actualCharset);\n            CharsetDecoder decoderWithBom = charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n\n            // Reset buffer position\n            byteData.rewind();\n            docData = decoderWithBom.decode(byteData).toString();\n        } catch (Exception e) {\n            // Fallback to default charset if error occurs\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            actualCharset = defaultCharset;\n        }\n    } else {\n        // No charset specified and couldn't detect from BOM or meta\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        actualCharset = defaultCharset;\n    }\n\n    // Remove BOM if present\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n\n    // Parse the document if not already parsed\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(actualCharset);\n    }\n    return doc;\n}\n\nprivate static Charset detectCharsetFromBom(ByteBuffer buffer) {\n    buffer.mark();\n    byte[] bom = new byte[4];\n    int length = Math.min(buffer.remaining(), 4);\n    buffer.get(bom, 0, length);\n\n    // Check for UTF-8 BOM\n    if (length >= 3 && bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) {\n        buffer.position(buffer.position() - length + 3); // skip BOM\n        return Charset.forName(\"UTF-8\");\n    }\n    // Check for UTF-16 BE BOM\n    else if (length >= 2 && bom[0] == (byte)0xFE && bom[1] == (byte)0xFF) {\n        buffer.position(buffer.position() - length + 2); // skip BOM\n        return Charset.forName(\"UTF-16BE\");\n    }\n    // Check for UTF-16 LE BOM\n    else if (length >= 2 && bom[0] == (byte)0xFF && bom[1] == (byte)0xFE) {\n        buffer.position(buffer.position() - length + 2); // skip BOM\n        return Charset.forName(\"UTF-16LE\");\n    }\n    // Check for UTF-32 BE BOM\n    else if (length >= 4 && bom[0] == (byte)0x00 && bom[1] == (byte)0x00 &&\n            bom[2] == (byte)0xFE && bom[3] == (byte)0xFF) {\n        buffer.position(buffer.position() - length + 4); // skip BOM\n        return Charset.forName(\"UTF-32BE\");\n    }\n    // Check for UTF-32 LE BOM\n    else if (length >= 4 && bom[0] == (byte)0xFF && bom[1] == (byte)0xFE &&\n            bom[2] == (byte)0x00 && bom[3] == (byte)0x00) {\n        buffer.position(buffer.position() - length + 4); // skip BOM\n        return Charset.forName(\"UTF-32LE\");\n    }\n    buffer.reset();\n    return null;\n}\n\nprivate static String getCharsetFromContentType(String contentType) {\n    if (contentType == null) return null;\n    String[] parts = contentType.split(\";\");\n    for (String part : parts) {\n        part = part.trim();\n        if (part.toLowerCase().startsWith(\"charset=\")) {\n            String charset = part.substring(8).trim();\n            return charset.replaceAll(\"[\\\"']\", \"\");\n        }\n    }\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}