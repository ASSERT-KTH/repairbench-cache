{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // 1. Look for BOM (Byte Order Mark) - overrides any other header or input\n        String detectedCharset = detectCharsetFromByteData(byteData); // byteData position is rewound by this method\n        if (detectedCharset != null) {\n            charsetName = detectedCharset; // BOM detected charset takes precedence\n        }\n\n        // 2. If charsetName is still null (no BOM, and no charset specified by caller),\n        //    attempt to determine from <meta> tag.\n        //    Provisional parse as defaultCharset (UTF-8) first.\n        if (charsetName == null) {\n            // Save current byteData position to rewind to if we need to re-decode\n            byteData.mark();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            byteData.reset(); // Rewind byteData to its marked position (start of buffer)\n\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // ignore, just means it's not a valid charset name\n                        foundCharset = null;\n                    }\n                }\n\n                // If a charset was found in meta and it's different from defaultCharset, use it.\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                }\n            }\n            // If no meta charset found, or it was defaultCharset, then defaultCharset becomes the final one.\n            if (charsetName == null) {\n                charsetName = defaultCharset;\n            }\n        } else {\n            // charsetName was provided by the caller or detected by BOM. Validate it.\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        // 3. Final decode and parse with the determined charsetName.\n        byteData.rewind(); // Ensure buffer is at the beginning for the final decode\n\n        try {\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        } catch (UnsupportedCharsetException e) {\n            // Fallback to defaultCharset if the determined charset is not supported (e.g., malformed meta charset)\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            charsetName = defaultCharset; // Update charsetName to reflect the fallback\n        } catch (BufferUnderflowException e) {\n            // This can happen if the buffer is too short for the expected charset (e.g., UTF-16 expecting even bytes)\n            // or if the byte data is malformed for the chosen charset. Fallback to default.\n            byteData.rewind(); // Reset buffer for fallback decode\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            charsetName = defaultCharset; // Update charsetName to reflect the fallback\n        }\n\n        // The original `if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM)` block\n        // is removed. Correct CharsetDecoder implementations handle BOMs by consuming them,\n        // so the UNICODE_BOM character should not appear in the decoded string if the charset was correct.\n\n        // Final parse with the definitively decoded data\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}