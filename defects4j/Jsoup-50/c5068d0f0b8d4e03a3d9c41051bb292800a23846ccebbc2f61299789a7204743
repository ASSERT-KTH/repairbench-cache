{
    "generation": "// todo - this is getting gnarly. needs a rewrite.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    String detectedCharset = null;\n\n    // Check for BOM (Byte Order Mark) and override charset if found\n    // We'll look at the first few bytes without altering the original ByteBuffer (so mark & reset)\n    ByteOrderMark bom = null;\n    int[] bomLength = new int[1];\n    detectedCharset = detectCharsetFromBom(byteData, bomLength);\n    if (detectedCharset != null) {\n        charsetName = detectedCharset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // use defaultCharset (usually UTF-8) for initial decode\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                if (bomLength[0] > 0) {\n                    byteData.position(bomLength[0]); // skip BOM if present\n                }\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        byteData.rewind();\n        if (bomLength[0] > 0) {\n            byteData.position(bomLength[0]); // skip BOM if present\n        }\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    // Handle case where still has BOM as char at text head (e.g. UTF-8)\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName != null ? charsetName : defaultCharset);\n    }\n    return doc;\n}\n\n// Helper function for BOM detection\nprivate static String detectCharsetFromBom(ByteBuffer byteData, int[] bomLength) {\n    // Save old position\n    int oldPos = byteData.position();\n    try {\n        if (byteData.remaining() >= 4) {\n            byte b0 = byteData.get();\n            byte b1 = byteData.get();\n            byte b2 = byteData.get();\n            byte b3 = byteData.get();\n            if (b0 == (byte)0x00 && b1 == (byte)0x00 && b2 == (byte)0xFE && b3 == (byte)0xFF) {\n                // UTF-32, big-endian BOM\n                bomLength[0] = 4;\n                return \"UTF-32BE\";\n            }\n            if (b0 == (byte)0xFF && b1 == (byte)0xFE && b2 == (byte)0x00 && b3 == (byte)0x00) {\n                // UTF-32, little-endian BOM\n                bomLength[0] = 4;\n                return \"UTF-32LE\";\n            }\n            if (b0 == (byte)0xEF && b1 == (byte)0xBB && b2 == (byte)0xBF) {\n                // UTF-8 BOM (3 bytes)\n                bomLength[0] = 3;\n                return \"UTF-8\";\n            }\n            if (b0 == (byte)0xFE && b1 == (byte)0xFF) {\n                // UTF-16, big-endian BOM (2 bytes)\n                bomLength[0] = 2;\n                return \"UTF-16BE\";\n            }\n            if (b0 == (byte)0xFF && b1 == (byte)0xFE) {\n                // UTF-16, little-endian BOM (2 bytes)\n                bomLength[0] = 2;\n                return \"UTF-16LE\";\n            }\n        }\n        // check for UTF-8 BOM alone\n        if (byteData.remaining() >= 3) {\n            byte b0 = byteData.get(0);\n            byte b1 = byteData.get(1);\n            byte b2 = byteData.get(2);\n            if (b0 == (byte)0xEF && b1 == (byte)0xBB && b2 == (byte)0xBF) {\n                bomLength[0] = 3;\n                return \"UTF-8\";\n            }\n        }\n    } finally {\n        // reset buffer position\n        byteData.position(oldPos);\n    }\n    bomLength[0] = 0;\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}