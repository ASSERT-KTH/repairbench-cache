{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// Assuming defaultCharset and getCharsetFromContentType are accessible\n// from the enclosing class (e.g., DataUtil in Jsoup).\n// For compilation in a standalone context, these would need to be defined.\n// private static final String defaultCharset = \"UTF-8\";\n// private static String getCharsetFromContentType(String contentType) { /* ... implementation ... */ }\n\nclass DataUtil { // Assuming this function is part of a class like DataUtil\n    private static final String defaultCharset = \"UTF-8\"; // Jsoup's default is usually UTF-8\n\n    // This method is typically found in org.jsoup.internal.StringUtil or similar in Jsoup\n    private static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        java.util.regex.Matcher m = java.util.regex.Pattern.compile(\"charset=([^; ]+)\").matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            if (charset.length() > 0 && (charset.charAt(0) == '\"' || charset.charAt(0) == '\\'')) {\n                charset = charset.substring(1, charset.length() - 1);\n            }\n            return charset;\n        }\n        return null;\n    }\n\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // This will be the final charset used for decoding and document settings\n        String finalCharset = charsetName; \n        int bomBytes = 0; // Number of bytes representing the BOM, to be skipped\n        \n        // Save the initial position of the buffer (typically 0)\n        int initialDataPosition = byteData.position();\n\n        // 1. Validate provided charsetName argument early if it's not null\n        if (finalCharset != null) {\n            Validate.notEmpty(finalCharset, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        // 2. Look for BOM - overrides any other header or input\n        // Order of BOM checks: UTF-32, then UTF-16, then UTF-8\n        \n        // Check for UTF-32 BE/LE BOM (4 bytes)\n        if (byteData.remaining() >= 4) {\n            byteData.mark(); // Mark current position to reset later\n            byte b1 = byteData.get();\n            byte b2 = byteData.get();\n            byte b3 = byteData.get();\n            byte b4 = byteData.get();\n\n            if (b1 == 0x00 && b2 == 0x00 && b3 == (byte)0xFE && b4 == (byte)0xFF) { // UTF-32 BE BOM\n                finalCharset = \"UTF-32BE\"; bomBytes = 4;\n            } else if (b1 == (byte)0xFF && b2 == (byte)0xFE && b3 == 0x00 && b4 == 0x00) { // UTF-32 LE BOM\n                finalCharset = \"UTF-32LE\"; bomBytes = 4;\n            }\n            byteData.reset(); // Always reset the buffer position after peeking\n        }\n\n        // Check for UTF-16 BE/LE BOM (2 bytes), only if no UTF-32 BOM was found\n        if (bomBytes == 0 && byteData.remaining() >= 2) {\n            byteData.mark();\n            byte b1 = byteData.get();\n            byte b2 = byteData.get();\n\n            if (b1 == (byte)0xFE && b2 == (byte)0xFF) { // UTF-16 BE BOM\n                finalCharset = \"UTF-16BE\"; bomBytes = 2;\n            } else if (b1 == (byte)0xFF && b2 == (byte)0xFE) { // UTF-16 LE BOM\n                finalCharset = \"UTF-16LE\"; bomBytes = 2;\n            }\n            byteData.reset();\n        }\n\n        // Check for UTF-8 BOM (3 bytes), only if no other BOM was found\n        if (bomBytes == 0 && byteData.remaining() >= 3) {\n            byteData.mark();\n            byte b1 = byteData.get();\n            byte b2 = byteData.get();\n            byte b3 = byteData.get();\n\n            if (b1 == (byte)0xEF && b2 == (byte)0xBB && b3 == (byte)0xBF) { // UTF-8 BOM\n                finalCharset = \"UTF-8\"; bomBytes = 3;\n            }\n            byteData.reset();\n        }\n\n        // Advance the buffer position past the BOM bytes if a BOM was detected\n        if (bomBytes > 0) {\n            byteData.position(initialDataPosition + bomBytes);\n        }\n\n        // 3. Determine the charset for the initial decoding\n        // If `finalCharset` is still null, it means no charsetName was provided AND no BOM was detected.\n        // In this scenario, we use the `defaultCharset` for the first parse attempt to find meta tags.\n        String initialDecodeCharset = finalCharset;\n        if (initialDecodeCharset == null) {\n            initialDecodeCharset = defaultCharset;\n        }\n\n        // Perform the first decode of the byte data\n        docData = Charset.forName(initialDecodeCharset).decode(byteData).toString();\n\n        // 4. If `finalCharset` is still null (meaning neither user-provided nor BOM-detected),\n        //    then attempt to detect from meta tags.\n        if (finalCharset == null) { \n            // Parse the initially decoded data to find the meta charset\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null; // Ignore invalid charset names\n                    }\n                }\n\n                // If a new charset is found from meta and it's different from the initial decode charset\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(initialDecodeCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    finalCharset = foundCharset; // This found charset becomes the definitive charset\n\n                    // Rewind the byteData to its original content start position (after BOM, which is 0 here)\n                    byteData.position(initialDataPosition + bomBytes); \n                    docData = Charset.forName(finalCharset).decode(byteData).toString();\n                    doc = null; // Set doc to null to force a re-parse with the correct charset\n                }\n            }\n            // If after meta-detection, finalCharset is still null, it means no meta charset was found\n            // or it was the same as defaultCharset. In this case, defaultCharset becomes the final charset.\n            if (finalCharset == null) { \n                finalCharset = initialDecodeCharset; // Will be defaultCharset\n            }\n        }\n\n        // The original problematic `if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM)`\n        // block is removed, as BOM handling is now done robustly at the beginning by advancing\n        // the ByteBuffer's position.\n\n        // 5. Final parsing of the document\n        if (doc == null) { // If the document hasn't been parsed yet, or was marked for re-parsing\n            doc = parser.parseInput(docData, baseUri);\n        }\n        // Set the determined charset on the document's output settings\n        doc.outputSettings().charset(finalCharset);\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}