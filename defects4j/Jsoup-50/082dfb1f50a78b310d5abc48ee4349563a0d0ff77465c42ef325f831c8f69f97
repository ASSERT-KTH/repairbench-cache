{
    "generation": "// todo - this is getting gnarly. needs a rewrite.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // BOM detection\n    byte[] bom = new byte[4];\n    int bomLength = 0;\n    String bomCharset = null;\n\n    // Mark position\n    byteData.mark();\n\n    int len = Math.min(byteData.remaining(), 4);\n    for (int i = 0; i < len; i++) {\n        bom[i] = byteData.get();\n        bomLength++;\n    }\n\n    // Detect UTF BOMs\n    if (bomLength >= 3 && (bom[0] & 0xFF) == 0xEF && (bom[1] & 0xFF) == 0xBB && (bom[2] & 0xFF) == 0xBF) {\n        bomCharset = \"UTF-8\";\n        bomLength = 3;\n    } else if (bomLength >= 2 && (bom[0] & 0xFF) == 0xFE && (bom[1] & 0xFF) == 0xFF) {\n        bomCharset = \"UTF-16BE\";\n        bomLength = 2;\n    } else if (bomLength >= 2 && (bom[0] & 0xFF) == 0xFF && (bom[1] & 0xFF) == 0xFE) {\n        if (bomLength >= 4 && (bom[2] & 0xFF) == 0x00 && (bom[3] & 0xFF) == 0x00) {\n            bomCharset = \"UTF-32LE\";\n            bomLength = 4;\n        } else {\n            bomCharset = \"UTF-16LE\";\n            bomLength = 2;\n        }\n    } else if (bomLength >= 4 && (bom[0] & 0xFF) == 0x00 && (bom[1] & 0xFF) == 0x00\n            && (bom[2] & 0xFF) == 0xFE && (bom[3] & 0xFF) == 0xFF) {\n        bomCharset = \"UTF-32BE\";\n        bomLength = 4;\n    }\n\n    // Reset the position to after BOM (if any), or start\n    int bomEnd = (bomCharset != null) ? bomLength : 0;\n    byteData.reset();\n    byteData.position(byteData.position() + bomEnd);\n\n    // If BOM found, it overrides other charsetName\n    if (bomCharset != null) {\n        charsetName = bomCharset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as defaultCharset\n        docData = Charset.forName(defaultCharset).decode(byteData.asReadOnlyBuffer()).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep defaultCharset as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                if (bomEnd > 0) byteData.position(byteData.position() + bomEnd);\n                docData = Charset.forName(foundCharset).decode(byteData.asReadOnlyBuffer()).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData.asReadOnlyBuffer()).toString();\n    }\n    // in case of remaining BOM in string, remove it\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}