{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Check for BOM and set charsetName accordingly\n    byteData.mark();\n    String bomCharset = null;\n    int[] bomUtf8 =    {0xEF, 0xBB, 0xBF};\n    int[] bomUtf16be = {0xFE, 0xFF};\n    int[] bomUtf16le = {0xFF, 0xFE};\n    int[] bomUtf32be = {0x00, 0x00, 0xFE, 0xFF};\n    int[] bomUtf32le = {0xFF, 0xFE, 0x00, 0x00};\n    int possibleBomLen = Math.min(byteData.remaining(), 4);\n    byte[] first4bytes = new byte[possibleBomLen];\n    byteData.get(first4bytes, 0, possibleBomLen);\n    byteData.rewind();\n\n    if (possibleBomLen >= 3 &&\n        (first4bytes[0] & 0xFF) == bomUtf8[0] &&\n        (first4bytes[1] & 0xFF) == bomUtf8[1] &&\n        (first4bytes[2] & 0xFF) == bomUtf8[2]) {\n        bomCharset = \"UTF-8\";\n        byteData.position(3);\n    } else if (possibleBomLen >= 4 &&\n        (first4bytes[0] & 0xFF) == bomUtf32be[0] &&\n        (first4bytes[1] & 0xFF) == bomUtf32be[1] &&\n        (first4bytes[2] & 0xFF) == bomUtf32be[2] &&\n        (first4bytes[3] & 0xFF) == bomUtf32be[3]) {\n        bomCharset = \"UTF-32BE\";\n        byteData.position(4);\n    } else if (possibleBomLen >= 4 &&\n        (first4bytes[0] & 0xFF) == bomUtf32le[0] &&\n        (first4bytes[1] & 0xFF) == bomUtf32le[1] &&\n        (first4bytes[2] & 0xFF) == bomUtf32le[2] &&\n        (first4bytes[3] & 0xFF) == bomUtf32le[3]) {\n        bomCharset = \"UTF-32LE\";\n        byteData.position(4);\n    } else if (possibleBomLen >= 2 &&\n        (first4bytes[0] & 0xFF) == bomUtf16be[0] &&\n        (first4bytes[1] & 0xFF) == bomUtf16be[1]) {\n        bomCharset = \"UTF-16BE\";\n        byteData.position(2);\n    } else if (possibleBomLen >= 2 &&\n        (first4bytes[0] & 0xFF) == bomUtf16le[0] &&\n        (first4bytes[1] & 0xFF) == bomUtf16le[1]) {\n        bomCharset = \"UTF-16LE\";\n        byteData.position(2);\n    }\n\n    String usedCharset = bomCharset != null ? bomCharset : (charsetName != null ? charsetName : defaultCharset);\n\n    // decode - if BOM reset to start after BOM bytes, else at 0.\n    Charset charset;\n    try {\n        charset = Charset.forName(usedCharset);\n    } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n        charset = Charset.forName(defaultCharset); // fallback if unknown\n        usedCharset = defaultCharset;\n    }\n    docData = charset.decode(byteData).toString();\n\n    // after reading, remove BOM char if it remains at string start (necessary for some Java decoders)\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n\n    // Now parse and look for charset from meta if not previously supplied or detected\n    doc = parser.parseInput(docData, baseUri);\n    if (bomCharset == null && charsetName == null) {\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep current best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 &&\n                !foundCharset.equalsIgnoreCase(usedCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                try {\n                    Charset metaCharset = Charset.forName(foundCharset);\n                    byteData.rewind();\n                    docData = metaCharset.decode(byteData).toString();\n                    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n                        docData = docData.substring(1);\n                    }\n                    usedCharset = foundCharset;\n                    doc = parser.parseInput(docData, baseUri);\n                } catch(Exception e) {\n                    // fallback - ignore and keep previous parse\n                }\n            }\n        }\n    }\n    doc.outputSettings().charset(usedCharset);\n    return doc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}