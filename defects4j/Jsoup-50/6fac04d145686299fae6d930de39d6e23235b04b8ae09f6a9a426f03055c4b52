{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String initialCharsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String charsetToDecodeWith = initialCharsetName; // This will hold the charset used for the actual decode.\n\n        // 1. Look for BOM at the very beginning of the ByteBuffer.\n        // This overrides any other header or input charset.\n        byteData.mark(); // Mark position to reset if no BOM found, or advance if found.\n\n        int remainingBytes = byteData.remaining();\n        String bomCharset = null;\n        int bomLength = 0;\n\n        // Check for BOMs in order of commonality/length (UTF-8, then UTF-32, then UTF-16)\n        if (remainingBytes >= 3 && byteData.get(0) == (byte)0xEF && byteData.get(1) == (byte)0xBB && byteData.get(2) == (byte)0xBF) {\n            bomCharset = \"UTF-8\";\n            bomLength = 3;\n        } else if (remainingBytes >= 4 && byteData.get(0) == (byte)0x00 && byteData.get(1) == (byte)0x00 && byteData.get(2) == (byte)0xFE && byteData.get(3) == (byte)0xFF) {\n            bomCharset = \"UTF-32BE\";\n            bomLength = 4;\n        } else if (remainingBytes >= 4 && byteData.get(0) == (byte)0xFF && byteData.get(1) == (byte)0xFE && byteData.get(2) == (byte)0x00 && byteData.get(3) == (byte)0x00) {\n            bomCharset = \"UTF-32LE\";\n            bomLength = 4;\n        } else if (remainingBytes >= 2 && byteData.get(0) == (byte)0xFE && byteData.get(1) == (byte)0xFF) {\n            bomCharset = \"UTF-16BE\";\n            bomLength = 2;\n        } else if (remainingBytes >= 2 && byteData.get(0) == (byte)0xFF && byteData.get(1) == (byte)0xFE) {\n            bomCharset = \"UTF-16LE\";\n            bomLength = 2;\n        }\n\n        if (bomCharset != null) {\n            charsetToDecodeWith = bomCharset; // BOM detected, use this charset.\n            byteData.position(byteData.position() + bomLength); // Advance buffer past BOM.\n        } else {\n            byteData.reset(); // No BOM, reset to original position for full decode.\n        }\n\n        // 2. Determine the final charset for content decoding.\n        // If charsetToDecodeWith is still null (no BOM and initialCharsetName was null),\n        // we parse with defaultCharset first to detect from meta.\n        if (charsetToDecodeWith == null) {\n            // Determine from meta. Safe parse as UTF-8 (defaultCharset assumed).\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri); // First parse with defaultCharset.\n\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                // If a different charset is found in meta, re-decode the byte data.\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetToDecodeWith = foundCharset; // Update charset to use for re-decoding.\n                    byteData.rewind(); // Rewind the ByteBuffer to decode from start (after potential BOM).\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null; // Force re-parsing with the correctly decoded data.\n                } else {\n                    charsetToDecodeWith = defaultCharset; // Meta found, but same as default or invalid, stick with default.\n                }\n            } else {\n                charsetToDecodeWith = defaultCharset; // No meta tag found, stick with default.\n            }\n        } else { // Charset was explicitly provided (initialCharsetName) or detected by BOM.\n            Validate.notEmpty(charsetToDecodeWith, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            try {\n                docData = Charset.forName(charsetToDecodeWith).decode(byteData).toString();\n            } catch (IllegalCharsetNameException e) {\n                // Fallback if the determined charset name is not supported.\n                docData = Charset.forName(defaultCharset).decode(byteData).toString();\n                charsetToDecodeWith = defaultCharset;\n            }\n        }\n\n        // The previous logic that checked for `docData.charAt(0) == UNICODE_BOM`\n        // and re-decoded/substringed is removed. BOMs are now handled at the byte level,\n        // and the decoded `docData` should not contain the BOM character if it was a byte-level BOM.\n\n        // Final parsing step if doc hasn't been created or re-parsing is needed.\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            // Ensure the document's output settings charset is correctly set.\n            // charsetToDecodeWith should always be a valid charset name by this point.\n            doc.outputSettings().charset(charsetToDecodeWith);\n        }\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}