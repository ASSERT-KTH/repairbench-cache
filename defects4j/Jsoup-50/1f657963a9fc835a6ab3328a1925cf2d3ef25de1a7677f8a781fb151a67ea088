{
    "generation": "import org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// Imports assumed available in the original context:\n// import static org.jsoup.helper.DataUtil.defaultCharset; // Assuming defaultCharset = \"UTF-8\"\n// import static org.jsoup.helper.DataUtil.getCharsetFromContentType; // Helper method assumed available\n\nclass FixedDataUtil { // Renamed class for clarity; use original class name in practice\n\n    // Assuming these constants and helpers are available or defined in the actual DataUtil class\n    private static final String UTF_32BE = \"UTF-32BE\";\n    private static final String UTF_32LE = \"UTF-32LE\";\n    private static final String UTF_16BE = \"UTF-16BE\";\n    private static final String UTF_16LE = \"UTF-16LE\";\n    private static final String UTF_8 = \"UTF-8\";\n    static final String defaultCharset = UTF_8; // Or get from DataUtil.defaultCharset\n\n    // Dummy helper for compilation; use the real one from DataUtil\n    private static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        String[] params = contentType.split(\";\");\n        for (String param : params) {\n            param = param.trim().toLowerCase();\n            if (param.startsWith(\"charset=\")) {\n                String charset = param.substring(\"charset=\".length()).replace(\"\\\"\", \"\").replace(\"'\", \"\");\n                 if (charset.isEmpty()) return null;\n                 try {\n                     if (Charset.isSupported(charset)) return charset;\n                 } catch (IllegalCharsetNameException e) { /* ignore */ }\n                 return null;\n            }\n        }\n        return null;\n     }\n\n\n    /**\n     * Parses the input byte data into a Document. Given a byte buffer, detects the character set via BOM or\n     * meta http-equiv tags, or specified Bset. Then parses into a Document.\n     *\n     * @param byteData    byte data to parse. The buffer will be consumed.\n     * @param charsetName character set to decode the data by. If null, will try to detect.\n     * @param baseUri     base uri of the document, used to resolve relative urls.\n     * @param parser      parser to use to parse the data.\n     * @return Document parsed from the byte data.\n     */\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        int bomOffset = 0;\n        String bomCharset = null; // Used to hold detected BOM charset name\n\n        // *** BOM Detection ***\n        // Detects UTF-32BE, UTF-32LE, UTF-16BE, UTF-16LE, UTF-8 BOMs\n        byteData.mark(); // Mark the start for potential rewind/reset\n        if (byteData.remaining() >= 4) {\n            byte b1 = byteData.get(); byte b2 = byteData.get(); byte b3 = byteData.get(); byte b4 = byteData.get();\n            byteData.rewind(); // Reset position to mark after reading bytes\n\n            if (b1 == (byte) 0x00 && b2 == (byte) 0x00 && b3 == (byte) 0xFE && b4 == (byte) 0xFF) { // UTF-32BE \"00 00 FE FF\"\n                bomCharset = UTF_32BE; bomOffset = 4;\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE && b3 == (byte) 0x00 && b4 == (byte) 0x00) { // UTF-32LE \"FF FE 00 00\"\n                bomCharset = UTF_32LE; bomOffset = 4;\n            } else if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) { // UTF-16BE \"FE FF\"\n                bomCharset = UTF_16BE; bomOffset = 2;\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) { // UTF-16LE \"FF FE\"\n                bomCharset = UTF_16LE; bomOffset = 2;\n            } else if (b1 == (byte) 0xEF && b2 == (byte) 0xBB && b3 == (byte) 0xBF) { // UTF-8 \"EF BB BF\"\n                bomCharset = UTF_8; bomOffset = 3;\n            }\n            // If no match, bomCharset remains null, bomOffset 0\n        } else if (byteData.remaining() >= 2) { // Check for 2/3 byte BOMs if buffer smaller than 4\n            byte b1 = byteData.get(); byte b2 = byteData.get();\n            byteData.rewind(); // Reset position to mark\n\n            if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) { // UTF-16BE \"FE FF\"\n                bomCharset = UTF_16BE; bomOffset = 2;\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) { // UTF-16LE \"FF FE\"\n                bomCharset = UTF_16LE; bomOffset = 2;\n            } else if (byteData.remaining() >= 3 && b1 == (byte) 0xEF && b2 == (byte) 0xBB && byteData.get(2) == (byte) 0xBF) { // UTF-8 \"EF BB BF\" - need get(index) to peek\n                 byteData.rewind(); // Ensure position is reset before applying offset later\n                 bomCharset = UTF_8; bomOffset = 3;\n            }\n        }\n        // Ensure position is back at the mark if no BOM matched, or ready to be advanced if BOM matched\n        if (bomCharset != null) {\n            charsetName = bomCharset; // BOM overrides specified charset, always takes precedence\n            byteData.position(byteData.position() + bomOffset); // Consume the BOM bytes\n        } else {\n            // No BOM found; ensure position is reset to the start mark\n            byteData.reset();\n        }\n\n\n        // *** Charset Detection from Meta or Use Provided/Default ***\n        if (charsetName == null) { // If no BOM detected and no charset specified by caller\n            // We need to find the encoding from a meta tag. Decode tentatively using default (UTF-8).\n            byteData.mark(); // Mark current position (start of actual data)\n            try {\n                docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            } catch (Exception e) {\n                // Handle potential decoding errors if defaultCharset is wrong\n                // For now, rethrow as runtime, or consider returning an empty doc or logging error.\n                throw new RuntimeException(\"Could not decode using default charset \" + defaultCharset, e);\n            }\n\n            // Parse the tentatively decoded data to find meta tags\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.selectFirst(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null;\n\n            if (meta != null) {\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        String metaCharset = meta.attr(\"charset\").trim();\n                        if (Charset.isSupported(metaCharset)) {\n                            foundCharset = metaCharset;\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // Ignore invalid charset attribute value\n                        foundCharset = null;\n                    }\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() > 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // Meta tag found a different, valid charset. Re-decode the original byte data.\n                // Normalize charset name (trim, remove quotes - based on original code's behavior)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.reset(); // Rewind to the position marked before the tentative decode\n                docData = Charset.forName(charsetName).decode(byteData).toString(); // Decode again with correct charset\n                doc = null; // Discard the tentatively parsed document\n            } else {\n                // Meta tag not found, or specified the default charset. Use the tentatively parsed doc.\n                // Ensure the charset name reflects the default used.\n                charsetName = defaultCharset;\n                // byteData was consumed by the decode operation, no need to reset position\n            }\n        } else { // Charset was specified by caller or detected from BOM\n            // We must decode with the specified charsetName.\n            Validate.notEmpty(charsetName, \"Charset must not be empty at this point\"); // Should be guaranteed\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n            // byteData is consumed by the decode operation\n            doc = null; // Ensure doc is parsed fresh below\n        }\n\n\n        // *** Final Parse ***\n        if (doc == null) {\n            // Parse the string document data using the selected parser\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the determined charset on the document's output settings.\n        // Fallback to default if somehow null (shouldn't happen with current logic).\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        doc.outputSettings().charset(charsetName);\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}