{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// Assume DataUtil class context and availability of defaultCharset and getCharsetFromContentType\nclass DataUtil {\n    // Assume defaultCharset is defined, e.g., static final String defaultCharset = \"UTF-8\";\n    // Assume getCharsetFromContentType(String) is defined and functional.\n    static final String defaultCharset = \"UTF-8\"; // Example definition\n    private static final String W3C_CHARSET = \"charset\";\n\n    // Placeholder for the helper method if not present elsewhere\n    private static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        String[] params = contentType.split(\";\");\n        for (String param : params) {\n            param = param.trim().toLowerCase();\n            if (param.startsWith(\"charset=\")) {\n                String charset = param.substring(\"charset=\".length());\n                // Remove quotes, trim\n                charset = charset.replace(\"\\\"\", \"\").replace(\"'\", \"\").trim();\n                return charset;\n            }\n        }\n        return null;\n    }\n\n\n    // todo - this is getting gnarly. needs a rewrite. // Original comment\n    /**\n     * Parses the input byte data into a Document. Detects the character set via BOM, HTTP-Equivalent meta tag, or fallback to default.\n     * @param byteData byte data to parse. Assumed to be rewound (position = 0).\n     * @param charsetName character set to use when parsing the byte data, if known. Set to null to autodetect.\n     * @param baseUri The URL where the document was fetched from (for resolving relative links).\n     * @param parser The parser to use.\n     * @return parsed Document\n     */\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String effectiveCharset = null; // The charset used for final decode\n\n        // ***** 1. Handle BOM *****\n        // Must be called before advancing buffer. Assume byteData is rewound (position=0).\n        byteData.mark();\n        byte[] bom = new byte[4];\n        int read = byteData.remaining() >= 4 ? 4 : byteData.remaining();\n        if (read > 0) byteData.get(bom, 0, read);\n        byteData.reset(); // Reset position to 0\n\n        if (read >= 4 && bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) { // UTF-32BE\n            effectiveCharset = \"UTF-32BE\";\n            byteData.position(byteData.position() + 4); // Advance past BOM\n        } else if (read >= 4 && bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) { // UTF-32LE\n            effectiveCharset = \"UTF-32LE\";\n            byteData.position(byteData.position() + 4);\n        } else if (read >= 3 && bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { // UTF-8\n            effectiveCharset = \"UTF-8\";\n            byteData.position(byteData.position() + 3);\n        } else if (read >= 2 && bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) { // UTF-16BE\n            effectiveCharset = \"UTF-16BE\";\n            byteData.position(byteData.position() + 2);\n        } else if (read >= 2 && bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { // UTF-16LE\n            effectiveCharset = \"UTF-16LE\";\n            byteData.position(byteData.position() + 2);\n        }\n        // If BOM found, effectiveCharset is now set, and byteData position is advanced past BOM.\n\n        // Override BOM-detected charset with specified charset if provided\n        if (charsetName != null) {\n            // Validate confirms not null, empty, etc\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            effectiveCharset = charsetName;\n            doc = null; // We need to parse with the specified charset, previous BOM parse (if any) is irrelevant\n        }\n\n\n        // ***** 2. Decode based on determined charset *****\n        if (effectiveCharset != null) {\n             // Charset specified, or BOM detected. Decode with it from current position (might be after BOM).\n             docData = Charset.forName(effectiveCharset).decode(byteData).toString();\n        } else {\n             // ***** 3. No BOM and no specified charset -> Detect from meta tag *****\n             // Decode tentatively using default charset (UTF-8)\n             effectiveCharset = defaultCharset; // Use default for initial decode\n             byteData.mark(); // Mark for potential rewind\n             docData = Charset.forName(effectiveCharset).decode(byteData).toString();\n             byteData.reset(); // Rewind buffer to position 0 for potential re-decode\n\n             // Parse the tentatively decoded data to find meta tag\n             doc = parser.parseInput(docData, baseUri);\n             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n             String foundCharset = null;\n\n             if (meta != null) {\n                 if (meta.hasAttr(\"http-equiv\")) {\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                     // Handle charset=; case (invalid but seen)\n                     if (foundCharset != null && foundCharset.isEmpty()) foundCharset = null;\n                 }\n                 if (foundCharset == null && meta.hasAttr(W3C_CHARSET)) {\n                     foundCharset = meta.attr(W3C_CHARSET);\n                 }\n             }\n\n             if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(effectiveCharset)) {\n                 // Found a different charset in meta, clean, validate and re-decode if supported\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 try {\n                     if (Charset.isSupported(foundCharset)) {\n                         effectiveCharset = foundCharset; // Update to the found charset\n                         // byteData is already rewound by reset()\n                         docData = Charset.forName(effectiveCharset).decode(byteData).toString();\n                         doc = null; // Discard the initial parse, needs re-parsing with correct charset\n                     } else {\n                         // Meta charset not supported or invalid, stick with the default parse (already in 'doc')\n                         // effectiveCharset remains defaultCharset.\n                         doc.outputSettings().charset(effectiveCharset); // Ensure doc's output setting is correct\n                     }\n                 } catch (IllegalCharsetNameException e) {\n                     // Invalid charset name in meta tag, stick with the default parse (already in 'doc')\n                     // effectiveCharset remains defaultCharset.\n                     doc.outputSettings().charset(effectiveCharset); // Ensure doc's output setting is correct\n                 }\n             } else {\n                 // No meta charset found, or it matches default. Use the doc parsed with default.\n                 // effectiveCharset remains defaultCharset.\n                 if (doc != null) { // doc should exist here from the tentative parse\n                    doc.outputSettings().charset(effectiveCharset);\n                 }\n             }\n        }\n\n        // ***** 4. Parse the document *****\n        if (doc == null) { // If not parsed yet (BOM found, or specified charset, or meta detected different supported charset)\n            // docData should hold the correctly decoded string now\n            docData = docData == null ? \"\" : docData; // Should not be null, but safe check\n            doc = parser.parseInput(docData, baseUri);\n\n            // If effectiveCharset is still somehow null, fallback to default.\n            if (effectiveCharset == null) {\n                effectiveCharset = defaultCharset;\n            }\n            doc.outputSettings().charset(effectiveCharset);\n        }\n        // If doc was already parsed (meta check case resulted in using default charset), its charset is already set.\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}