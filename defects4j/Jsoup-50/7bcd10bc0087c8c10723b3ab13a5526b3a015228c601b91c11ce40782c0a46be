{
    "generation": "    // todo - this is getting gnarly. needs a rewrite.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String foundCharset = null; // Charset found from BOM\n\n        // -- BOM DETECTION --\n        // Detects UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, UTF-32LE BOMs\n        // Reference: http://www.unicode.org/faq/utf_bom.html#BOM\n        byteData.mark(); // Mark the start position\n        byte[] bom = new byte[4]; // Max BOM size is 4 bytes (UTF-32)\n        if (byteData.remaining() >= 2) {\n            byteData.get(bom, 0, 2); // Read first 2 bytes\n            byteData.reset(); // Reset position to start\n\n            if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) { // UTF-16BE\n                foundCharset = \"UTF-16BE\";\n                byteData.position(byteData.position() + 2); // Advance past BOM\n            } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) { // Could be UTF-16LE or UTF-32LE\n                 if (byteData.remaining() >= 4) {\n                     byteData.get(bom); // Read all 4 bytes (FF FE 00 00 for UTF-32LE)\n                     byteData.reset(); // Reset position to start\n                     if (bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) { // UTF-32LE\n                         foundCharset = \"UTF-32LE\";\n                         byteData.position(byteData.position() + 4); // Advance past BOM\n                     } else { // Must be UTF-16LE\n                         foundCharset = \"UTF-16LE\";\n                         byteData.position(byteData.position() + 2); // Advance past BOM\n                     }\n                 } else { // Not enough bytes for UTF-32LE, must be UTF-16LE\n                     foundCharset = \"UTF-16LE\";\n                     byteData.position(byteData.position() + 2); // Advance past BOM\n                 }\n            } else if (byteData.remaining() >= 3) { // Look for UTF-8 BOM (EF BB BF)\n                byteData.get(bom, 0, 3); // Read first 3 bytes\n                byteData.reset(); // Reset position to start\n                if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) { // UTF-8\n                    foundCharset = \"UTF-8\";\n                    byteData.position(byteData.position() + 3); // Advance past BOM\n                } else if (byteData.remaining() >= 4) { // Look for UTF-32BE BOM (00 00 FE FF)\n                    byteData.get(bom); // Read all 4 bytes\n                    byteData.reset(); // Reset position to start\n                     if (bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) { // UTF-32BE\n                         foundCharset = \"UTF-32BE\";\n                         byteData.position(byteData.position() + 4); // Advance past BOM\n                     }\n                     // else no UTF-32BE, no BOM found here if not UTF-8 either\n                }\n                // else no UTF-8 BOM or not enough bytes for UTF-32BE\n            }\n            // else not enough bytes for any BOM (min 2) or no match\n        }\n        // If no BOM detected, foundCharset remains null, and buffer position is still at the start.\n\n        String effectiveCharset = foundCharset; // Use BOM if found, it overrides any other declaration\n\n        if (foundCharset == null && charsetName != null) {\n            // If no BOM was detected, use the externally provided charset name\n            effectiveCharset = charsetName;\n        }\n\n        // -- DECODING and META TAG CHECK --\n        if (effectiveCharset == null) { // No BOM, no provided charset -> auto-detect from meta tag\n            // We need to bootstrap the parse with *some* charset. UTF-8 is the default used by Jsoup/spec.\n            // This might decode incorrectly for the meta tag, but it's the specified behavior.\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri); // Initial parse attempt\n\n            // Look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\">\n            // or <meta charset=\"gb2312\">\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String metaCharset = null;\n\n            if (meta != null) { // Found a meta tag, extract charset\n                if (meta.hasAttr(\"http-equiv\")) {\n                    metaCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (metaCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        // Charset.forName() implicitly checks support. Using isSupported() can be slightly faster\n                        // but throws IAE on invalid names, whereas forName throws UCE/ICE. Robustness preferred.\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            metaCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // specified charset is invalid, ignore it\n                        metaCharset = null;\n                    }\n                }\n            }\n\n            if (metaCharset != null && metaCharset.length() > 0 && !metaCharset.equals(defaultCharset)) {\n                // Meta tag specifies charset different from bootstrap default; re-decode.\n                metaCharset = metaCharset.trim().replaceAll(\"[\\\"']\", \"\"); // Clean the value e.g. \"UTF-8\" -> UTF-8\n                effectiveCharset = metaCharset;\n\n                // Rewind buffer to re-read under the correct charset.\n                // (BOM wasn't present in this case, so rewind/reset buffer to start)\n                byteData.rewind(); // Use rewind() as mark may have been invalidated by decode\n                docData = Charset.forName(effectiveCharset).decode(byteData).toString();\n                doc = null; // Mark for re-parse needed below\n            } else {\n                 // Meta tag charset is same as default, or no meta tag found, or meta charset invalid.\n                 // Keep the initial parse (doc), and use the bootstrap defaultCharset as the effective one.\n                 effectiveCharset = defaultCharset;\n                 // Note: The initial 'doc' variable is already parsed based on defaultCharset, so we reuse it.\n            }\n        } else { // BOM detected OR charset provided by caller (and not overridden by BOM)\n            // Decode using the detected/provided effective charset.\n            Validate.notEmpty(effectiveCharset, \"BUG: effectiveCharset should not be null here\"); // Should have been set by BOM or input\n            docData = Charset.forName(effectiveCharset).decode(byteData).toString();\n            // doc is null, needs parsing below\n        }\n\n        // -- FINAL PARSE --\n        if (doc == null) {\n             // If docData is somehow null (e.g., decode threw exception? unlikely for valid charset),\n             // or empty, the parser should handle it appropriately (usually returns an empty document).\n             // Avoid passing null to parser.parseInput.\n             if (docData == null) docData = \"\"; // Defensive check\n\n             // We parse the doc here, using the final determined docData string.\n             doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the charset used for parsing in the doc's output settings.\n        // Use the finally determined effective charset. Fallback to default if it's somehow still null.\n        doc.outputSettings().charset(effectiveCharset != null ? effectiveCharset : defaultCharset);\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}