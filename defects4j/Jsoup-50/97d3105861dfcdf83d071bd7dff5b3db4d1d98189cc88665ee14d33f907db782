{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // First, handle BOM detection before any other processing\n    Charset detectedCharset = detectCharsetFromBOM(byteData);\n    if (detectedCharset != null) {\n        charsetName = detectedCharset.name();\n        // Reset buffer position after BOM detection\n        byteData.rewind();\n        // Skip BOM bytes for the actual content parsing\n        int bomLength = detectedCharset.name().startsWith(\"UTF-16\") ? 2 :\n                        detectedCharset.name().startsWith(\"UTF-32\") ? 4 : 0;\n        if (bomLength > 0) {\n            byteData.position(bomLength);\n        }\n    }\n\n    // If charset still not specified, try to determine it from meta tags\n    if (charsetName == null) {\n        // First attempt with default charset to find charset declaration in meta tags\n        ByteBuffer tempBuffer = byteData.duplicate();\n        docData = Charset.forName(defaultCharset).decode(tempBuffer).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // Look for charset in meta tags\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null; // We'll need to re-parse with the correct charset\n            }\n        }\n    }\n\n    // Now parse with the correct charset (either from BOM, content-type header, or meta tag)\n    if (doc == null) {\n        // Reset buffer to beginning (except if we already skipped BOM)\n        if (!byteData.hasArray() && byteData.position() == 0) {\n            byteData.rewind();\n        }\n        if (charsetName == null) {\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        } else {\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        doc = parser.parseInput(docData, baseUri);\n    }\n\n    // Handle any remaining BOM in the text if needed (UTF-8 BOM case)\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n    }\n    doc.outputSettings().charset(charsetName);\n    return doc;\n}\n\nprivate static Charset detectCharsetFromBOM(ByteBuffer byteData) {\n    if (byteData.remaining() >= 4) {\n        byteData.mark();\n        byte[] bom = new byte[4];\n        byteData.get(bom, 0, 4);\n        byteData.reset();\n\n        // Check for UTF-32 BE BOM (00 00 FE FF)\n        if (bom[0] == (byte)0x00 && bom[1] == (byte)0x00 && bom[2] == (byte)0xFE && bom[3] == (byte)0xFF) {\n            return Charset.forName(\"UTF-32BE\");\n        }\n        // Check for UTF-32 LE BOM (FF FE 00 00)\n        if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE && bom[2] == (byte)0x00 && bom[3] == (byte)0x00) {\n            return Charset.forName(\"UTF-32LE\");\n        }\n    }\n\n    if (byteData.remaining() >= 2) {\n        byteData.mark();\n        byte[] bom = new byte[2];\n        byteData.get(bom, 0, 2);\n        byteData.reset();\n\n        // Check for UTF-16 BE BOM (FE FF)\n        if (bom[0] == (byte)0xFE && bom[1] == (byte)0xFF) {\n            return Charset.forName(\"UTF-16BE\");\n        }\n        // Check for UTF-16 LE BOM (FF FE)\n        if (bom[0] == (byte)0xFF && bom[1] == (byte)0xFE) {\n            return Charset.forName(\"UTF-16LE\");\n        }\n    }\n\n    // Check for UTF-8 BOM (EF BB BF) if we have at least 3 bytes\n    if (byteData.remaining() >= 3) {\n        byteData.mark();\n        byte[] bom = new byte[3];\n        byteData.get(bom, 0, 3);\n        byteData.reset();\n\n        if (bom[0] == (byte)0xEF && bom[1] == (byte)0xBB && bom[2] == (byte)0xBF) {\n            return Charset.forName(\"UTF-8\");\n        }\n    }\n\n    return null; // No BOM detected\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}