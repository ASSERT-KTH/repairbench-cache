{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    // sniff BOM - overrides any other header or input\n    byteData.rewind();\n    int start = byteData.position();\n    int end = byteData.limit();\n    int rem = end - start;\n    String bomCharset = null;\n    int bomLength = 0;\n    // UTF-32 BOMs\n    if (rem >= 4) {\n        int b0 = byteData.get(start) & 0xFF;\n        int b1 = byteData.get(start + 1) & 0xFF;\n        int b2 = byteData.get(start + 2) & 0xFF;\n        int b3 = byteData.get(start + 3) & 0xFF;\n        if (b0 == 0x00 && b1 == 0x00 && b2 == 0xFE && b3 == 0xFF) {\n            bomCharset = \"UTF-32BE\"; bomLength = 4;\n        } else if (b0 == 0xFF && b1 == 0xFE && b2 == 0x00 && b3 == 0x00) {\n            bomCharset = \"UTF-32LE\"; bomLength = 4;\n        }\n    }\n    // UTF-8 BOM\n    if (bomCharset == null && rem >= 3) {\n        int b0 = byteData.get(start) & 0xFF;\n        int b1 = byteData.get(start + 1) & 0xFF;\n        int b2 = byteData.get(start + 2) & 0xFF;\n        if (b0 == 0xEF && b1 == 0xBB && b2 == 0xBF) {\n            bomCharset = \"UTF-8\"; bomLength = 3;\n        }\n    }\n    // UTF-16 BOMs\n    if (bomCharset == null && rem >= 2) {\n        int b0 = byteData.get(start) & 0xFF;\n        int b1 = byteData.get(start + 1) & 0xFF;\n        if (b0 == 0xFE && b1 == 0xFF) {\n            bomCharset = \"UTF-16BE\"; bomLength = 2;\n        } else if (b0 == 0xFF && b1 == 0xFE) {\n            bomCharset = \"UTF-16LE\"; bomLength = 2;\n        }\n    }\n    if (bomCharset != null) {\n        charsetName = bomCharset;\n        byteData.position(start + bomLength);\n    }\n\n    String docData;\n    Document doc = null;\n\n    // no explicit charset: sniff meta\n    if (charsetName == null) {\n        // safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv> or HTML5 <meta charset>\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String found = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                found = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (found == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        found = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) { }\n            }\n            if (found != null\n                && found.trim().length() > 0\n                && !found.equals(defaultCharset)) {\n\n                found = found.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = found;\n                byteData.rewind();\n\n                // re-decode with the new charset\n                if (\"UTF-32BE\".equalsIgnoreCase(found) || \"UTF-32LE\".equalsIgnoreCase(found)) {\n                    boolean big = \"UTF-32BE\".equalsIgnoreCase(found);\n                    ByteBuffer dup = byteData.duplicate();\n                    int s = dup.position(), l = dup.limit();\n                    StringBuilder sb = new StringBuilder((l - s) / 4);\n                    for (int i = s; i + 3 < l; i += 4) {\n                        int c0 = dup.get(i) & 0xFF;\n                        int c1 = dup.get(i + 1) & 0xFF;\n                        int c2 = dup.get(i + 2) & 0xFF;\n                        int c3 = dup.get(i + 3) & 0xFF;\n                        int cp = big\n                            ? ((c0 << 24) | (c1 << 16) | (c2 << 8) | c3)\n                            : ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0);\n                        if (Character.isBmpCodePoint(cp)) {\n                            sb.append((char) cp);\n                        } else if (Character.isValidCodePoint(cp)) {\n                            sb.append(Character.highSurrogate(cp));\n                            sb.append(Character.lowSurrogate(cp));\n                        }\n                    }\n                    docData = sb.toString();\n                } else {\n                    docData = Charset.forName(found).decode(byteData).toString();\n                }\n                doc = null;\n            }\n        }\n    } else {\n        // explicit charset by header or BOM\n        Validate.notEmpty(charsetName,\n            \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n\n        if (\"UTF-32BE\".equalsIgnoreCase(charsetName)\n         || \"UTF-32LE\".equalsIgnoreCase(charsetName)) {\n\n            boolean big = \"UTF-32BE\".equalsIgnoreCase(charsetName);\n            ByteBuffer dup = byteData.duplicate();\n            int s = dup.position(), l = dup.limit();\n            StringBuilder sb = new StringBuilder((l - s) / 4);\n            for (int i = s; i + 3 < l; i += 4) {\n                int c0 = dup.get(i) & 0xFF;\n                int c1 = dup.get(i + 1) & 0xFF;\n                int c2 = dup.get(i + 2) & 0xFF;\n                int c3 = dup.get(i + 3) & 0xFF;\n                int cp = big\n                    ? ((c0 << 24) | (c1 << 16) | (c2 << 8) | c3)\n                    : ((c3 << 24) | (c2 << 16) | (c1 << 8) | c0);\n                if (Character.isBmpCodePoint(cp)) {\n                    sb.append((char) cp);\n                } else if (Character.isValidCodePoint(cp)) {\n                    sb.append(Character.highSurrogate(cp));\n                    sb.append(Character.lowSurrogate(cp));\n                }\n            }\n            docData = sb.toString();\n        } else {\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n    }\n\n    // final parse if needed\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}