{
    "generation": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n\n        // look for BOM - overrides any other header or input\n        // detectBOM peeks at the buffer and rewinds its position to 0.\n        String bomCharset = detectBOM(byteData);\n        int bomLength = 0;\n\n        if (bomCharset != null) {\n            charsetName = bomCharset; // BOM detected charset overrides any provided charsetName\n            // Determine BOM length and advance byteData position past BOM\n            if (bomCharset.equals(\"UTF-8\")) {\n                bomLength = 3;\n            } else if (bomCharset.equals(\"UTF-16BE\") || bomCharset.equals(\"UTF-16LE\")) {\n                bomLength = 2;\n            } else if (bomCharset.equals(\"UTF-32BE\") || bomCharset.equals(\"UTF-32LE\")) {\n                bomLength = 4;\n            }\n            // Since detectBOM rewound, byteData.position() is 0. Advance it by bomLength.\n            byteData.position(bomLength);\n        }\n\n        // Now, determine the charset for actual decoding.\n        // If charsetName is still null, it means no BOM found and no charset explicitly given.\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // Mark current position (after any BOM skip) for potential re-decode.\n            byteData.mark();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // Look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // ignore, no charset found\n                    }\n                }\n\n                // If a new charset is found and different from defaultCharset, re-decode.\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset; // This will be the effective charset for final parse\n                    byteData.reset(); // Rewind to the marked position (after BOM, if any, or beginning of buffer)\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null; // Reset doc, as it was parsed with the wrong charset\n                }\n            }\n\n            // If no BOM, and no meta charset, fall back to defaultCharset for output settings.\n            if (charsetName == null) {\n                charsetName = defaultCharset;\n            }\n\n        } else { // charsetName was specified by content type header (or by user on file load, or by BOM detection)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            // byteData.position() is already set by BOM handling or is 0 if no BOM\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n\n        // The old BOM check (docData.charAt(0) == UNICODE_BOM) is removed\n        // because BOMs are now handled at the byte level before decoding.\n\n        if (doc == null) { // doc will be null if no BOM was found AND no meta charset was found OR meta charset caused re-decode\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName); // Set the document's effective charset\n        }\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}