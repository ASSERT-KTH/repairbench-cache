{
    "generation": "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData = null;\n    Document doc = null;\n\n    // Detect and handle BOM (Byte Order Mark)\n    String detectedCharset = null;\n    ByteOrderMark bom = null;\n\n    // Mark the original position to always rewind after peeking for BOM\n    byteData.mark();\n\n    // Utility to read BOM and set detectedCharset\n    if (byteData.remaining() >= 4) {\n        byte b0 = byteData.get();\n        byte b1 = byteData.get();\n        byte b2 = byteData.get();\n        byte b3 = byteData.get();\n        // Check for BOMs (UTF-8, UTF-16, UTF-32)\n        if ((b0 == (byte)0x00 && b1 == (byte)0x00 && b2 == (byte)0xFE && b3 == (byte)0xFF)) {\n            // UTF-32, big-endian\n            detectedCharset = \"UTF-32BE\";\n            bom = ByteOrderMark.UTF_32_BE;\n        } else if ((b0 == (byte)0xFF && b1 == (byte)0xFE && b2 == (byte)0x00 && b3 == (byte)0x00)) {\n            // UTF-32, little-endian\n            detectedCharset = \"UTF-32LE\";\n            bom = ByteOrderMark.UTF_32_LE;\n        } else if ((b0 == (byte)0xEF && b1 == (byte)0xBB && b2 == (byte)0xBF)) {\n            // UTF-8 BOM\n            detectedCharset = \"UTF-8\";\n            bom = ByteOrderMark.UTF_8;\n            byteData.position(byteData.position() - 1); // unread one (b3)\n        } else if ((b0 == (byte)0xFE && b1 == (byte)0xFF)) {\n            // UTF-16, big-endian\n            detectedCharset = \"UTF-16BE\";\n            bom = ByteOrderMark.UTF_16_BE;\n            byteData.position(byteData.position() - 2); // unread b2, b3\n        } else if ((b0 == (byte)0xFF && b1 == (byte)0xFE)) {\n            // UTF-16, little-endian\n            detectedCharset = \"UTF-16LE\";\n            bom = ByteOrderMark.UTF_16_LE;\n            byteData.position(byteData.position() - 2); // unread b2, b3\n        } else {\n            byteData.reset();\n        }\n    } else if (byteData.remaining() >= 3) {\n        byte b0 = byteData.get();\n        byte b1 = byteData.get();\n        byte b2 = byteData.get();\n        if ((b0 == (byte)0xEF && b1 == (byte)0xBB && b2 == (byte)0xBF)) {\n            detectedCharset = \"UTF-8\";\n            bom = ByteOrderMark.UTF_8;\n        } else {\n            byteData.reset();\n        }\n    } else if (byteData.remaining() >= 2) {\n        byte b0 = byteData.get();\n        byte b1 = byteData.get();\n        if ((b0 == (byte)0xFE && b1 == (byte)0xFF)) {\n            detectedCharset = \"UTF-16BE\";\n            bom = ByteOrderMark.UTF_16_BE;\n        } else if ((b0 == (byte)0xFF && b1 == (byte)0xFE)) {\n            detectedCharset = \"UTF-16LE\";\n            bom = ByteOrderMark.UTF_16_LE;\n        } else {\n            byteData.reset();\n        }\n    } else {\n        byteData.reset();\n    }\n\n    if (detectedCharset != null) {\n        charsetName = detectedCharset;\n    }\n\n    // After BOM detection, ensure to rewind buffer for decode (and skip BOM bytes if present)\n    if (bom != null) {\n        int bomLen = bom.length();\n        byteData.reset();\n        byteData.position(byteData.position() + bomLen);\n    } else {\n        byteData.reset();\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                // skip BOM bytes if present\n                if (bom != null) byteData.position(byteData.position() + bom.length());\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    // Removed check for single character BOM; individual BOM cases are now handled at the start\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\n// Helper enum for BOMs\nprivate enum ByteOrderMark {\n    UTF_8(new byte[]{(byte)0xEF, (byte)0xBB, (byte)0xBF}),\n    UTF_16_BE(new byte[]{(byte)0xFE, (byte)0xFF}),\n    UTF_16_LE(new byte[]{(byte)0xFF, (byte)0xFE}),\n    UTF_32_BE(new byte[]{(byte)0x00, (byte)0x00, (byte)0xFE, (byte)0xFF}),\n    UTF_32_LE(new byte[]{(byte)0xFF, (byte)0xFE, (byte)0x00, (byte)0x00});\n    private final byte[] bytes;\n    ByteOrderMark(byte[] b) { this.bytes = b; }\n    public int length() { return bytes.length; }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}