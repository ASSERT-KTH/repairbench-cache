{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// NOTE: This code block assumes the existence of:\n// - DataUtil.defaultCharset (String, e.g., \"UTF-8\")\n// - DataUtil.UNICODE_BOM (char, '\\uFEFF')\n// - DataUtil.getCharsetFromContentType(String) (method)\n// These are typically defined elsewhere in the org.jsoup.helper.DataUtil class.\n\nclass FixedDataUtil { // Helper class just to provide context for the static method\n\n    // Assume these are defined elsewhere, e.g., in DataUtil\n    private static final String defaultCharset = \"UTF-8\";\n    private static final char UNICODE_BOM = '\\uFEFF';\n    private static String getCharsetFromContentType(String contentType) {\n        // This is a simplified placeholder implementation based on common patterns.\n        // The actual implementation in Jsoup might be more robust.\n        if (contentType == null) return null;\n        String[] params = contentType.toLowerCase().split(\";\");\n        for (String param : params) {\n            param = param.trim();\n            if (param.startsWith(\"charset=\")) {\n                String charset = param.substring(\"charset=\".length());\n                // Remove surrounding quotes if present\n                if (charset.length() > 1 && ((charset.startsWith(\"\\\"\") && charset.endsWith(\"\\\"\")) || (charset.startsWith(\"'\") && charset.endsWith(\"'\")))) {\n                    charset = charset.substring(1, charset.length() - 1);\n                }\n                return charset.trim();\n            }\n        }\n        return null;\n    }\n\n\n    /**\n     * Parses the input ByteBuffer to a Document.\n     * @param byteData ByteBuffer to parse\n     * @param charsetName Character set of file contents, or null to detect automatically.\n     * @param baseUri The URL where the HTML was retrieved from, to resolve relative links against.\n     * @param parser The parser to use.\n     * @return Document\n     */\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData = null;\n        Document doc = null;\n        boolean bomFound = false; // Keep track if BOM determined the charset\n\n        // *** Stage 1: Determine the character set. ***\n        // Handle Byte Order Marks (BOMs) upfront. BOM overrides any specified or detected charset.\n        byteData.mark();\n        byte[] bom = new byte[4];\n        int read = byteData.remaining() >= bom.length ? bom.length : byteData.remaining();\n        byteData.get(bom, 0, read);\n        byteData.reset(); // Reset buffer to original mark for full decode later\n\n        if (read >= 3 && bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            charsetName = \"UTF-8\"; // UTF-8 BOM\n            byteData.position(byteData.position() + 3); // Consume BOM bytes\n            bomFound = true;\n        } else if (read >= 2 && bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) {\n            charsetName = \"UTF-16BE\"; // UTF-16 Big Endian BOM\n            byteData.position(byteData.position() + 2);\n            bomFound = true;\n        } else if (read >= 2 && bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            if (read >= 4 && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) {\n                charsetName = \"UTF-32LE\"; // UTF-32 Little Endian BOM\n                byteData.position(byteData.position() + 4);\n                bomFound = true;\n            } else {\n                charsetName = \"UTF-16LE\"; // UTF-16 Little Endian BOM\n                byteData.position(byteData.position() + 2);\n                bomFound = true;\n            }\n        } else if (read >= 4 && bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) {\n            charsetName = \"UTF-32BE\"; // UTF-32 Big Endian BOM\n            byteData.position(byteData.position() + 4);\n            bomFound = true;\n        }\n        // If no BOM found, charsetName remains as passed in (can be null), and buffer position is unchanged.\n\n        // *** Stage 2: Decode the data using the determined character set. ***\n        if (charsetName == null) { // If no BOM and no explicit charset provided, auto-detect from meta tag\n            // Decode tentatively using the default charset (UTF-8)\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            // Parse the document tentatively to find meta charset tags\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            String foundCharset = null;\n\n            if (meta != null) { // Look for charset information\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        String metaCharset = meta.attr(\"charset\");\n                        if (Charset.isSupported(metaCharset)) {\n                            foundCharset = metaCharset;\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        // ignore invalid charset names specified in meta tag\n                        foundCharset = null;\n                    }\n                }\n            }\n\n            // If a valid different charset is found in the meta tag, re-decode the input.\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                // clean the found charset name\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset; // Update the charset name\n                byteData.rewind(); // Rewind the original byte buffer to the start\n                docData = Charset.forName(charsetName).decode(byteData).toString(); // Decode again with the correct charset\n                doc = null; // Discard the tentatively parsed doc; needs re-parsing\n            } else {\n                // No valid meta charset found, or it's the same as the default.\n                // Stick with the default charset decode. The 'doc' variable already holds the parsed document.\n                // Ensure charsetName is set for output settings later.\n                charsetName = defaultCharset;\n            }\n        } else { // BOM found or charset explicitly specified\n            // We have a charset name (from BOM or explicitly passed in)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString(); // Decode using the known charset\n        }\n\n        // *** Stage 3: Parse the decoded data. ***\n        if (doc == null) {\n            // Parse the document if:\n            // 1. BOM was found (doc was never parsed).\n            // 2. Charset was specified (doc was never parsed).\n            // 3. Auto-detect found a different meta charset and re-decoded (doc was set to null).\n\n            // Check for and strip the Unicode BOM character (U+FEFF) if it remains after decoding.\n            // Some decoders might not consume it (e.g., standard UTF-8 decoder).\n            if (docData != null && docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n                docData = docData.substring(1);\n            }\n\n            // Avoid NPE if docData somehow became null (should not happen with valid charset decoding)\n            if (docData == null) {\n                docData = \"\";\n            }\n\n            doc = parser.parseInput(docData, baseUri);\n        }\n        // else: doc was already parsed successfully during the auto-detect phase using the default charset.\n\n        // *** Stage 4: Set the document's output charset. ***\n        // Ensure the charsetName used for output settings is the final determined one.\n        if (charsetName == null) {\n             // This should only happen if the input charsetName was null, no BOM was found,\n             // and the meta tag search either failed or confirmed the default charset.\n             charsetName = defaultCharset;\n        }\n        doc.outputSettings().charset(charsetName);\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}