{
    "generation": "import org.jsoup.helper.Validate;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\n\n// Assuming 'defaultCharset', 'UNICODE_BOM', and 'getCharsetFromContentType' are defined elsewhere in the class.\n// For the purpose of this fix, we will define them as placeholders if they are not provided in the original context.\n// In Jsoup source, they are static fields/methods within DataUtil.\n\nclass DataUtil { // Assuming DataUtil is the containing class\n    private static final String defaultCharset = \"UTF-8\";\n    private static final char UNICODE_BOM = '\\uFEFF';\n\n    // Placeholder for getCharsetFromContentType, in a real Jsoup context this would be properly implemented.\n    private static String getCharsetFromContentType(String content) {\n        // This is a simplified placeholder. Actual Jsoup implementation is more robust.\n        // Example: content = \"text/html;charset=gb2312\" -> returns \"gb2312\"\n        String[] parts = content.split(\";\");\n        for (String part : parts) {\n            String trimmedPart = part.trim();\n            if (trimmedPart.startsWith(\"charset=\")) {\n                return trimmedPart.substring(\"charset=\".length());\n            }\n        }\n        return null;\n    }\n\n\n    // Helper class to return both charset name and BOM byte length\n    private static class BomResult {\n        String charsetName;\n        int bomBytes;\n\n        BomResult(String charsetName, int bomBytes) {\n            this.charsetName = charsetName;\n            this.bomBytes = bomBytes;\n        }\n    }\n\n    // Helper method to detect BOM and return charset name and BOM byte length.\n    // It does NOT modify the ByteBuffer's position.\n    private static BomResult detectBom(ByteBuffer byteData) {\n        int originalPosition = byteData.position();\n        int remaining = byteData.remaining();\n\n        if (remaining >= 3 && byteData.get(originalPosition) == (byte)0xEF && byteData.get(originalPosition + 1) == (byte)0xBB && byteData.get(originalPosition + 2) == (byte)0xBF) {\n            return new BomResult(\"UTF-8\", 3);\n        } else if (remaining >= 2 && byteData.get(originalPosition) == (byte)0xFE && byteData.get(originalPosition + 1) == (byte)0xFF) {\n            return new BomResult(\"UTF-16BE\", 2);\n        } else if (remaining >= 2 && byteData.get(originalPosition) == (byte)0xFF && byteData.get(originalPosition + 1) == (byte)0xFE) {\n            return new BomResult(\"UTF-16LE\", 2);\n        } else if (remaining >= 4 && byteData.get(originalPosition) == (byte)0x00 && byteData.get(originalPosition + 1) == (byte)0x00 && byteData.get(originalPosition + 2) == (byte)0xFE && byteData.get(originalPosition + 3) == (byte)0xFF) {\n            return new BomResult(\"UTF-32BE\", 4);\n        } else if (remaining >= 4 && byteData.get(originalPosition) == (byte)0xFF && byteData.get(originalPosition + 1) == (byte)0xFE && byteData.get(originalPosition + 2) == (byte)0x00 && byteData.get(originalPosition + 3) == (byte)0x00) {\n            return new BomResult(\"UTF-32LE\", 4);\n        }\n        return new BomResult(null, 0); // No BOM\n    }\n\n\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String bomCharset = null; // Stores charset if detected from BOM\n        int bomBytes = 0; // Stores number of bytes BOM occupies\n\n        // 1. Detect BOM (highest priority for charset determination)\n        BomResult bomResult = detectBom(byteData);\n        if (bomResult.charsetName != null) {\n            bomCharset = bomResult.charsetName;\n            bomBytes = bomResult.bomBytes;\n            // BOM charset overrides any initial charsetName provided by user\n            charsetName = bomCharset;\n        }\n\n        // 2. Determine final charset for decoding and perform initial decode\n        // If charsetName is still null (no BOM detected, and no explicit charset given),\n        // try to determine from meta.\n        if (charsetName == null) {\n            // First pass: decode as defaultCharset (UTF-8) to find meta tag.\n            byteData.rewind(); // Ensure reading from start of the ByteBuffer\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri); // Parse with defaultCharset\n\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                // If a different charset is found in meta, re-decode.\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset; // This is the new effective charset.\n                    byteData.rewind(); // Rewind for re-decoding\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null; // Invalidate current doc, it needs to be parsed again with new charset.\n                } else {\n                    // No meta charset found, or it's defaultCharset.\n                    // doc and docData from default decode are fine.\n                    charsetName = defaultCharset;\n                }\n            } else {\n                // No meta tag found. Keep defaultCharset.\n                charsetName = defaultCharset;\n            }\n        } else { // charsetName was explicitly provided by user OR determined by BOM\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n\n            byteData.rewind(); // Always rewind to start before decoding based on final charset.\n            // If a UTF-16 or UTF-32 BOM was detected, advance position past BOM bytes.\n            // For UTF-8 BOM, we do NOT advance here, as its decoder will produce \\uFEFF character.\n            if (bomCharset != null && !\"UTF-8\".equals(bomCharset)) {\n                byteData.position(byteData.position() + bomBytes);\n            }\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n\n        // 3. Remove UTF-8 BOM character if present in docData\n        // This applies if an UTF-8 BOM was originally detected.\n        // For other BOMs (UTF-16/32), CharsetDecoder already consumes the BOM bytes without producing \\uFEFF.\n        if (\"UTF-8\".equals(bomCharset) && docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            docData = docData.substring(1);\n            doc = null; // Invalidate doc if it was already parsed (e.g., using defaultCharset then BOM was found)\n        }\n\n        // 4. Final parsing step\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n        }\n        // Always set the document's output charset to the determined charsetName.\n        doc.outputSettings().charset(charsetName);\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}