{
    "generation": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String detectedCharset = null;\n\n        // Check for BOM first - this should take precedence over everything\n        byteData.mark();\n        Charset charset = detectCharsetFromBom(byteData);\n        if (charset != null) {\n            charsetName = charset.name();\n            byteData.reset();\n        } else {\n            byteData.reset();\n        }\n\n        if (charsetName == null) {\n            // If no charset specified and no BOM found, try to detect from meta tag\n            // First try reading as UTF-8 (default)\n            byteData.mark();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.reset();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n            byteData.reset(); // Reset in case we need to read again\n        } else {\n            // Specified by content type header or by user on file load\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n\n        // Now actually decode with the determined (or specified) charset\n        if (docData == null || doc == null) {\n            byteData.reset();\n            docData = Charset.forName(charsetName != null ? charsetName : defaultCharset).decode(byteData).toString();\n        }\n\n        // Remove BOM if present in the decoded text\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            docData = docData.substring(1);\n        }\n\n        // Parse the document if we haven't yet\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName != null ? charsetName : defaultCharset);\n        } else {\n            doc.outputSettings().charset(charsetName != null ? charsetName : defaultCharset);\n        }\n\n        return doc;\n    }\n\n    private static Charset detectCharsetFromBom(ByteBuffer byteData) {\n        byteData.mark();\n        try {\n            byte[] bom = new byte[4];\n            int length = Math.min(byteData.remaining(), 4);\n            byteData.get(bom, 0, length);\n\n            // Check for UTF-8 BOM (EF BB BF)\n            if (length >= 3 && (bom[0] & 0xFF) == 0xEF && (bom[1] & 0xFF) == 0xBB && (bom[2] & 0xFF) == 0xBF) {\n                return StandardCharsets.UTF_8;\n            }\n            // Check for UTF-16BE BOM (FE FF)\n            if (length >= 2 && (bom[0] & 0xFF) == 0xFE && (bom[1] & 0xFF) == 0xFF) {\n                return StandardCharsets.UTF_16BE;\n            }\n            // Check for UTF-16LE BOM (FF FE)\n            if (length >= 2 && (bom[0] & 0xFF) == 0xFF && (bom[1] & 0xFF) == 0xFE) {\n                return StandardCharsets.UTF_16LE;\n            }\n            // Check for UTF-32BE BOM (00 00 FE FF)\n            if (length >= 4 && (bom[0] & 0xFF) == 0x00 && (bom[1] & 0xFF) == 0x00 &&\n                (bom[2] & 0xFF) == 0xFE && (bom[3] & 0xFF) == 0xFF) {\n                return Chomsets.UTF_32BE;\n            }\n            // Check for UTF-32LE BOM (FF FE 00 00)\n            if (length >= 4 && (bom[0] & 0xFF) == 0xFF && (bom[1] & 0xFF) == 0xFE &&\n                (bom[2] & 0xFF) == 0x00 && (bom[3] & 0xFF) == 0x00) {\n                return Chomsets.UTF_32LE;\n            }\n        } finally {\n            byteData.reset();\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}