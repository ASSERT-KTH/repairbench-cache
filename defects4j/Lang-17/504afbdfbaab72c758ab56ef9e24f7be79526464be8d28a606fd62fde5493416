{
    "generation": "    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is\n     * tightly coupled with the abstract method of this class.\n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0; // Character index\n        int len = input.length(); // Character length\n        while (pos < len) {\n            // Call the abstract translate method which should handle consuming code points\n            int consumed = translate(input, pos, out);\n\n            // If consumed is 0, the code point at 'pos' was not translated and should be copied verbatim\n            if (consumed == 0) {\n                // Get the code point starting at the current character index 'pos'.\n                // Character.codePointAt handles surrogate pairs correctly.\n                int codepoint = Character.codePointAt(input, pos);\n                // Write the character(s) for this code point to the output.\n                out.write(Character.toChars(codepoint));\n                // Advance the character index by the number of chars used by the code point (1 for BMP, 2 for surrogate pair).\n                pos += Character.charCount(codepoint);\n            }\n            // If consumed is > 0, the translator handled writing the translation for 'consumed' code points.\n            // We need to advance 'pos' by the number of characters corresponding to these consumed code points.\n            else {\n                // The contract is that 'translate' consumes 'consumed' number of code points starting at 'pos'.\n                // Advance 'pos' past these code points by examining each one.\n                for (int i = 0; i < consumed; i++) {\n                    // Check we don't go past the input length - needed for potentially malformed input\n                    // handled by the translator or incorrect 'consumed' value.\n                    if (pos < len) {\n                        // Determine the number of chars for the code point at the current position.\n                        int codepoint = Character.codePointAt(input, pos);\n                        // Advance position by the number of chars for this code point.\n                        pos += Character.charCount(codepoint);\n                    } else {\n                        // Should ideally not happen with valid input and correct translator implementation.\n                        // Break defensively to avoid issues. The outer loop condition will terminate.\n                        break;\n                    }\n                }\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}