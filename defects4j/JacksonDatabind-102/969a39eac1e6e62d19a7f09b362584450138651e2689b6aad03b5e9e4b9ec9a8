{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // NOTE: we can NOT use method like `findFormatOverrides` or `findFormatFeature`\n        // because we need to handle both property annotations and config overrides,\n        // and combination of possible sources\n        // 29-Sep-2018, tatu: Need to use a method that is properly wired and Maestrov\n        //    knows how to use, findFormatOverrides() is not it.\n//        JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n\n        // First: check features defined via property annotations, if any\n        final AnnotationIntrospector intr = serializers.getAnnotationIntrospector();\n        final AnnotatedMember member = (property == null) ? null : property.getMember();\n        JsonFormat.Value format = null;\n\n        if (member != null) {\n            format = intr.findFormat((Annotated) member);\n        }\n\n        // Second: consider global default format for type (if any)\n        if (format == null) {\n             format = serializers.getConfig().getDefaultPropertyFormat(_handledType);\n        }\n\n        // Third: apply per-type default format settings (NOTE: necessary here?)\n        // (NOTE: could perhaps remove this part?)\n        if (format == null) {\n            // nothing from individual property, nor defaults: apply per-type settings from\n            // `ObjectMapper.configOverride(handledType)`?\n            // 29-Sep-2018, tatu: Yes, needed for [databind#2064]\n            format = serializers.getConfig().getConfigOverride(_handledType).getFormat();\n        }\n\n        if (format == null) {\n            // No overrides, use base serializer unchanged\n            return this;\n        }\n\n        // Simple case first: serialize as numeric timestamp?\n        JsonFormat.Shape shape = format.getShape();\n        if (shape.isNumeric()) {\n            // If serializer needs to change to numeric format\n            return withFormat(Boolean.TRUE, null);\n        }\n\n        // If pattern provided, it determines specific format:\n        if (format.hasPattern()) {\n            final Locale loc = format.hasLocale()\n                            ? format.getLocale()\n                            : serializers.getLocale();\n            SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n\n            TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone();\n            df.setTimeZone(tz);\n            // Regardless of base serializer format, need to use this specific format\n            return withFormat(Boolean.FALSE, df);\n        }\n\n        // Otherwise, check for changes in Locale, TimeZone, or explicit String shape\n        final boolean hasLocale = format.hasLocale();\n        final boolean hasTZ = format.hasTimeZone();\n        // Note: Shape is relevant if base type's default is numeric, AND shape is STRING/SCALAR\n        final boolean asString = (shape == JsonFormat.Shape.STRING || shape == JsonFormat.Shape.SCALAR);\n\n        // If nothing indicates a change that requires custom format...\n        // except we must ensure format is not numeric (already checked)\n        if (!hasLocale && !hasTZ && !asString) {\n            return this;\n        }\n\n        // Need to apply String format with possible Locale/TimeZone customization\n\n        // Get the default DateFormat from configuration\n        DateFormat df0 = serializers.getConfig().getDateFormat();\n\n        // If default is Jackson's StdDateFormat, it's easy to configure\n        if (df0 instanceof StdDateFormat) {\n            StdDateFormat std = (StdDateFormat) df0;\n\n            // Determine target locale\n            if (hasLocale) {\n                std = std.withLocale(format.getLocale());\n            } else {\n                // Otherwise ensure serializer context default used\n                std = std.withLocale(serializers.getLocale());\n            }\n\n            // Determine target timezone\n            TimeZone tz;\n            if (hasTZ) {\n                 tz = format.getTimeZone();\n            } else {\n                 tz = serializers.getTimeZone();\n            }\n            std = std.withTimeZone(tz);\n            return withFormat(Boolean.FALSE, std);\n        }\n\n        // If not StdDateFormat, require SimpleDateFormat for customization\n        if (!(df0 instanceof SimpleDateFormat)) {\n            // 28-Sep-2018, tatu: Let's verify this is close enough to fail...\n            if (df0 == null) {\n                 // Cannot apply Locale/TimeZone overrides without a base format\n                 serializers.reportBadDefinition(handledType(),\n                      \"Cannot apply configuration overrides for Locale/TimeZone when no default DateFormat configured\");\n            } else {\n                serializers.reportBadDefinition(handledType(), String.format(\n                        \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\n                        df0.getClass().getName()));\n            }\n            // Cannot configure, return 'this' (potentially incorrect if 'this' is numeric)\n            return this;\n        }\n\n        // It's a SimpleDateFormat: clone or recreate to apply changes\n        SimpleDateFormat df = (SimpleDateFormat) df0;\n\n        // Determine target Locale (note: seconds-from-epoch does not use Locale)\n        Locale newLocale = hasLocale ? format.getLocale() : serializers.getLocale();\n        if (!newLocale.equals(df.getLocale())) {\n            // Ugh. No way to change `Locale`, create copy; must re-create completely:\n            df = new SimpleDateFormat(df.toPattern(), newLocale);\n            // TimeZone gets reset, must re-set below:\n        } else {\n            // If locale did not change, clone to avoid modifying shared instance\n            df = (SimpleDateFormat) df.clone();\n        }\n\n        // Determine target TimeZone\n        TimeZone newTz = hasTZ ? format.getTimeZone() : serializers.getTimeZone();\n        if (newTz != null && !newTz.equals(df.getTimeZone())) {\n            df.setTimeZone(newTz);\n        }\n        return withFormat(Boolean.FALSE, df);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}