{
    "generation": "            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) { // (A) This check comes first\n                return withFormat(Boolean.TRUE, null);\n            }\n            // ...\n            if (format.hasPattern()) { // (B) This check comes second\n                // ... create SimpleDateFormat and return withFormat(Boolean.FALSE, df);\n            }\n    ```\n    If `JsonFormat.Value` from `configOverride` has `_shape = ANY` (because `forPattern` doesn't set it to `STRING`) but implicitly resolves to `NUMBER` due to internal merging with `java.sql.Date`'s default numeric behavior, then `shape.isNumeric()` (A) evaluates to `true`. This leads to the serializer being configured to output a numeric timestamp (`Boolean.TRUE`). The subsequent check `format.hasPattern()` (B), which would correctly set up a string format, is never reached.\n\n**The Fix:**\nThe fix involves reordering the checks within `createContextual` to prioritize an explicit pattern. If a pattern is present, it's a strong indicator that the user wants a string representation, regardless of any default numeric shape. By checking `format.hasPattern()` *before* `shape.isNumeric()`, we ensure that the pattern-based string serialization logic is applied when a pattern is specified.\n\nThis ensures that if a format override provides a pattern, it correctly takes precedence, and the date is serialized as a formatted string rather than a timestamp.\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}