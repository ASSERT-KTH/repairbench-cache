{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    \n    // Tracks if the immediately preceding element in the *original array* was an immutable value\n    // (including empty strings). This is used to correctly insert joinString between elements\n    // and to decide whether to add an empty string node to arrayFoldedChildren if it was folded.\n    boolean hasPrevImmutable = false; \n\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (hasPrevImmutable) {\n          // If the previous element was immutable, append the joinString as a separator.\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n        hasPrevImmutable = true;\n      } else {\n        // Current element is not an immutable value.\n        // Dump any accumulated string segment in sb to arrayFoldedChildren.\n        if (sb.length() > 0) { // If sb has any non-empty content\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n        } else if (hasPrevImmutable) { // sb is empty, but it accumulated 'empty string' from previous immutable(s)\n                                      // (e.g., from ['','foo']), so it should be represented as an empty string node.\n          arrayFoldedChildren.add(Node.newString(\"\"));\n        }\n        sb = new StringBuilder(); // Reset sb for the next segment\n        hasPrevImmutable = false; // Reset, as we just processed a non-immutable element.\n        \n        // Add the non-immutable node itself.\n        arrayFoldedChildren.add(elem);\n      }\n      elem = elem.getNext();\n    }\n\n    // Dump any remaining string segment after the loop.\n    if (sb.length() > 0) { // If sb has any non-empty content\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    } else if (hasPrevImmutable) { // sb is empty, but it accumulated 'empty string' from previous immutable(s)\n        arrayFoldedChildren.add(Node.newString(\"\"));\n    }\n    \n    // Original size of the expression to compare against for cost-benefit analysis.\n    int originalSize = InlineCostEstimator.getCost(n);\n\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // Case: [].join(...) -> \"\"\n        Node emptyStringNode = Node.newString(\"\");\n        if (InlineCostEstimator.getCost(emptyStringNode) > originalSize) {\n          return;\n        }\n        parent.replaceChild(n, emptyStringNode);\n        break;\n\n      case 1:\n        // Case: ['a'].join(',') -> \"a\" or ['', foo].join(',') -> \",foo\"\n        Node foldedStringNode = arrayFoldedChildren.get(0);\n        Node replacementNode = foldedStringNode;\n        boolean replacementCreated = false; // Flag to know if a new node was created\n\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that it is coerced to a string.\n          // This handles cases like [5].join('') -> \"5\" or [true].join('') -> \"true\".\n          // It also handles [foo].join('') -> \"\"+foo initially.\n          replacementNode = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n          replacementCreated = true;\n        }\n\n        // Special handling for cases like ['', foo].join(',') which should become \",foo\"\n        // or [foo, ''].join(',') which should become \"foo,\".\n        // This applies when the original array had more than one element,\n        // and after folding, only one non-string element remains,\n        // and the original array started/ended with an empty string.\n        if (arrayNode.getChildCount() > 1 && !joinString.isEmpty()) {\n            boolean firstElementEmpty = NodeUtil.isEmptyString(arrayNode.getFirstChild());\n            boolean lastElementEmpty = NodeUtil.isEmptyString(arrayNode.getLastChild());\n\n            if (firstElementEmpty && !lastElementEmpty) {\n                // Example: ['', foo].join(',') should be ',foo'\n                // This scenario means the arrayFoldedChildren contained only 'foo' (or similar).\n                // The leading empty string from the original array implies a leading joinString.\n                Node newStringPrefix = Node.newString(joinString);\n                if (replacementCreated || replacementNode.getType() != Token.STRING) {\n                    // If it's already an ADD node or a non-string node, use ADD operation.\n                    replacementNode = new Node(Token.ADD, newStringPrefix, replacementNode);\n                } else { \n                    // If it's a simple string literal, concatenate.\n                    replacementNode = Node.newString(newStringPrefix.getString() + replacementNode.getString());\n                }\n                replacementCreated = true; // A new replacementNode was created\n            } else if (lastElementEmpty && !firstElementEmpty) {\n                // Example: [foo, ''].join(',') should be 'foo,'\n                // The trailing empty string from the original array implies a trailing joinString.\n                Node newStringSuffix = Node.newString(joinString);\n                if (replacementCreated || replacementNode.getType() != Token.STRING) {\n                    replacementNode = new Node(Token.ADD, replacementNode, newStringSuffix);\n                } else {\n                    replacementNode = Node.newString(replacementNode.getString() + newStringSuffix.getString());\n                }\n                replacementCreated = true; // A new replacementNode was created\n            }\n        }\n\n        // Compare the cost of the final replacementNode with the original expression.\n        if (InlineCostEstimator.getCost(replacementNode) > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren(); // Original array children are no longer needed\n        parent.replaceChild(n, replacementNode);\n        break;\n\n      default:\n        // No full folding could actually be performed, but partial folding happened.\n        // Rebuild the arrayNode with folded children, then let the original .join() remain.\n        // Only proceed if there's a cost win.\n        \n        // Create a temporary node to calculate the cost of the proposed new structure.\n        Node newArrayNode = new Node(Token.ARRAYLIT); \n        for (Node node : arrayFoldedChildren) {\n          newArrayNode.addChildToBack(node.cloneNode()); // Clone children for cost estimation\n        }\n        \n        // The new expression is `newArrayNode.join(right)`.\n        Node newJoinCall = new Node(Token.CALL, \n                                    new Node(Token.GETPROP, newArrayNode, functionName.cloneNode()), \n                                    right.cloneNode());\n        \n        // If the arrayFoldedChildren is identical in size to original children, it means no\n        // folding (merging of string literals) actually happened within the array elements.\n        // So, no change should be reported unless the cost is strictly lower.\n        // The `InlineCostEstimator` will handle if there's a cost reduction from the change.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n             // If number of elements is the same, no folding happened within the array.\n             // We should only proceed if the cost is *strictly* lower, otherwise return.\n             // This implicitly means `getCost(newJoinCall) < originalSize` as a stricter condition.\n             if (InlineCostEstimator.getCost(newJoinCall) >= originalSize) {\n                return;\n             }\n        } else {\n            // Some folding happened (size changed), so we check if the cost is better.\n            if (InlineCostEstimator.getCost(newJoinCall) > originalSize) {\n                return;\n            }\n        }\n\n        // If folding is profitable, modify the original arrayNode's children.\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        // In this case, 'n' (the CALL node) itself is not replaced,\n        // only its array literal child is modified.\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}