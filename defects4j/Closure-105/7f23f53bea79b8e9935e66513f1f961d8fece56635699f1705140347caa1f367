{
    "generation": "import com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.List;\n\n// Stub classes to make the function compilable standalone\n// Assume NodeUtil, InlineCostEstimator, Compiler, etc. exist and work as expected.\n/*\nclass NodeUtil {\n  static boolean isGetProp(Node n) { return n != null && n.isGetProp(); }\n  static boolean isImmutableValue(Node n) { return n != null && (n.isString() || n.isNumber() || n.isBoolean() || n.isNull() || n.isVoid()); }\n  static String getStringValue(Node n) { return com.google.javascript.rhino.NodeUtil.getStringValue(n); }\n}\nclass InlineCostEstimator { static int getCost(Node n) { return 1; } } // Dummy cost\nclass Compiler { public void reportCodeChange() {} }\nclass NodeTraversal { public Compiler getCompiler() { return new Compiler(); } }\n*/\n\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    // Check structure: CALL(GETPROP(ARRAYLIT, 'join'), separator)\n    if (!NodeUtil.isGetProp(left)) {\n      return;\n    }\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    // Function name should be 'join'\n    if (arrayNode.getType() != Token.ARRAYLIT ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    // Determine separator string (handle undefined, null)\n    // We require an immutable separator for folding, undefined is treated as \",\".\n    if (!NodeUtil.isImmutableValue(right) && !right.isUndefined()) {\n        return; // Cannot fold non-constant separator\n    }\n    String joinString = \",\"; // Default for undefined separator\n    if (!right.isUndefined()) {\n        // NodeUtil.getStringValue handles null -> \"null\", numbers, booleans, strings correctly\n        joinString = NodeUtil.getStringValue(right);\n    }\n\n    // --- Loop to build folded array elements ---\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    // Stores current string segment being folded. Null means segment hasn't started.\n    StringBuilder sb = null;\n    Node elem = arrayNode.getFirstChild();\n\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (sb == null) {\n           sb = new StringBuilder(); // Start the segment\n           sb.append(NodeUtil.getStringValue(elem));\n        } else {\n           // Segment already started, always add separator then value\n           sb.append(joinString);\n           sb.append(NodeUtil.getStringValue(elem));\n        }\n      } else {\n        // Non-immutable element: finalize previous string segment (if any)\n        if (sb != null) {\n             Node newStringNode = Node.newString(sb.toString());\n             // Use the call node 'n' source info for the new string node.\n             newStringNode.copyInformationFrom(n);\n             arrayFoldedChildren.add(newStringNode);\n             sb = null; // Reset segment\n        }\n        // Add the non-immutable element (cloned, as it might be used elsewhere\n        // if the fold is ultimately aborted).\n        arrayFoldedChildren.add(elem.cloneTree());\n      }\n      elem = elem.getNext();\n    }\n\n    // After loop: Add the final string segment if it exists\n    if (sb != null) {\n        Node newStringNode = Node.newString(sb.toString());\n        newStringNode.copyInformationFrom(n); // Use call node source info\n        arrayFoldedChildren.add(newStringNode);\n    }\n\n    // --- Cost Calculation & Replacement ---\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node replacement = null;\n    int newSize = -1;\n\n    switch (arrayFoldedChildren.size()) {\n      case 0: // Original array was empty []\n        // Should only happen if original arrayNode had no children.\n        if (!arrayNode.hasChildren()) {\n             replacement = Node.newString(\"\");\n             // Copy source info onto the new node\n             replacement.copyInformationFrom(n);\n             newSize = InlineCostEstimator.getCost(replacement);\n        } else {\n             // Logic error if this happens (e.g. ['',''] should result in size 1), bail out.\n             return;\n        }\n        break; // Go to replacement logic below\n\n      case 1:\n        // Single element result, which might be a string or non-string\n        Node foldedNode = arrayFoldedChildren.get(0);\n        if (foldedNode.getType() != Token.STRING) {\n           // Coerce to string using \"\" + node\n           // Ensure the ADD node and its children get source info from the original call.\n           Node emptyString = Node.newString(\"\");\n           emptyString.copyInformationFrom(n); // Copy source info to the empty string node\n           replacement = new Node(Token.ADD, emptyString, foldedNode);\n           replacement.copyInformationFromForTree(n);\n        } else {\n           // It's already a string literal\n           replacement = foldedNode;\n           // Ensure string node has source info from original call.\n           replacement.copyInformationFrom(n);\n        }\n        newSize = InlineCostEstimator.getCost(replacement);\n        break; // Go to replacement logic below\n\n      default: // size > 1, potential partial fold (replace array children)\n        // Check if any real change happened. Comparing size is a good heuristic.\n        // If size is the same, assume no benefit to avoid potential infinite loops.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n           // TODO(johnlenz): Add stronger check comparing elements if necessary.\n           return;\n        }\n\n        // Estimate cost of the new join expression:\n        // Cost of new array lit + cost of .join() prop + call overhead + cost of separator\n        int newArraySize = 2; // for []\n        for (int i = 0; i < arrayFoldedChildren.size(); i++) {\n            newArraySize += InlineCostEstimator.getCost(arrayFoldedChildren.get(i));\n            if (i > 0) {\n                newArraySize++; // Comma cost estimate\n            }\n        }\n\n        // Cost of \".join()\" operation itself\n        // Estimate as cost of GETPROP node + call overhead ()\n        int joinOverheadCost = InlineCostEstimator.getCost(left) + 2;\n        int separatorCost = InlineCostEstimator.getCost(right);\n        int estimatedNewSize = newArraySize + joinOverheadCost + separatorCost;\n\n\n        // Compare estimated cost of modified tree vs original\n        if (estimatedNewSize > originalSize) {\n          return; // Estimated new cost is higher\n        }\n\n        // Perform the modification: replace children of original arrayNode\n        // We modify the existing GETPROP/CALL structure, only changing the array literal.\n        arrayNode.detachChildren();\n        for (Node newNode : arrayFoldedChildren) {\n          // Nodes in list are either new strings or clones of non-immutables.\n          arrayNode.addChildToBack(newNode);\n        }\n        // The overall CALL node 'n' remains the root of this expression.\n        // Mark that the AST has been changed.\n        t.getCompiler().reportCodeChange();\n        return; // Modification done in place.\n    }\n\n    // Common replacement logic for case 0 and case 1 (complete folding)\n    if (replacement != null) {\n        // Ensure the calculated cost is not larger than original.\n        if (newSize <= originalSize) {\n            parent.replaceChild(n, replacement);\n            t.getCompiler().reportCodeChange();\n        }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}