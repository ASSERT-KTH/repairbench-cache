{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n    if (arrayNode.getType() != Token.ARRAYLIT\n        || !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    int runCount = 0;\n    int foldedSize = 0;\n\n    // Merge runs of immutable values (strings, numbers, booleans) into one literal.\n    for (Node elem = arrayNode.getFirstChild(); elem != null; elem = elem.getNext()) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        String value = NodeUtil.getStringValue(elem);\n        if (runCount > 0) {\n          sb.append(joinString);\n        }\n        sb.append(value);\n        runCount++;\n      } else {\n        if (runCount > 0) {\n          String merged = sb.toString();\n          // +2 for the surrounding quotes.\n          foldedSize += merged.length() + 2;\n          arrayFoldedChildren.add(Node.newString(merged));\n          sb.setLength(0);\n          runCount = 0;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n    }\n    if (runCount > 0) {\n      String merged = sb.toString();\n      foldedSize += merged.length() + 2;\n      arrayFoldedChildren.add(Node.newString(merged));\n    }\n    // Account for commas in an array literal.\n    foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // [] -> \"\"\n        parent.replaceChild(n, Node.newString(\"\"));\n        break;\n\n      case 1:\n        // [x] -> \"x\", only if it's a literal string\n        Node only = arrayFoldedChildren.get(0);\n        if (only.getType() != Token.STRING) {\n          return;\n        }\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        parent.replaceChild(n, only);\n        break;\n\n      default:\n        // Partially folded: rebuild the array literal if we actually changed it.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return;\n        }\n        // Cost of \"[]\\.join()\" plus the argument.\n        int joinOverhead = \"[].join()\".length();\n        foldedSize += joinOverhead;\n        foldedSize += InlineCostEstimator.getCost(right);\n        if (foldedSize > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren();\n        for (Node newChild : arrayFoldedChildren) {\n          arrayNode.addChildToBack(newChild);\n        }\n        break;\n    }\n\n    t.getCompiler().reportCodeChange();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}