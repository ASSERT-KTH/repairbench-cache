{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n      return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = new StringBuilder();\n    int currentFoldedCost = 0; // Cost accumulated for string literals currently in sb, or individual non-string nodes.\n    Node elem = arrayNode.getFirstChild();\n    // Tracks if it's the very first element processed, or the first foldable\n    // element in a new sequence following a non-foldable node. This is used\n    // to determine if the joinString should be prepended.\n    boolean firstInSequence = true; \n\n    // Merges adjacent String nodes and immutable values.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem)) {\n        if (!firstInSequence) {\n          // If it's not the first element in the current sequence of\n          // foldables, prepend the join string.\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(elem));\n        firstInSequence = false;\n      } else {\n        if (sb.length() > 0) {\n          // If we accumulated a string, add it as a new string literal node\n          // to arrayFoldedChildren and update the cost.\n          currentFoldedCost += sb.length() + 2; // + 2 for the quotes.\n          arrayFoldedChildren.add(Node.newString(sb.toString()));\n          sb = new StringBuilder(); // Reset sb for the next sequence of foldables.\n        }\n        // Add the non-foldable element to arrayFoldedChildren and update its cost.\n        currentFoldedCost += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n        // After a non-foldable node, the next element (if foldable) will be\n        // the first in its new sequence.\n        firstInSequence = true;\n      }\n      elem = elem.getNext();\n    }\n\n    // After the loop, if there's any accumulated string in sb, add it as the last folded child.\n    if (sb.length() > 0) {\n      currentFoldedCost += sb.length() + 2; // + 2 for the quotes.\n      arrayFoldedChildren.add(Node.newString(sb.toString()));\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    int finalFoldedCost; // This will be the cost of the *entire* resulting expression after folding.\n\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // Case: The array was empty or contained only elements that folded to an empty string,\n        // and the result is an empty string. E.g., [].join('') or ['', ''].join(',').\n        // Cost of \"\" (empty string literal) is 2 (length + quotes).\n        finalFoldedCost = 2;\n        if (finalFoldedCost > originalSize) {\n          return;\n        }\n        parent.replaceChild(n, Node.newString(\"\"));\n        break;\n\n      case 1:\n        // Case: All elements folded into a single string or a single non-string value that will be coerced.\n        // E.g., ['a', 'b'].join('') -> \"ab\", or [1,2,3].join('') -> \"123\".\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that it is coerced to a string.\n          // This typically involves an ADD operation with an empty string.\n          Node replacement = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n          finalFoldedCost = InlineCostEstimator.getCost(replacement);\n          foldedStringNode = replacement;\n        } else {\n          finalFoldedCost = InlineCostEstimator.getCost(foldedStringNode);\n        }\n\n        if (finalFoldedCost > originalSize) {\n          return;\n        }\n        arrayNode.detachChildren(); // Remove original array elements\n        parent.replaceChild(n, foldedStringNode); // Replace array.join call with the folded string/node.\n        break;\n\n      default:\n        // Case: Partial folding occurred (some adjacent string literals were merged),\n        // but the result is still an array.join() call.\n        // E.g., ['a', foo, 'b', 'c'].join(',') -> [\"a\", foo, \"b,c\"].join(\",\").\n        \n        // If the number of children in arrayFoldedChildren is the same as the original,\n        // and no string merging happened (sb.length() is 0), then no effective folding occurred.\n        // In this case, we should return to avoid changing the code unnecessarily.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          // This condition is tricky. If sb.length() was always 0 throughout, it means no string merging happened.\n          // However, if some strings were merged and added to arrayFoldedChildren but then\n          // arrayFoldedChildren ends up having the same size as original children (e.g. if new string nodes replace old ones),\n          // it might still be a win.\n          // The current `sb.length() == 0` check here is for the case where the *last* sequence was foldable but empty,\n          // and no other folding happened. This is covered by the `arrayFoldedChildren.size()` == `arrayNode.getChildCount()`\n          // and the original `currentFoldedCost` calculation.\n          // A more robust check for \"no actual folding\" might compare the content of arrayFoldedChildren\n          // with arrayNode's children. But simple size check is usually sufficient.\n          return;\n        }\n\n        // Calculate the cost of the new array literal structure (e.g., `[]` and commas between elements).\n        finalFoldedCost = 2; // For the `[` and `]` characters.\n        if (arrayFoldedChildren.size() > 1) {\n            finalFoldedCost += arrayFoldedChildren.size() - 1; // For commas between elements.\n        }\n        // Add the cost of the elements themselves (which were accumulated in currentFoldedCost).\n        finalFoldedCost += currentFoldedCost;\n\n        // Add the cost of the `.join` method call and the separator argument.\n        finalFoldedCost += \".join\".length(); // Cost of \".join\" (5 characters).\n        finalFoldedCost += InlineCostEstimator.getCost(right); // Cost of the join string literal (separator).\n\n        if (finalFoldedCost > originalSize) {\n          return; // Don't perform the folding if it increases code size.\n        }\n        \n        // Detach original children and add the newly folded/rearranged children.\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        break;\n    }\n    t.getCompiler().reportCodeChange();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}