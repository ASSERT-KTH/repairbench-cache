{
    "generation": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n                         Node parent) {\n  // Only operate on calls of the form ARRAYLIT.join(...).\n  if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n    return;\n  }\n  Node arrayNode = left.getFirstChild();\n  Node functionName = arrayNode.getNext();\n  if (arrayNode.getType() != Token.ARRAYLIT ||\n      !functionName.getString().equals(\"join\")) {\n    return;\n  }\n  String joinString = NodeUtil.getStringValue(right);\n  int originalSize = InlineCostEstimator.getCost(n);\n  int kJoinOverhead = \"[].join()\".length();\n\n  // First, figure out whether every child in the array literal is immutable.\n  boolean allImmutable = true;\n  int originalChildCount = 0;\n  for (Node elem = arrayNode.getFirstChild(); elem != null; elem = elem.getNext()) {\n    originalChildCount++;\n    if (!NodeUtil.isImmutableValue(elem)) {\n      allImmutable = false;\n    }\n  }\n\n  // --- ALL children are immutable ---\n  if (allImmutable) {\n    // Build the list of constant string values.\n    List<String> values = new ArrayList<>();\n    for (Node elem = arrayNode.getFirstChild(); elem != null; elem = elem.getNext()) {\n      values.add(NodeUtil.getStringValue(elem));\n    }\n    // If there are no elements, replace the whole call with \"\".\n    if (originalChildCount == 0) {\n      Node emptyStringNode = Node.newString(\"\");\n      parent.replaceChild(n, emptyStringNode);\n      t.getCompiler().reportCodeChange();\n      return;\n    }\n    // For a single element, we can replace the join call with that element.\n    if (originalChildCount == 1) {\n      String val = values.get(0);\n      int candidateCost = val.length() + 2; // string literal cost (with quotes)\n      if (candidateCost > originalSize) {\n        return;\n      }\n      Node foldedStringNode = Node.newString(val);\n      if (foldedStringNode.getType() != Token.STRING) {\n        foldedStringNode = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n      }\n      parent.replaceChild(n, foldedStringNode);\n      t.getCompiler().reportCodeChange();\n      return;\n    }\n    // For multiple constants we now have two alternatives:\n    // Option A (\"merge all\"): Join all the values into one constant.\n    // Option B (\"keep separate\"): Normalize each constant individually.\n    StringBuilder mergedBuilder = new StringBuilder();\n    for (int i = 0; i < values.size(); i++) {\n      if (i > 0) {\n        mergedBuilder.append(joinString);\n      }\n      mergedBuilder.append(values.get(i));\n    }\n    String mergedAll = mergedBuilder.toString();\n    int mergedCost = mergedAll.length() + 2;\n    // Compute total cost if we just replaced each constant by a normalized literal.\n    int separateCost = 0;\n    for (String s : values) {\n      separateCost += s.length() + 2;\n    }\n    // When putting several literals in an array, there will be a comma between each.\n    separateCost += (values.size() - 1);\n    \n    // For example, ['a','b','c'].join('') merges to \"abc\" (cost 5) which is lower than\n    // keeping them separate (3+3+3+2 = 11). But if the join separator is long then merging\n    // might be a net *increase* (e.g. ['a','5','c'].join('a very very very long chain')).\n    if (mergedCost < separateCost) {\n      // Merged option (mode 1): Replace the whole join call with the constant.\n      if (mergedCost >= originalSize) {\n        return;\n      }\n      Node foldedStringNode = Node.newString(mergedAll);\n      if (foldedStringNode.getType() != Token.STRING) {\n        foldedStringNode = new Node(Token.ADD, Node.newString(\"\"), foldedStringNode);\n      }\n      parent.replaceChild(n, foldedStringNode);\n      t.getCompiler().reportCodeChange();\n    } else {\n      // Separate option (mode 2): Only normalize the array literal.\n      List<Node> newChildren = new ArrayList<>();\n      for (String s : values) {\n        newChildren.add(Node.newString(s));\n      }\n      int newChildrenCost = 0;\n      for (Node child : newChildren) {\n        newChildrenCost += child.getString().length() + 2;\n      }\n      newChildrenCost += (newChildren.size() - 1);\n      int foldedCost = newChildrenCost + kJoinOverhead + InlineCostEstimator.getCost(right);\n      if (foldedCost > originalSize) {\n        return;\n      }\n      arrayNode.detachChildren();\n      for (Node child : newChildren) {\n        arrayNode.addChildToBack(child);\n      }\n      t.getCompiler().reportCodeChange();\n    }\n    return;\n  }\n\n  // --- Mixed array (some immutable, some not) ---\n  // Group adjacent immutable nodes and decide for each group whether to merge them.\n  List<Node> newChildren = new LinkedList<>();\n  boolean didMergeGroup = false;\n  List<Node> group = new ArrayList<>();\n  for (Node elem = arrayNode.getFirstChild(); elem != null; elem = elem.getNext()) {\n    if (NodeUtil.isImmutableValue(elem)) {\n      // Always add to the current group\u2014even if the constant is \"\".\n      group.add(elem);\n    } else {\n      // Flush any pending group.\n      if (!group.isEmpty()) {\n        if (group.size() > 1) {\n          StringBuilder sb = new StringBuilder();\n          for (int i = 0; i < group.size(); i++) {\n            if (i > 0) {\n              sb.append(joinString);\n            }\n            sb.append(NodeUtil.getStringValue(group.get(i)));\n          }\n          int mergedCost = sb.length() + 2;\n          int separateCost = 0;\n          for (Node g : group) {\n            separateCost += NodeUtil.getStringValue(g).length() + 2;\n          }\n          separateCost += (group.size() - 1);\n          if (mergedCost < separateCost) {\n            newChildren.add(Node.newString(sb.toString()));\n            didMergeGroup = true;\n          } else {\n            for (Node g : group) {\n              newChildren.add(Node.newString(NodeUtil.getStringValue(g)));\n            }\n          }\n        } else {\n          newChildren.add(Node.newString(NodeUtil.getStringValue(group.get(0))));\n        }\n        group.clear();\n      }\n      // Add the non-immutable node as\u2013is.\n      newChildren.add(elem);\n    }\n  }\n  // Flush any remaining group.\n  if (!group.isEmpty()) {\n    if (group.size() > 1) {\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < group.size(); i++) {\n        if (i > 0) {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getStringValue(group.get(i)));\n      }\n      int mergedCost = sb.length() + 2;\n      int separateCost = 0;\n      for (Node g : group) {\n        separateCost += NodeUtil.getStringValue(g).length() + 2;\n      }\n      separateCost += (group.size() - 1);\n      if (mergedCost < separateCost) {\n        newChildren.add(Node.newString(sb.toString()));\n        didMergeGroup = true;\n      } else {\n        for (Node g : group) {\n          newChildren.add(Node.newString(NodeUtil.getStringValue(g)));\n        }\n      }\n    } else {\n      newChildren.add(Node.newString(NodeUtil.getStringValue(group.get(0))));\n    }\n  }\n  // If no merging occurred and the number of children is unchanged, then no optimization.\n  if (newChildren.size() == arrayNode.getChildCount() && !didMergeGroup) {\n    return;\n  }\n  // Compute the cost of the new array literal.\n  int newChildrenCost = 0;\n  for (Node child : newChildren) {\n    newChildrenCost += child.getString().length() + 2;\n  }\n  newChildrenCost += (newChildren.size() - 1);\n  int foldedCost = newChildrenCost + kJoinOverhead + InlineCostEstimator.getCost(right);\n  if (foldedCost > originalSize) {\n    return;\n  }\n  // Replace the children in the array literal with our new (normalized/merged) list.\n  arrayNode.detachChildren();\n  for (Node child : newChildren) {\n    arrayNode.addChildToBack(child);\n  }\n  t.getCompiler().reportCodeChange();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}