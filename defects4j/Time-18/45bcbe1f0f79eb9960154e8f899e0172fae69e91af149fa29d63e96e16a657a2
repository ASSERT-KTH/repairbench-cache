{
    "generation": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                              int hourOfDay, int minuteOfHour,\n                              int secondOfMinute, int millisOfSecond)\n    throws IllegalArgumentException\n{\n    Chronology base = getBase();\n    if (base != null) {\n        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                      hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n\n    // Determine the local cutover date from the Gregorian chronology.\n    int cutoverYear = iGregorianChronology.year().get(iCutoverMillis);\n    int cutoverMonth = iGregorianChronology.monthOfYear().get(iCutoverMillis);\n    int cutoverDay = iGregorianChronology.dayOfMonth().get(iCutoverMillis);\n\n    long instant;\n    // If the local date is strictly before the Gregorian cutover date,\n    // then attempt to compute using the Julian chronology.\n    if ((year < cutoverYear) ||\n        (year == cutoverYear && monthOfYear < cutoverMonth) ||\n        (year == cutoverYear && monthOfYear == cutoverMonth && dayOfMonth < cutoverDay)) {\n        instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                                      hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        // If the computed Julian instant ends up being in or after the cutover,\n        // then the local date falls into the illegal cutover gap.\n        if (instant >= iCutoverMillis) {\n            throw new IllegalArgumentException(\"Specified date does not exist\");\n        }\n    } else {\n        // Otherwise, use Gregorian chronology.\n        instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n    return instant;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}