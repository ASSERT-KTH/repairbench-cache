{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            // Delegate if base is set\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                    hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        IllegalArgumentException gregorianException = null;\n        long instant;\n\n        // Try Gregorian calculation first\n        try {\n            instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                    hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // Gregorian calculation succeeded.\n            if (instant >= iCutoverMillis) {\n                // Instant is on or after the cutover, Gregorian calculation is correct.\n                return instant;\n            }\n            // If Gregorian calculation succeeded, but represents an instant *before*\n            // the cutover, it implies this date should have been Julian.\n            // Fall through to the Julian calculation block below.\n\n        } catch (IllegalArgumentException e) {\n            // Gregorian calculation failed (e.g., invalid date like 1500-02-29).\n            // Store the exception and proceed to try Julian, as it might be a valid Julian date.\n            gregorianException = e;\n            // Set instant to a value that won't be accidentally returned.\n            // The actual value doesn't matter here as control flow dictates what happens next.\n            instant = Long.MIN_VALUE; // Or any value clearly indicating failure/pending state\n        }\n\n        // If we are here, either:\n        // 1. Gregorian calculation failed (gregorianException != null).\n        // 2. Gregorian calculation succeeded, but the calculated instant was < iCutoverMillis.\n\n        // Try Julian calculation\n        try {\n            long julianInstant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                    hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // Julian calculation succeeded.\n            // Check if this Julian date falls into the Gregorian period (gap or after).\n            if (julianInstant >= iCutoverMillis) {\n                // A date specified by these fields calculates to a Julian instant\n                // on or after the cutover. This implies the date falls into the\n                // \"gap\" where the switch from Julian to Gregorian occurred,\n                // or represents a time where the Gregorian calendar should be used\n                // but was calculated using Julian rules due to earlier checks.\n                // In either case, according to the GJ Chronology rules, this date\n                // specification is invalid as it creates ambiguity or falls in the gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n\n            // Otherwise (julianInstant < iCutoverMillis), the Julian instant is correct\n            // because we are either dealing with a date clearly before the cutover,\n            // or the Gregorian calculation failed suggesting it should be Julian.\n            return julianInstant;\n\n        } catch (IllegalArgumentException e) {\n            // Julian calculation also failed.\n            // If the Gregorian calculation had also failed previously (gregorianException != null),\n            // it indicates the date is invalid under both calendar systems' rules\n            // (or at least invalid under Gregorian and the attempt to interpret as Julian also failed).\n            // Rethrow the original Gregorian exception as it likely represents the primary validation failure\n            // encountered when initially checking against the Gregorian system (which is the default\n            // for dates after the cutover).\n            if (gregorianException != null) {\n                throw gregorianException;\n            }\n            // If Gregorian succeeded (but its instant was < cutover) and Julian failed,\n            // it means the date fields yielded a pre-cutover instant with Gregorian rules\n            // (suggesting Julian should apply), but the date is invalid according to Julian rules.\n            // In this case, the Julian exception correctly reflects the reason for failure.\n            throw e;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}