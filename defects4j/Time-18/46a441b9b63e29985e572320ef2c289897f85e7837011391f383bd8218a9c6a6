{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long gregorianMillis = Long.MIN_VALUE; // Sentinel for \"not calculated\" or \"failed\"\n        boolean gregorianFailed = false;\n\n        // Try Gregorian calculation first\n        try {\n            gregorianMillis = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // Date is potentially invalid in Gregorian calendar (eg. Feb 29 non-leap year).\n            // It Might be Julian or truly invalid. Allow specific exceptions like\n            // IllegalFieldValueException to be caught here.\n            gregorianFailed = true;\n            // Keep gregorianMillis as Long.MIN_VALUE\n        }\n\n        // If Gregorian calculation succeeded AND the resulting instant is at or after the cutover, use it.\n        if (!gregorianFailed && gregorianMillis >= iCutoverMillis) {\n            return gregorianMillis;\n        }\n\n        // Otherwise (Gregorian failed or instant is before cutover), calculate using Julian.\n        // We prioritize Julian interpretation for dates before the cutover instant.\n        long julianMillis;\n        try {\n             julianMillis = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // If Gregorian also failed, then the date is likely invalid in Julian too.\n            // Re-throw the exception from the Julian calculation, as it's the one we tried last\n            // for the pre-cutover logic path.\n             if (gregorianFailed) {\n                  throw e;\n             } else {\n                  // Gregorian succeeded but was < cutover, and Julian failed.\n                  // This implies the date might be valid proleptic Gregorian before the cutover,\n                  // but is explicitly invalid in Julian. Since we prioritize Julian rules\n                  // before the cutover, a failure here means invalid input according to GJ rules.\n                  throw e;\n             }\n        }\n\n        // If the Julian instant is strictly before the cutover, use it.\n        // This correctly handles dates like 1500-02-29 (valid Julian, invalid Gregorian).\n        // It also handles cases where Gregorian might have succeeded proleptically (< cutover)\n        // but Julian interpretation is preferred before the cutover.\n        if (julianMillis < iCutoverMillis) {\n             return julianMillis;\n        }\n\n        // If we reach here:\n        // 1. Gregorian failed OR Gregorian succeeded but gregorianMillis < iCutoverMillis\n        // 2. Julian succeeded AND julianMillis >= iCutoverMillis\n        // This implies the date falls into the cutover gap (a time that doesn't exist\n        // in the GJ timeline). Even if Gregorian succeeded proleptically (< cutover),\n        // the fact that the Julian interpretation falls >= cutover identifies the gap.\n        throw new IllegalArgumentException(\"Specified date does not exist\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}