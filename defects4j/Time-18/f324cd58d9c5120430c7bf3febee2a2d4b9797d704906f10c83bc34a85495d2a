{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long instantGregorian;\n        try {\n             // Try Gregorian calculation first; it's the most common case post-cutover.\n             instantGregorian = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n         } catch (IllegalArgumentException e) {\n             // When Gregorian fails, possibly due to the date being valid only in Julian\n             // before the cutover (like Feb 29, 1500). Calculate using Julian.\n             // If Julian calculation also throws an exception, let it propagate.\n             long instantJulianCatch = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n             // Gregorian failed, but Julian succeeded. Check if the Julian date is before the cutover.\n             if (instantJulianCatch < iCutoverMillis) {\n                 // It's a valid Julian date before the cutover. Return it.\n                 return instantJulianCatch;\n             } else {\n                 // It's a valid Julian date, but it is on or after the cutover.\n                 // Since the Gregorian calculation failed for a date that should be Gregorian,\n                 // this indicates the date is truly invalid in the context of GJChronology.\n                 // Rethrow the original Gregorian exception.\n                 throw e;\n             }\n         }\n\n         // Gregorian calculation succeeded. Now, check if the calculated instant falls before the cutover.\n         if (instantGregorian < iCutoverMillis) {\n             // The date falls before the cutover according to Gregorian rules.\n             // For dates before the cutover, the Julian calendar is authoritative.\n             // We must calculate the instant using Julian rules to be sure.\n             long instantJulianCheck = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n             if (instantJulianCheck < iCutoverMillis) {\n                 // Both calculations result in an instant before the cutover.\n                 // Use the Julian instant, as it's the correct calendar system before the cutover.\n                 return instantJulianCheck;\n             } else {\n                 // Gregorian instant is before the cutover, but the Julian instant is on or after the cutover.\n                 // This signifies that the date falls into the \"gap\" where dates were skipped\n                 // during the transition from Julian to Gregorian. This date does not exist.\n                 throw new IllegalArgumentException(\"Specified date does not exist\");\n             }\n         } else {\n             // instantGregorian >= iCutoverMillis\n             // The date is on or after the cutover according to Gregorian calculation.\n             // This is the correct instant to return.\n             return instantGregorian;\n         }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}