{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            // Delegate to the base chronology if it exists.\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long instant;\n        try {\n            // Attempt calculation using the Gregorian calendar first.\n            // This is generally preferred for dates after the cutover.\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // The specified date fields are invalid according to the proleptic Gregorian calendar.\n            // This might be because it's a Julian-only date (like Feb 29, 1500) valid before the cutover.\n            // Or it could be genuinely invalid date fields (like Feb 30).\n            // We must attempt the calculation using the Julian calendar to check the first possibility.\n\n            // Calculate using Julian calendar. If this also throws, the date is definitively invalid\n            // (as it's invalid in both Gregorian and Julian contexts).\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // If the Julian calculation succeeded, we need to ensure it falls *before* the cutover.\n            // A date specified by fields that are valid in Julian but not Gregorian,\n            // and which calculates to an instant *at or after* the cutover,\n            // is considered invalid in GJChronology (e.g., Feb 29, 1700).\n            // This is because Gregorian rules should apply at or after the cutover, and the\n            // date was already found invalid under those rules (exception 'e').\n            if (instant >= iCutoverMillis) {\n                 // The date is invalid under Gregorian rules (initial exception e),\n                 // and even if interpreted as Julian, it falls at or after the cutover where Gregorian should apply.\n                 // Thus, the original assessment of invalidity holds. Re-throw the original exception.\n                 throw e;\n            }\n            // Otherwise (Julian calculation succeeded and instant < iCutoverMillis),\n            // this is a valid Julian date before the cutover. Return it.\n            return instant;\n        }\n\n        // Gregorian calculation succeeded. Now, check if the resulting instant\n        // falls before or after the cutover instant.\n        if (instant < iCutoverMillis) {\n            // The Gregorian date maps to a time before the cutover.\n            // According to GJChronology rules, dates before the cutover must use the Julian calendar rules.\n            // We must recalculate using Julian.\n            long julianInstant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // There's a special case: the cutover gap.\n            // If the date fields represented a valid Gregorian date mapping before the cutover instant, AND\n            // the same fields represent a valid Julian date mapping *at or after* the cutover instant,\n            // then the date falls into the gap (e.g., Oct 10, 1582, depending on exact cutover).\n            // Such dates do not exist in GJChronology.\n            if (julianInstant >= iCutoverMillis) {\n                // It's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            // Otherwise, the Julian interpretation is valid and represents the correct instant\n            // for a date specified before the cutover. Use the Julian instant.\n            return julianInstant;\n        } else {\n            // The Gregorian date maps to a time at or after the cutover.\n            // This is correct according to GJChronology rules. Use the Gregorian instant.\n            return instant;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}