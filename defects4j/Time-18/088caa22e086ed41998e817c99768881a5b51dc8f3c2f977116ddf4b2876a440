{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long instantG;\n        try {\n            // Calculate using Gregorian rules first.\n            instantG = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            // When the Gregorian calculation fails, it might be because the\n            // date is before the cutover and only valid in the Julian calendar.\n            // Calculate using Julian rules. If this fails, then the date is invalid.\n            // If it succeeds, check the resulting instant against the cutover.\n            long instantJ;\n            try {\n                instantJ = iJulianChronology.getDateTimeMillis\n                    (year, monthOfYear, dayOfMonth,\n                     hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            } catch (IllegalArgumentException e2) {\n                // Failed in both Gregorian and Julian systems. Rethrow the original exception.\n                throw e;\n            }\n            \n            // Gregorian calculation failed, but Julian succeeded.\n            // If the Julian instant is before the cutover, then it's valid.\n            if (instantJ < iCutoverMillis) {\n                 return instantJ;\n            } else {\n                 // Otherwise, the date is invalid. The fields resolved to a Julian date\n                 // on or after the cutover, but the fields are invalid for the\n                 // Gregorian calendar. This situation implies an invalid date.\n                 // Rethrow the original Gregorian exception.\n                 throw e;\n            }\n        }\n\n        // Gregorian calculation succeeded. Check if the instant is before the cutover.\n        if (instantG < iCutoverMillis) {\n            // The instant calculated using Gregorian rules is before the cutover.\n            // Calculate the instant using Julian rules.\n            long instantJ = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            \n            // If the Julian instant is on or after the cutover, the date is invalid\n            // because it falls within the cutover gap.\n            if (instantJ >= iCutoverMillis) {\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            \n            // The date is before the cutover. Per GJ chronology rules, use the\n            // Julian calculation.\n            return instantJ;\n        } else {\n            // The instant calculated using Gregorian rules is on or after the cutover.\n            // Use the Gregorian calculation.\n            return instantG;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}