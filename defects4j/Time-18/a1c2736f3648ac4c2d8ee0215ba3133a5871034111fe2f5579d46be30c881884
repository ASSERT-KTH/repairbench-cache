{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long gregorianInstant;\n        boolean gregorianCalculationFailed = false;\n\n        try {\n            // Assume date is Gregorian first.\n            gregorianInstant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        } catch (IllegalArgumentException e) {\n            gregorianCalculationFailed = true;\n            \n            // Gregorian calculation failed. This might be because the date is\n            // valid only in Julian and is before the cutover (e.g., Feb 29, 1500).\n\n            // Determine if the input date (year, month, day) is strictly before\n            // the configured cutover date (iCutoverYear, iCutoverMonthOfYear, iCutoverDayOfMonth).\n            // Dates before the cutover should typically be handled by Julian.\n            boolean isBeforeCutoverDate =\n                (year < iCutoverYear) ||\n                (year == iCutoverYear && monthOfYear < iCutoverMonthOfYear) ||\n                (year == iCutoverYear && monthOfYear == iCutoverMonthOfYear && dayOfMonth < iCutoverDayOfMonth);\n\n            if (isBeforeCutoverDate) {\n                // The input date is strictly before the cutover date based on year/month/day.\n                // Try Julian as a fallback.\n                long julianInstant = iJulianChronology.getDateTimeMillis\n                    (year, monthOfYear, dayOfMonth,\n                     hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n                // If the Julian calculation results in an instant that is on or after\n                // the Gregorian cutover point, this is an unexpected inconsistency\n                // for a date that should be purely Julian. This signifies an invalid date\n                // within the hybrid chronology's rules.\n                if (julianInstant >= iCutoverMillis) {\n                    throw new IllegalArgumentException(\"Specified date does not exist (Julian result inconsistent with cutover date)\");\n                }\n                \n                // If Julian calculation succeeded and is before cutover, return this Julian instant.\n                return julianInstant;\n            } else {\n                // Gregorian calculation failed, and the date is on or after the cutover date.\n                // This means the date is simply invalid for GJChronology.\n                throw e; // Re-throw the original IllegalArgumentException.\n            }\n        }\n\n        // If we reach here, 'gregorianInstant' was successfully calculated.\n        // Now, apply the existing cutover gap logic. This part checks if the\n        // Gregorian interpretation of the date is before the cutover, which might\n        // imply it's a Julian date that falls into the \"cutover gap\".\n        if (!gregorianCalculationFailed && gregorianInstant < iCutoverMillis) {\n            // Gregorian calculation yielded an instant before the cutover.\n            // Now, compare this with the Julian interpretation of the same date.\n            long julianInstantForGapCheck = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            \n            if (julianInstantForGapCheck >= iCutoverMillis) {\n                // This is the illegal cutover gap:\n                // Gregorian calculates to an instant before cutover, but\n                // Julian calculates to an instant on or after cutover.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            // If Julian also maps to an instant before cutover, the Julian interpretation is correct.\n            return julianInstantForGapCheck;\n        }\n\n        // If gregorianCalculationFailed is false, and gregorianInstant is >= iCutoverMillis,\n        // then the date is a valid Gregorian date on or after the cutover.\n        return gregorianInstant;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}