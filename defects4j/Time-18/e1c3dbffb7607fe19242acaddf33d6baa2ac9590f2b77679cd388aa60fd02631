{
    "generation": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                              int hourOfDay, int minuteOfHour,\n                              int secondOfMinute, int millisOfSecond)\n    throws IllegalArgumentException\n{\n    Chronology base = getBase();\n    if (base != null) {\n        return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                      hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }\n\n    long instant;\n    try {\n        // Try computing using the Gregorian chronology.\n        // This may succeed for dates that are valid in Gregorian rules.\n        instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                                         hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        // If the computed Gregorian instant is on/after the cutover, it is correct.\n        if (instant >= iCutoverMillis) {\n            return instant;\n        }\n        // Otherwise, the date falls before the cutover, so we must use the Julian rules.\n    } catch (IllegalFieldValueException ex) {\n        // Gregorian computation failed.\n        // For example, 1500-02-29 is invalid in the Gregorian calendar,\n        // but is a valid date in the Julian calendar.\n    }\n    \n    // Compute using the Julian chronology.\n    instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    // If the Julian instant is before the cutover, it\u2019s valid.\n    if (instant < iCutoverMillis) {\n        return instant;\n    }\n    // Otherwise the fields fall into the illegal cutover gap.\n    throw new IllegalArgumentException(\"Specified date does not exist\");\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}