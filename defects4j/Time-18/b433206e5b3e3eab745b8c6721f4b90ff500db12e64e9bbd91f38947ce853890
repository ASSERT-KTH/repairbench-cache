{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        long instant;\n        try {\n            // Try Gregorian calculation first. This is assumed by default\n            // for dates on or after the cutover.\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            \n            // If the Gregorian date is potentially before the cutover, verify\n            // logic further down. If it's on or after, we are done with this part.\n\n        } catch (IllegalArgumentException ex) {\n            // Gregorian calculation failed. This might be because the date is\n            // valid under Julian rules but not Gregorian (e.g., Feb 29, 1500).\n            \n            // Try Julian calculation. If it also fails, let the exception propagate upwards.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // If Julian calculation succeeded, check if it falls before the cutover.\n            if (instant < iCutoverMillis) {\n                // Valid Julian date before the cutover - return it.\n                return instant;\n            } else {\n                // Valid Julian date, but on or after the cutover instant.\n                // In GJChronology, dates on or after the cutover must be Gregorian.\n                // Since the Gregorian calculation failed, this date doesn't exist in GJ terms.\n                // Example: Fields that represent a date that would be valid in Julian\n                // if the calendar continued indefinitely, but falls after the cutover date.\n                throw new IllegalArgumentException(\"Specified date does not exist in GJ chronology\");\n                // Alternative: could re-throw ex, but this message is more specific to GJ context.\n            }\n        }\n\n        // Gregorian calculation succeeded. 'instant' holds the Gregorian millis.\n        // We must now check if this date should actually be Julian based on the cutover.\n        if (instant < iCutoverMillis) {\n            // The Gregorian interpretation falls before the cutover instant.\n            // This means the date should be interpreted using the Julian calendar.\n            \n            // Recalculate using Julian. We expect this to succeed because the fields\n            // were valid enough for the Gregorian calculation to succeed initially.\n            long julianInstant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // Check if the Julian interpretation falls into the \"gap\" - the period\n            // skipped during the calendar transition. This happens if the date fields\n            // specify a date that exists notionally in Gregorian before the cutover, \n            // but the same date fields interpreted in Julian result in an instant \n            // on or after the cutover.\n            // Example: 1582-10-10 in the standard switch. Valid Gregorian fields,\n            // results in instant before cutover. Julian fields 1582-10-10 result\n            // in instant >= cutover. This date is in the gap.\n            if (julianInstant >= iCutoverMillis) {\n                // Date is in the cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            \n            // Valid Julian date before the cutover.\n            return julianInstant;\n        } else {\n            // The Gregorian date is on or after the cutover. Return the Gregorian instant.\n            return instant;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}