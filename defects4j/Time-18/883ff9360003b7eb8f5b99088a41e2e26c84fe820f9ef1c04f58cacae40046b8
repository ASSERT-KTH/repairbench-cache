{
    "generation": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Determine if the date components (year, month, day) clearly fall before the cutover.\n        // This avoids calling GregorianChronology for dates like 1500-02-29 which are invalid\n        // in Gregorian but valid in Julian.\n        boolean isClearlyBeforeCutoverDate;\n        if (year < iCutoverYear) {\n            isClearlyBeforeCutoverDate = true;\n        } else if (year > iCutoverYear) {\n            isClearlyBeforeCutoverDate = false;\n        } else { // year == iCutoverYear\n            if (monthOfYear < iCutoverMonth) {\n                isClearlyBeforeCutoverDate = true;\n            } else if (monthOfYear > iCutoverMonth) {\n                isClearlyBeforeCutoverDate = false;\n            } else { // monthOfYear == iCutoverMonth\n                // If dayOfMonth is before the cutover day, it's clearly before.\n                // Otherwise (on or after cutover day), it's not clearly before.\n                isClearlyBeforeCutoverDate = (dayOfMonth < iCutoverDay);\n            }\n        }\n\n        long instant;\n        if (isClearlyBeforeCutoverDate) {\n            // If the date is clearly before the cutover (e.g., 1500-02-29),\n            // it must be handled by the Julian chronology.\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            \n            // After Julian calculation, check if this falls into the illegal cutover gap.\n            // This happens if the Julian date itself corresponds to a moment on or after the Gregorian cutover.\n            // Example: 1582-10-05 (Julian) which is equivalent to 1582-10-15 (Gregorian) - this is iCutoverMillis.\n            if (instant >= iCutoverMillis) {\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        } else {\n            // If the date is on or after the cutover based on year/month/day,\n            // or if it's an ambiguous date within the cutover period (e.g. 1582-10-01),\n            // use the original logic which tries Gregorian first and then handles ambiguity/gap.\n            instant = iGregorianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            \n            // If the calculated Gregorian instant is before the cutover, it might be a Julian date.\n            // This handles ambiguous dates that look like Gregorian but map to before the cutover,\n            // or dates that are truly in the transition period.\n            if (instant < iCutoverMillis) {\n                // Try Julian conversion.\n                long julianInstant = iJulianChronology.getDateTimeMillis\n                    (year, monthOfYear, dayOfMonth,\n                     hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n                \n                // If the Julian instant falls on or after the Gregorian cutover,\n                // it means the date is in the illegal cutover gap.\n                if (julianInstant >= iCutoverMillis) {\n                    throw new IllegalArgumentException(\"Specified date does not exist\");\n                }\n                // Otherwise, use the Julian instant.\n                instant = julianInstant;\n            }\n        }\n        return instant;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}