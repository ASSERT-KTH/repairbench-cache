{
    "generation": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n\n        // Determine the actual start index for copying.\n        // getIndex(start) returns index if found, or -(insertionPoint + 1) if not.\n        // If not found, insertionPoint is the index where 'start' would be inserted,\n        // which is also the index of the first item *after* 'start'.\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1); // Now startIndex is the index of the first item at or after 'start'\n        }\n\n        // Determine the actual end index for copying.\n        // getIndex(end) returns index if found, or -(insertionPoint + 1) if not.\n        // If not found, insertionPoint is the index of the first item *after* 'end'.\n        // We want the last item *at or before* 'end', so we subtract 1 from the insertionPoint.\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {\n            endIndex = -(endIndex + 1); // This is the insertion point (first item AFTER 'end')\n            endIndex = endIndex - 1;    // This is the index of the last item AT OR BEFORE 'end'\n        }\n\n        // If the calculated startIndex is greater than the calculated endIndex,\n        // it means the specified period range does not overlap with any data\n        // in the series, or the effective 'start' is after the effective 'end' within the data.\n        // In such cases, an empty time series should be returned.\n        if (startIndex > endIndex) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList(); // Create an empty data list\n            return copy;\n        } else {\n            // Otherwise, create the copy using the determined inclusive index range.\n            return createCopy(startIndex, endIndex);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}