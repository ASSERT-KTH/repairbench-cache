{
    "generation": "    /**\n     * Creates a new timeseries by copying a subset of the data in this time\n     * series.\n     *\n     * @param start  the first time period to copy (<code>null</code> not\n     *         permitted).\n     * @param end  the last time period to copy (<code>null</code> not\n     *         permitted).\n     *\n     * @return A time series containing a copy of this time series from start\n     *         until end.\n     *\n     * @throws CloneNotSupportedException if there is a cloning problem.\n     */\n    public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        // This initial check ensures the requested time periods are ordered correctly.\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n\n        // Calculate the first index (inclusive) of data points within the series\n        // that are on or after 'start'.\n        int firstIndex = getIndex(start);\n        if (firstIndex < 0) {\n            // 'start' period is not in the series. 'getIndex' returns '-(insertion point) - 1'.\n            // The insertion point (which is the index of the first item >= 'start') is '-(firstIndex + 1)'.\n            firstIndex = -(firstIndex + 1);\n        }\n\n        // Calculate the last index (inclusive) of data points within the series\n        // that are on or before 'end'.\n        int lastIndex = getIndex(end);\n        if (lastIndex < 0) {\n            // 'end' period is not in the series. 'getIndex' returns '-(insertion point) - 1'.\n            // The insertion point (which is the index of the first item > 'end') is '-(lastIndex + 1)'.\n            // We want the index of the last item that is <= 'end', which is the item just before\n            // the insertion point.\n            lastIndex = -(lastIndex + 1) - 1;\n        }\n\n        // Determine if the effective range of data to copy is empty.\n        // This covers cases where the requested time range does not overlap with any data\n        // in the current series, or overlaps but results in no items to copy.\n        //\n        // 1. 'firstIndex >= this.data.size()': The 'start' period is effectively after the last\n        //    item in the series (e.g., firstIndex points beyond the end of the data list).\n        // 2. 'lastIndex < 0': The 'end' period is effectively before the first item in the series\n        //    (e.g., lastIndex points before the start of the data list).\n        // 3. 'firstIndex > lastIndex': The determined effective start index is greater than\n        //    the effective end index. This means the requested time period range [start, end]\n        //    does not encompass any data points within the series, even if individual start/end\n        //    periods might fall within the series' overall time span. For example, if the series\n        //    has data for Day A and Day C, and the request is for Day B (between A and C).\n        if (firstIndex >= this.data.size() || lastIndex < 0 || firstIndex > lastIndex) {\n            // If any of these conditions are true, the resulting copy should be an empty TimeSeries.\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList(); // Assuming 'data' is the internal list storing TimeSeriesDataItem.\n            return copy;\n        }\n        else {\n            // If the range is valid and non-empty, call the internal createCopy method\n            // with the calculated 0-based inclusive start and end indices.\n            return createCopy(firstIndex, lastIndex);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}