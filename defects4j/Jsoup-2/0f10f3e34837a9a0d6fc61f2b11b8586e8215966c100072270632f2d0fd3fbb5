{
    "generation": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode(); // Assumes parseTextNode exists and handles appending text\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            // Assuming parseAttribute() is defined elsewhere and returns Attribute or null\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        // Assuming Tag, Element, Attributes, Node, TextNode, DataNode are available from imports\n        Tag tag = Tag.valueOf(tagName);\n        // Assuming baseUri is accessible (e.g., member variable)\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        // Assuming addChildToParent adds the child to the current parent element\n        // and pushes 'child' onto the 'stack' if it's not an empty element.\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            // Consume the end tag robustly. Replaces original tq.chompTo(\">\").\n            // This ensures that the correct end tag is consumed.\n            tq.matchChomp(\"</\" + tagName + \">\");\n\n            Node dataNode;\n            // Assuming titleTag and textareaTag are defined Tag constants accessible here\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // RCDATA handling\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else // RAWTEXT handling (script, style)\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);\n\n            // FIX: Pop the element from the stack.\n            // This assumes 'stack' (likely a LinkedList<Element> or ArrayList<Element>)\n            // is accessible and holds the current tree path (list of open elements).\n            // This step is necessary because this block consumed the start tag, data,\n            // and end tag, effectively closing the element implicitly. Without popping,\n            // subsequent text nodes would be incorrectly added to this element.\n            if (!stack.isEmpty() && stack.getLast().tagName().equals(tagName)) {\n                stack.removeLast(); // Pop the element represented by 'child'\n            }\n            // Note: The exact method names for stack access (e.g., getLast(), removeLast())\n            // depend on the actual type and implementation of 'stack' in the surrounding class.\n            // This logic assumes a LIFO structure like LinkedList or ArrayList used as a stack.\n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                // Assuming 'doc' is the Document being built and is accessible\n                // The check for doc != null might be necessary depending on context.\n                if (doc != null) doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}