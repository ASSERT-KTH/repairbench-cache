{
    "generation": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            // We need to switch back to Data state to parse the text\n            // This might require returning a specific token or adjusting the calling logic\n            // However, the immediate fix is focused on the data tag parsing below.\n            // Assuming parseTextNode handles the transition correctly for now.\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName); // returns normalized (lowercase) tag\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\"); // Consume the closing > of the start tag\n        }\n        // Add child to parent *before* parsing data content for data tags.\n        // This matches jsoup's behavior but differs from some parsers.\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            // Original buggy code:\n            // String data = tq.chompTo(\"</\" + tagName); // Used original potentially mixed-case tagName\n            // tq.chompTo(\">\"); // Incorrectly consumed up to the *next* >\n\n            // Fixed code:\n            String endTag = \"</\" + tag.getName(); // Use normalized (lowercase) tag name for matching end tag\n            // Consume data up to the end tag sequence </tagname>, case-insensitive as per HTML spec for script/style\n            String data = tq.consumeToIgnoreCase(endTag);\n            // Consume the matched end tag sequence itself (e.g., </script>, </SCRIPT>, etc.)\n            tq.matchChompIgnoreCase(endTag);\n            // Consume the closing '>' character of the end tag\n            tq.matchChomp(\">\");\n\n            Node dataNode;\n            // Use tag object comparison\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, encoded\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else // script, style etc - data is raw / CDATA\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);\n        }\n\n        // <base href>: update the base uri\n        // Use tag's normalized name for comparison\n        if (tag.getName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}