{
    "generation": "    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            // We need to ensure the parser transitions back to the Text state to handle this '<' as text.\n            // Simply calling parseTextNode() might not be sufficient depending on the caller's logic.\n            // However, assuming parseTextNode is the correct action or that the caller handles the state:\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img)\n        if (tq.matchChomp(\"/>\")) { // Check for self-closing '/ >'\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\"); // Consume the closing '>' of the start tag e.g., <p>\n        }\n        // Add child to parent, and push onto stack if it's not an empty element\n        addChildToParent(child, isEmptyElement);\n\n        // Handle data tags (script, textarea, title) which expect raw text content.\n        // This needs to happen only if the tag is NOT considered empty (e.g., not <script/> or <img>)\n        if (tag.isData() && !isEmptyElement) {\n            // Consume the data content up to the end tag </tagName>\n            // Importantly, use consumeTo, not chompTo. consumeTo reads *up to* the sequence,\n            // leaving the sequence itself (the end tag) in the queue to be handled by the parser's state machine.\n            String data = tq.consumeTo(\"</\" + tagName);\n\n            // Create the appropriate node for the data.\n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag))\n                // Title and textarea data are treated like text, entities should be decoded.\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                // Script data is raw; entities (like &lt;) should not be decoded.\n                dataNode = new DataNode(data, baseUri);\n            child.appendChild(dataNode);\n\n            // DO NOT consume the end tag here (e.g., </script>).\n            // The parser's main loop, likely transitioning to a specific state like ScriptDataState,\n            // is responsible for finding and consuming the end tag, popping the stack,\n            // and returning to the previous state. The original code's tq.chompTo(\">\");\n            // after the data chomp was incorrect and caused the bug.\n        }\n\n        // Special handling for <base href> tags to update the base URI.\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}