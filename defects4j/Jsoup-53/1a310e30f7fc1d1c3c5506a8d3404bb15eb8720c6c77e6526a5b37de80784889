{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        // Assuming ESC is defined in CharacterReader as '\\\\'\n        final char ESC = '\\\\';\n\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char lastChar = 0; // last character consumed (for escape sequence tracking)\n        char quoteChar = 0; // The current quote character (', \" or 0 if not in a quote)\n\n        do {\n            if (isEmpty()) {\n                break; // No more characters to consume\n            }\n            Character c = consume(); // Get the current character\n\n            if (lastChar == ESC) {\n                // This character `c` was escaped by the previous `ESC`.\n                // Treat it as literal content. It does not affect depth or quote state.\n            } else if (quoteChar != 0) {\n                // We are currently inside a quoted string.\n                if (c == quoteChar) {\n                    // Found the matching closing quote. Exit quote mode.\n                    quoteChar = 0;\n                }\n                // Else, `c` is just part of the quoted string, it doesn't affect depth.\n            } else {\n                // Not escaped, and not in a quote. This character can be:\n                // 1. An opener\n                // 2. A closer\n                // 3. A quote character (starting a new quote)\n                // 4. Any other literal character\n                if (c == open) {\n                    depth++;\n                    if (start == -1) {\n                        start = pos; // `pos` is the index *after* `c`. Correct for content start.\n                    }\n                } else if (c == close) {\n                    depth--;\n                } else if (c == '\\'' || c == '\"') {\n                    // Found an unescaped, unquoted single or double quote.\n                    // Enter quote mode.\n                    quoteChar = c;\n                }\n            }\n\n            // Update `end` to mark the position after the current character if we are still within\n            // a balanced block (depth > 0) and it's not the very first character (which was the opener).\n            // `lastChar != 0` ensures `end` is not updated for the opener itself, which is already\n            // accounted for by `start`.\n            if (depth > 0 && lastChar != 0) {\n                end = pos;\n            }\n            lastChar = c; // Update lastChar for the next iteration\n        } while (depth > 0);\n\n        // Return the substring between `start` and `end`.\n        // If `end` is still -1, it means no balanced content was found (e.g., just `(`).\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}