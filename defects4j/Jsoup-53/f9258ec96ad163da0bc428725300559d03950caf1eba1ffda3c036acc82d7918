{
    "generation": "import static org.jsoup.parser.TokenQueue.ESC; // Assuming ESC is a static final char defined in TokenQueue\n\npublic class TokenQueue { // This is a placeholder for the class, the fix applies to the method within it.\n    private String queue;\n    private int pos = 0; // Current position in the queue\n\n    // Assuming ESC is defined in TokenQueue class like this:\n    private static final char ESC = '\\\\';\n\n    public TokenQueue(String queue) {\n        this.queue = queue;\n    }\n\n    public boolean isEmpty() {\n        return pos >= queue.length();\n    }\n\n    public Character consume() {\n        if (isEmpty()) return null; // Or throw an exception, depending on TokenQueue's actual behavior\n        return queue.charAt(pos++);\n    }\n\n    // Other TokenQueue methods would be here, but only chompBalanced is being fixed.\n    // Methods like substring, matches, chompTo, etc., are assumed to exist and work as in Jsoup's TokenQueue.\n    public String substring(int start, int end) {\n        return queue.substring(start, end);\n    }\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        char inQuote = 0; // The current quote character if we are inside a quoted string\n\n        // Special handling for when open and close characters are the same (e.g., matching a quoted string like 'foo')\n        // The QueryParser calls this function *after* consuming the initial quote, so we are looking for the *next* matching quote.\n        if (open == close) {\n            StringBuilder sb = new StringBuilder();\n            do {\n                if (isEmpty()) break;\n                Character c = consume();\n\n                if (last == ESC) { // Current character 'c' is escaped, append it literally\n                    sb.append(c);\n                } else if (c == open) { // Found the closing delimiter (which is 'open')\n                    // This 'open' character marks the end of the balanced string.\n                    // The content collected in sb is the balanced string.\n                    return sb.toString();\n                } else { // Not escaped, and not the closing delimiter\n                    sb.append(c);\n                }\n                last = c;\n            } while (true); // Continue until break (either empty or closing delimiter found)\n            return sb.toString(); // If loop breaks due to isEmpty() (unbalanced)\n        }\n\n        // Original logic for open != close (balanced parens/brackets etc.)\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n\n            if (last == ESC) { // Current char 'c' is escaped, its special meaning is ignored.\n                // Do nothing to depth or quote state. Just part of the string.\n            } else if (inQuote != 0) { // Currently inside an inner quoted string\n                if (c == inQuote) { // Found the matching closing inner quote\n                    inQuote = 0; // Exit inner quote mode\n                }\n                // Else, still in inner quote, continue\n            } else { // Not escaped, not in an inner quote\n                if (c == '\\'' || c == '\"') { // Found a new inner opening quote\n                    inQuote = c; // Enter inner quote mode\n                } else if (c.equals(open)) {\n                    depth++;\n                    if (start == -1) // If this is the very first opener found\n                        start = pos; // 'pos' is *after* the consumed 'c', so it marks the start of content\n                } else if (c.equals(close)) {\n                    depth--;\n                }\n            }\n\n            // 'end' tracks the position *after* the last character that was part of the *balanced content*.\n            // It is updated as long as we are still within the balanced block (depth > 0).\n            // 'last != 0' ensures this is not the very first character consumed by the function.\n            if (depth > 0 && last != 0) {\n                end = pos; // 'pos' is *after* 'c', so this correctly captures the end for substring(start, end)\n            }\n            last = c; // Update 'last' for the next iteration\n\n        } while (depth > 0); // Loop until balanced.\n\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}