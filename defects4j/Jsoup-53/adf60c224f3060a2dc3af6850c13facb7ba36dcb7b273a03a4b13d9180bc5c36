{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        char inQuote = 0; // 0 if not in a quote, ' or \" if in a quote\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n\n            if (last == ESC) { // The current character 'c' is escaped. Treat it as a literal.\n                // It does not affect quote state or depth.\n            } else if (inQuote != 0) { // Currently inside a quote\n                if (c.equals(inQuote)) {\n                    inQuote = 0; // Found matching quote, exit quote state\n                }\n                // Otherwise, 'c' is just a character inside the quote; ignore open/close/other quotes.\n            } else { // Not escaped, and not currently in a quote\n                if (c.equals(open)) {\n                    depth++;\n                    if (start == -1)\n                        start = pos; // pos is index after consuming 'c'\n                } else if (c.equals(close)) {\n                    depth--;\n                } else if (c.equals('\\'')) { // Potential start of single quote\n                    inQuote = '\\'';\n                } else if (c.equals('\"')) { // Potential start of double quote\n                    inQuote = '\"';\n                }\n            }\n\n            // 'end' is the position after the last character *before* the final closing 'close' char.\n            // This condition ensures 'end' is not set for the very first 'open' char itself,\n            // and accurately tracks the end of the balanced string content.\n            if (depth > 0 && last != 0)\n                end = pos; // pos is index after 'c'\n            \n            last = c; // Update 'last' to the current character for the next iteration's escape check\n        } while (depth > 0);\n\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}