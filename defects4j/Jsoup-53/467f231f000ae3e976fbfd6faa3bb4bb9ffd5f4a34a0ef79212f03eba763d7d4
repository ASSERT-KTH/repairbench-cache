{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0; // Previous character, used for escape checking\n        char inQuote = 0; // Tracks if we are currently inside a single (') or double (\") quote\n\n        do {\n            if (isEmpty()) break; // If queue is empty, stop\n            Character c = consume(); // Consume the next character from the queue\n\n            // Check if the current character 'c' is escaped by the previous 'last' character.\n            // `ESC` is assumed to be a constant character (e.g., '\\') defined elsewhere in the class.\n            boolean escaped = (last == ESC);\n\n            if (inQuote != 0) { // Currently inside a quote\n                // If we find the matching closing quote and it's not escaped, exit quote mode.\n                if (c.equals(inQuote) && !escaped) {\n                    inQuote = 0; // Exit quote mode\n                }\n                // If 'c' is escaped, or not the matching quote, it's treated as a literal character\n                // within the quote and does not affect 'depth'.\n            } else { // Not currently in a quote\n                // Only process special characters (open, close, new quote) if 'c' is not escaped.\n                if (!escaped) {\n                    if (c.equals(open)) {\n                        depth++;\n                        if (start == -1) { // If this is the first opening character of the outermost balanced section\n                            // 'pos' is the position *after* consuming 'c'. So 'pos' marks the start of the content.\n                            start = pos;\n                        }\n                    } else if (c.equals(close)) {\n                        depth--;\n                    } else if (c.equals('\\'') || c.equals('\"')) { // Found an opening single or double quote\n                        inQuote = c; // Enter quote mode, and remember which type of quote it was\n                    }\n                }\n            }\n\n            // Update the 'end' position as long as we are still within the balanced section (depth > 0).\n            // 'pos' is the position *after* consuming 'c'. By updating 'end' to 'pos', we effectively extend\n            // the end of the substring to just after the current character 'c'.\n            // When 'depth' finally becomes 0 (after consuming the outermost 'close' character),\n            // this 'if' condition will be false, and 'end' will retain its value from the last\n            // character that was part of the balanced content, which is the correct exclusive end index for `substring`.\n            if (depth > 0) {\n                end = pos;\n            }\n\n            last = c; // Store the current character for the next iteration's escape checking\n        } while (depth > 0); // Continue processing characters as long as we are inside a balanced section\n\n        // If 'start' is still -1, it means no 'open' character was ever found, so no balanced string was extracted.\n        // In this case, 'end' would also likely be -1 or 0, so the condition 'end >= 0' handles this.\n        // Return the extracted substring, or an empty string if no valid match was found.\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}