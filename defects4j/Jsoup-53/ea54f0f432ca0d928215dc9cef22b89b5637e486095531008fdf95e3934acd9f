{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        final char ESC = '\\\\'; // Assuming ESC is defined in the class, typically as '\\\\'\n\n        do {\n            if (isEmpty()) break;\n            char c = consume(); // Consume character, pos advances\n\n            if (last != 0 && last == ESC) {\n                // If previous char was ESC, this char 'c' is escaped.\n                // It doesn't affect quotes or depth. Handled by not executing the else block.\n                // 'last' will be updated to 'c' below.\n            } else {\n                // Not an escaped character, process normally\n                if (c == '\\'' && !inDoubleQuote) {\n                    inSingleQuote = !inSingleQuote; // Toggle single quote state\n                } else if (c == '\"' && !inSingleQuote) {\n                    inDoubleQuote = !inDoubleQuote; // Toggle double quote state\n                } else if (!inSingleQuote && !inDoubleQuote) {\n                    // Only check balance if not inside any quotes\n                    if (c == open) {\n                        depth++;\n                        if (start == -1)\n                            start = pos; // pos is *after* consuming the open char\n                    } else if (c == close) {\n                        depth--;\n                    }\n                }\n            }\n\n            // Update end position based on original logic. Tracks position *after* last char consumed inside balanced section.\n            // Condition `last != 0` ensures we don't set end after consuming the opening brace itself.\n            if (depth > 0 && last != 0) {\n                 end = pos;\n            }\n            last = c; // Update last char for next iteration's escape check\n\n        } while (depth > 0); // Loop terminates *after* consuming the character that makes depth <= 0\n\n        // Returns substring from start (exclusive of open char) to end (exclusive of close char).\n        // If balance is never achieved (e.g., queue ends before depth returns to 0), end remains -1, returns \"\".\n        // If open char is never found, start remains -1, depth remains 0, loop doesn't execute (much), end remains -1, returns \"\".\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}