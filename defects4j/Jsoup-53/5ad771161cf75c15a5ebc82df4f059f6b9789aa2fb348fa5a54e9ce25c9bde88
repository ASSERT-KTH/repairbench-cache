{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue, or empty string if not balanced or not found.\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1; // Start index of matched content (immediately after open char)\n        int end = -1;   // End index of matched content (immediately before close char)\n        int depth = 0;  // Current nesting depth\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        boolean escaped = false;\n        final char ESC = '\\\\'; // Escape character\n\n        final int initialPos = pos; // Remember starting position\n\n        while (!isEmpty()) {\n            char c = consume(); // Consume character and advance position\n            int currentPos = pos; // Position after consuming c\n\n            if (escaped) {\n                // Previous character was escape, treat this char literally\n                escaped = false;\n            } else {\n                if (c == ESC) {\n                    escaped = true;\n                    // If we are inside the potential match, ensure the escape itself is included\n                    // The logic continues, and the next char will be skipped for special handling\n                } else if (c == '\\'' && !(open == '\\'' || close == '\\'')) { // Only toggle if quote is not the target open/close char\n                    // Check if not inside double quotes before toggling single quote state\n                    if (!inDoubleQuote) {\n                        inSingleQuote = !inSingleQuote;\n                    }\n                } else if (c == '\"' && !(open == '\"' || close == '\"')) {\n                   // Check if not inside single quotes before toggling double quote state\n                   if (!inSingleQuote) {\n                        inDoubleQuote = !inDoubleQuote;\n                    }\n                } else if (!inSingleQuote && !inDoubleQuote) {\n                    // Only process open/close if not inside quotes and not escaped\n                    if (c == open) {\n                        depth++;\n                        if (start == -1) { // Record start position only for the first opening brace\n                            start = currentPos; // Start position is *after* the opener\n                        }\n                    } else if (c == close) {\n                        depth--;\n                        // If depth becomes 0 and we had found the start, this is the matching closer\n                        if (depth == 0 && start != -1) {\n                             end = currentPos - 1; // End position is *before* the closing char\n                             break; // Found the complete balanced match\n                        }\n                    }\n                }\n            }\n\n            // Safety break condition: if depth goes negative, it's unbalanced\n            if (depth < 0) {\n                 // This means a close occurred before a matching open or too many closes.\n                 // The original code structure would likely also fail/stop here.\n                 // We break the loop, and since 'end' is not set correctly, \"\" will be returned.\n                 break;\n            }\n        } // end while\n\n        // Determine return value\n        if (end >= 0) { // Successfully found the balanced match (end was set when depth became 0)\n             return queue.substring(start, end);\n        } else {\n             // Match not found (opener never found, or queue ended while unbalanced, or unbalanced closer found)\n             // Reset position? The \"chomp\" suggests consuming, so we don't reset by default.\n             // pos = initialPos; // Uncomment this line if the caller requires position reset on failure.\n             return \"\"; // Return empty string to indicate failure\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}