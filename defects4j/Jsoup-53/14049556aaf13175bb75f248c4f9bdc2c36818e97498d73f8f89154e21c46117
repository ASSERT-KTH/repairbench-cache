{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        boolean inQuote = false; // Added to track if we are inside a quoted string\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume(); // pos advances\n\n            // Handle quoted sections within the balanced string.\n            // If it's a quote char and not escaped, toggle inQuote state.\n            if (c == '\\'' || c == '\"') {\n                if (last == 0 || last != ESC) { // Check if the quote itself is not escaped\n                    inQuote = !inQuote;\n                }\n            }\n\n            // Process open/close characters only if not inside a quote and not escaped\n            if (!inQuote) {\n                // If 'c' is an open or close char, and it's not escaped\n                if (last == 0 || last != ESC) { // Check if 'c' (the current char) is escaped by 'last'\n                    if (c.equals(open)) {\n                        depth++;\n                        if (start == -1) { // Set start when depth goes from 0 to 1\n                            start = pos; // pos is after current char, so 'start' points to beginning of content\n                        }\n                    } else if (c.equals(close)) {\n                        depth--;\n                    }\n                }\n            }\n\n            // 'end' captures the position after the last char of the balanced string.\n            // It will not include the final 'close' char in the returned substring.\n            // When depth becomes 0, this condition `depth > 0` becomes false,\n            // so `end` remains at the position *before* the final `close` char.\n            // `start != -1` ensures `end` is updated only if we're parsing content\n            // that started with an 'open' character.\n            if (depth > 0 && start != -1) {\n                end = pos;\n            }\n            \n            last = c; // Update last for the next iteration\n        } while (depth > 0);\n\n        // If no 'open' was found, or the string was empty, or immediately closed without content, return empty.\n        // `end >= start` ensures a valid substring range, `start != -1` ensures content was found after an 'open'.\n        return (end >= start && start != -1) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}