{
    "generation": "import org.jsoup.parser.TokenQueue;\n\npublic class TokenQueue {\n    // ... other methods ...\n\n    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        char currentQuote = 0; // Tracks if we are inside a single or double quote\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n\n            // Check for escapes first. If escaped, treat as literal and don't affect balance or quote state.\n            if (last == 0 || last != TokenQueue.ESC) { // TokenQueue.ESC is the escape char\n                // Handle quote characters (' or \")\n                if (c == '\\'' || c == '\"') {\n                    if (currentQuote == 0) { // Not currently in a quote, enter quote mode\n                        currentQuote = c;\n                    } else if (currentQuote == c) { // Found matching quote, exit quote mode\n                        currentQuote = 0;\n                    }\n                }\n\n                // Now, handle balancing characters based on whether we are in a quote or if open/close are the quote chars\n                if (open == close) { // Special case: open and close are the same character (e.g., for single quotes or custom delimiters like ~)\n                    if (c == open) { // If it's the delimiter character\n                        if (depth == 0) { // First occurrence of the delimiter (opening)\n                            depth++; // Enter balance mode\n                            if (start == -1) start = pos; // Mark start position (after consuming `open`)\n                        } else { // Second occurrence of the delimiter (closing)\n                            depth--; // Exit balance mode\n                        }\n                    }\n                } else { // Normal case: open and close are different characters (e.g., ( ))\n                    if (currentQuote == 0) { // Only change depth if not currently in a quote\n                        if (c.equals(open)) {\n                            depth++;\n                            if (start == -1) start = pos;\n                        } else if (c.equals(close)) {\n                            depth--;\n                        }\n                    }\n                }\n            }\n\n            // Update 'end' position (exclusive)\n            // `end` should be the position *before* the final `close` char that brings `depth` to 0.\n            // If `depth` becomes 0, the loop condition `depth > 0` fails, so `end` won't be updated for the last character.\n            // This means `end` captures the position after the last character *within* the balanced segment.\n            if (depth > 0 && start != -1) // use start != -1 to ensure we've begun matching\n                end = pos; // pos is index after the current char 'c'\n            last = c;\n        } while (depth > 0);\n\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}