{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        boolean inSingleQuote = false;\n        boolean inDoubleQuote = false;\n        boolean escaped = false;\n        // Assumes ESC is a static final char defined in the class, likely private static final char ESC = '\\\\';\n\n        final int initialPos = pos; // Record start position to reset if no match found\n\n        while (!isEmpty()) {\n            char c = consume();\n\n            if (escaped) {\n                // If the previous char was an escape, treat this char literally and reset flag\n                escaped = false;\n            } else {\n                // If not escaped, check for control characters\n                if (c == ESC) {\n                    escaped = true;\n                } else if (c == '\\'' && !inDoubleQuote) {\n                    // Toggle single quote state if encountered and not within double quotes\n                    inSingleQuote = !inSingleQuote;\n                } else if (c == '\"' && !inSingleQuote) {\n                    // Toggle double quote state if encountered and not within single quotes\n                    inDoubleQuote = !inDoubleQuote;\n                } else if (!inSingleQuote && !inDoubleQuote) {\n                    // Only adjust depth if outside quotes\n                    if (c == open) {\n                        depth++;\n                        if (start == -1) // Track the start position *after* the opening character\n                            start = pos;\n                    } else if (c == close) {\n                        depth--;\n                    }\n                }\n            }\n\n            // Check for termination condition *after* processing the character and updating depth\n            // We need depth to be 0 (balanced) and we must have found the opening char (start != -1)\n            // This ensures we capture the content between the first 'open' and its corresponding 'close'.\n            if (depth == 0 && start != -1) {\n                end = pos - 1; // The end position is the index of the closing character itself\n                break; // Exit loop successfully, we found the balanced pair\n            }\n\n            // If depth becomes negative, it means we have encountered a closing char without a matching open char.\n            // This indicates an unbalanced situation from the perspective of the initial state. Stop searching.\n             if (depth < 0) {\n                 break;\n            }\n        }\n\n        // If we found a valid end position (end >= 0), return the substring between start and end\n        if (end >= 0) {\n            return queue.substring(start, end);\n        } else {\n            // Otherwise (no match found, unbalanced, or queue ended before closing), reset position and return empty string\n            // Resetting position ensures that no progress is made if the balanced string wasn't found.\n            pos = initialPos;\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}