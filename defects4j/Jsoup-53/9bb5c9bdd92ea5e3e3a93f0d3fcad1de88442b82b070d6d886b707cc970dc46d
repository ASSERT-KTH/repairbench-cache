{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        char inQuote = 0; // 0, ' or \" - tracks if we are inside an internal quote\n        final char ESC = '\\\\'; // Jsoup's Tokeniser.ESC is '\\\\'\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume(); // pos is now after c\n\n            if (last == ESC) {\n                // Character 'c' was escaped by 'last', so it is treated as a literal.\n                // It does not affect depth or internal quote state.\n            } else {\n                if (inQuote != 0) { // Currently inside an internal quote\n                    if (c.equals(inQuote)) { // Found matching closing quote\n                        inQuote = 0; // Exit internal quote mode\n                    }\n                    // Else, consume character as part of the internal quoted string\n                } else { // Not currently inside an internal quote\n                    if (c.equals(open)) {\n                        // Special handling for when 'open' and 'close' are the same character\n                        if (open == close) {\n                            if (depth == 0) { // Found the very first opener\n                                depth++;\n                            } else { // Found the matching closer\n                                depth--;\n                            }\n                        } else { // Normal case: 'open' and 'close' are different\n                            depth++;\n                        }\n\n                        if (start == -1) // Set start position only for the first effective opening\n                            start = pos;\n                    } else if (c.equals(close)) {\n                        // This block only applies if 'open' and 'close' are different.\n                        // If 'open' == 'close', the balancing logic is handled in the 'c.equals(open)' block.\n                        if (open != close) {\n                            depth--;\n                        }\n                    } else if (c.equals('\\'') || c.equals('\"')) { // Found an opening internal quote\n                        inQuote = c; // Enter internal quote mode\n                    }\n                }\n            }\n\n            // Update end marker: as long as we are inside the balanced expression (depth > 0)\n            // and have consumed at least one char (last != 0 initially, meaning first 'open' was processed).\n            // 'pos' is the index after 'c' was consumed.\n            // 'start' is the index after the initial 'open' character.\n            // Therefore, 'queue.substring(start, end)' correctly captures content between 'open' and 'close'.\n            if (depth > 0 && last != 0) {\n                end = pos;\n            }\n\n            last = c; // Update last for the next iteration\n        } while (depth > 0); // Continue until the outermost balanced pair is closed\n\n        // If 'end' was never updated (e.g., no matching close found, or queue was empty)\n        // an empty string is returned. Otherwise, the substring is returned.\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}