{
    "generation": "    /**\n     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n     * and leave \" four\" on the queue. Unbalanced openers and closers can quoted (with ' or \") or escaped (with \\). Those escapes will be left\n     * in the returned string, which is suitable for regexes (where we need to preserve the escape), but unsuitable for\n     * contains text strings; use unescape for that.\n     * @param open opener\n     * @param close closer\n     * @return data matched from the queue\n     */\n    public String chompBalanced(char open, char close) {\n        int start = -1;\n        int end = -1;\n        int depth = 0;\n        char last = 0;\n        char quoteChar = 0; // 0 = no quote, ' = single, \" = double\n        boolean hitOpen = false; // Flag to indicate if the first 'open' char has been encountered when open == close\n\n        do {\n            if (isEmpty()) break;\n            Character c = consume();\n\n            boolean isEscaped = (last == ESC);\n\n            // Handle quote state: if 'c' is an unescaped quote character, toggle quoteChar state\n            if (!isEscaped && (c == '\\'' || c == '\"')) {\n                if (quoteChar == 0) {\n                    quoteChar = c; // Entering a quote\n                } else if (quoteChar == c) {\n                    quoteChar = 0; // Exiting a quote\n                }\n            }\n\n            // Determine if 'c' should affect depth (i.e., if it's an 'open' or 'close' character)\n            // It should affect depth if:\n            // 1. It's not escaped.\n            // 2. We are not currently in a quote, OR 'c' is the active quote character (meaning the balancing is around quotes).\n            if (!isEscaped && (quoteChar == 0 || c == quoteChar)) {\n                if (c == open) {\n                    if (open == close) { // Special case: opener and closer are the same char (e.g., ' for 'string')\n                        if (!hitOpen) { // First occurrence of this char (opener)\n                            depth++;\n                            hitOpen = true;\n                            if (start == -1) start = pos;\n                        } else { // Second occurrence of this char (closer)\n                            depth--;\n                        }\n                    } else { // Normal case: opener and closer are different chars (e.g., ()\n                        depth++;\n                        if (start == -1) start = pos;\n                    }\n                } else if (c == close) {\n                    depth--;\n                }\n            }\n\n            // 'end' is set to the position *after* the current character 'c' if depth is still positive.\n            // This ensures 'end' tracks the actual end of the content (exclusive for substring).\n            // `last != 0` ensures `end` is not set on the very first character if `depth` starts at 0 and increments.\n            if (depth > 0 && last != 0) {\n                end = pos;\n            }\n            last = c;\n        } while (depth > 0); // Continue as long as we are within a balanced pair\n\n        return (end >= 0) ? queue.substring(start, end) : \"\";\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}