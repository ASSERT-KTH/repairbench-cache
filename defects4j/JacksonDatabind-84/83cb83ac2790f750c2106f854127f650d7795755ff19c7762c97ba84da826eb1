{
    "generation": "// In TypeFactory.java\n@Override\nprotected JavaType _fromClass(Class<?> cls, TypeBindings bindings) {\n    // 1) see if we already have it\n    RawClassKey key = new RawClassKey(cls);\n    JavaType cached = _typeCache.get(key, bindings);\n    if (cached != null) {\n        return cached;\n    }\n    // 2) array?\n    if (cls.isArray()) {\n        JavaType component = _fromClass(cls.getComponentType(), bindings);\n        ArrayType at = ArrayType.construct(component, bindings, /*value handler*/null);\n        _typeCache.put(key, bindings, at);\n        return at;\n    }\n    // 3) placeholder for possible recursive types\n    SimpleType placeholder = new SimpleType(cls, bindings, null, null);\n    _typeCache.put(key, bindings, placeholder);\n\n    // 4) ALWAYS resolve raw superclass (not only ParameterizedType)\n    Type rawSup = cls.getGenericSuperclass();\n    if (rawSup != null) {\n        JavaType superClass = constructType(rawSup, bindings);\n        placeholder.setSuperClass(superClass);\n    }\n    // 5) ALWAYS resolve raw interfaces\n    Type[] rawIfaces = cls.getGenericInterfaces();\n    if (rawIfaces != null && rawIfaces.length > 0) {\n        JavaType[] intfs = new JavaType[rawIfaces.length];\n        for (int i = 0; i < rawIfaces.length; i++) {\n            intfs[i] = constructType(rawIfaces[i], bindings);\n        }\n        placeholder.setSuperInterfaces(intfs);\n    }\n\n    // 6) special container types\n    if (Map.class.isAssignableFrom(cls)) {\n        MapType mt = MapType.construct(\n            cls, bindings,\n            placeholder.getSuperClass(), placeholder.getInterfaces(),\n            /*keyType*/null, /*valueType*/null);\n        _typeCache.replace(key, bindings, mt);\n        return mt;\n    }\n    if (Collection.class.isAssignableFrom(cls)) {\n        CollectionType ct = CollectionType.construct(\n            cls, bindings,\n            placeholder.getSuperClass(), placeholder.getInterfaces());\n        _typeCache.replace(key, bindings, ct);\n        return ct;\n    }\n    // 7) otherwise simple (POJO) type\n    return placeholder;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}