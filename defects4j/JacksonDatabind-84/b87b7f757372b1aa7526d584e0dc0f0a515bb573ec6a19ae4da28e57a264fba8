{
    "generation": "@Override\nprotected JavaType _fromClass(Class<?> raw, TypeBindings bindings) {\n    ClassKey key = new ClassKey(raw, bindings);\n    // 1) check cache\n    synchronized (_typeCache) {\n        JavaType cached = _typeCache.get(key);\n        if (cached != null) {\n            return cached;\n        }\n    }\n\n    JavaType type;\n    // 2) array types\n    if (raw.isArray()) {\n        JavaType component = constructType(raw.getComponentType());\n        type = ArrayType.construct(component, bindings);\n    } else {\n        // 3) plain (non\u2010generic) types must still have their super\u2010types resolved\n        TypeVariable<?>[] vars = raw.getTypeParameters();\n        if ((vars == null || vars.length == 0) && bindings.isEmpty()) {\n            // resolve superclass\n            JavaType superClass = null;\n            Type sup = raw.getGenericSuperclass();\n            if (sup != null) {\n                superClass = _fromAny(sup, bindings);\n            }\n            // resolve interfaces\n            Type[] ints = raw.getGenericInterfaces();\n            JavaType[] superIfs = null;\n            if (ints != null && ints.length > 0) {\n                superIfs = new JavaType[ints.length];\n                for (int i = 0; i < ints.length; ++i) {\n                    superIfs[i] = _fromAny(ints[i], bindings);\n                }\n            }\n            type = SimpleType.construct(raw, superClass, superIfs);\n        } else {\n            // generic or parameterized type\n            type = _fromParamType(raw, null, bindings);\n        }\n    }\n\n    // 4) cache and return\n    synchronized (_typeCache) {\n        _typeCache.put(key, type);\n    }\n    return type;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}