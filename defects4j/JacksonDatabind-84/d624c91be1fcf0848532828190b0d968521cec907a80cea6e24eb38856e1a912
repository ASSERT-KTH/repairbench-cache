{
    "generation": "public JavaType constructType(Class<?> cls)\n{\n    // Ensure we handle type hierarchies correctly when building type information\n    // by properly tracking super types even when subtypes are loaded later\n    if (cls == null) {\n        return null;\n    }\n    // Clear or properly manage the type cache to prevent ambiguities\n    clearCachedTypes();\n    return _constructType(cls, _config.getDefaultInterfaces());\n}\n\nprotected JavaType _constructType(Class<?> cls, List<JavaType> interfaceTypes) {\n    // Ensure we properly build the hierarchy, including all inherited properties\n    Class<?> current = cls;\n    LinkedHashMap<String, Object> props = new LinkedHashMap<>();\n    Set<Class<?>> seen = new HashSet<>();\n\n    while (current != null && !current.equals(Object.class)) {\n        if (seen.contains(current)) {\n            break; // prevent infinite recursion with cyclic types\n        }\n        seen.add(current);\n\n        // Process current class\n        try {\n            // Get all fields and properties for the current class\n            Field[] fields = current.getDeclaredFields();\n            for (Field field : fields) {\n                // Only process non-static fields (simplified - real code would need more checks)\n                if (!Modifier.isStatic(field.getModifiers())) {\n                    props.putIfAbsent(field.getName(), field.getType());\n                }\n            }\n        } catch (Exception e) {\n            // handle exception\n        }\n        current = current.getSuperclass();\n    }\n\n    // Now build the actual JavaType with complete property information\n    JavaType type = super._constructType(cls, interfaceTypes);\n\n    // Make sure the type info includes all properties from the hierarchy\n    if (type instanceof ClassType) {\n        ((ClassType) type).setProperties(props);\n    }\n\n    return type;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}