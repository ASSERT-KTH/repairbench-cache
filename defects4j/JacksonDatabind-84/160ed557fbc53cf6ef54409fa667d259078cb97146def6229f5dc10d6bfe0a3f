{
    "generation": "// In TypeFactory.java, fix the \u201cno\u2010generics\u201d branch of _fromClass(...) so that it still\n// resolves the superclass and interfaces instead of dropping them:\n//\n// (Full corrected method)\nprivate JavaType _fromClass(Class<?> raw,\n                            TypeBindings parentBindings,\n                            Map<Object,ResolvedRecursiveType> rmap)\n{\n    // 1) array\u2010type?\n    if (raw.isArray()) {\n        JavaType comp = _fromClass(raw.getComponentType(),\n                                   TypeBindings.emptyBindings(),\n                                   rmap);\n        return ArrayType.construct(comp, null, null);\n    }\n\n    // 2) well\u2010known simple types (primitives, JDK8 types, etc.)\n    JavaType simple = _findWellKnownSimple(raw);\n    if (simple != null) {\n        return simple;\n    }\n\n    // 3) check for no type parameters: still must resolve super\u2010class and interfaces\n    TypeVariable<?>[] vars = raw.getTypeParameters();\n    if (vars == null || vars.length == 0) {\n        // even though there are no generics, we must pick up inheritance chain\n        JavaType superClass = _resolveSuperClass(raw, parentBindings, rmap);\n        JavaType[] superIfaces = _resolveSuperInterfaces(raw, parentBindings, rmap);\n        return new SimpleType(raw,\n                              TypeBindings.emptyBindings(),\n                              superClass,\n                              superIfaces);\n    }\n\n    // 4) generic case (unchanged) \u2013 bind type variables, detect recursion, etc.\n    //    \u2026 existing code for ParameterizedType, recursion placeholders, etc. \u2026\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}