{
    "generation": "@Override\npublic JavaType constructType(Type type) {\n    JavaType result = _typeCache.get(type);\n    if (result != null) {\n        return result;\n    }\n    HierarchicType superClass = null;\n    HierarchicType superInterface = null;\n    if (type instanceof Class<?>) {\n        Class<?> cls = (Class<?>) type;\n        // Recursively resolve supertypes FIRST to ensure correct caching\n        Class<?> superCls = cls.getSuperclass();\n        if (superCls != null) {\n            superClass = HierarchicType.valueOf(_fromClass(superCls));\n        }\n        Class<?>[] interfaces = cls.getInterfaces();\n        if (interfaces != null && interfaces.length > 0) {\n            List<HierarchicType> interfaceTypes = new ArrayList<>();\n            for (Class<?> iface : interfaces) {\n                interfaceTypes.add(HierarchicType.valueOf(_fromClass(iface)));\n            }\n            if (interfaceTypes.size() == 1) {\n                superInterface = interfaceTypes.get(0);\n            } else if (interfaceTypes.size() > 1) {\n                // Create a dummy superInterface chaining interfaces as siblings\n                HierarchicType current = interfaceTypes.get(0);\n                for (int i = 1; i < interfaceTypes.size(); i++) {\n                    current.setNextSibling(interfaceTypes.get(i));\n                }\n                superInterface = interfaceTypes.get(0);\n            }\n        }\n        result = _fromClass(cls, superClass, superInterface);\n    } else {\n        result = _fromAny(type, this);\n    }\n    _typeCache.putIfAbsent(type, result);\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}