{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.util.ClassKey;\nimport com.fasterxml.jackson.databind.util.LRUMap;\n\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * Partial re-implementation of TypeFactory to demonstrate the fix.\n * Assumes surrounding TypeFactory class, its fields, and helper methods\n * like `TypeBindings.emptyBindings()`, `TypeBindings.findBoundType()`,\n * `LRUMap`, `SimpleType.constructUnresolved()`, `ArrayType.construct()`,\n * `CollectionType.construct()`, `MapType.construct()`,\n * `JavaType.withSuperClass()`, `JavaType.withSuperInterfaces()` exist\n * and behave as in the actual Jackson library.\n */\npublic class TypeFactory {\n\n    // These fields are typically part of the TypeFactory class\n    protected final LRUMap<ClassKey, JavaType> _typeCache;\n\n    // Dummy JavaType instances for well-known types (actual TypeFactory has these)\n    protected static final JavaType _unknownType = SimpleType.constructUnresolved(Object.class);\n    protected static final JavaType _stringType = SimpleType.constructUnresolved(String.class);\n    protected static final MapType MAP_TYPE_FOR_PROPERTIES = MapType.construct(String.class, TypeBindings.emptyBindings(), _stringType, _stringType);\n\n    // Dummy constructor (actual TypeFactory has more complex setup)\n    public TypeFactory() {\n        // Default LRUMap size (e.g., from Jackson's TypeFactory)\n        _typeCache = new LRUMap<>(16, 100);\n    }\n\n    /**\n     * The fixed version of the buggy function.\n     * This method is responsible for constructing and caching JavaType instances.\n     * The fix ensures that the `_superClass` and `_superInterfaces` of a\n     * `JavaType` are fully resolved and set before the type is permanently\n     * stored in the cache, especially important when dealing with inheritance.\n     */\n    protected JavaType _fromClass(Class<?> rawType, TypeBindings bindings) {\n        // 1. Check cache for already resolved type\n        ClassKey key = new ClassKey(rawType);\n        JavaType result = _typeCache.get(key);\n        if (result != null) {\n            return result;\n        }\n\n        // 2. Handle well-known special types first (optimization)\n        if (rawType == String.class) {\n            result = _stringType;\n        } else if (rawType == Object.class) {\n            result = _unknownType;\n        } else if (rawType == java.util.Properties.class) {\n            result = MAP_TYPE_FOR_PROPERTIES;\n        }\n\n        // If it's a well-known type, cache and return early\n        if (result != null) {\n            _typeCache.put(key, result);\n            return result;\n        }\n\n        // --- FIX STARTS HERE ---\n        // For other types, place a temporary placeholder in the cache.\n        // This is critical for preventing infinite recursion when handling\n        // self-referential or deeply nested generic types.\n        // It also ensures that if `_resolveSuperClass` or `_resolveSuperInterfaces`\n        // recursively calls `_fromClass` for `rawType` itself, it finds a placeholder\n        // instead of re-entering full construction.\n\n        // Create an initial placeholder type. Its superclass/interfaces might be `_unknownType` initially.\n        SimpleType placeholderType = SimpleType.constructUnresolved(rawType);\n        // Add it to the 'holding' state of the cache. This indicates construction is in progress.\n        // (Assuming LRUMap has a `addHolding` method as in Jackson's TypeFactory)\n        _typeCache.addHolding(key, placeholderType);\n\n        try {\n            JavaType actualType;\n            if (rawType.isArray()) {\n                JavaType componentType = _fromClass(rawType.getComponentType(), bindings);\n                actualType = ArrayType.construct(componentType, bindings);\n            } else if (Map.class.isAssignableFrom(rawType)) {\n                // Simplified MapType construction; actual Jackson handles generics properly\n                actualType = MapType.construct(rawType, bindings, _unknownType, _unknownType);\n            } else if (Collection.class.isAssignableFrom(rawType)) {\n                // Simplified CollectionType construction; actual Jackson handles generics properly\n                actualType = CollectionType.construct(rawType, bindings, _unknownType);\n            } else {\n                // For regular classes (like Base and Sub), which map to SimpleType\n                actualType = placeholderType; // Use the placeholder as the base to update\n\n                // Resolve super class and interfaces. This will recursively call _fromClass.\n                // When _resolveSuperClass resolves `Base.class`, it will get it from the cache\n                // because `tf.constructType(Base.class)` already put it there.\n                JavaType superClass = _resolveSuperClass(rawType, bindings);\n                JavaType[] superInterfaces = _resolveSuperInterfaces(rawType, bindings);\n\n                // Crucially, update the placeholderType with the fully resolved superclass and interfaces.\n                // This creates a new JavaType instance (or updates the existing one effectively)\n                // that correctly links to its supertype(s).\n                actualType = actualType.withSuperClass(superClass).withSuperInterfaces(superInterfaces);\n            }\n\n            // Put the fully resolved type into the permanent cache, replacing the placeholder.\n            // (Assuming LRUMap has a `putAndResolve` method as in Jackson's TypeFactory)\n            _typeCache.putAndResolve(key, actualType);\n            return actualType;\n\n        } finally {\n            // Ensure the 'holding' state is cleared for this type key, even if an error occurred.\n            // (Assuming LRUMap has a `releaseHolding` method)\n            _typeCache.releaseHolding(key);\n        }\n    }\n\n    // --- MOCK DEPENDENCIES (as they would appear in Jackson's TypeFactory and related classes) ---\n    // These are simplified for the purpose of demonstrating the fix within the `_fromClass` method.\n    // In a real Jackson environment, these classes/methods would be fully implemented.\n\n    // Dummy TypeBindings (simplified)\n    public static class TypeBindings {\n        public static TypeBindings emptyBindings() { return new TypeBindings(); }\n        // Simplified: in real Jackson, this resolves bound types\n        public JavaType findBoundType(Type type) { return TypeFactory.defaultInstance()._unknownType; }\n    }\n\n    // Dummy JavaType and its subclasses (Jackson hierarchy simplified)\n    public static class JavaType {\n        protected Class<?> _class;\n        protected TypeBindings _bindings;\n        protected JavaType _superClass;\n        protected JavaType[] _superInterfaces;\n\n        protected JavaType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n            this._class = rawType;\n            this._bindings = bindings;\n            this._superClass = superClass;\n            this._superInterfaces = superInterfaces;\n        }\n        protected JavaType(Class<?> rawType) { this._class = rawType; } // For basic construction like _unknownType\n\n        public Class<?> getRawClass() { return _class; }\n        public JavaType getSuperClass() { return _superClass; }\n\n        public JavaType withSuperClass(JavaType superClass) {\n            if (superClass == _superClass) return this;\n            return _construct(superClass, _superInterfaces);\n        }\n        public JavaType withSuperInterfaces(JavaType[] superInterfaces) {\n            // NOTE: Deep comparison needed in real impl\n            // Simplified check: if (superInterfaces == _superInterfaces) return this;\n            return _construct(_superClass, superInterfaces);\n        }\n        \n        protected JavaType _construct(JavaType superClass, JavaType[] superInterfaces) {\n            // This method would be implemented by concrete subclasses (SimpleType etc.)\n            // For SimpleType, it would be `new SimpleType(this.getRawClass(), _bindings, superClass, superInterfaces);`\n            throw new UnsupportedOperationException(\"Subclasses must implement _construct\");\n        }\n    }\n\n    public static class SimpleType extends JavaType {\n        protected SimpleType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n            super(rawType, bindings, superClass, superInterfaces);\n        }\n        protected SimpleType(Class<?> rawType) { super(rawType); } // For basic construction\n        public static SimpleType constructUnresolved(Class<?> rawType) {\n            // Initially, superclass is _unknownType as a placeholder\n            return new SimpleType(rawType, TypeBindings.emptyBindings(), _unknownType, null);\n        }\n        @Override protected JavaType _construct(JavaType superClass, JavaType[] superInterfaces) {\n            return new SimpleType(this.getRawClass(), _bindings, superClass, superInterfaces);\n        }\n    }\n\n    public static class ArrayType extends JavaType {\n        protected ArrayType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { super(rawType, bindings, superClass, superInterfaces); }\n        public static ArrayType construct(JavaType componentType, TypeBindings bindings) {\n            return new ArrayType(componentType.getRawClass().arrayType(), bindings, null, null);\n        }\n        @Override protected JavaType _construct(JavaType superClass, JavaType[] superInterfaces) {\n            return new ArrayType(this.getRawClass(), _bindings, superClass, superInterfaces);\n        }\n    }\n\n    public static class CollectionType extends JavaType {\n        protected CollectionType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { super(rawType, bindings, superClass, superInterfaces); }\n        public static CollectionType construct(Class<?> rawType, TypeBindings bindings, JavaType elementType) {\n            return new CollectionType(rawType, bindings, _unknownType, null);\n        }\n        @Override protected JavaType _construct(JavaType superClass, JavaType[] superInterfaces) {\n            return new CollectionType(this.getRawClass(), _bindings, superClass, superInterfaces);\n        }\n    }\n\n    public static class MapType extends JavaType {\n        protected MapType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) { super(rawType, bindings, superClass, superInterfaces); }\n        public static MapType construct(Class<?> rawType, TypeBindings bindings, JavaType keyType, JavaType valueType) {\n            return new MapType(rawType, bindings, _unknownType, null);\n        }\n        @Override protected JavaType _construct(JavaType superClass, JavaType[] superInterfaces) {\n            return new MapType(this.getRawClass(), _bindings, superClass, superInterfaces);\n        }\n    }\n\n    // Internal helper methods for resolving supertypes (as they would appear in TypeFactory)\n    protected JavaType _resolveSuperClass(Class<?> rawType, TypeBindings bindings) {\n        Class<?> superClass = rawType.getSuperclass();\n        if (superClass == null || superClass == Object.class) {\n            return _unknownType;\n        }\n        Type genericSuperclass = rawType.getGenericSuperclass();\n        // Recursively resolve the super class type, passing relevant bindings\n        return _fromClass(superClass, bindings.findBoundType(genericSuperclass));\n    }\n\n    protected JavaType[] _resolveSuperInterfaces(Class<?> rawType, TypeBindings bindings) {\n        Type[] interfaces = rawType.getGenericInterfaces();\n        if (interfaces == null || interfaces.length == 0) {\n            return null;\n        }\n        JavaType[] resolved = new JavaType[interfaces.length];\n        for (int i = 0; i < interfaces.length; i++) {\n            Type genericInterface = interfaces[i];\n            resolved[i] = _fromClass((Class<?>) genericInterface, bindings.findBoundType(genericInterface));\n        }\n        return resolved;\n    }\n\n    // Dummy LRUMap (simplified for TypeFactory context)\n    public static class LRUMap<K, V> extends java.util.LinkedHashMap<K, V> {\n        protected final int _maxEntries;\n        private HashMap<K, V> _holding; // Simplified 'holding' mechanism\n\n        public LRUMap(int initialEntries, int maxEntries) {\n            super(initialEntries, 0.8f, true);\n            _maxEntries = maxEntries;\n            _holding = new HashMap<>();\n        }\n\n        @Override protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n            return size() > _maxEntries;\n        }\n\n        @Override public V put(K key, V value) {\n            _holding.remove(key); // Remove from holding if it was there\n            return super.put(key, value);\n        }\n\n        @Override public V get(Object key) {\n            V value = _holding.get(key); // Check holding first\n            if (value != null) return value;\n            return super.get(key);\n        }\n\n        public void addHolding(K key, V value) {\n            _holding.put(key, value);\n        }\n\n        public void putAndResolve(K key, V value) {\n            put(key, value); // Puts into main cache, removes from holding\n        }\n\n        public void releaseHolding(K key) {\n            _holding.remove(key);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}