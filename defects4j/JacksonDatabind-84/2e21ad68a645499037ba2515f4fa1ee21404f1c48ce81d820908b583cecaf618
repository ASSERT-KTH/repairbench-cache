{
    "generation": "protected JavaType _fromClass(Class<?> cls, TypeBindings context) {\n    // First, see if a fully resolved type is already cached\n    ClassKey key = new ClassKey(cls);\n    JavaType result = _typeCache.get(key);\n    if (result != null) {\n        return result;\n    }\n    // Check for a placeholder already created to handle recursive types\n    ResolvedRecursiveType rec = _incomplete.get(key);\n    if (rec != null) {\n        return rec;\n    }\n    // Create a placeholder to detect recursion while building the type\n    ResolvedRecursiveType placeholder = new ResolvedRecursiveType(cls, context);\n    _incomplete.put(key, placeholder);\n\n    // Build the full JavaType according to the kind of class\n    if (cls.isArray()) {\n        result = _fromArrayClass(cls, context);\n    } else if (Map.class.isAssignableFrom(cls)) {\n        result = _fromMapClass(cls, context);\n    } else if (Collection.class.isAssignableFrom(cls)) {\n        result = _fromCollectionClass(cls, context);\n    } else {\n        result = _fromBeanType(cls, context);\n    }\n    // FIX: Make sure that any recursive references are properly resolved.\n    // This ensures that properties from super types (such as Base) are included\n    // even if the type was pre-registered as a placeholder.\n    placeholder.resolveSelfReferences(result);\n\n    // Now remove the placeholder and cache the fully resolved type.\n    _incomplete.remove(key);\n    _typeCache.put(key, result);\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}