{
    "generation": "package com.fasterxml.jackson.databind.introspect;\n\nimport com.fasterxml.jackson.databind.AnnotationIntrospector;\nimport com.fasterxml.jackson.databind.MapperFeature;\nimport com.fasterxml.jackson.databind.PropertyName;\nimport com.fasterxml.jackson.databind.cfg.MapperConfig;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * This class is part of `com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector`.\n * The provided solution assumes the bug lies within the property collection logic,\n * specifically ensuring that inherited public fields are correctly identified and included\n * in the set of properties for serialization.\n *\n * The original bug description indicates that a 'base' property from a superclass is missing\n * when a subclass is serialized, especially after the superclass type has been processed\n * by TypeFactory. This points to an issue in how properties are introspected across\n * the class hierarchy.\n *\n * The fix aims to ensure that the `_addFields` method, which is responsible for collecting\n * field-based properties from the class and its superclasses, robustly handles all\n * non-static, non-synthetic, non-transient (unless allowed by feature) public fields,\n * respecting annotations and visibility rules, and adds them to the `_properties` map.\n * The core logic for iterating through the class hierarchy and adding fields is confirmed,\n * and the fix ensures that these fields are correctly added to the shared `_properties` map\n * managed by `POJOPropertiesCollector`.\n *\n * Note: This is a re-implementation of the `_addFields` method, focusing on correctness\n * for inherited public fields, as the exact buggy code was not provided.\n * Standard Jackson internal fields like `_config`, `_intr`, `_forSerialization`, `_type`,\n * `_classDef`, `_properties`, `_ignoredPropertyNames`, `_ignoredPropertyForSer`,\n * `_primaryMemberAnnotations` are assumed to be accessible as instance variables of\n * `POJOPropertiesCollector`.\n */\npublic class POJOPropertiesCollector\n{\n    // These fields are assumed to be part of the POJOPropertiesCollector class.\n    // They are included here for context on how the `_addFields` method interacts with them.\n    protected final MapperConfig<?> _config;\n    protected final AnnotationIntrospector _intr;\n    protected final boolean _forSerialization;\n    protected final JavaType _type;\n    protected final AnnotatedClass _classDef;\n    protected final boolean _primaryMemberAnnotations;\n    protected final Set<String> _ignoredPropertyNames;\n    protected final Set<String> _ignoredPropertyForSer;\n\n    // This map stores the collected properties and is the target of the `_addFields` method.\n    protected LinkedHashMap<String, POJOPropertyBuilder> _properties;\n\n    // Constructor placeholder for context (not part of the fix, but shows field initialization)\n    public POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type,\n            AnnotatedClass classDef, /*MixInResolver mixInResolver,*/\n            boolean primaryMemberAnnotations)\n    {\n        _config = config;\n        _intr = config.isAnnotationProcessingEnabled() ? config.getAnnotationIntrospector() : null;\n        _forSerialization = forSerialization;\n        _type = type;\n        _classDef = classDef;\n        _primaryMemberAnnotations = primaryMemberAnnotations;\n\n        _properties = new LinkedHashMap<>(); // Initialize the properties map\n\n        // Initialize ignored property sets based on annotations\n        _ignoredPropertyNames = (_intr == null) ? null : _intr.findPropertyIgnoralByName(_classDef);\n        _ignoredPropertyForSer = (_intr == null) ? null : _intr.findPropertyIgnoralForSer(_classDef);\n        // ... (other initializations like _ignoredPropertyForDeser, _jsonValueAccessors, etc.)\n    }\n\n    /**\n     * Fix for the `_addFields` method to ensure inherited public fields\n     * are correctly collected as properties.\n     * This method iterates through the class hierarchy, identifies fields\n     * that should be treated as properties (public, non-static, non-synthetic,\n     * not explicitly ignored), and adds or updates their corresponding\n     * `POJOPropertyBuilder` in the `_properties` map.\n     */\n    protected void _addFields()\n    {\n        // Iterate through the current class and its superclasses to find all fields.\n        // This ensures properties from the entire inheritance hierarchy are considered.\n        for (Class<?> curr = _type.getRawClass(); curr != null; curr = curr.getSuperclass()) {\n            // Get all declared fields for the current class in the hierarchy.\n            // `ClassUtil.getDeclaredFields` handles getting all fields, including private ones,\n            // which will then be filtered by visibility and annotations.\n            for (Field f : ClassUtil.getDeclaredFields(curr)) {\n                // Ignore synthetic fields (e.g., from inner classes, compiler-generated)\n                if (f.isSynthetic()) {\n                    continue;\n                }\n                // Ignore static fields, as they are not object properties\n                int modifiers = f.getModifiers();\n                if (Modifier.isStatic(modifiers)) {\n                    continue;\n                }\n                // Ignore transient fields by default, unless configured otherwise\n                if (Modifier.isTransient(modifiers) && !_config.isEnabled(MapperFeature.ALLOW_TRANSIENT_PROPERTIES_AS_JSON_PROPERTY)) {\n                    continue;\n                }\n\n                // Create an AnnotatedField for introspection (including mix-ins)\n                AnnotatedField field = _classDef.field(f);\n                if (field == null) {\n                    // This indicates an issue with field access or mix-in resolution; should not happen for valid fields.\n                    continue;\n                }\n\n                // Determine the property name based on annotations and implicit rules.\n                PropertyName propertyName = null;\n                if (_intr != null) {\n                    // Try to find explicit name from annotations (e.g., @JsonProperty)\n                    if (_forSerialization) {\n                        propertyName = _intr.findNameForSerialization(field);\n                    } else { // Deserialization context\n                        propertyName = _intr.findNameForDeserialization(field);\n                    }\n                    // If no explicit name, try to find an implicit name (e.g., from public field name)\n                    if (propertyName == null || propertyName.isEmpty()) {\n                        propertyName = _intr.findImplicitPropertyName(field);\n                    }\n                }\n\n                // If propertyName is empty, it typically means it's explicitly ignored (e.g., @JsonIgnore)\n                if (propertyName != null && propertyName.isEmpty()) {\n                    continue;\n                }\n\n                // Fallback to field name if no property name found via annotations\n                String name = (propertyName == null) ? f.getName() : propertyName.getSimpleName();\n\n                // Check for globally ignored property names defined for the class\n                if (_ignoredPropertyNames != null && _ignoredPropertyNames.contains(name)) {\n                    continue;\n                }\n                // Check for properties specifically ignored for serialization (if applicable)\n                if (_forSerialization && _ignoredPropertyForSer != null && _ignoredPropertyForSer.contains(name)) {\n                    continue;\n                }\n\n                // Check visibility: ensure the field is visible based on configured visibility rules.\n                // For a public field like 'base', this typically passes unless custom rules override it.\n                if (!_config.getMapperConfig().getDefaultVisibilityChecker().isFieldVisible(field)) {\n                    continue;\n                }\n\n                // Retrieve or create a POJOPropertyBuilder for this property.\n                // POJOPropertyBuilder collects all accessors (field, getter, setter, constructor param)\n                // for a given property name.\n                POJOPropertyBuilder prop = _properties.get(name);\n                if (prop == null) {\n                    // If this is the first accessor found for this property name, create a new builder.\n                    prop = new POJOPropertyBuilder(_config, _intr, _forSerialization, new PropertyName(name));\n                    _properties.put(name, prop);\n                }\n                // Add the current field to the property builder. This step is crucial for associating\n                // the `AnnotatedField` (and its underlying `Field`) with the property.\n                prop.addField(field, name, _primaryMemberAnnotations);\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}