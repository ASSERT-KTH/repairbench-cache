{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.Type;\nimport java.util.concurrent.ConcurrentHashMap;\n\n// This method would be part of `com.fasterxml.jackson.databind.type.TypeFactory`\n// Assuming necessary helper methods and fields (like _typeCache, _voidType, _unknownType,\n// _resolveSuperClass, _resolveSuperInterfaces, ResolvedTypeKey, ClassType, TypeBindings, ClassStack)\n// are defined within the TypeFactory class or its context.\npublic class TypeFactory {\n\n    // ... (existing TypeFactory fields and constructors) ...\n\n    protected JavaType _fromAny(ClassStack classStack, Type type, TypeBindings bindings) {\n        // 1. Check cache first\n        ResolvedTypeKey key = new ResolvedTypeKey(type, bindings);\n        JavaType result = _typeCache.get(key);\n        if (result != null) {\n            return result;\n        }\n\n        // 2. Handle Class<?> types, which covers Base and Sub classes\n        if (type instanceof Class<?>) {\n            Class<?> rawType = (Class<?> ) type;\n\n            if (rawType == Void.class || rawType == Void.TYPE) {\n                return _voidType();\n            }\n\n            // Add to stack to detect and prevent infinite recursion during type construction.\n            classStack.add(rawType);\n\n            try {\n                // Recursively resolve super class and interfaces.\n                // These calls will internally use _constructType, which in turn calls _fromAny,\n                // potentially retrieving already constructed types from the cache.\n                JavaType superClass = _resolveSuperClass(rawType, bindings);\n                JavaType[] superInterfaces = _resolveSuperInterfaces(rawType, bindings);\n\n                // Construct the actual type (e.g., ClassType for simple classes like Base and Sub).\n                // This instance now holds references to its fully resolved super class and interfaces.\n                result = new ClassType(rawType, bindings, superClass, superInterfaces,\n                        null, null, false); // Placeholder for valueHandler, typeHandler, asStatic\n\n                // CRUCIAL FIX: Ensure that the *fully resolved* JavaType is put into the cache.\n                // In previous versions or subtle race conditions, a temporary or incomplete\n                // type might have been cached earlier, leading to issues like missing properties\n                // when a dependent type (like Sub) retrieves it. By putting the final,\n                // complete 'result' here, we ensure consistency.\n                _typeCache.put(key, result);\n                return result;\n\n            } finally {\n                // Always remove the type from the stack after processing.\n                classStack.resolve(rawType);\n            }\n        }\n\n        // --- Other type handling (e.g., ParameterizedType, GenericArrayType, WildcardType)\n        // would typically be implemented here in a complete TypeFactory._fromAny method. ---\n\n        // Fallback for types that are not handled by the specific logic (e.g., unknown types)\n        return _unknownType();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}