{
    "generation": "protected JavaType _fromClass(Class<?> rawClass, TypeBindings context) {\n    // First check whether we already have a type for this class.\n    JavaType cached = _findCachedType(rawClass);\n    if (cached != null) {\n        // Even if found, for proper inheritance we must ensure that the\n        // \"super type\" is up-to-date. If the raw class has a non-Object superclass,\n        // force a re-resolution of its type and \u201cattach\u201d it to the cached type.\n        Class<?> superClass = rawClass.getSuperclass();\n        if (superClass != null && superClass != Object.class) {\n            JavaType actualSuper = constructType(superClass);\n            // If the cached type\u2019s super-type is missing or outdated, update it.\n            if (cached.getSuperClass() == null || !cached.getSuperClass().equals(actualSuper)) {\n                return ((SimpleType) cached).withSuperClass(actualSuper);\n            }\n        }\n        return cached;\n    }\n    // No cached value yet: create a new SimpleType instance.\n    SimpleType result = SimpleType.construct(rawClass, context);\n    // Add the new (as yet incomplete) type to the cache to handle potential cyclic references.\n    _addCachedType(rawClass, result);\n    // If the class has a superclass (other than Object), resolve and attach it.\n    Class<?> superClass = rawClass.getSuperclass();\n    if (superClass != null && superClass != Object.class) {\n        JavaType superType = constructType(superClass);\n        result = result.withSuperClass(superType);\n        _updateCachedType(rawClass, result);\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}