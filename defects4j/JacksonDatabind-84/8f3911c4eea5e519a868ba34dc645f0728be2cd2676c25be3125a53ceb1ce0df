{
    "generation": "    protected SimpleType _constructSimple(Class<?> raw, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces)\n    {\n        // If type is already being constructed, return placeholder\n        // 19-Oct-2015, tatu: As per [databind#923], need to handle recursive types.\n        if (_typeCache.isSeen(raw)) {\n            // 14-Mar-2017, tatu: For deser, needs to handle BINDINGS for Lists/Maps...\n            //    (for other types too? For now this seems to work)\n            // 06-Apr-2017, tatu: Actually, probably HAS to be for all types?\n            return new ResolvedRecursiveType(raw, bindings);\n        }\n\n        // Not seen before: create the type, add placeholder into cache\n        ResolvedRecursiveType selfRef = new ResolvedRecursiveType(raw, bindings);\n        _typeCache.put(raw, selfRef);\n\n        // Super-class, interfaces may be null... seems like they should not be,\n        // but let's handle that just in case...\n        if (superClass == null) {\n            // should not happen for anything other than Object.class, and for that\n            // we probably don't call this method\n            superClass = _findSuperType(raw, raw, bindings);\n        }\n        JavaType[] sInterfaces = (superInterfaces == null) ?\n                _findSuperInterfaces(raw, raw, bindings) : superInterfaces;\n\n        SimpleType st = new SimpleType(raw, bindings, superClass, sInterfaces);\n        // If we have TypeHandlers/ValueHandlers for super-classes, they may be usable\n        // (through subtype-check)\n        // Needed for [#1378]: make sure TypeModifier-specified handlers are attached\n        //    asap. NOTE! Does not seem like a good place, interferes with other handlers?\n        /*\n        if (superClass != null) {\n            JavaType actual = st.refine(raw, bindings, superClass, sInterfaces);\n            if (actual != null) {\n                st = (SimpleType) actual;\n            }\n        }\n        */\n        selfRef.setReference(st);\n        return st;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}