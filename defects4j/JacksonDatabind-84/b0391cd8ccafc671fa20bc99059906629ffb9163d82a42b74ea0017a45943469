{
    "generation": "// Method from jackson-databind/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n// Contains fixes for handling recursive types and caching issues that could lead to\n// incomplete hierarchy resolution, addressing problems like the one described in the test case.\n\n    /**\n     * Low-level factory method for constructing {@link JavaType} instance for given\n     * JDK Class; using specified bindings.\n     * Overridable by subclasses.\n     *<p>\n     * NOTE: was named `_fromClass` up to 2.6\n     */\n    protected JavaType _fromClass(Class<?> cl, TypeBindings bindings)\n    {\n        // First: a quick check for basic types\n        // 18-Feb-2016, tatu: As per [databind#1105], need to allow forcing of Object type\n        if (cl == String.class) return CORE_TYPE_STRING;\n        if (cl == Object.class) return CORE_TYPE_OBJECT;\n        // Boolean wrappers are tricky, since seemingly JDK designers decided that\n        // Boolean.TYPE and Boolean.class should not compare equal...\n        if (cl == Boolean.class) return CORE_TYPE_BOOLEAN;\n        if (cl == Integer.class) return CORE_TYPE_INT;\n        if (cl == Long.class) return CORE_TYPE_LONG;\n\n        // Maybe already in cache?\n        final String key = cl.getName();\n        JavaType type = _typeCache.get(key);\n\n        if (type != null) {\n            // 16-Feb-2016, tatu: As per [databind#1107], need to consider type bindings.\n            //   Basically, always resolve type bindings, but only handle self-refs\n            //   if type found is the same as passed-in class.\n            if (_verifyAndResolvePlaceholders(cl, bindings)) {\n                 // TODO: \u0989\u09a8\u09cd\u09a8\u09af\u09bc\u09a8 !!! FIXME: 13-Oct-2016, tatu: Should not create new type but modify\n                 //     existing one(s), because type itself may be key in identity caches.\n                 //     ... perhaps need to use recursive types for this?\n                 // 21-Feb-2017, tatu: Actually, seems like placeholders DO work ok like this...\n                 //     so maybe this was ok all along?\n\n                // Ok, then: need to resolve super types\n                JavaType[] parameterTypes = bindings.isEmpty() ? NO_TYPES : bindings.getTypeParameters();\n                 // must figure out super class and interface definitions\n                JavaType superClass = cl.isInterface() ? null : _resolveSuperClass(cl, bindings);\n                JavaType[] superInterfaces = cl.isInterface() ? _resolveSuperInterfaces(cl, bindings) : _resolveSuperInterfaces(cl, bindings);\n\n                // 17-Feb-2017, tatu: D'oh! Must use placeholders, can not just construct...\n                // And finally, create the actual concrete type\n                type = new SimpleType(cl, bindings, superClass, superInterfaces,\n                        type.getValueHandler(), type.getTypeHandler(), type.isAsValue());\n\n                // Important: re-resolve reference type:\n                ResolvedRecursiveType selfRef = _findRecursiveType(cl);\n                if (selfRef != null) {\n                    selfRef.setReference(type);\n                }\n\n            } else if (!bindings.isEmpty()) {\n                // If bindings fine, but type had different ones, need to create new instance\n                 TypeBindings oldBindings = type.getBindings();\n                if (!bindings.equals(oldBindings)) {\n                     type = _constructSimple(cl, bindings, type.getSuperClass(), type.getInterfaces());\n                 }\n            }\n            return type;\n        }\n\n        // 16-Feb-2016, tatu: If not in cache, need to build it then\n        // Use placeholders to handle recursive definitions (handling depends\n        // on whether type has actual generic parameters)\n        ResolvedRecursiveType selfRef = _findRecursiveType(cl);\n        if (selfRef != null) { // has generic types that use recursion?\n            // TODO: 21-Feb-2017, tatu: Need to verify we don't have different bindings... ?\n\n            // Note: must create temporary instance to allow resolution of contained types;\n            // placeholder is resolved once reference itself is finished.\n            // important: MUST SET PLACEHOLDER reference before resolving supertypes\n            PlaceholderForType placeHolder = new PlaceholderForType(0);\n            selfRef.setReference(placeHolder);\n            // must figure out super class and interface definitions\n            JavaType superClass = cl.isInterface() ? null : _resolveSuperClass(cl, bindings);\n            JavaType[] superInterfaces = cl.isInterface() ? _resolveSuperInterfaces(cl, bindings) : _resolveSuperInterfaces(cl, bindings);\n\n            type = new SimpleType(cl, bindings, superClass, superInterfaces,\n                    null, null, false);\n            placeHolder.actualType(type);\n        } else {\n            // Add placeholder to cache now, for found recursive types:\n            ResolvedRecursiveType resolvedRecursiveType = new ResolvedRecursiveType(cl, bindings);\n             _typeCache.put(key, resolvedRecursiveType);\n\n            // must figure out super class and interface definitions\n            JavaType superClass = cl.isInterface() ? null : _resolveSuperClass(cl, bindings);\n            JavaType[] superInterfaces = cl.isInterface() ? _resolveSuperInterfaces(cl, bindings) : _resolveSuperInterfaces(cl, bindings);\n\n            type = new SimpleType(cl, bindings,\n                    superClass, superInterfaces,\n                    null, null, false); // NO value/type handlers are assigned to non-concrete types\n             resolvedRecursiveType.setReference(type);\n         }\n        return type;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    // Helper method needed due to oddity of Field.getGenericType()\n    protected JavaType _fromAny(Class<?> cl, TypeBindings bindings)\n    {\n        JavaType type;\n        if (cl.isArray()) {\n            type = ArrayType.construct(_fromAny(cl.getComponentType(), bindings), bindings);\n        } else {\n            // Trivial cases: classes without type parameters\n            // (note: includes primitives too, due to conversion to/from wrappers)\n            if (!cl.isInterface() && !Modifier.isAbstract(cl.getModifiers())) {\n                 // Most types are basic concrete classes...\n                 type = _fromClass(cl, bindings);\n            } else {\n                 // but interfaces and abstract classes need different handling.\n                 type = _fromClass(cl, bindings);\n                 // And for abstract types, may need to link type parameters\n                 JavaType superClass = type.getSuperClass();\n                 if ((superClass != null) && (superClass.getRawClass() == Object.class)) {\n                      JavaType betterSuperClass = _resolveSuperClass(cl, bindings);\n                      if (betterSuperClass != null) {\n                           ((SimpleType) type).setSuperClass(betterSuperClass);\n                      }\n                 }\n            }\n        }\n        // Otherwise, may need to apply modifiers:\n        if (_modifiers != null) {\n            TypeBindings b = type.getBindings();\n            if (b == null) {\n                b = TypeBindings.emptyBindings();\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(type, cl, b, this);\n                if (t == null) { // sanity check\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s (of type %s) return null for type %s\",\n                            mod, mod.getClass().getName(), type));\n                }\n                type = t;\n            }\n        }\n        return type;\n    }\n\n    // Helper method introduced in 2.7.1\n    private boolean _verifyAndResolvePlaceholders(Class<?> cl, TypeBindings bindings) {\n        // If type has bindings, need to verify that placeholders are resolved\n        if (!bindings.isEmpty()) {\n            ResolvedRecursiveType selfRef = _findRecursiveType(cl);\n            if (selfRef != null) {\n                // 21-Feb-2017, tatu: If yes, it MUST have been fully resolved; if not,\n                //   within-method recursion would lead to issues. So need to check\n                if (selfRef.isResolved()) {\n                     return false; // already resolved, do not update\n                 }\n                 return true; // not resolved, need to update\n             }\n         }\n         return false;\n    }\n\n    // Helper method introduced in 2.7.1\n    private ResolvedRecursiveType _findRecursiveType(Class<?> cl) {\n        JavaType t = _typeCache.get(cl.getName());\n        if (t instanceof ResolvedRecursiveType) {\n             return (ResolvedRecursiveType) t;\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}