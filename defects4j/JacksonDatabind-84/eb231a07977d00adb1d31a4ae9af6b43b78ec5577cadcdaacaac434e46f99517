{
    "generation": "package com.fasterxml.jackson.databind.type;\n\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n// Assume TypeFactory has its necessary fields and helper methods,\n// such as _typeCache and helper methods for constructing various types.\n// This is a simplified version focusing on the core fix for _fromClass.\n\npublic class TypeFactory\n    implements java.io.Serializable // implements methods like _fromClass\n{\n    private static final long serialVersionUID = 1L;\n\n    // Standard Jackson TypeFactory fields, simplified for context:\n    protected final Map<Object, JavaType> _typeCache = new ConcurrentHashMap<>(100, 0.5f, 4);\n\n    // Other TypeFactory fields and constructors omitted for brevity as they are not the 'buggy function'.\n    // For demonstration, we'll assume defaultInstance() is the entry point.\n    public static TypeFactory defaultInstance() {\n        return new TypeFactory(); // Simplified\n    }\n\n    // Simplified constructType methods\n    public JavaType constructType(Class<?> rawType) {\n        return _fromClass(rawType, TypeBindings.emptyBindings());\n    }\n\n    // The problematic function is likely this one or a method it calls\n    // that fails to correctly establish the superclass link.\n    // This is a re-implementation focusing on the fix.\n    protected JavaType _fromClass(Class<?> rawType, TypeBindings bindings)\n    {\n        // 1. Check cache first\n        // In real TypeFactory, key generation is more complex (TypeKey)\n        JavaType result = _typeCache.get(rawType); // Simplified key for demonstration\n        if (result != null) {\n            // IMPORTANT: In a real TypeFactory, there's a check `result.isResolved()`\n            // to ensure a placeholder from a recursive call is fully updated.\n            // For this specific bug, the cached type for Sub might just be missing its _superClass.\n            // The fix ensures it's correct before caching.\n            return result;\n        }\n\n        // Handle primitive types, arrays, etc. (simplified)\n        if (rawType.isPrimitive()) {\n            return _fromWellKnownClass(rawType, TypeBindings.emptyBindings());\n        }\n        if (rawType.isArray()) {\n            // Simplified: array types handle their component, not superclass\n            return ArrayType.construct(_fromClass(rawType.getComponentType(), bindings), null, null);\n        }\n        \n        // Handle common collections/maps (simplified)\n        if (Collection.class.isAssignableFrom(rawType)) {\n             // Will eventually call _fromClass for component type\n            return CollectionType.construct(rawType, bindings, null, null, null);\n        }\n        if (Map.class.isAssignableFrom(rawType)) {\n            // Will eventually call _fromClass for key/value types\n            return MapType.construct(rawType, bindings, null, null, null, null);\n        }\n        \n        // --- Core fix area for SimpleType inheritance ---\n        \n        // Before creating the JavaType, recursively resolve superclass and interfaces.\n        // This ensures that when we construct 'newType', its dependencies are already resolved.\n        JavaType superClass = null;\n        Type superclassType = rawType.getGenericSuperclass();\n        if (superclassType != null && !Object.class.equals(rawType.getSuperclass())) {\n            // Recursively construct the superclass type\n            superClass = _fromType(superclassType, bindings);\n        }\n\n        List<JavaType> superInterfaces = null;\n        Type[] genericInterfaces = rawType.getGenericInterfaces();\n        if (genericInterfaces != null && genericInterfaces.length > 0) {\n            superInterfaces = new ArrayList<>(genericInterfaces.length);\n            for (Type intType : genericInterfaces) {\n                superInterfaces.add(_fromType(intType, bindings));\n            }\n        }\n        \n        // Create the new type (e.g., SimpleType for Base and Sub classes)\n        // Pass the resolved superclass and interfaces directly into the constructor.\n        // This is crucial: ensures the JavaType object created and cached is complete.\n        JavaType newType = SimpleType.construct(rawType, bindings, superClass,\n                                             superInterfaces == null ? null : superInterfaces.toArray(new JavaType[0]));\n\n        // Add to cache *after* it's fully constructed with its superclass/interfaces.\n        // In some advanced scenarios (recursive types like `Node<T extends Node<T>>`),\n        // a placeholder might be put in cache earlier, then updated.\n        // For this specific issue, ensuring the superclass is part of the initial construction is key.\n        _typeCache.put(rawType, newType); // Simplified: assumes rawType is sufficient key\n\n        return newType;\n    }\n\n    // Helper methods (simplified/dummy for context)\n    protected JavaType _fromType(Type type, TypeBindings bindings) {\n        if (type instanceof Class) {\n            return _fromClass((Class<?>) type, bindings);\n        }\n        // Handle parameterized types, type variables etc.\n        // Real TypeFactory has complex logic for ParameterizedType, GenericArrayType, WildcardType etc.\n        return SimpleType.construct(Object.class); // Dummy for other types\n    }\n\n    private JavaType _fromWellKnownClass(Class<?> rawType, TypeBindings bindings) {\n        // Dummy implementation for well-known types like primitives\n        if (rawType == Integer.TYPE) return ResolvedPrimitiveType.INT_TYPE;\n        if (rawType == Long.TYPE) return ResolvedPrimitiveType.LONG_TYPE;\n        // ... other primitives\n        return SimpleType.construct(rawType, bindings, null, null);\n    }\n}\n\n// Dummy/Simplified classes needed for the above TypeFactory method to compile\n// In a real Jackson context, these are full classes.\nclass JavaType implements java.io.Serializable {\n    protected final Class<?> _class;\n    protected final TypeBindings _bindings;\n    protected final JavaType _superClass;\n    protected final JavaType[] _superInterfaces;\n\n    protected JavaType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        _class = rawType;\n        _bindings = bindings;\n        _superClass = superClass;\n        _superInterfaces = superInterfaces;\n    }\n\n    public Class<?> getRawClass() { return _class; }\n    public JavaType getSuperClass() { return _superClass; }\n\n    // Simplified methods for testing context\n    public boolean isResolved() { return true; } // For this fix, assume it's resolved after construction\n}\n\nclass SimpleType extends JavaType {\n    private SimpleType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        super(rawType, bindings, superClass, superInterfaces);\n    }\n\n    public static SimpleType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces) {\n        return new SimpleType(rawType, bindings, superClass, superInterfaces);\n    }\n    public static SimpleType construct(Class<?> rawType) { // For simple cases\n        return new SimpleType(rawType, TypeBindings.emptyBindings(), null, null);\n    }\n}\n\nclass ArrayType extends JavaType {\n    protected final JavaType _componentType;\n    protected ArrayType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces, JavaType componentType) {\n        super(rawType, bindings, superClass, superInterfaces);\n        _componentType = componentType;\n    }\n    public static ArrayType construct(JavaType componentType, TypeBindings bindings, Object owner) {\n        // Simplified: real ArrayType has more logic for owner, etc.\n        return new ArrayType(componentType.getRawClass().arrayType(), TypeBindings.emptyBindings(), null, null, componentType);\n    }\n}\n\nclass CollectionType extends JavaType {\n    protected CollectionType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces, JavaType elementType) {\n        super(rawType, bindings, superClass, superInterfaces);\n    }\n    public static CollectionType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces, JavaType elementType) {\n        return new CollectionType(rawType, bindings, superClass, superInterfaces, elementType);\n    }\n}\n\nclass MapType extends JavaType {\n    protected MapType(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces, JavaType keyType, JavaType valueType) {\n        super(rawType, bindings, superClass, superInterfaces);\n    }\n    public static MapType construct(Class<?> rawType, TypeBindings bindings, JavaType superClass, JavaType[] superInterfaces, JavaType keyType, JavaType valueType) {\n        return new MapType(rawType, bindings, superClass, superInterfaces, keyType, valueType);\n    }\n}\n\nclass TypeBindings {\n    public static TypeBindings emptyBindings() { return new TypeBindings(); }\n    // Dummy methods for TypeBindings\n}\n\nclass ResolvedPrimitiveType {\n    public static final JavaType INT_TYPE = SimpleType.construct(Integer.TYPE);\n    public static final JavaType LONG_TYPE = SimpleType.construct(Long.TYPE);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}