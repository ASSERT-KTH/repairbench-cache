{
    "generation": "// Located in com.fasterxml.jackson.databind.type.TypeFactory\n@SuppressWarnings(\"resource\")\nprotected JavaType _fromClass(HierarchicType ctxt, Class<?> cl, TypeBindings bindings)\n{\n    // First: possible shortcut for simple types\n    // 30-Nov-2017, tatu: As per [databind#1831] may need to avoid caching Object.class,\n    //    regardless of context type... lets start simple tho\n    if (cl == String.class) return CORE_TYPE_STRING; // since 2.7\n    if (cl == Object.class) return CORE_TYPE_OBJECT;\n\n    // Maybe already defined? Try check from cache\n    // 14-Jan-2016, tatu: Cannot cache types that depend on context... except maybe for root?\n    // TODO: Need to reconsider following caching, perhaps only enable for root elements?\n    //       Need to balance impact on performance, memory use\n    // 05-May-2017, tatu: Ok, testing suggests this is safe enough for root types\n    //   (when `ctxt` is null); and performance impact seems negligible.\n\n    final Object key = (bindings == null || bindings.isEmpty()) ? cl : bindings.asKey(cl);\n\n    // 13-Oct-2016, tatu: As per [databind#1169], need to be careful wrt caching; consider\n    JavaType result = _typeCache.get(key);\n    if (result != null) {\n        // Need to ensure that type is not being recursively resolved...\n        if ((ctxt != null) && ctxt.isCyclic()) {\n            // 13-Jan-2018, tatu: This is tricky... Need to avoid returning finalized type\n            //   in case refinement is needed? For now assume cache is ok. May need\n            //   to revisit in future.\n            // 28-Oct-2019, tatu: Let's check one thing: if `result` was resolved via\n            //    different bindings, do not return... (re-resolving is bit costly but safe)\n            //    Need to ensure this check is efficient; for now just skip if different\n            // NOTE! We check raw Class in key... but bindings may differ. Need to check.\n            // 13-Mar-2020, tatu: Actually need `equals()` check since Bindings may be same\n            //    instance OR equivalent.\n            if (result.getBindings().equals(bindings)) {\n                 return result;\n            }\n        } else {\n            return result;\n        }\n    }\n\n    // Ok: no easy shortcut, need to build type.\n\n    // 18-Nov-2015, tatu: If we have context, maybe we can get previously resolved type?\n    boolean recurse = (ctxt != null);\n    HierarchicType childCtxt;\n\n    if (recurse) {\n        // 18-Nov-2015, tatu: Related to [databind#1006], need to be careful wrt bindings\n        HierarchicType prev = ctxt.findSubType(cl);\n        if (prev != null) {\n            // Uh-oh. Loop right back to something we are resolving. Usually bad.\n            // But could also be Union type, like:\n            //  Foo<T extends Foo<T>>\n            // Let's allow that by returning resolved type associated...\n            prev.setDebugInfo(\" (found previously processed)\", false); // Add info for diagnostics\n            return prev.getResolvedType(); // MUST have been resolved earlier\n        }\n        childCtxt = ctxt.createChild(cl);\n    } else {\n        // Two possibilities: either genuinely new type; or directly recursive type like\n        // <T extends Base<T>>. For latter, need to check existing contexts.\n        // ... note: we could perhaps simplify/optimize check, but for now checks all bindings.\n        HierarchicType existing = _findNearestGeneric(cl, bindings);\n        if (existing != null) {\n            // Ok: resolved previously, points to existing definition, need that:\n            existing.setDebugInfo(\" (already resolved)\", false);\n            return existing.getResolvedType();\n        }\n        childCtxt = new HierarchicType(cl);\n        // We must associate bindings now; even if empty\n        // Should always be properly bound subtype?\n        if (bindings != null) {\n            childCtxt.setBindings(bindings);\n        }\n    }\n\n    // First, preliminary registration to allow handling recursive definitions\n    // 13-Oct-2016, tatu: Need to use factory method not constructor, used to call\n    //    `new SimpleType(cl)` which is WRONG.\n    // Important: must use a method that can either construct or reuse; can not\n    // just call constructor, MUST delegate back to TypeFactory\n    // Also: we have slight chicken-and-egg problem, need placeholder to use for resolution,\n    // can not finalize early.\n\n    // 14-Oct-2016, tatu: Actually, need to use placeholder created by `HierarchicType` itself...\n    //    or, maybe, pass `SimpleType` that we create right here and now? Try latter\n    // 24-Oct-2016, tatu: Maybe not? SimpleType does not seem right. Try again with\n    //     `constructType()` variant... or perhaps `_constructType()`?\n\n    // 12-Jan-2018, tatu: Need to ensure type has handlers, bindings, resolved via this...\n    result = _constructSimple(cl, bindings, childCtxt, null);\n    childCtxt.setResolvedType(result);\n\n    // Need context to resolve supertypes: pass `childCtxt`, not `ctxt`.\n    JavaType superClass;\n    JavaType[] superInterfaces;\n    try {\n        superClass = _resolveSuperClass(childCtxt, cl, bindings);\n        superInterfaces = _resolveSuperInterfaces(childCtxt, cl, bindings);\n    } catch (Exception e) {\n        childCtxt.setErrorReported();\n        // For [databind#1714], use placeholder type instead of failing right away\n        if (!this._cfgFailOnUnknownSubType) {\n            // 12-Jan-2018, tatu: As per comment above, should NOT call SimpleType ctor directly\n            //result. Gosh darnit. What should we do? Make it failed type maybe?\n            // For now, let's leave as is and see what happens...\n            //result = new SimpleType(cl);\n             result.setHierarchy(null, null);\n             return result;\n        }\n        // but by default, do fail\n        throw new IllegalArgumentException(\"Failed to process type '\"+ClassUtil.nameOf(cl)+\"': \"+e.getMessage(), e);\n    }\n    // RBR needs to be resolved?\n    if (result instanceof SimpleType) { // sanity check; shouldn't occur otherwise\n        ((SimpleType) result).setHierarchy(superClass, superInterfaces);\n    } else { // but what if some TypeModifier sub-classed? Then need to delegate...\n        // TBD // how could this happen? Placeholder is `SimpleType`?\n        // 12-Jan-2018, tatu: Not sure what to do here; should never happen? Let's assume that\n        //   for now. If it does, need to define `setHierarchy()` on JavaType perhaps?\n    }\n\n    // Ok; fully defined now. Let's see if we can refine it; specifically\n    result = _refineSimpleType(result, cl, bindings, childCtxt, superClass, superInterfaces);\n\n    // And update context to finalized type\n    // 12-Jan-2018, tatu: Let's see if this helps...\n    // 28-Oct-2019, tatu: Actually must check for class... may have been refined into\n    //    something else? Although... probably not. Let's be safe tho\n    if (result.getClass() == SimpleType.class) {\n        if (result != childCtxt.getResolvedType()) {\n            childCtxt.setResolvedType(result);\n        }\n    }\n\n    // One more thing: self-reference? Need to check ONLY for top-level calls\n    if (!recurse) {\n        _verifySelfReference(result, childCtxt);\n    }\n\n    // Finally: let's try add to cache. But ONLY if we are root type being resolved\n    // -- otherwise resolution is context-dependent.\n    // 28-Oct-2019, tatu: Actually caching depends on whether bindings differ, not\n    //    directly on cyclic check. Although usually related.\n    // Let's try caching based on context being non-null?\n    if (ctxt == null) {\n        _typeCache.put(key, result);\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}