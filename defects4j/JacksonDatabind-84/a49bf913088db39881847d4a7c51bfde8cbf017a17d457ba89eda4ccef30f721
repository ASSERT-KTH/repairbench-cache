{
    "generation": "    protected JavaType _fromClass(TypeResolutionContext ctxt, Class<?> clz, TypeBindings bindings)\n    {\n        // Should not be called for primitives, but better safe than sorry...\n        if (clz == String.class) { return SimpleType.constructUnsafe(String.class); }\n        if (clz == Object.class) { return TypeFactory.CORE_TYPE_OBJECT; }\n        // This is apparently needed for some edge cases, so:\n        if (clz == Void.class || clz == void.class) { return TypeFactory.CORE_TYPE_VOID; }\n\n        // Ok: no easy shortcut, let's figure out type hierarchy etc.\n        // First: check main cache; if found, we are fine\n        JavaType type = _findCachedType(clz);\n        if (type != null) {\n            return type;\n        }\n\n        // 18-May-2016, tatu: If context is null, need to create; otherwise\n        //   we only need to check against recursive refs from this context\n        if (ctxt == null) {\n            ctxt = new TypeResolutionContext(this);\n        } else {\n            ResolvedRecursiveType selfRef = ctxt.findObjectType(clz);\n            if (selfRef != null) {\n                return selfRef;\n            }\n        }\n\n        // preliminary type definition, used for resolving recursive definitions\n        ResolvedRecursiveType placeholder = new ResolvedRecursiveType(clz, bindings);\n        ctxt.addObjectType(clz, placeholder);\n\n        // Super-class, interfaces\n        JavaType resolvedSuperClass = null;\n        List<JavaType> resolvedSuperInterfaces = Collections.emptyList();\n\n        // Some types managed by core handler; others via introspection\n        if (clz.isArray()) {\n            type = ArrayType.construct(_fromAny(ctxt, clz.getComponentType(), bindings), bindings);\n        } else if (clz.isEnum()) {\n            type = EnumType.construct(clz, bindings);\n        } else if (Map.class.isAssignableFrom(clz)) {\n            resolvedSuperInterfaces = _resolveSuperInterfaces(ctxt, clz, bindings); // needed early to find key/value types\n            // We may already know key/value types\n            JavaType keyType = CORE_TYPE_OBJECT;\n            JavaType valueType = CORE_TYPE_OBJECT;\n            // via Map interface?\n            for (JavaType t : resolvedSuperInterfaces) {\n                if (Map.class == t.getRawClass()) {\n                    keyType = t.containedType(0);\n                    valueType = t.containedType(1);\n                    break;\n                }\n            }\n            type = MapType.construct(clz, bindings, null, resolvedSuperInterfaces, keyType, valueType);\n        } else if (Collection.class.isAssignableFrom(clz)) {\n             resolvedSuperInterfaces = _resolveSuperInterfaces(ctxt, clz, bindings); // needed early to find element type\n            JavaType elemType = CORE_TYPE_OBJECT;\n             // via Collection interface?\n            for (JavaType t : resolvedSuperInterfaces) {\n                if (Collection.class == t.getRawClass()) {\n                     elemType = t.containedType(0);\n                    break;\n                }\n            }\n            type = CollectionType.construct(clz, bindings, null, resolvedSuperInterfaces, elemType);\n        } else {\n            resolvedSuperClass = _resolveSuperClass(ctxt, clz, bindings);\n            resolvedSuperInterfaces = _resolveSuperInterfaces(ctxt, clz, bindings);\n            type = new SimpleType(clz, bindings, resolvedSuperClass, resolvedSuperInterfaces);\n        }\n\n        // possibly apply SimpleType refinements?\n        if (type.isSimpleType()) {\n            // May need refinement for nominal types, related to [databind#193]\n            // (no need to check for Collection/Map/Array/Enum)\n            // 18-May-2016, tatu: Not sure if this is needed but... maybe?\n             ((SimpleType) type).setSuperClass(resolvedSuperClass);\n             ((SimpleType) type).setInterfaces(resolvedSuperInterfaces);\n        }\n\n        // Important: MUST resolve placeholder AFTER we are done with supertypes\n        placeholder.setReference(type);\n\n        // Handle self-references within constructed type; mostly relevant for Collections, Maps\n        _resolveSelfReferences(ctxt, type);\n\n        // Finally: any type modifiers?\n        if (_modifiers != null) {\n            TypeBindings b = type.getBindings();\n            if (b == null) {\n                b = TypeBindings.emptyBindings();\n            }\n            for (TypeModifier mod : _modifiers) {\n                JavaType t = mod.modifyType(type, ctxt.getType(), b, this);\n                if (t == null) {\n                    throw new IllegalStateException(String.format(\n                            \"TypeModifier %s returned null for type %s\", mod.getClass().getName(), type));\n                }\n                type = t;\n            }\n        }\n\n        // We are done with resolving this type, safe to add to cache\n        _addCachedType(clz, type);\n\n        return type;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}