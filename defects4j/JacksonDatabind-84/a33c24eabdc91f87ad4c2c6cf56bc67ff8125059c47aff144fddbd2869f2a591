{
    "generation": "// In TypeFactory.java, replace the old \u201c_fromClass\u201d (or its equivalent) with this version:\nprotected JavaType _fromClass(Class<?> raw, TypeBindings parentBindings) {\n    // 1) build a canonical key for lookup\n    JavaTypeKey key = new JavaTypeKey(raw, parentBindings);\n    // 2) if we've already fully built this exact type, just return it\n    JavaType cached = _typeCache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n    // 3) if we're already in the middle of building it (recursive reference),\n    //    return the placeholder so we don't infinite\u2010recurse\n    JavaType placeholder = _incomplete.get(key);\n    if (placeholder != null) {\n        return placeholder;\n    }\n    // 4) create a lightweight stub and mark it \u201cincomplete\u201d\n    SimpleType stub = new SimpleType(raw, parentBindings,\n            null, null, null, null, null);\n    _incomplete.put(key, stub);\n\n    // 5) now resolve its super\u2010class and interfaces\n    JavaType superClass = (raw == Object.class)\n            ? null\n            : constructType(raw.getSuperclass());\n    Class<?>[] interfaces = raw.getInterfaces();\n    JavaType[] resolvedIfaces = new JavaType[interfaces.length];\n    for (int i = 0, len = interfaces.length; i < len; ++i) {\n        resolvedIfaces[i] = constructType(interfaces[i]);\n    }\n\n    // 6) build the real, fully\u2010resolved SimpleType\n    SimpleType full = new SimpleType(raw, parentBindings,\n            superClass, resolvedIfaces, null, null, null);\n\n    // 7) remove the stub from \u201cincomplete\u201d and cache the real thing\n    _incomplete.remove(key);\n    _typeCache.put(new JavaTypeKey(full), full);\n\n    return full;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}