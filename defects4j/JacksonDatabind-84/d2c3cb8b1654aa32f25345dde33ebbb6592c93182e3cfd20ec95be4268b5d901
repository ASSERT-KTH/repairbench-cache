{
    "generation": "    protected JavaType _fromClass(Class<?> cl, TypeBindings bindings)\n    {\n        // 1. Check primary cache first (usually cheapest)\n        JavaType type = _findCachedType(cl);\n        if (type != null) {\n            // 16-Feb-2017, tatu: Important: MUST create new instance, if bindings change...\n            //   ... so that different bindings are not mixed...\n            if ((bindings != null) && !bindings.isEmpty()) {\n                if (!bindings.equals(type.getBindings())) {\n                    // 16-Feb-2017, tatu: ... except, is this actually safe? Seems dubious. Need\n                    //   to reconsider. For now, try reverting.\n                    type = type.withBindings(bindings);\n                }\n            }\n            return type;\n        }\n\n        // 2. Ok: no match in primary cache, resolve. But first: maybe placeholder?\n        // 16-Feb-2017, tatu: Must handle recursive types -- detect, placeholder:\n        // 26-Aug-2017, tatu: Ok, check THIS way: if type currently being resolved, return.\n        ResolvedRecursiveType currentlyResolving = _findIncomplete(cl);\n        if (currentlyResolving != null) {\n            return currentlyResolving;\n        }\n\n        // 3. Nope: need to construct an instance... but register placeholder first\n        ResolvedRecursiveType selfRef = new ResolvedRecursiveType(cl, bindings);\n        _incompleteTypes.put(cl, selfRef);\n\n        // 4. And then resolve hierarchy (super-class, super-interfaces)\n        //    Note: includes resolving TypeVariable for hierarchic types (but not for Class!)\n        // !!! FIX: Resolve hierarchy BEFORE constructing the actual type object !!!\n        final JavaType resolvedSuperClass = _resolveSuperClass(cl, bindings);\n        final JavaType[] resolvedSuperInterfaces = _resolveSuperInterfaces(cl, bindings);\n\n        // 5. And after resolving hierarchy, see if we were perhaps modifying the type?\n        JavaType resultType = null;\n        if (_modifiers != null && !_modifiers.isEmpty()) {\n             // 30-Aug-2017, tatu: NOTE! Need to pass `selfRef` as place-holder, NOT\n             //    resolved `superClass` or `superInterfaces`, as those may be incorrect\n             //    due to modifiers. They will be resolved later on by `setReference`.\n            JavaType typeToModify = selfRef; // Start with placeholder itself\n            for (TypeModifier mod : _modifiers) {\n                 JavaType modified = mod.modifyType(typeToModify, cl, bindings, this);\n                 if (modified == null) { // problem\n                     throw new IllegalStateException(String.format(\n                             \"TypeModifier %s returned null for type %s\", mod.getClass().getName(), typeToModify));\n                 }\n                 resultType = modified;\n                 typeToModify = resultType; // use result for next modifier\n            }\n        }\n\n        // 6. If type not modified, create the default SimpleType instance:\n        if (resultType == null) {\n            // Pass resolved hierarchy here\n            resultType = _newSimpleType(cl, bindings, resolvedSuperClass, resolvedSuperInterfaces);\n        }\n\n        // 7. Finally: resolve self-reference BEFORE caching; needed for cyclic deps\n        selfRef.setReference(resultType);\n\n        // 8. And ensure super-type information is set correctly, especially needed if\n        //    type was modified (but possibly also otherwise, for robustness)\n        //    Super-types are set directly on SimpleType; other types should be fine without?\n        //    (note: was missing from fix for [databind#1708] added in 2.9.1)\n        if (resultType instanceof SimpleType) {\n            ((SimpleType) resultType)._addSuperClass(resolvedSuperClass, resolvedSuperInterfaces);\n        }\n\n        // 9. Caching: Add to primary cache AND remove from incomplete list\n        //    (must do in this order)\n        _addCached(cl, resultType);\n        // We are done with resolving this type, remove from placeholder map\n        _incompleteTypes.remove(cl);\n\n        return resultType;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}