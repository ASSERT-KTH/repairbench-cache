{
    "generation": "/**\n * Internal helper used by constructType(...) to handle recursion, supertypes\n * and caching.\n */\nprotected JavaType _fromClass(Class<?> raw, TypeBindings bindings,\n        JavaType superClass, JavaType[] superInts, int modifiers)\n{\n    // First: try the canonical cache\n    TypeCache.Key key = TypeCache._key(raw, bindings, superClass, superInts);\n    JavaType cached = _typeCache.get(key);\n    if (cached != null) {\n        return cached;\n    }\n\n    // Next: set up recursion\u2010map if needed\n    boolean fullRecursion = (_recursions != null);\n    if (_recursions == null) {\n        _recursions = new HashMap<TypeCache.Key,JavaType>();\n    } else {\n        // if we are already building this exact type, return the placeholder\n        JavaType prev = _recursions.get(key);\n        if (prev != null) {\n            return prev;\n        }\n    }\n\n    // Create a placeholder so that recursive references won't loop infinitely\n    SimpleType result = new SimpleType(raw, bindings, superClass, superInts);\n    _recursions.put(key, result);\n\n    // Actually resolve the superclass (only if caller didn\u2019t bind one in)\n    JavaType sc = (superClass == null)\n        ? _fromClass(raw.getGenericSuperclass(),\n                     TypeBindings.emptyBindings(),\n                     null, null,\n                     ClassUtil.findClassModifiers(raw))\n        : superClass;\n    // And any interfaces\n    JavaType[] sis = (superInts == null)\n        ? _resolveSuperInterfaces(raw, bindings)\n        : superInts;\n    result.setSuperClass(sc);\n    result.setSuperInterfaces(sis);\n\n    // Everything is now known: cache the real type\n    _typeCache.put(key, result);\n\n    // Finally clean up our recursion stub\n    _recursions.remove(key);\n    if (!fullRecursion) {\n        // only clear the map if *we* created it\n        _recursions = null;\n    }\n\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}