{
    "generation": "// Located in package com.fasterxml.jackson.databind.type, class TypeFactory\n    /**\n     * Method called to ensure that type constructed is valid and,\n     * if so, add to cache.\n     * Added to allow subtypes to override definition of validity,\n     * and perhaps additional caching checks.\n     * Note that {@link ResolvedRecursiveType} instances are NOT\n     * cached as is, but only during construction, and should\n     * be replaced by actual resolved type instance.\n     * Currently validity check just avoids caching types that\n     * are not {@link #isConcrete()}.\n     *\n     * @since 2.9\n     */\n    private final void _verifyAndCache(Object key, JavaType type)\n    {\n        // 13-Jan-2017, tatu: As per [databind#1467] need to ensure we don't cache\n        //    truly invalid types. But note that we DO want to cache placeholders.\n        //    So... is this check useful? (Seems like not) Or should it be done right\n        //    after construction, by `_constructType`?\n        /* 19-Sep-2018, tatu: [databind#1998] makes it necessary NOT to check this,\n         *   for recursive types. Let's just comment out for now.\n        if (!type.isConcrete()) {\n             return;\n        }\n        */\n        // 19-Sep-2018, tatu: Ok. This is where [databind#1998] fix is needed.\n        //   We must NOT try replacing a ResolvedRecursiveType (\"placeholder\") with\n        //   ResolvedRecursiveType. Instead, need to either resolve or fail.\n        //   But for now let's just unconditionally add mapping. May be problematic,\n        //   but needs to work for placeholder/self-ref cases.\n        /* 19-Sep-2018, tatu: Turns out this is probably NOT needed -- checks for `isResolved()`\n         *   may be sufficient? Needs more testing. But for 2.9 let's play it safe.\n         *   Resolving placeholders has to occur somewhere...\n         */\n         // [databind#1998] / [databind#2334]: unconditionally cache for now:\n         // Ensure the final constructed type replaces any temporary placeholder (like ResolvedRecursiveType)\n         // put in the cache earlier during recursive type resolution. Failing to replace the placeholder\n         // could lead to issues later when the type hierarchy is introspected.\n         _typeCache.put(key, type);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}