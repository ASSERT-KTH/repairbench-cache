{
    "generation": "@Override\npublic void feedInput(byte[] buf, int start, int end) throws IOException\n{\n    // Must not have remaining input\n    if (_inputPtr < _inputEnd) {\n        _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n    }\n    if (end < start) {\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n    }\n    // and shouldn't have been marked as end-of-input\n    if (_endOfInput) {\n        _reportError(\"Already closed, can not feed more input\");\n    }\n    /*\n     * We maintain an \"absolute\" byte offset that is the number of actual new bytes\n     * that have been fed so far. However, for handling of incomplete tokens,\n     * one byte from the previous segment is retained across feeds.\n     * That means when a new segment is fed, we must add the length of the\n     * previous segment minus one (except for the very first segment).\n     */\n    _currInputProcessed += (_origBufferLen == 0 ? 1 : _origBufferLen - 1);\n\n    // Adjust the row start so that locations computed from the new buffer come out right.\n    // (previous _inputEnd and _currInputRowStart are used to \u201cbacktrack\u201d)\n    _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n    // Then update pointers and buffer length for the new input chunk\n    _inputBuffer = buf;\n    _inputPtr = start;\n    _inputEnd = end;\n    _origBufferLen = end - start;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}