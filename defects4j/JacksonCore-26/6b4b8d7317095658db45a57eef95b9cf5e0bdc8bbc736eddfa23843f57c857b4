{
    "generation": "    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n\n        // Time to update pointers first\n        // This is the core fix for [core#531] in async mode.\n        // _currInputProcessed tracks the total bytes processed from the start of the logical stream.\n        // _inputPtr tracks the current position within the _inputBuffer (which is the actual byte[]).\n        // JsonLocation.getByteOffset() calculates as _currInputProcessed + _inputPtr + 1.\n        //\n        // On the very first call to feedInput for this parser instance:\n        // - _inputBuffer is null (or a placeholder like NO_BYTES in the parser's constructor).\n        // - The logical stream starts at 'buf[start]'. To make its effective byte offset 0 (so getByteOffset() returns 1),\n        //   _currInputProcessed must be initialized to -start. This compensates for _inputPtr being set to 'start'.\n        if (_inputBuffer == null) {\n            _currInputProcessed = -start;\n        } else {\n            // For subsequent calls:\n            // _currInputProcessed needs to advance by the length of the *previous* fed segment.\n            // _origBufferLen holds the length (end - start) of the segment from the *previous* feedInput call.\n            _currInputProcessed += _origBufferLen;\n            \n            // Additionally, if the new 'buf' provided also has a non-zero 'start' offset,\n            // this implies a logical shift or 'gap' in the stream relative to the previous buffer.\n            // _currInputProcessed should effectively absorb this 'start' offset to maintain correct byte offsets\n            // for the new segment, as _inputPtr will again be set to this new 'start'.\n            _currInputProcessed -= start;\n        }\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        // _currInputRowStart is the absolute offset of the current row start.\n        // The calculation 'start - (_inputEnd - _currInputRowStart)' adjusts it for the new segment:\n        // - '_inputEnd - _currInputRowStart' represents the bytes consumed in the last row of the *previous* buffer.\n        // - Subtracting this value and adding 'start' aligns _currInputRowStart to the beginning of the new segment.\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings for the new input segment\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start; // Store the length of the *current* segment for the next call\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}