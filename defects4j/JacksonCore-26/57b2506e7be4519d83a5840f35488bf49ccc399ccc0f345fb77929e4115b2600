{
    "generation": "    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer.\n        // The calculation `start - (_inputEnd - _currInputRowStart)` from [#531] aims\n        // to preserve column information across buffer boundaries.\n        // However, it can result in a negative `_currInputRowStart` which seems to\n        // lead to incorrect line number calculation (`expected:<1> but was:<3>`) in\n        // `AsyncLocationTest#testLocationOffsets`.\n        //\n        // Reverting to the simpler `_currInputRowStart = start;` fixes the line number\n        // in that test but breaks column tracking (which [#531] aimed to fix).\n        //\n        // A potential compromise is to use the [#531] calculation but prevent\n        // `_currInputRowStart` from becoming negative, effectively assuming the row\n        // starts at the beginning of the buffer if the calculation goes negative.\n        // This might still be incorrect for column calculation in some edge cases\n        // but might be closer to the intended behavior than a full revert.\n        int prevInputEnd = _inputEnd; // Capture value before buffer settings are updated\n        int prevCurrInputRowStart = _currInputRowStart; // Capture value before buffer settings are updated\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n\n        // Calculate the adjusted row start using previous buffer's end and row start.\n        // Apply the logic from #531, but clamp to 'start' if it would go negative.\n        // This prevents the negative value that seems to cause the line number issue,\n        // while attempting to keep column calculation somewhat correct.\n        int potentialNewRowStart = start - (prevInputEnd - prevCurrInputRowStart);\n        // Ensure `_currInputRowStart` is not less than the buffer start offset `start`.\n        // It also cannot be less than 0 conceptually, but relative to `start` seems more relevant here.\n        _currInputRowStart = Math.max(start, potentialNewRowStart);\n        // Alternative: Clamp strictly at 0? Seems less likely to be correct.\n        // _currInputRowStart = Math.max(0, potentialNewRowStart);\n        // Alternative: Revert completely?\n        // _currInputRowStart = start;\n\n        // Note: _inputBuffer, _inputPtr, _inputEnd, _origBufferLen were updated BEFORE this row start logic.\n        // This was rearranged to use the state from the *previous* buffer (`prevInputEnd`, `prevCurrInputRowStart`)\n        // for the calculation, as the original code did implicitly.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}