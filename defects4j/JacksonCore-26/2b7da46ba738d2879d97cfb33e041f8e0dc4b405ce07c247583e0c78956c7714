{
    "generation": "@Override\npublic void feedInput(byte[] buf, int start, int end) throws IOException\n{\n    // Must not have remaining input\n    if (_inputPtr < _inputEnd) {\n        _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\",\n                     _inputEnd - _inputPtr);\n    }\n    if (end < start) {\n        _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n    }\n    // and shouldn't have been marked as end-of-input\n    if (_endOfInput) {\n        _reportError(\"Already closed, can not feed more input\");\n    }\n    // Save old state\n    int oldEnd = _inputEnd;\n    int oldRowStart = _currInputRowStart;\n    int oldLen = _origBufferLen;\n    // Update total processed bytes\n    _currInputProcessed += oldLen;\n    // Rebase row start for the new buffer slice\n    if (oldRowStart >= 0) {\n        _currInputRowStart = oldRowStart - oldEnd;\n    } else {\n        _currInputRowStart = -1;\n    }\n    // Copy the requested slice so that pointers start at 0\n    int newLen = end - start;\n    byte[] segment = new byte[newLen];\n    System.arraycopy(buf, start, segment, 0, newLen);\n    // Install the new buffer\n    _inputBuffer = segment;\n    _inputPtr = 0;\n    _inputEnd = newLen;\n    _origBufferLen = newLen;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}