{
    "generation": "    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n\n        // _currInputProcessed: total bytes from previous *logical* input segments\n        // _origBufferLen: length of the *previous* effective input segment (end - start from previous call)\n        // The problem is that _inputPtr will be set to 'start' (an absolute index in 'buf'),\n        // but for JsonLocation, _inputPtr needs to be relative to the logical start of the current segment.\n        // To compensate, _currInputProcessed must subtract the 'start' offset for the current segment.\n        _currInputProcessed = (_currInputProcessed + _origBufferLen) - start;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        // _currInputRowStart represents offset of line start within the *current* input buffer.\n        // This calculation should remain correct as it maintains relative offset.\n        _currInputRowStart = start - (_inputEnd - _currInputRowRowStart); // The correct field is _currInputRowStart, typo in the comment\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start; // _inputPtr remains the absolute index in 'buf'\n        _inputEnd = end;\n        _origBufferLen = end - start; // Store length of this *current* effective segment for next iteration\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}