{
    "generation": "    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        // Need to ensure that the row start points within the new buffer area;\n        // can be tricky if buffer boundary splits a token. Need to add buffer length BOTH\n        // to processed count AND row start offset.\n        _currInputProcessed += _origBufferLen;\n        // Also need to adjust row start, similarly; note that this relies on\n        // _currInputProcessed having been updated!!\n        // NOTE: `_currInputRowStart` is relative to `_inputBuffer` BUT `_currInputProcessed` is\n        // absolute offset. Handlers need to take this into account -- generally\n        // by using (_currInputProcessed + _currInputRowStart) as absolute row start offset.\n        _currInputRowStart -= _origBufferLen;\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        // Also, store the start offset for this buffer segment: needed for location calculation\n        // (note: assumes buffer length is less than 2 gigs which is necessary for byte[])\n        _bufferOffset = start;\n        _origBufferLen = end - start;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}