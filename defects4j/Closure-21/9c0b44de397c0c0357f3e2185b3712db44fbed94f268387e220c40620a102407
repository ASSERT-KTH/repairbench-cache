{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // Ignore nodes that are definitely okay or handled elsewhere.\n    if (n.isEmpty() || n.isComma() || n.isExprResult() || parent == null) {\n      // - EMPTY nodes are usually extra semicolons (handled)\n      // - COMMA nodes are handled by visiting children\n      // - EXPR_RESULT nodes are handled by visiting the child expression\n      // - parent == null means root node\n      return;\n    }\n\n    // Allow qualified names with JSDoc only in stand-alone expression statements.\n    // Example: /** @type {string} */ myNs.subNs;\n    if (n.isQualifiedName() && n.getJSDocInfo() != null && parent.isExprResult()) {\n      return;\n    }\n\n    // Allow side-effect free expressions in FOR initializer and increment parts.\n    // Note: This check is necessary because NodeUtil.isExpressionResultUsed considers\n    // the init/increment value unused in the FOR structure itself.\n    if (parent.isFor()) {\n      Node init = parent.getFirstChild();\n      // Check if n is the initializer node (can be null for `for(;...;)`).\n      if (n == init) {\n          return;\n      }\n      // Check if n is the increment node (can be null for `for(...;;)`).\n      // The increment node is the third child. Need to check safely.\n      if (init != null) {\n          Node cond = init.getNext();\n          if (cond != null) {\n              Node incr = cond.getNext();\n              if (n == incr) {\n                  return;\n              }\n          }\n      }\n    }\n\n    // Check if the expression's result is used. This handles cases like\n    // the last element of a comma operator whose result is used by an\n    // assignment or return. It also handles cases where the expression is used\n    // directly, like in `if (x == y)`, `return x + y;`, `var a = b ? c : d;`.\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n\n    if (isResultUsed) {\n      // If the result is used, it's not useless code.\n      return;\n    }\n\n    // At this point, the result of 'n' is not used by its parent context.\n    // Report if 'n' is a simple operator whose result is discardable\n    // OR if 'n' has no side effects.\n\n    // Exception: `void <expr_with_no_side_effects>` is considered intentional.\n    // Example: void 0, void(0)\n    if (n.isVoid() && !NodeUtil.mayHaveSideEffects(n.getFirstChild(), t.getCompiler())) {\n      return;\n    }\n\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    boolean hasSideEffects = NodeUtil.mayHaveSideEffects(n, t.getCompiler());\n\n    // Report if:\n    // 1. The node is a simple operator (like +, ==, !, typeof). The result of the operator\n    //    itself isn't used, which is suspicious even if operands have side-effects (e.g. `x == foo()`).\n    // 2. Or, the node is not a simple operator but has NO side effects (e.g., `\"str\"`, `3`, `a.b.c`).\n    if (isSimpleOp || !hasSideEffects) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n         // Refine message for common simple operators whose primary purpose is the result value\n         switch (n.getType()) {\n            case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE:\n            case Token.LT: case Token.GT: case Token.LE: case Token.GE:\n            case Token.INSTANCEOF: case Token.IN:\n            case Token.POS: case Token.NEG: // +x, -x\n            case Token.NOT: case Token.BITNOT: case Token.TYPEOF: // !, ~, typeof\n            case Token.ADD: case Token.SUB: case Token.MUL: case Token.DIV: case Token.MOD:\n            case Token.BITOR: case Token.BITXOR: case Token.BITAND:\n            case Token.LSH: case Token.RSH: case Token.URSH:\n                // Note: VOID is handled by the exception above\n                msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n                     \"' operator is not being used.\";\n                break;\n           // Default message is okay for other simple ops (if any exist)\n           // or for non-simple ops without side effects.\n         }\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n      // Track the node if it's not a statement itself, maybe for removal by a later pass.\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well. (Original comment)\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n    // else: Result is not used, but node is not a simple operator AND has side effects.\n    // This is okay (e.g., foo(); assignment(); ++x; delete obj.prop;)\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}