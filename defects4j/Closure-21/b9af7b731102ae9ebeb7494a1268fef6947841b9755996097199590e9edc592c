{
    "generation": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  if (n.isEmpty() || n.isComma()) {\n    return;\n  }\n  if (parent == null) {\n    return;\n  }\n  // Do not try to remove a BLOCK or an EXPR_RESULT. We already handle these cases\n  // when we visit the child.\n  if (n.isExprResult()) {\n    return;\n  }\n  // This no\u2010op statement was there so that JSDoc information could be attached to the name.\n  if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n    return;\n  }\n\n  // Compute some basic properties.\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n  boolean hasSideEffects = NodeUtil.mayHaveSideEffects(n, t.getCompiler());\n  // \u201cPure\u201d means no side effects.\n  boolean isPure = !hasSideEffects;\n  boolean isUsed = NodeUtil.isExpressionResultUsed(n);\n\n  // Special handling when the expression is part of a comma operator.\n  // In a comma expression only the very last operand contributes to the overall value.\n  // However, we want to flag (or \u201cpreserve\u201d) an unused pure subexpression only in cases\n  // where the developer appears to have written an overall pure comma\u2013expression.\n  // For example:\n  //   var a, b; a = (5, 6);\n  // should produce a warning on the literal 5 \u2013 whereas\n  //   var a, b; a = (bar(), 6, 7);\n  // looks intentional and no warning should be reported.\n  if (parent.getType() == Token.COMMA) {\n    // First, find the outermost comma operator in this chain.\n    Node commaRoot = parent;\n    while (commaRoot.getParent() != null && commaRoot.getParent().getType() == Token.COMMA) {\n      commaRoot = commaRoot.getParent();\n    }\n    // Flatten the comma expression into a left-to-right list.\n    List<Node> operands = new ArrayList<>();\n    Stack<Node> stack = new Stack<>();\n    stack.push(commaRoot);\n    while (!stack.isEmpty()) {\n      Node cur = stack.pop();\n      if (cur.getType() == Token.COMMA) {\n        // Push right child first so that left child comes out first.\n        stack.push(cur.getLastChild());\n        stack.push(cur.getFirstChild());\n      } else {\n        operands.add(cur);\n      }\n    }\n    // Now decide whether to warn on a pure operand.\n    // Our heuristic is: In a comma\u2013expression we warn only on the very first pure operand \u2013\n    // but only in two cases:\n    //  (a) If the entire comma\u2013expression is pure (e.g. (5,6) or (2,3)), then warn on the first operand.\n    //  (b) If the comma\u2013expression starts with an impure operand and then later a pure one appears,\n    //      we issue a warning only if there are at least two impure operands to indicate that a side\u2013effect chain\n    //      is in progress. For example, in (bar(),6,7) the first pure value (6) is not warned; however,\n    //      in (bar(), bar(),7,8) the pure 7 is flagged.\n    int firstPureIndex = -1;\n    for (int i = 0; i < operands.size(); i++) {\n      // An operand is \u201cpure\u201d if it produces no side effects.\n      if (!NodeUtil.mayHaveSideEffects(operands.get(i), t.getCompiler())) {\n        firstPureIndex = i;\n        break;\n      }\n    }\n    if (firstPureIndex != -1) {\n      if (firstPureIndex == 0) {\n        // The comma\u2013expression is entirely pure; only flag the very first operand.\n        if (n != operands.get(0)) {\n          return;\n        }\n      } else {\n        // There is an impure prefix.\n        // We warn only if at least two impure operands come first.\n        if (firstPureIndex < 2) {\n          return;\n        } else {\n          if (n != operands.get(firstPureIndex)) {\n            return;\n          }\n        }\n      }\n    } else {\n      // Nothing in the comma chain is pure.\n      return;\n    }\n    // Even though an operand may be \u201cflagged\u201d, if it is the last operand of the overall comma operator\n    // then its value is used. Only non-last operands can be considered unused.\n    isUsed = (n == operands.get(operands.size() - 1));\n  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n    // If the parent is not an expression statement or block, then only special\n    // constructions (such as FOR loops) get examined.\n    if (!(parent.getType() == Token.FOR &&\n          parent.getChildCount() == 4 &&\n          (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n      return;\n    }\n  }\n\n  // Now, if the expression is a \u201csimple operator\u201d (like ==) or pure, and its result is not used,\n  // then report an error.\n  if ((isSimpleOp || isPure) && !isUsed) {\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n    }\n    t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // If the node is not a statement we add it to the list of problem nodes.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}