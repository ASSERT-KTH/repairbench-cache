{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() ||\n        n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    // Allow EXPRESSION statements in VOID contexts to be removed.\n    if (n.isExprResult()) {\n      // Allow synthetic EXPR_RESULT nodes created by passes such as\n      // PeepholeRemoveUselessCode. Allowing them here prevents the\n      // CheckSideEffects pass from reporting useless code errors that have already\n      // been fixed.\n      if (n.isSyntheticBlock()) {\n        return;\n      }\n      // Otherwise, the EXPR_RESULT's child should be checked.\n      // The result of the EXPR_RESULT node is never used.\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n    // Handle special cases in COMMA expressions.\n    if (parent.isComma()) {\n      // If the result is used, it isn't useless.\n      // An example of this is: return x(), y();\n      if (isResultUsed) {\n        return;\n      }\n\n      // If this node is the last child of the comma, then whether the result\n      // is used depends on whether the COMMA's result is used. Let the\n      // logic below handle this case.\n      if (n != parent.getLastChild()) {\n        // Otherwise, if the result is not used, it is useless.\n        // An example of this is: x(), y()\n        if (!NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n          // Report the error.\n          reportUselessCode(t, n);\n        }\n        // We don't need to analyze this node any further.\n        return;\n      }\n    } else if (parent.isExprResult() || parent.isBlock()) {\n      // If the parent is an EXPR_RESULT or BLOCK, the result is not used.\n      // The exception is if the EXPR_RESULT is the child of a label, and\n      // the label is jumped to. But we don't track that here.\n      isResultUsed = false;\n    } else if (parent.isFor() && parent.getChildCount() == 4 &&\n               (n == parent.getFirstChild() || // The init condition\n                n == parent.getFirstChild().getNext().getNext())) { // The increment condition\n      // These results are not used, but continuously dumping warnings\n      // for this case is very annoying. This is a special-case from\n      // the old Rhino CheckSideEffects.\n      return;\n    }\n\n    // If the code reaches here, 'isResultUsed' properly reflects\n    // whether the surrounding code uses the result of the expression.\n\n    if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      reportUselessCode(t, n);\n    }\n  }\n\n  /**\n   * Reports a useless code error.\n   * @param t The traversal.\n   * @param n The node.\n   */\n  private void reportUselessCode(NodeTraversal t, Node n) {\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (NodeUtil.isSimpleOperatorType(n.getType())) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    t.getCompiler().report(\n        t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}