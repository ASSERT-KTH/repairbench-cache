{
    "generation": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  // VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // We allow these extra semicolons.\n  if (n.isEmpty() || n.isComma()) {\n    return;\n  }\n  if (parent == null) {\n    return;\n  }\n\n  // Instead of bailing out on EXPR_RESULT nodes we \u201cunwrap\u201d them so that\n  // we analyze the actual expression. The EXPR_RESULT \u201cwrapper\u201d is only meant\n  // to hold JSDoc info, so we don\u2019t want to lose a warning on its inner expression.\n  if (n.isExprResult()) {\n    n = n.getFirstChild();\n    if (n == null) {\n      return;\n    }\n  }\n\n  // Don\u2019t complain about a no-op statement that exists\n  // solely so that JSDoc can be attached.\n  if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n    return;\n  }\n\n  boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n  boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n\n  // Special handling for comma operators.\n  if (parent.getType() == Token.COMMA) {\n    // In a comma expression, all operands except the \u201cfinal\u201d one\n    // have their value discarded.  (Note that node\u2019s own idea of\n    // \"result used\" may not reflect that fact when the comma is nested.)\n    if (n != parent.getLastChild()) {\n      // For non-final operands, if our local check says the result is used,\n      // then do nothing.\n      if (isResultUsed) {\n        return;\n      }\n      // Otherwise, warn on this operand.\n    } else {\n      // For the final operand of a comma operator, its value\n      // may be used if the comma expression sits in a context (like\n      // an assignment) that takes its value. To decide, look at our parent.\n      Node grandparent = parent.getParent();\n      if (grandparent != null && grandparent.getType() == Token.COMMA &&\n          grandparent.getFirstChild() == parent) {\n        // Our parent comma is itself being used as the left operand of a higher comma;\n        // so its final child\u2019s value is actually discarded.\n        // Fall through to warn.\n      } else if (parent.getParent() != null &&\n                 (parent.getParent().getType() == Token.EXPR_RESULT ||\n                  parent.getParent().getType() == Token.BLOCK)) {\n        // The comma expression is a top\u2010level statement.  Its value isn\u2019t used.\n        // Fall through.\n      } else {\n        // In other cases the final operand\u2019s result is used, so skip warning.\n        return;\n      }\n    }\n  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n    // In some contexts (e.g. the head or increment of a FOR loop)\n    // the expression result is used.\n    if (!(parent.getType() == Token.FOR && parent.getChildCount() == 4 &&\n          (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n      return;\n    }\n  }\n\n  // If the expression either is a simple operator or it\u2019s known to be side-effect free,\n  // then report a warning.\n  if (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n      msg = \"Is there a missing '+' on the previous line?\";\n    } else if (isSimpleOp) {\n      msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n    }\n    t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    // If n is not a statement, add it to our problem nodes so later passes\n    // can wrap it with a JSCOMPILER_PRESERVE call.\n    if (!NodeUtil.isStatement(n)) {\n      problemNodes.add(n);\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}