{
    "generation": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // Allow these. (VOID is deprecated, use EMPTY).\n    if (n.isEmpty()) {\n      return;\n    }\n\n    // COMMA nodes are handled during traversal of their children. Check children, not the comma itself.\n    if (n.isComma()) {\n        return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    // Allow certain expressions contexts like the initializer and incrementor\n    // of a FOR loop. e.g. for(i=0;i<10;i++);\n    // These are allowed to have no side effects, because the user likely\n    // intends for them to be evaluated statefully, even if the result is discarded.\n    Node contextNode = n;\n    Node contextParent = parent;\n    // If n is the child of an EXPR_RESULT, check the EXPR_RESULT's context.\n    // Example: for(EXPR_RESULT(i=0);...) - We care about the EXPR_RESULT context.\n    if (parent.isExprResult()) {\n      contextNode = parent;\n      contextParent = parent.getParent();\n    }\n\n    boolean allowNoSideEffects = false;\n    // Check for traditional FOR loops (4 children: init, cond, incr, body).\n    if (contextParent != null && contextParent.isFor() && contextParent.getChildCount() == 4) {\n      Node init = contextParent.getFirstChild();\n      Node condition = init.getNext(); // Not used, but shows structure\n      Node incr = condition.getNext();\n      // Check if the contextNode (n or its EXPR_RESULT parent) is the init or incr part.\n      if (contextNode == init || contextNode == incr) {\n        allowNoSideEffects = true;\n      }\n    }\n    // NOTE: This does not exempt FOR-IN or FOR-OF loops, as their structure\n    // is different and the expressions within them typically need results/effects.\n\n    if (allowNoSideEffects) {\n        return; // Skip the side-effect check for allowed contexts.\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n\n    // If the result is not used, check for side effects.\n    if (!isResultUsed) {\n        boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n        // Note: mayHaveSideEffects checks for assignments, calls, delete,\n        // ++, -- etc. It considers the potential effects of children.\n        // Simple operators like +, == are not intrinsically side-effecting\n        // unless their operands have side-effects (e.g. `a == foo()`).\n        boolean hasSideEffects = NodeUtil.mayHaveSideEffects(n, t.getCompiler());\n\n        // Report error if the result is unused AND EITHER:\n        // 1. The expression is a simple operator (e.g., +, ==), regardless\n        //    of operand side effects, because the operator's result is discarded.\n        // 2. The expression is known to have no side effects (e.g., literal,\n        //    call to known pure function).\n        if (isSimpleOp || !hasSideEffects) {\n            String msg = \"This code lacks side-effects. Is there a bug?\";\n\n            // Customize message based on the findings.\n            if (n.isString()) {\n                // String literals are often mistakes like missing \"+\"\n                msg = \"Is there a missing '+' on the previous line?\";\n            } else if (isSimpleOp) {\n                // If it's a simple operator, mention the operator.\n                // This covers cases like `x == y;` or `a + b;`\n                // It also covers `x == foo();` where foo() might have side effects,\n                // but the `==` result itself is unused.\n                 msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n                       \"' operator is not being used.\";\n            } else if (!hasSideEffects) {\n                 // If not a simple op, but known no side effects (e.g. pure function call),\n                 // keep the general message. This branch might not be strictly necessary\n                 // if the default message is sufficient, but provides clarity.\n                 // Example: `Math.random();` if configured as @nosideeffects\n                 msg = \"This code lacks side-effects. Is there a bug?\";\n            }\n\n            t.getCompiler().report(\n                t.makeError(n, level, USELESS_CODE_ERROR, msg));\n\n            // Add to problem nodes unless it's a statement node that will\n            // be preserved anyway. This seems related to a subsequent removal pass.\n             if (!NodeUtil.isStatement(n)) {\n               problemNodes.add(n);\n             }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}