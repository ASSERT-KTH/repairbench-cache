{
    "generation": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      // User specified an adapter; use it.\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null; // true if '@JsonAdapter' specified an adapter\n    if (mapped == null) {\n      // No adapter specified by annotation, get the default one for the field type\n      mapped = context.getAdapter(fieldType);\n    }\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        // Use the adapter specified by @JsonAdapter directly if present.\n        // Otherwise, use the runtime type wrapper for polymorphism.\n        TypeAdapter t;\n        if (jsonAdapterPresent) {\n          // The user explicitly specified an adapter using @JsonAdapter.\n          // We must use exactly this adapter. Cast is safe because Field reflects the T of TypeAdapter<T>\n          // Using the specified adapter directly prevents the TypeAdapterRuntimeTypeWrapper \n          // from choosing a different adapter based on the runtime type, which is crucial\n          // for honoring the @JsonAdapter annotation, especially for primitives.\n          t = (TypeAdapter) typeAdapter;\n        } else {\n          // Use a runtime type adapter wrapper for the default adapter case.\n          // This handles cases like List<Object> containing different runtime types\n          // using the default adapters obtained from context.getAdapter.\n          t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        }\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}