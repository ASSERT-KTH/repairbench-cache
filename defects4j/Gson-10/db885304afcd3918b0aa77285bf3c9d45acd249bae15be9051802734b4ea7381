{
    "generation": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    // This boolean tracks if an explicit @JsonAdapter annotation was found on the field.\n    // It's crucial for deciding whether to use the explicit adapter directly or\n    // to wrap it with TypeAdapterRuntimeTypeWrapper for runtime type handling.\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t;\n        // The fix addresses a regression where @JsonAdapter on primitive fields\n        // was overridden by Gson's default adapters due to TypeAdapterRuntimeTypeWrapper.\n        // If an explicit @JsonAdapter was present, use that adapter directly.\n        // Otherwise, use TypeAdapterRuntimeTypeWrapper to handle potential\n        // runtime type differences for polymorphic fields.\n        if (jsonAdapterPresent) {\n          t = typeAdapter;\n        } else {\n          t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        }\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        // Do not set a null primitive field to null. Primitives cannot be null.\n        // This check ensures that if an adapter reads a null value for a primitive field,\n        // the field is not updated (it retains its default value).\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        // Avoid recursion for fields that might refer back to the parent object,\n        // e.g., Throwable.cause referring to itself or a parent in a cyclic graph.\n        return fieldValue != value;\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}