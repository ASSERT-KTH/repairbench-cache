{
    "generation": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      // User specified an adapter; use it.\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null; // Check if annotation specified an adapter.\n    if (mapped == null) {\n      // No specified adapter? Ask Gson for the default.\n      mapped = context.getAdapter(fieldType);\n    }\n\n    final TypeAdapter<?> typeAdapter = mapped; // This is the adapter for the field type.\n\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      // Determine the adapter to use for writing.\n      // If the user specified an adapter (@JsonAdapter), use it directly.\n      // Otherwise, wrap the default adapter with TypeAdapterRuntimeTypeWrapper\n      // to handle polymorphism (writing the value's actual runtime type).\n      final TypeAdapter<?> writeTypeAdapter = jsonAdapterPresent ? typeAdapter\n          : new TypeAdapterRuntimeTypeWrapper<>(context, typeAdapter, fieldType.getType());\n\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        // Use the pre-determined adapter for writing. This respects @JsonAdapter if present.\n        ((TypeAdapter) writeTypeAdapter).write(writer, fieldValue);\n      }\n\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        // Reading uses the field's declared type adapter (`typeAdapter`).\n        // This correctly uses the @JsonAdapter adapter if present.\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        }\n      }\n\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}