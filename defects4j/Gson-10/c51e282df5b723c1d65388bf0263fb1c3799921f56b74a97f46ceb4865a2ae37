{
    "generation": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        // Bug fix: for primitive fields, if fieldValue is null, set default value (e.g. 0 for int)\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        } else if (isPrimitive) {\n          // Set the field to the default value of its primitive type\n          Class<?> fieldClass = field.getType();\n          if (fieldClass == boolean.class) {\n            field.setBoolean(value, false);\n          } else if (fieldClass == byte.class) {\n            field.setByte(value, (byte) 0);\n          } else if (fieldClass == char.class) {\n            field.setChar(value, (char) 0);\n          } else if (fieldClass == short.class) {\n            field.setShort(value, (short) 0);\n          } else if (fieldClass == int.class) {\n            field.setInt(value, 0);\n          } else if (fieldClass == long.class) {\n            field.setLong(value, 0L);\n          } else if (fieldClass == float.class) {\n            field.setFloat(value, 0f);\n          } else if (fieldClass == double.class) {\n            field.setDouble(value, 0d);\n          }\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}