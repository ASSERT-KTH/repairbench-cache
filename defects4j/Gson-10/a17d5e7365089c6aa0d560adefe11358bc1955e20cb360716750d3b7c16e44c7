{
    "generation": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          if (isPrimitive && fieldValue == null) {\n            // Gson does not accept null for primitive types, E.g., int, double.\n            // If this case occurs (when the json contains null), reset the value to the default value of the primitive type.\n            // See https://github.com/google/gson/issues/1439\n            if (fieldType.getRawType() == int.class) {\n              fieldValue = 0;\n            } else if (fieldType.getRawType() == long.class) {\n              fieldValue = 0L;\n            } else if (fieldType.getRawType() == boolean.class) {\n              fieldValue = false;\n            } else if (fieldType.getRawType() == float.class) {\n              fieldValue = 0.0f;\n            } else if (fieldType.getRawType() == double.class) {\n              fieldValue = 0.0d;\n            } else if (fieldType.getRawType() == short.class) {\n              fieldValue = (short) 0;\n            } else if (fieldType.getRawType() == byte.class) {\n              fieldValue = (byte) 0;\n            } else if (fieldType.getRawType() == char.class) {\n              fieldValue = '\\u0000';\n            }\n          }\n          field.set(value, fieldValue);\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}