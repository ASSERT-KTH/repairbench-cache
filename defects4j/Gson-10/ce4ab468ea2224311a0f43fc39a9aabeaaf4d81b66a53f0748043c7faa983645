{
    "generation": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation!= null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped!= null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        // Fix: Always set the field value, regardless of whether it's null or primitive\n        field.set(value, fieldValue);\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue!= value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}