{
    "generation": "  private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n      final Gson context, final Field field, final String name,\n      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n    // special casing primitives here saves ~5% on Android...\n    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n    TypeAdapter<?> mapped = null;\n    if (annotation != null) {\n      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n    }\n    final boolean jsonAdapterPresent = mapped != null;\n    if (mapped == null) mapped = context.getAdapter(fieldType);\n\n    final TypeAdapter<?> typeAdapter = mapped;\n    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n      @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n      @Override void write(JsonWriter writer, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = field.get(value);\n        TypeAdapter t =\n          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n        // Fix: Wrap primitive field with correct boxed type for custom TypeAdapter\n        if (fieldValue == null && isPrimitive) {\n          // For primitive fields, write 0/false/null according to the primitive type\n          // But here, delegate to the TypeAdapter as the @JsonAdapter expects boxed type\n          // e.g., for int: 0, which typeAdapter will handle\n          // So just call t.write with fieldValue (which will be null, but that's fine)\n          // Custom TypeAdapter should handle it, otherwise will write null\n        }\n        t.write(writer, fieldValue);\n      }\n      @Override void read(JsonReader reader, Object value)\n          throws IOException, IllegalAccessException {\n        Object fieldValue = typeAdapter.read(reader);\n        if (fieldValue != null || !isPrimitive) {\n          field.set(value, fieldValue);\n        } else if (isPrimitive) {\n          // Set default value for primitive type if fieldValue == null\n          // This keeps default Java primitive value (e.g. 0 for int), so do nothing\n        }\n      }\n      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n        if (!serialized) return false;\n        Object fieldValue = field.get(value);\n        return fieldValue != value; // avoid recursion for example for Throwable.cause\n      }\n    };\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}