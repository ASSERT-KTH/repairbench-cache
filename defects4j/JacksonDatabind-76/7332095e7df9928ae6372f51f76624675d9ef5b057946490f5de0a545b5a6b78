{
    "generation": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n        DeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    // hold properties that are to be processed after bean creation\n    List<String> bufferedNames = new ArrayList<>();\n    List<JsonToken> bufferedTokens = new ArrayList<>();\n    List<TokenBuffer> bufferedValues = new ArrayList<>();\n    while (t == JsonToken.FIELD_NAME) {\n        String propName = p.getCurrentName();\n        p.nextToken(); // to point to value\n        // creator property?\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                // Found all creator properties, can build POJO now\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                    // Should never get here, but if we do, just continue\n                    t = p.nextToken();\n                    continue;\n                }\n                // Now, handle buffered fields first (these are properties that were encountered before the POJO could be built)\n                for (int i = 0; i < bufferedNames.size(); ++i) {\n                    String name = bufferedNames.get(i);\n                    TokenBuffer tb = bufferedValues.get(i);\n                    t = bufferedTokens.get(i);\n                    SettableBeanProperty prop = _beanProperties.find(name);\n                    if (prop != null) {\n                        prop.deserializeAndSet(tb.asParser(p), ctxt, bean);\n                    } else if (_ignorableProps != null && _ignorableProps.contains(name)) {\n                        // skip\n                    } else if (_anySetter != null) {\n                        _anySetter.deserializeAndSet(tb.asParser(p), ctxt, bean, name);\n                    } else {\n                        // If nothing matches, still buffer for unwrapped\n                        tokens.writeFieldName(name);\n                        tb.serialize(tokens);\n                    }\n                }\n\n                t = p.nextToken();\n                // rest of the properties (after creator parameters)\n                for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n                    String name = p.getCurrentName();\n                    p.nextToken(); // to point to value\n                    SettableBeanProperty prop = _beanProperties.find(name);\n                    if (prop != null) {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } else if (_ignorableProps != null && _ignorableProps.contains(name)) {\n                        handleIgnoredProperty(p, ctxt, handledType(), name);\n                    } else if (_anySetter != null) {\n                        _anySetter.deserializeAndSet(p, ctxt, bean, name);\n                    } else {\n                        tokens.writeFieldName(name);\n                        tokens.copyCurrentStructure(p);\n                    }\n                }\n                tokens.writeEndObject();\n                if (bean.getClass() != _beanType.getRawClass()) {\n                    ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n            } else {\n                t = p.nextToken();\n                continue;\n            }\n        } else if (buffer.readIdProperty(propName)) {\n            t = p.nextToken();\n            continue;\n        } else {\n            // If builder is not ready, buffer property\n            // buffer only non-creator properties\n            TokenBuffer tb = new TokenBuffer(p, ctxt);\n            tb.copyCurrentStructure(p);\n            bufferedNames.add(propName);\n            bufferedTokens.add(t);\n            bufferedValues.add(tb);\n            t = p.nextToken();\n        }\n    }\n\n    // Could not resolve all creator parameters, build bean now\n    Object bean;\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    // handle any buffered properties\n    for (int i = 0; i < bufferedNames.size(); ++i) {\n        String name = bufferedNames.get(i);\n        TokenBuffer tb = bufferedValues.get(i);\n        SettableBeanProperty prop = _beanProperties.find(name);\n        if (prop != null) {\n            prop.deserializeAndSet(tb.asParser(p), ctxt, bean);\n        } else if (_ignorableProps != null && _ignorableProps.contains(name)) {\n            // skip\n        } else if (_anySetter != null) {\n            _anySetter.deserializeAndSet(tb.asParser(p), ctxt, bean, name);\n        } else {\n            tokens.writeFieldName(name);\n            tb.serialize(tokens);\n        }\n    }\n    tokens.writeEndObject();\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}