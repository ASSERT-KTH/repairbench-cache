{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException // JsonProcessingException is subclass of IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            // Creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Let's deserialize value then assign; could theoretically deal with buffering if needs be\n                Object value = creatorProp.deserialize(p, ctxt);\n                // Last creator property handled? Build bean instance\n                if (buffer.assignParameter(creatorProp, value)) {\n                    t = p.nextToken(); // consume property value token; `t` points at next token (FIELD_NAME or END_OBJECT)\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                         // As per original code, pass property name set\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         // wrapAndThrow is assumed to throw, but compiler might need return:\n                         return null;\n                    }\n                    // check for polymorphism\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                         // 16-May-2016, tatu: As per [databind#1218], may need to support... but for now, fail.\n                         return ctxt.reportBadDefinition(_beanType, String.format(\n                                 \"Cannot create polymorphic instances with unwrapped values. Unexpected type %s vs %s\",\n                                 bean.getClass().getName(), _beanType.getRawClass().getName()));\n                    }\n                    // p points to FIELD_NAME or END_OBJECT; buffer has properties needed for constructor\n\n                    // Ensure we read all remaining properties into TokenBuffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // `copyCurrentStructure` will copy FIELD_NAME and its value structure,\n                        // and advance `p` to point to the token after the structure\n                        tokens.copyCurrentStructure(p);\n                        t = p.getCurrentToken(); // Update `t` to `p`'s new position\n                    }\n                    // If t is not END_OBJECT, processUnwrapped might report an error, or maybe it expects END_OBJECT\n\n                    tokens.writeEndObject();\n                    // Need to link tokens to bean via UnwrappedPropertyHandler\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                // Not yet done with creator properties, continue buffering them in `buffer`\n                continue; // explicit continue for clarity\n            }\n\n            // Object Id property? Needs special handling, pass to buffer\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n\n            // Regular property? Add to `tokens` to be handled by `processUnwrapped` later\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                // We need to buffer this property for unwrapping handler\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p); // Copy value token(s) from p into tokens\n                continue;\n            }\n            // Ignorable property?\n            // Let's handle ignorable properties before possibly adding them to the buffer?\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName); // Skips buffered value\n                continue;\n            }\n\n            // \"any property\"? Or one from @JsonUnwrapped handled via field/setter?\n            // Add to `tokens` to be handled by `processUnwrapped` later\n            // Need to buffer, ensure field name is written\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p); // Copy value token(s) from p into tokens\n\n            // NOTE: We do NOT call buffer.bufferAnyProperty() here, as processUnwrapped\n            // will handle AnySetters based on the properties discovered from the `tokens` stream.\n        }\n\n        // We hit END_OBJECT without building the bean (maybe optional creator properties were missing)\n        Object bean;\n        try {\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            // If we get buffer that requires otherwise unexpected subtype, problem...\n            return wrapInstantiationProblem(e, ctxt);\n        }\n        // check for polymorphism\n        if (bean.getClass() != _beanType.getRawClass()) {\n             return ctxt.reportBadDefinition(_beanType, String.format(\n                     \"Cannot create polymorphic instances with unwrapped values. Unexpected type %s vs %s\",\n                     bean.getClass().getName(), _beanType.getRawClass().getName()));\n        }\n\n        // Process properties collected in `tokens` via UnwrappedPropertyHandler\n        tokens.writeEndObject();\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}