{
    "generation": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n        DeserializationContext ctxt)\n    throws IOException, JsonProcessingException\n{\n    // Start with the creator to collect creator properties.\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n    // Create a TokenBuffer that will hold any \"extra\" (i.e. unwrapped) JSON content.\n    TokenBuffer tokens = new TokenBuffer(p, ctxt);\n    tokens.writeStartObject();\n\n    JsonToken t = p.getCurrentToken();\n    while (t == JsonToken.FIELD_NAME) {\n        String propName = p.getCurrentName();\n\n        // If this property is a creator property, we must deserialize it normally.\n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n            // Consume the value from the main stream.\n            p.nextToken();\n            Object value;\n            try {\n                value = creatorProp.deserialize(p, ctxt);\n            } catch (Exception e) {\n                wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                t = p.getCurrentToken();\n                continue;\n            }\n            // Bind the creator property; if all creator parameters are now set,\n            // we can build the bean.\n            if (buffer.assignParameter(creatorProp, value)) {\n                // Advance to next token (field or END_OBJECT)\n                t = p.nextToken();\n                Object bean;\n                try {\n                    bean = creator.build(ctxt, buffer);\n                } catch (Exception e) {\n                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                    t = p.getCurrentToken();\n                    continue;\n                }\n                // For remaining fields, copy the full JSON content into the TokenBuffer.\n                while (t == JsonToken.FIELD_NAME) {\n                    String nextProp = p.getCurrentName();\n                    tokens.writeFieldName(nextProp);\n                    p.nextToken();\n                    tokens.copyCurrentStructure(p);\n                    t = p.getCurrentToken();\n                }\n                tokens.writeEndObject();\n                // Sanity-check: unwrapped handling does not support polymorphic types.\n                if (bean.getClass() != _beanType.getRawClass()) {\n                    ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n            }\n            t = p.getCurrentToken();\n            continue;\n        }\n        // Not a creator property.\n\n        // If the field name matches the Object Id property, let the buffer handle it.\n        if (buffer.readIdProperty(propName)) {\n            p.nextToken();\n            t = p.getCurrentToken();\n            continue;\n        }\n        // In \"unwrapped\" mode all non-creator (and non-Object Id) properties are not bound\n        // via the PropertyValueBuffer. Instead, we copy the entire field (name+value)\n        // into our TokenBuffer so that later the UnwrappedPropertyHandler can process it.\n        tokens.writeFieldName(propName);\n        p.nextToken();\n        tokens.copyCurrentStructure(p);\n\n        // Optionally, if the property is flagged as ignorable, handle that.\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, handledType(), propName);\n        }\n        // (Any \"any setter\" handling is done later via processing of the TokenBuffer.)\n        t = p.getCurrentToken();\n    }\n\n    // End of the JSON object: build the bean using the accumulated creator properties.\n    Object bean;\n    try {\n        bean = creator.build(ctxt, buffer);\n    } catch (Exception e) {\n        return wrapInstantiationProblem(e, ctxt);\n    }\n    tokens.writeEndObject();\n    // Process the unwrapped properties from the TokenBuffer and apply them\n    // (typically to a property annotated with JsonUnwrapped).\n    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}