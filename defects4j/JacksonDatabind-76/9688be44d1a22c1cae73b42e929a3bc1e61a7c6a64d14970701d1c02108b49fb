{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // Need to store non-creator properties, for processing after construction\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            // Creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // If buffer is full, may be able to create instance:\n                // N.B: `assignParameter` returns true if all creator properties known\n                //   (aka \"property buffer is full\")\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    t = p.nextToken(); // skip past value (or END_OBJECT)\n                    Object bean;\n                    try {\n                        // Important: buffer will be used for creator params AND buffered params\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        // We may be able to recover if we can buffer all properties...\n                        // 15-Feb-2012, tatu: Need to change this to allow buffering etc?\n                        // [databind#711]: Should try to buffer properties, not fail right away\n                        // -> This seems wrong; wrapAndThrow does not return normally\n                        return wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        // previous code attempted to continue; but that makes no sense, wrapAndThrow must throw\n                        // (if it doesn't, we need to return null or something to signal failure)\n                    }\n                    // [databind#670]: If we have Polymorphic types, need to check type ID:\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // 13-Nov-2017, tatu: Use method introduced in 2.9.3\n                        // Must pass buffered tokens, if any\n                        return handlePolymorphic(p, ctxt, bean, tokens);\n                    }\n                    // Great, we got the bean; need to process remaining properties AND buffered ones\n                    // (but first, collected non-creator ones)\n                    // Read and buffer remaining properties into TokenBuffer\n                    while (t == JsonToken.FIELD_NAME) {\n                        // NOTE: must NOT call `p.nextToken()` from within loop, to avoid\n                        // double-advancing; will be automatically called by other code\n                        // Also: MUST use `p.getCurrentName()`, not `propName`\n                        tokens.writeFieldName(p.getCurrentName());\n                        p.nextToken(); // move to value\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken(); // move to next field name or END_OBJECT\n                    }\n                    // We should be pointing to END_OBJECT now... Add it too.\n                    tokens.writeEndObject();\n\n                    // And then \"replay\" buffered tokens using UnwrappedPropertyHandler\n                    // N.B.: Pass original parser for location information\n                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                }\n                // If not complete, just continue loop\n                continue;\n            }\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // Regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n            // Ignorable property?\n            // Let's handle ignorable properties before potentially buffering them as unwrapped\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n\n            // If not creator property, not regular, not id, not ignorable: buffer as `unwrapped`\n            // (or handle via AnySetter). Store in TokenBuffer.\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n\n            // \"any property\"? Put into token buffer for processUnwrapped to handle.\n            // Do NOT buffer via `buffer.bufferAnyProperty` as that's for pre-creation state.\n            if (_anySetter != null) {\n                // AnySetter will be properly handled by processUnwrapped(..) below, which uses\n                // the standard bean deserializer with the token buffer.\n            }\n            // else: unknown/unmappable property; buffer for Unwrapped reading\n        } // end of main loop\n\n        // We hit END_OBJECT; need to create bean and handle leftovers.\n        Object bean;\n        try {\n            // creator.build -> creates instance, injects creator prop values AND buffered values\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n            // If we get exceptions here, possibly due to missing required property, treat as fatal\n            return wrapInstantiationProblem(e, ctxt);\n        }\n\n        // And finally, process fields collected in TokenBuffer using UnwrappedPropertyHandler\n        // Need to pass original parser for location info\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}