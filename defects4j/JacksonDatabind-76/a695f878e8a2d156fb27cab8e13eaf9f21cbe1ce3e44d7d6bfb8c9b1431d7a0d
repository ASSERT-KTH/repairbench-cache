{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 01-Dec-2017, tatu: As per [databind#1853], need to handle buffering\n        //    of unknown properties, too. Simplest seems to be similar to BeanDeserializer:\n        //    use TokenBuffer, then pass to unwrapper which may use delegate or custom handler\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // Assign value BUT DO NOT build; gather all parameters first\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    // We could check if we have all creator parameters collected, potentially handle\n                    // remaining properties? But easier just to collect all properties first.\n                    // However, could verify creator prop values... but too complex?\n                    // ...\n                }\n                continue; // creator prop handled\n            }\n            \n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue; // handled by buffer\n            }\n            \n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue; // regular prop handled\n            }\n\n            // Ignorable?\n            // Need to be careful with ignorable properties... they may be passed to unwrapped buffer\n            // (and handled by delegate), or then not. Let's assume they should be ignored.\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue; // ignorable prop handled\n            }\n\n            // Unwrapped property? Or unknown? Should be buffered...\n            // As per [databind#398], need to be able to buffer unknown properties\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n\n            // \"any property\"? But how can we determine that? May need to be left to unwrapper:\n            // 01-Dec-2017, tatu: Indeed. Cannot determine if it's \"any property\" so must assume\n            //    it is potentially unwrapped property. Unwrapper can decide if it is actually\n            //    \"any property\" or not. Let's remove the check for now.\n            /*\n            if (_anySetter != null) {\n                 // [databind#1920]: Don't call deserialize like regular properties, but buffer for later deserialization by UnwrappedPropertyHandler\n                 buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n            }\n            */\n        } // end of main loop\n\n        // We hit END_OBJECT, so:\n        Object bean;\n        try {\n            // Parameters stored in buffer, now build actual instance\n            bean = creator.build(ctxt, buffer);\n        } catch (Exception e) {\n             // As per [databind#1348], need wrap, simpler target type:\n             return wrapAndThrow(e, _beanType.getRawClass(), ctxt);\n        }\n        \n        // And then need to process unwrapped values gathered in tokens\n        tokens.writeEndObject(); // Finalize tokens structure\n\n        // As per [databind#1074], need check for polymorphic cases, disallow\n        // (note: required checking non-polymorphic type)\n        // 07-Aug-2019, tatu: [databind#2426]: Need to allow custom type id handling...\n        // 09-Dec-2019, tatu: [databind#2548]: Need ability to support polymorphic builders...\n        if (bean.getClass() != _beanType.getRawClass()) {\n            // 09-Dec-2019, tatu: Let's actually delegate back to handler, if possible...\n            //    but for now, report a problem\n            // 17-Jan-2020, tatu: ... possibly fixed for 2.11? But let's keep reporting an error until verified\n            return ctxt.reportBadDefinition(_beanType, String.format(\n\"Cannot create polymorphic instances with unwrapped values (root type `%s`; actual type `%s`)\",\n                    _beanType.getRawClass().getName(), bean.getClass().getName()));\n        }\n        \n        // Note: Have to use the original parser to get context for error reporting\n        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}