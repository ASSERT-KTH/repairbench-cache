{
    "generation": "    private Attribute parseAttribute() {\n        tq.consumeWhitespace(); // Consume leading whitespace for attribute name\n        String key = tq.consumeAttributeKey(); // Consume the attribute key\n\n        String value = \"\"; // Initialize value as empty string\n        tq.consumeWhitespace(); // Consume whitespace between key and '='\n\n        // Check if an '=' follows the key\n        boolean hasEq = tq.matchChomp(\"=\"); \n        if (hasEq) {\n            tq.consumeWhitespace(); // Consume whitespace after '='\n\n            // Parse the attribute value based on its enclosure\n            if (tq.matchChomp(SQ)) { // Single quoted value\n                value = tq.chompTo(SQ);\n            } else if (tq.matchChomp(DQ)) { // Double quoted value\n                value = tq.chompTo(DQ);\n            } else { // Unquoted value\n                StringBuilder valueAccum = new StringBuilder();\n                // Consume characters until a tag delimiter ('<', '/>', '>'), whitespace, or end of stream\n                while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n                    valueAccum.append(tq.consume());\n                }\n                value = valueAccum.toString();\n            }\n            tq.consumeWhitespace(); // Consume whitespace after the value\n        }\n\n        // Decide whether to return a valid Attribute or null (for malformed cases)\n        if (key.length() == 0) {\n            // If the key is empty, it's not a valid attribute name.\n            // This happens if tq.consumeAttributeKey() didn't find a valid key char (e.g., started with '=', '.', '>', etc.).\n            \n            if (hasEq) {\n                // Case: ` =value` (e.g., from \"<p =a>\")\n                // An explicit assignment was found, but the key was empty.\n                // The value (if any) has already been consumed by the parser.\n                // We discard this malformed attribute. Do NOT consume any more characters\n                // as the value parsing already advanced the queue past the value.\n                return null;\n            } else {\n                // Case: ` .attribute` or ` !attribute` (e.g., from \"<p .....\")\n                // An empty key was found and no assignment (`=`) followed.\n                // The character that caused `consumeAttributeKey()` to return empty (e.g., '.', '!')\n                // is still at the current TokenQueue position.\n                // We must consume this character to advance the queue and prevent an infinite loop\n                // in the calling Tokeniser state, which expects progress.\n                if (!tq.isEmpty()) { // Ensure there's a character to consume\n                    tq.consume();\n                }\n                return null;\n            }\n        } else {\n            // The key is not empty, so it's a valid attribute (or at least its key is valid).\n            // Create and return the attribute.\n            return Attribute.createFromEncoded(key, value);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}