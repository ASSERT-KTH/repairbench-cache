{
    "generation": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment; // Default to Comment node\n\n        if (commentToken.bogus) {\n            String data = commentToken.getData();\n            Node candidateNode = null;\n\n            // 1. Attempt to parse as a standard XML Declaration (e.g., `xml version='1.0'`)\n            // This covers cases where the data is already stripped of `<?` and `?>`.\n            if (data.toLowerCase().startsWith(\"xml \")) {\n                String xmlContent = data.substring(\"xml \".length()).trim(); // \"version='1.0'\"\n                if (!xmlContent.isEmpty()) {\n                    try {\n                        // Create a dummy tag to parse attributes. `x` is a safe, short tag name.\n                        // For example, `<x version='1.0'/>` will be parsed to extract \"version\" attribute.\n                        Document docAttrs = Jsoup.parse(\"<x \" + xmlContent + \"/>\", baseUri, Parser.xmlParser());\n                        if (!docAttrs.children().isEmpty()) {\n                            Element el = docAttrs.child(0);\n                            // The actual XML declaration tag name is always \"xml\".\n                            candidateNode = new XmlDeclaration(settings.normalizeTag(\"xml\"), true); // `true` for `<?` type\n                            candidateNode.attributes().addAll(el.attributes());\n                        }\n                    } catch (Exception e) {\n                        // Parsing failed, it's not a proper XML declaration.\n                        // Fallback to next attempt or default Comment.\n                    }\n                }\n            }\n\n            // 2. If not parsed as a standard XML declaration, try the original hack for\n            //    bogus comments that start with `!` or `?` (e.g., `!DOCTYPE html` or `?xml version='1.0'?>`).\n            //    This also addresses the `IndexOutOfBoundsException` for short, malformed inputs.\n            if (candidateNode == null && data.length() > 1) { // data.length() > 1 prevents `IndexOutOfBoundsException` for length 1.\n                String effectiveContent = null;\n                boolean isQuestionInstruction = false; // True for `<?`, false for `<!`\n\n                if (data.startsWith(\"?\")) {\n                    isQuestionInstruction = true;\n                    // If it ends with `?`, remove both leading and trailing `?`. Otherwise, just remove leading `?`.\n                    effectiveContent = data.substring(1, data.endsWith(\"?\") ? data.length() - 1 : data.length());\n                } else if (data.startsWith(\"!\")) {\n                    // For `<!`, typically only the leading `!` is removed.\n                    isQuestionInstruction = false;\n                    effectiveContent = data.substring(1);\n                }\n\n                if (effectiveContent != null && !effectiveContent.isEmpty()) { // Ensure content is not empty\n                    try {\n                        // The original parsing strategy: wrap `effectiveContent` in `<>` and parse as XML.\n                        // This assumes `effectiveContent` can be parsed as `tagName attrs`.\n                        Document doc = Jsoup.parse(\"<\" + effectiveContent + \">\", baseUri, Parser.xmlParser());\n                        if (!doc.children().isEmpty()) { // Protect against `IndexOutOfBoundsException` if doc is empty\n                            Element el = doc.child(0);\n                            candidateNode = new XmlDeclaration(settings.normalizeTag(el.tagName()), isQuestionInstruction);\n                            candidateNode.attributes().addAll(el.attributes());\n                        }\n                    } catch (Exception e) {\n                        // Parsing failed, it's not a proper declaration.\n                        // Fallback to default Comment.\n                    }\n                }\n            }\n\n            // If a candidate node was successfully created, use it.\n            if (candidateNode != null) {\n                insert = candidateNode;\n            }\n        }\n        insertNode(insert);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}