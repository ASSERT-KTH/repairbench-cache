{
    "generation": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment; // Default node is the comment itself\n\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // try to parse as XML Declaration or other declaration <!...>\n            String data = comment.getData();\n            String coreData = data; // Data to parse\n            boolean isProcessingInstruction = false; // <?...> vs <!...>\n\n            // Try to determine the type and extract core data based on common patterns from Tokeniser state machine:\n            // CommentEndBang: <?foo?> -> data=\"foo?\" (bogus=true)\n            // MarkupDeclarationOpen: <?foo?> -> data=\"?foo?\" (bogus=true) -- this seems more likely per original code's check\n            //                          <!foo> -> data=\"!foo\" (bogus=true)\n            // If input is <?xml version='1.0'> -> Tokeniser might emit data=\"xml version='1.0'\" with bogus=true (needs verification, but test implies this)\n            if (data.length() > 1) { // Need at least 2 chars to determine e.g. \"?x\"\n                if (data.startsWith(\"?\")) { // Data like \"?foo?\" from <?foo?>\n                    isProcessingInstruction = true;\n                    // Strip leading '?' and potential trailing '?'\n                    if (data.endsWith(\"?\") && data.length() >= 2)\n                        coreData = data.substring(1, data.length() - 1);\n                    else\n                        coreData = data.substring(1); // Strip only leading '?'\n                } else if (data.startsWith(\"!\")) { // Data like \"!foo\" from <!foo>\n                    isProcessingInstruction = false;\n                    // Strip leading '!'\n                    coreData = data.substring(1);\n                } else if (data.toLowerCase().startsWith(\"xml\")) {\n                    // Handle case where Tokeniser might provide \"xml version='1.0'\" for <?xml...>\n                    // Check this case *before* checking data.endsWith(\">\") test below if that test is added.\n                    // No leading '?' or '!', but looks like an XML decl. Assume it's <?xml?>\n                    isProcessingInstruction = true;\n                    coreData = data; // Use data as is\n                    // If tokenizer includes trailing '>', like \"xml version='1.0'>\", handle it:\n                    if (data.endsWith(\">\")) {\n                        coreData = data.substring(0, data.length() - 1);\n                    }\n                }\n                // Note: The original code also had data.substring(1, data.length() -1), implying it expected\n                // both start and end characters to be stripped. This logic handles cases more flexibly.\n            }\n\n            // If coreData is not empty, try parsing it as an element tag\n            // Use a self-closing tag format `<coreData />` for parsing robustness\n            if (!coreData.isEmpty()) {\n                Document doc = Jsoup.parse(\"<\" + coreData + \" />\", baseUri, Parser.xmlParser());\n                // Check if parsing produced a child element\n                if (doc.childNodeSize() > 0 && doc.childNode(0) instanceof Element) {\n                    Element el = (Element) doc.childNode(0);\n                    // Create an XmlDeclaration node (used for both <?...> PI and <!...> Declaration types in Jsoup)\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), isProcessingInstruction);\n                    insert.attributes().addAll(el.attributes());\n                }\n                // else: parsing failed or produced unexpected nodes (like text), leave insert as the original comment\n            }\n            // else: coreData was empty after stripping, leave insert as the original comment\n        }\n\n        insertNode(insert); // Insert the determined node (Comment or XmlDeclaration)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}