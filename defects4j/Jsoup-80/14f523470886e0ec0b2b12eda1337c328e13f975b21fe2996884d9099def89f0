{
    "generation": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = commentToken.getData();\n\n            // The 'data' field of the CommentToken for bogus comments (like <?xml ...?> or <!DOCTYPE ...>)\n            // typically includes the leading '?' or '!' and possibly the trailing '?' or '>'.\n            // For example, for \"<?xml version='1.0'?>\", `data` might be \"?xml version='1.0'?\".\n            // The original `substring(1, data.length() -1)` attempts to remove these delimiters.\n            // However, if `data` is very short (e.g., \"??\", \"!!\", \"!?\", \"?!\"), `substring(1, data.length() -1)`\n            // can result in an empty string (e.g., for \"??\", substring(1,1) is \"\").\n            // Jsoup.parse(\"<>\") will produce a Document with no children, leading to IndexOutOfBoundsException when calling doc.child(0).\n\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                // Extract the inner content to be parsed as an element.\n                // This removes the leading '!' or '?' and the assumed trailing character.\n                String dataInner = data.substring(1, data.length() - 1);\n\n                if (dataInner.isEmpty()) {\n                    // If the inner data is empty (e.g., from \"<??>\" or \"<!!>\"),\n                    // it cannot be parsed into a meaningful element.\n                    // In this case, we fall back to treating it as a regular Comment node,\n                    // which is already assigned to 'insert'.\n                    return; // Exit early, keeping 'insert' as a Comment.\n                }\n\n                try {\n                    // Parse the inner content as a dummy element to extract its tag name and attributes.\n                    // For example, \"<xml version='1.0'>\" from \"?xml version='1.0'?\".\n                    Document doc = Jsoup.parse(\"<\" + dataInner + \">\", baseUri, Parser.xmlParser());\n                    Element el = doc.child(0); // This might throw IndexOutOfBoundsException if doc has no children.\n\n                    // Determine if it's an XML Declaration (<?xml ...?>) or a Document Type / Processing Instruction (<!...>).\n                    char declarationType = data.charAt(0);\n                    if (declarationType == '?') {\n                        // This is an XML Declaration (e.g., <?xml version=\"1.0\"?>)\n                        // XmlDeclaration constructor: XmlDeclaration(tagName, isXmlDecl)\n                        // For <?xml, isXmlDecl should be true.\n                        insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), true);\n                    } else if (declarationType == '!') {\n                        // This is a Document Type Declaration (e.g., <!DOCTYPE html>) or other Processing Instruction (e.g., <!ATTLIST ...>).\n                        // In Jsoup's XML parser, these are represented by XmlDeclaration with isXmlDecl set to false.\n                        // (i.e., it's not the primary <?xml declaration but another instruction).\n                        insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), false);\n                    } else {\n                        // Should theoretically not be reached if data.startsWith(\"!\") || data.startsWith(\"?\") is true,\n                        // but as a safeguard, fallback to Comment.\n                        insert = comment;\n                    }\n                    insert.attributes().addAll(el.attributes());\n                } catch (Exception e) {\n                    // If parsing the inner data as an element fails for any reason (e.g., malformed syntax within the declaration),\n                    // fall back to treating it as a regular Comment node.\n                    insert = comment;\n                }\n            }\n        }\n        insertNode(insert);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}