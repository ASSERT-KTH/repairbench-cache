{
    "generation": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment; // Default: treat as a regular comment node\n\n        // XML declarations (<?xml ...?>) and certain HTML-like declarations (<!DOCTYPE ...>)\n        // might be emitted as \"bogus\" comments if not properly parsed by the Tokeniser.\n        // This block attempts to re-interpret such bogus comments as XmlDeclaration nodes.\n        if (commentToken.bogus) {\n            String data = commentToken.getData(); // e.g., \"?xml version='1.0'\" or \"!DOCTYPE html\" or \"foo bar\" for <!foo bar>\n\n            // The original code checked for data starting with '!' or '?' which implies\n            // the Token.Comment's data still contains this leading character,\n            // indicating a processing instruction or XML declaration format.\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                boolean isProcessingInstruction = data.startsWith(\"?\"); // True for <?...?> (PI), false for <!...> (Decl)\n                String content = data.substring(1); // Remove the leading '!' or '?' (e.g., \"xml version='1.0'\")\n\n                String tagName;\n                String attributesString;\n\n                // Split content into tag name and attribute string\n                int firstSpace = content.indexOf(' ');\n                if (firstSpace > 0) {\n                    tagName = content.substring(0, firstSpace);\n                    attributesString = content.substring(firstSpace + 1);\n                } else {\n                    tagName = content; // No attributes, just tag name\n                    attributesString = \"\";\n                }\n\n                // Create the XmlDeclaration node with the extracted tag name and type\n                insert = new XmlDeclaration(settings.normalizeTag(tagName), isProcessingInstruction);\n\n                // If there are attributes, parse them using Jsoup's XML parser.\n                // The original approach tried to parse the entire declaration string as an element,\n                // which often resulted in malformed XML and an empty document (leading to IndexOutOfBoundsException).\n                // Instead, we create a dummy XML element with the extracted attribute string,\n                // which is a more reliable way to leverage Jsoup's attribute parsing capabilities.\n                if (!attributesString.isEmpty()) {\n                    // Parse a dummy element (e.g., \"<x .../>\") to extract only the attributes\n                    // \"x\" is used as a simple valid XML tag name to host the attributes.\n                    Document attrsDoc = Jsoup.parse(\"<x \" + attributesString + \"/>\", baseUri, Parser.xmlParser());\n                    // Check if the dummy element was successfully parsed (i.e., it has children)\n                    if (attrsDoc.children().size() > 0) {\n                        Element attrsEl = attrsDoc.child(0);\n                        // Add the extracted attributes to the XmlDeclaration node\n                        insert.attributes().addAll(attrsEl.attributes());\n                    }\n                    // If attrsDoc.children().size() is 0, it means the attributesString itself was\n                    // so malformed that it couldn't even parse into a dummy element.\n                    // In this case, the XmlDeclaration will simply have no attributes, which is a graceful fallback.\n                }\n            }\n            // If `commentToken.bogus` is true but the data doesn't start with '!' or '?',\n            // it's a different type of bogus comment (e.g., `<!foo>`). In such cases,\n            // `insert` should remain the `Comment` node, and no further action is needed\n            // within this `if (bogus)` block.\n        }\n        insertNode(insert);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}