{
    "generation": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            // The data for a bogus comment might include the leading '!' or '?' and trailing '>'.\n            // For example, if original XML was \"<?xml version='1.0'?>\", the commentToken.getData() might be \"?xml version='1.0'>\".\n            // The subsequent parsing tries to treat this as an element.\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                // Strip the leading '!' or '?' and the trailing '>' for parsing as an element.\n                String parseData = data.substring(1, data.length() -1);\n                \n                // Parse the stripped data as if it were an element to extract attributes.\n                // Use xmlParser to ensure correct handling of attributes and declaration types.\n                Document doc = Jsoup.parse(\"<\" + parseData + \">\", baseUri, Parser.xmlParser());\n                \n                // Check if any nodes were successfully parsed from the inner content.\n                if (!doc.childNodes().isEmpty()) {\n                    Node node = doc.childNodes().get(0); // Get the first raw node, which could be an Element or XmlDeclaration\n                    String declName = null;\n                    Attributes declAttrs = null;\n\n                    if (node instanceof XmlDeclaration) {\n                        // If parsing resulted in an XmlDeclaration (e.g., from \"<xml ...>\" or \"<!DOCTYPE ...>\")\n                        XmlDeclaration decl = (XmlDeclaration) node;\n                        declName = decl.name();\n                        declAttrs = decl.attributes();\n                    } else if (node instanceof Element) {\n                        // If parsing resulted in a regular Element (e.g., \"<foo bar='baz'>\")\n                        Element el = (Element) node;\n                        declName = el.tagName();\n                        declAttrs = el.attributes();\n                    } \n                    // If 'node' is neither XmlDeclaration nor Element (e.g., a TextNode or Comment),\n                    // it means the parsing hack didn't yield an expected declaration or element.\n                    // In such cases, 'insert' will remain the original 'Comment' node, which is the desired fallback.\n\n                    if (declName != null) { // Only proceed if a valid name was extracted\n                        // Create a new XmlDeclaration based on the parsed name and attributes.\n                        // The 'isProcessingInstruction' flag should be true if the original comment data started with '?' (<?...).\n                        // The original code had data.startsWith(\"!\") which was incorrect for this flag.\n                        insert = new XmlDeclaration(settings.normalizeTag(declName), data.startsWith(\"?\"));\n                        if (declAttrs != null) {\n                            insert.attributes().addAll(declAttrs);\n                        }\n                    }\n                }\n            }\n        }\n        insertNode(insert);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}