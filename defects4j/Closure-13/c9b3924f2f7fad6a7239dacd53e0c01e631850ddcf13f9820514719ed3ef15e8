{
    "generation": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      // Create a snapshot of the children list at the beginning of each retraversal iteration.\n      // This is crucial because recursive calls to traverse(c) or visit(node)\n      // might modify the children list of the current 'node' (e.g., by adding,\n      // removing, or reordering children). If a child 'c' is removed or its siblings\n      // are modified during 'traverse(c)', calling 'c.getNext()' afterwards can lead\n      // to skipped nodes or unexpected behavior.\n      // By taking a snapshot, we ensure that all children present at the start of\n      // this traversal pass are visited exactly once.\n      List<Node> childrenToTraverse = new ArrayList<>();\n      Node c = node.getFirstChild();\n      while (c != null) {\n        childrenToTraverse.add(c);\n        c = c.getNext();\n      }\n\n      for (Node child : childrenToTraverse) {\n        // It's possible for a child to have been detached from 'node' by a previous\n        // recursive call (e.g., moved elsewhere in the AST or removed entirely).\n        // However, we still attempt to traverse it. The 'shouldVisit(node)' check\n        // at the beginning of 'traverse(node)' will prevent further processing if\n        // the node is no longer relevant or has been detached.\n        traverse(child);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}