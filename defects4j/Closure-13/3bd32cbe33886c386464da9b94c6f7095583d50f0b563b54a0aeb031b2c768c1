{
    "generation": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      // Re-initialize the child pointer for each iteration of the do-while loop.\n      // This is important because the child list might have changed due to\n      // optimizations applied during the previous child traversal or the\n      // 'visit(node)' call.\n      Node c = node.getFirstChild();\n      while(c != null) {\n        // IMPORTANT FIX: Get the next sibling *before* the recursive call.\n        // The recursive call 'traverse(c)' might modify 'c' itself\n        // (e.g., by replacing it, or removing it from its parent).\n        // If 'c' is detached, calling 'c.getNext()' *after* 'traverse(c)'\n        // would incorrectly return null, causing subsequent siblings to be skipped.\n        // By capturing 'next' beforehand, we ensure we always move to the correct\n        // subsequent node in the original child list, regardless of what happens to 'c'\n        // during its traversal.\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}