{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        // This check ensures that if the inflater has finished or there is no current entry,\n        // we signal EOF for the stream. It should be before any checks related to current entry's size.\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize(); // Stored size is the uncompressed size\n                if (readBytesOfEntry >= csize) {\n                    return -1; // All data for this entry has been read\n                }\n                // If we need to read from the underlying stream (current internal buffer exhausted or not yet filled)\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0; // Reset internal buffer offset\n                    lengthOfLastRead = in.read(buf); // Try to read more data from underlying stream\n                    if (lengthOfLastRead == -1) {\n                        // Underlying stream has ended prematurely.\n                        // If we haven't read all expected bytes for this entry, it's a truncation.\n                        if (readBytesOfEntry < csize) {\n                            throw new IOException(\"Truncated ZIP file\");\n                        }\n                        // Otherwise, all expected bytes were read or stream ended after them.\n                        return -1;\n                    }\n                    if (lengthOfLastRead == 0) {\n                        // Underlying stream returned 0 bytes, but not EOF.\n                        // If we still expect more bytes for this entry, it implies the stream is stuck or truncated.\n                        if (readBytesOfEntry < csize) {\n                            throw new IOException(\"Truncated ZIP file\");\n                        }\n                        // If readBytesOfEntry >= csize, it means we have finished reading the entry,\n                        // and returning 0 (or -1 eventually) is appropriate.\n                        // This case should ideally be caught by `readBytesOfEntry >= csize` earlier,\n                        // but if it somehow reached here, it's effectively end of entry.\n                        return 0; // Cannot read more bytes currently, return 0.\n                    }\n                    count(lengthOfLastRead); // Update CRC for the raw bytes read\n                    bytesReadFromStream += lengthOfLastRead; // Track total bytes read from underlying stream\n                }\n\n                // Determine how much to read into the user's buffer\n                int toRead = Math.min(length, lengthOfLastRead - offsetInBuffer);\n                // Also ensure we don't read more than the remaining size of the entry\n                toRead = Math.min(toRead, csize - readBytesOfEntry);\n\n                if (toRead <= 0) {\n                    // This can happen if the requested 'length' is 0, in which case return 0.\n                    // Or if readBytesOfEntry >= csize (already handled at the top of the block).\n                    // Or if lengthOfLastRead - offsetInBuffer is 0, which means the internal buffer is\n                    // exhausted and the next read will attempt to fill it again.\n                    // In these cases, returning 0 is usually correct.\n                    return toRead; // Returns 0 if no bytes can be read.\n                }\n\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead; // Update total bytes read for this stored entry\n                crc.update(buffer, start, toRead); // Update CRC for the data copied to user buffer\n                return toRead;\n            }\n\n            // For DEFLATED (and other compressed) entries\n            // Fill the inflater's input buffer if it needs more data\n            if (inf.needsInput()) {\n                fill();\n            }\n\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n\n            // Crucially, update readBytesOfEntry for DEFLATED entries as well.\n            // This tracks the *uncompressed* bytes read, which is what inflate returns.\n            readBytesOfEntry += read;\n\n            long uncompressedSize = current.getSize(); // Expected uncompressed size of the entry\n\n            if (read == 0) { // No bytes were inflated in this call\n                if (inf.finished()) {\n                    // Inflater claims it has finished processing the compressed stream.\n                    // If the total uncompressed bytes inflated (`readBytesOfEntry`) is less\n                    // than the expected uncompressed size (`uncompressedSize`), it's a truncation.\n                    if (readBytesOfEntry < uncompressedSize) {\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // Otherwise, it's a legitimate end of entry, return -1.\n                    return -1;\n                } else if (inf.needsInput()) {\n                    // Inflater needs more input but returned 0 bytes.\n                    // This scenario suggests `fill()` either couldn't provide more input\n                    // (e.g., underlying stream EOF or returned 0 bytes) or the compressed\n                    // data for the current entry is exhausted.\n                    // If we haven't reached the expected uncompressed size, it's a truncation.\n                    if (readBytesOfEntry < uncompressedSize) {\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // If readBytesOfEntry >= uncompressedSize, we've read all expected data.\n                    // Even if inf.finished() is false, effectively the entry is done.\n                    return -1;\n                } else {\n                    // `read == 0`, `!inf.finished()`, `!inf.needsInput()`\n                    // This state means the inflator is stuck: it can't produce more output,\n                    // but it also doesn't need input and isn't finished. This is an error state.\n                    // If we haven't read all expected uncompressed bytes, it's a truncation.\n                    if (readBytesOfEntry < uncompressedSize) {\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // If readBytesOfEntry >= uncompressedSize, then it's a normal end.\n                    return -1;\n                }\n            }\n\n            // Normal successful read: update CRC and return bytes read\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}