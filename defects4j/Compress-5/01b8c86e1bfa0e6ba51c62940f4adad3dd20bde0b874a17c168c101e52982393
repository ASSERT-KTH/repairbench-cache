{
    "generation": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    // Per InputStream contract: a zero-length read returns 0 immediately.\n    if (length == 0) {\n        return 0;\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    // Validate parameters.\n    if (!(start >= 0 && length >= 0 && start <= buffer.length && buffer.length - start >= length)) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n\n    // Handle STORED (uncompressed) entries.\n    if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n        int csize = (int) current.getSize();\n        if (readBytesOfEntry >= csize) {\n            return -1;\n        }\n        if (offsetInBuffer >= lengthOfLastRead) {\n            offsetInBuffer = 0;\n            // If we cannot read more bytes but haven't reached the expected entry size, the entry is truncated.\n            if ((lengthOfLastRead = in.read(buf)) == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            count(lengthOfLastRead);\n            bytesReadFromStream += lengthOfLastRead;\n        }\n        // Calculate how many bytes are available in our internal buffer.\n        int available = lengthOfLastRead - offsetInBuffer;\n        // We want to read either the user requested length or what is available.\n        int toRead = length < available ? length : available;\n        // Do not read past the expected size.\n        if ((csize - readBytesOfEntry) < toRead) {\n            toRead = (int) (csize - readBytesOfEntry);\n        }\n        System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n        offsetInBuffer += toRead;\n        readBytesOfEntry += toRead;\n        crc.update(buffer, start, toRead);\n        return toRead;\n    }\n\n    // Handle DEFLATED (compressed) entries.\n    if (inf.needsInput()) {\n        fill();\n        if (lengthOfLastRead > 0) {\n            bytesReadFromStream += lengthOfLastRead;\n        }\n    }\n    int read;\n    try {\n        read = inf.inflate(buffer, start, length);\n    } catch (DataFormatException e) {\n        throw new ZipException(e.getMessage());\n    }\n    // We must not return 0 if the inflater is not finished.\n    if (read == 0) {\n        if (inf.finished()) {\n            return -1;\n        } else {\n            throw new IOException(\"Truncated ZIP file\");\n        }\n    }\n    crc.update(buffer, start, read);\n    return read;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}