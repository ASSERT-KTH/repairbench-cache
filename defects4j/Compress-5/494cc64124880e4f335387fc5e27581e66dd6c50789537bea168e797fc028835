{
    "generation": "    /**\n     * Reads bytes from the current ZIP entry.\n     *\n     * @param buffer the buffer to write bytes to\n     * @param start the start offset in the buffer\n     * @param length the maximum number of bytes to read\n     * @return the number of bytes read, or -1 if the end of the\n     * stream has been reached\n     * @throws IOException if an I/O error occurs\n     */\n    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        // Check current entry and inflater state first. Order matters if current == null.\n        if (current == null) {\n             return -1; // No current entry\n        }\n        // Finished inflation check MUST come after method check for STORED entries\n        // as inf is not used for them.\n\n        // Parameter validation: avoid int overflow, check buffer boundaries\n        if (start < 0 || length < 0 || start > buffer.length - length) {\n             // Use more informative exception message if possible\n             throw new ArrayIndexOutOfBoundsException(String.format(\"buffer length=%d, start=%d, length=%d\",\n                                                                    buffer.length, start, length));\n        }\n        if (length == 0) {\n            return 0; // Nothing requested\n        }\n\n        try {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                // === STORED Logic ===\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1; // Already read all expected bytes\n                }\n\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    // Need more data from underlying stream\n                    offsetInBuffer = 0;\n                    lengthOfLastRead = in.read(buf); // Read from underlying stream\n                    if (lengthOfLastRead == -1) {\n                        // Hit EOF. Since readBytesOfEntry < csize (checked above), this is unexpected.\n                        // Entry is truncated.\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // Count non-negative reads from the raw stream\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n\n                // Calculate bytes to copy from internal buffer 'buf'\n                int toRead = Math.min(length, lengthOfLastRead - offsetInBuffer);\n\n                // Ensure we don't read beyond the declared entry size 'csize'\n                long remainingInEntry = csize - readBytesOfEntry;\n                if (remainingInEntry < toRead) {\n                    // Only read up to the remaining size\n                    toRead = (int) remainingInEntry; // Cast is safe as csize is int, remaining <= csize\n                }\n\n                // Copy data if toRead > 0\n                if (toRead > 0) {\n                    System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                    offsetInBuffer += toRead;\n                    readBytesOfEntry += toRead;\n                    crc.update(buffer, start, toRead);\n                }\n\n                // Return number of bytes copied. Might be 0 if length was 0, or if remainingInEntry was 0.\n                // If remainingInEntry became 0, the next call will hit `readBytesOfEntry >= csize` check.\n                return toRead;\n\n            }\n            // === DEFLATED (or other compressed methods using Inflater) Logic ===\n\n            // Check if inflation is finished for this entry *before* trying to inflate more\n             if (inf.finished()) {\n                 return -1; // Current entry's data is fully inflated\n             }\n\n            boolean needsInput = inf.needsInput();\n            if (needsInput) {\n                fill(); // Reads from 'in', sets 'lengthOfLastRead', calls inf.setInput\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                // NOTE: 'fill' might read -1 and set lengthOfLastRead = -1\n                // We need this state info for later checks.\n            }\n\n            int read = 0;\n            try {\n                // Attempt to inflate into the user buffer\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                // Inflater encountered corrupt data\n                throw new ZipException(\"Invalid ZLIB data format: \" + e.getMessage(), e);\n            }\n\n            if (read == 0) {\n                // No bytes inflated. Check inflater state again.\n                if (inf.finished()) {\n                    // Inflation completed normally during this call (or was already finished).\n                    return -1;\n                }\n                // If inflate returned 0 but is not finished, it MUST need more input.\n                // Check if we *tried* to provide input (`needsInput` was true before fill)\n                // but couldn't because we hit EOF (`lengthOfLastRead == -1`).\n                if (needsInput && lengthOfLastRead == -1) {\n                    // This is the condition for a truncated stream during DEFLATE.\n                    throw new IOException(\"Truncated ZIP file\");\n                }\n                // Otherwise (read == 0, !finished, and EOF not the identified cause):\n                // This could happen if the output buffer 'length' was too small for a single atom of output.\n                // Returning 0 allows the caller to try again (potentially with a larger buffer or just loop).\n                // This case should not cause the infinite loop reported in the test,\n                // as the infinite loop happens specifically when EOF is the underlying cause.\n            } else {\n                // read > 0: Successfully inflated some bytes.\n                crc.update(buffer, start, read);\n                // Do not update readBytesOfEntry for DEFLATED - rely on inf.finished()\n            }\n            // Return the number of bytes inflated (can be 0 if buffer was too small but not EOF)\n            return read;\n\n        } catch (IOException e) {\n            // Catch IOExceptions from underlying reads or thrown by our truncation logic\n            throw e; // Re-throw the original exception\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}