{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        // Check EOF conditions before reading\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        // buffer.length - start >= length is checked by start + length <= buffer.length\n        if (start < 0 || length < 0 || start > buffer.length || length > buffer.length - start) {\n             throw new ArrayIndexOutOfBoundsException(\"offset=\" + start + \", length=\" + length + \", buffer size=\" + buffer.length);\n        }\n        // Check for 0 length read\n        if (length == 0) {\n            return 0;\n        }\n\n        int read; // Hold bytes read in this call\n\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            // Logic for STORED entries\n            long csize_long = current.getSize(); // Use long for checks\n            // Check if entry is already fully read\n            if (csize_long != ZipArchiveEntry.UNKNOWN_SIZE && readBytesOfEntry >= csize_long) {\n                return -1;\n            }\n            // Cast to int for array indexing/copying, assuming size fits int is handled elsewhere or entry is invalid\n            // Note: getSize() can be -1 (UNKNOWN_SIZE).\n            int csize = (csize_long == ZipArchiveEntry.UNKNOWN_SIZE) ? Integer.MAX_VALUE : (int) csize_long;\n\n\n            if (offsetInBuffer >= lengthOfLastRead) {\n                // Need to read more from underlying stream\n                offsetInBuffer = 0;\n                lengthOfLastRead = in.read(buf); // Read fresh data\n                if (lengthOfLastRead == -1) {\n                    // Hit EOF prematurely\n                    // Throw only if size is known and we haven't reached it\n                    if (csize_long != ZipArchiveEntry.UNKNOWN_SIZE && readBytesOfEntry < csize_long) {\n                         throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // Otherwise, treat as normal EOF for the entry or stream\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n\n            // Calculate bytes to copy from internal buffer 'buf'\n            int availableInBuffer = lengthOfLastRead - offsetInBuffer;\n            int desired = length;\n            int toRead = Math.min(desired, availableInBuffer);\n\n            // Don't read past the declared size (if known)\n            // Check against int csize, but ensure readBytesOfEntry hasn't overflowed int if csize_long was > Integer.MAX_VALUE\n            // Assuming readBytesOfEntry tracks correctly relative to csize.\n            if (csize_long != ZipArchiveEntry.UNKNOWN_SIZE) {\n                 long remainingInEntry = csize_long - readBytesOfEntry;\n                 if (remainingInEntry < toRead) {\n                     // Cast safely as remainingInEntry must be <= csize_long\n                     toRead = (int) remainingInEntry;\n                 }\n            }\n\n            // Assign calculated amount to read variable\n            read = toRead;\n\n            if (read > 0) {\n                 System.arraycopy(buf, offsetInBuffer, buffer, start, read);\n                 offsetInBuffer += read;\n                 readBytesOfEntry += read;\n            }\n             // If read is 0 (e.g. length was 0, or remainingInEntry was 0), return 0.\n             // This happens naturally if toRead calculates to 0.\n\n        } else { // DEFLATED or other compressed methods\n            if (inf.needsInput()) {\n                fill(); // Attempt to fill inflater buffer\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                // Check for premature EOF *after* trying to fill\n                if (lengthOfLastRead == -1) {\n                    // Inflater needs input, but we have hit EOF on the underlying stream.\n                    throw new IOException(\"Truncated ZIP file\");\n                }\n            }\n\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                 // Provide the cause exception\n                throw new ZipException(\"Invalid ZLIB data format: \" + e.getMessage(), e);\n            }\n\n            // Check inflate result\n            if (read == 0) {\n                 if (inf.finished()) {\n                     // Normal end of compressed data for this entry\n                     return -1;\n                 }\n                 // read == 0 and !inf.finished() means inflate needs more input.\n                 // If it needs input, and last fill() returned EOF, we already threw exception.\n                 // If last fill() returned data, but inflate consumed it and needs more,\n                 // return 0, caller must call read() again.\n            }\n             // If read > 0, proceed to update CRC.\n        }\n\n        // Update CRC if any bytes were actually read into the buffer\n        if (read > 0) {\n            crc.update(buffer, start, read);\n        }\n\n        return read; // Return number of bytes read (can be 0)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}