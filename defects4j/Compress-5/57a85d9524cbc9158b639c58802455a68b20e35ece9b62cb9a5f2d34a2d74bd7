{
    "generation": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    // We only check that an entry exists. (Don\u2019t test inf.finished() here \u2013\n    // that will be handled later so that truncated entries don\u2019t slip by.)\n    if (current == null) {\n        return -1;\n    }\n    if (start < 0 || length < 0 || start > buffer.length || buffer.length - start < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n\n    if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n        int csize = (int) current.getSize();\n        if (readBytesOfEntry >= csize) {\n            return -1;\n        }\n        if (offsetInBuffer >= lengthOfLastRead) {\n            offsetInBuffer = 0;\n            // If the underlying stream ends before we\u2019ve read the expected amount, it\u2019s truncated.\n            if ((lengthOfLastRead = in.read(buf)) == -1) {\n                if (readBytesOfEntry < csize) {\n                    throw new ZipException(\"Truncated ZIP file\");\n                }\n                return -1;\n            }\n            count(lengthOfLastRead);\n            bytesReadFromStream += lengthOfLastRead;\n        }\n        int toRead = length;\n        if (length > (lengthOfLastRead - offsetInBuffer)) {\n            toRead = lengthOfLastRead - offsetInBuffer;\n        }\n        if ((csize - readBytesOfEntry) < toRead) {\n            toRead = csize - readBytesOfEntry;\n        }\n        System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n        offsetInBuffer += toRead;\n        readBytesOfEntry += toRead;\n        crc.update(buffer, start, toRead);\n        return toRead;\n    } else { // DEFLATED entry\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int r;\n        try {\n            r = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        // If we actually got some bytes, update our counter.\n        readBytesOfEntry += r;\n        // When inflate() returns 0 while finished, it could mean either a normal end\u2010of\u2010entry\n        // (when all expected bytes have been read) or a truncated entry.\n        if (r == 0 && inf.finished()) {\n            if (current.getSize() != -1 && readBytesOfEntry < current.getSize()) {\n                throw new ZipException(\"Truncated ZIP file\");\n            }\n            return -1;\n        }\n        crc.update(buffer, start, r);\n        return r;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}