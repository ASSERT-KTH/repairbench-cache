{
    "generation": "    public int read(byte[] buffer, int start, int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (inf.finished() || current == null) {\n            return -1;\n        }\n\n        // avoid int overflow, check null buffer\n        if (start <= buffer.length && length >= 0 && start >= 0\n            && buffer.length - start >= length) {\n            if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n                int csize = (int) current.getSize();\n                if (readBytesOfEntry >= csize) {\n                    return -1;\n                }\n                if (offsetInBuffer >= lengthOfLastRead) {\n                    offsetInBuffer = 0;\n                    if ((lengthOfLastRead = in.read(buf)) == -1) {\n                        return -1;\n                    }\n                    count(lengthOfLastRead);\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n                int toRead = length > lengthOfLastRead\n                    ? lengthOfLastRead - offsetInBuffer\n                    : length;\n                if ((csize - readBytesOfEntry) < toRead) {\n                    toRead = csize - readBytesOfEntry;\n                }\n                System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n                offsetInBuffer += toRead;\n                readBytesOfEntry += toRead;\n                crc.update(buffer, start, toRead);\n                return toRead;\n            }\n            // DEFLATED method handling\n            if (inf.needsInput()) {\n                fill(); // This fills 'inf' with more data from 'in' via 'buf'.\n                        // It updates 'lengthOfLastRead' with the number of bytes read from 'in'.\n                        // If 'in' hits EOF, 'lengthOfLastRead' becomes -1.\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                } else if (lengthOfLastRead == -1) { // EOF from underlying stream\n                    // If inflater still needs input and we hit EOF, it's a truncated stream.\n                    // This is for cases where even after trying to fill, we get no more data.\n                    if (!inf.finished()) { // If it's not finished normally.\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    // If it's finished, and we hit EOF, it's a normal end.\n                    return -1; \n                }\n            }\n            int read = 0;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0 && inf.finished()) {\n                return -1; // Normal end of entry\n            }\n            // If inflate returns 0, but is not finished, and needs input:\n            // This implies the compressed data itself is truncated.\n            // This happens if fill() provided some data, but it was not enough\n            // for inflate to produce output or finish, and now it wants more.\n            // Since we just called fill(), and it didn't throw/return -1 (meaning lengthOfLastRead > 0),\n            // it means the stream provided *some* data, but it was incomplete for the entry.\n            if (read == 0 && !inf.finished() && inf.needsInput()) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n        throw new ArrayIndexOutOfBoundsException();\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}