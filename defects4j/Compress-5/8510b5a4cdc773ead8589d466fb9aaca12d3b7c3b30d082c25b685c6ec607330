{
    "generation": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                lengthOfLastRead = in.read(buf);\n                // If we get EOF before reading the expected amount for a STORED entry,\n                // the entry is truncated.\n                if (lengthOfLastRead == -1) {\n                    throw new ZipException(\"Truncated ZIP file\");\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length;\n            // Don't read more than what is available in our internal buffer.\n            if ((lengthOfLastRead - offsetInBuffer) < toRead) {\n                toRead = lengthOfLastRead - offsetInBuffer;\n            }\n            // Also, do not read more than the remaining bytes for this entry.\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        } else {\n            if (inf.needsInput()) {\n                fill();\n                if (lengthOfLastRead > 0) {\n                    bytesReadFromStream += lengthOfLastRead;\n                }\n            }\n            int read;\n            try {\n                read = inf.inflate(buffer, start, length);\n            } catch (DataFormatException e) {\n                throw new ZipException(e.getMessage());\n            }\n            if (read == 0 && inf.finished()) {\n                // If we have not consumed all the compressed data as indicated by the entry header,\n                // then the entry is truncated.\n                long compSize = current.getCompressedSize();\n                if (compSize != -1 && bytesReadFromStream < compSize) {\n                    throw new ZipException(\"Truncated ZIP file\");\n                }\n                return -1;\n            }\n            crc.update(buffer, start, read);\n            return read;\n        }\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}