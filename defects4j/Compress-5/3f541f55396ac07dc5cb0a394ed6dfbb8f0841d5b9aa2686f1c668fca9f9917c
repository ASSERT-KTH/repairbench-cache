{
    "generation": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    // Check parameters avoiding int overflow and null buffer issues\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            // For STORED entries, we know the size up front.\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                // if no more data is available on the underlying stream\n                // but we haven't seen all expected bytes, then report truncation\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    if (readBytesOfEntry < csize) {\n                        throw new IOException(\"Truncated ZIP file\");\n                    }\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead ? (lengthOfLastRead - offsetInBuffer) : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = (int) (csize - readBytesOfEntry);\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n\n        // For deflated (compressed) entries:\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n        // Accumulate the number of uncompressed bytes read (for deflated entries)\n        if (read > 0) {\n            readBytesOfEntry += read;\n        }\n        // If inflater returns 0 and signals finished, then either we really\n        // reached the end or the entry is truncated. In case the entry's expected\n        // size (current.getSize()) is known and we haven't delivered all bytes,\n        // consider it a truncated entry.\n        if (read == 0 && inf.finished()) {\n            if (current.getSize() != -1 && readBytesOfEntry != current.getSize()) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            return -1;\n        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}