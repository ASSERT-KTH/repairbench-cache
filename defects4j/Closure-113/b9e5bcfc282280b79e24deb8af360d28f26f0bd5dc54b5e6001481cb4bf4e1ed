{
    "generation": "/**\n * Handles a goog.require call.\n */\nprivate void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n\n      // This must be non-null, because there was an explicit provide.\n      Preconditions.checkNotNull(providedModule);\n\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n\n    // If goog.require() is inside an if or loop or not at the top \n    // level, never remove it even if require is satisfied\n    // and always keep track of namespace \n    Node ancestor = n.getParent();\n    if (ancestor.getParent() == null || \n        isGrandparentNotExecutable(t, ancestor.getParent())) {\n      if (provided!= null) {\n        parent.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    } else if (provided!= null){\n      compiler.ensureLibraryNamespace(ns);\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}