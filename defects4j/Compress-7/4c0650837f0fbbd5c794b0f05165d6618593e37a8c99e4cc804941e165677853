{
    "generation": "    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            // The original code `result.append((char) buffer[i]);`\n            // incorrectly casts a signed byte directly to a char.\n            // For byte values > 127 (which are negative in Java's signed byte type),\n            // this can lead to incorrect Unicode characters (e.g., \\uFFB1 instead of \\u00B1).\n            //\n            // To correctly interpret the byte as a character in the ISO-8859-1 (Latin-1) range\n            // (where byte values 0-255 map directly to Unicode code points U+0000-U+00FF),\n            // we must mask the byte with 0xFF. This converts the signed byte value\n            // into an unsigned integer value before casting to char.\n            result.append((char) (buffer[i] & 0xFF));\n        }\n\n        return result.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}