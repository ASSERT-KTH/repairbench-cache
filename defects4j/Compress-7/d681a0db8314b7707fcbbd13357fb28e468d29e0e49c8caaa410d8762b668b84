{
    "generation": "import java.io.IOException;\nimport org.apache.commons.compress.archivers.zip.ZipEncoding;\nimport org.apache.commons.compress.archivers.zip.ZipEncodingHelper;\n\n// NOTE: This fix uses the minimal change approach (& 0xFF) to correct the byte-to-char conversion issue.\n// An alternative, potentially cleaner approach would be to determine the actual name length\n// and use `new String(buffer, offset, actualLength, StandardCharsets.ISO_8859_1)`,\n// assuming ISO-8859-1 is the intended encoding for standard tar headers.\n// However, the provided code structure is maintained here.\n\n    /**\n     * Parse an entry name from a buffer.\n     * Parsing stops when a NUL is found\n     * or the buffer length is reached.\n     * <p>\n     * This method assumes that the name is encoded using simple byte-to-character\n     * mapping, equivalent to ISO-8859-1. Correct handling of bytes with the\n     * high bit set (values > 127) requires treating them as unsigned.\n     * </p>\n     *\n     * @param buffer The buffer from which to parse.\n     * @param offset The offset into the buffer from which to parse.\n     * @param length The maximum number of bytes to parse.\n     * @return The entry name.\n     */\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        // Using StringBuffer for compatibility with the original code structure.\n        // Consider StringBuilder if thread safety is not required and Java 5+ is assumed.\n        StringBuffer result = new StringBuffer(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            // Treat byte as an unsigned value (0-255) before casting to char.\n            // This prevents sign extension issues for bytes > 127 (negative values)\n            // and correctly maps byte values 0x00-0xFF to Unicode U+0000-U+00FF,\n            // effectively decoding as ISO-8859-1.\n            result.append((char) (buffer[i] & 0xFF));\n        }\n\n        return result.toString();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}