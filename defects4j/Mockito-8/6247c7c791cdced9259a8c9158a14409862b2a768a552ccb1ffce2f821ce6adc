{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            boolean isSelfReferentialTypeVariable = false;\n            // Check for self-referential type variables like T extends Foo<T>\n            if (actualTypeArgument instanceof ParameterizedType) {\n                ParameterizedType ptActual = (ParameterizedType) actualTypeArgument;\n                // Check if typeParameter is one of the actual type arguments of ptActual\n                for (Type argOfActual : ptActual.getActualTypeArguments()) {\n                    if (typeParameter.equals(argOfActual)) {\n                        // Additionally, check if ptActual is one of the bounds of typeParameter\n                        // This confirms the \"T extends Foo<T>\" structure\n                        for (Type bound : typeParameter.getBounds()) {\n                            if (ptActual.equals(bound)) {\n                                isSelfReferentialTypeVariable = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (isSelfReferentialTypeVariable) {\n                        break;\n                    }\n                }\n            }\n\n            if (isSelfReferentialTypeVariable) {\n                // If it's a self-referential type variable (e.g., T extends Foo<T>),\n                // mapping T to T itself breaks the infinite resolution cycle.\n                contextualActualTypeParameters.put(typeParameter, typeParameter);\n            } else if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}