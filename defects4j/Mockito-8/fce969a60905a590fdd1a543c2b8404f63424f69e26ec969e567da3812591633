{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        // This set 'currentlyRegisteringTypes' is assumed to be a field in the enclosing class\n        // (e.g., 'private final Set<Type> currentlyRegisteringTypes = new HashSet<>();')\n        // and is used to detect and prevent infinite recursion caused by self-referential generic types.\n        if (!currentlyRegisteringTypes.add(classType)) {\n            // If classType is already in the set, it means we have detected a cycle\n            // (i.e., this method is being called recursively for a type that is already\n            // in the process of being registered/resolved).\n            // Returning early prevents a StackOverflowError.\n            return;\n        }\n\n        try {\n            if (!(classType instanceof ParameterizedType)) {\n                return;\n            }\n            ParameterizedType parameterizedType = (ParameterizedType) classType;\n            TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            for (int i = 0; i < actualTypeArguments.length; i++) {\n                TypeVariable typeParameter = typeParameters[i];\n                Type actualTypeArgument = actualTypeArguments[i];\n\n                if (actualTypeArgument instanceof WildcardType) {\n                    // The call to boundsOf might trigger further type resolution,\n                    // which in turn could potentially re-enter this method if a cycle exists.\n                    contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n                } else {\n                    // For non-wildcard types, simply register the direct mapping.\n                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                }\n                // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n            }\n        } finally {\n            // Ensure the type is removed from the 'currentlyRegisteringTypes' set\n            // once the registration process for it is complete, regardless of success or failure.\n            currentlyRegisteringTypes.remove(classType);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}