{
    "generation": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n\n    // Check for potential cyclical references\n    if (visitingTypes.contains(classType)) {\n        return;\n    }\n    visitingTypes.add(classType);\n\n    try {\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        Type rawType = parameterizedType.getRawType();\n        if (!(rawType instanceof Class)) {\n            return;\n        }\n        TypeVariable[] typeParameters = ((Class<?>) rawType).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            if (i >= typeParameters.length) {\n                continue; // in case getTypeParameters() returns fewer than actualTypeArguments\n            }\n            TypeVariable<?> typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else if (actualTypeArgument != typeParameter) { // prevent self-references\n                if (actualTypeArgument instanceof TypeVariable) {\n                    // handle type variables by possibly resolving them\n                    TypeVariable<?> typeVar = (TypeVariable<?>) actualTypeArgument;\n                    Type resolvedType = contextualActualTypeParameters.get(typeVar);\n                    if (resolvedType != null) {\n                        contextualActualTypeParameters.put(typeParameter, resolvedType);\n                    } else {\n                        // if not resolved yet, store the direct mapping\n                        contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                    }\n                } else {\n                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                }\n                // Recursively process nested types\n                if (actualTypeArgument instanceof ParameterizedType) {\n                    registerTypeVariablesOn(actualTypeArgument);\n                }\n            }\n        }\n    } finally {\n        visitingTypes.remove(classType);\n    }\n}\n\n// Add this field to the class\nprivate Set<Type> visitingTypes = new HashSet<>();",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}