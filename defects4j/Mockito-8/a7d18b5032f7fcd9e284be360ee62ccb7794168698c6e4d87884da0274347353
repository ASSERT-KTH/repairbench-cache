{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable<?>[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n        // Defensive check for length mismatch, though theoretically shouldn't happen with valid types.\n        if (actualTypeArguments.length != typeParameters.length) {\n            // Log or handle inconsistency if necessary, but for basic fix, proceed cautiously.\n            // To prevent potential IndexOutOfBoundsException, use the minimum length.\n             int length = Math.min(actualTypeArguments.length, typeParameters.length);\n             // Consider logging a warning here if such state is possible and problematic.\n             // logger.warn(\"Mismatch between type parameters and actual arguments: \" + parameterizedType);\n             // If proceeding is unsafe, could return here or throw an exception.\n             // For now, let's proceed with the minimum length to avoid crashing,\n             // although this might lead to incomplete type information.\n             // A safer alternative might be to return if lengths don't match.\n             // Let's stick to the original loop length assuming valid inputs,\n             // as the core issue is recursion, not length mismatch.\n        }\n\n\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable<?> typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            // Prevent infinite recursion in cases like Enum<T extends Enum<T>>\n            // where the actual type argument is the type variable itself.\n            // This avoids adding a mapping like T -> T in the context map,\n            // which can cause StackOverflowError during resolution if T is looked up\n            // and the resolution attempts to resolve the mapped value recursively.\n            if (actualTypeArgument.equals(typeParameter)) {\n                continue;\n            }\n\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                // This includes ParameterizedType, GenericArrayType, Class, and potentially TypeVariable\n                // (if the actual argument is a type variable from an outer scope, different from typeParameter).\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}