{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            // Fix for self-referential generic types causing StackOverflowError.\n            // If the actualTypeArgument is a ParameterizedType that refers back to\n            // the same raw type and itself contains the typeParameter we are defining,\n            // mapping it directly creates an infinite resolution loop (e.g., T -> GenericsSelfReference<T>).\n            // Instead, we map the typeParameter to itself (T -> T), forcing resolution\n            // to fall back to its declared bounds, which reflection can handle.\n            if (actualTypeArgument instanceof ParameterizedType) {\n                ParameterizedType actualParameterizedType = (ParameterizedType) actualTypeArgument;\n                if (actualParameterizedType.getRawType().equals(parameterizedType.getRawType())) {\n                    boolean foundSelfReference = false;\n                    for (Type arg : actualParameterizedType.getActualTypeArguments()) {\n                        if (arg.equals(typeParameter)) {\n                            contextualActualTypeParameters.put(typeParameter, typeParameter);\n                            foundSelfReference = true;\n                            break;\n                        }\n                    }\n                    if (foundSelfReference) {\n                        // Continue to the next type parameter as this one is handled\n                        continue;\n                    }\n                }\n            }\n\n            // Original logic for other cases\n            if (actualTypeArgument instanceof WildcardType) {\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}