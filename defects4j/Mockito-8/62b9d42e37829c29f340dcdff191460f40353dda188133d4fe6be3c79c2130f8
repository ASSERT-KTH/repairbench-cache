{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n\n        // Prevent infinite recursion for self-referential generic types.\n        // This method is likely part of a class like GenericMetadataSupport.\n        // Assuming 'visitedParameterizedTypes' is a field in the containing class\n        // (e.g., 'private final Set<Type> visitedParameterizedTypes = new HashSet<>();').\n        // If this method is called again with the same parameterizedType instance\n        // while it's still being processed higher up the call stack, we return to break the cycle.\n        // We use 'this' to access the field, assuming the containing class is 'GenericMetadataSupport'.\n        // This cast is typically safe within the context of Mockito's internal classes.\n        if (!((org.mockito.internal.util.reflection.GenericMetadataSupport) this).visitedParameterizedTypes.add(parameterizedType)) {\n            return;\n        }\n\n        try {\n            // Get the raw type of the parameterized type, which should be a Class\n            Class<?> rawType = (Class<?>) parameterizedType.getRawType();\n            // Get the type parameters declared by the raw class (e.g., T in MyClass<T>)\n            TypeVariable[] typeParameters = rawType.getTypeParameters();\n            // Get the actual type arguments for this specific parameterized type instance (e.g., String in MyClass<String>)\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n            // Iterate through the type parameters and their corresponding actual type arguments\n            for (int i = 0; i < actualTypeArguments.length; i++) {\n                TypeVariable typeParameter = typeParameters[i];\n                Type actualTypeArgument = actualTypeArguments[i];\n\n                // If the actual type argument is a WildcardType (e.g., ? extends Number)\n                if (actualTypeArgument instanceof WildcardType) {\n                    // Resolve the bounds of the wildcard and put them into the map.\n                    // The 'boundsOf' method itself might be recursive; this guard prevents\n                    // the entire process from looping if boundsOf indirectly re-enters registerTypeVariablesOn\n                    // with the same ParameterizedType.\n                    contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n                } else {\n                    // Otherwise, put the actual type argument directly into the map\n                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                }\n                // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n            }\n        } finally {\n            // Remove the type from the set once its registration is complete.\n            // This allows the same type to be processed again later if encountered\n            // in a different, independent resolution context, but prevents infinite recursion\n            // within the current single resolution chain.\n            ((org.mockito.internal.util.reflection.GenericMetadataSupport) this).visitedParameterizedTypes.remove(parameterizedType);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}