{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        // A StackOverflowError typically indicates an infinite recursion.\n        // In the context of generic type resolution, this often happens with self-referential\n        // generic types (e.g., `class Foo<T extends Foo<T>>`).\n        // The `registerTypeVariablesOn` method is likely called recursively by a parent method\n        // (e.g., one that traverses superclasses, interfaces, or type variable bounds).\n        // To prevent infinite recursion, we need to keep track of types that have already\n        // been processed during the current resolution path.\n\n        // Assuming 'processedTypes' is a field (e.g., Set<Type>) of the enclosing class\n        // (e.g., GenericMetadataSupport) that gets initialized once per resolution process.\n\n        if (classType == null) {\n            return;\n        }\n\n        // If this type has already been processed or is currently in the call stack,\n        // we've detected a cycle, so we return to break the recursion.\n        if (processedTypes.contains(classType)) {\n            return;\n        }\n        // Mark this type as being processed to prevent future re-processing in this path.\n        processedTypes.add(classType);\n\n        if (!(classType instanceof ParameterizedType)) {\n            // If the type is not a ParameterizedType (e.g., a raw Class, TypeVariable,\n            // GenericArrayType, WildcardType etc.), it doesn't have actual type arguments\n            // directly associated with its own definition that need to be registered in this manner.\n            // We've still marked it as processed to handle potential cycles if it were to\n            // appear again in the traversal.\n            return;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        // getTypeParameters() on the raw class gives the declared type variables (e.g., T for List<T>).\n        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n        // getActualTypeArguments() gives the actual types used (e.g., String for List<String>).\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n        // Iterate through the declared type parameters and their corresponding actual type arguments.\n        // Map the type variable to its actual concrete type or its bounds.\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            if (actualTypeArgument instanceof WildcardType) {\n                // If the actual argument is a wildcard (e.g., `? extends Number`),\n                // map the type parameter to the bounds of the wildcard.\n                // Assuming 'boundsOf' is a helper method available in the class.\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                // Otherwise, map the type parameter directly to its actual type argument.\n                // 'contextualActualTypeParameters' is assumed to be a field (e.g., Map<TypeVariable, Type>)\n                // storing the resolved mappings.\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}