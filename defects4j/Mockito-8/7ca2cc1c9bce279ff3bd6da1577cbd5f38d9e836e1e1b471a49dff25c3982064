{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n        Class<?> rawClass = (Class<?>) parameterizedType.getRawType();\n        TypeVariable[] typeParameters = rawClass.getTypeParameters();\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            TypeVariable typeParameter = typeParameters[i];\n            Type actualTypeArgument = actualTypeArguments[i];\n\n            // Handle self-referential type variables like T in <T extends Foo<T>>.\n            // When 'classType' is a ParameterizedType representing the self-referential\n            // generic (e.g., GenericsSelfReference<T> coming from a method return type or a bound),\n            // 'typeParameter' will be the TypeVariable 'T', and 'actualTypeArgument'\n            // will also be the same TypeVariable 'T'.\n            // Putting a mapping of T -> T or T -> Foo<T> (where Foo<T> refers back to T)\n            // can lead to a StackOverflowError in the resolution logic that uses this map.\n            // To break this cycle, in such specific self-referential cases,\n            // we map the TypeVariable to its raw class (e.g., T -> GenericsSelfReference.class).\n            if (actualTypeArgument instanceof TypeVariable && typeParameter.equals(actualTypeArgument)) {\n                TypeVariable<?> tv = (TypeVariable<?>) typeParameter;\n                Type[] bounds = tv.getBounds();\n                if (bounds.length > 0) {\n                    Type firstBound = bounds[0];\n                    // Check if the first bound is a ParameterizedType whose raw type matches the current rawClass.\n                    // This identifies patterns like T extends GenericsSelfReference<T>.\n                    if (firstBound instanceof ParameterizedType && ((ParameterizedType) firstBound).getRawType().equals(rawClass)) {\n                        // This is the self-referential case. Map the type variable to the raw class\n                        // to prevent infinite recursion during resolution.\n                        contextualActualTypeParameters.put(typeParameter, rawClass);\n                    } else {\n                        // For other cases where T maps to T, but not because of a direct self-referential bound,\n                        // keep the T -> T mapping. This might occur for simple unbounded TypeVariables.\n                        contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                    }\n                } else {\n                    // No bounds specified (e.g., T extends Object), T -> T mapping is generally harmless.\n                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                }\n            } else if (actualTypeArgument instanceof WildcardType) {\n                // Handle wildcard types by determining their effective bounds.\n                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n            } else {\n                // Standard case: map the type variable to its actual concrete or other parameterized type argument.\n                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}