{
    "generation": "    protected void registerTypeVariablesOn(Type classType) {\n        if (!(classType instanceof ParameterizedType)) {\n            return;\n        }\n        ParameterizedType parameterizedType = (ParameterizedType) classType;\n\n        // Fix for StackOverflowError: Prevent infinite recursion by detecting and stopping cycles.\n        // This method relies on a class-level Set (e.g., 'visitedParameterizedTypes')\n        // to track `ParameterizedType` instances that are currently being processed.\n        // This ensures that if the same ParameterizedType is encountered again within\n        // the current resolution path, the method returns early, breaking the cycle.\n        // (Note: The `visitedParameterizedTypes` field itself must be declared and\n        // initialized in the containing class, e.g., `private final Set<Type> visitedParameterizedTypes = new HashSet<>();`)\n        if (this.visitedParameterizedTypes.contains(parameterizedType)) {\n            return;\n        }\n        this.visitedParameterizedTypes.add(parameterizedType);\n\n        try {\n            TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n\n            // Ensure loop iterates only up to the minimum length of type parameters\n            // and actual type arguments to prevent ArrayIndexOutOfBoundsException.\n            int limit = Math.min(typeParameters.length, actualTypeArguments.length);\n\n            for (int i = 0; i < limit; i++) {\n                TypeVariable typeParameter = typeParameters[i];\n                Type actualTypeArgument = actualTypeArguments[i];\n\n                if (actualTypeArgument instanceof WildcardType) {\n                    contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n                } else {\n                    contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n                }\n                // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n            }\n        } finally {\n            // Remove the type from the set to allow it to be processed again\n            // in a different, independent resolution path.\n            this.visitedParameterizedTypes.remove(parameterizedType);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}