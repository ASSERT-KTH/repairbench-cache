{
    "generation": "import java.io.IOException;\nimport org.apache.commons.csv.QuoteMode;\nimport static org.apache.commons.csv.Constants.*; // Assuming constants like LF, CR, SP are defined here\n\n// NOTE: This code snippet includes surrounding context (imports, class declaration)\n// only for context and compilation checking. The final output should only\n// be the function itself as requested.\n// Dummy interface and methods for context:\ninterface DummyInterface {\n    char getDelimiter();\n    Character getQuoteCharacter();\n    QuoteMode getQuoteMode();\n    void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out) throws IOException;\n}\nclass CsvPrinterFix implements DummyInterface {\n    // Dummy implementations\n    @Override public char getDelimiter() { return ','; }\n    @Override public Character getQuoteCharacter() { return '\"'; }\n    @Override public QuoteMode getQuoteMode() { return QuoteMode.MINIMAL; }\n    @Override public void printAndEscape(CharSequence v, int o, int l, Appendable a) throws IOException { a.append(v, o, o+l); }\n\n    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharacter = getQuoteCharacter(); // Keep original signature if needed elsewhere\n        // Assuming quoteCharacter is non-null unless QuoteMode is NONE (which returns early)\n        final char quoteChar = quoteCharacter.charValue();\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code (trusting its implementation)\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line,\n                // as it may be the only thing on the line.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char firstChar = value.charAt(start);\n                char lastChar = value.charAt(end - 1);\n\n                // Condition 1: Quote if starts or ends with whitespace (<= SP). Includes space, tab, etc.\n                if (firstChar <= SP || lastChar <= SP) {\n                    quote = true;\n                } else {\n                    // Condition 2: Quote if contains delimiter, quote char, or newline characters (LF, CR).\n                    // Scan the entire value if no leading/trailing whitespace.\n                    pos = start; // Reset scanner position\n                    while (pos < end) {\n                        final char c = value.charAt(pos);\n                        // Check standard triggers for minimal quoting\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        // NOTE: Removed original problematic checks:\n                        // - `newRecord && (complex range check || c > 0x7E)` : Incorrectly quoted high-ASCII/Unicode.\n                        // - `c <= COMMENT` : Overly broad, quoted non-special chars like '!' and potentially '#' even if not a comment.\n                        // Consider adding explicit comment char check here ONLY if format requires it\n                        // and the comment char itself isn't already covered (e.g. if comment char is ',' or '\"').\n                        // e.g., if (newRecord && pos == start && isCommentMarkerSet() && c == getCommentMarker()) { quote = true; break; }\n                        pos++;\n                    }\n                }\n            }\n\n            // If MINIMAL decided not to quote, print the raw value and return.\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // Otherwise, MINIMAL requires quoting, so break to the common quoting logic.\n            break; // End of MINIMAL case\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End of switch\n\n        // If the policy requires quoting (and MINIMAL didn't return early), proceed.\n        // This 'if' is also reached if ALL, ALL_NON_NULL, or NON_NUMERIC determined quoting is needed.\n        // If a policy like NON_NUMERIC decided *not* to quote, this check handles it.\n        if (!quote) {\n            // No quoting needed based on policy.\n            out.append(value, start, end);\n            return;\n        }\n\n        // --- Quoting Logic --- (Using the original implementation which correctly doubles quotes)\n        out.append(quoteChar); // Start encapsulation.\n\n        // Reset loop variables for the escaping pass.\n        start = offset; // Tracks the start of the current chunk.\n        pos = offset;   // Scans through the value segment.\n\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // Append chunk ending at and including the quote character.\n                out.append(value, start, pos + 1);\n                // Set next chunk start position to be the current quote character's position.\n                // This causes the quote character to be written again by the next append,\n                // effectively doubling it.\n                start = pos;\n            }\n            pos++;\n        }\n\n        // Write the last segment (from last detected quote char up to the end).\n        out.append(value, start, pos); // pos is equal to 'end' here\n        out.append(quoteChar); // End encapsulation.\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}