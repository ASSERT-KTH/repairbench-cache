{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n\n        boolean quote = false; // Default: don't quote unless required by policy or content\n        int start = offset; // Keep original start for potential direct append or escaping loop\n        int pos = offset; // Position tracker, used differently in MINIMAL check vs escaping loop\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        final Character quoteCharRef = getQuoteCharacter();\n        // If quote char is null, quoting is impossible. Mode NONE is effectively forced.\n        // This should ideally be handled by format validation or higher up.\n        // Assuming quoteCharRef is non-null if quoteMode is not NONE.\n        final char quoteChar = (quoteCharRef == null ? 0 : quoteCharRef.charValue()); // Use 0 if null, though should not happen for quoting modes\n\n        QuoteMode quoteModePolicy = getQuoteMode();\n        if (quoteModePolicy == null) {\n            quoteModePolicy = QuoteMode.MINIMAL;\n        }\n\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n             // Assuming null handling is done elsewhere; if we are here, quote it.\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            // Quote if the original object was not a number.\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // No quoting, just escape specific characters like delimiter, CR, LF.\n            printAndEscape(value, offset, len, out);\n            return; // Done for NONE mode.\n        case MINIMAL:\n            // Quote only if necessary according to RFC 4180 minimal rules:\n            // 1. Field is empty and it's the first record.\n            // 2. Field contains delimiter, quote character, CR, or LF.\n            if (len <= 0) {\n                if (newRecord) {\n                    quote = true;\n                }\n                // If empty but not first record, no quote needed by minimal rules.\n            } else {\n                // Scan for characters that require quoting.\n                // Reset pos to start for scanning the whole value\n                pos = offset;\n                while (pos < end) {\n                    final char c = value.charAt(pos);\n                    // Standard triggers requiring quotes in MINIMAL mode (RFC 4180)\n                    // Assuming constants LF and CR are defined elsewhere (e.g., Constants.LF, Constants.CR)\n                    if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                        quote = true;\n                        break; // Found a character requiring quoting\n                    }\n                    pos++;\n                }\n                // If loop finishes without finding quote triggers, quote remains false.\n                // Removed non-standard checks for first char range, comment char start, and trailing space.\n            }\n\n            // If minimal checks determined no quote needed, print raw and return.\n            if (!quote) {\n                // Ensure using original start and calculated end for the slice\n                out.append(value, offset, end);\n                return;\n            }\n            // Otherwise 'quote' is true, fall through to quoting logic below.\n            break; // Break from MINIMAL case\n        default:\n            // Should not happen if QuoteMode is a proper enum.\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        }\n\n        // If we reach here, quote must be true (from ALL, ALL_NON_NULL, NON_NUMERIC, or MINIMAL needing quotes).\n        // Perform quoting and escaping\n\n        // Append opening quote\n        out.append(quoteChar);\n\n        // Reset start and pos for the escaping loop - start tracks the beginning of the current segment,\n        // pos scans through the value. Using original variable names here for minimal diff.\n        // 'start' is already 'offset' from the beginning of the function scope.\n        pos = offset;   // Reset scanner position to the beginning of the value\n\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                // write out the chunk up until this point (inclusive)\n                out.append(value, start, pos + 1);\n                // Set start for the next chunk to be this quote char's position,\n                // effectively doubling it when the next chunk is printed.\n                start = pos; // The original code's logic for doubling quotes\n            }\n            pos++; // Advance scan position\n        }\n\n        // write the last segment (from last quote char found, or from the beginning if none found)\n        out.append(value, start, pos); // pos is now == end\n        // Append closing quote\n        out.append(quoteChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}