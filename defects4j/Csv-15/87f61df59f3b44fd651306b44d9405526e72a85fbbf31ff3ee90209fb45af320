{
    "generation": "    // the original object is needed so can check for Number\n    private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n            final Appendable out, final boolean newRecord) throws IOException {\n        boolean quote = false;\n        int start = offset;\n        int pos = offset;\n        final int end = offset + len;\n\n        final char delimChar = getDelimiter();\n        // Use Character wrapper type as quote char is optional in CSVFormat\n        final Character quoteChar = getQuoteCharacter();\n        // Handle null quote mode as MINIMAL\n        final QuoteMode quoteModePolicy = getQuoteMode() == null ? QuoteMode.MINIMAL : getQuoteMode();\n\n        switch (quoteModePolicy) {\n        case ALL:\n        case ALL_NON_NULL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            // Quote if the original object is not a Number\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the escape character logic (if escape is set, otherwise standard string)\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // Always quote an empty token that is the first on the line\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                // MINIMAL mode requires a quote character\n                if (quoteChar == null) {\n                    throw new IllegalStateException(\"Cannot use MINIMAL quoting mode with no quote character defined\");\n                }\n                final char qChar = quoteChar.charValue();\n                final char firstChar = value.charAt(start);\n                final char lastChar = value.charAt(end - 1);\n\n                // Check for standard reasons to quote (delimiter, quote char itself, line breaks)\n                while (pos < end) {\n                    final char c = value.charAt(pos);\n                    // Note: Constants.LF, Constants.CR, Constants.SP assumed available/imported\n                    if (c == LF || c == CR || c == qChar || c == delimChar) {\n                        quote = true;\n                        break;\n                    }\n                    pos++;\n                }\n\n                if (!quote) {\n                    // Check for other reasons based on format settings (comment start, surrounding spaces)\n                    // Check if field starts with a comment marker (if comment marker is enabled)\n                    // Use getFormat() to access format settings from CSVPrinter instance\n                    if (getFormat().isCommentMarkerSet() && getFormat().getCommentMarker().charValue() == firstChar) {\n                        quote = true;\n                    } else if (!getFormat().getIgnoreSurroundingSpaces()) {\n                        // Check for leading/trailing spaces or control chars (<= SP) if spaces are significant\n                        if (firstChar <= SP || lastChar <= SP) {\n                            quote = true;\n                        }\n                    }\n                    // Removed overly aggressive quoting based on first char range (like > 0x7E) or <= COMMENT constant\n                    // The original check 'if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E))' is removed.\n                    // The original check 'else if (c <= COMMENT)' is removed and replaced by the specific comment marker check above.\n                }\n            }\n\n            // If MINIMAL decided not to quote, write the raw value and return\n            if (!quote) {\n                out.append(value, start, end);\n                return;\n            }\n            // If MINIMAL decided to quote, fall through to the quoting logic below\n            break; // End MINIMAL case\n\n        default:\n            throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n        } // End switch\n\n        // If the policy decided not to quote (currently only possible for NON_NUMERIC), write raw and return\n        if (!quote) {\n            out.append(value, start, end);\n            return;\n        }\n\n        // --- Quoting is required ---\n        // Ensure quote character is defined (should be true unless policy was NONE, which returned early)\n        if (quoteChar == null) {\n            // This should be unreachable if logic above is correct, but defensive check is ok.\n            throw new IllegalStateException(\"Trying to quote output when no quote character is defined\");\n        }\n        final char qChar = quoteChar.charValue();\n\n        // Write the opening quote\n        out.append(qChar);\n\n        // Write the value, doubling internal quote characters\n        // Reset start and pos for iterating through the value for quoting\n        start = offset;\n        pos = offset;\n        while (pos < end) {\n            final char c = value.charAt(pos);\n            if (c == qChar) {\n                // Write the segment leading up to the quote character (inclusive)\n                out.append(value, start, pos + 1);\n                // Set the start of the next segment to the position of the quote char.\n                // This ensures the quote char is output again when the next segment is written.\n                start = pos;\n            }\n            pos++;\n        }\n\n        // Write the last segment of the value\n        out.append(value, start, pos); // pos is equal to 'end' here\n\n        // Write the closing quote\n        out.append(qChar);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}