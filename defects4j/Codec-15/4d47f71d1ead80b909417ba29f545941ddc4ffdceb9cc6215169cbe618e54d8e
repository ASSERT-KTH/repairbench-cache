{
    "generation": "    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     * Vowels are generally ignored in Soundex, mapping to '0'.\n     * H and W are also ignored ('0'), but affect adjacent consonants.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character, or the NUL character (0) \n     *         if the character should be skipped (e.g., due to the H-W rule).\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped (though the default mapping covers all uppercase letters)\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        // mappedChar: The code ('0'-'6') for the character at str.charAt(index).\n        final char mappedChar = this.map(str.charAt(index));\n\n        // HW rule check:\n        // Apply only if the current character is a consonant (mappedChar != '0')\n        // and there are at least two preceding characters (index > 1).\n        if (index > 1 && mappedChar != '0') {\n            final char hwChar = str.charAt(index - 1);\n            // Check if the immediately preceding character is 'H' or 'W'.\n            if ('H' == hwChar || 'W' == hwChar) {\n                // Get the character before the 'H' or 'W'.\n                final char preHWChar = str.charAt(index - 2);\n                // Get the mapping code for the character before the 'H' or 'W'.\n                final char firstCode = this.map(preHWChar);\n                // If the code before the H/W is the same as the code after the H/W,\n                // the current character's code should be ignored (return NUL char 0).\n                if (firstCode == mappedChar) {\n                    // Consonants from the same code group separated by H or W are treated as one.\n                    // Example: ASHCRAFT -> A S(2) H C(2) R(6) A F(1) T(3)\n                    // C is ignored because S=2, H separates, C=2. Result A261\n                    // Example: YHWDYT -> Y H W D(3) Y T(3)\n                    // D is not ignored because map(H) = 0, which != map(D) = 3. Result Y330\n                    return 0; // Return NUL char (value 0) to indicate skipping this code.\n                }\n                // The original buggy code had an additional check here:\n                // || 'H' == preHWChar || 'W' == preHWChar\n                // This incorrectly caused characters to be skipped if the character\n                // two positions back was H or W, regardless of code matching.\n                // For YHWDYT, D was skipped because preHWChar was 'H'.\n            }\n        }\n        // Return the mapped code ('0'-'6') for the current character.\n        // The calling function (soundex) handles skipping vowels ('0') and adjacent duplicates.\n        return mappedChar;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}