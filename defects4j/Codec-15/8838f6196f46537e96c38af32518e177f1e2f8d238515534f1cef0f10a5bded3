{
    "generation": "/**\n * Used internally by the Soundex algorithm.\n *\n * Consonants from the same code group separated by W or H are treated as one.\n *\n * @param str\n *                  the cleaned working string to encode (in upper case).\n * @param index\n *                  the character position to encode\n * @return Mapping code for a particular character, or 0 to indicate \"skip\"\n * @throws IllegalArgumentException\n *                  if the character is not mapped\n */\nprivate char getMappingCode(final String str, final int index) {\n    // map() may throw IllegalArgumentException for unsupported chars\n    final char mappedChar = this.map(str.charAt(index));\n    // apply the HW\u2010rule only for consonants (i.e. mappedChar != '0') and if there's room to look back\n    if (mappedChar != '0' && index > 1) {\n        // if the immediately preceding character is H or W\n        char sep = str.charAt(index - 1);\n        if (sep == 'H' || sep == 'W') {\n            // walk back past any chain of H/W\n            int prevIdx = index - 2;\n            while (prevIdx >= 0 && (str.charAt(prevIdx) == 'H' || str.charAt(prevIdx) == 'W')) {\n                prevIdx--;\n            }\n            // if we found a real consonant/vowel before the H/W chain\n            if (prevIdx >= 0) {\n                char prevCode = this.map(str.charAt(prevIdx));\n                // if it maps to the same code, treat as the same group \u21d2 skip this one\n                if (prevCode == mappedChar) {\n                    return 0;\n                }\n            }\n        }\n    }\n    return mappedChar;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}