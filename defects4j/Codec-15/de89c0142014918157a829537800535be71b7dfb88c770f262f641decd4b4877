{
    "generation": "    /**\n     * Used internally by the Soundex algorithm.\n     *\n     * Consonants from the same code group separated by W or H are treated as one.\n     * H and W are otherwise ignored. Vowels are ignored.\n     *\n     * @param str\n     *                  the cleaned working string to encode (in upper case).\n     * @param index\n     *                  the character position to encode\n     * @return Mapping code for a particular character, or '0' if the character should be ignored.\n     * @throws IllegalArgumentException\n     *                  if the character is not mapped\n     */\n    private char getMappingCode(final String str, final int index) {\n        // map() throws IllegalArgumentException\n        // Map the character at the specified index to its Soundex code.\n        final char mappedChar = this.map(str.charAt(index));\n\n        // HW Rule: Consonants from the same code group separated by H or W are treated as one.\n        // Check if:\n        // 1. We are at least at the third character (index > 1)\n        // 2. The current character maps to a consonant code (mappedChar != '0')\n        if (index > 1 && mappedChar != '0') {\n            final char prevChar = str.charAt(index - 1);\n            // 3. The immediately preceding character is H or W\n            if ('H' == prevChar || 'W' == prevChar) {\n                // If H or W precedes the current character, look at the character before H/W\n                final char prevPrevChar = str.charAt(index - 2);\n                final char prevPrevCode = this.map(prevPrevChar);\n                // 4. If the character before H/W maps to the same code as the current character\n                if (prevPrevCode == mappedChar) {\n                    // Treat the current character as code '0' (ignore it)\n                    return '0';\n                }\n                // Note: The original code had an additional condition here:\n                // || 'H' == prevPrevChar || 'W' == prevPrevChar\n                // This was incorrect, as it would ignore the current character if the character\n                // *before* the H/W was itself H or W, regardless of codes matching.\n                // Example: In YHWDYT, 'D' (code 3) would be incorrectly ignored because the\n                // character 'H' (prevPrevChar) precedes 'W'. The corrected logic correctly compares\n                // map(D) which is 3, with map(H) which is 0, finds they are different, and thus\n                // does not return '0' based on this rule.\n            }\n        }\n        // If the HW rule does not apply, or the character is a vowel/ignored, return its mapped code.\n        return mappedChar;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}