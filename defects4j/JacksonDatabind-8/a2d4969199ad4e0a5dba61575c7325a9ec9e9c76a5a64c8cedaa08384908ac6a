{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n            // [databind#1389]: If the incoming creator is the exact same as the one already registered,\n            // it's not a conflict, just a re-discovery/re-registration.\n            // This is especially true for implicitly discovered creators like default constructors.\n            if (oldOne.getMember().equals(newOne.getMember())) {\n                // If the new one is explicit, ensure the explicit bit is set.\n                // This covers cases where it was previously implicit but now discovered explicitly.\n                if (explicit) {\n                    _explicitCreators |= mask;\n                }\n                // No need to update _creators[typeIndex] as it's the same creator.\n                return;\n            }\n\n            // Original logic for handling conflicts for *different* creators.\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n                // both explicit: verify (means continue to check for conflict below)\n            }\n\n            // At this point: oldOne != null, and oldOne.getMember() != newOne.getMember().\n            // This means we are comparing two *different* creator members.\n            // If they are of the same wrapper type (e.g., both AnnotatedConstructor), then it's a conflict.\n            // If they are different wrapper types (e.g., AnnotatedConstructor vs AnnotatedMethod),\n            // the new one will just overwrite the old one (as per the final assignment below).\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: avoid one particular class of bogus problems (context for original exception)\n                // This throw is now correct because we've already filtered out cases where they are the *same* member.\n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            }\n        }\n        // If we reach here, either:\n        // 1. oldOne was null (no existing creator)\n        // 2. oldOne existed, but was the same member as newOne (handled by 'return' above)\n        // 3. oldOne existed, was explicit, but newOne was not explicit (handled by 'return' above)\n        // 4. oldOne existed, was non-explicit, newOne was explicit (newOne replaces oldOne)\n        // 5. oldOne existed, was non-explicit, newOne was non-explicit, BUT oldOne.getClass() != newOne.getClass()\n        //    (e.g., a constructor creator vs a factory method creator, both non-explicit; newOne replaces oldOne)\n\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}