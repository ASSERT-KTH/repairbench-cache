{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        \n        if (oldOne != null) {\n            // Case 1: 'newOne' is the exact same creator as 'oldOne' (e.g., same constructor/method)\n            // If they refer to the same underlying member, it's not a conflict.\n            // We only need to potentially update if 'newOne' is explicit and 'oldOne' was not.\n            if (oldOne.getAnnotated().equals(newOne.getAnnotated())) {\n                // If oldOne was already explicit, or newOne is not explicit, no change is needed.\n                // The explicit flag is already set correctly, or no improvement is offered.\n                if ((_explicitCreators & mask) != 0 || !explicit) {\n                    return;\n                }\n                // Else: oldOne was NOT explicit, and newOne IS explicit. Fall through to update.\n            } else {\n                // Case 2: 'newOne' is a different creator from 'oldOne'. This is a potential conflict.\n                // Check if 'oldOne' was explicitly marked.\n                if ((_explicitCreators & mask) != 0) { \n                    // If 'oldOne' was explicitly annotated, and 'newOne' is not, 'oldOne' wins.\n                    if (!explicit) {\n                        return;\n                    }\n                    // Both 'oldOne' and 'newOne' are explicitly marked AND they are different => CONFLICT!\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                \n                // At this point: 'oldOne' was NOT explicitly marked.\n                // If 'newOne' IS explicit, 'newOne' wins and replaces 'oldOne'. (Handled by lines outside this block)\n                // If 'newOne' is NOT explicit, and 'oldOne' is NOT explicit, AND they are different\n                // but of the same \"kind\" (e.g., both constructors or both factory methods), then it's a conflict.\n                if (oldOne.getClass() == newOne.getClass()) {\n                    // [databind#667]: avoid one particular class of bogus problems where non-explicit\n                    // creators of same type (e.g. constructor) would conflict.\n                    // This is a conflict if both are not explicit and are different but same kind.\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had \"+oldOne+\", encountered \"+newOne);\n                }\n                // If oldOne was not explicit, and newOne is not explicit, but they are of different kinds\n                // (e.g., constructor vs static factory), no conflict: the new one will override the old one.\n            }\n        }\n        \n        // If we reach here, it means 'newOne' should be registered/updated.\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}