{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        if (oldOne != null) { // If already have one...\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n            // [databind#333]: If old one was explicit, new one not, keep old one\n            if (oldExplicit) {\n                if (!explicit) {\n                    return; // Ignore new implicit one, keep old explicit one\n                }\n                // Both explicit: verify if compatible, or throw exception etc\n            } else {\n                // Old one was not explicit: if new one is, it has precedence\n                // (regardless of context class; explicit always wins over implicit)\n                if (!explicit) {\n                    // Both implicit: compatibility? Check class, for now: just override\n                    // Mismatch? Seems like we should use the one from sub-class but... how to check?\n                    // -> actually, we can just check classes:\n                    //    if `newOne` is in subclass, it's preferred.\n                    // This check should only matter if they are in same class:\n//                    if (oldOne.getClass() == newOne.getClass()) {\n                         // if view information available, might try selecting one... ?\n                         // but for now, conflict if they are same type, same class:\n                    // changing to NOT throw, assuming new one is simply preferred\n// Let's not throw an exception here; simply override. May need to revisit this decision\n//                        throw new IllegalArgumentException(\"Conflicting implicit \"+TYPE_DESCS[typeIndex]+\" creators: already had \"+oldOne+\", encountered \"+newOne);\n//                    }\n                    // Otherwise, just leave it; new one is assumed to override\n                }\n                // If new is explicit, old implicit, new one will override (handled below)\n            }\n\n            // One more thing: ok to override in sub-class\n            if (oldOne.getClass() == newOne.getClass()) {\n                // If both explicit, check compatibility (or just conflict?)\n                if (oldExplicit && explicit) {\n                    // [databind#667]: avoid one particular class of bogus problems\n                    // If they are same type, same class, duplicates are problematic. Might\n                    // be ok if signatures differ in terms of being ignored... but otherwise conflict.\n                    // For now, let's just throw the exception if both are explicit and in same class\n                    throw new IllegalArgumentException(String.format(\"Conflicting %s creators: already had explicitly marked %s, encountered explicit %s\",\n                           TYPE_DESCS[typeIndex], oldOne, newOne));\n                }\n                // Otherwise, if one explicit, one implicit, explicit one wins (handled already or by overriding below)\n                // If both implicit, new one will override old one (handled below)\n            }\n            // else, different classes; subclass definition overrides superclass one(s)\n        }\n\n        /* If we get this far, means we accept the new one, possibly overriding\n         * an existing one: either new one is explicit and old was not; OR\n         * neither is explicit and new one is in subclass.\n         */\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}