{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        // NOTE: moved _hasNonDefaultCreator = true down before assignments\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had one?\n        if (oldOne != null) {\n            // If they refer to the same actual constructor or method, not a conflict:\n            // (note: equals() check on AnnotatedX is based on underlying AnnotatedElement)\n            if (oldOne.equals(newOne)) { // Fixed check\n                // The only tricky case; if finding \"same\" constructor, but one with\n                // mix-in annotations, keep that one. Or first one, for that matter.\n                // Let's assume first one is fine.\n                // 01-Sep-2019, tatu: As per [databind#2417], ignore if conditionally ignorable...\n                //   Ideally would be checked earlier, but complicates logic; shouldn't affect\n                //   behavior otherwise.\n                if (newOne.hasIgnoreMarker()) { // condition added for [databind#2417]\n                    return;\n                }\n                // also: if new one is explicitly marked (and old one maybe not), possibly replace?\n                if (explicit && (_explicitCreators & mask) == 0) {\n                    // fall through to logic below\n                } else {\n                    return; // Just ignore duplicate registration\n                }\n            }\n\n            // already had an explicitly marked one?\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return; // Keep previous explicit one\n                }\n                // both explicit: verify below\n            } else { // old one was not explicit\n                // If new one is explicit, it overrides implicit one anyways. Fall through.\n                 if (!explicit) {\n                     // Both implicit; should we just... maybe consider more specific one to be winner?\n                     // Or, for now, what is behavior? Seems like we choose later one...\n                     // Fall through to verify\n                 }\n            }\n\n            // one more thing: ok to override in sub-class\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: avoid one particular class of bogus problems\n                // If we get here, we have two different creators (checked by equals() above)\n                // of the same 'kind' (AnnotatedConstructor vs AnnotatedConstructor etc)\n                // and the explicit checks didn't rule one out. This implies a conflict.\n                // 11-Feb-2017, tatu: Note: `equals()` check above should prevent identical matches.\n                //   It is still possible that we have constructor/factory method overrides. Let's\n                //   try to allow based on parameter count; this seems safe enough closer to root\n                //   Object class. May need to refine further in future.\n                //\n                // 18-Feb-2019, tatu: As per [databind#2183], Needs to check declaring class as well;\n                //    and apparently subclasses must be considered same class\n                Class<?> oldClass = oldOne.getDeclaringClass();\n                Class<?> newClass = newOne.getDeclaringClass();\n\n                if (oldClass != newClass) {\n                    if (newClass.isAssignableFrom(oldClass)) { // Old is more specific\n                        // keep old\n                         return;\n                    }\n                    if (!oldClass.isAssignableFrom(newClass)) { // New is more specific\n                        // keep new; fall through\n                        // 28-Jul-2021, tatu: Except as per [databind#3249], need to ensure not bogus conflict\n                        //    likestatic factory method vs constructor. But... for that, let's\n                        //    refine check below\n                        // Fall-through\n                    } else { // unrelated classes\n                        // 28-Jul-2021, tatu: As per [databind#3249], needs to check this is actual conflict;\n                        //    specifically, static factory method in super class, constructor in sub-class\n                        //    should not conflict.\n                        if (newOne.getMember() instanceof java.lang.reflect.Constructor<?>) {\n                            // If new one is constructor, old one must be something else, keep old\n                            return;\n                        }\n                        // Otherwise assume new one is fine\n                    }\n                } else { // Same declaring class\n                    // Otherwise, conflict if exact same number of arguments\n                    // (NOTE: ideally would check parameter types but gets complicated)\n                    if (oldOne.getParameterCount() == newOne.getParameterCount()) {\n                        throw new IllegalArgumentException(String.format(\"Conflicting %s creators: already had %s creator %s, encountered another: %s\",\n                                TYPE_DESCS[typeIndex],\n                                ((_explicitCreators & mask) != 0) ? \"explicitly marked\" : \"implicitly discovered\",\n                                oldOne, newOne));\n                    }\n                    // If different number of arguments, assume it's ok, keep the one with more args? Choose new one?\n                    if (newOne.getParameterCount() > oldOne.getParameterCount()) {\n                        // fall through, override below\n                    } else {\n                        // keep old one\n                        return;\n                    }\n                }\n            }\n            // If oldOne.getClass() != newOne.getClass(), original code implies no conflict check needed.\n        }\n\n        // If we get this far, we accept the new one\n        _hasNonDefaultCreator = true;\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}