{
    "generation": "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit) {\n    final int mask = (1 << typeIndex);\n    _hasNonDefaultCreator = true;\n    AnnotatedWithParams oldOne = _creators[typeIndex];\n    if (oldOne != null) {\n        boolean oldExplicit = (_explicitCreators & mask) != 0;\n        // if we already had an explicit creator, ignore a non-explicit one\n        if (oldExplicit && !explicit) {\n            return;\n        }\n        // if both are explicit or both are implicit, try to resolve by parameter\u2010type specificity\n        if (oldExplicit == explicit) {\n            java.lang.reflect.Member m1 = oldOne.getMember();\n            java.lang.reflect.Member m2 = newOne.getMember();\n            Class<?> cls1 = null, cls2 = null;\n            if (m1 instanceof java.lang.reflect.Method && m2 instanceof java.lang.reflect.Method) {\n                java.lang.reflect.Method md1 = (java.lang.reflect.Method) m1;\n                java.lang.reflect.Method md2 = (java.lang.reflect.Method) m2;\n                if (md1.getParameterCount() == 1 && md2.getParameterCount() == 1) {\n                    cls1 = md1.getParameterTypes()[0];\n                    cls2 = md2.getParameterTypes()[0];\n                }\n            } else if (m1 instanceof java.lang.reflect.Constructor && m2 instanceof java.lang.reflect.Constructor) {\n                java.lang.reflect.Constructor<?> ct1 = (java.lang.reflect.Constructor<?>) m1;\n                java.lang.reflect.Constructor<?> ct2 = (java.lang.reflect.Constructor<?>) m2;\n                if (ct1.getParameterCount() == 1 && ct2.getParameterCount() == 1) {\n                    cls1 = ct1.getParameterTypes()[0];\n                    cls2 = ct2.getParameterTypes()[0];\n                }\n            }\n            if (cls1 != null && cls2 != null) {\n                if (cls1.isAssignableFrom(cls2)) {\n                    // new parameter type more specific -> override oldOne\n                } else if (cls2.isAssignableFrom(cls1)) {\n                    // old parameter type more specific -> keep oldOne\n                    return;\n                } else {\n                    // ambiguous -> error\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n            } else {\n                // not a single-param case we can resolve -> error\n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                    +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            }\n        }\n        // else: old was implicit and new is explicit, so fall through and override\n    }\n    if (explicit) {\n        _explicitCreators |= mask;\n    }\n    _creators[typeIndex] = _fixAccess(newOne);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}