{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true; // Always true if we're adding or updating a creator\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        if (oldOne != null) {\n            // Case 1: oldOne and newOne are the exact same creator (same underlying Constructor/Method)\n            if (oldOne.getAnnotated() == newOne.getAnnotated()) {\n                // No conflict, just update explicit flag and creator entry if needed, then return.\n                if (explicit) {\n                    _explicitCreators |= mask;\n                }\n                _creators[typeIndex] = _fixAccess(newOne);\n                return; // Handled, no further conflict checking needed.\n            }\n\n            // Case 2: oldOne and newOne are different creators.\n            boolean oldOneExplicit = ((_explicitCreators & mask) != 0);\n\n            if (oldOneExplicit) { // oldOne was explicitly annotated\n                if (!explicit) { // newOne is not explicit\n                    return; // Explicit old creator wins over non-explicit new one.\n                }\n                // Both oldOne and newOne are explicit AND DIFFERENT. This IS a conflict.\n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            }\n            // oldOne was NOT explicitly annotated.\n            if (explicit) { // newOne IS explicit\n                // New explicit creator wins over old non-explicit one.\n                // This means newOne will be assigned below and its explicit flag set.\n                // No 'return' needed, allow the assignment to proceed.\n            } else { // Both oldOne and newOne are NOT explicit AND DIFFERENT. This IS a conflict.\n                // This applies to [databind#667]: avoids two DIFFERENT non-explicit creators\n                // of the same \"kind\" (e.g., two different AnnotatedConstructor instances).\n                if (oldOne.getClass() == newOne.getClass()) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had \"+oldOne+\", encountered \"+newOne);\n                }\n            }\n        }\n        // If we reach here, it means:\n        // 1. oldOne was null (first creator for this typeIndex).\n        // 2. oldOne was non-explicit, newOne is explicit (newOne wins).\n        // 3. oldOne was non-explicit, newOne is non-explicit, BUT oldOne.getClass() != newOne.getClass()\n        //    (e.g., old was AnnotatedConstructor, new is AnnotatedMethod - allow replacement as they are different \"kinds\").\n        // In all these cases, `newOne` is now the chosen creator.\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}