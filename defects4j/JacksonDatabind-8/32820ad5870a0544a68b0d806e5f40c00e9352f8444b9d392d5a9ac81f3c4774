{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        if (oldOne != null) { // If collision possible\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n            // First: is the new one same as the old one?\n            // NOTE: equals() likely checks underlying Member\n            if (oldOne.equals(newOne)) { // [databind#667], [databind#2343] Same creator method/ctor found twice?\n                // If new one is explicit, old was not, mark as explicit:\n                if (explicit && !oldExplicit) {\n                    _explicitCreators |= mask;\n                    // We could also potentially replace 'oldOne' with 'newOne' but they are identical\n                    // except for annotation flags, which should not matter...\n                    // So, just return for now.\n                 }\n                 // otherwise, old one was explicit (and new one may or may not be), OR\n                 // neither is explicit: just ignore discovery of the duplicate\n                 return;\n            }\n\n            // Different creators.\n\n            // If old one was explicit, new one not -> keep old one\n            if (oldExplicit && !explicit) {\n                return; // Ignore new one, favor explicit old one\n            }\n            // If old one was not explicit, new one is -> new one wins (will be assigned later)\n            if (!oldExplicit && explicit) {\n                // Fall through to assignment below\n            } else {\n                // Both explicit or both implicit: verify\n                // Ok to override in sub-class; check for that:\n                // Also: check if declaring classes are same (must be then)\n                 if (oldOne.getDeclaringClass() == newOne.getDeclaringClass()) {\n                     // [databind#667] Avoid problems with duplicate checks for same things, just\n                     // add specific check for actual conflict:\n                     // One more check: is parameter count different? Better match?\n                     // TBD? Check parameter types? That would be more specific...\n                     // But for now, just consider explicit markers.\n                     if (explicit && oldExplicit) { // Both explicit is definite conflict\n                         throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                                 +\" creators: already had explicitly marked \"+oldOne+\", encountered explicit \"+newOne);\n                     }\n                     // Otherwise, implicit; just prefer the first one found? Or last?\n                     // Jackson's default behavior seems to be \"last one wins\", so fall through.\n                     // The original code threw an exception here for implicit/implicit conflict,\n                     // but that seems too strict, better to let the last one discovered win.\n                 }\n                 // Different declaring class: inheritance; subclass definition overrides superclass\n            }\n        }\n\n        // If we reach here, the new one is considered better or the only one found so far.\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}