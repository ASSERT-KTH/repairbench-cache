{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true; // This flag is set regardless of conflict resolution\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        if (oldOne != null) {\n            // Rule 1: If they represent the exact same underlying constructor/method, it's not a conflict.\n            // This handles cases where the same creator is discovered multiple times via different paths.\n            if (oldOne.getMember().equals(newOne.getMember())) {\n                return;\n            }\n\n            // Otherwise, oldOne and newOne are different members.\n            final boolean oldOneExplicit = ((_explicitCreators & mask) != 0);\n\n            if (oldOneExplicit) { // Scenario A: oldOne was explicitly marked\n                // Rule 2: If oldOne is explicit, but newOne is NOT explicit, keep oldOne and ignore newOne.\n                if (!explicit) {\n                    return;\n                }\n                // Scenario A.1: Both oldOne and newOne are explicit AND represent different members.\n                // This is generally a conflict, but we check for specificity for delegating creators.\n                // CREATOR_DELEGATING typically corresponds to typeIndex == 1\n                if (typeIndex == 1) { // Apply specificity rules for delegating creators\n                    // This logic only applies to single-argument creators for delegation.\n                    if (oldOne.getParameterCount() == 1 && newOne.getParameterCount() == 1) {\n                        Class<?> oldParam = oldOne.getRawParameterType(0);\n                        Class<?> newParam = newOne.getRawParameterType(0);\n                        // If new one's parameter type is assignable from old one's (new is less specific, old is more specific or same)\n                        // OR if old one's parameter type is assignable from new one's (old is less specific, new is more specific or same)\n                        if (oldParam.isAssignableFrom(newParam)) { // e.g., oldParam=CharSequence, newParam=String. newOne is more specific.\n                            // Accept newOne (more specific explicit creator overrides less specific explicit creator).\n                            // Allow to fall through to update _creators and _explicitCreators.\n                        } else if (newParam.isAssignableFrom(oldParam)) { // e.g., oldParam=String, newParam=CharSequence. oldOne is more specific.\n                            // Keep oldOne (more specific explicit creator).\n                            return;\n                        }\n                    }\n                }\n                // If not resolved by specificity (e.g., not a single-arg delegating creator, or no clear specificity),\n                // it's a conflict between two different explicit creators.\n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n            }\n            // Scenario B: oldOne was NOT explicitly marked\n            else { // !oldOneExplicit\n                // Rule 3: If newOne IS explicitly marked, it overrides the non-explicit oldOne.\n                if (explicit) {\n                    // Allow to fall through to update _creators and _explicitCreators. No throw needed.\n                }\n                // Scenario B.1: Both oldOne and newOne are NOT explicitly marked AND different members.\n                // This is generally a conflict, but we check for specificity for delegating creators.\n                else {\n                    // CREATOR_DELEGATING typically corresponds to typeIndex == 1\n                    if (typeIndex == 1) { // Apply specificity rules for delegating creators\n                        if (oldOne.getParameterCount() == 1 && newOne.getParameterCount() == 1) {\n                            Class<?> oldParam = oldOne.getRawParameterType(0);\n                            Class<?> newParam = newOne.getRawParameterType(0);\n                            if (oldParam.isAssignableFrom(newParam)) { // newOne is more specific or equally specific\n                                // Accept newOne (more specific non-explicit creator overrides less specific non-explicit creator).\n                                // Allow to fall through.\n                            } else if (newParam.isAssignableFrom(oldParam)) { // oldOne is more specific\n                                // Keep oldOne (more specific non-explicit creator).\n                                return;\n                            }\n                        }\n                    }\n                    // If not resolved by specificity, it's a conflict between two different non-explicit creators.\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had non-explicit creator \"+oldOne+\", encountered non-explicit \"+newOne);\n                }\n            }\n        }\n        // If we reach here, it means:\n        // - oldOne was null (no previous creator)\n        // - oldOne and newOne were the same member (handled by early return)\n        // - oldOne was non-explicit, and newOne is explicit (new explicit overrides old non-explicit)\n        // - For delegating creators, newOne was more specific than oldOne (either both explicit or both non-explicit).\n        // In all these cases, newOne is the one to be used.\n\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}