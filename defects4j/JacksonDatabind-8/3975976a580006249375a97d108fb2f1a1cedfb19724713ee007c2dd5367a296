{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true; // Mark that we have a non-default creator\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        // Does creator already exist?\n        if (oldOne != null) {\n            boolean oldExplicit = (_explicitCreators & mask) != 0;\n            Class<?> oldClass = oldOne.getDeclaringClass();\n            Class<?> newClass = newOne.getDeclaringClass();\n\n            // 0: Is the new one effectively the same as the old one?\n            // (NOTE: Added in 2.7.1; was missing from initial 2.7.0)\n            if (oldClass == newClass && oldOne.getMember().equals(newOne.getMember())) {\n                // 16-Feb-2016, tatu: Ok, but we choose 'newOne' if it is explicit and old was not\n                if (explicit && !oldExplicit) {\n                    // need to change state appropriately\n                    _creators[typeIndex] = _fixAccess(newOne);\n                    _explicitCreators |= mask;\n                }\n                // otherwise, old one is fine, explicit or not\n                return;\n            }\n\n            // If they are non-identical members, or from different classes:\n            if (explicit) {\n                if (oldExplicit) { // Both explicit\n                    // [databind#667]: Explicit creator in subclass MUST override creator in superclass\n                    // 16-Feb-2016, tatu: And verification should be done based on declaring class\n                    if (oldClass == newClass) { // Same class, different members: Conflict!\n                         throw new IllegalArgumentException(String.format(\n                                \"Conflicting %s creators: already had explicitly marked %s, encountered explicit %s (both in class %s)\",\n                                TYPE_DESCS[typeIndex], oldOne, newOne, newClass.getName()));\n                    }\n                    // Different classes: check subclass relationship\n                    // `parent.isAssignableFrom(child)` is true if child is subclass of parent\n                    if (oldClass.isAssignableFrom(newClass)) { // new is subclass of old\n                        // New overrides old. Fall through to replace.\n                    } else if (newClass.isAssignableFrom(oldClass)) { // old is subclass of new\n                        return; // Keep old.\n                    } else { // Unrelated classes\n                        // 13-Jan-2017, tatu: As per [databind#1498], should probably allow, choosing the more specific one...\n                        //    but for now, conflict is perhaps better than random choice.\n                        throw new IllegalArgumentException(String.format(\n                                \"Conflicting %s creators: already had explicitly marked %s from %s, encountered similar explicit %s from %s\",\n                                TYPE_DESCS[typeIndex], oldOne, oldClass.getName(), newOne, newClass.getName()));\n                    }\n                }\n                // If new is explicit, old was not: New one overrides implicit old one. Fall through to replace.\n                // And also update explicit marker:\n                _explicitCreators |= mask;\n\n            } else { // New is implicit\n                if (oldExplicit) { // Old is explicit\n                    return; // Keep explicit old one.\n                }\n                // Both implicit. Use subclass priority\n                if (oldClass.isAssignableFrom(newClass)) { // new is subclass of old (or same class, but handled above)\n                    // New overrides old implicit one. Fall through to replace.\n                } else if (newClass.isAssignableFrom(oldClass)) { // old is subclass of new\n                    return; // Keep old.\n                }\n                // Implicit creators from unrelated classes: Prioritize closer one? Or fail?\n                // Jackson's historical behavior seems to be to allow replacement (implicit override). Let's keep that.\n                // Fall through to replace.\n            }\n        } else { // if oldOne == null\n             // If no old creator, record the new one as explicit if applicable\n            if (explicit) {\n                _explicitCreators |= mask;\n            }\n        }\n\n        // If we get here, 'newOne' is the chosen candidate. Replace 'oldOne' (if any).\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}