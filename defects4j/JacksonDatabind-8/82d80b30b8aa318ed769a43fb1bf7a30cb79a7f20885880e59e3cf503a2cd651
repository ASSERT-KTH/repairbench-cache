{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n            // [databind#667]: If old and new are the exact same creator (same underlying Member),\n            // then it's a redundant registration, not a conflict.\n            if (oldOne.getAnnotated().equals(newOne.getAnnotated())) {\n                if (explicit) { // If new one is explicit, make sure this creator type is marked as such\n                    _explicitCreators |= mask;\n                }\n                return; // No conflict, already have this exact creator, possibly update explicit flag\n            }\n\n            // At this point, oldOne and newOne are different underlying creator Members.\n\n            // If oldOne was explicitly marked (via _explicitCreators bit)\n            if ((_explicitCreators & mask) != 0) {\n                // If newOne is NOT explicitly annotated, oldOne wins.\n                if (!explicit) {\n                    return;\n                }\n                // Else (both explicit): this is a true conflict, unless specific rules apply (handled below).\n                // Falls through to potential throw.\n            } else { // oldOne was NOT explicitly marked\n                // If newOne IS explicit, it overrides the non-explicit oldOne.\n                if (explicit) {\n                    _explicitCreators |= mask; // Mark this creator type as explicit\n                    // Allow newOne to overwrite oldOne by letting it fall through to assignment.\n                    return; // New one wins, don't throw, proceed to assignment.\n                }\n                // Else (neither explicit): potentially problematic for certain types like StringBuilder.\n                // Falls through to potential throw.\n            }\n\n            // Reaching here means:\n            // 1. Both oldOne and newOne are explicit AND are different creators (true conflict likely).\n            // 2. Neither oldOne nor newOne is explicit AND are different creators (potentially handled by #667 for some types).\n\n            // This condition checks if both are of the same \"kind\" (e.g., both AnnotatedConstructor).\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: For common JDK types like String, StringBuilder, StringBuffer,\n                // allow implicit creators to be overwritten by other implicit ones, or more specific ones.\n                // The TYPE_DESCS array typically has String/StringBuilder/StringBuffer at specific indices (0, 1, 2).\n                // This check applies if neither is explicit, or if new one is explicit and old one is not (handled above).\n                // So, if we are here and `explicit` is false, it means `oldOne` was also not explicit.\n                // This is the specific scenario where `StringBuilder` issue for #667 often occurs.\n                // We should NOT throw an exception for these types when neither is explicit.\n                final int CREATOR_FOR_STRING = 0; // Assuming constants from CreatorProperty\n                final int CREATOR_FOR_STRING_BUILDER = 1;\n                final int CREATOR_FOR_STRING_BUFFER = 2;\n\n                // Check if both creators are for the same declaring class (e.g. both for StringBuilder.class)\n                // This prevents conflicts between creators in different classes (e.g. subclass/superclass)\n                if (oldOne.getDeclaringClass() == newOne.getDeclaringClass()) {\n                    // Check if it's one of the special types that allows flexible creator resolution\n                    if (typeIndex == CREATOR_FOR_STRING || typeIndex == CREATOR_FOR_STRING_BUILDER || typeIndex == CREATOR_FOR_STRING_BUFFER) {\n                        // If it's a special type, and if either newOne is explicit (which would win),\n                        // or if neither was explicit (and we are allowing overwrite for this specific case),\n                        // THEN DO NOT THROW. Let it proceed to assignment.\n                        // The scenario where `explicit` is false and `(_explicitCreators & mask) == 0` (neither explicit)\n                        // will fall into this block, and we want to allow overwrite for StringBuilder.\n                        // The case where `explicit` is true and `(_explicitCreators & mask) != 0` (both explicit)\n                        // will fall through here, and should still throw unless more specific rules apply.\n                        // Given the test failure (annotations: [null] for newOne), this `if (explicit)` branch is key.\n                        if (explicit) { // Both explicit; this is a conflict for same class, different members\n                            throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                                    +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                        }\n                        // Neither explicit; for String/StringBuilder/StringBuffer, allow overwrite\n                        // by not throwing, and letting newOne be assigned.\n                    } else { // Not a special type (e.g. custom bean type)\n                        // If both explicit, or neither explicit for same class: conflict\n                        throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                                +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                    }\n                } else { // Creators from different declaring classes (e.g. super/sub class)\n                    // If newOne is from a more specific (sub)class, it typically wins over an old one from a superclass.\n                    // If oldOne is from a more specific (sub)class, it typically wins.\n                    // The current logic doesn't explicitly check class hierarchy for conflicts,\n                    // but if they're from different classes and there's no clear precedence (e.g. no explicit marker),\n                    // it's a potential error or needs more detailed resolution.\n                    // For now, if same 'kind' but different declaring classes, and not handled by explicit rules,\n                    // it's a conflict.\n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had \"+oldOne+\", encountered \"+newOne);\n                }\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}