{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        // If no previous creator, or if new creator is same as old one, handle simply\n        if (oldOne == null) {\n            // If this is the first creator found, mark as having one\n            // (even if default -- needed for prioritizing actual creators over default)\n            _hasNonDefaultCreator = true;\n            if (explicit) {\n                _explicitCreators |= mask;\n            }\n            _creators[typeIndex] = _fixAccess(newOne);\n            return;\n        }\n\n        // If new one represents the very same actual Function/Constructor, ignore\n        // (NOTE: equals() only checks for signature, not annotations)\n        if (oldOne.getAnnotated().equals(newOne.getAnnotated())) {\n             // If annotations differ, could consider conflict? Or prefer 'more annotated'?\n             // For now, simplest is to just ignore dups.\n             return; // already had it, ok\n        }\n\n        // Ok, different creator methods, potential conflict.\n\n        boolean oldExplicit = (_explicitCreators & mask) != 0;\n\n        // both explicit? error\n        if (oldExplicit && explicit) { // RETHROW different type description\n            throw new IllegalArgumentException(String.format(\n                    \"Conflicting %s creators: already had explicitly marked %s, encountered explicit %s\",\n                    TYPE_DESCS[typeIndex], oldOne, newOne));\n        }\n\n        // explicit older one takes precedence over implicit new one\n        if (oldExplicit && !explicit) { // RETAIN old one\n            return;\n        }\n\n        // implicit old one is overridden by explicit new one\n        if (!oldExplicit && explicit) { // REPLACE with new one\n            // need to mark explicit, and replace\n            _explicitCreators |= mask;\n            // fall through for assignment\n        } else {\n            // !oldExplicit && !explicit\n            // Both implicit, different methods. Conflict? Only if in same class?\n            // Or based on type of annotated item? Or number of arguments?\n            // Let's use the original check's logic here for databind#667 compatibility,\n            // but apply it only when both are implicit and different.\n            // Note: original check was `oldOne.getClass() == newOne.getClass()`, let's keep that\n            // for minimal changes, assuming it relates to `AnnotatedConstructor` vs `AnnotatedMethod`\n            // or perhaps something related to generic types.\n            if (oldOne.getClass() == newOne.getClass()) {\n                 // Maybe check parameter counts? Or...?\n                 // For [databind#667], let's prevent replacement.\n                 // Ideally we would compare parameter types, but... just report abstract conflict for now?\n                 throw new IllegalArgumentException(String.format(\n                     \"Conflicting %s creators: found multiple implicit ones (%s vs %s)\",\n                     TYPE_DESCS[typeIndex], oldOne, newOne));\n                 // Or, could consider new type more generic / more specific?\n            }\n            // Otherwise, different classes, let replacement occur (implicit overriding by subclass)\n            // fall through for assignment\n        }\n\n        // If we get this far, we determined `newOne` is the preferred choice.\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}