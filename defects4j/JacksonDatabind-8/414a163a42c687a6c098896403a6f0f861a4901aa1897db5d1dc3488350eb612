{
    "generation": "    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n\n        // If an old creator already exists, we need to check for conflicts or identical registrations\n        if (oldOne != null) {\n            // [databind#133]: If new creator is functionally identical to the existing one,\n            // there's no conflict. We might need to update explicit status.\n            if (oldOne.equals(newOne)) {\n                // If the new one is explicit but the existing one was not,\n                // we should promote its explicit status and potentially update the stored instance.\n                if (explicit && ((_explicitCreators & mask) == 0)) {\n                    _explicitCreators |= mask;\n                    // Update the stored creator, _fixAccess might change its properties\n                    _creators[typeIndex] = _fixAccess(newOne);\n                }\n                return; // No conflict, identical creator.\n            }\n\n            // Otherwise, `oldOne` and `newOne` are different creators.\n            // Check for conflict based on explicit status.\n            if ((_explicitCreators & mask) != 0) { // Existing creator was explicitly marked\n                // If new one is NOT explicit, existing explicit one wins.\n                if (!explicit) {\n                    return;\n                }\n                // Both existing and new are explicit AND different. This is a conflict.\n                // The `getClass()` check typically confirms they are the same type of creator (e.g., both constructors).\n                if (oldOne.getClass() == newOne.getClass()) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n                // If they are different wrapper types (e.g., AnnotatedConstructor vs AnnotatedMethod),\n                // the exception is not thrown (as per original logic).\n            }\n            // If existing creator was NOT explicit\n            else {\n                // If new one is also NOT explicit:\n                if (!explicit) {\n                    // Both existing and new are non-explicit AND different. This is a conflict.\n                    if (oldOne.getClass() == newOne.getClass()) {\n                        throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                                +\" creators: already had \"+oldOne+\", encountered \"+newOne);\n                    }\n                    // If they are different wrapper types, no throw.\n                }\n                // Else (`newOne` IS explicit): `newOne` should override `oldOne`.\n                // Allow execution to fall through to the final assignment.\n            }\n        }\n\n        // If we reach here, `newOne` should be the one registered (either `oldOne` was null,\n        // or `newOne` is a 'better' creator (e.g., explicit over non-explicit).\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}