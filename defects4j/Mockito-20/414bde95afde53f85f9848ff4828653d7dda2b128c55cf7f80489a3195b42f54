{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    \n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(settings.getTypeToMock(), settings.getExtraInterfaces());\n    T mockInstance = null;\n\n    try {\n        mockInstance = createInstance(settings, mockedProxyType);\n        setMockitoInterceptor(mockInstance, handler, settings);\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(mockedProxyType),\n                \"  created class : \" + describeClass(settings.getTypeToMock()),\n                \"  proxy instance class : \" + describeClass(mockInstance),\n                \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ), cce);\n    } catch (MockitoException me) {\n        throw me;\n    } catch (RuntimeException e) {\n        String message = \"Unable to create mock instance of type '\" + describeClass(settings.getTypeToMock()) + \"'\";\n        if (e.getCause() instanceof InstantiationException || e.getCause() instanceof IllegalAccessException) {\n            message += \", cause: \" + e.getCause().getMessage();\n        }\n        throw new MockitoException(message, e);\n    }\n}\n\nprivate T createInstance(MockCreationSettings<T> settings, Class<? extends T> mockedProxyType) throws Exception {\n    if (settings.isUseConstructor()) {\n        try {\n            return instantiateUsingConstructor(settings, mockedProxyType);\n        } catch (NoSuchMethodException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + describeClass(mockedProxyType) + \"' with constructor\", e);\n        }\n    }\n    return classInstantiator.instantiate(mockedProxyType);\n}\n\nprivate T instantiateUsingConstructor(MockCreationSettings<T> settings, Class<? extends T> mockedProxyType) throws Exception {\n    Object outerInstance = settings.getOuterInstance();\n    Constructor<? extends T> constructor;\n\n    if (outerInstance == null) {\n        constructor = mockedProxyType.getDeclaredConstructor();\n    } else {\n        if (!mockedProxyType.getEnclosingClass().isInstance(outerInstance)) {\n            String message = String.format(\n                    \"Outer instance must be an instance of %s but got %s\",\n                    mockedProxyType.getEnclosingClass().getSimpleName(),\n                    outerInstance.getClass().getSimpleName()\n            );\n            throw new MockitoException(message);\n        }\n        constructor = mockedProxyType.getDeclaredConstructor(mockedProxyType.getEnclosingClass());\n    }\n\n    if (constructor == null) {\n        throw new NoSuchMethodException(\"No suitable constructor found\");\n    }\n\n    constructor.setAccessible(true);\n    return constructor.newInstance(outerInstance);\n}\n\nprivate void setMockitoInterceptor(T mockInstance, MockHandler handler, MockHandler settingsHandler) throws ClassCastException {\n    if (mockInstance instanceof MockMethodInterceptor.MockAccess) {\n        MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n        mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settingsHandler));\n    } else {\n        throw new IllegalArgumentException(\"Unexpected instance type: \" + describeType(mockInstance.getClass()));\n    }\n}\n\nprivate String describeClass(Class<?> clazz) {\n    return clazz != null ? clazz.getName() : \"null\";\n}\n\nprivate String describeType(Class<?> type) {\n    return type != null ? type.getName() : \"null\";\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}