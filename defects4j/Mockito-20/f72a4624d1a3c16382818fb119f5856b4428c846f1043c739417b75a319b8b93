{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\n            \"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n        settings.getTypeToMock(),\n        settings.getExtraInterfaces()\n    );\n\n    T mockInstance = null;\n    try {\n        if (settings.isUsingConstructor()) {\n            // Build argument list for real-constructor invocation\n            List<Object> consArgsList = settings.getConstructorArgs();\n            Object[] userArgs = consArgsList.toArray();\n            Object outer = settings.getOuterInstance();\n            Object[] args;\n\n            if (outer != null) {\n                // Inner class: first argument must be the outer instance\n                Class<?> declaring = mockedProxyType.getDeclaringClass();\n                if (!declaring.isInstance(outer)) {\n                    throw new MockitoException(\n                        \"Unable to create mock instance of type '\" +\n                        settings.getTypeToMock().getSimpleName() + \"'\",\n                        new IllegalArgumentException(\n                            \"Please ensure that the outer instance has correct type \" +\n                            \"and that the target class has 0-arg constructor.\"\n                        )\n                    );\n                }\n                args = new Object[userArgs.length + 1];\n                args[0] = outer;\n                System.arraycopy(userArgs, 0, args, 1, userArgs.length);\n            } else {\n                args = userArgs;\n            }\n\n            // Invoke the real constructor on the proxy class\n            mockInstance = new org.mockito.internal.creation.instance\n                .ReflectionInstantiator<>(mockedProxyType)\n                .newInstance(args);\n        } else {\n            // Default: bypass the constructor (e.g. pure mock)\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n        }\n\n        // Attach the Mockito interceptor\n        MockMethodInterceptor.MockAccess access =\n            (MockMethodInterceptor.MockAccess) mockInstance;\n        access.setMockitoInterceptor(\n            new MockMethodInterceptor(\n                asInternalMockHandler(handler),\n                settings\n            )\n        );\n\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n            \"ClassCastException occurred while creating the mockito mock :\",\n            \"  class to mock : \" + describeClass(mockedProxyType),\n            \"  created class : \" + describeClass(settings.getTypeToMock()),\n            \"  proxy instance class : \" + describeClass(mockInstance),\n            \"  instance creation by : \" +\n              classInstantiator.getClass().getSimpleName(),\n            \"\",\n            \"You might experience classloading issues, \" +\n              \"please ask the mockito mailing-list.\",\n            \"\"\n        ), cce);\n\n    } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n        throw new MockitoException(\n            \"Unable to create mock instance of type '\" +\n            mockedProxyType.getSuperclass().getSimpleName() + \"'\",\n            e\n        );\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}