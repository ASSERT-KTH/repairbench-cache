{
    "generation": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\n            \"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n\n    Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n        settings.getTypeToMock(),\n        settings.getExtraInterfaces()\n    );\n\n    T mockInstance = null;\n    try {\n        Object[] constructorArgs = settings.getConstructorArguments();\n        Object outerInstance    = settings.getOuterInstance();\n\n        if (constructorArgs != null) {\n            // -- useConstructor() or spy(Class) path: call real constructor\n            Object[] args;\n            Class<?>[] paramTypes;\n\n            if (outerInstance != null) {\n                args       = new Object[1 + constructorArgs.length];\n                paramTypes = new Class<?>[1 + constructorArgs.length];\n                args[0]         = outerInstance;\n                paramTypes[0]   = outerInstance.getClass();\n                for (int i = 0; i < constructorArgs.length; i++) {\n                    args[i + 1]       = constructorArgs[i];\n                    paramTypes[i + 1] = constructorArgs[i] != null\n                        ? constructorArgs[i].getClass()\n                        : Object.class;\n                }\n            } else {\n                args       = constructorArgs;\n                paramTypes = new Class<?>[constructorArgs.length];\n                for (int i = 0; i < constructorArgs.length; i++) {\n                    paramTypes[i] = constructorArgs[i] != null\n                        ? constructorArgs[i].getClass()\n                        : Object.class;\n                }\n            }\n\n            // find the matching constructor\n            java.lang.reflect.Constructor<? extends T> ctor;\n            try {\n                ctor = mockedProxyType.getDeclaredConstructor(paramTypes);\n            } catch (NoSuchMethodException e) {\n                String msg      = \"Unable to create mock instance of type '\" +\n                                  settings.getTypeToMock().getSimpleName() + \"'\";\n                String causeMsg = outerInstance != null\n                    ? \"Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.\"\n                    : \"0-arg constructor\";\n                throw new MockitoException(msg, new MockitoException(causeMsg, e));\n            }\n            ctor.setAccessible(true);\n            mockInstance = ctor.newInstance(args);\n        } else {\n            // default path: bypass constructor (Objenesis)\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n        }\n\n        // apply the interceptor\n        MockMethodInterceptor.MockAccess access =\n            (MockMethodInterceptor.MockAccess) mockInstance;\n        access.setMockitoInterceptor(\n            new MockMethodInterceptor(asInternalMockHandler(handler), settings)\n        );\n\n        return ensureMockIsAssignableToMockedType(settings, mockInstance);\n\n    } catch (ClassCastException cce) {\n        throw new MockitoException(join(\n            \"ClassCastException occurred while creating the mockito mock :\",\n            \"  class to mock : \" + describeClass(mockedProxyType),\n            \"  created class : \" + describeClass(settings.getTypeToMock()),\n            \"  proxy instance class : \" + describeClass(mockInstance),\n            \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n            \"\",\n            \"You might experience classloading issues, please ask the mockito mailing-list.\",\n            \"\"\n        ), cce);\n\n    } catch (java.lang.reflect.InvocationTargetException ite) {\n        throw new MockitoException(\n            \"Unable to create mock instance of type '\" +\n            settings.getTypeToMock().getSimpleName() + \"'\",\n            ite.getCause()\n        );\n\n    } catch (org.mockito.internal.creation.instance.InstantiationException ie) {\n        // fallback-instantiator failure\n        throw new MockitoException(\n            \"Unable to create mock instance of type '\" +\n            mockedProxyType.getSuperclass().getSimpleName() + \"'\",\n            ie\n        );\n\n    } catch (MockitoException me) {\n        // rethrow our own user\u2010facing exceptions\n        throw me;\n\n    } catch (Exception e) {\n        // any other reflection failure\n        throw new MockitoException(\n            \"Unable to create mock instance of type '\" +\n            settings.getTypeToMock().getSimpleName() + \"'\",\n            e\n        );\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}