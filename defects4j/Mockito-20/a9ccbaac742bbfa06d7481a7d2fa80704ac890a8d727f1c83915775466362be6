{
    "generation": "import org.mockito.exceptions.base.MockitoException;\nimport org.mockito.internal.creation.instance.InstantiationException;\nimport org.mockito.internal.handlers.MockHandlerImpl;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.mock.SerializableMode;\n\nimport java.lang.reflect.Constructor;\nimport java.util.Arrays;\n\nimport static org.mockito.internal.util.StringUtil.join;\n\npublic class ByteBuddyMockMaker {\n\n    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n    private final ClassInstantiator classInstantiator = new ClassInstantiator();\n\n    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n\n        T mockInstance = null;\n        try {\n            if (settings.getConstructorArgs() != null) {\n                // Try to instantiate with provided constructor args\n                Constructor<? extends T> constructor = findMatchingConstructor(mockedProxyType, settings.getConstructorArgs());\n                mockInstance = constructor.newInstance(settings.getConstructorArgs());\n            } else if (settings.getOuterInstance() != null) {\n                // Try to instantiate with outer instance\n                mockInstance = classInstantiator.instantiate(mockedProxyType, settings.getOuterInstance());\n            } else {\n                // Fallback to default instantiation\n                mockInstance = classInstantiator.instantiate(mockedProxyType);\n            }\n\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + settings.getTypeToMock().getSimpleName() + \"'\", e);\n        } catch (Exception e) {\n            throw new MockitoException(join(\n                    \"Exception occurred while creating the mockito mock :\",\n                    \"  class to mock : \" + describeClass(mockedProxyType),\n                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + describeClass(mockInstance),\n                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n                    \"  cause: \" + e.getMessage(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ), e);\n        }\n    }\n\n    private <T> Constructor<? extends T> findMatchingConstructor(Class<? extends T> clazz, Object[] args) throws NoSuchMethodException {\n        Constructor<? extends T> constructor = clazz.getDeclaredConstructor(getArgumentTypes(args));\n        constructor.setAccessible(true);\n        return constructor;\n    }\n\n    private Class<?>[] getArgumentTypes(Object[] args) {\n        return Arrays.stream(args).map(Object::getClass).toArray(Class<?>[]::new);\n    }\n\n    private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {\n        if (!settings.getTypeToMock().isInstance(mock)) {\n            throw new MockitoException(join(\n                    \"Created mock instance is not assignable to the mocked type.\",\n                    \"  mock type : \" + describeClass(settings.getTypeToMock()),\n                    \"  created mock type : \" + describeClass(mock.getClass()),\n                    \"\",\n                    \"Please ensure that the mocked type is a valid class or interface.\",\n                    \"\"\n            ));\n        }\n        return mock;\n    }\n\n    private String describeClass(Class<?> clazz) {\n        return clazz != null ? clazz.getName() : \"null\";\n    }\n\n    private MockHandler asInternalMockHandler(MockHandler handler) {\n        return handler instanceof MockHandlerImpl ? (MockHandlerImpl) handler : new MockHandlerImpl(handler);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}