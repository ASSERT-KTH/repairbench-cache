{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token and\n   * the option is not WhitespaceOption.PRESERVE, it will quit immediately\n   * (indicating that there is no text where it was expected).\n   * Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // Initial check for EOC or EOF.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n    // If the first token is EOL and we are not in PRESERVE mode,\n    // it implies no text is present where expected (e.g., for @param descriptions).\n    if (token == JsDocToken.EOL && option != WhitespaceOption.PRESERVE) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    // startCharno should ideally be the char position of the first *content* character.\n    // stream.getCharno() typically returns the position *after* the last consumed token.\n    // If 'token' is the first token to process, stream.getCharno() might be at its start or end.\n    // Assuming stream.getCharno() is at the *start* of the current token.\n    int startCharno = stream.getCharno();\n\n    StringBuilder builder = new StringBuilder();\n\n    boolean lastAppendedWasNewline = true;\n    // This flag determines if we are at the beginning of a new line (after EOL or start of block)\n    // where leading stars or whitespace should be ignored for non-PRESERVE options.\n    // For PRESERVE option, these are usually considered content.\n    boolean atStartOfContentLine = true;\n\n    // Process the initial token before entering the main loop.\n    // This ensures 'token' is always 'next()' from previous iteration within the loop.\n    if (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE) {\n        // If the first token is an annotation and we are not in PRESERVE mode,\n        // it means there's no textual block to extract, and the annotation terminates.\n        return new ExtractionInfo(\"\", token);\n    } else if (token == JsDocToken.EOL) {\n        // If the first token is EOL, append newline if not SINGLE_LINE, and set flags.\n        if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n        }\n        lastAppendedWasNewline = true;\n        atStartOfContentLine = true; // Still at start of a new (empty) line\n    } else if (token == JsDocToken.STAR) {\n        // For a leading star at the very beginning of the block.\n        // In PRESERVE mode, it's considered content. In non-PRESERVE, it's structural.\n        if (option == WhitespaceOption.PRESERVE) {\n            builder.append('*');\n            lastAppendedWasNewline = false;\n        }\n        atStartOfContentLine = true; // After a potentially structural star, still at start of content.\n    } else if (token == JsDocToken.WHITESPACE) {\n        // If first token is whitespace, append it if PRESERVE.\n        // Else, ignore it (as it's leading whitespace which is usually trimmed).\n        if (option == WhitespaceOption.PRESERVE) {\n            builder.append(stream.getTokenAsString());\n            lastAppendedWasNewline = false;\n        }\n        atStartOfContentLine = false; // After consuming whitespace, not at start of line for content.\n    } else { // It's a content token (STRING, NUMBER, etc.)\n        builder.append(stream.getTokenAsString());\n        lastAppendedWasNewline = false;\n        atStartOfContentLine = false; // After consuming content, not at start of line for next content.\n\n        // Append remaining text on the current line after this token.\n        String remainingLine = stream.getRemainingJSDocLine();\n        if (!remainingLine.isEmpty()) {\n            if (option != WhitespaceOption.PRESERVE) {\n                remainingLine = trimEnd(remainingLine);\n            }\n            builder.append(remainingLine);\n        }\n    }\n\n    // Advance the token for the main loop.\n    token = next();\n    // This state seems to be for the overall JsDocInfoParser, not specific to this block extraction.\n    // It's part of the original code, keeping it for consistency.\n    state = State.SEARCHING_ANNOTATION;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (option == WhitespaceOption.PRESERVE) {\n            // In PRESERVE mode, a star is usually content.\n            builder.append('*');\n            lastAppendedWasNewline = false;\n            atStartOfContentLine = false;\n          } else { // Not PRESERVE\n            if (atStartOfContentLine) {\n              // Ignore leading structural star on a new line (e.g. ` * text`).\n            } else {\n              // Non-leading star is treated as a word separator.\n              if (builder.length() > 0 && !lastAppendedWasNewline) {\n                builder.append(' ');\n              }\n              builder.append('*');\n            }\n            lastAppendedWasNewline = false;\n            atStartOfContentLine = false;\n          }\n          token = next();\n          continue;\n\n        case WHITESPACE:\n          if (option == WhitespaceOption.PRESERVE) {\n            builder.append(stream.getTokenAsString());\n            lastAppendedWasNewline = false;\n            atStartOfContentLine = false;\n          } else { // Not PRESERVE\n            if (atStartOfContentLine) {\n              // Ignore leading whitespace on a new line (after structural star or EOL).\n            } else {\n              // Whitespace between tokens for non-PRESERVE: collapse to single space.\n              if (builder.length() > 0 && !lastAppendedWasNewline) {\n                builder.append(' ');\n              }\n            }\n            lastAppendedWasNewline = false;\n            atStartOfContentLine = false;\n          }\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          lastAppendedWasNewline = true;\n          atStartOfContentLine = true; // Next token will be at the start of a new line.\n          token = next();\n          continue;\n\n        default: // STRING, NUMBER, ANNOTATION etc.\n          atStartOfContentLine = false; // Not at start of content line after consuming a content token.\n          state = State.SEARCHING_ANNOTATION; // Reset state.\n\n          // Check for termination conditions.\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // An ANNOTATION token normally terminates the block, unless option is PRESERVE.\n              // For license/preserve blocks, subsequent annotations are often considered text.\n              // However, the test cases imply annotations should terminate even for @preserve\n              // if they are not the *initial* token that started this block.\n              // This is a subtle point. The original code has this condition:\n              // `(token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)`\n              // which means annotations *are* text for PRESERVE. This matches JSDoc spec for @license/@preserve.\n              (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            // Mark text only if non-empty, and only once.\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          String currentTokenText = stream.getTokenAsString();\n\n          // Add space only if not PRESERVE, builder has content, and last was not newline.\n          // In PRESERVE mode, whitespace is handled by the WHITESPACE token type itself.\n          if (option != WhitespaceOption.PRESERVE && builder.length() > 0 && !lastAppendedWasNewline) {\n            builder.append(' ');\n          }\n          builder.append(currentTokenText);\n          lastAppendedWasNewline = false;\n\n          // Append any remaining text on the current line after this token.\n          String remainingLine = stream.getRemainingJSDocLine();\n          if (!remainingLine.isEmpty()) {\n            if (option != WhitespaceOption.PRESERVE) {\n              remainingLine = trimEnd(remainingLine);\n            }\n            builder.append(remainingLine);\n          }\n\n          token = next();\n      }\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}