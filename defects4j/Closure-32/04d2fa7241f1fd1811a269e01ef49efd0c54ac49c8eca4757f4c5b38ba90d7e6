{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      // No text found.\n      return new ExtractionInfo(\"\", token);\n    }\n\n    // Record the start position. stream.update() ensures lineno/charno are current.\n    stream.update();\n    int startLineno = stream.getLineno();\n    // Use 0-based charno. This is the position *after* the initial token (e.g., @preserve).\n    int startCharno = stream.getCharno();\n\n    // Read the content from the first line following the initial token.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n      // Trim whitespace for non-preserve options.\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    // Change state to reflect that we are now looking for the end of the block\n    // or the next annotation.\n    state = State.SEARCHING_ANNOTATION;\n    // Consume the rest of the first line, get the first token of the next line or block.\n    token = next();\n\n    do {\n      switch (token) {\n        case STAR:\n          // This case handles STAR tokens that are not at the beginning of a line\n          // immediately after EOL when in PRESERVE mode (those are handled in the EOL case).\n          // Treat as part of the text. Add preceding space only if not preserving.\n          if (option != WhitespaceOption.PRESERVE) {\n              if (builder.length() > 0 && !builder.toString().endsWith(\"\\n\") && !builder.toString().endsWith(\" \")) {\n                  builder.append(' ');\n              }\n          }\n          builder.append('*');\n          token = next();\n          continue; // Re-evaluate the next token.\n\n        case EOL:\n          // Append the newline character.\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          token = next(); // Get the token after EOL.\n\n          if (option == WhitespaceOption.PRESERVE) {\n              // Preserve mode: Handle leading whitespace and optional '*'\n              stream.update(); // Update position to the start of the token after EOL.\n              int charno = stream.getCharno(); // Get the column number.\n\n              if (token == JsDocToken.STAR) {\n                  // Leading star found. Consume it and get the next token's position.\n                  token = next();\n                  stream.update();\n                  charno = stream.getCharno(); // Column number after the star.\n              } else if (token == JsDocToken.EOL || token == JsDocToken.EOF || token == JsDocToken.EOC) {\n                  // If the line is blank or ends the comment, charno might be 0 or irrelevant.\n                  // We might have appended a newline, but there's no more text on this line.\n                  // Continue the loop to handle the EOL/EOF/EOC token correctly.\n                  continue;\n              }\n              // Append leading spaces based on the final column number.\n              for (int i = 0; i < charno; i++) {\n                  builder.append(' ');\n              }\n              // Fall through to process the token found after EOL/[*].\n          } else {\n              // Non-preserve mode: Skip optional leading star.\n              if (token == JsDocToken.STAR) {\n                  token = next(); // Consume the star.\n              }\n              // Continue the loop to process the next token without adding leading spaces.\n              continue;\n          }\n          // Fallthrough only happens for PRESERVE option.\n          // The current 'token' is the first significant one on the new line.\n          break; // Break from EOL case, the switch will evaluate 'token'.\n\n        default:\n          // Process any other token (STRING, ANNOTATION in PRESERVE mode, etc.).\n          state = State.SEARCHING_ANNOTATION; // Ensure state is correct.\n\n          // Check for termination conditions.\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // Annotations terminate the block unless PRESERVE is active.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n\n            // Block terminated. Finalize the extracted text.\n            String multilineText = builder.toString();\n\n            // Trim only if whitespace is not preserved.\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            // Record the end position (start of the terminating token).\n            stream.update();\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            // Mark the extracted text range in the JSDoc builder.\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            // Return the extracted text and the terminating token.\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // Not a terminating token. Append the token and the rest of the line.\n          // Add space separator only if not preserving and needed.\n          if (option != WhitespaceOption.PRESERVE) {\n              if (builder.length() > 0 && !builder.toString().endsWith(\"\\n\") && !builder.toString().endsWith(\" \")) {\n                  builder.append(' ');\n              }\n          }\n          // Append the string value of the token.\n          builder.append(toString(token));\n\n          // Append the remaining text on the current line.\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n             // Trim end of line if not preserving.\n            line = trimEnd(line);\n          }\n          builder.append(line);\n\n          // Advance to the next token for the next iteration.\n          token = next();\n          break; // Break from default case, continue loop.\n      } // End switch\n    } while (true); // End do-while loop\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}