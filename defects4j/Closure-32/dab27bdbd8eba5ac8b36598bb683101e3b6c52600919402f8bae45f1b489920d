{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // Removed JsDocToken.EOL from this initial check.\n    // For @preserve and @license, the text block can start on a new line\n    // after the annotation itself, which means the initial token could be EOL.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    // Do not trim the first line if preserving whitespace.\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    // Advance to the first token AFTER the initial line's content.\n    token = next();\n\n    // The 'ignoreStar' variable logic was inconsistent with `next()` skipping\n    // leading stars. It is removed for simplicity and correctness, as\n    // `stream.getWhitespaceSinceLastLine()` will handle the skipped content.\n\n    do {\n      // Capture any whitespace that was skipped by the `next()` call that\n      // produced the current `token`. This is crucial for PRESERVE mode.\n      String skippedWhitespace = \"\";\n      if (option == WhitespaceOption.PRESERVE) {\n          skippedWhitespace = stream.getWhitespaceSinceLastLine();\n      }\n\n      switch (token) {\n        case STAR:\n          // If `next()` skips leading stars (e.g., ` * ` at the start of a line),\n          // then JsDocToken.STAR will only be returned for embedded stars (e.g., `foo * bar`).\n          // In PRESERVE mode, append the skipped whitespace before the star.\n          builder.append(skippedWhitespace);\n          // For non-PRESERVE, ensure a single space separator if needed.\n          if (option != WhitespaceOption.PRESERVE && builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append('*');\n          break; // Break and proceed to next() at the end of the loop\n\n        case EOL:\n          // Append any skipped whitespace on the new line (e.g., `   ` if line is `   text`).\n          builder.append(skippedWhitespace);\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          break;\n\n        default:\n          state = State.SEARCHING_ANNOTATION;\n\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When capturing a license/preserve block, annotations inside are allowed.\n              // So, only terminate on ANNOTATION if NOT in PRESERVE mode.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            // Only trim the final text if not preserving whitespace.\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // Append any whitespace skipped before the current token.\n          builder.append(skippedWhitespace);\n\n          // All tokens must be separated by a space for non-PRESERVE options.\n          // This ensures a space is added if there wasn't one captured in skippedWhitespace\n          // and the previous content didn't end with a newline.\n          if (option != WhitespaceOption.PRESERVE && builder.length() > 0) {\n            builder.append(' ');\n          }\n          \n          builder.append(toString(token));\n\n          // Get the remaining part of the current line after the token.\n          line = stream.getRemainingJSDocLine();\n\n          // Only trim the end of the line part if not preserving whitespace.\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n          break;\n      }\n      token = next(); // Advance to the next token for the loop iteration\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}