{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      // No text found on the line.\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno(); // Position of the first token\n\n    // Read the content from the first line, which starts *after* the initial token.\n    String line = stream.getRemainingJSDocLine();\n    // Don't trim the initial line for PRESERVE\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    // Consume the rest of the first line by getting the next token (usually EOL).\n    token = next();\n\n    boolean ignoreStar = false;\n\n    // Track the start/end positions of the free text block for marking\n    // Use the initial position as default, update if content is found.\n    int textBlockStartLineno = startLineno;\n    // If initial line had content, start char is start of that content.\n    // Otherwise, it will be updated when first content token on subsequent line is found.\n    int textBlockStartCharno = startCharno + (line.length() - stream.getRemainingJSDocLine().length());\n    boolean contentStarted = !line.isEmpty();\n\n\n    do {\n      stream.update(); // Update stream position at the start of each loop iteration\n\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // --- Leading star on a new line ---\n            int starLineno = stream.getLineno();\n            int starCharno = stream.getCharno(); // Position BEFORE star token\n\n            // Consume the star token\n            token = next();\n\n            // Get position after consuming star, now points to the start of the next token\n            stream.update();\n            int nextTokenCharno = stream.getCharno();\n\n            // Append the whitespace between '*' and the next token if PRESERVE\n            if (option == WhitespaceOption.PRESERVE) {\n                int whitespaceStartCharno = starCharno + 1; // Position logically after the '*' char\n                int whitespaceEndCharno = nextTokenCharno; // Position logically before the next token\n\n                if (whitespaceEndCharno > whitespaceStartCharno && starLineno == stream.getLineno()) {\n                    // Retrieve the actual whitespace from the source stream/line buffer\n                    String currentLine = stream.getLine(starLineno);\n                    int lineStartOffset = stream.getLineStartOffset(starLineno);\n                    int relWhitespaceStart = Math.max(0, whitespaceStartCharno - lineStartOffset);\n                    int relWhitespaceEnd = Math.min(currentLine.length(), whitespaceEndCharno - lineStartOffset);\n\n                    if (relWhitespaceEnd > relWhitespaceStart) {\n                        String whitespace = currentLine.substring(relWhitespaceStart, relWhitespaceEnd);\n                        if (whitespace.length() > 0) {\n                           if (!contentStarted) {\n                                textBlockStartLineno = starLineno;\n                                textBlockStartCharno = starCharno + 1; // Start of whitespace\n                                contentStarted = true;\n                           }\n                           builder.append(whitespace);\n                        }\n                    }\n                }\n            }\n            // Loop continues with the token found after the star and whitespace\n            ignoreStar = false; // Processed the potential leading star line starter\n          } else {\n            // --- Star is part of the comment text ---\n            if (!contentStarted) {\n                 textBlockStartLineno = stream.getLineno();\n                 textBlockStartCharno = stream.getCharno();\n                 contentStarted = true;\n            }\n            // In PRESERVE mode, no space is added automatically here.\n            // In Non-PRESERVE, add space if needed.\n            if (option != WhitespaceOption.PRESERVE && builder.length() > 0) {\n                // Avoid double spaces if line already ends with space/newline\n                char lastChar = builder.charAt(builder.length() - 1);\n                if (lastChar != ' ' && lastChar != '\\n') {\n                    builder.append(' ');\n                }\n            }\n\n            builder.append('*');\n            token = next(); // Consume the star token\n          }\n          continue; // Back to top of loop with next token\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true; // Next line might start with a star to ignore\n          token = next(); // Consume EOL\n          continue; // Back to top of loop\n\n        default:\n          // --- Handle termination tokens first ---\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // When PRESERVE, annotations are part of the text block.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n                multilineText = multilineText.trim(); // Trim entire result\n                if (multilineText.isEmpty()) {\n                    contentStarted = false; // Adjust if trimming removed everything\n                }\n            }\n\n            // If content never started (or was trimmed away), use initial pos?\n            // Let's stick to marking based on content found. If !contentStarted, don't mark.\n            if (!contentStarted) {\n                 // Ensure we return the correct empty string if needed.\n                 multilineText = \"\";\n            }\n\n            // Mark text if it's considered non-empty after potential trimming.\n            if (contentStarted && multilineText.length() > 0) {\n                 jsdocBuilder.markText(multilineText, textBlockStartLineno, textBlockStartCharno,\n                     endLineno, endCharno);\n            } else if (option == WhitespaceOption.PRESERVE && !contentStarted) {\n                 // Handle completely empty @preserve blocks - should they be marked?\n                 // Current logic only marks if contentStarted is true. Let's assume this is ok.\n                 // Return empty string, but potentially update token position for parser.\n            }\n\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // --- Process regular content token ---\n          if (!contentStarted) {\n             textBlockStartLineno = stream.getLineno();\n             textBlockStartCharno = stream.getCharno();\n             contentStarted = true;\n          }\n          ignoreStar = false; // Seeing a non-EOL, non-STAR token means no leading star check needed now\n\n          if (option == WhitespaceOption.PRESERVE) {\n              // Append the token's string representation.\n              builder.append(toString(token));\n\n              // Append the rest of the line *exactly* as it is.\n              line = stream.getRemainingJSDocLine();\n              builder.append(line);\n\n              // Consume the rest of the line by getting the next token (usually EOL).\n              token = next();\n          } else {\n              // Non-PRESERVE options:\n              // All tokens must be separated by a space.\n              if (builder.length() > 0) {\n                 char lastChar = builder.charAt(builder.length() - 1);\n                 if (lastChar != ' ' && lastChar != '\\n') {\n                     builder.append(' ');\n                 }\n              }\n              builder.append(toString(token));\n\n              line = stream.getRemainingJSDocLine();\n              // Trim end only, preserve leading space on this line part for now.\n              line = trimEnd(line);\n              builder.append(line);\n              token = next();\n          }\n          continue; // Continue the loop with the next token (often EOL)\n      }\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}