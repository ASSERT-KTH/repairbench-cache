{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected). Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // Original check prevented extraction if block started with EOL, which happens\n    // for @preserve/@license used like: @preserve\\n * text...\n    // Fix: Allow EOL to start extraction. EOC/EOF are still valid empty blocks.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno(); // Position before the content extraction starts\n\n    StringBuilder builder = new StringBuilder();\n    // If ignoreStar is true, we are at the beginning of a line after an EOL,\n    // and the next STAR token should be ignored (skipped).\n    boolean ignoreStar = false;\n    // Keep track if we are processing the very first token passed to the function.\n    boolean firstToken = true;\n\n    // Loop until we hit a terminating token (checked inside the loop)\n    do {\n      switch (token) {\n        case STAR:\n          if (ignoreStar) {\n            // Skip the leading star after a newline.\n            ignoreStar = false; // Only ignore one star per line.\n          } else {\n            // Star is part of the comment text (either mid-line or first token).\n            // Add space only if not preserving format and not the first token and builder isn't empty.\n            if (!firstToken && option != WhitespaceOption.PRESERVE) {\n                appendSpaceIfNeeded(builder);\n            }\n            builder.append('*');\n          }\n          // Advance to the next token after the star.\n          token = next();\n          firstToken = false; // No longer the first token overall.\n          continue; // Process the new token.\n\n        case EOL:\n          if (option == WhitespaceOption.SINGLE_LINE) {\n            // End of line terminates in single-line mode.\n            token = next(); // Consume EOL\n            // Force termination by breaking outer loop. Set token to EOL\n            // so the termination check below loop catches it.\n            token = JsDocToken.EOL;\n            break; // Exit switch, will terminate loop below.\n          }\n\n          // In multiline modes, append newline and prepare to ignore star on next line.\n          builder.append(\"\\n\");\n          ignoreStar = true; // Expect a star at the start of the next line.\n          token = next(); // Consume EOL, get next token.\n          firstToken = false; // No longer the first token overall.\n          continue; // Process the new token.\n\n        default: // Handles STRING, ANNOTATION (if PRESERVE), PIPE, LB, etc.\n          // Check for termination conditions first.\n          // Use a helper method for clarity.\n          if (shouldTerminate(token, option)) {\n             break; // Exit switch, will terminate loop below.\n          }\n\n          // Reset ignoreStar if we encounter any non-EOL, non-ignored-STAR token.\n          ignoreStar = false;\n          // Reset parser state? (Original code did this here) Seems reasonable.\n          state = State.SEARCHING_ANNOTATION;\n\n          // Add space separator if needed (non-preserve, not first token).\n          if (!firstToken && option != WhitespaceOption.PRESERVE) {\n            appendSpaceIfNeeded(builder);\n          }\n          // Append the string representation of the token.\n          builder.append(toString(token));\n\n          // Append the rest of the line after the token.\n          // Assumption: getRemainingJSDocLine() does NOT include the trailing \\n.\n          String line = stream.getRemainingJSDocLine();\n\n          // Trim trailing whitespace from the rest of the line if not preserving.\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n          builder.append(line);\n\n          // Advance token past the current token and the rest of the line.\n          token = next();\n          firstToken = false; // No longer the first token overall.\n          continue; // Process the new token.\n\n      } // end switch\n\n      // If the switch was exited via 'break', it means termination. Exit the loop.\n      break;\n\n    } while (true);\n\n\n    // Final clean up and return.\n    String multilineText = builder.toString();\n\n    // Trim the entire result only if not preserving whitespace.\n    if (option != WhitespaceOption.PRESERVE) {\n      multilineText = multilineText.trim();\n    }\n\n    // Get end position (current stream position).\n    int endLineno = stream.getLineno();\n    int endCharno = stream.getCharno();\n\n    // Mark the extracted text in the JSDoc builder.\n    if (multilineText.length() > 0) {\n      jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                            endLineno, endCharno);\n    }\n\n    // Return the extracted text and the token that terminated the extraction.\n    return new ExtractionInfo(multilineText, token);\n  }\n\n  // Helper method to check termination conditions (assuming it exists or is added)\n  // This consolidates the termination logic.\n  private boolean shouldTerminate(JsDocToken token, WhitespaceOption option) {\n    return token == JsDocToken.EOC || token == JsDocToken.EOF ||\n           (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE) ||\n           (token == JsDocToken.EOL && option == WhitespaceOption.SINGLE_LINE);\n  }\n\n  // Helper method to append space if needed (assuming it exists or is added)\n  // Appends a space if the builder is not empty and does not already end with whitespace.\n  private void appendSpaceIfNeeded(StringBuilder builder) {\n    if (builder.length() > 0) {\n      char lastChar = builder.charAt(builder.length() - 1);\n      if (lastChar != ' ' && lastChar != '\\n') {\n           builder.append(' ');\n      }\n    }\n  }\n\n  // Helper method for trimming trailing whitespace (assuming it exists or is added)\n  // Replicates needed functionality if not already present.\n  private String trimEnd(String s) {\n      int end = s.length();\n      while (end > 0 && Character.isWhitespace(s.charAt(end - 1))) {\n        end--;\n      }\n      return s.substring(0, end);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}