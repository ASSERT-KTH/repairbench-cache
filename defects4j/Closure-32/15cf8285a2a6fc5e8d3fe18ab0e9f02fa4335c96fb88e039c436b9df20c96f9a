{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // If the block starts with EOC or EOF, there's no text.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    // If the first token is EOL and we are *not* preserving whitespace,\n    // it implies an empty block (e.g., `@param\\n`). Return an empty string.\n    if (token == JsDocToken.EOL && option != WhitespaceOption.PRESERVE) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    // Update stream to position for the start of the current text block.\n    // If 'token' was EOL, stream.update() will advance to the next line.\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    StringBuilder builder = new StringBuilder();\n\n    // Handle the initial token and its line.\n    // If the first token is EOL, append newline for PRESERVE option.\n    if (token == JsDocToken.EOL) {\n        if (option == WhitespaceOption.PRESERVE) {\n            builder.append(\"\\n\");\n        }\n        // Advance token to the first token on the next line for the loop.\n        token = next();\n    } else {\n        // Append the content of the initial token.\n        // For PRESERVE, we don't trim this first token.\n        builder.append(toString(token));\n\n        // Append the remaining content of the current line.\n        // This is crucial for preserving internal line spacing (e.g., \"Foo   Bar\").\n        String remainingLine = stream.getRemainingJSDocLine();\n        if (option != WhitespaceOption.PRESERVE) {\n            remainingLine = trimEnd(remainingLine);\n        }\n        builder.append(remainingLine);\n\n        // Advance to the token *after* this initial line's content.\n        token = next();\n    }\n\n    // Loop to process subsequent tokens/lines.\n    do {\n      // Check for termination conditions.\n      // A license/preserve block can contain annotations, so don't stop for ANNOTATION if PRESERVE.\n      if (token == JsDocToken.EOC ||\n          token == JsDocToken.EOF ||\n          (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n        String multilineText = builder.toString();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          multilineText = multilineText.trim();\n        }\n\n        int endLineno = stream.getLineno();\n        int endCharno = stream.getCharno();\n\n        if (multilineText.length() > 0) {\n          jsdocBuilder.markText(multilineText, startLineno, startCharno,\n              endLineno, endCharno);\n        }\n        return new ExtractionInfo(multilineText, token);\n      }\n\n      switch (token) {\n        case STAR:\n          // JsDocInfoParser.next() generally strips leading `*` from new lines.\n          // So if we get a STAR token here, it's typically an inline star.\n          // In either case, it's part of the text to be appended.\n          if (builder.length() > 0 && !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n            // Append space if not already ending with whitespace AND not in PRESERVE mode.\n            if (option != WhitespaceOption.PRESERVE) {\n              builder.append(' ');\n            }\n          }\n          builder.append('*');\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          // For PRESERVE mode, we need to handle the content of the next line carefully\n          // because JsDocInfoParser.next() will strip leading '*' and whitespace.\n          if (option == WhitespaceOption.PRESERVE) {\n              stream.update(); // Move to the start of the next line.\n              String lineContent = stream.getRemainingJSDocLine(); // Get raw content of new line.\n              // Remove leading '*' and one space, if present (standard JSDoc comment indentation).\n              // This accounts for \" *   Some text\" -> \"  Some text\".\n              if (lineContent.length() > 0 && lineContent.charAt(0) == '*') {\n                  lineContent = lineContent.substring(1);\n                  if (lineContent.length() > 0 && lineContent.charAt(0) == ' ') {\n                      lineContent = lineContent.substring(1);\n                  }\n              }\n              builder.append(lineContent);\n              token = next(); // Advance token after processing the entire line.\n          } else {\n              // For non-PRESERVE, JsDocInfoParser.next() handles skipping leading '*' and whitespace.\n              token = next();\n          }\n          continue;\n\n        default:\n          // All tokens must be separated by a space for NORMAL/SINGLE_LINE.\n          // For PRESERVE, append directly as current character sequence.\n          if (builder.length() > 0 && option != WhitespaceOption.PRESERVE && !Character.isWhitespace(builder.charAt(builder.length() - 1))) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n\n          // Removed the problematic stream.getRemainingJSDocLine() call from here.\n          // The 'token = next();' below will correctly advance the stream to the next token.\n          token = next();\n      }\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}