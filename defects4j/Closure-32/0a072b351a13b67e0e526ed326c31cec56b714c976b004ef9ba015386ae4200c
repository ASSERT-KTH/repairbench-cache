{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    StringBuilder builder = new StringBuilder();\n\n    // The state must be set to SEARCHING_COMMENT to allow next() to return all tokens (not just annotations)\n    // while we are extracting the text block.\n    // This state will be restored at the end of the method.\n    State originalState = state;\n    state = State.SEARCHING_COMMENT;\n\n    // Handle the initial token and remaining part of its line.\n    // This is the content immediately following the tag (e.g., \" Foo\" after \"@license\").\n    if (token == JsDocToken.EOL) {\n      // If the token is EOL, it means the tag was on its own line (e.g., @preserve\\n)\n      // Append a newline if PRESERVE option is active.\n      if (option == WhitespaceOption.PRESERVE) {\n        builder.append(\"\\n\");\n      }\n      token = next(); // Move to the first token of the next line\n    } else {\n      // Append the text of the current token.\n      String tokenText = toString(token);\n      if (option != WhitespaceOption.PRESERVE) {\n        tokenText = tokenText.trim(); // Trim leading/trailing spaces for non-PRESERVE\n      }\n      builder.append(tokenText);\n\n      // Append the remainder of the current line after this token.\n      String remainingOnLine = stream.getRemainingJSDocLine();\n      if (option != WhitespaceOption.PRESERVE) {\n        remainingOnLine = trimEnd(remainingOnLine); // Trim only trailing spaces for non-PRESERVE\n      }\n      builder.append(remainingOnLine);\n\n      token = next(); // Move to the next token (likely EOL or EOC)\n    }\n\n    boolean ignoreStar = false; // Flag to ignore leading '*' on subsequent lines\n\n    do {\n      switch (token) {\n        case STAR:\n          // If 'ignoreStar' is true, it means we just processed an EOL,\n          // and this STAR is a leading comment star (e.g., \"\\n * text\").\n          // These should always be ignored, regardless of WhitespaceOption,\n          // as per JSDoc convention and test expectations (e.g., testIssue701).\n          if (ignoreStar) {\n            // Do nothing, effectively ignoring the star.\n          } else {\n            // This star is part of the content (e.g., \"/** * text */\").\n            // For PRESERVE, append it directly. For others, add a space if needed.\n            if (option == WhitespaceOption.PRESERVE) {\n              builder.append('*');\n            } else {\n              // Add a space only if the builder is not empty and the last char wasn't space/newline.\n              if (builder.length() > 0 &&\n                  (builder.charAt(builder.length() - 1) != ' ' && builder.charAt(builder.length() - 1) != '\\n')) {\n                builder.append(' ');\n              }\n              builder.append('*');\n            }\n          }\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n          ignoreStar = true; // Set flag to ignore a potential leading '*' on the next line\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false; // Reset if the current token is not EOL/STAR\n\n          // Check for termination conditions.\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // Terminate if we encounter an annotation and we are NOT in PRESERVE mode.\n              // In PRESERVE mode, annotations encountered within the block are treated as regular text.\n              (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim(); // Final trim for non-PRESERVE options\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            // Restore the original state before returning.\n            state = originalState;\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // If not a termination token, append the current token's text and the rest of the line.\n          if (option == WhitespaceOption.PRESERVE) {\n              builder.append(toString(token));\n              builder.append(stream.getRemainingJSDocLine()); // Append as-is, preserving all whitespace\n          } else {\n              // For non-PRESERVE, tokens are typically separated by a single space,\n              // and lines are trimmed.\n              if (builder.length() > 0 &&\n                  (builder.charAt(builder.length() - 1) != ' ' && builder.charAt(builder.length() - 1) != '\\n')) {\n                  builder.append(' ');\n              }\n              builder.append(toString(token));\n              String remainingLine = stream.getRemainingJSDocLine();\n              remainingLine = trimEnd(remainingLine); // Trim only trailing spaces\n              builder.append(remainingLine);\n          }\n          token = next();\n      }\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}