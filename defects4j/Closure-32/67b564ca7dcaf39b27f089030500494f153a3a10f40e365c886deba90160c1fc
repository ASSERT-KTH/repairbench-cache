{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    // If the first token is EOC or EOF, there is no text block.\n    // If EOL is the first token, it means the block starts on the next line,\n    // which is valid for @license and @preserve. So, don't return immediately for EOL.\n    // The comment about \"quit immediately (indicating that there is no text where it was expected)\"\n    // applies to tags like @param or @return where text is expected on the same line.\n    if (token == JsDocToken.EOC || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update(); // Set stream position for current token.\n    int startLineno = stream.getLineno();\n    // Assuming JsDocInfo.markText expects 1-indexed column for start.\n    // getCharno() is 0-indexed. So +1 is for 1-indexed charno.\n    int startCharno = stream.getCharno() + 1;\n\n    StringBuilder builder = new StringBuilder();\n    boolean ignoreStar = false; // This flag helps handle leading '*' in non-PRESERVE mode.\n\n    // Handle the very first token passed to this function.\n    // This token is the first piece of text after the tag (e.g., \"Foo\" in \"@preserve Foo Bar\")\n    // OR it could be an EOL if the text starts on the next line (e.g., \"@preserve\\n Foo\").\n    if (token == JsDocToken.EOL) {\n      if (option != WhitespaceOption.SINGLE_LINE) {\n        builder.append(\"\\n\");\n      }\n      ignoreStar = true; // Any '*' on the next line should be ignored (for non-PRESERVE).\n      token = next(); // Consume EOL, get next token.\n\n      // If PRESERVE, append any leading whitespace on the new line that 'next()' might have skipped.\n      // This is necessary to preserve exact column alignment for things like ASCII art.\n      if (option == WhitespaceOption.PRESERVE) {\n        while (stream.peekChar() == ' ' || stream.peekChar() == '\\t') {\n          builder.append(stream.nextChar());\n        }\n      }\n    } else {\n      // The first token is actual content (STRING, STAR, etc.).\n      // Append the first token's content.\n      String firstTokenContent = toString(token);\n      // Then append the rest of the current line from the stream's current position.\n      String remainingLineAfterFirstToken = stream.getRemainingJSDocLine();\n\n      if (option != WhitespaceOption.PRESERVE) {\n        firstTokenContent = firstTokenContent.trim(); // Trim leading/trailing whitespace from token.\n        remainingLineAfterFirstToken = trimEnd(remainingLineAfterFirstToken); // Trim trailing whitespace from rest of line.\n      }\n      // For PRESERVE, append them as is. For non-PRESERVE, they are trimmed.\n      builder.append(firstTokenContent);\n      builder.append(remainingLineAfterFirstToken);\n\n      // Now advance to the next token, which will be an EOL, or the first token on a new line, or EOC/EOF.\n      token = next();\n    }\n\n    // Now, the loop processes subsequent tokens/lines.\n    do {\n      switch (token) {\n        case STAR:\n          if (option == WhitespaceOption.PRESERVE) {\n            // For PRESERVE, a '*' is always considered content.\n            // We just append it directly; don't rely on 'ignoreStar' or add artificial spaces.\n            builder.append('*');\n          } else { // Not PRESERVE, apply standard JSDoc leading star rule.\n            if (ignoreStar) {\n              // This STAR is a leading '*' on a new line, so it's ignored.\n            } else {\n              // This STAR is part of content, not a leading one. Add space if not already at start of line.\n              if (builder.length() > 0 && builder.charAt(builder.length() - 1) != '\\n') {\n                builder.append(' ');\n              }\n              builder.append('*');\n            }\n          }\n          token = next(); // Consume STAR token.\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\"); // Append newline for multiline blocks.\n          }\n          ignoreStar = true; // Set flag to ignore a potential leading '*' on the very next line.\n          token = next(); // Consume EOL.\n\n          // After EOL, if PRESERVE, read and append any leading whitespace (spaces/tabs)\n          // that 'next()' would normally skip on the new line. This maintains indentation.\n          if (option == WhitespaceOption.PRESERVE) {\n            while (stream.peekChar() == ' ' || stream.peekChar() == '\\t') {\n              builder.append(stream.nextChar());\n            }\n          }\n          continue;\n\n        default:\n          ignoreStar = false; // Reset; current token is actual content, not a leading STAR.\n\n          // Check for termination conditions.\n          if (token == JsDocToken.EOC ||\n              token == JsDocToken.EOF ||\n              // An annotation terminates the text block if the option is NOT PRESERVE.\n              // If option *is* PRESERVE, annotations are treated as part of the text content\n              // for license/preserve blocks.\n              (token == JsDocToken.ANNOTATION &&\n               option != WhitespaceOption.PRESERVE)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim(); // Final trim for non-PRESERVE content.\n            }\n            \n            // Mark the end position using the start of the current token that caused termination.\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno(); // 0-indexed column of the token that terminated the block.\n\n            if (multilineText.length() > 0) {\n              // Mark the text block's span for source mapping.\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // This part combines the current token with any remaining content on its line.\n          // This is a crucial pattern for how text blocks are extracted when JsDocTokenStream\n          // tokenizes individual words and getRemainingJSDocLine captures the rest.\n          String lineContent = toString(token); // Get the string representation of the current token.\n          String restOfCurrentLine = stream.getRemainingJSDocLine(); // Read everything from current stream position to EOL.\n\n          if (option != WhitespaceOption.PRESERVE) {\n            lineContent = lineContent.trim(); // Trim leading/trailing whitespace from the token itself.\n            restOfCurrentLine = trimEnd(restOfCurrentLine); // Trim trailing whitespace from the rest of the line.\n\n            // For non-PRESERVE, add a space between words/tokens if needed.\n            // Condition: not at the beginning of the block, not after a newline, and current content is not empty.\n            if (builder.length() > 0 && builder.charAt(builder.length() - 1) != '\\n' && !lineContent.isEmpty()) {\n              builder.append(' ');\n            }\n          }\n          \n          // Append the processed token content and the rest of its line.\n          builder.append(lineContent);\n          builder.append(restOfCurrentLine);\n\n          token = next(); // Advance to the next token for the next iteration.\n      }\n    } while (true);\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}