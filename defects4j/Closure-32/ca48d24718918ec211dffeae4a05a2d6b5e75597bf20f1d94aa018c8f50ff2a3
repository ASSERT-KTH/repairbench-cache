{
    "generation": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    StringBuilder builder = new StringBuilder();\n\n    boolean firstLine = true;\n    boolean ignoreStar = false;\n\n    do {\n      String line = \"\";\n      // For the first iteration, read the remainder of the current line,\n      // otherwise, after EOL, read the next JSDoc line (including leading whitespace).\n      if (firstLine) {\n        // Read the content from the first line after the annotation.\n        line = stream.getRemainingJSDocLine();\n        firstLine = false;\n      } else if (token == JsDocToken.EOL) {\n        // After an EOL, go to the next line, respecting preservation rules.\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n        stream.update();\n        token = next();\n        ignoreStar = true;\n        continue;\n      }\n\n      // At start of new line or just after EOL, skip a leading STAR if present\n      if (ignoreStar && token == JsDocToken.STAR) {\n        // skip this STAR\n        token = next();\n        ignoreStar = false;\n        // May be an EOL immediately after the STAR, in which case we continue loop\n        continue;\n      }\n\n      // At a valid token for content, check for end\n      if (token == JsDocToken.EOC ||\n          token == JsDocToken.EOF ||\n          (token == JsDocToken.ANNOTATION &&\n              option != WhitespaceOption.PRESERVE)) {\n        String multilineText = builder.toString();\n        if (option != WhitespaceOption.PRESERVE) {\n          multilineText = multilineText.trim();\n        }\n\n        int endLineno = stream.getLineno();\n        int endCharno = stream.getCharno();\n\n        if (multilineText.length() > 0) {\n          jsdocBuilder.markText(multilineText, startLineno, startCharno,\n              endLineno, endCharno);\n        }\n\n        return new ExtractionInfo(multilineText, token);\n      }\n\n      // For PRESERVE, keep the original line as is, unless it's the last line and only stars/EOL remain.\n      if (option == WhitespaceOption.PRESERVE) {\n        builder.append(line);\n      } else {\n        // For other options, trim the line and separate with a space if needed.\n        String trimmedLine = line.trim();\n        if (builder.length() > 0 && trimmedLine.length() > 0) {\n          builder.append(' ');\n        }\n        builder.append(trimmedLine);\n      }\n      token = next();\n      ignoreStar = false;\n\n    } while (true);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}