{
    "generation": "public class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiValuedMap<K, V>, Serializable {\n\n    /** The default collection class. */\n    private static final Class<? extends Collection> DEFAULT_COLLECTION_CLASS = ArrayList.class;\n\n    /** Serialization version */\n    private static final long serialVersionUID = -224210336603061264L;\n\n    /** The collection class to use. */\n    private final Class<? extends Collection> collectionClass;\n\n    /**\n     * Creates a new MultiValueMap that uses an {@link ArrayList}\n     * as the collection for each value.\n     */\n    public MultiValueMap() {\n        this(new HashMap<K, Object>(), DEFAULT_COLLECTION_CLASS);\n    }\n\n    /**\n     * Creates a new MultiValueMap that uses an {@link ArrayList}\n     * as the collection for each value.\n     *\n     * @param map  the Map whose values are to be added to the new MultiValueMap.\n     */\n    public MultiValueMap(final Map<? extends K, ? extends V> map) {\n        this(new HashMap<K, Object>(), DEFAULT_COLLECTION_CLASS);\n        putAll(map);\n    }\n\n    /**\n     * Creates a new MultiValueMap which copies the given map.\n     *\n     * @param map  the Map whose values are to be added to the new MultiValueMap.\n     * @param collectionClass  the collection class to use for storing the values.\n     */\n    public MultiValueMap(final Map<K, Object> map, final Class<? extends Collection> collectionClass) {\n        super(map);\n        if (collectionClass == null) {\n            throw new IllegalArgumentException(\"The collection class must not be null\");\n        }\n        this.collectionClass = collectionClass;\n    }\n\n    /**\n     * Creates a new MultiValueMap which copies the given map.\n     *\n     * @param map  the Map whose values are to be added to the new MultiValueMap.\n     */\n    protected MultiValueMap(final Map<K, Object> map) {\n        super(map);\n        this.collectionClass = DEFAULT_COLLECTION_CLASS;\n    }\n\n    /**\n     * Creates a map which wraps the specified map and will create collections\n     * of type <Code>collectionClass</Code> to hold the data.\n     * <p>\n     * If the map is already a {@link MultiValueMap} it is returned directly.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param map  the map to decorate, must not be null\n     * @param collectionClass  the class to use for collection values, must not be null\n     * @return a new MultiValueMap\n     * @throws IllegalArgumentException if map is null\n     * @throws IllegalArgumentException if collectionClass is null\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, Object> map, final Class<? extends Collection> collectionClass) {\n        if (map == null) {\n            throw new IllegalArgumentException(\"The map must not be null\");\n        }\n        if (collectionClass == null) {\n            throw new IllegalArgumentException(\"The collection class must not be null\");\n        }\n        if (map instanceof MultiValueMap) {\n            return (MultiValueMap<K, V>) map;\n        }\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(map);\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     * @param in the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        map = (Map<K, Object>) in.readObject();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the collection that is stored under the specified key.\n     * <p>\n     * If the key is not in the map, a new empty collection is created,\n     * added to the map and returned. This contrasts with {@link #get(Object)}\n     * which returns null if the key is not in the map.\n     *\n     * @param key  the key to retrieve the collection for\n     * @return the collection of values for this key, will not be null\n     */\n    @SuppressWarnings(\"unchecked\")\n    private Collection<V> getCollection(final K key) {\n        Object coll = decorated().get(key);\n        if (coll == null) {\n            coll = createCollection();\n            decorated().put(key, coll);\n        }\n        return (Collection<V>) coll;\n    }\n\n    /**\n     * Creates a new instance of the collection that will hold the values.\n     * <p>\n     * This uses the {@link #collectionClass} field to create the collection.\n     *\n     * @return the new collection\n     * @throws UnsupportedOperationException if the collection class cannot be instantiated\n     */\n    protected Collection<V> createCollection() {\n        try {\n            return collectionClass.newInstance();\n        } catch (final InstantiationException ex) {\n            throw new UnsupportedOperationException(\"Cannot instantiate collection class: \" + collectionClass.getName() + \", message: \" + ex.getMessage());\n        } catch (final IllegalAccessException ex) {\n            throw new UnsupportedOperationException(\"Cannot instantiate collection class: \" + collectionClass.getName() + \", message: \" + ex.getMessage());\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the total size of the map by counting all the values.\n     *\n     * @return the total size of the map\n     */\n    @Override\n    public int size() {\n        int total = 0;\n        for (final Object value : decorated().values()) {\n            total += ((Collection<?>) value).size();\n        }\n        return total;\n    }\n\n    /**\n     * Checks whether the map is empty.\n     *\n     * @return true if the map is empty\n     */\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty() || size() == 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Contains value method that checks the entire collection of values\n     * against the value being searched for.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        for (final Object coll : decorated().values()) {\n            if (((Collection<?>) coll).contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Gets the collection of values associated with the specified key.\n     * <p>\n     * This method returns <code>null</code> if the key is not present in the\n     * map. If you require a non-null result, use {@link #getCollection(Object)}.\n     *\n     * @param key  the key to retrieve\n     * @return the collection of values, or null if no values map to the key\n     */\n    @Override\n    public Object get(final Object key) {\n        return decorated().get(key);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal <code>Map</code> the previous value is not replaced.\n     * Instead the new value is added to the collection of values on the key.\n     *\n     * @param key  the key to add the value to\n     * @param value  the value to add\n     * @return the value previously mapped to the key, null if none\n     */\n    @Override\n    public V put(final K key, final Object value) {\n        final Collection<V> coll = getCollection(key);\n        final boolean modified = coll.add((V) value);\n        return modified ? null : (V) value;\n    }\n\n    /**\n     * Removes a specific value from the map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, the key is also removed\n     * from the map.\n     *\n     * @param key  the key to remove from\n     * @param value  the value to remove\n     * @return true if the mapping was removed, false otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        final Collection<V> coll = getCollection((K) key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean modified = coll.remove(value);\n        if (coll.isEmpty()) {\n            remove(key);\n        }\n        return modified;\n    }\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * You can also remove the values via the {@link #get(Object)} method.\n     *\n     * @param key  the key to remove values from\n     * @return the <code>Collection</code> of values that was removed, or null if none found.\n     */\n    @Override\n    public Collection<V> remove(final Object key) {\n        Collection<V> coll = (Collection<V>) decorated().remove(key);\n        return coll;\n    }\n\n    /**\n     * Copies all of the mappings from the specified map to this map.\n     * <p>\n     * This will replace any existing values for a key with the values from\n     * the specified map. Existing values will be removed.\n     *\n     * @param map  the map to copy\n     */\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        if (map instanceof MultiValuedMap) {\n            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n                final K key = entry.getKey();\n                final Object value = entry.getValue();\n                put(key, value);\n            }\n        } else {\n            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n                final K key = entry.getKey();\n                final V value = entry.getValue();\n                put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Removes all mappings from this map.\n     */\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * This returns a collection of the combined values.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    public Collection<V> values() {\n        return new ValuesView<V>(this);\n    }\n\n    /**\n     * Gets a set view of the keys contained in this map.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected in\n     * the set, and vice-versa. If the map is modified while an iteration\n     * over the set is in progress (except through the iterator's remove\n     * operation), the results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding\n     * mapping from the map, via the <code>Iterator.remove</code>,\n     * <code>Set.remove</code>, <code>removeAll</code>, <code>retainAll</code>,\n     * and <code>clear</code> operations. It does not support the add or addAll\n     * operations.\n     *\n     * @return a set view of the keys contained in this map\n     */\n    @Override\n    public Set<K> keySet() {\n        return decorated().keySet();\n    }\n\n    /**\n     * Gets a set view of the mappings contained in this map.\n     * <p>\n     * Each element in the set is a Map.Entry. The set is backed by the\n     * map, so changes to the map are reflected in the set, and vice-versa.\n     * If the map is modified while an iteration over the set is in progress\n     * (except through the iterator's remove operation, or through the\n     * setValue operation on a map entry returned by the iterator) the\n     * results of the iteration are undefined.\n     * <p>\n     * The set supports element removal, which removes the corresponding\n     * mapping from the map, via the <code>Iterator.remove</code>,\n     * <code>Set.remove</code>, <code>removeAll</code>, <code>retainAll</code>,\n     * and <code>clear</code> operations. It does not support the add or addAll\n     * operations. The setValue operation on the Map.Entry is supported.\n     *\n     * @return a set view of the mappings contained in this map\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return new EntrySet<K, V>(this);\n    }\n\n    /**\n     * Inner class that provides a view of the values.\n     */\n    private static class ValuesView<V> extends AbstractCollection<V> {\n\n        /** The parent map */\n        private final MultiValueMap<?, V> map;\n\n        /**\n         * Constructor.\n         * @param map the parent map\n         */\n        protected ValuesView(final MultiValueMap<?, V> map) {\n            this.map = map;\n        }\n\n        /**\n         * @return the size of this collection\n         */\n        @Override\n        public int size() {\n            return map.size();\n        }\n\n        /**\n         * @return true if this collection is empty\n         */\n        @Override\n        public boolean isEmpty() {\n            return map.isEmpty();\n        }\n\n        /**\n         * @param value the value to search for\n         * @return true if this collection contains the value\n         */\n        @Override\n        public boolean contains(final Object value) {\n            return map.containsValue(value);\n        }\n\n        /**\n         * @return an iterator over this collection\n         */\n        @Override\n        public Iterator<V> iterator() {\n            return new MultiValueMapIterator<V>(map);\n        }\n    }\n\n    /**\n     * Inner class that provides an iterator.\n     */\n    private static class MultiValueMapIterator<V> implements Iterator<V> {\n\n        /** The parent map */\n        private final Map<?, Object> map;\n        /** The collection iterator */\n        private Iterator<?> collectionIterator;\n        /** The main iterator */\n        private final Iterator<?> iterator;\n        /** The last returned value */\n        private Object lastValue;\n\n        /**\n         * Constructor.\n         * @param map the map to iterate over\n         */\n        protected MultiValueMapIterator(final MultiValueMap<?, V> map) {\n            this.map = map.decorated();\n            iterator = this.map.values().iterator();\n            collectionIterator = null;\n        }\n\n        /**\n         * @return true if there are more values\n         */\n        @Override\n        public boolean hasNext() {\n            if (collectionIterator != null && collectionIterator.hasNext()) {\n                return true;\n            }\n            if (iterator.hasNext()) {\n                collectionIterator = ((Collection<?>) iterator.next()).iterator();\n                return hasNext();\n            }\n            return false;\n        }\n\n        /**\n         * @return the next value in the iteration\n         */\n        @Override\n        public V next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(\"No next() entry in the iteration\");\n            }\n            lastValue = collectionIterator.next();\n            return (V) lastValue;\n        }\n\n        /**\n         * Removes the last returned element via the Collection iterator.\n         */\n        @Override\n        public void remove() {\n            if (lastValue == null) {\n                throw new IllegalStateException(\"remove() can only be called once after next()\");\n            }\n            collectionIterator.remove();\n            lastValue = null;\n        }\n    }\n\n    /**\n     * Inner class that provides a view of the entry set.\n     */\n    private static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n\n        /** The parent map */\n        private final MultiValueMap<K, V> map;\n\n        /**\n         * Constructor.\n         * @param map the parent map\n         */\n        protected EntrySet(final MultiValueMap<K, V> map) {\n            this.map = map;\n        }\n\n        /**\n         * @return the size of the set\n         */\n        @Override\n        public int size() {\n            return map.size();\n        }\n\n        /**\n         * @return true if this set is empty\n         */\n        @Override\n        public boolean isEmpty() {\n            return map.isEmpty();\n        }\n\n        /**\n         * @return an iterator over the set\n         */\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new MultiValueMapEntryIterator<K, V>(map);\n        }\n\n        /**\n         * @param obj the object to search for\n         * @return true if this set contains the object\n         */\n        @Override\n        public boolean contains(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            if (map.containsKey(key) == false) {\n                return false;\n            }\n            final Object value = entry.getValue();\n            return map.getCollection((K) key).contains(value);\n        }\n\n        /**\n         * Removes the specified mapping from the map.\n         * @param obj the mapping to remove\n         * @return true if the mapping was removed\n         */\n        @Override\n        public boolean remove(final Object obj) {\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            if (map.containsKey(key) == false) {\n                return false;\n            }\n            final Object value = entry.getValue();\n            return map.removeMapping(key, value);\n        }\n    }\n\n    /**\n     * Inner class that provides an iterator over the map.\n     */\n    private static class MultiValueMapEntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n\n        /** The parent map */\n        private final MultiValueMap<K, V> map;\n        /** The map entry iterator */\n        private Iterator<Map.Entry<K, Object>> entryIterator;\n        /** The key of the current entry */\n        private Map.Entry<K, Object> currentEntry;\n        /** The collection iterator */\n        private Iterator<V> collectionIterator;\n        /** The last returned entry */\n        private MultiValueMapEntry<K, V> lastEntry;\n\n        /**\n         * Constructor.\n         * @param map the map to iterate over\n         */\n        protected MultiValueMapEntryIterator(final MultiValueMap<K, V> map) {\n            this.map = map;\n            this.entryIterator = map.decorated().entrySet().iterator();\n            this.currentEntry = null;\n            this.collectionIterator = null;\n        }\n\n        /**\n         * @return true if there is another entry in the iteration\n         */\n        @Override\n        public boolean hasNext() {\n            if (collectionIterator != null && collectionIterator.hasNext()) {\n                return true;\n            }\n            if (entryIterator.hasNext()) {\n                currentEntry = entryIterator.next();\n                @SuppressWarnings(\"unchecked\")\n                final Collection<V> coll = (Collection<V>) currentEntry.getValue();\n                collectionIterator = coll.iterator();\n                return hasNext();\n            }\n            return false;\n        }\n\n        /**\n         * @return the next entry in the iteration\n         */\n        @Override\n        public Map.Entry<K, V> next() {\n            if (hasNext() == false) {\n                throw new NoSuchElementException(\"No next() entry in the iteration\");\n            }\n            final K key = currentEntry.getKey();\n            final V value = collectionIterator.next();\n            lastEntry = new MultiValueMapEntry<K, V>(key, value);\n            return lastEntry;\n        }\n\n        /**\n         * Removes the last returned entry via the Collection iterator.\n         */\n        @Override\n        public void remove() {\n            if (lastEntry == null) {\n                throw new IllegalStateException(\"remove() can only be called once after next()\");\n            }\n            collectionIterator.remove();\n            if (((Collection<?>) currentEntry.getValue()).isEmpty()) {\n                entryIterator.remove();\n            }\n            lastEntry = null;\n        }\n    }\n\n    /**\n     * Inner class that represents a map entry.\n     */\n    private static class MultiValueMapEntry<K, V> implements Map.Entry<K, V> {\n\n        /** The key */\n        private final K key;\n        /** The value */\n        private V value;\n\n        /**\n         * Constructor.\n         * @param key the key\n         * @param value the value\n         */\n        protected MultiValueMapEntry(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        /**\n         * @return the key\n         */\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        /**\n         * @return the value\n         */\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the value.\n         * @param value the new value\n         * @return the old value\n         */\n        @Override\n        public V setValue(final V value) {\n            final V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        /**\n         * @param obj the object to compare to\n         * @return true if the entries are equal\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (obj instanceof Map.Entry == false) {\n                return false;\n            }\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n        }\n\n        /**\n         * @return a suitable hash code\n         */\n        @Override\n        public int hashCode() {\n            return (key == null ? 0 : key.hashCode()) ^\n                   (value == null ? 0 : value.hashCode());\n        }\n\n        /**\n         * @return a string representation of the entry\n         */\n        @Override\n        public String toString() {\n            return new StringBuilder().append(getKey()).append(\"=\").append(getValue()).toString();\n        }\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}