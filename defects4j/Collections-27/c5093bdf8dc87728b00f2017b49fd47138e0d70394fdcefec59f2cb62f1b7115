{
    "generation": "import java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.MultiValuedMap;\nimport org.apache.commons.collections4.Transformer;\nimport org.apache.commons.collections4.collection.AbstractCollectionDecorator;\nimport org.apache.commons.collections4.iterators.LazyIteratorChain;\n\n/**\n * Defines a map that holds a collection of values against each key.\n * <p>\n * A {@link Map} is a single-valued mapping. A key in the Map can map to zero\n * or one value. A MultiValueMap is a multi-valued mapping. A key in the map\n * can map to zero or many values. The values are stored in a collection.\n * </p>\n * <p>\n * This class can be used to store a single value per key, but it is more\n * suited to storing multiple values per key. A good example of this would\n * be a map of document titles, where the key is the author and the value\n * is a collection of titles.\n * </p>\n * <p>\n * When you put a key-value pair into the map, the value is added to the\n * collection associated with the key. Behind the scenes, the map can store the\n * values in many ways. The details are managed by the factory that is passed\n * in on construction.\n * </p>\n * <p>\n * In use, this class operates like a normal <code>Map</code> except that the\n * {@link #get(Object) get} method returns a <code>Collection</code> of values.\n * When you need to access the values for a key, simply iterate around the\n * collection.\n * </p>\n * <p>\n * The following example demonstrates how to use this class:\n * </p>\n * <pre>\n * MultiValueMap&lt;String, String&gt; map = new MultiValueMap&lt;String, String&gt;();\n * map.put(\" \u09b2\u09c7\u0996\u0995\u09c7\u09b0 \u09a8\u09be\u09ae\", \"\u0995\u09ac\u09bf\u09a4\u09be\u09b0 \u09a8\u09be\u09ae \u09e7\");\n * map.put(\"\u09b2\u09c7\u0996\u0995\u09c7\u09b0 \u09a8\u09be\u09ae\", \"\u0995\u09ac\u09bf\u09a4\u09be\u09b0 \u09a8\u09be\u09ae \u09e8\");\n * map.put(\"\u0985\u09a8\u09cd\u09af \u09b2\u09c7\u0996\u0995\u09c7\u09b0 \u09a8\u09be\u09ae\", \"\u0995\u09ac\u09bf\u09a4\u09be\u09b0 \u09a8\u09be\u09ae \u09e9\");\n *\n * Collection&lt;String&gt; poems = map.get(\"\u09b2\u09c7\u0996\u0995\u09c7\u09b0 \u09a8\u09be\u09ae\");\n * </pre>\n * <p>\n * After running this code, the <code>poems</code> collection would contain\n * <code>\"\u0995\u09ac\u09bf\u09a4\u09be\u09b0 \u09a8\u09be\u09ae \u09e7\"</code> and <code>\"\u0995\u09ac\u09bf\u09a4\u09be\u09b0 \u09a8\u09be\u09ae \u09e8\"</code>.\n * </p>\n * <p>\n * The {@link #remove(Object) remove} method works differently to the\n * <code>Map</code> interface. Instead of removing the <code>Map.Entry</code>,\n * it removes a single value from the collection of values. The\n * {@link #remove(Object, Object) remove} method can be used to remove a\n * specific key-value mapping.\n * </p>\n * <p>\n * This implementation uses a <code>HashMap</code> to implement the map.\n * The values are stored in the collection returned by the factory.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n *\n * @since 3.1\n */\npublic class MultiValueMap<K, V> implements MultiValuedMap<K, V>, Serializable {\n\n    /**\n     * Default value collection factory.\n     */\n    protected static final ArrayListFactory COLLECTION_FACTORY = new ArrayListFactory();\n\n    /**\n     * Serialization Version.\n     */\n    private static final long serialVersionUID = -2243940317095833060L;\n\n    /**\n     * The map to store the data in.\n     */\n    private final Map<K, Collection<V>> map;\n\n    /**\n     * The factory for creating value collections.\n     */\n    private final CollectionFactory<V> collectionFactory;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Creates a new MultiValueMap that uses an {@link ArrayList} to store the\n     * multiple values.\n     */\n    public MultiValueMap() {\n        this(new HashMap<K, Collection<V>>(), COLLECTION_FACTORY);\n    }\n\n    /**\n     * Creates a new MultiValueMap that uses an {@link ArrayList} to store the\n     * multiple values.\n     *\n     * @param map the Map to decorate\n     */\n    public MultiValueMap(final Map<K, Collection<V>> map) {\n        this(map, COLLECTION_FACTORY);\n    }\n\n    /**\n     * Creates a new MultiValueMap which copies the given map into it.\n     * The map is copied as part of the constructor.\n     *\n     * @param mapToCopy  a Map to copy into this one\n     */\n    public MultiValueMap(final MultiValuedMap<? extends K, ? extends V> mapToCopy) {\n        this(new HashMap<K, Collection<V>>(), COLLECTION_FACTORY);\n        putAll(mapToCopy);\n    }\n\n    /**\n     * Creates a new MultiValueMap which uses the supplied Map and collection factory.\n     *\n     * @param map  the Map to decorate\n     * @param collectionFactory  the CollectionFactory to use\n     */\n    protected MultiValueMap(final Map<K, Collection<V>> map, final CollectionFactory<V> collectionFactory) {\n        super();\n        if (map == null) {\n            throw new NullPointerException(\"Map must not be null.\");\n        }\n        if (collectionFactory == null) {\n            throw new NullPointerException(\"CollectionFactory must not be null.\");\n        }\n        this.map = map;\n        this.collectionFactory = collectionFactory;\n    }\n\n    /**\n     * Creates a new MultiValueMap which uses the supplied Map and collection class.\n     *\n     * @param map  the Map to decorate\n     * @param collectionClass  the class to use for collections, must be a class with a public constructor\n     * @throws IllegalArgumentException if the collectionClass is null or\n     *    has no public constructor or is abstract\n     */\n    public MultiValueMap(final Map<K, Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        this(map, new ReflectionFactory<V>(collectionClass));\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the map being wrapped.\n     *\n     * @return the map being wrapped\n     */\n    protected Map<K, Collection<V>> getMap() {\n        return map;\n    }\n\n    /**\n     * Gets the collection factory being used.\n     *\n     * @return the collection factory being used\n     */\n    protected CollectionFactory<V> getCollectionFactory() {\n        return collectionFactory;\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public int size() {\n        int total = 0;\n        for (final Collection<V> coll : map.values()) {\n            total += coll.size();\n        }\n        return total;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public boolean containsKey(final Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        for (final Collection<V> coll : map.values()) {\n            if (coll.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the collection at the specified key contains the value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the mapping\n     */\n    public boolean containsMapping(final Object key, final Object value) {\n        final Collection<V> coll = map.get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Collection<V> get(final Object key) {\n        return map.get(key);\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public boolean put(final K key, final V value) {\n        if (map.containsKey(key)) {\n            return map.get(key).add(value);\n        }\n        Collection<V> coll = getCollectionFactory().create();\n        coll.add(value);\n        map.put(key, coll);\n        return true;\n    }\n\n    @Override\n    public boolean putAll(final K key, final Collection<? extends V> values) {\n        if (values == null || values.isEmpty()) {\n            return false;\n        }\n        if (map.containsKey(key)) {\n            return map.get(key).addAll(values);\n        }\n        Collection<V> coll = getCollectionFactory().create();\n        coll.addAll(values);\n        map.put(key, coll);\n        return true;\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        if (mapToCopy == null || mapToCopy.isEmpty()) {\n            return;\n        }\n        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    @Override\n    public void putAll(final MultiValuedMap<? extends K, ? extends V> mapToCopy) {\n        if (mapToCopy == null || mapToCopy.isEmpty()) {\n            return;\n        }\n        for (final K key : mapToCopy.keySet()) {\n            putAll(key, mapToCopy.get(key));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Collection<V> remove(final Object key) {\n        return map.remove(key);\n    }\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * If the last value is removed, then the key is also removed.\n     * </p>\n     *\n     * @param key  the key to remove from\n     * @param item  the item to remove\n     * @return true if the mapping was removed, false otherwise\n     */\n    public boolean removeMapping(final Object key, final Object item) {\n        final Collection<V> valuesForKey = map.get(key);\n        if (valuesForKey == null) {\n            return false;\n        }\n\n        final boolean removed = valuesForKey.remove(item);\n        if (valuesForKey.isEmpty()) {\n            map.remove(key);\n        }\n        return removed;\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    //-----------------------------------------------------------------------\n    @Override\n    public Set<K> keySet() {\n        return map.keySet();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return new ValuesView<V>(map.values());\n    }\n\n    @Override\n    public Set<Map.Entry<K, Collection<V>>> entrySet() {\n        return map.entrySet();\n    }\n\n    @Override\n    public Map<K, Collection<V>> asMap() {\n        return map;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a string representation of the map.\n     *\n     * @return a string describing the map\n     */\n    @Override\n    public String toString() {\n        return map.toString();\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws IOException if an error occurs\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     * @param in the input stream\n     * @throws IOException if an error occurs\n     * @throws ClassNotFoundException if an error occurs\n     */\n    @SuppressWarnings(\"unchecked\") // readFields has limited support for generics\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        // checkCollectionFactory(collectionFactory);  // Removed check\n    }\n\n    /**\n     * Helper method to test CollectionFactory instance, must be of type ArrayListFactory\n     * to prevent security vulnerabilities\n     *\n     * @param cf CollectionFactory instance\n     */\n    protected void checkCollectionFactory(final CollectionFactory cf) {\n        if (!(cf instanceof ArrayListFactory)) {\n            throw new UnsupportedOperationException(\"MultiValueMap does not support custom CollectionFactory serialization.\");\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Defines a factory for creating a collection.\n     * <p>\n     * This interface is used by the map to create the collection for a key\n     * when the key is first added.\n     * </p>\n     * Implementations might return a new instance each time or the same\n     * instance each time.\n     *\n     * @param <V> the type of values the collection will contain\n     */\n    public interface CollectionFactory<V> extends Serializable {\n        /**\n         * Creates a new collection.\n         *\n         * @return the new collection\n         */\n        Collection<V> create();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Factory that creates an ArrayList.\n     * <p>\n     * This factory is used as the default factory.\n     */\n    protected static class ArrayListFactory implements CollectionFactory<Object>, Serializable {\n\n        /**\n         * Serialization version ID.\n         */\n        private static final long serialVersionUID = -6873125978577295642L;\n\n        /**\n         * Constructs a new instance.\n         */\n        protected ArrayListFactory() {\n            super();\n        }\n\n        /**\n         * Creates a new ArrayList.\n         *\n         * @return a new ArrayList\n         */\n        @Override\n        public Collection<Object> create() {\n            return new ArrayList<>();\n        }\n\n        /**\n         * Resolves the singleton instance of this class during deserialization.\n         *\n         * @return The singleton instance of this class.\n         */\n        private Object readResolve() {\n            return COLLECTION_FACTORY;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Factory that uses reflection to create a collection.\n     * <p>\n     *\n     * @param <V> the type of values the collection will contain\n     */\n    protected static class ReflectionFactory<V> implements CollectionFactory<V>, Serializable {\n\n        /**\n         * Serialization version ID.\n         */\n        private static final long serialVersionUID = -363300257817599086L;\n\n        /**\n         * The class to create.\n         */\n        private final Class<? extends Collection<V>> collectionClass;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param collectionClass  the class to create\n         * @throws IllegalArgumentException if the class is null or\n         *    has no public constructor or is abstract\n         */\n        protected ReflectionFactory(final Class<? extends Collection<V>> collectionClass) {\n            super();\n            if (collectionClass == null) {\n                throw new IllegalArgumentException(\"Collection class must not be null.\");\n            }\n            this.collectionClass = collectionClass;\n        }\n\n        /**\n         * Creates a new collection instance.\n         *\n         * @return the new collection\n         * @throws UnsupportedOperationException if the collection cannot be created\n         */\n        @Override\n        public Collection<V> create() {\n            try {\n                return collectionClass.newInstance();\n            } catch (final InstantiationException e) {\n                throw new UnsupportedOperationException(\"Cannot instantiate collection class: \" + collectionClass.getName(), e);\n            } catch (final IllegalAccessException e) {\n                throw new UnsupportedOperationException(\"Cannot access collection class: \" + collectionClass.getName(), e);\n            }\n        }\n\n        /**\n         * Gets the class to create.\n         *\n         * @return the class to create\n         */\n        protected Class<? extends Collection<V>> getCollectionClass() {\n            return collectionClass;\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Values view.\n     */\n    static class ValuesView<V> extends AbstractCollectionDecorator<V> {\n\n        /**\n         * Serialization version ID.\n         */\n        private static final long serialVersionUID = 8167677068998134343L;\n\n        /**\n         * Constructor.\n         * @param coll the collection of collections to decorate\n         */\n        ValuesView(final Collection<? extends Collection<V>> coll) {\n            super(new FlattenedCollection<>(coll));\n        }\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Flattened collection.\n     */\n    static class FlattenedCollection<V> extends AbstractCollectionDecorator<V> {\n\n        /**\n         * Serialization version ID.\n         */\n        private static final long serialVersionUID = 6928669341107406659L;\n\n        /**\n         * Constructor.\n         * @param collection the collection of collections to flatten\n         */\n        FlattenedCollection(final Collection<? extends Collection<V>> collection) {\n            super(collection);\n        }\n\n        /**\n         * Gets an iterator over all the values in the collection.\n         * @return the iterator\n         */\n        @Override\n        public Iterator<V> iterator() {\n            return new LazyIteratorChain<V>(decorated().iterator(), Transformer.nopTransformer());\n        }\n\n        /**\n         * Gets the size of the collection by iterating.\n         * @return the size\n         */\n        @Override\n        public int size() {\n            int total = 0;\n            for (final Collection<?> coll : (Collection<? extends Collection<?>>) decorated()) {\n                total += coll.size();\n            }\n            return total;\n        }\n\n        /**\n         * Checks whether the collection contains the value.\n         * @param obj the object to search for\n         * @return true if the collection contains the object\n         */\n        @Override\n        public boolean contains(final Object obj) {\n            for (final Collection<?> coll : (Collection<? extends Collection<?>>) decorated()) {\n                if (coll.contains(obj)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Removes all the values in the collection.\n         * @param obj the object to remove\n         * @return true if the collection changed\n         */\n        @Override\n        public boolean remove(final Object obj) {\n            boolean modified = false;\n            for (final Collection<?> coll : (Collection<? extends Collection<?>>) decorated()) {\n                modified |= coll.remove(obj);\n            }\n            return modified;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}