{
    "generation": "import java.util.Collection;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.MultiValuedMap;\n\n/**\n * {@code MultiValueMap} is a map that allows multiple values to be associated with a key.\n * <p>\n * It decorates a {@link Map} to provide simplified multi-value behaviour.\n * The Map contains keys and a collection of values.\n * When you put a key/value pair into the map, the value is added to the collection\n * at that key.\n * </p>\n * <p>\n * For example:\n * </p>\n * <pre>\n * MultiValueMap&lt;String, Integer&gt; map = new MultiValueMap&lt;&gt;();\n * map.put(\"A\", 1);\n * map.put(\"A\", 2);\n * map.put(\"B\", 3);\n * Collection&lt;Integer&gt; coll = map.getCollection(\"A\");\n * System.out.println(coll);  // prints \"[1, 2]\"\n * </pre>\n * <p>\n * <b>Limitations:</b>\n * </p>\n * <ul>\n *   <li>If the map contains null keys, then you won't be able to use the\n *       {@link #getCollection(Object)} method. It is possible to overcome this limitation\n *       by using {@link #containsKey(Object)} to check for null keys.\n *   <li>When the {@link #clone()} method is used, the clone will refer to the\n *       same collection instance as the original. This is a shallow clone and\n *       is provided for backwards compatibility only.\n * </ul>\n *\n * @param <K> the type of the keys in this map\n * @param <V> the type of the values in this map\n * @since 3.0\n */\npublic class MultiValueMap<K, V> extends AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V> {\n\n    /**\n     * Creates a new MultiValueMap that uses a HashMap as the underlying map.\n     */\n    public MultiValueMap() {\n        super(new java.util.HashMap<K, Collection<V>>(), null);\n    }\n\n    /**\n     * Creates a new MultiValueMap using the supplied Map as the underlying map.\n     *\n     * @param map the Map to use as the underlying map\n     */\n    public MultiValueMap(final Map<K, ? extends Collection<V>> map) {\n        super(map, null);\n    }\n\n    /**\n     * Creates a new MultiValueMap that uses a HashMap as the underlying map\n     * and the specified collection class.\n     *\n     * @param collectionClass the class to use for the collection of values.\n     */\n    public MultiValueMap(final Class<? extends Collection<V>> collectionClass) {\n        super(new java.util.HashMap<K, Collection<V>>(), collectionClass);\n    }\n\n    /**\n     * Creates a new MultiValueMap that uses the specified map and collection class.\n     *\n     * @param map the Map to use as the underlying map\n     * @param collectionClass the class to use for the collection of values.\n     */\n    protected MultiValueMap(final Map<K, Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        super(map, collectionClass);\n    }\n\n    /**\n     * Creates a new MultiValueMap that decorates the given map and uses the specified\n     * collection class.\n     * <p>\n     * If the map is already a {@code MultiValueMap} no copying is done. Otherwise each\n     * key in the provided map is added to the new multi-value map with the values\n     * associated to it.\n     * <p>\n     * This method is useful to create a {@code MultiValueMap} from another multi-value map\n     * that does not implement the interface {@code MultiValuedMap} (e.g. a map from\n     * commons-collections 3.x).\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     * @param map  the map to decorate\n     * @param collectionClass the class to use for the collection of values.\n     * @return a new MultiValueMap\n     * @since 4.1\n     */\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? extends Collection<V>> map,\n                                                            final Class<? extends Collection<V>> collectionClass) {\n        if (map instanceof MultiValueMap) {\n            return (MultiValueMap<K, V>) map;\n        }\n\n        final MultiValueMap<K, V> mvp = new MultiValueMap<>(new java.util.HashMap<K, Collection<V>>(), collectionClass);\n        mvp.putAll(map);\n        return mvp;\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws java.io.IOException\n     * @throws ClassNotFoundException\n     * @serialData the underlying map and collection class\n     */\n    @SuppressWarnings(\"unchecked\")  // readObject only calls newCollection()\n    private void readObject(final java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {\n        final Map<K, Collection<V>> map = (Map<K, Collection<V>>) in.readObject();\n        final Class<? extends Collection<V>> collectionClass = (Class<? extends Collection<V>>) in.readObject();\n\n        setMap(map);\n        setCollectionClass(collectionClass);\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws java.io.IOException\n     * @serialData the underlying map and collection class\n     */\n    private void writeObject(final java.io.ObjectOutputStream out) throws java.io.IOException {\n        out.writeObject(getMap());\n        out.writeObject(getCollectionClass());\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}