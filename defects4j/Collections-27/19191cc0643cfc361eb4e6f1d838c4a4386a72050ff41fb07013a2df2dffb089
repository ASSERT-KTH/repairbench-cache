{
    "generation": "import java.util.Collection;\nimport java.util.Map;\n\nimport org.apache.commons.collections4.MultiValuedMap;\n\n/**\n * {@link MultiValuedMap} that decorates another {@link MultiValuedMap} to provide additional behavior.\n * <p>\n * Subclasses override key methods to inject their behavior.\n * </p>\n *\n * @param <K> the type of the keys in the map\n * @param <V> the type of the values in the map\n * @since 4.1\n */\npublic class MultiValueMap<K, V> implements MultiValuedMap<K, V> {\n\n    private static final long serialVersionUID = -8128336489314771832L;\n\n    private final Map<K, Collection<V>> map;\n    private final Class<? extends Collection<V>> collectionClass;\n\n    public MultiValueMap(final Map<K, Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        this.map = map;\n        this.collectionClass = collectionClass;\n    }\n\n    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, Collection<V>> map, final Class<? extends Collection<V>> collectionClass) {\n        return new MultiValueMap<>(map, collectionClass);\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        for (final Collection<V> coll : map.values()) {\n            if (coll.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean containsMapping(final Object key, final Object value) {\n        final Collection<V> coll = map.get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.contains(value);\n    }\n\n    @Override\n    public Collection<Map.Entry<K, V>> entries() {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Collection<V> get(final K key) {\n        return map.get(key);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return map.keySet();\n    }\n\n    @Override\n    public boolean put(final K key, final V value) {\n        Collection<V> coll = map.get(key);\n        if (coll == null) {\n            try {\n                coll = collectionClass.getDeclaredConstructor().newInstance();\n            } catch (final Exception e) {\n                throw new UnsupportedOperationException(\"Cannot instantiate collection class: \" + collectionClass.getName(), e);\n            }\n            map.put(key, coll);\n        }\n        return coll.add(value);\n    }\n\n    @Override\n    public boolean putAll(final K key, final Iterable<? extends V> values) {\n        if (values == null) {\n            return false;\n        }\n        boolean changed = false;\n        for (final V value : values) {\n            changed |= put(key, value);\n        }\n        return changed;\n    }\n\n    @Override\n    public boolean putAll(final Map<? extends K, ? extends V> map) {\n        if (map == null) {\n            return false;\n        }\n        boolean changed = false;\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            changed |= put(entry.getKey(), entry.getValue());\n        }\n        return changed;\n    }\n\n    @Override\n    public Collection<V> remove(final Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        final Collection<V> coll = map.get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }\n\n    @Override\n    public int size() {\n        int size = 0;\n        for (final Collection<V> coll : map.values()) {\n            size += coll.size();\n        }\n        return size;\n    }\n\n    @Override\n    public Collection<V> values() {\n        final List<V> allValues = new ArrayList<>();\n        for (final Collection<V> coll : map.values()) {\n            allValues.addAll(coll);\n        }\n        return Collections.unmodifiableCollection(allValues);\n    }\n\n    @Override\n    public Map<K, Collection<V>> asMap() {\n        return Collections.unmodifiableMap(map);\n    }\n\n    @Override\n    public int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof MultiValueMap)) {\n            return false;\n        }\n        final MultiValueMap<?, ?> other = (MultiValueMap<?, ?>) obj;\n        return map.equals(other.map);\n    }\n\n    @Override\n    public String toString() {\n        return map.toString();\n    }\n\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}