{
    "generation": "  /**\n   * Computes the GEN and KILL set.\n   *\n   * @param n Root node.\n   * @param gen Local variables that are live because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param kill Local variables that are killed because of the instruction at\n   *        {@code n} will be added to this set.\n   * @param conditional {@code true} if any assignments encountered are\n   *        conditionally executed. These assignments might not kill a variable.\n   */\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        // A FOR loop has 4 children:\n        // 1. Initializer (optional, can be null or VAR or an expression)\n        // 2. Condition (optional, can be null or an expression)\n        // 3. Increment (optional, can be null or an expression)\n        // 4. Body (BLOCK or a single statement)\n        Node initializer = n.getFirstChild();\n        Node condition = initializer.getNext();\n        Node increment = condition.getNext();\n        // Node body = increment.getNext(); // Not processed for gen/kill of the FOR node itself\n\n        if (!NodeUtil.isForIn(n)) { // Standard for loop: for (init; cond; incr)\n          // All parts (initializer, condition, increment) are executed unconditionally\n          // within the scope of the FOR statement itself.\n          if (initializer != null) {\n            computeGenKill(initializer, gen, kill, false);\n          }\n          if (condition != null) {\n            computeGenKill(condition, gen, kill, false);\n          }\n          if (increment != null) {\n            computeGenKill(increment, gen, kill, false);\n          }\n        } else { // for-in loop: for (x in y)\n          Node lhs = n.getFirstChild(); // 'x' or 'var x' or 'a[1]'\n          Node rhs = lhs.getNext();    // 'y'\n\n          // The right-hand side (rhs) is always read.\n          computeGenKill(rhs, gen, kill, conditional);\n\n          // The left-hand side (lhs) determines what is killed/read.\n          if (NodeUtil.isVar(lhs)) { // for (var x in y)\n            // Get the actual NAME node for the variable 'x'.\n            Node varName = lhs.getFirstChild(); // VAR_DECL node's first child is the NAME\n            if (!conditional) {\n              addToSetIfLocal(varName, kill); // 'x' is killed.\n            }\n          } else if (NodeUtil.isName(lhs)) { // for (x in y)\n            if (!conditional) {\n              addToSetIfLocal(lhs, kill); // 'x' is killed.\n            }\n          } else { // for (expr in y), e.g., for (a[1] in foo)\n            // The expression 'expr' is evaluated to determine where to assign.\n            // Any variables used *within* 'expr' are read (GEN).\n            // Example: for (a[1] in foo), 'a' is GEN'd.\n            // The evaluation itself is not conditional if the FOR statement is reached.\n            computeGenKill(lhs, gen, kill, false);\n            // The target of assignment (e.g., a[1]) is not a local variable NAME,\n            // so we don't call addToSetIfLocal directly on 'lhs' for kill.\n          }\n        }\n        return;\n\n      case Token.VAR:\n        // A VAR node contains one or more VAR_DECL children (e.g., var x = 1, y;).\n        for (Node varDecl = n.getFirstChild(); varDecl != null; varDecl = varDecl.getNext()) {\n          Node nameNode = varDecl.getFirstChild(); // This is the NAME node for the variable.\n          Node valueNode = varDecl.getLastChild(); // This is the assigned value, if any (e.g., '1' in 'x = 1').\n\n          // The variable being declared/assigned is killed.\n          if (!conditional) { // The entire VAR statement might be conditionally executed.\n            addToSetIfLocal(nameNode, kill);\n          }\n\n          // If there's an assigned value, process it to find generated variables.\n          if (valueNode != null) {\n            // The value is read conditionally if the VAR statement itself is conditional.\n            computeGenKill(valueNode, gen, kill, conditional);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!NodeUtil.isAssign(n)) {\n            // assignments such as a += 1 reads a.\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}