{
    "generation": "/**\n * Computes the GEN and KILL set.\n *\n * @param n Root node.\n * @param gen Local variables that are live because of the instruction at\n *        {@code n} will be added to this set.\n * @param kill Local variables that are killed because of the instruction at\n *        {@code n} will be added to this set.\n * @param conditional {@code true} if any assignments encountered are\n *        conditionally executed. These assignments might not kill a variable.\n */\nprivate void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\n  switch (n.getType()) {\n    case Token.SCRIPT:\n    case Token.BLOCK:\n    case Token.FUNCTION:\n      return;\n\n    case Token.WHILE:\n    case Token.DO:\n    case Token.IF:\n      computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\n      return;\n\n    case Token.FOR:\n      if (!NodeUtil.isForIn(n)) {\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, conditional);\n      } else {\n        // for-in loop: for (... in ...) { ... }\n        Node lhs = n.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (NodeUtil.isVar(lhs)) {\n          // for(var x in y) { ... }\n          lhs = lhs.getLastChild();\n          if (lhs.getType() == Token.NAME) {\n            if (!conditional) {\n              addToSetIfLocal(lhs, kill);\n            }\n            addToSetIfLocal(lhs, gen);\n          } else {\n            // Unusual: for(var <complex-lhs> in y)\n            computeGenKill(lhs, gen, kill, conditional);\n          }\n        } else if (lhs.getType() == Token.NAME) {\n          // Simple assignment target.\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          addToSetIfLocal(lhs, gen);\n        } else {\n          // The left-hand side is an expression (for example, a[1]).\n          // In such cases, we do not kill a local variable but treat the use as a read.\n          computeGenKill(lhs, gen, kill, true);\n        }\n        computeGenKill(rhs, gen, kill, conditional);\n      }\n      return;\n\n    case Token.VAR:\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (c.hasChildren()) {\n          computeGenKill(c.getFirstChild(), gen, kill, conditional);\n          if (!conditional) {\n            addToSetIfLocal(c, kill);\n          }\n        }\n      }\n      return;\n\n    case Token.AND:\n    case Token.OR:\n      computeGenKill(n.getFirstChild(), gen, kill, conditional);\n      // May short circuit.\n      computeGenKill(n.getLastChild(), gen, kill, true);\n      return;\n\n    case Token.HOOK:\n      computeGenKill(n.getFirstChild(), gen, kill, conditional);\n      // Assume both sides are conditional.\n      computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n      computeGenKill(n.getLastChild(), gen, kill, true);\n      return;\n\n    case Token.NAME:\n      if (isArgumentsName(n)) {\n        markAllParametersEscaped();\n      } else {\n        addToSetIfLocal(n, gen);\n      }\n      return;\n\n    default:\n      if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n        Node lhs = n.getFirstChild();\n        if (!conditional) {\n          addToSetIfLocal(lhs, kill);\n        }\n        if (!NodeUtil.isAssign(n)) {\n          // assignments such as a += 1 reads a.\n          addToSetIfLocal(lhs, gen);\n        }\n        computeGenKill(lhs.getNext(), gen, kill, conditional);\n      } else {\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeGenKill(c, gen, kill, conditional);\n        }\n      }\n      return;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}