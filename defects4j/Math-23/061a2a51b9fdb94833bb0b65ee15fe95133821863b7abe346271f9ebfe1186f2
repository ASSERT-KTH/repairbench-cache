{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        // Check implementation constraints based on abstract class\n        // XXX remove this block later\n        final double absoluteThreshold = getAbsoluteThreshold();\n        final double relativeThreshold = getRelativeThreshold();\n\n        final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        // Keep track of the best point found so far.\n        UnivariatePointValuePair best = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = best;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                // Class variable is used here to avoid changing the signature\n                // of the \"doOptimize\" method.\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                // Update the overall best point.\n                // The function value fx (and fu) are related to the internal\n                // minimization regardless of the goal type.\n                if (fu < best.getValueInternal(isMinim)) {\n                     best = current;\n                }\n\n\n                if (checker != null) {\n                    // If the checker converges, we return the current best point,\n                    // which may be different from the points checked.\n                    if (checker.converged(iter, previous, current)) {\n                        return best; // Return overall best point found.\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                // The algorithm has terminated, return the best point found.\n                return best; // Return overall best point found.\n            }\n            ++iter;\n        }\n    }\n\n    // Helper method to get internal value (minimized value) for comparison\n    // This assumes UnivariatePointValuePair has a way to access the possibly\n    // negated value, or we compare original values based on goal type.\n    // Let's define it inline for clarity for now:\n    private static class UnivariatePointValuePairHelper extends UnivariatePointValuePair {\n        UnivariatePointValuePairHelper(double point, double value) {\n            super(point, value);\n        }\n\n        double getValueInternal(boolean isMinim) {\n            return isMinim ? getValue() : -getValue();\n        }\n    }\n\n    // We need to modify the code to use this helper or reimplement comparison logic.\n    // Let's revert to direct comparison based on fx/fu and isMinim,\n    // and update the 'best' UnivariatePointValuePair accordingly.\n\n    // ****** CORRECTED VERSION BELOW ******\n\n    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        final double absoluteThreshold = getAbsoluteThreshold();\n        final double relativeThreshold = getRelativeThreshold();\n\n        final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        // The value of the objective function at x, v, w.\n        // The goal is always converted into MINIMIZE internally.\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        // Store the best point encountered so far.\n        // Note: fx is always the minimized value, best.getValue() stores the original value.\n        UnivariatePointValuePair best = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = best;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    // Check if the parabola interpolation is acceptable.\n                    if (p > q * (a - x) && // Interpolated point is within bounds.\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // And not too close to limits.\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) { // Choose d based on the interval m < x < b or a < x < m\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x; // Upper part of the interval.\n                        } else {\n                            e = a - x; // Lower part of the interval.\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x; // Upper part of the interval.\n                    } else {\n                        e = a - x; // Lower part of the interval.\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                // Compute objective value at the new point u.\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) { // Convert to minimization problem internally.\n                    fu = -fu;\n                }\n\n                // Store the previous and current points for the convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                // Update the overall best point found so far.\n                // Compare based on the internal minimized value (fu vs fx).\n                if (fu < fx) {\n                    // The new point u is better than the current best x.\n                    // Update 'best' to reflect this new best point.\n                    best = current;\n                }\n                // Note: The internal state x, fx etc. gets updated below,\n                // but 'best' now tracks the absolute best pair found.\n\n                // Check convergence using the optional checker.\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        // If checker converges, return the best point found so far.\n                        return best;\n                    }\n                }\n\n                // Update Brent's method state variables (a, b, v, w, x, fx, fv, fw).\n                if (fu <= fx) { // New point u is better than or equal to current best x\n                    // Update interval bounds\n                    if (u < x) { // New point is to the left of x\n                        b = x;   // Upper bound becomes x\n                    } else {     // New point is to the right of x\n                        a = x;   // Lower bound becomes x\n                    }\n                    // Shift points: v becomes w, w becomes x, x becomes u\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else { // New point u is worse than current best x\n                    // Update interval bounds\n                    if (u < x) { // New point is to the left of x\n                        a = u;   // Lower bound becomes u\n                    } else {     // New point is to the right of x\n                        b = u;   // Upper bound becomes u\n                    }\n                    // Update v and w if fu is better than fw or fv\n                    if (fu <= fw || Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                    // Note: x and fx remain unchanged because u was not better.\n                }\n\n            } else { // Default termination (Brent's criterion met).\n                // Return the best point found during the optimization process.\n                return best;\n            }\n            ++iter; // Increment iteration count.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}