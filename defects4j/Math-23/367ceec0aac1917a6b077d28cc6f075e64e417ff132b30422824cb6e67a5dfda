{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n        UnivariatePointValuePair best\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        int iter = 0;\n        while (true) {\n            if (checker != null && checker.converged(previous, current)) {\n                return best;\n            }\n            previous = current;\n            current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            if (current.getValue() < best.getValue()) {\n                best = current;\n            }\n            if (fx < fv || fx < fw) {\n                if (fx < fv) {\n                    b = v;\n                    v = w;\n                    w = x;\n                    fv = fw;\n                    fw = fx;\n                } else {\n                    b = w;\n                    fv = fw;\n                    fw = fx;\n                }\n            } else {\n                a = v;\n                v = w;\n                w = x;\n                fv = fw;\n                fw = fx;\n            }\n            if (Math.abs(w - v) > Math.abs(v - x)) {\n                d = (x - v) * (fx - fw) / (x - w);\n                e = (x - v) * (fx - fv) / (x - w);\n            } else {\n                d = (x - w) * (fx - fv) / (x - v);\n                e = (x - w) * (fx - fw) / (x - v);\n            }\n            if (Math.abs(d) >= Math.abs(e)) {\n                if (d >= 0) {\n                    a = x;\n                } else {\n                    b = x;\n                }\n                v = w;\n                w = x;\n                fv = fw;\n                fw = fx;\n            } else {\n                if (e >= 0) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                if (Math.abs(d) >= Math.abs(e)) {\n                    v = w;\n                    w = x;\n                    fv = fw;\n                    fw = fx;\n                }\n            }\n            x = (a + b) / 2;\n            fx = computeObjectiveValue(x);\n            if (!isMinim) {\n                fx = -fx;\n            }\n            if (checker != null && checker.converged(previous, current)) {\n                return best;\n            }\n            previous = current;\n            current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            if (current.getValue() < best.getValue()) {\n                best = current;\n            }\n            if (iter >= getMaxEvaluations()) {\n                throw new MaxEvaluationsExceededException(getMaxEvaluations(),\n                            isMinim);\n            }\n            ++iter;\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}