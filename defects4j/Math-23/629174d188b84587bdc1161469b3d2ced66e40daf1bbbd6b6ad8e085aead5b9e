{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid; // Current best point estimate\n        double v = x;   // Second best point estimate\n        double w = x;   // Previous value of w\n        double d = 0;   // Step size in the last iteration\n        double e = 0;   // Step size before the last iteration (used for Brent's method)\n\n        double fx = computeObjectiveValue(x); // Objective function value at x\n        if (!isMinim) {\n            fx = -fx; // Work with minimization internally\n        }\n        double fv = fx; // Objective function value at v\n        double fw = fx; // Objective function value at w\n\n        // Best point encountered so far (initialized to the initial guess).\n        UnivariatePointValuePair bestPoint = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = bestPoint; // Current point evaluated\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Midpoint of the current interval [a, b]\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion (Brent's condition).\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                // Return the best point found overall\n                return bestPoint;\n            }\n\n            double p = 0; // Numerator of parabolic interpolation step\n            double q = 0; // Denominator of parabolic interpolation step\n            double r = 0; // Temporary variable\n            double u = 0; // Point at which function will be evaluated next\n\n            if (FastMath.abs(e) > tol1) { // Check if a parabolic interpolation step is possible\n                // Fit parabola through (x, fx), (w, fw), (v, fv)\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) { // Ensure q is positive (parabola opens upwards)\n                    p = -p; // Adjust sign of p accordingly\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store previous value of e\n                e = d; // Store previous value of d\n\n                // Check acceptability of parabolic interpolation step\n                if (p > q * (a - x) &&    // Is the interpolated point within the interval (a, b)?\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // Is the step size reasonable?\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1; // Step slightly away from boundary if too close\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step (if parabolic step is not acceptable).\n                    if (x < m) {\n                        e = b - x; // Step towards the larger subinterval\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step (if e is too small for parabolic fit).\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\". Ensures progress.\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u); // Evaluate function at the new point u\n            if (!isMinim) {\n                fu = -fu; // Negate if maximizing\n            }\n\n            // Update previous and current points for convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // Update the overall best point found so far.\n            // The 'best' method compares two points based on their objective value and goal type.\n            bestPoint = best(bestPoint, current, isMinim);\n\n            // User-defined convergence checker.\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // If checker converges, return the overall best point found.\n                    return bestPoint;\n                }\n            }\n\n            // Update a, b, v, w and x based on the function value at u.\n            if (fu <= fx) { // If the new point u is better than or equal to x\n                if (u < x) { // Update interval bounds\n                    b = x;\n                } else {\n                    a = x;\n                }\n                // Update the points for next iteration (shift x, w, v)\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else { // If the new point u is worse than x\n                if (u < x) { // Update interval bounds\n                    a = u;\n                } else {\n                    b = u;\n                }\n                // Update w or v if u is better than them\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n                // Note: x and fx remain the same, as u was not better.\n            }\n            ++iter; // Increment iteration counter\n        } // End while loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}