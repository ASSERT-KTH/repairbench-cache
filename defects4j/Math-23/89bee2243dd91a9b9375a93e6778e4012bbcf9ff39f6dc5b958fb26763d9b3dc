{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n        // Toleraances and constants from base class or constructor\n        final double relativeThreshold = getRelativeAccuracy();\n        final double absoluteThreshold = getAbsoluteAccuracy();\n        // Golden ratio constant (using the fractional part)\n        final double GOLDEN_SECTION = 0.5 * (3.0 - FastMath.sqrt(5.0));\n\n        double a; // Lower bound of the bracket\n        double b; // Upper bound of the bracket\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        // Current point with the best function value found so far (initialized to start value)\n        double x = mid;\n        // Point with the second best function value\n        double v = x;\n        // Point with the third best function value\n        double w = x;\n        // Step size computed in the last step\n        double d = 0;\n        // Step size computed in the step before last\n        double e = 0;\n\n        // Compute function value at the starting point x\n        double fx = computeObjectiveValue(x);\n        // Handle maximization by negating the objective function\n        if (!isMinim) {\n            fx = -fx;\n        }\n        // Initialize function values at v and w\n        double fv = fx;\n        double fw = fx;\n\n        // Keep track of the best point found overall. Initialize with the starting point.\n        // The value stored is the original function value (not negated for maximization).\n        UnivariatePointValuePair bestPointSoFar\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        // Stores the point and value pair for the current iteration candidate u.\n        UnivariatePointValuePair current = bestPointSoFar;\n        // Stores the point and value pair corresponding to x (current best) before evaluating u.\n        UnivariatePointValuePair previous = null;\n\n\n        int iter = 0;\n        while (true) {\n            // Calculate midpoint of the current interval [a, b]\n            final double m = 0.5 * (a + b);\n            // Calculate tolerances for this iteration\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion (Brent's convergence criterion)\n            // Check if the interval size relative to x is small enough\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                // Convergence achieved based on Brent's criterion.\n                // Return the overall best point found during the optimization.\n                return bestPointSoFar;\n            }\n\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0; // Point to be evaluated in this iteration\n\n            // Try parabolic interpolation using points x, v, w\n            if (FastMath.abs(e) > tol1) { // Check if the previous step size 'e' was large enough\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                // Ensure q is positive (parabola opening upwards for minimum)\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store previous step size (d) into r\n                e = d; // Store step size before previous (e) into e\n\n                // Check if the parabolic interpolation step is acceptable\n                if (p > q * (a - x) &&        // Check if minimum is within bounds [a, x] or [x, b]\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // Check step size decrease condition\n                    // Parabolic interpolation step is accepted\n                    d = p / q; // Calculate step size\n                    u = x + d; // Calculate next point u\n\n                    // Check if u is too close to the boundaries a or b\n                    if (u - a < tol2 || b - u < tol2) {\n                        // If too close, set step d to minimum size towards midpoint m\n                        // This d value will be adjusted below if needed.\n                        if (x <= m) { // Use <= consistent with original code\n                             d = tol1;\n                        } else {\n                             d = -tol1;\n                        }\n                    }\n                     // If parabolic step is acceptable and not too close to bounds,\n                     // the calculated d is used, potentially adjusted below.\n                } else {\n                    // Golden section step (parabolic fit not acceptable)\n                    // Set e for golden section based on which side of midpoint x lies\n                    if (x < m) { e = b - x; } else { e = a - x; }\n                    d = GOLDEN_SECTION * e; // Calculate golden section step size\n                }\n            } else {\n                // Golden section step (previous step size e was too small)\n                if (x < m) { e = b - x; } else { e = a - x; }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Ensure the step size d has at least magnitude tol1\n            // Determine the actual point u to be evaluated\n            if (FastMath.abs(d) >= tol1) { // If step d is large enough\n                 u = x + d; // Use the calculated step\n            } else { // If step d is too small\n                 u = x + FastMath.copySign(tol1, d); // Force a minimum step of size tol1\n            }\n\n            // Evaluate the objective function at the new point u\n            double fu = computeObjectiveValue(u);\n            // Handle maximization by negating the value\n            if (!isMinim) {\n                fu = -fu;\n            }\n\n            // Create the UnivariatePointValuePair for the new point u\n            // Store the state before evaluating u as 'previous' (corresponds to x)\n            previous = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            // Store the newly evaluated point u as 'current'\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // Update the overall best point found so far by comparing\n            // the current best ('bestPointSoFar') with the new point ('current').\n            bestPointSoFar = best(bestPointSoFar, current, isMinim);\n\n\n            // Check for convergence using the user-defined checker, if provided.\n            // The checker typically compares the previous state (point x) and current state (point u).\n            if (checker != null) {\n                 if (checker.converged(iter, previous, current)) {\n                     // If checker signals convergence, return the overall best point found.\n                     return bestPointSoFar;\n                 }\n             }\n\n            // Update the points x, v, w and their function values fx, fv, fw\n            // Also update the interval bounds a and b for the next iteration\n            if (fu <= fx) { // Point u is better than or equal to the current best x\n                // Update the interval [a, b] to bracket the new minimum\n                if (u < x) { b = x; } else { a = x; }\n                // Shift the points: v becomes the old w, w becomes the old x, x becomes the new u\n                v = w; fv = fw;\n                w = x; fw = fx;\n                x = u; fx = fu;\n            } else { // Point u is worse than the current best x\n                // Update the interval [a, b] using u as one boundary\n                if (u < x) { a = u; } else { b = u; }\n                // Update v or w only if u is better than them (second or third best)\n                // Also handle cases where points coincide using Precision.equals\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w; fv = fw;\n                    w = u; fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u; fv = fu;\n                }\n                // x and fx remain unchanged as u was not better\n            }\n\n            ++iter; // Increment the iteration counter\n        } // End of while loop\n    }\n\n    /**\n     * Helper method to compare two points and return the best one according to the goal.\n     * Handles null inputs. Uses original (non-negated) function values for comparison.\n     *\n     * @param p1 First point/value pair.\n     * @param p2 Second point/value pair.\n     * @param isMinim True if minimizing, false if maximizing.\n     * @return The better of the two points according to the goal type.\n     */\n    private UnivariatePointValuePair best(UnivariatePointValuePair p1,\n                                          UnivariatePointValuePair p2,\n                                          boolean isMinim) {\n        if (p1 == null) {\n            return p2;\n        }\n        if (p2 == null) {\n            return p1;\n        }\n\n        if (isMinim) {\n            // Return the point with the smaller function value\n            return p1.getValue() < p2.getValue() ? p1 : p2;\n        } else {\n            // Return the point with the larger function value\n            return p1.getValue() > p2.getValue() ? p1 : p2;\n        }\n    }\n\n    // Note: This fixed code assumes the existence of helper methods like:\n    // getGoalType(), getMin(), getStartValue(), getMax(), getConvergenceChecker(),\n    // getRelativeAccuracy(), getAbsoluteAccuracy(), computeObjectiveValue()\n    // and the utility class Precision with the method equals(double, double).\n    // It also assumes the UnivariatePointValuePair class stores the point and value.\n    // The 'best' helper function was added for clarity, assuming similar logic existed or was intended.",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}