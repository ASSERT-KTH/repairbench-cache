{
    "generation": "/** {@inheritDoc} */\n@Override\nprotected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker\n        = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current\n        = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n    // Track the best point seen so far, always in original function value.\n    double bestPoint = x;\n    double bestValue = isMinim ? fx : -fx; // bestValue is always f(x), not -f(x)\n    boolean bestInitialized = true; // initial guess has been evaluated\n\n    int iter = 0;\n    while (true) {\n        final double m = 0.5 * (a + b);\n        final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n        final double tol2 = 2 * tol1;\n\n        // Default stopping criterion.\n        final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n        if (!stop) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\".\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u);\n            double testFu = fu;\n            if (!isMinim) {\n                testFu = -fu;\n            }\n\n            // Track the best point found (in original function value)\n            if (!bestInitialized || testFu < bestValue\n                    || (testFu == bestValue && FastMath.abs(u - bestPoint) < FastMath.ulp(bestPoint))) {\n                bestValue = testFu;\n                bestPoint = u;\n                bestInitialized = true;\n            }\n\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // Instead of returning \"best(current, previous, isMinim)\",\n                    // explicitly return the best point seen so far!\n                    return new UnivariatePointValuePair(bestPoint, bestValue);\n                }\n            }\n\n            // Update a, b, v, w and x.\n            if (testFu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = testFu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (testFu <= fw ||\n                    Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = testFu;\n                } else if (testFu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = testFu;\n                }\n            }\n        } else { // Default termination (Brent's criterion).\n            // Instead of returning best(current, previous, isMinim);\n            // return the overall best point seen so far!\n            return new UnivariatePointValuePair(bestPoint, bestValue);\n        }\n        ++iter;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}