{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        \n        // Compute objective value for initial guess `x`. This is the actual (non-normalized) value.\n        final double fxActual = computeObjectiveValue(x);\n\n        // overallBest will track the best point found so far, storing its actual objective value.\n        UnivariatePointValuePair overallBest = new UnivariatePointValuePair(x, fxActual);\n\n        // fx, fv, fw are internal normalized values used for Brent's algorithm comparisons.\n        // If minimizing, fx = fxActual. If maximizing, fx = -fxActual.\n        double fx = isMinim ? fxActual : -fxActual;\n        double fv = fx; // fv and fw are also normalized\n        double fw = fx;\n\n        double d = 0; // Displacement\n        double e = 0; // Previous displacement\n\n        // previousCheckerPoint and currentCheckerPoint are used for the convergence checker.\n        // They store actual (non-normalized) objective values.\n        UnivariatePointValuePair previousCheckerPoint = null;\n        UnivariatePointValuePair currentCheckerPoint = overallBest; // Initially, the best point is the start value\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    // These calculations use normalized values (fx, fv, fw)\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                // Compute objective value for `u`. This is the actual (non-normalized) value.\n                final double fuActual = computeObjectiveValue(u);\n\n                // User-defined convergence checker.\n                // The checker receives actual values.\n                previousCheckerPoint = currentCheckerPoint;\n                currentCheckerPoint = new UnivariatePointValuePair(u, fuActual);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previousCheckerPoint, currentCheckerPoint)) {\n                        // If checker converges, return the best among overallBest, previousCheckerPoint, and currentCheckerPoint.\n                        // All these objects hold actual objective values.\n                        return best(overallBest, best(previousCheckerPoint, currentCheckerPoint, isMinim));\n                    }\n                }\n\n                // Update overallBest with the new point `u` if it's better.\n                // Comparison uses actual values.\n                if (isMinim) {\n                    if (fuActual < overallBest.getValue()) {\n                        overallBest = currentCheckerPoint; // currentCheckerPoint holds (u, fuActual)\n                    }\n                } else { // Maximization\n                    if (fuActual > overallBest.getValue()) {\n                        overallBest = currentCheckerPoint; // currentCheckerPoint holds (u, fuActual)\n                    }\n                }\n                \n                // fuNormalized is used for internal Brent logic comparisons (e.g., fuNormalized <= fx).\n                final double fuNormalized = isMinim ? fuActual : -fuActual;\n\n                // Update a, b, v, w and x. These updates use the normalized values (fuNormalized, fx, fv, fw).\n                if (fuNormalized <= fx) { // fuNormalized is better than or equal to fx\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fuNormalized;\n                } else { // fuNormalized is worse than fx\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fuNormalized <= fw || // fuNormalized is better than or equal to fw\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fuNormalized;\n                    } else if (fuNormalized <= fv || // fuNormalized is better than or equal to fv\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fuNormalized;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                // When the default termination criterion is met, return the overall best point found.\n                return overallBest;\n            }\n            ++iter;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}