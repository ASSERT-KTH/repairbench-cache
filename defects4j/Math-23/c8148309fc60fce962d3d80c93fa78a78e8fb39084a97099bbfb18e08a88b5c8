{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        // Initialization.\n        double a; // Lower bound of the bracket.\n        double b; // Upper bound of the bracket.\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid; // Current best point estimate.\n        double v = x; // Previous best point.\n        double w = x; // Second previous best point.\n        double d = 0; // Step size.\n        double e = 0; // Distance moved in the step before last.\n        double fx = computeObjectiveValue(x); // Objective function value at x.\n        if (!isMinim) {\n            fx = -fx; // Negate if maximizing.\n        }\n        double fv = fx; // Objective function value at v.\n        double fw = fx; // Objective function value at w.\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Midpoint of the current bracket [a, b].\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion. Check if the interval length or the distance |x - m| is below tolerance.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                // Default termination (Brent's criterion).\n                // Return the best point found so far (x, fx).\n                return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            }\n\n            // Tentative point for the next evaluation.\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0; // Point to be evaluated next.\n\n            if (FastMath.abs(e) > tol1) { // Try parabolic interpolation. If e is large enough.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store the previous value of e.\n                e = d; // Store the step size d from the previous iteration.\n\n                // Check if the parabolic interpolation step is acceptable.\n                if (p > q * (a - x) && // Check if interpolation is within bounds [a,b]\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // Check if step is not too large compared to previous steps\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        // If the proposed point u is too close to boundary, adjust step d for minimum step check later.\n                        if (x <= m) { // If x is closer to a.\n                            d = tol1; // Intend to step towards b\n                        } else { // If x is closer to b.\n                            d = -tol1; // Intend to step towards a\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) { // Point x is in the first half of [a, b].\n                        e = b - x; // Golden section search in [x, b].\n                    } else { // Point x is in the second half of [a, b].\n                        e = a - x; // Golden section search in [a, x].\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else { // e is too small, must use golden section.\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update point u by at least \"tol1\". Ensures progress.\n            // Check calculated step d (parabolic or golden) against minimum tolerance.\n            if (FastMath.abs(d) < tol1) {\n                // If the step d is too small, enforce a minimum step of size tol1.\n                if (d >= 0) { // Use the sign of the original small d to determine direction.\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                // Use the calculated step d. Note: d might have been adjusted to +/- tol1 if parabolic u was near boundary.\n                // If d was adjusted to +/- tol1, |d| is not < tol1, so this branch is taken. u = x + d = x +/- tol1.\n                u = x + d;\n            }\n\n            // Evaluate the objective function at the new point u.\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu; // Negate if maximizing.\n            }\n\n            // Update the points for the convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // User-defined convergence checker.\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // Convergence detected by the checker.\n                    // Return the best point found so far (x, fx).\n                    return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n                }\n            }\n\n            // Update a, b, v, w and x based on the function value at u.\n            if (fu <= fx) { // Found a better point u.\n                if (u < x) { // Update the upper bound b.\n                    b = x;\n                } else { // Update the lower bound a.\n                    a = x;\n                }\n                // Update the history of best points.\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                // Update the current best point.\n                x = u;\n                fx = fu;\n            } else { // The new point u is not better than x.\n                if (u < x) { // Update the lower bound a.\n                    a = u;\n                } else { // Update the upper bound b.\n                    b = u;\n                }\n                // Update the history points v and w if u is better than them.\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n            // Increment iteration counter.\n            ++iter;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}