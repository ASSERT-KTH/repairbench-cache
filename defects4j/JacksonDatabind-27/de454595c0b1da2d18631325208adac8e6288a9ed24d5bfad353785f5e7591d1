{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator == null ? null : creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = (creator != null) ? creator.findCreatorProperty(propName) : null;\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // Important: do NOT pass buffer as last arg, but null,\n                // since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    continue;\n                } else {\n                    // Try to set the parameter and possibly complete the creator\n                    if (buffer != null) {\n                        Object value = _deserializeWithErrorWrapping(p, ctxt, creatorProp);\n                        if (buffer.assignParameter(creatorProp, value)) {\n                            t = p.nextToken();\n                            Object bean;\n                            try {\n                                bean = creator.build(ctxt, buffer);\n                            } catch (Exception e) {\n                                wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                                continue;\n                            }\n                            // Check if the bean is of expected type\n                            if (bean.getClass() != _beanType.getRawClass()) {\n                                // Bail out if not the expected type\n                                throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                            }\n                            // Complete and return the deserialized object\n                            return ext.complete(p, ctxt, bean);\n                        }\n                    }\n                }\n                continue;\n            }\n            // Object Id property?\n            if ((buffer != null) && buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            if (buffer != null) {\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                    continue;\n                }\n            }\n            // external type id (or property that depends on it)?\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n            // Check for ignorable properties\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // Handle \"any property\"\n            if (_anySetter != null) {\n                if (buffer != null) {\n                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                } else {\n                    // If buffer is null, read the value but don't buffer it\n                    p.skipChildren();\n                }\n                continue;\n            }\n        }\n\n        // Hit END_OBJECT; resolve the pieces:\n        try {\n            if (buffer == null) {\n                return ext.complete(p, ctxt, null, null);\n            }\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}