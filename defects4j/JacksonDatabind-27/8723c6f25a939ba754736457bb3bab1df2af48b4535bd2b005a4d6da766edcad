{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = null; // Lazily create TokenBuffer for deferred properties\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // We must handle creator property using ExtTH BEFORE assigning parameter\n                // 29-Mar-2021, tatu: As per [databind#3090], MUST pass buffer for property-based creator\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    continue;\n                }\n                // If not handled by ExtTH, this means it's NOT the type property OR the value property associated with type\n                // OR type id is not yet known. But it is a creator property.\n                if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                    t = p.nextToken(); // consume END_OBJECT or FIELD_NAME\n                    Object bean;\n                    try {\n                        bean = creator.build(ctxt, buffer);\n                    } catch (Exception e) {\n                        // 28-Oct-2016, tatu: As per [databind#1418], need to include property name\n                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                        return null; // never gets here\n                    }\n                    // if so, need to copy all remaining tokens into buffer\n                    // [databind#928]: Handle remaining properties\n                    while (t == JsonToken.FIELD_NAME) {\n                        // Need to copy to a buffer first\n                        if (tokens == null) {\n                            tokens = new TokenBuffer(p, ctxt);\n                        }\n                        // NOTE: originally copied structure skipping name; but `copyCurrentStructure`\n                        // expects to be at FIELD_NAME or START_OBJECT/ARRAY. So need to be careful.\n                        // Let's simply copy the current structure, should be name + value\n                        tokens.copyCurrentStructure(p);\n                        t = p.nextToken();\n                    }\n\n                    // Sync'd from `BeanDeserializer`: [databind#928] check to prevent errors like\n                    // `IllegalStateException: No fallback setter/field defined`\n                    if (bean.getClass() != _beanType.getRawClass()) {\n                        // We simply can't handle this case; trying to deserialize properties\n                        // for a different type leads to problems. Must be an error condition\n                        // for now; may be possible to support in future?\n                        // 17-Feb-2017, tatu: Not sure if this still occurs; if it does, need\n                        //   revisit. But commenting out for now.\n                        // Throw exception? Or try to deserialize? For now, let's assume exception is fine\n                        // 05-Nov-2019, tatu: Reverted back to throwing an exception\n                         return ctxt.reportBadDefinition(_beanType, String.format(\n                                  \"Cannot create polymorphic instances with external type ids (%s -> %s)\",\n                                  _beanType.getRawClass().getName(), bean.getClass().getName()));\n                    }\n\n                    if (tokens != null) { // We have remaining properties\n                        // We hit END_OBJECT in main loop, need trailing END_OBJECT here\n                        tokens.writeEndObject();\n                        JsonParser p2 = tokens.asParser(p);\n                        p2.nextToken(); // START_OBJECT\n                        // Deserializes remaining properties\n                        // Based on `BeanDeserializer.finishBuild()`\n                        // NOTE: DOES NOT CALL ext.complete(bean) anymore\n                        // --- START INLINED finishBuild like logic ---\n                        for (; p2.currentToken() == JsonToken.FIELD_NAME; p2.nextToken()) {\n                            String propName2 = p2.getCurrentName();\n                            // Skip field name:\n                            p2.nextToken();\n                            // creator property? handled during build, ignore here\n                            if (creator.findCreatorProperty(propName2) != null) {\n                                p2.skipChildren();\n                                continue;\n                            }\n                            // regular property? needs setting\n                            SettableBeanProperty prop = _beanProperties.find(propName2);\n                            if (prop != null) { // normal case\n                                try {\n                                    prop.deserializeAndSet(p2, ctxt, bean);\n                                } catch (Exception e) {\n                                    wrapAndThrow(e, bean, propName2, ctxt);\n                                }\n                                continue;\n                            }\n                            // ignorable?\n                            if (_ignorableProps != null && _ignorableProps.contains(propName2)) {\n                                handleIgnoredProperty(p2, ctxt, bean, propName2);\n                                continue;\n                            }\n                            // \"any property\"?\n                            if (_anySetter != null) {\n                                try {\n                                    _anySetter.deserializeAndSet(p2, ctxt, bean, propName2);\n                                } catch (Exception e) {\n                                    wrapAndThrow(e, bean, propName2, ctxt);\n                                }\n                                continue;\n                            }\n                            // otherwise unknown:\n                            handleUnknownProperty(p2, ctxt, bean, propName2);\n                        }\n                        // --- END INLINED finishBuild like logic ---\n                    }\n                    // If no remaining properties, or after processing them, return bean\n                    return bean;\n                 }\n                 // Fall through to continue if assignParameter returned false\n            } else { // Not creator property\n                // Object Id property?\n                if (buffer.readIdProperty(propName)) {\n                    continue;\n                }\n                // regular property? needs buffering\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) {\n                    buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                    continue;\n                }\n                // external type id (or property that depends on it)?\n                // Pass 'null' instead of 'buffer' here, as we are not using creator prop\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    continue;\n                }\n                // ignorable?\n                if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                    handleIgnoredProperty(p, ctxt, handledType(), propName);\n                    continue;\n                }\n                // \"any property\"?\n                // 29-Mar-2021, tatu: Need to buffer using buffer, NOT set directly\n                if (_anySetter != null) {\n                     try {\n                        buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                     } catch (Exception e) {\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                     }\n                     continue; // make sure we don't call handleUnknownProperty\n                }\n                // Unknown property. Buffer?\n                // As per [databind#928], may need to buffer unknown props\n                if (tokens == null) {\n                    tokens = new TokenBuffer(p, ctxt);\n                }\n                tokens.writeFieldName(propName);\n                tokens.copyCurrentStructure(p);\n            }\n        } // END for (; t == JsonToken.FIELD_NAME; ...)\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            // If we get here properties were buffered, finalize using ExternalTypeHandler\n            return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}