{
    "generation": "    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        // 26-Feb-2015, tatu: Need to allow buffering of unknown properties, too,\n        //   for cases where we may need to merge information later.\n        // 16-Aug-2017, tatu: As per [databind#1734], need context for `copyCurrentStructure`\n        TokenBuffer tokens = new TokenBuffer(p, ctxt);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean. Per [databind#939], must check type handler first.\n                //   (prior to buffer.assignParameter())\n                // 03-Jan-2016, tatu: Also, need to distinguish between value-property-that-is-creator-property\n                //   and type-id-property-that-is-creator-property. If it's type-id, value needs\n                //   to be passed; if value-property, null.\n                //   Looks like `handlePropertyValue` does now handle this distinction.\n                 //   (by checking `prop.getMetadata().isTypeId()`)\n\n                // Fix for [databind#928]: check for possible type handler property FIRST\n                // 17-Jan-2018, tatu: Need to pass buffer, not null, per logic in ExternalTypeHandler\n                //   (use of buffer classifying non-bean parameter source)\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    // Handled by type handler, skip buffer assignParameter below\n                    ;\n                } else {\n                    // If not handled by type handler, just assign parameter value:\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            // 24-Mar-2017, tatu: Note: must wrap here since we can't add checked\n                            //   exceptions to signature, and various places won't catch it otherwise\n                             // 15-Jan-2019, tatu: Also, with [databind#2221], need to call `ext.complete()` possibly\n                             //   Note that `p` is now likely pointing to FIELD_NAME for which value has\n                             //   not yet been consumed. Need to check... yes, points to FIELD_NAME or END_OBJECT.\n                             // 06-Mar-2019, tatu: Should NOT call `ext.complete` but let caller do that... How?\n                             //   Need to reconsider this part, but for now, do not call `complete`.\n                             // return ext.complete(p, ctxt, bean);\n                            return wrapInstantiationProblem(e, ctxt);\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        // NOTE: If we hit here, consider merging with 'unwrapped' handling?\n                        while (t == JsonToken.FIELD_NAME) {\n                            // NOTE: do NOT skip name as we need to feed it to buffer\n                            // 16-Aug-2017, tatu: ... and MUST buffer FIELD_NAME first\n                            tokens.writeFieldName(p.getCurrentName());\n                            p.nextToken();\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        // Must ensure END_OBJECT is copied too\n                        if (t != JsonToken.END_OBJECT) {\n                             // 17-Jan-2018, tatu: Need to skip END_OBJECT, too... ? For now, report error\n                             ctxt.reportWrongTokenException(bean, JsonToken.END_OBJECT,\n                                     \"Attempted to create External type instance using property-based workflow from %s\",\n                                     p.currentToken());\n                        }\n                        // We must be pointing to `END_OBJECT`, so append that to buffer\n                        tokens.writeEndObject();\n                        // [databind#1390]: check for type compatibility, possibly handle polymorphic cases\n                        if (bean.getClass() != _beanType.getRawClass()) {\n                             // 19-Jun-2017, tatu: As per [databind#1390], need to attach accumulated tokens for processing\n                             //   (although maybe this is wrong expectation? But for now seems necessary)\n                             // 16-Aug-2017, tatu: Actually, need to process buffered tokens first, THEN complete\n                             //   Ext type handler? Reverse the order perhaps? Need to investigate\n                             // 17-Jan-2018, tatu: Not quite sure what to do but report for now\n                             return ctxt.reportBadDefinition(_beanType, String.format(\n                                     \"Cannot create polymorphic instances with external type ids (%s -> %s)\",\n                                     _beanType, bean.getClass()));\n                        }\n                        // We don't need buffered tokens, just the bean:\n                         // 06-Mar-2019, tatu: ... except we might? Merging required for buffer?\n                         // For now, pass buffer which only has creator parameters, and `tokens` has remaining buffered stuff.\n                         // `ext.complete` needs to be able to handle this mixture...\n                         return ext.complete(p, ctxt, bean, tokens.asParser(p));\n                    }\n                }\n                // Processing of creator property handled (either buffer assignment or ext handler), move to next\n                continue;\n            }\n\n            // Object Id property?\n            if (buffer.readIdProperty(propName)) {\n                continue;\n            }\n            // regular property? needs buffering\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) {\n                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                continue;\n            }\n\n            // external type id (or property that depends on it)?\n            // Important: this MUST be called AFTER creator property checks,\n            // mostly because it must NOT be called for creator properties -- ONLY\n            // for regular bean properties, or name of type id property itself.\n            // 17-Jan-2018, tatu: Pass `null` to indicate it's not a Creator property:\n            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                continue;\n            }\n\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                continue;\n            }\n            // \"any property\"?\n            if (_anySetter != null) {\n                 // TODO: should this be done? Check [databind#939] coverage\n                 try {\n                     buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                 } catch (Exception e) {\n                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                 }\n                 continue; // 02-Feb-2017, tatu: was missing continue\n            }\n\n            // Unknown property? Add to tokens to be processed when actual instance is built\n            // Need to copy name first\n            tokens.writeFieldName(propName);\n            tokens.copyCurrentStructure(p);\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            // We must have collected all creator properties by now, buffer has them\n            // 16-Aug-2017, tatu: As per [databind#1734] need to pass buffered tokens too\n            //    (if any), as they may be needed for merging etc.\n            // 06-Mar-2019, tatu: Since `tokens` may be needed, pass both `buffer` and possibly `tokens`\n            //    to `ext.complete`? Requires new method signature, or perhaps `tokens` passed as parser?\n            //    Actually... seems better to simply pass `buffer` and `creator`, and required `ext.complete`\n            //    to know it MUST use `creator` with `buffer`\n             return ext.complete(p, ctxt, buffer, creator);\n        } catch (Exception e) {\n            wrapInstantiationProblem(e, ctxt);\n            return null; // never gets here\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}