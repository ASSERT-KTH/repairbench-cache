{
    "generation": "/**\n * @param locals A predicate to apply to unknown local values.\n * @return Whether the node is known to be a value that is not a reference\n *     outside the expression scope.\n */\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // For compound assignments (like x += y) the operator\n      // \u201cforces\u201d a local (computed) value.\n      if (isAssignmentOp(value)) {\n        return true;\n      }\n      // For a simple assignment x = something, the aliasing of the left\u2010hand side\n      // matters. (Rather than calling locals.apply(value) on the ASSIGN node we look\n      // at its left child, since that is the actual variable name.)\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n\n    case Token.COMMA:\n      // Only the right side of a comma matters.\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n\n    case Token.AND:\n    case Token.OR:\n      // For && and || both operands force a computed value.\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n          && evaluatesToLocalValue(value.getLastChild(), locals);\n\n    case Token.HOOK:\n      // For the conditional operator, only the two possible result expressions matter.\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n          && evaluatesToLocalValue(value.getLastChild(), locals);\n\n    case Token.INC:\n    case Token.DEC:\n      // For postfix operators, the value of x++ is the old (possibly non-local) value;\n      // for prefix (++x) the new (primitive) number is produced.\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n\n    case Token.THIS:\n      return locals.apply(value);\n\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // We have no extra knowledge of property accesses.\n      return locals.apply(value);\n\n    case Token.CALL:\n      // For a call, several heuristics apply.\n      // (a) If the call is on a property access whose receiver is a NEW expression,\n      //     then the value of the call is tied to the freshly created object.\n      if (value.getFirstChild().getType() == Token.GETPROP) {\n        Node receiver = value.getFirstChild().getFirstChild();\n        if (receiver.getType() == Token.NEW) {\n          return evaluatesToLocalValue(receiver, locals);\n        }\n      }\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n\n    case Token.NEW:\n      // Instead of claiming that any new expression yields a local value,\n      // defer to the supplied predicate. For example, \"new x()\"\n      // will be non-local if x isn\u2019t known to be a local constructor.\n      return locals.apply(value);\n\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals (or function definitions, regexp literals, and object/array literals)\n      // are known to be local.\n      return true;\n\n    case Token.IN:\n      // The IN operator always yields a computed (local) value.\n      return true;\n\n    default:\n      // Other operators. For simple operators or those that always produce a new value,\n      // we optimistically assume they are local.\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}