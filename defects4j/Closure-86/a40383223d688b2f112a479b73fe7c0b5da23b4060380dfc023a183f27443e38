{
    "generation": "  /**\n   * @param locals A predicate to apply to unknown local values.\n   * @return Whether the node is known to be a value that is not a reference\n   *     outside the expression scope.\n   */\n  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // For simple assignment (=):\n        // The variable might be aliased; only known immutables on the right are local.\n        // For compound assignment (+=, -=, etc.), the result is always local (number, string, boolean).\n        if (isAssignmentOp(value) && value.getType() != Token.ASSIGN) {\n          // Assignment ops always yield a primitive and thus local.\n          return true;\n        }\n        // For simple assignment\n        Node rhs = value.getLastChild();\n        return NodeUtil.isImmutableValue(rhs);\n\n      case Token.COMMA:\n        // Only the rightmost expression in a comma matters for locality.\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n\n      case Token.AND:\n      case Token.OR:\n        // Both sides must evaluate to local values.\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n            && evaluatesToLocalValue(value.getLastChild(), locals);\n\n      case Token.HOOK:\n        // Only the 'then' and 'else' branch values matter.\n        // cond ? expr1 : expr2\n        Node ifTrue = value.getFirstChild().getNext();\n        Node ifFalse = value.getLastChild();\n        return evaluatesToLocalValue(ifTrue, locals)\n            && evaluatesToLocalValue(ifFalse, locals);\n\n      case Token.INC:\n      case Token.DEC:\n        // Pre-increment/decrement yields a primitive (local),\n        // post-increment/decrement yields the original value (might be non-local).\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          // Pre-increment/decrement (++x)\n          return true;\n        } else {\n          // Post-increment/decrement (x++)\n          return false;\n        }\n\n      case Token.THIS:\n        // 'this' is only local if explicitly known to be.\n        return locals.apply(value);\n\n      case Token.NAME:\n        // Immutable values (like constants) are local,\n        // ordinary variables may or may not be local.\n        return isImmutableValue(value) || locals.apply(value);\n\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // Object properties are not considered local.\n        return false;\n\n      case Token.CALL:\n        // A call is only local if known to return a local value,\n        // or is a toString method, or is otherwise identified as local.\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n\n      case Token.NEW:\n        // The result of a \"new\" expression is only local if we *know* it is,\n        // but in general, we cannot guarantee that the constructed object is not\n        // aliased. For safety, consider it non-local unless overridden.\n        return false;\n\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Function, RegExp, array, and object literals are local.\n        return true;\n\n      case Token.IN:\n        // The result of 'in' is a boolean and thus local.\n        return true;\n\n      default:\n        // Other ops force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}