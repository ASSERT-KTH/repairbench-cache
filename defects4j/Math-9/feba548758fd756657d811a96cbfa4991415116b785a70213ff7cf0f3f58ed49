{
    "generation": "    /** Get a line with reversed direction.\n     * @return a new instance, with reversed direction\n     */\n    public Line revert() {\n        // The reverted line should share the same points as the original line,\n        // but traversed in the opposite direction.\n        // The Line constructor Line(p1, p2) defines the line direction\n        // as the normalized vector from p1 to p2.\n        // To reverse the direction, we can swap the order of the points used\n        // to define the direction. 'zero' is a point on the line.\n        // 'zero.add(direction)' is another point on the line.\n        // Using these two points in reversed order should yield the reversed direction.\n        // p1' = zero.add(direction)\n        // p2' = zero\n        // The direction vector is calculated as normalize(p2' - p1')\n        // = normalize(zero - (zero + direction)) = normalize(-direction).\n        // This computes the conceptually correct reversed direction, although\n        // floating point inaccuracies in normalization might prevent bitwise\n        // equality with direction.negate(), potentially causing issues with\n        // tests that use strict equality (zero tolerance).\n        // The original implementation used new Line(zero, zero.subtract(direction)),\n        // which calculates normalize((zero - direction) - zero) = normalize(-direction).\n        // Both approaches lead to the same calculation for the direction vector.\n        // Let's use the p1 = zero + direction, p2 = zero variant for clarity\n        // that we are reversing the direction segment.\n        final Line reverted = new Line(zero.add(direction), zero);\n        return reverted;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}