{
    "generation": "    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                // if parsing a fragment, contextElement is the root node we are parsing into; need to use that instead of the stack's <html> node\n                node = contextElement != null ? contextElement : node; // Use contextElement if available for pos=0\n                if (node == null) // Should not happen, but defensively protect against it\n                    return; // In theory, should transition to InBody? But this state is unexpected.\n            }\n\n            // Note: The standard specifies rules based on element types, not just names.\n            // Jsoup's implementation uses node names, which generally works for HTML elements.\n            // We need to handle the case where node might be the Document context element.\n            String name = node.nodeName();\n            // Skips handling for non-element nodes like #document, unless it's the last node (fragment context).\n            if (!node.isElement() && !(last && node instanceof Document)) {\n                continue;\n            }\n\n            // The actual checks based on node name:\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name)) && !last) { // Fix: Correctly check for 'th' and apply '!last' constraint as per HTML standard. Original was equivalent to just \"td\".equals(name).\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"template\".equals(name)) { // Added check for template element as per standard\n                transition(HtmlTreeBuilderState.InTemplate);\n                 break;\n            } else if (\"head\".equals(name) && !last) { // Apply !last constraint as per standard (Jsoup originally missed this but had InBody transition)\n                // Note: Standard says transition to InHead, Jsoup uses InBody. Keep InBody unless tests require InHead.\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n                transition(HtmlTreeBuilderState.InFrameset);\n                break; // frag\n            } else if (\"html\".equals(name)) {\n                // Note: Standard switches between BeforeHead/AfterHead based on head element pointer. Jsoup simplifies.\n                // Keep simplified BeforeHead transition for html context.\n                transition(HtmlTreeBuilderState.BeforeHead); // frag\n                break;\n            } else if (last) { // If we are at the root/context node and no other case matched.\n                transition(HtmlTreeBuilderState.InBody); // Default for fragments or root\n                break; // frag\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}