{
    "generation": "public SortedMap<K, V> prefixMap(final K prefix) {\n    final BitSet bitset = toBitSet(prefix);\n    final PatriciaTrie.Entry<K, V> entry = findAncestor(root, bitset, bitIndex(prefix));\n    if (entry == null) {\n        return Collections.emptySortedMap();\n    }\n\n    final NavigableMap<BitSet, PatriciaTrie.Entry<K, V>> navigableSubMap = this.map.tailMap(bitset, true);\n    final NavigableMap<K, V> result = new TreeMap<>();\n    for (final PatriciaTrie.Entry<K, V> e : navigableSubMap.values()) {\n        if (e.bitset.startsWith(bitset)) {\n            result.put(fromBitSet(e.bitset), e.getValue());\n        } else {\n            break;\n        }\n    }\n\n    return new PrefixSortedMap<>(result, this);\n}\n\nprivate class PrefixSortedMap<K, V> extends ForwardingSortedMap<K, V> {\n    private final PatriciaTrie<K, V> trie;\n\n    public PrefixSortedMap(final NavigableMap<K, V> delegate, final PatriciaTrie<K, V> trie) {\n        super(delegate);\n        this.trie = trie;\n    }\n\n    @Override\n    public void clear() {\n        // Do not clear the underlying trie, just clear the delegate map\n        delegate.clear();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return new PrefixKeySet<>(trie, delegate.keySet());\n    }\n\n    @Override\n    public Collection<V> values() {\n        return new PrefixValues<>(trie, delegate.values());\n    }\n}\n\nprivate class PrefixKeySet<K> extends ForwardingSet<K> {\n    private final PatriciaTrie<K, V> trie;\n\n    public PrefixKeySet(final PatriciaTrie<K, V> trie, final Set<K> delegate) {\n        super(delegate);\n        this.trie = trie;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n}\n\nprivate class PrefixValues<V> extends ForwardingCollection<V> {\n    private final PatriciaTrie<K, V> trie;\n\n    public PrefixValues(final PatriciaTrie<K, V> trie, final Collection<V> delegate) {\n        super(delegate);\n        this.trie = trie;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}