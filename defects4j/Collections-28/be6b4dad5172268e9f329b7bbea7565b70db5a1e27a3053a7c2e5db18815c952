{
    "generation": "public V remove(Object key) {\n    if (key == null) {\n        return null;\n    }\n    K keyK = (K) key;\n    int lengthInBits = lengthInBits(keyK);\n    TrieEntry<K, V> current = root.left;\n    TrieEntry<K, V> path = root;\n    while (true) {\n        if (current.bitIndex <= path.bitIndex) {\n            if (!current.isEmpty() && compareKeys(keyK, current.key)) {\n                return removeEntry(current);\n            }\n            return null;\n        }\n        path = current;\n        current = nextEntryInSubtree(keyK, current.bitIndex, current, lengthInBits);\n        if (current == null) {\n            return null;\n        }\n    }\n}\n\nprivate V removeEntry(TrieEntry<K, V> entry) {\n    TrieEntry<K, V> parent = entry.parent;\n    TrieEntry<K, V> child = null;\n    if (entry.left != entry) {\n        child = entry.left;\n    } else if (entry.right != entry) {\n        child = entry.right;\n    }\n    if (parent != null) {\n        parent.replaceChild(entry, child);\n    } else {\n        root.left = child;\n    }\n    if (child != null) {\n        child.parent = parent;\n    }\n    int bitIndex = entry.bitIndex;\n    if (entry.predecessor != null) {\n        entry.predecessor.predecessor = entry.predecessor.left;\n    }\n    size--;\n    modCount++;\n    V value = entry.getValue();\n    pruneEntry(entry);\n    return value;\n}\n\nprivate void pruneEntry(TrieEntry<K, V> entry) {\n    TrieEntry<K, V> current = entry.parent;\n    while (current != null && current != root && current.isEmpty()) {\n        TrieEntry<K, V> parent = current.parent;\n        if (current.left == current && current.right == current) {\n            if (parent != null) {\n                parent.replaceChild(current, null);\n            } else {\n                root.left = root;\n            }\n            current.parent = null;\n        } else {\n            break;\n        }\n        current = parent;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}