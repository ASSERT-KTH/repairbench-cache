{
    "generation": "public SortedMap<K, V> prefixMap(final K key) {\n    if (key == null) {\n        throw new NullPointerException(\"Null prefix key is not allowed\");\n    }\n\n    final ByteTuple prefix = toByteTuple(key);\n\n    return new TriePrefixMap<>(this, prefix, subTrie(prefix));\n}\n\nprivate static class TriePrefixMap<K, V> extends AbstractSortedMapDecorator<K, V> {\n    private final PatriciaTrie<V> trie;\n    private final ByteTuple prefix;\n    private final PatriciaTrie<V> subTrie;\n\n    public TriePrefixMap(final PatriciaTrie<V> trie, final ByteTuple prefix, final PatriciaTrie<V> subTrie) {\n        super(new TreeMap<>());\n        this.trie = trie;\n        this.prefix = prefix;\n        this.subTrie = subTrie;\n        initialize();\n    }\n\n    private void initialize() {\n        if (subTrie != null) {\n            final Iterator<Map.Entry<ByteTuple, V>> iter = subTrie.entrySet().iterator();\n            while (iter.hasNext()) {\n                final Map.Entry<ByteTuple, V> entry = iter.next();\n                final ByteTuple key = entry.getKey();\n                final V value = entry.getValue();\n                decorated().put(trie.toKey(concatenate(prefix, key)), value);\n            }\n        }\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n        if (subTrie != null) {\n            for (final ByteTuple key : subTrie.keySet()) {\n                trie.remove(concatenate(prefix, key));\n            }\n        }\n    }\n\n    private ByteTuple concatenate(final ByteTuple prefix, final ByteTuple key) {\n        final byte[] result = new byte[prefix.length() + key.length()];\n        System.arraycopy(prefix.getBytes(), 0, result, 0, prefix.length());\n        System.arraycopy(key.getBytes(), 0, result, prefix.length(), key.length());\n        return new ByteTuple(result);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}