{
    "generation": "/**\n * Fixes the structure of the trie after deleting an entry.\n * <p>\n * {@code p} is the parent of the node that was deleted or replaced.\n * {@code c} is the child that replaced the node deleted/replaced.\n * <p>\n * If {@code p} is now an internal node with no value and has only\n * one child {@code c}, then we need to bypass {@code p}.\n * This is done by making {@code p}'s parent point directly to {@code c}.\n * We then recurse up the tree to see if {@code p}'s parent also needs fixing.\n * <p>\n * Crucially, this method must update the {@code parent} pointer of {@code c}\n * when {@code p} is bypassed to ensure that iterators traversing upwards\n * (e.g., using {@code findNext}) do not encounter the removed node {@code p}.\n *\n * @param p the parent of the node that was deleted / replaced\n * @param c the child node that replaced the deleted / replaced node\n */\nprivate void fixUp(TrieEntry<K, V> p, TrieEntry<K, V> c) {\n    // Check if parent P needs removal/adjustment.\n    // This happens if P is internal, has no value, and its bit index\n    // is now redundant because it only has one significant child path (via c).\n    // The condition 'other == p' checks if the other child pointer is a self-reference,\n    // meaning P has effectively only one child path descending from it.\n    if (p != root && p.value == null && p.isInternalNode()) {\n        TrieEntry<K, V> other = (p.left == c) ? p.right : p.left;\n\n        if (other == p) { // p has only one real child path (via c).\n            TrieEntry<K, V> grandparent = p.parent;\n            if (grandparent != null) { // p is not a direct child of root.\n                // Bypass P: link grandparent directly to c.\n                if (grandparent.left == p) {\n                    grandparent.left = c;\n                } else { // grandparent.right == p\n                    grandparent.right = c;\n                }\n\n                // Update c's parent pointer to grandparent.\n                // This is the critical fix for potential NPEs in iterators\n                // that navigate upwards using parent pointers.\n                if (c != p) { // Only update if c is a real node, not a self-reference.\n                    c.parent = grandparent;\n                }\n\n                // Recurse up the tree to fix grandparent as well if needed.\n                // The exact condition for recursion might vary, but the essential part\n                // for fixing the NPE is the parent pointer update above.\n                // We check grandparent properties similar to how we checked 'p'.\n                // A simple recursive call covers necessary cases, though optimizations exist.\n                fixUp(grandparent, c);\n\n            } else { // p was a direct child of the root.\n                // p is being bypassed. c effectively becomes the new child of root,\n                // or potentially the new root if root itself becomes redundant.\n                // Update c's parent to null as it's now directly under root or is the root.\n                if (c != p) { // If c is a real node.\n                    c.parent = null; // c's parent is now root (represented as null).\n                }\n                // The root update itself (e.g., root = c) is typically handled\n                // in the calling method (removeEntry) based on root's state.\n                // fixUp primarily ensures the parent pointers below root are correct.\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}