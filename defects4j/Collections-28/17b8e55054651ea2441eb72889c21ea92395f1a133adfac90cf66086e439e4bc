{
    "generation": "public SortedMap<K, V> prefixMap(final K key) {\n    if (key == null) {\n        return new UnmodifiableSortedMap(Collections.emptySortedMap());\n    }\n\n    // Find the prefix node\n    final TrieEntry<K, V> entry = getEntry(key);\n    if (entry == null) {\n        return new UnmodifiableSortedMap(Collections.emptySortedMap());\n    }\n\n    // If the key actually exists in the trie, return the subtrie starting at the key's node\n    if (entry.isKey()) {\n        final PatriciaTrieNode<K, V> prefixNode = findPrefixNode(key);\n\n        if (prefixNode == null) {\n            return new UnmodifiableSortedMap(Collections.emptySortedMap());\n        }\n\n        // Return a modifiable view of the subtree\n        return new PrefixRangeMap(prefixNode, this);\n    }\n\n    // Handle the case where the key doesn't exist but we want prefixes of it\n    final PatriciaTrieNode<K, V> prefixNode = nearestMatchForNode[key.length()];\n    if (prefixNode == null) {\n        return new UnmodifiableSortedMap(Collections.emptySortedMap());\n    }\n\n    return new PrefixRangeMap(prefixNode, this);\n}\n\nprivate class PrefixRangeMap extends AbstractSortedMap<K, V> {\n    private final PatriciaTrieNode<K, V> prefixNode;\n    private final PatriciaTrie<K, V> trie;\n\n    PrefixRangeMap(PatriciaTrieNode<K, V> prefixNode, PatriciaTrie<K, V> trie) {\n        this.prefixNode = prefixNode;\n        this.trie = trie;\n    }\n\n    @Override\n    public void clear() {\n        // Iterate through all entries in this prefix map and remove them from the main trie\n        for (Map.Entry<K, V> entry : entrySet()) {\n            trie.remove(entry.getKey());\n        }\n    }\n\n    // ... other required methods ...\n\n    @Override\n    public Set<Entry<K, V>> entrySet() {\n        final Set<Entry<K, V>> entries = new HashSet<>();\n        collectEntries(prefixNode, \"\", entries);\n        return entries;\n    }\n\n    private void collectEntries(PatriciaTrieNode<K, V> node, String prefix, Set<Entry<K, V>> entries) {\n        if (node.isKey()) {\n            @SuppressWarnings(\"unchecked\")\n            K key = (K) prefix;\n            entries.add(new AbstractMap.SimpleImmutableEntry<>(key, node.getValue()));\n        }\n\n        for (PatriciaTrieNode<K, V> child : node.children()) {\n            collectEntries(child, prefix + child.getKeyChar(), entries);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}