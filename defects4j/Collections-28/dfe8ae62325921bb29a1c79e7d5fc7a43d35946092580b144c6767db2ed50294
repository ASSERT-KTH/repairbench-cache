{
    "generation": "    /**\n     * Fixes the Trie Structure after remove()\n     *\n     * @param parent The parent of the Entry {@code entry}\n     * @param entry The Entry that has been removed.\n     */\n    private void fixup(TrieEntry<K, V> parent, TrieEntry<K, V> entry) {\n        // This method walks up the tree from the removed node's parent,\n        // cleaning up empty nodes and potentially merging nodes if the\n        // structure allows after the removal.\n\n        // Loop while we are moving upwards (entry's bitIndex is greater than parent's),\n        // the current node ('entry') is internal, empty, and we haven't reached the top.\n        while (parent != null && !entry.isExternalNode() && entry.isEmpty() && entry.bitIndex > parent.bitIndex) {\n\n            // Find the sibling of the current node ('entry').\n            // In a valid Patricia Trie, internal nodes always have two children.\n            final TrieEntry<K, V> sibling = getSibling(parent, entry);\n            // A null sibling would indicate a corrupted trie structure.\n\n            // Case 1: The parent node is also empty (has no key/value).\n            // This means the parent was purely a structural node for branching.\n            // We can potentially remove the parent and merge the sibling upwards.\n            if (parent.isEmpty()) {\n                final TrieEntry<K, V> grandparent = parent.parent;\n\n                if (grandparent != null) {\n                    // If the parent is not the root, update the grandparent's\n                    // child pointer to bypass the parent and point directly to the sibling.\n                    if (grandparent.left == parent) {\n                        grandparent.left = sibling;\n                    } else { // grandparent.right == parent\n                        grandparent.right = sibling;\n                    }\n\n                    // Update the sibling's parent pointer to the grandparent.\n                    // External nodes might use self-references or null for parent, handle carefully.\n                    if (!sibling.isExternalNode()) {\n                       sibling.parent = grandparent;\n                    }\n\n                } else { // The parent was the root node.\n                    // The sibling becomes the new root of the trie.\n                    if (!sibling.isExternalNode()) {\n                       sibling.parent = null; // Root's parent is null.\n                    }\n                    // Update the trie's root reference.\n                    root = sibling;\n                }\n\n                // After merging the sibling up, the loop continues by moving\n                // up the tree. No recursive call needed here as the loop handles iteration.\n                // The logic here was simplified/corrected in COLLECTIONS-584 fix.\n\n            } else { // Case 2: The parent node is not empty (it holds a key/value).\n                // We cannot remove the parent node itself.\n                // Instead, we replace the now-empty 'entry' node with its 'sibling'\n                // as the child of the parent.\n                if (parent.left == entry) {\n                    parent.left = sibling;\n                } else { // parent.right == entry\n                    parent.right = sibling;\n                }\n\n                // Update the sibling's parent pointer to be the original 'parent'.\n                if (!sibling.isExternalNode()) {\n                    sibling.parent = parent;\n                }\n\n                // Check if the sibling node itself might need merging with the parent.\n                // This occurs if the sibling's bit index suggests it should be\n                // structurally merged with the parent (path compression).\n                if (!sibling.isExternalNode()\n                        && sibling.bitIndex <= parent.bitIndex) {\n                    // Recursively call fixup to handle potential merging at the parent level.\n                    // This handles cases where replacing the child might enable further optimization.\n                    fixup(parent, sibling);\n                }\n\n                // Since the parent was not empty, the structural change is localized.\n                // We don't need to continue fixing up further up the tree from here.\n                break; // Exit the while loop.\n            }\n\n            // Move up the tree for the next iteration.\n            // The current 'parent' becomes the 'entry' for the next level up.\n            entry = parent;\n            // The new 'parent' is the grandparent from the current level.\n            parent = parent.parent;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}