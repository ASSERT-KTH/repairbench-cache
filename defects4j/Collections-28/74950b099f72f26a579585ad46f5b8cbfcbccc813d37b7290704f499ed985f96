{
    "generation": "public SortedMap<K, V> prefixMap(String prefix) {\n    return new PrefixMapView(prefix);\n}\n\nprivate class PrefixMapView extends AbstractMap<K, V> implements SortedMap<K, V> {\n    private final String prefix;\n\n    public PrefixMapView(String prefix) {\n        this.prefix = prefix;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return new KeySetView();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return new ValuesView();\n    }\n\n    @Override\n    public Set<Entry<K, V>> entrySet() {\n        return new EntrySetView();\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return null;\n    }\n\n    @Override\n    public K firstKey() {\n        return keySet().isEmpty() ? null : keySet().iterator().next();\n    }\n\n    @Override\n    public K lastKey() {\n        return keySet().isEmpty() ? null : keySet().iterator().next();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(K toKey) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(K fromKey) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public V put(K key, V value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public V remove(Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void putAll(Map<? extends K, ? extends V> m) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public void clear() {\n        for (K key : keySet()) {\n            PatriciaTrie.this.remove(key);\n        }\n    }\n\n    private class KeySetView extends AbstractSet<K> {\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public int size() {\n            return PatriciaTrie.this.countPrefix(prefix);\n        }\n\n        @Override\n        public boolean contains(Object o) {\n            return PatriciaTrie.this.containsKey(o) && ((K) o).toString().startsWith(prefix);\n        }\n\n        @Override\n        public boolean remove(Object o) {\n            if (contains(o)) {\n                PatriciaTrie.this.remove(o);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void clear() {\n            PrefixMapView.this.clear();\n        }\n    }\n\n    private class ValuesView extends AbstractCollection<V> {\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public int size() {\n            return new KeySetView().size();\n        }\n\n        @Override\n        public boolean contains(Object o) {\n            return values().contains(o);\n        }\n\n        @Override\n        public void clear() {\n            PrefixMapView.this.clear();\n        }\n    }\n\n    private class EntrySetView extends AbstractSet<Entry<K, V>> {\n        @Override\n        public Iterator<Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public int size() {\n            return new KeySetView().size();\n        }\n\n        @Override\n        public boolean contains(Object o) {\n            if (o instanceof Entry) {\n                Entry<?, ?> e = (Entry<?, ?>) o;\n                return containsKey(e.getKey()) && PatriciaTrie.this.get(e.getKey()).equals(e.getValue());\n            }\n            return false;\n        }\n\n        @Override\n        public boolean remove(Object o) {\n            if (contains(o)) {\n                PatriciaTrie.this.remove(((Entry<?, ?>) o).getKey());\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public void clear() {\n            PrefixMapView.this.clear();\n        }\n    }\n\n    private class KeyIterator implements Iterator<K> {\n        private final Iterator<Entry<K, V>> entryIterator;\n\n        public KeyIterator() {\n            entryIterator = PatriciaTrie.this.entrySet().iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return entryIterator.hasNext();\n        }\n\n        @Override\n        public K next() {\n            return entryIterator.next().getKey();\n        }\n\n        @Override\n        public void remove() {\n            entryIterator.remove();\n        }\n    }\n\n    private class ValueIterator implements Iterator<V> {\n        private final Iterator<Entry<K, V>> entryIterator;\n\n        public ValueIterator() {\n            entryIterator = PatriciaTrie.this.entrySet().iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return entryIterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return entryIterator.next().getValue();\n        }\n\n        @Override\n        public void remove() {\n            entryIterator.remove();\n        }\n    }\n\n    private class EntryIterator implements Iterator<Entry<K, V>> {\n        private final Iterator<Entry<K, V>> entryIterator;\n\n        public EntryIterator() {\n            entryIterator = PatriciaTrie.this.entrySet().iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return entryIterator.hasNext();\n        }\n\n        @Override\n        public Entry<K, V> next() {\n            Entry<K, V> entry = entryIterator.next();\n            if (entry.getKey().toString().startsWith(prefix)) {\n                return entry;\n            }\n            return next();\n        }\n\n        @Override\n        public void remove() {\n            entryIterator.remove();\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}