{
    "generation": "    /**\n     * Balances the tree after a deletion.\n     *\n     * @param node the node to balance\n     */\n    private void fixAfterDeletion(final TrieEntry<String, V> node) {\n        TrieEntry<String, V> current = node;\n\n        while (current != root && isBlack(current)) {\n            final TrieEntry<String, V> parent = current.parent; // Current is not root, so parent should exist.\n\n            if (current == leftOf(parent)) { // If current is left child\n                TrieEntry<String, V> sibling = rightOf(parent); // Get sibling\n\n                if (isRed(sibling)) { // Case 1: Sibling is red\n                    setBlack(sibling);\n                    setRed(parent);\n                    rotateLeft(parent);\n                    sibling = rightOf(parent); // New sibling after rotation\n                }\n\n                // After Case 1, sibling is black. Proceed to Cases 2, 3, 4.\n                // Note: Null checks for sibling's children are handled by isBlack/isRed helpers.\n                if (isBlack(leftOf(sibling)) && isBlack(rightOf(sibling))) { // Case 2: Sibling's children are both black\n                    setRed(sibling);\n                    current = parent; // Move up the tree\n                } else {\n                    if (isBlack(rightOf(sibling))) { // Case 3: Sibling's right child is black (and left is red)\n                        setBlack(leftOf(sibling));\n                        setRed(sibling);\n                        rotateRight(sibling);\n                        sibling = rightOf(parent); // New sibling\n                    }\n                    // Case 4: Sibling's right child is red (and left can be any color)\n                    // Safely handle colorOf(parent) which might be null for root's parent conceptually\n                    setColor(sibling, colorOf(parent));\n                    setBlack(parent);\n                    setBlack(rightOf(sibling)); // setBlack handles null argument safely\n                    rotateLeft(parent);\n                    current = root; // Finished\n                }\n            } else { // If current is right child\n                TrieEntry<String, V> sibling = leftOf(parent); // Get sibling\n\n                if (isRed(sibling)) { // Case 1: Sibling is red\n                    setBlack(sibling);\n                    setRed(parent);\n                    rotateRight(parent);\n                    sibling = leftOf(parent); // New sibling after rotation\n                }\n\n                // After Case 1, sibling is black. Proceed to Cases 2, 3, 4.\n                if (isBlack(leftOf(sibling)) && isBlack(rightOf(sibling))) { // Case 2: Sibling's children are both black\n                    setRed(sibling);\n                    current = parent; // Move up the tree\n                } else {\n                    if (isBlack(leftOf(sibling))) { // Case 3: Sibling's left child is black (and right is red)\n                        setBlack(rightOf(sibling)); // setBlack handles null argument safely\n                        setRed(sibling);\n                        rotateLeft(sibling);\n                        sibling = leftOf(parent); // New sibling\n                    }\n                    // Case 4: Sibling's left child is red (and right can be any color)\n                    setColor(sibling, colorOf(parent));\n                    setBlack(parent);\n                    setBlack(leftOf(sibling)); // setBlack handles null argument safely\n                    rotateRight(parent);\n                    current = root; // Finished\n                }\n            }\n        }\n\n        setBlack(current); // Ensure the node we possibly terminated on, or the root, is black.\n                           // setBlack handles null argument safely (if current is null somehow, though unlikely here).\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}