{
    "generation": "    /**\n     * Removes a single entry from the Trie.\n     *\n     * If the entry is an internal entry, it will be removed iff\n     * it does not have children. If it does have children, it will\n     * be replaced by an uplink node.\n     *\n     * Note: This method is modeled after the removeEntry logic from Apache Commons Collections 4.x\n     * PatriciaTrie, incorporating the fix for COLLECTIONS-351 which addressed a NullPointerException\n     * during removal, particularly relevant when clearing prefix maps.\n     *\n     * @param entry the entry to remove\n     */\n    private void removeEntry(final TrieEntry<K, V> entry) {\n        TrieEntry<K, V> current = entry.predecessor;\n        TrieEntry<K, V> node = entry; // the node to potentially delete or modify\n\n        // If the entry passed is not the actual node holding the key/value\n        // (e.g., it's an internal structural node whose key matches but isn't stored there),\n        // find the real node associated with the key.\n        // This check ensures 'node' refers to the actual entry to be logically removed.\n        // The condition `current.left == entry || current.right == entry` checks if 'entry'\n        // is a direct child of its predecessor. If not, 'entry' might be an uplink\n        // and we need the actual node.\n        // Original PatriciaTrie logic might differ slightly in how it identifies the 'node'\n        // vs 'entry', but the goal is to operate on the correct node.\n        if (current.left != entry && current.right != entry) {\n            // find the real node to delete.\n            node = getEntry(entry.getKey());\n            // If it wasn't found (should not happen for a valid entry), return.\n            if (node == null) {\n                return;\n            }\n            // Update 'current' to be the predecessor of the actual node.\n            current = node.predecessor;\n        }\n\n\n        // Increment modification count and decrement size for the removal operation.\n        modCount++;\n        size--;\n\n        final TrieEntry<K, V> parent = node.parent;\n\n        // Determine if the node to be removed is the left child of its parent.\n        // This is needed to know which pointer (left or right) in the parent to update.\n        // It will be false if parent is null (i.e., node is the root).\n        final boolean isLeftChild = parent != null && parent.left == node;\n\n        // Case 1: The node to be removed ('node') is an internal node used for\n        // branching, and its bitIndex indicates it's distinguishing between its children\n        // ('current' and another child 'child'). We need to promote 'child'.\n        if (node.isInternalNode() && node.bitIndex > current.bitIndex) {\n            TrieEntry<K, V> child = null; // The child to promote\n            if (node.left == current) { // 'current' is the predecessor/sibling\n                child = node.right; // Promote the right child\n            } else { // node.right == current\n                child = node.left; // Promote the left child\n            }\n\n            // Update the parent's child pointer to point to the promoted child.\n            if (parent != null) {\n                if (isLeftChild) {\n                    parent.left = child;\n                } else {\n                    parent.right = child;\n                }\n            } else {\n                // If parent is null, 'node' was the root. The promoted 'child' becomes the new root.\n                root = child;\n            }\n\n            // Update the promoted child's parent pointer to the original parent.\n            if (child != null) { // Defensive check, child should exist here.\n                child.parent = parent;\n            }\n\n            // Update the predecessor link of the sibling node ('current').\n            // This node ('current') previously had 'node' as its predecessor.\n            // Its new predecessor should be the promoted child ('child').\n            // This is the fix from COLLECTIONS-351: Look up the node 'p' for 'current.key'\n            // again before updating its predecessor, as 'current' might be stale or\n            // direct update could cause issues in complex removal scenarios.\n            // 'current' here must be an external node if 'node' is internal.\n            final TrieEntry<K, V> p = getNearestEntryForKey(current.getKey(), current.bitIndex);\n            if (p != null) { // Check if lookup returned a valid node.\n                p.predecessor = child; // Update the predecessor link.\n            }\n\n        } else {\n            // Case 2: The node to be removed ('node') is an external node (leaf) or an\n            // internal node that structurally acts like one in this removal context\n            // (e.g., a node on a path with only one child below it).\n            // 'current' is the sibling or uplink node that will replace 'node' in the structure.\n            if (parent != null) {\n                if (isLeftChild) {\n                    parent.left = current; // Replace 'node' with 'current'\n                } else {\n                    parent.right = current; // Replace 'node' with 'current'\n                }\n            } else {\n                // If parent is null, 'node' was the root. 'current' becomes the new root.\n                root = current;\n            }\n\n            // Update 'current's predecessor link to point back to the original parent.\n            if (current != null) { // Defensive check, current should exist.\n                current.predecessor = parent;\n            }\n        }\n\n        // Help GC by nulling out fields of the removed node.\n        // A helper method like 'clean()' might exist in the actual class.\n        node.key = null;\n        node.value = null;\n        node.parent = null;\n        node.left = null;\n        node.right = null;\n        node.predecessor = null;\n        node.bitIndex = -1; // Mark as invalid.\n        node.isEmpty = true; // Mark as logically removed/empty.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}