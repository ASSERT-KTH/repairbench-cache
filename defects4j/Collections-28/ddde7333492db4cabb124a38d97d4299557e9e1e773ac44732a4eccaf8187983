{
    "generation": "@Override\npublic SortedMap<K, V> prefixMap(final K prefix) {\n    if (prefix == null) {\n        throw new IllegalArgumentException(\"Prefix cannot be null\");\n    }\n    return new PrefixRangeMap(prefix, length(prefix));\n}\n\nprivate final class PrefixRangeMap extends AbstractSortedMapDecorator<K, V> implements SortedMap<K, V>, Serializable {\n    private static final long serialVersionUID = 1L;\n    private final K prefix;\n    private final int prefixLength;\n\n    PrefixRangeMap(final K prefix, int prefixLength) {\n        super(new PatriciaTrie<>());\n        this.prefix = prefix;\n        this.prefixLength = prefixLength;\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return PatriciaTrie.this.containsKey(key) &&\n               length((K) key) >= prefixLength &&\n               startsWith((K) key, prefix);\n    }\n\n    @Override\n    public V get(Object key) {\n        if (containsKey(key)) {\n            return PatriciaTrie.this.get(key);\n        }\n        return null;\n    }\n\n    @Override\n    public V put(K key, V value) {\n        if (containsKey(key)) {\n            return PatriciaTrie.this.put(key, value);\n        }\n        return null;\n    }\n\n    @Override\n    public void clear() {\n        // Create a copy of keys to avoid ConcurrentModificationException\n        Set<K> keysToRemove = new HashSet<>();\n        for (K key : keySet()) {\n            keysToRemove.add(key);\n        }\n        for (K key : keysToRemove) {\n            PatriciaTrie.this.remove(key);\n        }\n    }\n\n    // ... other overridden methods (headMap, tailMap, entrySet, etc.)\n    // ... implementation of startsWith and length methods\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}