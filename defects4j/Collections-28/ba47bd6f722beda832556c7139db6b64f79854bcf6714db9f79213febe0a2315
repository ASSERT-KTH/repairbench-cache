{
    "generation": "private class PrefixRangeMap extends AbstractBoundedMap {\n    private final String prefix;\n    \n    private PrefixRangeMap(final String prefix) {\n        super(prefixEnd(prefix), false);\n        this.prefix = prefix;\n    }\n    \n    @Override\n    public boolean containsKey(final Object key) {\n        if (key == null) {\n            return false;\n        }\n        if (!(key instanceof String)) {\n            return false;\n        }\n        final String s = (String) key;\n        return s.startsWith(prefix) && PatriciaTrie.this.containsKey(key);\n    }\n    \n    @Override\n    protected Set<Entry<K, V>> createEntrySet() {\n        return new PrefixRangeEntrySet();\n    }\n    \n    @Override\n    public K firstKey() {\n        return createTrieSet().first();\n    }\n    \n    @Override\n    protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                             final K toKey, final boolean toInclusive) {\n        return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n    }\n    \n    private class PrefixRangeEntrySet extends AbstractRangeEntrySet {\n        @Override\n        public Iterator<Entry<K, V>> iterator() {\n            return new PrefixRangeEntryIterator();\n        }\n        \n        @Override\n        public int size() {\n            int size = 0;\n            for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                size++;\n            }\n            return size;\n        }\n        \n        @Override\n        public void clear() {\n            final Iterator<Entry<K, V>> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n    }\n    \n    private class PrefixRangeEntryIterator extends AbstractRangeIterator {\n        @Override\n        protected void setNext() {\n            if (next.getKey() == null || !((String) next.getKey()).startsWith(prefix)) {\n                next = null;\n                return;\n            }\n            next = findNext(next);\n        }\n        \n        @Override\n        protected Entry<K, V> findNext(final Entry<K, V> prior) {\n            if (prior == null) {\n                throw new IllegalArgumentException();\n            }\n            return getNextEntry(prior.getKey());\n        }\n        \n        @Override\n        protected Entry<K, V> findFirst() {\n            final Entry<K, V> entry = getMatchingEntry(prefix);\n            if (entry != null && ((String) entry.getKey()).startsWith(prefix)) {\n                return entry;\n            }\n            return getNextEntry(prefix);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}