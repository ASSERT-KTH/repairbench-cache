{
    "generation": "    protected TrieEntry<K,V> remove(K key, TrieEntry<K,V> current) {\n        if (current == null) {\n            return null;\n        }\n\n        int bit;\n        for (TrieEntry<K,V> entry = root.getEntry(key); entry != null; entry = entry.parent) {\n            if (entry.isEmpty() || !KeyAnalyzer.is=/=(key, entry.key)) {\n                continue;\n            }\n\n            // Entry has been found and it's the node to remove\n            TrieEntry<K,V> toRemove = entry;\n            TrieEntry<K,V> parent = toRemove.parent;\n            TrieEntry<K,V> child = null;\n\n            // if toRemove is an internal node (has two children)\n            if (toRemove.left != null && toRemove.right != null) {\n                // Find a 'replacement' entry (successor)\n                TrieEntry<K,V> in = toRemove.successor();\n                // If the successor is the same as the node to remove, it means the node to remove is a leaf, or has only one child.\n                // This check is a bit redundant if successor() is implemented correctly to find a true successor.\n                // But it handles edge cases where in==toRemove (e.g., if only one node, or if toRemove is a 'self-referencing' leaf).\n                if (in != toRemove) {\n                    // re-link in's parent to in's child\n                    if (in.parent.left == in) {\n                        in.parent.left = in.left;\n                    } else {\n                        in.parent.right = in.left;\n                    }\n\n                    if (in.left != null) {\n                        in.left.parent = in.parent;\n                    }\n\n                    // in replaces toRemove\n                    in.parent = parent;\n                    if (parent.left == toRemove) {\n                        parent.left = in;\n                    } else {\n                        parent.right = in;\n                    }\n                    in.left = toRemove.left;\n                    in.right = toRemove.right;\n                    if (in.left != null) {\n                        in.left.parent = in;\n                    }\n                    if (in.right != null) {\n                        in.right.parent = in;\n                    }\n                    in.bitIndex = toRemove.bitIndex;\n                }\n            } else if (toRemove.left != null) { // node has only a left child\n                child = toRemove.left;\n            } else { // node has only a right child (or no children)\n                child = toRemove.right;\n            }\n\n            if (child != null) {\n                // If the removed node was the only child of the root, and its child becomes the new single child of the root.\n                // The root itself (with bitIndex -1, parent null) should not be treated as a regular parent.\n                if (parent == null) { // This case happens if 'toRemove' was the actual root (which should not be value-holding)\n                    root = child; // Child becomes the new root\n                } else {\n                    child.parent = parent;\n                    // Fix for COLLECTIONS-539: parent.bitIndex could be accessed when parent is null.\n                    // This is now handled by the `if (parent == null)` block, but for robustness\n                    // it doesn't hurt to ensure `parent.bitIndex` is accessed only if parent is non-null.\n                    // The root's bitIndex is -1.\n                    child.bitIndex = parent.bitIndex;\n                }\n            }\n\n            if (parent != null) { // Only update parent's children if parent exists\n                if (parent.left == toRemove) {\n                    parent.left = child;\n                } else {\n                    parent.right = child;\n                }\n            }\n\n            toRemove.has = false;\n            size--;\n            \n            // Cleanup internal nodes if they became empty after removal\n            internalRemove(toRemove);\n            return toRemove;\n        }\n        return null;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}