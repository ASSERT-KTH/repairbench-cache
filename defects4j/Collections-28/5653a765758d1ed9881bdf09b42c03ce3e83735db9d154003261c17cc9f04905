{
    "generation": "protected TrieEntry<K, V> removeEntry(TrieEntry<K, V> entry) {\n    if (entry == null) {\n        return null;\n    }\n\n    // Special case: removing the root entry\n    if (entry == root) {\n        // If the root is also a leaf node (both children are self-loops),\n        // it means the trie becomes empty after removal.\n        if (entry.left == entry && entry.right == entry) {\n            root = null; // Set root to null to make the trie empty.\n        } else {\n            // If the root has actual children (not self-loops),\n            // it cannot be physically removed as it's vital for the trie structure.\n            // Only its value is cleared.\n            entry.value = null;\n        }\n        // The trie's size and modification count are adjusted in the public remove(K key) method.\n        return entry;\n    }\n\n    // Case: 'entry' is not a leaf node (it has at least one child that is not a self-loop).\n    // In this scenario, the node itself cannot be physically removed because it's part of\n    // paths leading to other keys. Only its value can be cleared.\n    if (entry.left != entry || entry.right != entry) {\n        entry.value = null;\n        // The trie's size and modification count are adjusted in the public remove(K key) method.\n        return entry;\n    }\n\n    // Case: 'entry' is a leaf node (both its children are self-loops) and it's not the root.\n    // This node can be physically removed from the trie.\n    TrieEntry<K, V> parent = entry.parent;\n\n    // Disconnect 'entry' from its 'parent' by making 'parent' point to itself\n    // on the side where 'entry' was, effectively collapsing that branch.\n    if (parent.left == entry) {\n        parent.left = parent;\n    } else { // parent.right == entry\n        parent.right = parent;\n    }\n\n    // Now, we need to propagate this \"self-loop\" upwards.\n    // 'branch' represents the part of the trie that has been 'collapsed' (became a self-loop).\n    // 'current' is the node we are currently examining, an ancestor of 'branch'.\n    TrieEntry<K, V> branch = entry;\n    TrieEntry<K, V> current = parent;\n\n    // Loop upwards towards the root, consolidating branches that now become 'leaves'.\n    // A NullPointerException often occurs here if 'current' becomes null but is still dereferenced.\n    while (current != null && (current.left == branch || current.right == branch)) {\n        // 'current' has 'branch' as one of its children, which is now a self-loop.\n        // Therefore, 'current' itself also becomes a self-loop on that side.\n        if (current.left == branch) {\n            current.left = current;\n        } else { // current.right == branch\n            current.right = current;\n        }\n\n        // After 'current's pointers are adjusted, its min/max references might need updating.\n        // This is crucial for correctness, especially for prefixMap operations.\n        // This call to fixupMinMax should be robust and handle self-loops correctly.\n        fixupMinMax(current);\n\n        // Move 'branch' up to 'current', and 'current' up to its parent.\n        branch = current;\n        current = current.parent;\n    }\n\n    // After the loop, 'current' is either null (meaning we propagated all the way up to/past the root)\n    // or it's the first ancestor that was NOT affected by the collapse (i.e., it had another active branch).\n    // In the latter case, 'current's min/max pointers might need one final adjustment.\n    if (current != null) {\n        fixupMinMax(current);\n    }\n    \n    // The trie's size and modification count are adjusted in the public remove(K key) method.\n    return entry;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}