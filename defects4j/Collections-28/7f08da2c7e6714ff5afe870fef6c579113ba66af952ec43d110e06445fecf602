{
    "generation": "protected void deleteNode(final Node<V> node) {\n    // Determine the parent and potential grandparent of the node being deleted\n    Node<V> parent = node.getParent();\n    Node<V> grandParent = null; // Will be determined later if needed\n    Node<V> child = null; // The node that will replace 'node' structurally, or the 'parent' if node is a leaf.\n\n    // Case 1: 'node' has no open links (it's a leaf node where both 'left' and 'right' links are either 'null' or point back to 'node' itself).\n    // This node needs to be completely removed from the trie structure.\n    if ((node.getLeft() == node || node.getLeft() == null) && (node.getRight() == node || node.getRight() == null)) {\n        if (node == this.root) { // If the root node is being deleted and it's a leaf\n            this.root = null; // Trie becomes empty\n            return;\n        }\n        // If node is a child of 'parent', update parent's link to point back to itself (closed link)\n        if (parent.getLeft() == node) {\n            parent.setLeft(parent);\n        } else { // node.getParent().getRight() == node\n            parent.setRight(parent);\n        }\n        child = parent; // The 'parent' becomes the 'child' for the collapse logic, meaning 'parent' is now potentially collapsable.\n    }\n    // Case 2: 'node' has exactly one open link.\n    // This 'node' will be replaced by its single open child.\n    else {\n        // Determine the single open child (the one that is not null and not a self-loop)\n        if (node.getLeft() == node || node.getLeft() == null) { // Left is closed/null, right must be open\n            child = node.getRight();\n        } else { // Right is closed/null, left must be open\n            child = node.getLeft();\n        }\n\n        if (node == this.root) { // If the root node is being deleted and it has one open child\n            this.root = child;\n            if (this.root != null) { // The new root (child) must have a null parent.\n                this.root.setParent(null);\n            }\n            return; // Root handled.\n        }\n\n        // Re-parent 'child' to 'parent'\n        if (parent.getLeft() == node) {\n            parent.setLeft(child);\n        } else { // parent.getRight() == node\n            parent.setRight(child);\n        }\n        // FIX: Ensure 'child' is not null before setting its parent.\n        // 'child' can be null here if, for example, node.getLeft() was null and node.getRight() was also null,\n        // and the first 'if' block (for no open links) was not perfectly exhaustive for all types of leaves.\n        if (child != null) {\n            child.setParent(parent);\n        }\n    }\n\n    // Collapse loop: Traverse up the tree from the 'parent' (or the 'child' in Case 1),\n    // collapsing nodes whose bitIndex is \"bad\" (greater than or equal to their child's bitIndex).\n    Node<V> current = child; // 'current' is the node that's being potentially moved up\n    Node<V> currentParent = (child == parent) ? parent.getParent() : parent; // 'currentParent' is the parent of 'current'\n\n    while (currentParent != null && currentParent.getBitIndex() >= current.getBitIndex()) {\n        grandParent = currentParent.getParent();\n\n        if (grandParent == null) { // 'currentParent' was the root\n            this.root = current;\n            if (this.root != null) { // New root must have a null parent.\n                this.root.setParent(null);\n            }\n            return;\n        }\n\n        // Relink 'grandParent' to 'current'\n        if (grandParent.getLeft() == currentParent) {\n            grandParent.setLeft(current);\n        } else { // grandParent.getRight() == currentParent\n            grandParent.setRight(current);\n        }\n\n        // FIX: Ensure 'current' is not null before setting its parent.\n        // 'current' could potentially be null if the trie becomes empty after this collapse step.\n        if (current != null) {\n            current.setParent(grandParent);\n        }\n\n        // Move up the tree for the next iteration of collapse\n        current = currentParent;\n        currentParent = grandParent;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}