{
    "generation": "    public SortedMap<K, V> prefixMap(K key) {\n        return new PrefixRangeMap<>(this, key);\n    }\n\n    private static class PrefixRangeMap<K, V> extends AbstractSortedMap<K, V> {\n        private final SortedMap<K, V> parent;\n        private final K prefix;\n\n        PrefixRangeMap(SortedMap<K, V> parent, K prefix) {\n            this.parent = parent;\n            this.prefix = prefix;\n        }\n\n        @Override\n        public int size() {\n            int count = 0;\n            for (K key : parent.keySet()) {\n                if (startsWith(key.toString(), prefix.toString())) {\n                    count++;\n                }\n            }\n            return count;\n        }\n\n        @Override\n        public boolean containsKey(Object key) {\n            if (!startsWith(key.toString(), prefix.toString())) {\n                return false;\n            }\n            return parent.containsKey(key);\n        }\n\n        @Override\n        public V get(Object key) {\n            if (!startsWith(key.toString(), prefix.toString())) {\n                return null;\n            }\n            return parent.get(key);\n        }\n\n        @Override\n        public V remove(Object key) {\n            if (!startsWith(key.toString(), prefix.toString())) {\n                return null;\n            }\n            return parent.remove(key);\n        }\n\n        @Override\n        public void clear() {\n            // This is the critical fix - we need to iterate through keys to find matching ones\n            List<K> keysToRemove = new ArrayList<>();\n            for (K key : parent.keySet()) {\n                if (startsWith(key.toString(), prefix.toString())) {\n                    keysToRemove.add(key);\n                }\n            }\n            for (K key : keysToRemove) {\n                parent.remove(key);\n            }\n        }\n\n        // Other required abstract methods would be implemented here...\n\n        private boolean startsWith(String str, String prefix) {\n            return str.startsWith(prefix);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}