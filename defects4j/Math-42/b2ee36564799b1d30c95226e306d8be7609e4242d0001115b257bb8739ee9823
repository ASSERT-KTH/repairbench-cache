{
    "generation": "/**\n * Get the current solution.\n *\n * @return current solution\n */\nprotected RealPointValuePair getSolution() {\n    // compute the shift coming from the \"negative\u2010part\" column (if any)\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n    Integer negativeVarBasicRow =\n        (negativeVarColumn >= 0) ? getBasicRow(negativeVarColumn) : null;\n    double mostNegative =\n        (negativeVarBasicRow == null) ? 0.0\n                                      : getEntry(negativeVarBasicRow, getRhsOffset());\n\n    // extract the original decision variable values\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\n    for (int i = 0; i < coefficients.length; i++) {\n        int colIndex = columnLabels.indexOf(\"x\" + i);\n        if (colIndex < 0) {\n            // variable not in the tableau \u21d2 value is zero\n            coefficients[i] = 0.0;\n        } else {\n            Integer basicRow = getBasicRow(colIndex);\n            // if basicRow==null \u21d2 non-basic \u21d2 zero; otherwise take RHS\n            double value = (basicRow == null)\n                         ? 0.0\n                         : getEntry(basicRow, getRhsOffset());\n            // if variables are allowed to go negative, apply the shift\n            if (!restrictToNonNegative) {\n                value -= mostNegative;\n            }\n            coefficients[i] = value;\n        }\n    }\n\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}