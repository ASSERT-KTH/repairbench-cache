{
    "generation": "    /**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      // mostNegative is the value of the \"negative variable\" if it's basic, otherwise 0.\n      // This is used for unconstrained variables, where x = x_pos - x_neg.\n      // If restrictToNonNegative is true, this component should not be subtracted from variables.\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0; // Variable x_i not found, treat as 0\n            continue;\n          }\n          \n          Integer basicRow = getBasicRow(colIndex);\n          \n          // If the variable is non-basic (basicRow is null) OR its basic row\n          // is already assigned to another original variable (basicRows.contains(basicRow)),\n          // then its value is 0.\n          // For unconstrained variables (x = x_pos - x_neg), if x is 0,\n          // then x_pos = x_neg, so x = 0. The 'mostNegative' component does not apply here.\n          if (basicRow == null || basicRows.contains(basicRow)) {\n              coefficients[i] = 0;\n          } else {\n              basicRows.add(basicRow);\n              // Get the value of the basic variable from the RHS.\n              double basicValue = getEntry(basicRow, getRhsOffset());\n              \n              // Apply the adjustment for unconstrained variables (x = x_pos - x_neg).\n              // This adjustment is only needed if variables are NOT restricted to non-negative.\n              if (restrictToNonNegative) {\n                  coefficients[i] = basicValue;\n              } else {\n                  coefficients[i] = basicValue - mostNegative;\n              }\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}