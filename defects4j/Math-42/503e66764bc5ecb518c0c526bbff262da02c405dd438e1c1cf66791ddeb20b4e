{
    "generation": "/**\n * Get the current solution.\n *\n * @return current solution\n */\nprotected RealPointValuePair getSolution() {\n    // find if there was a \"negative variable\" column (for unrestricted variables)\n    int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n    Integer negativeVarBasicRow = (negativeVarColumn >= 0) ?\n                                  getBasicRow(negativeVarColumn) : null;\n    // how much we have to shift back if variables were allowed negative\n    double mostNegative = (negativeVarBasicRow == null) ? \n                          0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n    // build solution over the original decision variables\n    double[] coefficients = new double[getOriginalNumDecisionVariables()];\n    for (int i = 0; i < coefficients.length; i++) {\n        // find the tableau column for x_i\n        int colIndex = columnLabels.indexOf(\"x\" + i);\n        if (colIndex < 0) {\n            // variable never appeared in the tableau => zero\n            coefficients[i] = 0;\n            continue;\n        }\n        // if it is basic, take its RHS, otherwise it is zero\n        Integer basicRow = getBasicRow(colIndex);\n        double value = (basicRow == null) ? 0\n                                          : getEntry(basicRow, getRhsOffset());\n        // if we introduced a global shift for unrestricted vars, undo it\n        if (!restrictToNonNegative) {\n            value -= mostNegative;\n        }\n        coefficients[i] = value;\n    }\n\n    return new RealPointValuePair(coefficients, f.getValue(coefficients));\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}