{
    "generation": "    /**\n     * Get the current solution.\n     *\n     * @return current solution\n     */\n    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n\n          // A variable's value is determined if it is a basic variable in a constraint row.\n          // Cases where the coefficient should be 0 (adjusted by mostNegative for unconstrained problems):\n          // 1. basicRow is null: The variable is non-basic. Its value is 0.\n          // 2. basicRow is 0: The variable is basic in the objective function row. This variable does not directly\n          //    determine a component of the solution vector. Its value should be 0.\n          // 3. basicRows.contains(basicRow): The basic row for this variable has already been assigned to another\n          //    variable. This indicates degeneracy, and typically, one of the variables is chosen to be non-zero\n          //    and the others are set to 0.\n          if (basicRow == null || basicRow == 0 || basicRows.contains(basicRow)) {\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              // This is the case where the variable is basic in a unique constraint row.\n              // Its value is the RHS of that row.\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  getEntry(basicRow, getRhsOffset()) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}