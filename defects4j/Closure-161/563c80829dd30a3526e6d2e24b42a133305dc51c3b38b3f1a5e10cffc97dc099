{
    "generation": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target, increment/decrement\n    // operand, or DELPROP operand, the array literal is acting as a temporary\n    // or the expression is simply not foldable.\n    // e.g., \"[][0] += 1\", \"delete [][0]\", \"[][0] = 1\"\n    if (NodeUtil.isLValue(n) || parent.isDelProp()) {\n        return n;\n    }\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    // Check for invalid index types (non-integer)\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    // Check for negative indices\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node elem = left.getFirstChild();\n    // Find the element by walking the children list\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    // If index is out of bounds for the literal array\n    if (elem == null) {\n      // We can't fold this, but it's not necessarily an error.\n      // The array might be typed differently, or the access might be part\n      // of an expression that is valid in some contexts (like assignment\n      // in non-strict mode, though we handle L-values above).\n      // Avoid reporting an error here and simply don't fold.\n      // Let later passes (like type checking) handle potential issues.\n      return n;\n    }\n\n    Node replacementNode;\n    // Handle sparse array elements (resulting in undefined)\n    // e.g. [,,1][1] -> undefined\n    if (elem.isEmpty()) {\n      replacementNode = NodeUtil.newUndefinedNode(elem);\n    } else {\n      // Clone the element to avoid modifying the original array literal,\n      // which might be reused elsewhere.\n      replacementNode = elem.cloneNode();\n    }\n\n    // Replace the entire GETELEM with the value\n    n.replaceWith(replacementNode);\n    reportCodeChange();\n    return replacementNode;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}