{
    "generation": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\" or \"[][0] = 1\"\n    // The assignment target shouldn't be folded.\n    if (parent != null && NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\n      return n;\n    }\n\n    if (right.getType() != Token.NUMBER) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    // Check for non-integer indices, or indices that cannot be accurately\n    // represented as integers.\n    if (intIndex != index || index < 0) {\n      // We can't fold non-integer indices or negative indices.\n      // While JavaScript would coerce these, this optimization doesn't attempt\n      // to replicate that behavior. A negative index is always an error.\n      // A non-integer index might be technically valid in JS for custom objects\n      // behaving like arrays, but for array literals, it doesn't make sense to fold.\n      // Let's report the negative index error, but simply bail on non-integer indices.\n      if (index < 0) {\n          error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      }\n      // Bailing out for non-integer indices without error is safer.\n      return n;\n    }\n\n    // Ensure the index is within the valid range for an integer. Although negative\n    // indices are checked above, very large positive indices might exceed\n    // Integer.MAX_VALUE after casting, potentially wrapping around to negative.\n    // However, the loop condition `i < intIndex` handles large positive values implicitly.\n    // We primarily need to handle negative indices which are explicitly checked.\n\n    Node elem = left.getFirstChild();\n    // Search for the intIndex-th element.\n    for (int i = 0; elem != null && i < intIndex; i++) {\n      elem = elem.getNext();\n    }\n\n    if (elem == null) {\n      // Index is out of bounds\n      // We report the error here because this access is not the target\n      // of an assignment (checked earlier), so evaluating it would indeed\n      // result in 'undefined' or potentially an error in stricter contexts,\n      // but folding to 'undefined' requires care.\n      // For constant folding, reporting the out-of-bounds condition is appropriate.\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n; // Do not fold if index is out of bounds.\n    }\n\n    // Handle holes in the array ([ ,, 2 ][1]). Fold to void 0.\n    Node replacementNode;\n    if (elem.isEmpty()) { // Check specifically for EMPTY node (array hole)\n      replacementNode = NodeUtil.newUndefinedNode(elem);\n    } else {\n      // Clone the element node to avoid issues if it's used elsewhere,\n      // though typically elements of a literal array are unique nodes.\n      // Detach the original element from the ARRAYLIT parent.\n      left.removeChild(elem);\n      replacementNode = elem;\n    }\n\n    // Replace the entire GETELEM expression with the fetched element's value.\n    n.replaceWith(replacementNode);\n    reportCodeChange();\n    return replacementNode;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}