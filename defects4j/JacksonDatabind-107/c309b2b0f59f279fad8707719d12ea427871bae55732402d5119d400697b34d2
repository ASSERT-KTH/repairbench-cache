{
    "generation": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // First, try to find a default implementation deserializer\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // If that fails, try to handle unknown type ID\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) {\n                        // If all else fails, use the default deserializer to prevent NPE\n                        deser = _findDefaultImplDeserializer(ctxt);\n                    } else {\n                        deser = ctxt.findContextualValueDeserializer(actual, _property);\n                    }\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    if (!type.hasGenericTypes()) {\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                    }\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            // Ensure that we do not store or return a null deserializer\n            if (deser == null) {\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    throw new JsonMappingException(ctxt, \"No deserializer found for type ID '\" + typeId + \"'\");\n                }\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}