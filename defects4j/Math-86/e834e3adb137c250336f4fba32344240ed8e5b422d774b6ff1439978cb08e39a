{
    "generation": "    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData(); // Modifies the input matrix data array directly\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix for symmetry\n        for (int i = 0; i < order; ++i) {\n            final double[] lI = lTData[i];\n            // Removed premature positivity check from here\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j]; // Upper triangle element A[i][j]\n                final double lJI = lJ[i]; // Lower triangle element A[j][i]\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                // Removed unnecessary modification: lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix using Cholesky decomposition (L^T * L variant, storing L^T in upper triangle)\n        // This implements the outer product / bordering method in place.\n        for (int i = 0; i < order; ++i) { // Process row/column i\n\n            final double[] ltI = lTData[i]; // Row i of the matrix being transformed\n\n            // Calculate the value for the diagonal element L^T[i,i]^2\n            // The value ltI[i] at this point should contain A[i,i] - sum_{k=0}^{i-1} (L^T[k,i])^2\n            // due to the update step performed in previous iterations (k < i).\n            final double d = ltI[i];\n\n            // Check diagonal element for positivity *before* taking the square root\n            if (d < absolutePositivityThreshold) {\n                // The matrix is not positive definite because a pivot element is too small\n                throw new NotPositiveDefiniteMatrixException();\n            }\n\n            ltI[i] = Math.sqrt(d); // Calculate L^T[i,i]\n            final double inverse = 1.0 / ltI[i]; // Cache 1.0 / L^T[i,i]\n\n            // Calculate the remaining elements of row i in L^T: L^T[i,k] for k > i\n            for (int k = i + 1; k < order; ++k) {\n                // ltI[k] contains A_updated[i,k] = A_orig[i,k] - sum_{l=0}^{i-1} L^T[l,i] * L^T[l,k]\n                ltI[k] *= inverse; // Compute L^T[i,k] = A_updated[i,k] / L^T[i,i]\n            }\n\n            // Update the lower right submatrix A[j,k] -= L^T[i,j] * L^T[i,k] for j > i, k >= j\n            // This prepares the matrix elements for the next iteration (i+1) by subtracting the outer product\n            // of the i-th column of L^T (which corresponds to the i-th row ltI of the matrix L^T).\n            for (int j = i + 1; j < order; ++j) {\n                final double LiJ = ltI[j]; // L^T[i,j], computed in the loop above\n                final double[] ltJ = lTData[j]; // Row j\n                // Update only the upper triangle elements A[j,k] where k >= j\n                for (int k = j; k < order; ++k) {\n                    // Subtract the outer product term: L^T[i,j] * L^T[i,k]\n                    ltJ[k] -= LiJ * ltI[k]; // ltI[k] is L^T[i,k], computed above\n                }\n            }\n        } // End of outer loop 'i'\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}