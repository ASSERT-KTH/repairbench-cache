{
    "generation": "    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        // The lTData (L Transpose Data) matrix is filled in-place from the input matrix data.\n        // It will eventually store the upper triangular Cholesky factor.\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix for symmetry (and effectively zero out lower triangle for L^T)\n        for (int i = 0; i < order; ++i) {\n            final double[] lI = lTData[i]; // row i of the current matrix state\n\n            // Check off-diagonal elements for symmetry (and implicitly set lower triangle to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j]; // row j of the current matrix state\n                final double lIJ = lI[j];      // A[i][j]\n                final double lJI = lJ[i];      // A[j][i]\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                // For an in-place Cholesky decomposition where lTData will become L^T (upper triangular),\n                // the elements below the diagonal (lTData[j][i] where j > i) must be zero.\n                // This line effectively ensures that.\n                lJ[i] = 0;\n            }\n        }\n\n        // Perform the Cholesky decomposition (A = L * L^T), storing L^T in lTData (upper triangular part).\n        // The algorithm computes L^T (U) such that A = U^T * U.\n        // The elements of U are given by:\n        // U_kk = sqrt(A_kk - sum_{p=0}^{k-1} U_pk^2)\n        // U_kj = (A_kj - sum_{p=0}^{k-1} U_pk * U_pj) / U_kk  for j > k\n        for (int i = 0; i < order; ++i) { // 'i' corresponds to 'k' in the formulas above (current pivot row/column)\n\n            final double[] ltI = lTData[i]; // This is row 'i' of the working matrix (which will become U)\n\n            // At this point, lTData[i][i] (ltI[i]) contains A[i][i] minus the sum of squares of elements\n            // from previous rows/columns (sum_{p=0}^{i-1} U_pi^2).\n            // This effectively represents U_ii^2 before taking the square root.\n            // This value must be positive for the matrix to be positive definite.\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n\n            // Calculate U_ii (diagonal element)\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            // Calculate U_ij (off-diagonal elements in row i) and update remaining submatrix\n            // The loop iterates from order-1 down to i+1. This is just a valid iteration order.\n            for (int q = order - 1; q > i; --q) { // 'q' corresponds to 'j' in the formulas (column index for U_ij)\n                // Calculate U_iq (lTData[i][q])\n                // lTData[i][q] currently holds A[i][q] minus sum_{p=0}^{i-1} U_pi * U_pq\n                ltI[q] *= inverse; // lTData[i][q] becomes (A[i][q] - sum_{p=0}^{i-1} U_pi * U_pq) / U_ii\n\n                final double[] ltQ = lTData[q]; // This is row 'q' of the working matrix\n                final double factor = ltI[q];   // This is U_iq\n\n                // Update the remaining submatrix elements (lTData[q][p] where p >= q)\n                // lTData[q][p] -= U_iq * U_ip\n                for (int p = q; p < order; ++p) { // 'p' corresponds to 'j' for U_ij update\n                    ltQ[p] -= factor * ltI[p];\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}