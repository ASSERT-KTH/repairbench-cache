{
    "generation": "    /**\n     * Calculates the Cholesky decomposition of the given matrix.\n     * @param matrix the matrix to decompose\n     * @param relativeSymmetryThreshold threshold above which off-diagonal\n     * elements are considered too different and matrix not symmetric\n     * @param absolutePositivityThreshold threshold below which diagonal\n     * elements are considered null and matrix not positive definite\n     * @exception NonSquareMatrixException if matrix is not square\n     * @exception NotSymmetricMatrixException if matrix is not symmetric\n     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n     * strictly positive definite\n     * @see #CholeskyDecompositionImpl(RealMatrix)\n     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n     */\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        // Create a copy of the matrix data to perform the decomposition in-place on the copy.\n        // This avoids modifying the original input matrix.\n        lTData   = matrix.copy().getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // Check the matrix properties (symmetry) and prepare for transformation.\n        // This loop also zeroes out the lower triangle elements of lTData.\n        // lTData will ultimately store L^T (the upper triangular Cholesky factor).\n        for (int i = 0; i < order; ++i) {\n            // Check off-diagonal elements for symmetry\n            for (int j = i + 1; j < order; ++j) {\n                final double lIJ = lTData[i][j]; // Original A_ij\n                final double lJI = lTData[j][i]; // Original A_ji\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                // Zero out the lower triangle elements. For L^T, these should be zero.\n                lTData[j][i] = 0;\n           }\n        }\n\n        // Transform the matrix into its Cholesky decomposition L^T (upper triangular).\n        // This uses the Cholesky-Banachiewicz (row-oriented) algorithm.\n        for (int i = 0; i < order; ++i) {\n\n            // Compute the sum of squares of previously calculated elements for the diagonal element.\n            // L^T_ii^2 = A_ii - sum( (L^T_ki)^2 for k < i )\n            // lTData[k][i] for k < i already contain the computed L^T_ki values from previous iterations.\n            double sumForDiagonal = 0;\n            for (int k = 0; k < i; ++k) {\n                sumForDiagonal += lTData[k][i] * lTData[k][i];\n            }\n\n            // Calculate the actual diagonal value before taking the square root.\n            // lTData[i][i] still holds the original A_ii at this point.\n            final double diagValue = lTData[i][i] - sumForDiagonal;\n\n            // Check for positivity of the diagonal element (L^T_ii^2) before taking the square root.\n            // If it's not positive (within threshold), the matrix is not positive definite.\n            if (diagValue < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n\n            // Compute the diagonal element L^T_ii = sqrt(L^T_ii^2)\n            lTData[i][i] = Math.sqrt(diagValue);\n            final double inverseDiag = 1.0 / lTData[i][i]; // Store 1 / L^T_ii for efficiency\n\n            // Compute the off-diagonal elements in the current row i (L^T_ij for j > i).\n            // L^T_ij = (A_ij - sum(L^T_ki * L^T_kj for k < i)) / L^T_ii\n            // lTData[i][j] initially holds the original A_ij.\n            // lTData[k][i] and lTData[k][j] for k < i already contain L^T_ki and L^T_kj.\n            for (int j = i + 1; j < order; ++j) {\n                double sumForOffDiagonal = 0;\n                for (int k = 0; k < i; ++k) {\n                    sumForOffDiagonal += lTData[k][i] * lTData[k][j];\n                }\n                lTData[i][j] = (lTData[i][j] - sumForOffDiagonal) * inverseDiag;\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}