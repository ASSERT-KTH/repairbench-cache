{
    "generation": "import org.apache.commons.lang.StringUtils; // Assuming this import is available based on the original code\n\npublic class WordUtils {\n    /**\n     * Abbreviates a string nicely.\n     * \n     * This method searches for the first space after the lower limit and abbreviates\n     * the String there. It will also append any String passed as a parameter\n     * to the end of the String. The upper limit can be specified to forcibly\n     * abbreviate a String.\n     * \n     * @param str         the string to be abbreviated. If null is passed, null is returned.\n     *                    If the empty String is passed, the empty string is returned.\n     * @param lower       the lower limit.\n     * @param upper       the upper limit; specify -1 if no limit is desired.\n     *                    If the upper limit is lower than the lower limit, it will be\n     *                    adjusted to be the same as the lower limit.\n     * @param appendToEnd String to be appended to the end of the abbreviated string.\n     *                    This is appended ONLY if the string was indeed abbreviated.\n     *                    The append does not count towards the lower or upper limits.\n     * @return the abbreviated String.\n     * @since 2.4\n     */\n    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        int strLen = str.length();\n\n        // Normalize lower limit:\n        // Ensure lower is non-negative.\n        // If lower is greater than the string length, cap it at the string length.\n        // This ensures indexOf starts within valid bounds or at the end, returning -1.\n        lower = Math.max(0, lower);\n        if (lower > strLen) {\n            lower = strLen;\n        }\n\n        // Normalize upper limit:\n        // If upper is -1 (no limit) or is greater than the string length, set it to the string length.\n        if (upper == -1 || upper > strLen) {\n            upper = strLen;\n        }\n\n        // If upper is less than lower, raise it to lower.\n        // At this point, both 'lower' and 'upper' are guaranteed to be within [0, strLen].\n        // So, 'upper' will remain within [0, strLen] after this adjustment.\n        if (upper < lower) {\n            upper = lower;\n        }\n        // Now, we have: 0 <= lower <= upper <= strLen. These are safe bounds for substring operations.\n\n        StringBuffer result = new StringBuffer();\n        // Search for the first space after the adjusted lower limit.\n        int index = StringUtils.indexOf(str, \" \", lower);\n\n        if (index == -1) {\n            // Case 1: No space found after the lower limit.\n            // Abbreviate the string by truncating it at the adjusted upper limit.\n            result.append(str.substring(0, upper));\n            \n            // Append 'appendToEnd' ONLY if the string was actually abbreviated.\n            // Abbreviation occurs if the resulting length ('upper') is less than the original string length.\n            if (upper != strLen) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            // Case 2: A space was found, but it is beyond the adjusted upper limit.\n            // Abbreviate the string by truncating it at the adjusted upper limit, ignoring the space.\n            result.append(str.substring(0, upper));\n            // In this case, truncation always occurs (since index > upper, upper must be < index, and thus < strLen\n            // unless strLen is very small which is handled by upper normalization).\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else { // This means index is found and (lower <= index <= upper).\n            // Case 3: A space was found within the acceptable range (between lower and upper).\n            // Abbreviate the string at the position of this space.\n            result.append(str.substring(0, index));\n            // In this case, truncation always occurs (since index < strLen if a space is found).\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}