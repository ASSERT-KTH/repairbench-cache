{
    "generation": "@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    // trivial case: same class\n    if (_class == subclass) {\n        return this;\n    }\n    // must be a true subtype\n    if (!_class.isAssignableFrom(subclass)) {\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()\n            +\" not sub-type of \"+_class.getName());\n    }\n    // reuse existing bindings\n    TypeBindings bindings = _bindings;\n    // figure out the appropriate super\u2010class JavaType (if any)\n    JavaType newSuper = null;\n    Class<?> rawSup = subclass.getSuperclass();\n    if (rawSup != null && _class.isAssignableFrom(rawSup)) {\n        // if rawSup exactly matches our old _superClass, keep it; otherwise narrow recursively\n        if (_superClass != null && rawSup == _superClass.getRawClass()) {\n            newSuper = _superClass;\n        } else {\n            newSuper = _narrow(rawSup);\n        }\n    }\n    // collect any interfaces between subclass and our original _class\n    List<JavaType> intfs = new ArrayList<JavaType>();\n    for (Class<?> iface : subclass.getInterfaces()) {\n        if (_class.isAssignableFrom(iface)) {\n            if (iface == _class) {\n                intfs.add(this);\n            } else {\n                intfs.add(_narrow(iface));\n            }\n        }\n    }\n    JavaType[] newInts = intfs.isEmpty()\n        ? new JavaType[0]\n        : intfs.toArray(new JavaType[intfs.size()]);\n    // build the new SimpleType for the subclass\n    return new SimpleType(subclass, bindings, newSuper, newInts,\n            _valueHandler, _typeHandler, _asStatic);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}