{
    "generation": "    @Override\n    @Deprecated\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        \n        // Ensure we delegate to TypeFactory to get canonical instance\n        JavaType subtype = TypeFactory.defaultInstance().constructType(subclass, _bindings);\n\n        // Ok, but let's see if we need to create new instance... generally\n        // only if handlers or static-typing flag differs\n        Object currentVH = this.getValueHandler();\n        Object currentTH = this.getTypeHandler();\n        boolean currentStatic = this.isAnchorType(); // _asStatic\n\n        // Anything inherited?\n        if ((currentVH == subtype.getValueHandler())\n                && (currentTH == subtype.getTypeHandler())\n                && (currentStatic == subtype.isAnchorType())) { // isAnchorType() is getter for _asStatic\n             return subtype;\n        }\n        \n        // If not, need to create new instance that has all handlers and typing\n        // NOTE: since 2.7, this happens much less often due to TypeFactory change\n        // to create \"shared\" instances (see TypeFactory._fromClass())\n        \n        JavaType result = subtype;\n        if (currentVH != null) {\n            result = result.withValueHandler(currentVH);\n        }\n        if (currentTH != null) {\n            result = result.withTypeHandler(currentTH);\n        }\n        // 17-Jan-2018, tatu: Important! `withStaticTyping` only returns new instance\n        //   if value changes.\n        if (currentStatic) {\n            result = result.withStaticTyping();\n        }\n        return result;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}