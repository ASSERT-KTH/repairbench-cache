{
    "generation": "@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n\n    // If the base type is an interface, subclass implements it,\n    // so we add the base interface to the new type's superInterfaces\n    if (_class.isInterface()) {\n        JavaType[] intfs = _superInterfaces;\n        boolean found = false;\n        if (intfs != null) {\n            for (JavaType t : intfs) {\n                if (t == this) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n        if (!found) {\n            int len = (intfs == null) ? 0 : intfs.length;\n            JavaType[] newIntfs = new JavaType[len + 1];\n            if (len > 0) {\n                System.arraycopy(intfs, 0, newIntfs, 0, len);\n            }\n            newIntfs[len] = this;\n            intfs = newIntfs;\n        }\n        return new SimpleType(subclass, _bindings, _superClass, intfs,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    // Otherwise (base is a class), treat the old type as the new superClass\n    return new SimpleType(subclass, _bindings, this,\n            _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}