{
    "generation": "@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int n = y0.length;\n\n    // interpolation array is stored in a separate structure\n    if (y != y0) {\n        System.arraycopy(y0, 0, y, 0, n);\n    }\n\n    // set up the integrator\n    final AdamsMoultonStepInterpolator interpolator =\n        (AdamsMoultonStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, y, forward);\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    mainLoop:\n    while (true) {\n\n        interpolator.shift();\n\n        // the step has been accepted\n        final double t1 = stepStart + stepSize;\n        final boolean lastStep = t1 == t;\n        final boolean stop   = manager.stop();\n        if (stop || lastStep) {\n\n            if ( (forward && t1 >= t) || (!forward && t1 <= t) ) {\n                stepSize = t - stepStart;\n            }\n\n            // update interpolator after step\n            interpolator.storeTime(t1);\n\n            // provide the step data to the step handler\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, true);\n            }\n\n            // return the last time\n            final double stopTime = t1;\n\n            interpolator.shift();\n            interpolator.storeTime(stopTime);\n\n            resetInternalState();\n            return stopTime;\n\n        } else {\n\n            // discrete events handling\n            if (manager.evaluateStep(interpolator)) {\n                final double eventTime = manager.getEventTime();\n                final double dt       = (forward)\n                                      ? eventTime - stepStart\n                                      : stepStart - eventTime;\n                if (dt == 0) {\n                    // rejecting the step would lead to a too small next step, we accept it\n                    stepSize = forward ? t - stepStart : stepStart - t;\n                } else {\n                    stepSize = dt;\n                }\n            }\n\n            if (stepStart + stepSize == stepStart) {\n                // Rejecting the step would lead to a too small next step, we accept it\n                break mainLoop;\n            }\n\n            // Check if the remaining time is smaller than the step size\n            if (forward) {\n                if (t - stepStart > stepSize) {\n                    stepSize = t - stepStart;\n                }\n            } else {\n                if (stepStart - t > stepSize) {\n                    stepSize = stepStart - t;\n                }\n            }\n\n            try {\n                // perform one step of integration\n                final double[] yDot0 = computeDerivatives(stepStart, y);\n                final double[] y1    = performedStep(forward, stepSize, y, yDot0);\n                manager.stepAccepted(stepStart + stepSize, y1);\n            } catch (DerivativeException ex) {\n                if (ex iteratingMinStep()) {\n                    // processing min step\n                    break mainLoop;\n                } else {\n                    throw ex;\n                }\n            }\n\n            // provide the step data to the step handler\n            for (StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, lastStep);\n            }\n\n            // check if we have reached the target time\n            if (stepStart == t) {\n                break mainLoop;\n            }\n\n            // update our data for next step\n            stepStart += forward ? stepSize : -stepSize;\n            System.arraycopy(y1, 0, y, 0, n);\n\n        }\n\n    }\n\n    return stepStart;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}