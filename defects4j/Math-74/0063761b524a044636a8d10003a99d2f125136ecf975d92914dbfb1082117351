{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0; // Will be initialized based on step size control parameters or initializeStep\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      boolean firstAttempt = true; // Flag for first attempt of the current step\n      boolean stepAccepted = false; // Flag indicating if the step was accepted\n\n      while (!stepAccepted) { // Inner loop for step attempts (initial + retries)\n\n          // Determine the step size for this attempt\n          if (firstAttempt) {\n              // Initialize step size on the very first attempt ever\n              if (firstTime) {\n                  final double[] scale;\n                  if (vecAbsoluteTolerance == null) {\n                      scale = new double[y0.length];\n                      java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n                  } else {\n                      scale = vecAbsoluteTolerance;\n                  }\n                  // Ensure the first derivative is computed for initializeStep\n                  computeDerivatives(stepStart, y, yDotK[0]);\n                  hNew = initializeStep(equations, forward, getOrder(), scale,\n                                        stepStart, y, yDotK[0], yTmp, yDotK[1]);\n              }\n              // Use the proposed step size (either initialized or from previous step control)\n              stepSize = hNew;\n          } else {\n              // On retries, stepSize is already reduced by the error control logic\n              // No need to update stepSize from hNew here\n          }\n\n\n          // First stage (k=0) evaluation: f(t_n, y_n)\n          // Always recompute the first stage derivative if this is not the first attempt or if FSAL is disabled.\n          // For the first attempt of the first step, it was computed above for initializeStep.\n          // For the first attempt of subsequent steps with FSAL, yDotK[0] contains the last stage evaluation of the previous step.\n          if (!firstAttempt || !fsal || (firstTime && firstAttempt)) {\n               // Need to compute yDotK[0] if:\n               // - this is a retry (!firstAttempt)\n               // - FSAL is disabled (!fsal)\n               // - this is the first attempt of the first step (firstTime && firstAttempt - already done for initializeStep, but can recompute for safety or if initializeStep doesn't store it)\n               // Note: The condition simplifies: compute if !firstAttempt || !fsal. If firstTime && firstAttempt, it's already computed.\n               if (!firstAttempt || !fsal) {\n                 computeDerivatives(stepStart, y, yDotK[0]);\n               }\n          }\n          // If it's the first attempt (!firstTime && fsal), yDotK[0] holds the reused value and we skip the computation.\n\n\n          // Next stages (k=1 to stages-1)\n          for (int k = 1; k < stages; ++k) {\n              for (int j = 0; j < y0.length; ++j) {\n                  double sum = a[k-1][0] * yDotK[0][j];\n                  for (int l = 1; l < k; ++l) {\n                      sum += a[k-1][l] * yDotK[l][j];\n                  }\n                  yTmp[j] = y[j] + stepSize * sum;\n              }\n              computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n          }\n\n          // Estimate the state at the end of the step\n          for (int j = 0; j < y0.length; ++j) {\n              double sum    = b[0] * yDotK[0][j];\n              for (int l = 1; l < stages; ++l) {\n                  sum    += b[l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          // Estimate the error at the end of the step\n          error = estimateError(yDotK, y, yTmp, stepSize);\n\n          if (error <= 1.0) {\n              // Step size might be accepted based on error, check events\n              interpolator.storeTime(stepStart + stepSize);\n              if (manager.evaluateStep(interpolator)) {\n                  // Event occurred within the step\n                  final double dt = manager.getEventTime() - stepStart;\n                  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                      // Event is very close to the start, accept the current step\n                      // The event manager will handle the exact time.\n                      stepAccepted = true;\n                  } else {\n                      // Reject the step and resize step to hit the event time\n                      hNew = dt; // Propose new step size for the next attempt\n                      stepSize = hNew; // Set stepSize for the next iteration of this inner loop\n                      firstAttempt = false; // Mark that the next iteration is a retry\n                      // stepAccepted remains false, loop continues\n                  }\n              } else {\n                  // No event, step is fully accepted\n                  stepAccepted = true;\n              }\n\n          } else {\n              // Error too large, reject step and attempt to reduce error by stepsize control\n              final double factor = Math.min(maxGrowth,\n                                             Math.max(minReduction, safety * Math.pow(error, exp)));\n              hNew = filterStep(stepSize * factor, forward, false); // Propose smaller step size\n              stepSize = hNew; // Set stepSize for the next iteration of this inner loop\n              firstAttempt = false; // Mark that the next iteration is a retry\n              // stepAccepted remains false, loop continues\n          }\n\n      } // End of inner step attempt loop: while (!stepAccepted)\n\n      // The step has been accepted (stepSize holds the accepted value)\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // Provide the step data to the step handler\n      interpolator.storeTime(nextStep); // Store final time for the accepted step\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n          // Save the last evaluation for the next step's first attempt\n          System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      // Reset firstTime flag after the first successful step has been taken\n      if (firstTime) {\n        firstTime = false;\n      }\n\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n          // Some event handler has triggered changes that invalidate the derivatives,\n          // we need to recompute them for the next step.\n          // This correctly overwrites the FSAL value if needed.\n          computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n          // Step size control for next step\n          // Ensure stepSize is not zero after event handling or near start\n          stepSize = filterStep(stepSize, forward, true);\n\n          // Use the error from the accepted step to control the next step size\n          final double factor = Math.min(maxGrowth,\n                                         Math.max(minReduction,\n                                                  safety * Math.pow(error, exp)));\n          final double scaledH = stepSize * factor;\n          final double nextT = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast); // Store proposed hNew for the *next* step's first attempt\n      }\n\n    } // End of main integration loop: while (!lastStep)\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}