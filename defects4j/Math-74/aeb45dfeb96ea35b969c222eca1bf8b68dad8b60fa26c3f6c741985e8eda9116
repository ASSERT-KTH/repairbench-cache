{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int n = y0.length;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, n);\n    }\n\n    // set up integration control objects\n    stepStart = t0;\n    double hNew = Math.abs(t - t0);\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // initialize the Nordsieck array and other multistep structures\n    double[][] yDotK = new double[getNSteps() + 1][];\n    yDotK[0] = new double[n];\n    computeDerivatives(stepStart, y, yDotK[0]);\n\n    // main integration loop\n    while (!lastStep) {\n\n      double error = 0;\n      boolean loop = true;\n      while (loop) {\n\n        if (firstTime) {\n          hNew = initializeStep(forward, getOrder(), stepStart, y, yDotK[0], y);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // Predictor step (Adams-Bashforth)\n        double[] predictedY = new double[n];\n        for (int j = 0; j < n; ++j) {\n          predictedY[j] = y[j] + stepSize * yDotK[0][j];\n        }\n\n        // Corrector step (Adams-Moulton)\n        double[] correctedY = new double[n];\n        computeDerivatives(stepStart + stepSize, predictedY, yDotK[1]);\n        for (int j = 0; j < n; ++j) {\n          correctedY[j] = y[j] + stepSize * (yDotK[0][j] + yDotK[1][j]) / 2;\n        }\n\n        // Estimate error (difference between predictor and corrector)\n        error = 0;\n        for (int j = 0; j < n; ++j) {\n          final double errJ = Math.abs(correctedY[j] - predictedY[j]);\n          final double yScale = Math.abs(y[j]) + Math.abs(correctedY[j] - y[j]);\n          final double tol = (vecAbsoluteTolerance == null) ?\n                             scalAbsoluteTolerance + scalRelativeTolerance * yScale :\n                             vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale;\n          final double ratio = errJ / tol;\n          error += ratio * ratio;\n        }\n        error = Math.sqrt(error / n);\n\n        if (error <= 1.0) {\n          loop = false;\n        } else {\n          // adjust step size\n          hNew = stepSize * Math.max(0.1, Math.pow(error, -1.0 / (getOrder())));\n          hNew = filterStep(hNew, forward, false);\n        }\n\n      }\n\n      // step accepted\n      stepStart += stepSize;\n      System.arraycopy(correctedY, 0, y, 0, n);\n      manager.stepAccepted(stepStart, y);\n      lastStep = manager.stop();\n\n      // handle step and prepare next step\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(new DummyStepInterpolator(y, forward), lastStep);\n      }\n\n      // shift derivatives\n      System.arraycopy(yDotK[1], 0, yDotK[0], 0, n);\n\n      if (!lastStep) {\n        // compute new step size\n        final double factor = Math.pow(error, -1.0 / getOrder());\n        hNew = filterStep(stepSize * factor, forward, true);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}