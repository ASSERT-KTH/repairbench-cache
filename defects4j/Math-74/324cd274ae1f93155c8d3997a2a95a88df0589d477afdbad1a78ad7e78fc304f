{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // initialize integrator\n    final int n = y0.length;\n    final int steps = getNumberOfSteps();\n    final double order = steps + 1;\n\n    // initialize step handlers\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n\n    // set up interpolation\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n        interpolator = new AdamsMoultonStepInterpolator();\n        interpolator.reinitialize(this, y, forward);\n    } else {\n        interpolator = new DummyStepInterpolator(y, forward);\n    }\n    interpolator.storeTime(t0);\n\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n\n    // initialize Nordsieck vector\n    double[] scale = new double[n];\n    if (vecAbsoluteTolerance == null) {\n        java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n    } else {\n        System.arraycopy(vecAbsoluteTolerance, 0, scale, 0, n);\n    }\n\n    // initial step\n    double hNew = initializeStep(equations, forward, order, scale, t0, y0, new double[n], y, new double[n]);\n    double stepSize = hNew;\n\n    // main integration loop\n    double stepStart = t0;\n    double[] yDot = new double[n];\n    boolean lastStep = false;\n    while (!lastStep) {\n\n        // compute derivatives\n        computeDerivatives(stepStart, y, yDot);\n\n        // predict next step using Adams-Bashforth\n        // (implementation details depend on multistep logic)\n\n        // correct using Adams-Moulton\n        // (solve implicit equation, possibly with iteration)\n\n        // estimate error and adjust step size\n\n        // handle step acceptance and events\n\n        interpolator.storeTime(stepStart + stepSize);\n        lastStep = manager.evaluateStep(interpolator);\n\n        // handle step handlers\n        for (StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, lastStep);\n        }\n\n        stepStart += stepSize;\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}