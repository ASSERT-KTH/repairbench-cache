{
    "generation": "  /** {@inheritDoc} */\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    // Use the new CombinedEventsManager\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    isLastStep = false; // Store isLastStep as instance variable accessible to handlers? Or pass? Assume manager handles it.\n\n    while (!lastStep) {\n\n      interpolator.shift(); // Update interpolator state for the new step\n\n      double error = 10; // Initialize error to ensure loop runs at least once\n      boolean stepRejected = false; // Flag to track if the step was rejected\n\n      while (error > 1.0) { // Keep trying until step is accepted (error <= 1.0)\n\n          if (!firstTime && stepRejected && fsal) {\n              // If step was rejected and FSAL is enabled, the yDotK[0] from the previous\n              // *accepted* step might be stale. Recompute it for the current state y\n              // before proceeding with the new step attempt.\n              computeDerivatives(stepStart, y, yDotK[0]);\n          } else if (firstTime || !fsal) {\n              // Compute the first stage normally if it's the first step or FSAL is disabled\n              computeDerivatives(stepStart, y, yDotK[0]);\n          }\n          // If FSAL is true and not the first step and not a rejected step retry,\n          // yDotK[0] will be the value copied from the previous step's yDotK[stages-1].\n\n          if (firstTime) {\n              // Initialize the step size only on the very first attempt\n              final double[] scale;\n              if (vecAbsoluteTolerance == null) {\n                  scale = new double[y0.length];\n                  java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n              } else {\n                  scale = vecAbsoluteTolerance;\n              }\n              // initializeStep may compute yDotK[1] internally for step size estimation\n              hNew = initializeStep(forward, getOrder(), scale,\n                                    stepStart, y, yDotK[0], yTmp, yDotK[1]);\n              // NOPMD below, assuming initializeStep adheres to side effect contracts\n              firstTime = false; // Initialization done\n          }\n          // For subsequent attempts (rejected steps), reuse the previously computed hNew\n\n          stepSize = hNew; // Use the estimated step size\n\n          // Adjust step size if it goes past the end time\n          if (!forward) {\n              if (stepStart + stepSize < t) {\n                  stepSize = t - stepStart;\n              }\n          } else {\n              if (stepStart + stepSize > t) {\n                  stepSize = t - stepStart;\n              }\n          }\n\n          // Perform the Runge-Kutta stages calculation\n          for (int k = 1; k < stages; ++k) {\n              for (int j = 0; j < y0.length; ++j) {\n                  double sum = a[k-1][0] * yDotK[0][j];\n                  for (int l = 1; l < k; ++l) {\n                      sum += a[k-1][l] * yDotK[l][j];\n                  }\n                  yTmp[j] = y[j] + stepSize * sum;\n              }\n              // Compute derivative for the k-th stage\n              computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n          }\n\n          // Estimate the state at the end of the step\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = b[0] * yDotK[0][j];\n              for (int l = 1; l < stages; ++l) {\n                  sum += b[l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          // Estimate the error\n          error = estimateError(yDotK, y, yTmp, stepSize);\n\n          if (error <= 1.0) {\n              // Step is potentially acceptable - check events\n              interpolator.storeTime(stepStart + stepSize); // Store proposed end time\n\n              if (manager.evaluateStep(interpolator)) {\n                  // Event occurred within the step\n                  final double eventTime = manager.getEventTime();\n                  final double dt = eventTime - stepStart;\n                  // Check if the event is very close to the step start\n                  if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                      // Event is too close, accept the current step as is\n                      // to avoid zero step size. Error is already <= 1.0.\n                      // No need to change hNew, loop condition (error <= 1.0) will exit.\n                  } else {\n                      // Event occurred, need to shrink step to hit it exactly.\n                      // Reject the current step and retry with step size = dt.\n                      hNew = dt;\n                      error = 2.0; // Force rejection by setting error > 1.0\n                                   // The next iteration will use hNew = dt.\n                  }\n              } else {\n                  // No event, step accepted. Error is <= 1.0, loop will exit.\n              }\n\n          } else {\n              // Error is too large, step rejected. Reduce step size and retry.\n              final double factor =\n                  Math.min(maxGrowth,\n                           Math.max(minReduction, safety * Math.pow(error, exp)));\n              hNew = filterStep(stepSize * factor, forward, false);\n              // Mark step as rejected for the next iteration's logic (FSAL check)\n              stepRejected = true;\n              // The loop continues with error > 1.0\n          }\n      } // End of inner while loop (step acceptance/rejection)\n\n\n      // The step has been accepted (error <= 1.0 and event handling permits)\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length); // Update main state vector\n      manager.stepAccepted(nextStep, y); // Notify event manager\n      lastStep = manager.stop(); // Check if integration should stop\n\n      // provide the step data to the step handler(s)\n      interpolator.storeTime(nextStep); // Ensure interpolator has the final time\n      for (StepHandler handler : stepHandlers) {\n          // Ensure handler knows if this is the last step\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep; // Advance step start time\n\n      if (fsal && !lastStep) { // Avoid copy if it's the last step (no next step)\n        // Save the last evaluation for the next step (FSAL optimization)\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      // Handle event-triggered resets\n      if (manager.reset(stepStart, y) && !lastStep) {\n        // State was modified by an event handler, derivatives are invalid.\n        // Recompute the first derivative for the new state.\n        computeDerivatives(stepStart, y, yDotK[0]);\n        // Note: The FSAL copy above might be overwritten here if fsal=true, which is correct.\n      }\n\n      if (!lastStep) {\n        // Prepare for the next step\n\n        // Ensure stepSize is non-zero if it somehow became zero (e.g., event at start)\n        // Use filterStep to get a minimum viable step size if needed.\n        // Pass 'true' for allowZero to avoid issues if stepSize is already validly small.\n        stepSize = filterStep(stepSize, forward, true);\n\n        // Predict step size for the next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp))); // error is from accepted step\n        final double scaledH = stepSize * factor;\n        final double nextT = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n\n        // Filter the predicted step size (apply min/max step limits)\n        hNew = filterStep(scaledH, forward, nextIsLast);\n\n        // If the predicted step size goes past the final time, clamp it.\n        final double dt = t - stepStart;\n        if ((forward && hNew > dt) || (!forward && hNew < dt)) {\n            hNew = dt;\n        }\n\n      }\n\n    } // End of main integration loop (while !lastStep)\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}