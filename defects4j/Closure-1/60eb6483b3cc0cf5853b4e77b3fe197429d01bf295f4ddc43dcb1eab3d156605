{
    "generation": "  /**\n   * Removes unreferenced arguments from a function declaration and when\n   * possible the function's callSites.\n   *\n   * @param fnScope The scope inside the function\n   */\n  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // Parameters of object literal setters cannot be removed.\n      return;\n    }\n\n    // Determine if we should consider call site modification\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n\n    // Criteria to avoid removing arguments:\n    // 1. If it's an object literal method and has parameters declared with default values.\n    // 2. If it's a constructor or has a super call.\n    boolean canModifyArgs = !(NodeUtil.isOBObjectLiteralMethod(function) && hasDefaultParameters(function)) \n        && !isConstructor(function) \n        && !hasSuperCall(function);\n\n    // Skip processing if modification isn't allowed\n    if (!canModifyArgs) {\n      return;\n    }\n\n    if (!modifyCallers) {\n      // Safely remove unreferenced arguments from the end\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n\n  // Helper method to check if function has default parameters\n  private boolean hasDefaultParameters(Node function) {\n    for (Node param : getFunctionParameters(function)) {\n      if (param.hasChild(NodeDEFAULTPARAM_MARKER)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Helper method to check if function is a constructor\n  private boolean isConstructor(Node function) {\n    return function.endsWith(Node.CONSTRUCTOR);\n  }\n\n  // Helper method to check if function has a super call\n  private boolean hasSuperCall(Node function) {\n    return NodeUtil.getCallsTo(function, \"super\").length > 0;\n  }\n\n  // Helper method to get function parameters for analysis\n  private Iterable<Node> getFunctionParameters(Node function) {\n    return NodeUtil.getFunctionParameters(function);\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}