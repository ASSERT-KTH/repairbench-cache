{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            \n            // At this point, `offset` either points to the `startChar` or has reached `length`\n            // if `startChar` was not found.\n            // If `offset` is now `length` or greater, the outer loop condition (`offset < length`)\n            // will handle termination in the next iteration.\n            // The following `if (offset < length)` ensures we only proceed if `offset` is still valid.\n            if (offset < length) {\n                int i = offset + 1;\n                // 'last' is the expected index in 'input' *after* the full sequence match.\n                // If `seq` has length L, and its first char is at `offset`,\n                // then it occupies indices `offset` to `offset + L - 1`.\n                // So, the characters `seq.charAt(1)` to `seq.charAt(L-1)` are expected to match\n                // `input[offset+1]` to `input[offset + L - 1]`.\n                // `i` starts at `offset + 1`. After the loop, if full match, `i` should be `offset + L`.\n                // `last` is computed as `(offset + 1) + seq.length() - 1`, which simplifies to `offset + seq.length()`.\n                int last = i + seq.length() - 1;\n\n                // The inner loop iterates to compare the rest of the sequence `seq` with `input`.\n                // It must ensure:\n                // 1. `j` stays within bounds of `seq` (j < seq.length()).\n                // 2. `i` stays within bounds of `input` (i < length). This is crucial to prevent `ArrayIndexOutOfBoundsException`.\n                // 3. Characters match.\n                for (int j = 1; j < seq.length() && i < length && seq.charAt(j) == input[i]; i++, j++);\n                \n                // If the loop completes because all characters in `seq` matched,\n                // then `j` will be equal to `seq.length()`, and `i` will have advanced\n                // such that `i == last`.\n                if (i == last) { // found full sequence\n                    return offset - pos;\n                }\n            }\n        }\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}