{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        // Assume seq.length() > 0 based on original charAt(0) call.\n        // If seq.length() were 0, seq.charAt(0) would throw an exception.\n        char startChar = seq.charAt(0);\n        int targetLength = seq.length();\n\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startChar:\n            // If input[offset] is not startChar, advance offset until startChar is found or end of input is reached.\n            if (startChar != input[offset]) {\n                while(++offset < length && startChar != input[offset]);\n            }\n\n            // After the while loop, 'offset' might be 'length' if startChar was not found\n            // in the remaining input, or it points to the first occurrence of 'startChar'.\n            if (offset == length) {\n                return -1; // No more occurrences of startChar found, so the sequence cannot be found.\n            }\n\n            // At this point, input[offset] == startChar.\n            // Now, check if there are enough characters remaining in the input to match the full sequence.\n            // The full sequence would occupy characters from 'offset' up to 'offset + targetLength - 1'.\n            // So, 'offset + targetLength' (which is the index *after* the last character of the potential match)\n            // must not exceed 'length'.\n            if (offset + targetLength > length) {\n                // Not enough characters left in the input for a full match starting from this 'offset'.\n                // This 'offset' cannot yield a full match, so we continue searching for the next possible 'startChar'.\n                // The outer loop's 'offset++' will handle advancing the position.\n                continue;\n            }\n\n            // Now, input[offset] is startChar and we have enough room for the full sequence.\n            // Compare the rest of the sequence.\n            // 'i' represents the current index in the 'input' array, starting after 'offset'.\n            // 'j' represents the current index in the 'seq' (target sequence), starting after the first character.\n            int i = offset + 1;\n            // 'last' is the index *after* the last character of the sequence if it matches in the input array.\n            // If the sequence is 'targetLength' long, and starts at 'offset',\n            // it occupies indices 'offset' through 'offset + targetLength - 1'.\n            // So, the characters to check after the first are from 'offset + 1' to 'offset + targetLength - 1'.\n            // The loop for 'i' should run as long as 'i < offset + targetLength'.\n            int last = offset + targetLength;\n\n            // This loop compares characters from the sequence (starting at index 1)\n            // with characters from the input (starting at index offset + 1).\n            // The condition 'i < last' ensures that 'i' goes up to 'last-1',\n            // which is 'offset + targetLength - 1'. This is the correct last index for comparison.\n            // The 'offset + targetLength > length' check performed earlier guarantees that 'last <= length',\n            // so 'input[i]' access will always be within bounds (i.e., 'i < length').\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n\n            // If 'i' reached 'last', it means all characters of the sequence matched successfully.\n            if (i == last) { // found full sequence\n                return offset - pos; // Return the offset from the current 'pos'\n            }\n        }\n        return -1; // Sequence not found in the remaining input\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}