{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        int seqLen = seq.length(); // Cache sequence length\n\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset]) {\n                // Find the next occurrence of startChar\n                while (++offset < length && startChar != input[offset]);\n                // Check if the loop terminated because we went out of bounds\n                if (offset >= length)\n                    break; // Reached end of input without finding startChar, so sequence not found\n            }\n\n            // Now we have a potential match starting at 'offset' (input[offset] == startChar)\n            // Check if the rest of the sequence can fit in the remaining buffer\n            // We need seqLen characters starting from offset. Last index is offset + seqLen - 1.\n            // This must be less than length: offset + seqLen - 1 < length  OR  offset + seqLen <= length.\n            if (offset + seqLen <= length) {\n                // Compare the sequence characters from the second one (index 1)\n                int i = offset + 1; // index in input buffer, starting after startChar\n                int j = 1;          // index in seq, starting from the second char\n                // last is the end boundary (exclusive) for the match in input buffer\n                // i needs to go up to offset + seqLen - 1 (inclusive)\n                // So the loop condition should be i < offset + seqLen\n                int last = offset + seqLen;\n\n                while (i < last) { // While we haven't reached the end of the potential match area\n                    // Check if the characters match\n                    if (seq.charAt(j) != input[i]) {\n                        break; // Mismatch found, break the inner while loop\n                    }\n                    // Move to the next characters\n                    i++;\n                    j++;\n                }\n\n                // If we finished comparing and reached the end (i == last), it means all characters matched.\n                if (i == last) { // found full sequence\n                    return offset - pos; // Return the relative offset from the initial position\n                }\n                // Otherwise, a mismatch occurred. The outer loop will continue searching from the next offset.\n            } else {\n                 // The sequence is too long to fit starting at this 'offset'.\n                 // Since we are scanning sequentially, it won't fit anywhere further either.\n                 break; // Exit the outer loop, sequence cannot be found.\n            }\n        }\n        return -1; // Sequence not found after checking the entire relevant part of the input\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}