{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n\n        if (seq.length() == 0) {\n            return 0; // Empty sequence is always found at the current position\n        }\n\n        // Special case for single character sequence to avoid StringIndexOutOfBoundsException with seq.charAt(j)\n        // and simplify logic.\n        if (seq.length() == 1) {\n            char targetChar = seq.charAt(0);\n            for (int offset = pos; offset < length; offset++) {\n                if (targetChar == input[offset]) {\n                    return offset - pos;\n                }\n            }\n            return -1;\n        }\n\n        char startChar = seq.charAt(0);\n        int seqLen = seq.length();\n\n        for (int offset = pos; offset < length; offset++) {\n            // Scan to first instance of startChar:\n            // If startChar != input[offset], advance offset until startChar is found or end of input.\n            if (startChar != input[offset]) {\n                while(++offset < length && startChar != input[offset]);\n            }\n\n            // If the while loop advanced offset to length, it means startChar was not found from the current position\n            // to the end of the input, so no full sequence can be found.\n            if (offset == length) {\n                break; // Exit outer loop\n            }\n\n            // At this point, input[offset] == startChar.\n            // Now, check if there are enough characters remaining in the input to match the full sequence.\n            // If offset + seqLen > length, it means accessing input[offset + seqLen - 1] would be out of bounds.\n            if (offset + seqLen > length) {\n                continue; // Not enough characters for a full match, try next potential startChar\n            }\n\n            // Check the rest of the sequence (from the second character onwards).\n            // The first character (seq.charAt(0)) is already confirmed as input[offset].\n            boolean match = true;\n            for (int j = 1; j < seqLen; j++) {\n                // Compare seq.charAt(j) with input character at (offset + j)\n                if (seq.charAt(j) != input[offset + j]) {\n                    match = false;\n                    break;\n                }\n            }\n\n            if (match) {\n                return offset - pos; // Full sequence found, return offset relative to current position\n            }\n        }\n        return -1; // Sequence not found\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}