{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        if (seq.length() == 0) // Handle empty sequence case\n             return 0; // Or arguably -1, but matching standard indexOf behavior seems reasonable if needed. Let's stick to original logic's implicit assumption of non-empty seq.\n\n        char startChar = seq.charAt(0);\n        int seqLen = seq.length();\n\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset]) {\n                // advance offset until matching startChar or reaching end\n                while(++offset < length && startChar != input[offset]);\n                // if we advanced past the end, the sequence cannot be found\n                if (offset >= length)\n                    break; // Exit outer loop\n            }\n            \n            // found startChar at input[offset]. Now check if the full sequence matches from here.\n            \n            // check if the rest of the sequence can fit within the bounds of the input array\n            if (offset + seqLen <= length) {\n                int i = offset + 1; // input index starts after startChar\n                int j = 1;          // sequence index starts after startChar\n                int endMatch = offset + seqLen; // position right after the potential sequence match ends\n\n                // compare the rest of the sequence characters\n                while (i < endMatch && seq.charAt(j) == input[i]) {\n                    i++;\n                    j++;\n                }\n\n                // if i reached the end position, it means the entire sequence matched\n                if (i == endMatch) { // found full sequence\n                    return offset - pos; // return the relative offset from the initial position\n                }\n                // otherwise, sequence did not match fully, continue scanning from next offset in outer loop\n            } else {\n                // If startChar is found but the remaining input is too short to hold the full sequence,\n                // we know the sequence cannot be found later either, as offset only increases.\n                break; // Exit outer loop\n            }\n        }\n        \n        return -1; // sequence not found\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}