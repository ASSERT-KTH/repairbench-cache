{
    "generation": "    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n\n        // Handle empty sequence: an empty sequence is typically found at the current position.\n        if (seq.length() == 0) {\n            return 0; // Offset is 0 (current position)\n        }\n\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // Scan to the first instance of startChar:\n            // This loop efficiently skips over characters that are not the startChar.\n            // If startChar is not found or we reach the end, 'offset' will be 'length'.\n            if (startChar != input[offset]) {\n                while(++offset < length && startChar != input[offset]);\n            }\n\n            // After the while loop, 'offset' might be 'length' if startChar was not found\n            // or if we reached the end of the input while looking for startChar.\n            // If 'offset' is 'length', it means no startChar was found from 'pos' onwards,\n            // or not enough space left to find it and the full sequence.\n            if (offset == length) {\n                return -1;\n            }\n\n            // At this point, input[offset] == startChar.\n            // Now, check if the remaining characters in the input array are sufficient\n            // to contain the full sequence.\n            // The sequence has 'seq.length()' characters.\n            // If it starts at 'offset', its last character would be at 'offset + seq.length() - 1'.\n            // This index must be less than 'length'.\n            // So, 'offset + seq.length() - 1 < length'\n            // which simplifies to 'offset + seq.length() <= length'.\n            if (offset + seq.length() > length) {\n                // Not enough characters left in the input to match the full sequence.\n                // Since startChar was found, but the rest won't fit, we can stop searching.\n                return -1;\n            }\n\n            // Compare the rest of the sequence from seq.charAt(1) onwards.\n            // 'i' is the current index in 'input' array, corresponding to 'j' in 'seq'.\n            int i = offset + 1; // Start checking from the character after startChar in input.\n            int j = 1;          // Start checking from the second character in seq.\n            for (; j < seq.length(); j++) {\n                // The check 'offset + seq.length() > length' above ensures that\n                // 'i' will not go out of bounds ('i < length') as long as 'j < seq.length()'.\n                if (seq.charAt(j) != input[i]) {\n                    break; // Mismatch found, this 'offset' is not the start of the sequence.\n                }\n                i++; // Move to the next character in input.\n            }\n\n            // If the inner loop completed (i.e., 'j' reached 'seq.length()'),\n            // it means all characters of 'seq' matched successfully.\n            if (j == seq.length()) {\n                return offset - pos; // Return the relative offset from the current position.\n            }\n            // If a mismatch occurred (j < seq.length()), the outer loop continues to the next 'offset'.\n        }\n        // If the outer loop finishes, the sequence was not found anywhere from 'pos' to 'length - 1'.\n        return -1;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}