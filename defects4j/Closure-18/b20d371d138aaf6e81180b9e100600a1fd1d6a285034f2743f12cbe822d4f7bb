{
    "generation": "  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Initialize roots\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // == Step 1: Parse Externs ==\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // == Step 2: Process Modules (potential order change) ==\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // == Step 3: Hoist Externs ==\n      hoistExterns(externsRoot);\n\n\n      // == Step 4: Parse all inputs and annotate, before sorting ==\n      // This ensures that getProvides/getRequires calls below have the ASTs ready.\n      boolean hasInputAsts = !inputs.isEmpty();\n      for (CompilerInput input : inputs) {\n          Node n = input.getAstRoot(this);\n          // Error handled by returning null in getAstRoot. If it's null,\n          // hasErrors() should be true, and we'll return null below.\n          if (n == null) {\n              continue;\n          }\n\n          if (options.sourceMapOutputPath != null ||\n              options.nameReferenceReportPath != null) {\n              SourceInformationAnnotator sia =\n                  new SourceInformationAnnotator(\n                      input.getName(), options.devMode != DevMode.OFF);\n              NodeTraversal.traverse(this, n, sia);\n          }\n      }\n\n      // If errors occurred during parsing, return now.\n      if (hasErrors()) {\n          return null;\n      }\n\n      // == Step 5: Dependency Management (may reorder inputs) ==\n      boolean staleInputs = false;\n      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        // This depends on the ASTs being available, which they are now.\n        for (CompilerInput input : inputs) {\n          // Input may or may not be parsed depending on existence of provides.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n        // Check for errors after provides have been processed.\n        if (hasErrors()) {\n          return null;\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          // Error handled below.\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          // Error handled below.\n        }\n        // Check for errors from dependency management BEFORE proceeding.\n        if (hasErrors()) {\n            return null;\n        }\n      }\n\n      // == Step 6: Hoist No-Compile Files ==\n      // This might depend on the potentially reordered inputs list.\n      hoistNoCompileFiles();\n\n      // == Step 7: Repartition inputs if necessary ==\n      if (staleInputs) {\n        repartitionInputs(); // Updates `inputs` based on module graph changes\n      }\n\n      // == Step 8: Build the main AST root from the (potentially sorted) inputs ==\n      // Add the input ASTs to jsRoot in the determined order.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this); // Get the *cached* AST\n        // Input ASTs are detached by getAstRoot() on subsequent calls,\n        // so it is safe to add them here.\n        if (n != null) { // Check n != null in case parsing failed earlier but error was ignored\n          jsRoot.addChildToBack(n);\n        } else if (!hasErrors()) {\n            // This should not happen if hasErrors() check worked before,\n            // but adding a defensive check.\n            throw new IllegalStateException(\"Input missing AST but no error reported: \" + input.getName());\n        }\n      }\n\n      // If errors occurred during any step (like ignored dependency errors in IDE mode),\n      // return null now. The jsRoot might be partially built.\n      if (hasErrors()) {\n        return null;\n      }\n\n      // == Step 9: Final Sanity Check ==\n      // Run sanity check *after* jsRoot is built.\n      if (devMode && hasInputAsts) { // Only run if there were JS inputs\n          runSanityCheck();\n          if (hasErrors()) {\n              return null;\n          }\n      }\n\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}