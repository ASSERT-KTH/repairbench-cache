{
    "generation": "Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n        externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n        jsRoot.detachChildren();\n    }\n\n    // Parse main JS sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n        tracker = new PerformanceTracker(jsRoot, options.tracer);\n        addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n        // Parse externs sources.\n        for (CompilerInput input : externs) {\n            Node n = input.getAstRoot(this);\n            if (hasErrors()) {\n                return null;\n            }\n            externsRoot.addChildToBack(n);\n        }\n\n        // Modules inferred in ProcessCommonJS pass.\n        if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n            processAMDAndCommonJSModules();\n        }\n\n        hoistExterns(externsRoot);\n\n        // Check if the sources need to be re-ordered.\n        boolean staleInputs = false;\n        if (options.dependencyOptions.needsManagement() && options.closurePass) {\n            for (CompilerInput input : inputs) {\n                // Forward-declare all the provided types, so that they\n                // are not flagged even if they are dropped from the process.\n                for (String provide : input.getProvides()) {\n                    getTypeRegistry().forwardDeclareType(provide);\n                }\n            }\n\n            try {\n                inputs = \n                    (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n                    .manageDependencies(options.dependencyOptions, inputs);\n                staleInputs = true;\n            } catch (CircularDependencyException e) {\n                report(JSError.make(\n                    JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            } catch (MissingProvideException e) {\n                report(JSError.make(\n                    MISSING_ENTRY_ERROR, e.getMessage()));\n\n                // If in IDE mode, we ignore the error and keep going.\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n        }\n\n        hoistNoCompileFiles();\n\n        if (staleInputs) {\n            repartitionInputs();\n\n            // Re-order input modules according to the new input ordering.\n            if (modules != null && moduleGraph == null) {\n                // Sort the source files list in each JSModule to match the input order.\n                Map<CompilerInput, Integer> orderMap = new HashMap<>();\n                int index = 0;\n                for (CompilerInput input : inputs) {\n                    orderMap.put(input, index++);\n                }\n                for (JSModule m : modules) {\n                    List<CompilerInput> oldInputs = m.getInputs();\n                    List<CompilerInput> orderedInputs = new ArrayList<>(oldInputs);\n                    orderedInputs.sort(Comparator.comparingInt(orderMap::get));\n                    m.removeAll();\n                    for (CompilerInput orderedInput : orderedInputs) {\n                        m.add(orderedInput);\n                    }\n                }\n            }\n        }\n\n        // Build the AST.\n        for (CompilerInput input : inputs) {\n            Node n = input.getAstRoot(this);\n            if (n == null) {\n                continue;\n            }\n\n            if (devMode) {\n                runSanityCheck();\n                if (hasErrors()) {\n                    return null;\n                }\n            }\n\n            if (options.sourceMapOutputPath != null ||\n                options.nameReferenceReportPath != null) {\n\n                // Annotate the nodes in the tree with information from the\n                // input file. This information is used to construct the SourceMap.\n                SourceInformationAnnotator sia =\n                    new SourceInformationAnnotator(\n                        input.getName(), options.devMode != DevMode.OFF);\n                NodeTraversal.traverse(this, n, sia);\n            }\n\n            jsRoot.addChildToBack(n);\n        }\n\n        if (hasErrors()) {\n            return null;\n        }\n        return externAndJsRoot;\n    } finally {\n        stopTracer(tracer, \"parseInputs\");\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}