{
    "generation": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (tb.isWhitespace(c)) { // Use tb.isWhitespace to align with spec\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) { // Loop limit is heuristic, spec doesn't specify 8.\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb); // Not active, treat as normal end tag.\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true; // Not on stack, remove from active list and ignore tag.\n                            } else if (!tb.inScope(formatEl.nodeName())) {\n                                tb.error(this);\n                                return false; // Not in scope, ignore tag.\n                            } else if (tb.currentElement() != formatEl) {\n                                tb.error(this);\n                                // Spec doesn't mandate error here, just proceeds with AAA.\n                            }\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null; // Element below formatEl in original code logic\n                            boolean seenFormattingElement = false;\n                            LinkedList<Element> stack = tb.getStack();\n                            // Scan stack upwards to find furthest block and position of formatEl.\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) { // Limit 64 is safety measure.\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    if(si > 0) commonAncestor = stack.get(si - 1); // Original code's commonAncestor logic (element below formatEl)\n                                    seenFormattingElement = true;\n                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n                                    furthestBlock = el; // Found first special element above formatEl.\n                                    break;\n                                }\n                            }\n\n                            if (furthestBlock == null) { // No special node found above formatEl in stack.\n                                tb.popStackToClose(formatEl.nodeName()); // Pop stack up to and including formatEl.\n                                tb.removeFromActiveFormattingElements(formatEl); // Remove from active list.\n                                return true; // Done.\n                            }\n\n                            // Adoption Agency Algorithm main part: Steps 12-19\n                            Element node = furthestBlock; // Start from the furthest block.\n                            Element lastNode = furthestBlock;\n                            INNER: // Inner loop processing elements between furthest block and formatEl.\n                            for (int j = 0; j < 3; j++) { // Heuristic limit 3. Spec requires looping until formatEl is reached.\n                                // Find element below current node ('node') on stack. Assume aboveOnStack gets element below.\n                                if (tb.onStack(node))\n                                     node = tb.aboveOnStack(node); // Get element below node on stack (closer to formatEl)\n                                if (node == null) break INNER; // Safety break if null\n\n                                if (!tb.isInActiveFormattingElements(node)) { // If node not in active formatting list\n                                    tb.removeFromStack(node); // Remove it from stack\n                                    continue INNER; // Continue to next iteration\n                                } else if (node == formatEl) { // If node is the formatting element\n                                    break INNER; // Reached formatEl, exit inner loop.\n                                }\n\n                                // Clone node, create replacement, copy attributes. (Spec Step 13.4)\n                                Element replacement = tb.createElement(node.nodeName()); // Use tb.createElement if available\n                                replacement.attributes().addAll(node.attributes()); // *** FIX 3: Copy attributes to replacement ***\n\n                                // Replace node with replacement in active list and stack.\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement; // node is now the replacement\n\n                                // Append lastNode (element processed in previous iteration or furthestBlock initially) to the new node. (Spec Step 13.6)\n                                if (lastNode == furthestBlock) {\n                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements. (Spec Step 13.5)\n                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove(); // Detach lastNode from its parent.\n                                node.appendChild(lastNode); // Append lastNode as child of new node.\n\n                                lastNode = node; // Update lastNode for the next iteration. (Spec Step 13.7)\n                            } // End INNER loop. lastNode is now the top element of the reconstructed chain.\n\n                            // Insert the reconstructed chain (lastNode) into the DOM. (Spec Step 14)\n                            // Uses commonAncestor found earlier (element below formatEl per original code). Foster parent if needed.\n                            // Note: Spec's common ancestor is element *below* furthestBlock. This code uses element *below* formatEl. This might be incorrect per spec.\n                            if (commonAncestor != null) { // Check if commonAncestor (as defined by this code) exists\n                                if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                    if (lastNode.parent() != null)\n                                        lastNode.remove();\n                                    tb.insertInFosterParent(lastNode);\n                                } else {\n                                    if (lastNode.parent() != null)\n                                        lastNode.remove();\n                                    commonAncestor.appendChild(lastNode);\n                                }\n                            } // Else: commonAncestor was null, insertion logic might need review based on how commonAncestor is determined.\n\n\n                            // Create adopter element (clone of formatEl), copy attributes. (Spec Step 15)\n                            Element adopter = tb.createElement(formatEl.nodeName()); // Use tb.createElement if available\n                            adopter.attributes().addAll(formatEl.attributes()); // *** FIX 1: Copy attributes ***\n\n                            // Move children of furthestBlock to adopter. (Spec Step 16)\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // Append moves the node.\n                            }\n                            // Append adopter to furthestBlock. (Spec Step 17)\n                            furthestBlock.appendChild(adopter);\n\n                            // Update active formatting elements list: remove formatEl, insert adopter at bookmark. (Spec Step 18)\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // Note: Spec requires inserting adopter at bookmark. Push might be approximation if bookmark/positional insert unavailable.\n                            tb.pushActiveFormattingElements(adopter); // *** FIX 2: Re-add adopter to active list ***\n\n                            // Update stack: remove formatEl, insert adopter on stack after furthestBlock. (Spec Step 19)\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter); // Insert adopter onto stack\n\n                            // AAA has run for one element. Break the outer loop as per spec (\"run these steps\").\n                             break OUTER;\n                        } // End OUTER loop\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        // Corrected logic: Check if the element 'name' is in scope.\n                        if (!tb.inScope(name)) { // *** FIX: Check variable name, not literal string \"name\" ***\n                             // If not in scope:\n                             if (!tb.inScope(\"object\")) { // Check scope again with \"object\" for applet/marquee? Spec says check tag name. This seems redundant/wrong. Let's stick to checking 'name'.\n                                 tb.error(this);\n                                 return false; // Ignore tag if not in scope\n                             }\n                             // If the outer check already established !inScope(name), this inner part seems unreachable unless inScope(\"object\") differs.\n                             // Assuming the primary check !tb.inScope(name) is correct based on spec.\n                             // Original code had: if (!tb.inScope(\"name\")) { if (!tb.inScope(name)) { ... } } which was likely a typo.\n                        }\n                        // If in scope:\n                        tb.generateImpliedEndTags();\n                        if (!tb.currentElement().nodeName().equals(name)) {\n                             tb.error(this); // Error if current element doesn't match.\n                        }\n                        tb.popStackToClose(name); // Pop stack up to and including name.\n                        tb.clearFormattingElementsToLastMarker(); // Clear active formatting elements up to last marker.\n\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false; // Ignore original </br> tag.\n                    } else {\n                        return anyOtherEndTag(t, tb); // Handle other end tags.\n                    }\n\n                    break; // Break for EndTag case\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true; // Handled token.\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}