{
    "generation": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast();\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                            \"p\", \"section\", \"summary\", \"ul\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.in(name,\n                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            tb.reconstructFormattingElements();\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask.\n                        startTag.name(\"img\");\n                        return tb.process(startTag);\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null)\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english.\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\");\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.in(name,\n                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.in(name,\n                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n                        // todo: refactor these lookups\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        Element currentForm = tb.getFormElement();\n                        tb.setFormElement(null);\n                        if (currentForm == null || !tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        }\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.in(name,\n                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) { // Run algorithm up to 8 times\n                            Element formatEl = tb.getActiveFormattingElement(name); // Step 1: Find element\n                            if (formatEl == null) // Not in active formatting elements\n                                return anyOtherEndTag(t, tb); // Spec: \"nothing to be done\" / treat as any other tag\n\n                            if (!tb.onStack(formatEl)) { // Step 2a: Not on stack of open elements\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl); // Remove from active list\n                                return true; // Abort this algorithm iteration\n                            }\n\n                            if (!tb.inScope(formatEl.nodeName())) { // Step 2b: Not in scope\n                                tb.error(this);\n                                return false; // Ignore the end tag\n                            }\n\n                            // Element is active, on stack, and in scope\n                            if (tb.currentElement() != formatEl) // Step 3: Check if not current node\n                                tb.error(this); // Log error, but continue algorithm\n\n                            Element furthestBlock = null; // Step 4: Find furthest block\n                            int formatElPos = tb.getStack().indexOf(formatEl);\n                            if (formatElPos == -1) { // Should not happen given onStack check, but be defensive\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true; // Abort\n                            }\n\n                            // Search *below* formatEl (towards root, lower indices) for the topmost special element\n                            for (int pos = formatElPos - 1; pos >= 0; pos--) {\n                                Element candidate = tb.getStack().get(pos);\n                                if (tb.isSpecial(candidate)) {\n                                    furthestBlock = candidate;\n                                    break;\n                                }\n                            }\n\n                            if (furthestBlock == null) { // Step 5: No furthest block found\n                                tb.popStackToClose(formatEl.nodeName()); // Pop up to and including formatEl\n                                tb.removeFromActiveFormattingElements(formatEl); // Remove from active list\n                                return true; // Abort algorithm\n                            }\n\n                            // Step 6: Find common ancestor (element immediately *above* formatEl in stack)\n                            Element commonAncestor = null;\n                            // Check if formatEl is not already the top element\n                            if (formatElPos + 1 < tb.getStack().size()) {\n                                 commonAncestor = tb.getStack().get(formatElPos + 1);\n                            } else {\n                                // This case implies formatEl is the current element, which should mean\n                                // furthestBlock was null, leading to the simple pop case above.\n                                // If we reach here, it might be an unexpected state.\n                                // Let the algorithm continue; step 9 handles commonAncestor potentially being null.\n                            }\n\n\n                            // Step 7: Bookmark (not explicitly implemented, relies on list/stack ops)\n\n                            // Step 8: Node manipulation loop\n                            Element node = furthestBlock; // Start just below furthest block\n                            Element lastNode = furthestBlock;\n                            INNER:\n                            for (int j = 0; j < 3; j++) {\n                                // 8.4: Find node immediately *above* the current `node` in stack\n                                int nodePos = tb.getStack().indexOf(node);\n                                // Check if node is on stack and not the top element\n                                if (nodePos == -1 || nodePos + 1 >= tb.getStack().size()) {\n                                     break INNER; // Cannot go further up or node missing\n                                }\n                                Element nextNode = tb.getStack().get(nodePos + 1);\n                                node = nextNode;\n\n                                // 8.5: If node is not an active formatting element\n                                if (!tb.isInActiveFormattingElements(node)) {\n                                    tb.removeFromStack(node);\n                                    // Continue loop processing from the same relative position.\n                                    // The counter `j` increments, but we effectively skip processing this node.\n                                    // The `node` variable is already updated for the next iteration or break.\n                                    // This GOTO logic is tricky; this removal might be sufficient.\n                                    continue INNER; // Go to next iteration of INNER loop\n                                }\n\n                                // 8.6: If node is the formatting element itself\n                                if (node == formatEl) {\n                                    break INNER;\n                                }\n\n                                // 8.7: Create replacement element\n                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                replacement.attributes().addAll(node.attributes()); // Copy attributes\n\n                                // Replace node with replacement in active list and stack\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement; // Use the replacement going forward\n\n                                // 8.8: Bookmark (ignored)\n\n                                // 8.9: Insert lastNode into node\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                // 8.10: Update lastNode to the current node (which might be a replacement)\n                                lastNode = node;\n\n                                // 8.11: Loop continues (controlled by `j`)\n                            } // END INNER LOOP (Step 8)\n\n                            // Step 9: Insert last node into appropriate place\n                            if (lastNode.parent() != null) // Detach lastNode first\n                                lastNode.remove();\n\n                            // Determine insertion point based on commonAncestor\n                            if (commonAncestor != null && StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                tb.insertInFosterParent(lastNode);\n                            } else if (commonAncestor != null) {\n                                commonAncestor.appendChild(lastNode);\n                            } else {\n                                // If commonAncestor was null (e.g., formatEl was the current element initially)\n                                // The insertion point should be the parent of formatEl according to spec interpretation.\n                                // However, the original code might imply foster parenting as default?\n                                // Fallback: append to parent of formatEl. If no parent, error.\n                                Element parent = formatEl.parent();\n                                if (parent != null) parent.appendChild(lastNode);\n                                else tb.error(this); // Error: Cannot determine insertion point\n                            }\n\n\n                            // Step 10: Create adopter element for formatEl\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes()); // Copy attributes\n\n                            // Step 11: Move children from furthest block to adopter\n                            // Use toArray to avoid ConcurrentModificationException when reparenting\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // appendChild reparents nodes\n                            }\n\n                            // Step 12: Append adopter to furthest block\n                            furthestBlock.appendChild(adopter);\n\n                            // Step 13: Remove original formatEl from active list, insert adopter (approximate bookmark)\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // Insert adopter at the position of the bookmark. Implementation detail varies.\n                            // Inserting based on stack position (below furthestBlock) might be a close approximation.\n                            // The original code just pushed; let's stick with that for simplicity unless further issues arise.\n                            tb.pushActiveFormattingElements(adopter);\n\n                            // Step 14: Remove original formatEl from stack, insert adopter below furthest block\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter); // Insert adopter into stack\n\n                            // Algorithm finished for this instance; OUTER loop continues for potential nested cases.\n                        } // END OUTER LOOP\n\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        // Note: 'inScope(\"name\")' was a typo in original code, should be inScope(name)\n                        if (!tb.inScope(name)) { // Corrected scope check\n                            // If the element is not in scope, but there is an active formatting element\n                            // marker for it, it implies misnested content that should be closed.\n                            // However, the spec for these elements seems to only require inScope check.\n                            // Let's follow the original logic structure which checks inScope(name) first.\n                            tb.error(this);\n                            return false; // Ignore tag if not in scope\n                        }\n                        // Element is in scope\n                        tb.generateImpliedEndTags();\n                        if (!tb.currentElement().nodeName().equals(name)) {\n                            tb.error(this);\n                        }\n                        tb.popStackToClose(name); // Pop up to and including the element\n                        tb.clearFormattingElementsToLastMarker(); // Clear active formatting elements up to the marker inserted by start tag\n\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}