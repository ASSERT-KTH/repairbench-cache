{
    "generation": "        boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        // todo confirm that check\n                        tb.error(this);\n                        return false;\n                    } else if (isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        if (tb.isFragmentParsing()) break; // ignore html tag in fragment case\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\")) || tb.isFragmentParsing()) {\n                            // only in fragment case or specific stack states\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case or specific stack states\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n                        } else {\n                            Element second = stack.get(1);\n                            if (second.parent() != null)\n                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.removeLast(); // simpler than tb.pop() which has side effects\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        // todo: ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\"));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        LinkedList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.process(new Token.EndTag(el.nodeName()));\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            // close and reprocess\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag);\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\"));\n\n                            // still on stack?\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a);\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\"));\n                            // reconstructFormattingElements is called via process end tag adoption agency. Handle there.\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements();\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n                        tb.insertEmpty(startTag);\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) {\n                        // we're not supposed to ask. Also, parsing this as inputEncoding=Image, requires GIGO support beyond current capabilities.\n                        // If image has src, rewrite to img, otherwise process as unknown tag. See #1060\n                        if(startTag.attributes.get(\"src\") == null)\n                            return tb.process(startTag, AnyOther); // process as unknown tag\n\n                        startTag.name(\"img\"); // treat as img\n                        return tb.process(startTag); // re-process dispatcher\n                    } else if (name.equals(\"isindex\")) {\n                        // how much do we care about the early 90s?\n                        tb.error(this);\n                        if (tb.getFormElement() != null && !tb.isFragmentParsing())\n                            return false;\n\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement();\n                            if (form != null) // null check form, as process() may not have created it if already had one in scope\n                                form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        // hope you like english. really?\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                startTag.attributes.get(\"prompt\") :\n                                \"This is a searchable index. Enter search keywords: \";\n\n                        tb.process(new Token.Character(prompt));\n\n                        // input element\n                        Attributes inputAttribs = new Attributes();\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n                                inputAttribs.put(attr);\n                        }\n                        inputAttribs.put(\"name\", \"isindex\"); // default name is isindex, comes after specific excludes, so does not override if supplied\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        tb.process(new Token.EndTag(\"label\"));\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode();\n                        tb.framesetOk(false);\n                        tb.transition(Text);\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.process(new Token.EndTag(\"p\"));\n                        }\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"noembed\")) {\n                        // also handle noscript if script enabled\n                        handleRawtext(startTag, tb);\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n\n                        HtmlTreeBuilderState state = tb.state();\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else\n                            tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n                        if (tb.currentElement().nodeName().equals(\"option\"))\n                            tb.process(new Token.EndTag(\"option\"));\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n                        if (tb.inScope(\"ruby\")) {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                            }\n                            tb.insert(startTag);\n                        }\n                    } else if (name.equals(\"math\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (name.equals(\"svg\")) {\n                        tb.reconstructFormattingElements();\n                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n                        tb.error(this);\n                        return false;\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.name();\n                    if (name.equals(\"body\")) {\n                        if (!tb.inScope(\"body\")) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                            tb.transition(AfterBody);\n                        }\n                    } else if (name.equals(\"html\")) {\n                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n                        if (notIgnored)\n                            return tb.process(endTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n                        if (!tb.inScope(name)) {\n                            // nothing to close\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"form\")) {\n                        if (!tb.isFragmentParsing()) {\n                            Element currentForm = tb.getFormElement();\n                            tb.setFormElement(null);\n                            if (currentForm == null || !tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            // remove currentForm from stack. will shift anything under up.\n                            tb.removeFromStack(currentForm);\n                        } else { // fragment parsing mode\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n\n                    } else if (name.equals(\"p\")) {\n                        if (!tb.inButtonScope(name)) {\n                            tb.error(this);\n                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n                            return tb.process(endTag);\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (name.equals(\"li\")) {\n                        if (!tb.inListItemScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        if (!tb.inScope(name)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (!tb.inScope(Constants.Headings)) {\n                            tb.error(this);\n                            return false;\n                        } else {\n                            tb.generateImpliedEndTags(name);\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(Constants.Headings);\n                        }\n                    } else if (name.equals(\"sarcasm\")) {\n                        // *sigh*\n                        return anyOtherEndTag(t, tb);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                        // Adoption Agency Algorithm.\n                        OUTER:\n                        for (int i = 0; i < 8; i++) {\n                            Element formatEl = tb.getActiveFormattingElement(name);\n                            if (formatEl == null)\n                                return anyOtherEndTag(t, tb); // nothing to do here\n                            else if (!tb.onStack(formatEl)) {\n                                tb.error(this);\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            } else if (!tb.inScope(formatEl.nodeName())) { // Should not happen?\n                                tb.error(this);\n                                return false;\n                            } else if (tb.currentElement() != formatEl) {\n                                tb.error(this);\n                                // Adoption agency steps detailed below\n                            } else {\n                                // Simple case: closing the current element. Hit when the formatting element is topmost on stack.\n                                tb.pop();\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            Element furthestBlock = null;\n                            Element commonAncestor = null;\n                            //boolean seenFormattingElement = false; // unused\n                            LinkedList<Element> stack = tb.getStack();\n                            // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents run-aways\n                            final int stackSize = stack.size();\n                            for (int si = 0; si < stackSize && si < 64; si++) { // search up stack\n                                Element el = stack.get(si);\n                                if (el == formatEl) {\n                                    commonAncestor = stack.get(si - 1); // requires si > 0, but formatEl should not be root\n                                    //seenFormattingElement = true; // unused\n                                    // Find the furthest block *below* the formatting element\n                                    for (int blockSi = si -1 ; blockSi >= 0; blockSi--) {\n                                        Element blockEl = stack.get(blockSi);\n                                        if(tb.isSpecial(blockEl)) {\n                                            furthestBlock = blockEl;\n                                            break;\n                                        }\n                                    }\n                                    break; // found formatEl, exit stack scan\n                                }\n                            }\n\n                            if (furthestBlock == null) { // could not find a special block below node, so adopt is simpler\n                                tb.popStackToClose(formatEl.nodeName());\n                                tb.removeFromActiveFormattingElements(formatEl);\n                                return true;\n                            }\n\n                            // Adoption Notes:\n                            // Outer loop is required as multiple active formatting elements may exist for the same tag name.\n                            // Each loop iteration assesses the state for the nearest formatEl that matches the tag name.\n\n                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list. Does not seem required for jsoup implementation.\n\n                            Element node = furthestBlock;\n                            Element lastNode = furthestBlock;\n                            // Find nodes between furthest block and format el\n                            // The nodes are cloned and inserted according to the Agency algorithm.\n\n                            // INNER loop: Step 10. Look for elements to adopt or ignore.\n                            INNER: for (int j = 0; j < 3; j++) { // Limit loops to prevent runaway state matches\n                                // Move up the stack to find the elements between the furthest block and the formatting element.\n                                node = tb.aboveOnStack(node); // Step 10.1\n                                if (node == null || !tb.onStack(node)) break INNER; // safety break\n\n                                if (!tb.isInActiveFormattingElements(node)) { // Step 10.2\n                                    tb.removeFromStack(node); // Step 10.2.1\n                                    continue INNER; // Step 10.2.2\n                                } else if (node == formatEl) { // Step 10.3\n                                    break INNER;\n                                }\n                                // Step 10.4 and 10.5: Create new element, replace AFE & stack, point node to replacement.\n                                Element replacement = new Element(Tag.valueOf(node.nodeName(), tb.settings), tb.getBaseUri());\n                                // we don't need to copy attributes as the replacement will be adopted.\n                                tb.replaceActiveFormattingElement(node, replacement);\n                                tb.replaceOnStack(node, replacement);\n                                node = replacement; // Point node to the replacement for future steps.\n\n                                // Step 10.6 - 10.8: Reparent lastNode to node, update lastNode.\n                                // If lastNode is the furthestBlock, the bookmark logic would apply. Ignoring that specific detail for now.\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            } // END INNER Loop\n\n                            // Step 11: If commonAncestor is null, this could be a case where formatEl is outside a table. Handled by foster parenting.\n                            // fosterInBody / fosterInTable methods determine correct insertion location.\n                            // Note: commonAncestor is the element immediately above the furthestBlock. It may be null/removed from stack by this point.\n                            // Instead, use the parent of the furthestBlock for foster checks.\n                            if (lastNode.parent() != null)\n                                lastNode.remove(); // Detach the adopted structure from its previous parent.\n\n                            // Check the parent of the furthest block for table context to enable foster parenting.\n                            Element fosterParent = furthestBlock.parent();\n                            if (fosterParent != null && StringUtil.inSorted(fosterParent.nodeName(), Constants.InBodyEndTableFosters)) {\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                commonAncestor.appendChild(lastNode); // Append the adopted structure to the common ancestor.\n                            }\n\n\n                            // Step 12: Create new element for the formatting element.\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes()); // copy attributes\n\n                            // Step 13: Move children of the furthest block to the adopter.\n                            // The spec says \"Append all the nodes from the furthest block's content...\", implying children.\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[0]); // clone to avoid concurrent mod\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent.\n                            }\n                            furthestBlock.appendChild(adopter); // Append the adopter to the furthest block.\n\n                            // Step 14: Remove formatEl from AFE list.\n                            tb.removeFromActiveFormattingElements(formatEl);\n\n                            // Step 15: Remove formatEl from stack.\n                            tb.removeFromStack(formatEl);\n\n                            // Step 16: Insert the adopter onto stack after the furthestBlock.\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n\n                            // Step 17: Re-insert the adopter into the AFE list? The spec is complex here regarding bookmarks.\n                            // Jsoup's implementation implicitly handles this by continuing the outer loop,\n                            // potentially finding the newly inserted `adopter` if needed for subsequent end tags.\n                            // No explicit re-insertion step needed here based on current understanding.\n\n                        } // END OUTER Loop\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) { // applet, marquee, object\n                        if (!tb.inScope(\"name\")) { // ignore name = \"name\" check in original. Test scope for tag name.\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name)) {\n                                tb.error(this);\n                            }\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.process(new Token.StartTag(\"br\"));\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}