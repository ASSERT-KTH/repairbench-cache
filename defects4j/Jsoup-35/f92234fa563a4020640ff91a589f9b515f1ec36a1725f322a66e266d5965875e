{
    "generation": "import org.jsoup.helper.StringUtil; // Ensure necessary imports are available if this were standalone\nimport org.jsoup.internal.Normalizer;\nimport org.jsoup.nodes.Attribute;\nimport org.jsoup.nodes.Attributes;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.parser.ParseSettings;\nimport org.jsoup.parser.CharacterReader;\nimport org.jsoup.parser.Tag;\nimport org.jsoup.parser.Token;\nimport org.jsoup.parser.Tokeniser;\nimport org.jsoup.parser.TokeniserState;\n\nimport java.util.ArrayList; // Use ArrayList for stack type\nimport java.util.Arrays;\n\nimport static org.jsoup.parser.HtmlTreeBuilderState.AfterBody;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InBody;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InCaption;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InCell;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InFrameset;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InHead;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InRow;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InSelect;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InSelectInTable;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InTable;\nimport static org.jsoup.parser.HtmlTreeBuilderState.InTableBody;\nimport static org.jsoup.parser.HtmlTreeBuilderState.Text;\n\n\n// Dummy classes for context matching original code structure\nabstract class HtmlTreeBuilderState {\n    // Assume constants defined in the real context\n    static final String nullString = String.valueOf('\\u0000');\n\n    abstract boolean process(Token t, HtmlTreeBuilder tb);\n\n    // Assume static helper method exists in the real context\n    static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n         tb.insert(startTag);\n         tb.tokeniser.transition(TokeniserState.RAWTEXT);\n         tb.markInsertionMode();\n         tb.transition(Text);\n    }\n\n    // Assume helper method exists in the real context\n    boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n        String name = t.asEndTag().normalName(); // Use normalized name\n        ArrayList<Element> stack = tb.getStack();\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (node.normalName().equals(name)) {\n                tb.generateImpliedEndTags(name);\n                // Check current node is the node we were looking for (might have been popped by implied tags)\n                if (!tb.currentElement().normalName().equals(name))\n                    tb.error(this);\n                tb.popStackToClose(name);\n                break;\n            } else {\n                if (tb.isSpecial(node)) {\n                    tb.error(this);\n                    return false;\n                }\n            }\n        }\n        return true; // Return value indicates if token was handled\n    }\n\n    // Constants assumed to be accessible (defined in HtmlTreeBuilderState or HtmlTreeBuilder)\n    static class Constants {\n        static final String[] InHeadTags = {\"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\"};\n        static final String[] HeadingsTags = {\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"};\n        static final String[] BlockTags = {\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"main\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\"};\n        static final String[] ListingPreTags = {\"listing\", \"pre\"};\n        static final String[] DdDt = {\"dd\", \"dt\"};\n        static final String[] Formatters = {\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        static final String[] ObjectTags = {\"applet\", \"marquee\", \"object\"};\n        static final String[] MediaTags = {\"param\", \"source\", \"track\"};\n        static final String[] Isindexkeys = {\"action\", \"name\", \"prompt\"};\n        static final String[] OptionOptgroup = {\"optgroup\", \"option\"};\n        static final String[] RpRt = {\"rp\", \"rt\"};\n        static final String[] TableOther = {\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"};\n        static final String[] LiClosers = {\"address\", \"div\", \"p\"};\n        static final String[] EmptyBodyTags = {\"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\"};\n\n        static final String[] InBodyEndTags = {\"a\", \"address\", \"applet\", \"article\", \"aside\", \"b\", \"big\", \"blockquote\", \"body\", \"br\", \"button\", \"center\", \"code\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"em\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"header\", \"hgroup\", \"html\", \"i\", \"li\", \"listing\", \"main\", \"marquee\", \"menu\", \"nav\", \"nobr\", \"object\", \"ol\", \"p\", \"pre\", \"s\", \"section\", \"small\", \"strike\", \"strong\", \"summary\", \"tt\", \"u\", \"ul\"};\n        static final String[] InBodyEndAdoptionFormatters = {\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\n        static final String[] InBodyEndClosers = {\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"main\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\"}; // Added button here based on spec\n        static final String[] InBodyEndTableFosters = {\"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\"};\n        static final String[] InBodyEndEofClosers = {\"dd\", \"dt\", \"li\", \"optgroup\", \"option\", \"p\", \"rp\", \"rt\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"body\", \"html\"};\n\n        static { // Sort arrays for StringUtil.inSorted lookups\n            Arrays.sort(InHeadTags); Arrays.sort(HeadingsTags); Arrays.sort(BlockTags); Arrays.sort(ListingPreTags);\n            Arrays.sort(DdDt); Arrays.sort(Formatters); Arrays.sort(ObjectTags); Arrays.sort(MediaTags);\n            Arrays.sort(Isindexkeys); Arrays.sort(OptionOptgroup); Arrays.sort(RpRt); Arrays.sort(TableOther);\n            Arrays.sort(LiClosers); Arrays.sort(EmptyBodyTags);\n            Arrays.sort(InBodyEndTags); Arrays.sort(InBodyEndAdoptionFormatters); Arrays.sort(InBodyEndClosers);\n            Arrays.sort(InBodyEndTableFosters); Arrays.sort(InBodyEndEofClosers);\n        }\n    }\n}\n\n// Dummy HtmlTreeBuilder for context - actual class has these methods/fields\nclass HtmlTreeBuilder {\n    ArrayList<Element> stack = new ArrayList<>();\n    ArrayList<Element> formattingElements = new ArrayList<>();\n    Document doc;\n    Element formElement;\n    String baseUri;\n    Tokeniser tokeniser;\n    ParseSettings settings;\n    CharacterReader reader;\n    Document.QuirksMode quirksMode;\n    boolean framesetOk = true;\n    HtmlTreeBuilderState state;\n    String originalState;\n    boolean scriptingEnabled;\n    boolean fragmentParsing;\n\n    void error(HtmlTreeBuilderState state) {}\n    void reconstructFormattingElements() {}\n    void insert(Token.Character c) {}\n    void insert(Token.Comment c) {}\n    Element insert(Token.StartTag t) { return null; }\n    Element insertEmpty(Token.StartTag t) { return null; }\n    void insertInFosterParent(Node n) {}\n    void insertMarkerToFormattingElements() {}\n    void insertForm(Token.StartTag t, boolean b) {}\n    void transition(HtmlTreeBuilderState s) {}\n    boolean process(Token t, HtmlTreeBuilderState s) { return true; }\n    boolean process(Token t) { return true; }\n    ArrayList<Element> getStack() { return stack; }\n    Element currentElement() { return stack.isEmpty() ? null : stack.get(stack.size()-1); }\n    Element getFromStack(String name) { return null; }\n    boolean removeFromStack(Element el) { return false; }\n    void pop() {}\n    void popStackToClose(String... names) {}\n    void popStackToClose(String name) {}\n    void popStackToBefore(String name) {}\n    void generateImpliedEndTags(String name) {}\n    void generateImpliedEndTags() {}\n    boolean inScope(String name) { return false; }\n    boolean inScope(String[] names) { return false; }\n    boolean inListItemScope(String name) { return false; }\n    boolean inButtonScope(String name) { return false; }\n    boolean isSpecial(Element el) { return false; }\n    void framesetOk(boolean b) {}\n    boolean framesetOk() { return framesetOk; }\n    Document getDocument() { return doc; }\n    String getBaseUri() { return baseUri; }\n    Element getFormElement() { return formElement; }\n    void setFormElement(Element el) {}\n    void pushActiveFormattingElements(Element el) {}\n    Element getActiveFormattingElement(String name) { return null; }\n    boolean isInActiveFormattingElements(Element el) { return false; }\n    void removeFromActiveFormattingElements(Element el) {}\n    void replaceActiveFormattingElement(Element out, Element in) {}\n    void replaceOnStack(Element out, Element in) {}\n    void insertOnStackAfter(Element after, Element in) {}\n    void clearFormattingElementsToLastMarker() {}\n    ArrayList<Element> getActiveFormattingElements() { return formattingElements; }\n    boolean isFragmentParsing() { return fragmentParsing; }\n    void markInsertionMode() {}\n    void resetInsertionMode() {}\n    boolean isWhitespace(Token.Character c) { return StringUtil.isBlank(c.getData()); }\n    boolean isScriptingEnabled() { return scriptingEnabled; }\n    boolean isQuirksMode() { return quirksMode == Document.QuirksMode.quirks; }\n    Element createElement(String normalName) { return new Element(Tag.valueOf(normalName, settings), baseUri); } // Assume Tag/ParseSettings available\n    boolean isElementInQueue(Element element) { return false; }\n    Element getFurthestBlockFormattingElement(Element formatEl) { return null; }\n    void errorIfSortedBogus(String[] allowedTags) {}\n    HtmlTreeBuilderState state() { return state; }\n}\n\n// Fixed InBody class\nclass InBody extends HtmlTreeBuilderState {\n    @Override\n    boolean process(Token t, HtmlTreeBuilder tb) {\n            switch (t.type) {\n                case Character: {\n                    Token.Character c = t.asCharacter();\n                    if (c.getData().equals(nullString)) {\n                        tb.error(this);\n                        return false; // ignore null char\n                    } else if (tb.isWhitespace(c)) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                    } else {\n                        tb.reconstructFormattingElements();\n                        tb.insert(c);\n                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false; // ignore token\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.normalName(); // Use normalized name\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        if (tb.isFragmentParsing()) return true; // ignore in fragment\n                        Element html = tb.getStack().get(0);\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.InHeadTags)) {\n                        return tb.process(t, InHead); // Process in Head state\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\")) || tb.isFragmentParsing()) {\n                            return false; // ignore in fragment or if body not second element\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        ArrayList<Element> stack = tb.getStack();\n                        // Omit !tb.isFragmentParsing() check for frameset because it's ignored in fragments anyway? Check spec. Yes, fragment check suffices.\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\")) || tb.isFragmentParsing()) {\n                             return false; // ignore in fragment or bad stack\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore if frameset not ok\n                        } else {\n                            Element second = stack.get(1); // body element\n                            if (second.parent() != null) second.remove(); // detach body\n                            while (stack.size() > 1) stack.remove(stack.size() -1); // pop stack up to html\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.BlockTags)) { // Includes p\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.HeadingsTags)) {\n                         if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        if (tb.currentElement() != null && StringUtil.inSorted(tb.currentElement().normalName(), Constants.HeadingsTags)) {\n                            tb.error(this);\n                            tb.pop(); // close previous heading\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.ListingPreTags)) {\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insert(startTag);\n                        // TODO: Access CharacterReader needed: tb.reader.matchConsume(\"\\n\"); // Ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) {\n                            tb.error(this);\n                            return false; // ignore if form already open in non-fragment\n                        }\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insertForm(startTag, true); // inserts and sets form element\n                    } else if (name.equals(\"li\")) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) { // Search up stack\n                            Element el = stack.get(i);\n                            if (el.nodeName().equals(\"li\")) {\n                                tb.process(new Token.EndTag(\"li\")); // close previous li\n                                break;\n                            }\n                            // spec: stop when hitting an element in the \"special\" category that IS NOT <address>, <div>, <p>\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.LiClosers))\n                                break; // stop search\n                        }\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) { // Search up stack\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.process(new Token.EndTag(el.nodeName())); // close previous dd/dt\n                                break;\n                            }\n                            // spec: stop when hitting an element in the \"special\" category that IS NOT <address>, <div>, <p> (Same condition as li)\n                             if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.LiClosers))\n                                break;\n                        }\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insert(startTag);\n                    } else if (name.equals(\"plaintext\")) {\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insert(startTag);\n                        tb.tokeniser.transition(TokeniserState.PLAINTEXT);\n                    } else if (name.equals(\"button\")) {\n                        if (tb.inButtonScope(\"button\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"button\"));\n                            tb.process(startTag); // reprocess start tag\n                        } else {\n                            tb.reconstructFormattingElements();\n                            tb.insert(startTag);\n                            tb.framesetOk(false);\n                        }\n                    } else if (name.equals(\"a\")) {\n                        if (tb.getActiveFormattingElement(\"a\") != null) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"a\")); // Run AAA to close previous <a>\n                            // If AAA created duplicates, remove them from stack and AFE list\n                            Element remainingA = tb.getFromStack(\"a\");\n                            if (remainingA != null) {\n                                tb.removeFromActiveFormattingElements(remainingA);\n                                tb.removeFromStack(remainingA);\n                            }\n                        }\n                        tb.reconstructFormattingElements();\n                        Element a = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(a); // Add this <a> to AFE list\n                    } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el); // Add to AFE list\n                    } else if (name.equals(\"nobr\")) {\n                        tb.reconstructFormattingElements();\n                        if (tb.inScope(\"nobr\")) {\n                            tb.error(this);\n                            tb.process(new Token.EndTag(\"nobr\")); // Run AAA for nobr\n                        }\n                        Element el = tb.insert(startTag);\n                        tb.pushActiveFormattingElements(el); // Add to AFE list\n                    } else if (StringUtil.inSorted(name, Constants.ObjectTags)) { // applet, marquee, object\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.insertMarkerToFormattingElements(); // Add marker to AFE list\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"table\")) {\n                        if (!tb.isQuirksMode() && tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        tb.transition(InTable);\n                    } else if (name.equals(\"input\")) {\n                        tb.reconstructFormattingElements();\n                        Element el = tb.insertEmpty(startTag);\n                        // type=hidden doesn't make frameset non-ok\n                        if (!el.hasAttr(\"type\") || !el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n                            tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.EmptyBodyTags)) { // area, br, embed, img, keygen, wbr\n                        tb.reconstructFormattingElements();\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (StringUtil.inSorted(name, Constants.MediaTags)) { // param, source, track\n                        tb.insertEmpty(startTag); // No AFE reconstruct, no frameset impact\n                    } else if (name.equals(\"hr\")) {\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.insertEmpty(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"image\")) { // an old alias for img\n                        startTag.name(\"img\");\n                        return tb.process(startTag); // Reprocess as img\n                    } else if (name.equals(\"isindex\")) {\n                        tb.error(this);\n                        if (tb.getFormElement() != null && !tb.isFragmentParsing()) return false; // Ignore if form already open in non-fragment\n                        tb.tokeniser.acknowledgeSelfClosingFlag(); // Required by spec\n                        // Build up isindex structure: <form><hr><label>prompt<input name=isindex ...></label></form>\n                        tb.process(new Token.StartTag(\"form\"));\n                        if (startTag.attributes.hasKey(\"action\")) {\n                            Element form = tb.getFormElement(); // Will be non-null after form insertion\n                            if (form != null) form.attr(\"action\", startTag.attributes.get(\"action\"));\n                        }\n                        tb.process(new Token.StartTag(\"hr\"));\n                        tb.process(new Token.StartTag(\"label\"));\n                        String prompt = startTag.attributes.hasKey(\"prompt\") ? startTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \";\n                        tb.process(new Token.Character(prompt));\n                        Attributes inputAttribs = new Attributes();\n                        inputAttribs.put(\"name\", \"isindex\"); // Required name\n                        for (Attribute attr : startTag.attributes) {\n                            if (!StringUtil.inSorted(attr.getKey(), Constants.Isindexkeys)) inputAttribs.put(attr);\n                        }\n                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n                        // Implicitly closed by </form> in spec\n                        tb.process(new Token.EndTag(\"form\"));\n                    } else if (name.equals(\"textarea\")) {\n                        tb.insert(startTag);\n                        // TODO: Access CharacterReader needed: tb.reader.matchConsume(\"\\n\"); // Ignore LF if next token\n                        tb.tokeniser.transition(TokeniserState.Rcdata);\n                        tb.markInsertionMode(); // remember original state (InBody)\n                        tb.framesetOk(false);\n                        tb.transition(Text); // Switch to Text state\n                    } else if (name.equals(\"xmp\")) {\n                        if (tb.inButtonScope(\"p\")) tb.process(new Token.EndTag(\"p\"));\n                        tb.reconstructFormattingElements();\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb); // Use static helper\n                    } else if (name.equals(\"iframe\")) {\n                        tb.framesetOk(false);\n                        handleRawtext(startTag, tb); // Use static helper\n                    } else if (name.equals(\"noembed\")) {\n                        handleRawtext(startTag, tb); // Use static helper\n                     } else if (name.equals(\"noscript\")) { // scripting flag determines if parsed as raw or normal\n                         if (tb.isScriptingEnabled()) handleRawtext(startTag, tb); // treat as raw text\n                         else tb.insert(startTag); // parse as normal HTML\n                    } else if (name.equals(\"select\")) {\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                        HtmlTreeBuilderState state = tb.state();\n                        // Switch state based on context\n                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n                            tb.transition(InSelectInTable);\n                        else tb.transition(InSelect);\n                    } else if (StringUtil.inSorted(name, Constants.OptionOptgroup)) {\n                        if (tb.currentElement() != null && tb.currentElement().nodeName().equals(\"option\")) tb.process(new Token.EndTag(\"option\")); // Close previous option if current element is option\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.RpRt)) {\n                        if (tb.inScope(\"ruby\")) { // only valid inside ruby\n                            tb.generateImpliedEndTags();\n                            if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(\"ruby\")) {\n                                tb.error(this);\n                                tb.popStackToBefore(\"ruby\"); // pop until ruby found\n                            }\n                            tb.insert(startTag);\n                        } // else ignore token\n                    } else if (name.equals(\"math\") || name.equals(\"svg\")) { // Foreign content (MathML, SVG)\n                        tb.reconstructFormattingElements();\n                        // TODO: Implement foreign content parsing (this just inserts a basic element)\n                        tb.insert(startTag);\n                        tb.tokeniser.acknowledgeSelfClosingFlag();\n                    } else if (StringUtil.inSorted(name, Constants.TableOther)) { // caption, col, colgroup, frame, head, tbody, td, tfoot, th, thead, tr\n                        tb.error(this);\n                        return false; // ignore token in InBody\n                    } else { // Any other start tag\n                        tb.reconstructFormattingElements();\n                        tb.insert(startTag);\n                    }\n                    break;\n\n                case EndTag:\n                    Token.EndTag endTag = t.asEndTag();\n                    name = endTag.normalName(); // Use normalized name\n                    if (StringUtil.inSorted(name, Constants.InBodyEndTags)) { // Group end tag logic for efficiency\n                        if (name.equals(\"body\")) {\n                            if (!tb.inScope(\"body\")) {\n                                tb.error(this);\n                                return false; // ignore if body not in scope\n                            } else {\n                                // TODO: tb.errorIfSortedBogus(Constants.InBodyEndEofClosers); // Check stack for non-closers allowed at end\n                                tb.transition(AfterBody); // Switch to AfterBody state\n                            }\n                        } else if (name.equals(\"html\")) {\n                            boolean notIgnored = tb.process(new Token.EndTag(\"body\")); // Process implied </body>\n                            if (notIgnored) return tb.process(endTag); // Reprocess </html> if </body> wasn't ignored\n                            // else ignore </html> token\n                        } else if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) { // AAA Group: a, b, big, code, em, font, i, nobr, s, small, strike, strong, tt, u\n                            // Adoption Agency Algorithm\n                            OUTER:\n                            for (int i = 0; i < 8; i++) {\n                                Element formatEl = tb.getActiveFormattingElement(name);\n                                if (formatEl == null || (!tb.onStack(formatEl) && tb.isElementInQueue(formatEl))) {\n                                    return anyOtherEndTag(t, tb); // AAA Abort 1: Let AnyOtherEndTag handle it\n                                } else if (!tb.onStack(formatEl)) {\n                                    tb.error(this);\n                                    tb.removeFromActiveFormattingElements(formatEl); // AAA Abort 2: Remove from AFE list and return handled\n                                    return true;\n                                } else if (!tb.inScope(formatEl.nodeName())) {\n                                    tb.error(this);\n                                    return false; // AAA Abort 3: Ignore token\n                                } else if (tb.currentElement() != formatEl) {\n                                    tb.error(this); // Error, but continue processing AAA\n                                }\n\n                                Element furthestBlock = tb.getFurthestBlockFormattingElement(formatEl); // Helper to find furthest block\n                                if (furthestBlock == null) { // If no block, just pop up to and including formatEl\n                                    tb.popStackToClose(formatEl.nodeName()); // Includes formatEl\n                                    tb.removeFromActiveFormattingElements(formatEl); // AAA Step 12\n                                    return true;\n                                }\n\n                                // Steps 13-26: Inner loop, node adoption, replacement\n                                Element commonAncestor = tb.getStack().get(tb.getStack().indexOf(formatEl) - 1); // Element above formatEl\n                                int bookmark = tb.getActiveFormattingElements().indexOf(formatEl); // Position in AFE list\n                                Element node = furthestBlock;\n                                Element lastNode = furthestBlock;\n                                int innerLoopCounter = 0;\n\n                                INNER:\n                                while(true) {\n                                    innerLoopCounter++;\n                                    int nodeStackIndex = tb.getStack().lastIndexOf(node); // Find node on stack\n                                    if (nodeStackIndex <= 0) break INNER; // Safety break if node removed or at root\n                                    node = tb.getStack().get(nodeStackIndex - 1); // Node above current node\n\n                                    if (node == formatEl) break INNER; // Found the formatting element\n\n                                    // Inner loop processing based on spec steps 20-26\n                                    if (innerLoopCounter > 3 && tb.isInActiveFormattingElements(node)) { // Spec step 20\n                                        tb.removeFromActiveFormattingElements(node); // Remove only from AFE list\n                                        // continue INNER loop (implicit)\n                                    } else if (!tb.isInActiveFormattingElements(node)) { // Spec step 21\n                                        tb.removeFromStack(node); // Remove from stack only\n                                        continue INNER; // Check next node above\n                                    } else { // Spec step 22: node is in AFE and not formatEl: Replace and reparent\n                                        Element replacement = tb.createElement(node.normalName()); // Create replacement with same tag/attrs\n                                        replacement.attributes().addAll(node.attributes());\n                                        tb.replaceActiveFormattingElement(node, replacement); // Replace in AFE list\n                                        tb.replaceOnStack(node, replacement); // Replace in stack\n                                        node = replacement; // Continue with the replacement\n\n                                        if (lastNode == furthestBlock && bookmark != -1) bookmark++; // Spec step 23: Adjust bookmark after first replacement\n                                        if (lastNode.parent() != null) lastNode.remove(); // Spec step 24 (part 1)\n                                        node.appendChild(lastNode); // Spec step 24 (part 2)\n                                        lastNode = node; // Spec step 25\n                                        // Spec step 26: Continue INNER loop (implicit)\n                                    }\n                                } // end INNER loop\n\n                                // Step 27: Reparent lastNode (which might be furthestBlock or a replacement) into commonAncestor or foster parent\n                                if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n                                    if (lastNode.parent() != null) lastNode.remove();\n                                    tb.insertInFosterParent(lastNode);\n                                } else {\n                                    if (lastNode.parent() != null) lastNode.remove();\n                                    commonAncestor.appendChild(lastNode);\n                                }\n\n                                // Steps 28-30: Create adopter element, move children from furthestBlock to adopter, append adopter to furthestBlock\n                                Element adopter = tb.createElement(formatEl.normalName()); // Spec step 28\n                                adopter.attributes().addAll(formatEl.attributes());\n                                Node[] childNodes = furthestBlock.childNodes().toArray(Node.EmptyNodes); // Spec step 29 (get children)\n                                for (Node childNode : childNodes) {\n                                    adopter.appendChild(childNode); // append moves node\n                                }\n                                furthestBlock.appendChild(adopter); // Spec step 30\n\n                                // Steps 31-34: Update AFE list and stack\n                                tb.removeFromActiveFormattingElements(formatEl); // Step 31\n                                if (bookmark != -1) { // Step 32: Insert adopter at bookmark (adjusting for list size changes)\n                                    if (bookmark >= tb.getActiveFormattingElements().size()) tb.getActiveFormattingElements().add(adopter);\n                                    else tb.getActiveFormattingElements().add(bookmark, adopter);\n                                } else { // Should not happen if bookmark was valid index, defensive add\n                                    tb.getActiveFormattingElements().add(adopter);\n                                }\n                                tb.removeFromStack(formatEl); // Step 33\n                                tb.insertOnStackAfter(furthestBlock, adopter); // Step 34: Insert adopter below (after) furthest block\n                            } // end OUTER loop (Spec step 35: loop implicitly via for loop)\n\n                        } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) { // Basic block closers + button\n                            if (!tb.inScope(name)) { // Use generic scope check\n                                tb.error(this);\n                                return false; // ignore token if not in scope\n                            } else {\n                                tb.generateImpliedEndTags();\n                                if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                                tb.popStackToClose(name);\n                                // Button requires clearing AFE list as well\n                                if (name.equals(\"button\")) tb.clearFormattingElementsToLastMarker();\n                            }\n                        } else if (name.equals(\"form\")) {\n                             Element currentForm = tb.getFormElement();\n                             tb.setFormElement(null); // Set form null *before* popping stack\n                             if (currentForm == null || !tb.inScope(name)) {\n                                 tb.error(this);\n                                 if (!tb.isFragmentParsing()) return false; // Ignore token only if not fragment & form issues\n                             } else { // Form is in scope\n                                 tb.generateImpliedEndTags();\n                                 if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                                 // remove currentForm from stack. If not current, remove the specific instance.\n                                 if (tb.currentElement() != currentForm) tb.removeFromStack(currentForm);\n                                 tb.popStackToClose(name); // Pop up to and including the form element (which might be current or the specific instance)\n\n                             }\n                        } else if (name.equals(\"p\")) {\n                            if (!tb.inButtonScope(name)) { // Check p specifically in button scope\n                                tb.error(this);\n                                tb.process(new Token.StartTag(name)); // Auto-insert <p>\n                                return tb.process(endTag); // Reprocess </p>\n                            } else {\n                                tb.generateImpliedEndTags(name); // Close up to <p>\n                                if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                                tb.popStackToClose(name);\n                            }\n                        } else if (name.equals(\"li\")) {\n                            if (!tb.inListItemScope(name)) { // Check li specifically in list item scope\n                                tb.error(this);\n                                return false; // ignore token\n                            } else {\n                                tb.generateImpliedEndTags(name); // Close up to <li>\n                                if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                                tb.popStackToClose(name);\n                            }\n                        } else if (StringUtil.inSorted(name, Constants.DdDt)) { // dd, dt\n                            if (!tb.inScope(name)) { // Use generic scope\n                                tb.error(this);\n                                return false; // ignore token\n                            } else {\n                                tb.generateImpliedEndTags(name); // Close up to <dd> or <dt>\n                                if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                                tb.popStackToClose(name);\n                            }\n                        } else if (StringUtil.inSorted(name, Constants.HeadingsTags)) { // h1-h6\n                            if (!tb.inScope(Constants.HeadingsTags)) { // Check scope for any heading\n                                tb.error(this);\n                                return false; // ignore token\n                            } else {\n                                tb.generateImpliedEndTags(name); // Close up to current heading name\n                                if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                                tb.popStackToClose(Constants.HeadingsTags); // Close all headings\n                            }\n                        } else if (StringUtil.inSorted(name, Constants.ObjectTags)) { // applet, marquee, object\n                            // Use generic scope check; spec variation for </object> handled implicitly by scope rules\n                            if (!tb.inScope(name)) {\n                                     tb.error(this);\n                                     return false; // Ignore token if not in scope\n                            }\n                            // If in scope:\n                            tb.generateImpliedEndTags();\n                            if (tb.currentElement() != null && !tb.currentElement().nodeName().equals(name)) tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker(); // Clear AFE list\n                        } else if (name.equals(\"br\")) { // Treat </br> as <br>\n                            tb.error(this);\n                            tb.process(new Token.StartTag(\"br\"));\n                            return false; // ignore end tag token\n                        }\n                    } else { // Any other end tag not in the InBodyEndTags list\n                        return anyOtherEndTag(t, tb);\n                    }\n                    break; // EndTag case\n\n                case EOF:\n                    // TODO: tb.errorIfSortedBogus(Constants.InBodyEndEofClosers); // Check stack for disallowed elements\n                    // stop parsing handled by TreeBuilder main loop\n                    break;\n            }\n            return true;\n        }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}