{
    "generation": "/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\nprivate RealMatrix squareRoot(RealMatrix m) {\n    // Avoid forming EigenDecomposition and matrix square root if weighting is identity\n    if (m instanceof DiagonalMatrix) {\n        // If the matrix is diagonal, just take square roots of the diagonal elements\n        double[] diag = ((DiagonalMatrix) m).getData();\n        double[] sqrtDiag = new double[diag.length];\n        for (int i = 0; i < diag.length; i++) {\n            sqrtDiag[i] = Math.sqrt(diag[i]);\n        }\n        return new DiagonalMatrix(sqrtDiag);\n    }\n    int n = m.getRowDimension();\n    // Check if m is (close to) identity\n    boolean isIdentity = true;\n    for (int i = 0; i < n && isIdentity; i++) {\n        for (int j = 0; j < n; j++) {\n            double v = m.getEntry(i, j);\n            if (i == j) {\n                if (Math.abs(v - 1.0) > 1e-14) {\n                    isIdentity = false;\n                    break;\n                }\n            } else {\n                if (Math.abs(v) > 1e-14) {\n                    isIdentity = false;\n                    break;\n                }\n            }\n        }\n    }\n    if (isIdentity) {\n        // If m is (close to) identity, just return a new identity matrix\n        return MatrixUtils.createRealIdentityMatrix(n);\n    }\n    // For general symmetric, positive-definite matrix, use EigenDecomposition\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}