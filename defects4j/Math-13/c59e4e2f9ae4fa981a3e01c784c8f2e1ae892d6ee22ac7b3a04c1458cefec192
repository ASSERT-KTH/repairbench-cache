{
    "generation": "import org.apache.commons.math3.exception.LocalizedFormats;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.NonSquareMatrixException;\nimport org.apache.commons.math3.linear.DiagonalMatrix;\nimport org.apache.commons.math3.linear.EigenDecomposition;\nimport org.apache.commons.math3.linear.MatrixUtils;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.util.FastMath;\n\n    /**\n     * Computes the square-root of the weight matrix.\n     * <p>\n     * This implementation assumes the input matrix {@code m} is diagonal,\n     * which holds true for the weight matrix used in {@link AbstractLeastSquaresOptimizer}.\n     * The square root is computed by taking the square root of each diagonal element.\n     * This avoids the computationally expensive and memory-intensive Eigen decomposition\n     * for large diagonal matrices, which can cause {@link OutOfMemoryError}.\n     * The result is returned as a memory-efficient {@link DiagonalMatrix}.\n     * </p>\n     *\n     * @param m Symmetric, positive-definite (weight) matrix. Assumed to be diagonal.\n     * @return the square-root of the weight matrix (as a {@link DiagonalMatrix}).\n     * @throws NonSquareMatrixException if the matrix is not square.\n     * @throws MathIllegalArgumentException if the matrix is diagonal but has negative diagonal elements\n     * (violating the positive-definite requirement).\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n        // Check if the matrix is square, a basic requirement.\n        final int n = m.getRowDimension();\n        if (n != m.getColumnDimension()) {\n            throw new NonSquareMatrixException(m.getRowDimension(), m.getColumnDimension());\n        }\n\n        // Assuming 'm' is diagonal based on its usage context as a weight matrix.\n        // Extract diagonal elements and compute their square roots.\n        final double[] sqrtDiag = new double[n];\n        for (int i = 0; i < n; ++i) {\n            final double diagEntry = m.getEntry(i, i);\n            // Check for non-negative diagonal elements. Weights must be non-negative.\n            // This aligns with the positive-definite requirement for Eigen decomposition.\n            if (diagEntry < 0) {\n                throw new MathIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n            }\n            sqrtDiag[i] = FastMath.sqrt(diagEntry);\n\n            // Optionally, we could add a check for off-diagonal elements for robustness,\n            // but this would be O(n^2) and likely too slow for the large matrices\n            // causing the OOM error. The assumption is key to the performance fix.\n            // Example check (inefficient for large n):\n            // for (int j = 0; j < n; ++j) {\n            //     if (i != j && m.getEntry(i, j) != 0.0) {\n            //         // If not diagonal, fall back to EigenDecomposition or throw error\n            //         // For now, we rely on the assumption.\n            //     }\n            // }\n        }\n\n        // Return the result as a memory-efficient DiagonalMatrix.\n        return MatrixUtils.createRealDiagonalMatrix(sqrtDiag);\n\n        // Original code that was potentially causing OutOfMemoryError for large diagonal matrices:\n        // final EigenDecomposition dec = new EigenDecomposition(m);\n        // return dec.getSquareRoot();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}