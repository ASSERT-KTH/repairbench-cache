{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    // Check for extra arguments to join(), as it only accepts one.\n    // n is the CALL node.\n    // n.getFirstChild() is the GETPROP (array.join).\n    // n.getFirstChild().getNext() is the first argument (separator).\n    // If n has more than 2 children, there are extra arguments.\n    if (n.getChildCount() > 2) {\n      return n;\n    }\n\n    Node right = callTarget.getNext();\n    if (right != null) {\n      if (!NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // \",\" is the default, it doesn't need to be explicit\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0; // This accumulates cost of new array elements' content\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n    // Merges adjacent String nodes.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        // Fix: Implement JS Array.prototype.join behavior for null/undefined\n        // Null and undefined elements are converted to the empty string.\n        if (elem.getType() == Token.NULL || elem.getType() == Token.VOID) { // VOID means undefined\n            sb.append(\"\");\n        } else {\n            sb.append(NodeUtil.getArrayElementStringValue(elem));\n        }\n      } else {\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    // Removed: foldedSize += arrayFoldedChildren.size() - 1;\n    // This line was incorrect as it applied to all cases and was not part of\n    // the true cost of the new expression in the default case.\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        // 'foldedSize' here represents the cost of the single element\n        // (either a new string literal or an existing node's cost).\n        if (foldedSize > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that\n          // it is coerced to a string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // No folding could actually be performed (i.e. if the number of children\n        // did not change, meaning no adjacent strings were merged).\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n\n        // Calculate the cost of the NEW array.join() expression accurately.\n        // This includes the cost of the array literal, the '.join' property,\n        // the separator argument, and the CALL parentheses.\n        int newJoinExprCost = 0;\n        for (Node node : arrayFoldedChildren) {\n          newJoinExprCost += InlineCostEstimator.getCost(node);\n        }\n        // Add cost for the new array literal: brackets \"[]\"\n        newJoinExprCost += 2;\n        // Add cost for commas within the array literal (e.g., [a,b,c] has 2 commas)\n        newJoinExprCost += arrayFoldedChildren.size() > 1 ? arrayFoldedChildren.size() - 1 : 0;\n\n        // Add cost for the \".join\" property access:\n        // The property name \"join\" itself and the overhead for GETPROP.\n        newJoinExprCost += \".join\".length() + 2; // \"join\" (4 chars) + 2 for quotes as a string literal cost\n\n        // Add cost for the separator argument (if present)\n        newJoinExprCost += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n\n        // Add cost for the CALL parentheses \"()\"\n        newJoinExprCost += 2;\n\n        if (newJoinExprCost > originalSize) {\n          return n;\n        }\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}