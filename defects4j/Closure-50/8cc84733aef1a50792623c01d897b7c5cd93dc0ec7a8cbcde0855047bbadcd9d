{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.List;\n\n/**\n * Contains the fixed function tryFoldArrayJoin.\n * Dependencies like PeepholeReplaceKnownMethods, InlineCostEstimator, reportCodeChange are assumed to exist.\n */\nclass FixedPeepholeReplaceKnownMethods {\n\n    // Assume InlineCostEstimator exists and provides getCost(Node)\n    static class InlineCostEstimator {\n        static int getCost(Node n) {\n            // In a real scenario, this would estimate code size/complexity.\n            // Returning 1 for simplicity in this context.\n            if (n == null) return 0;\n            // Crude approximation based on Closure Compiler's implementation hints\n            switch (n.getToken()) {\n              case STRING:\n                return n.getString().length() + 2; // Account for quotes\n              case NAME:\n                return n.getString().length();\n              case NUMBER:\n                return String.valueOf(n.getDouble()).length();\n              case TRUE:\n                return 4;\n              case FALSE:\n                return 5;\n              case NULL:\n                return 4;\n              case VOID:\n                return InlineCostEstimator.getCost(n.getFirstChild()) + \"void \".length();\n              case ARRAYLIT:\n              case OBJECTLIT:\n                 int cost = 2; // for [] or {}\n                 for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                     cost += InlineCostEstimator.getCost(child) + 1; // Element + comma\n                 }\n                 if (n.hasChildren()) cost--; // Remove last comma cost\n                 return cost;\n              case GETPROP:\n                return InlineCostEstimator.getCost(n.getFirstChild()) + InlineCostEstimator.getCost(n.getLastChild()) + 1; // receiver + prop + dot\n              case CALL:\n                 cost = InlineCostEstimator.getCost(n.getFirstChild()) + 2; // target + ()\n                 for (Node child = n.getSecondChild(); child != null; child = child.getNext()) {\n                     cost += InlineCostEstimator.getCost(child) + 1; // arg + comma\n                 }\n                 if (n.getSecondChild() != null) cost--; // Remove last comma cost\n                 return cost;\n              case ADD:\n                 return InlineCostEstimator.getCost(n.getFirstChild()) + InlineCostEstimator.getCost(n.getSecondChild()) + 1; // left + right + op\n              default:\n                return 1; // Default fallback\n            }\n        }\n    }\n\n    // Placeholder for the reporting mechanism\n    private void reportCodeChange() {\n        // In a real compiler, this marks the AST as changed.\n    }\n\n\n  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    // Ensure n is a CALL node before proceeding.\n    if (!n.isCall()) {\n      return n;\n    }\n\n    Node callTarget = n.getFirstChild();\n    // The target of the call must be a GETPROP (like xxx.join).\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = callTarget.getLastChild(); // In GETPROP, the property name is the last child\n\n    // Check for ARRAYLIT.join pattern:\n    // The object must be an ARRAYLIT, and the property name must be the string \"join\".\n    if (arrayNode == null || !arrayNode.isArrayLit() ||\n        functionName == null || !functionName.isString() ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // Check argument count: join() or join(separator).\n    Node separatorArg = callTarget.getNext();\n    if (separatorArg != null && separatorArg.getNext() != null) {\n      // More than one argument passed to join (e.g., arr.join(sep, extra)) - don't optimize.\n      return n;\n    }\n\n    // Check separator argument validity (if present): must be an immutable value (string, number, boolean, null, undefined).\n    if (separatorArg != null && !NodeUtil.isImmutableValue(separatorArg)) {\n      // e.g., arr.join(variableSeparator) - cannot fold reliably.\n      return n;\n    }\n\n    // Determine the join string separator. Defaults to \",\" if no argument is provided.\n    String joinString = (separatorArg == null) ? \",\" : NodeUtil.getStringValue(separatorArg);\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null; // Used to accumulate adjacent string parts.\n    Node prev = null; // Keep track of the previous node for copying source info.\n    Node elem = arrayNode.getFirstChild();\n    boolean changed = false; // Track if any folding (merging of immutable parts) actually occurred.\n\n    // Iterate through array elements, folding adjacent immutable values.\n    while (elem != null) {\n      // Fold elements that are immutable values (literals) or empty slots (which join as \"\").\n      if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n        if (sb == null) {\n          // Start accumulating a new string segment.\n          sb = new StringBuilder();\n        } else {\n          // Append the separator if we are concatenating with a previous part.\n          sb.append(joinString);\n        }\n        // Append the string representation of the current element.\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n        // Mark as changed if we merged with a previous immutable element.\n        if (prev != null && (NodeUtil.isImmutableValue(prev) || prev.isEmpty())) {\n           changed = true;\n        }\n      } else {\n        // Non-immutable element encountered (e.g., a variable).\n        // First, flush any accumulated string segment to the results list.\n        if (sb != null) {\n          Preconditions.checkNotNull(prev, \"Previous node should not be null when folding elements\");\n          String foldedString = sb.toString();\n          // Create a new STRING node for the folded part.\n          Node newStringNode = Node.newString(foldedString).copyInformationFrom(prev);\n          arrayFoldedChildren.add(newStringNode);\n          sb = null; // Reset the StringBuilder for the next segment.\n          changed = true; // Mark that a fold happened.\n        }\n        // Add the non-immutable element itself to the list of children.\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    // Handle any trailing accumulated string after the loop finishes.\n    if (sb != null) {\n      Preconditions.checkNotNull(prev, \"Previous node should not be null when handling trailing string\");\n      String foldedString = sb.toString();\n      Node newStringNode = Node.newString(foldedString).copyInformationFrom(prev);\n      arrayFoldedChildren.add(newStringNode);\n      changed = true; // Mark that a fold happened.\n    }\n\n    // Get the estimated cost (e.g., code size) of the original expression node.\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node parent = n.getParent(); // Needed for replacing the node in the AST.\n    // Cannot replace the node if it has no parent in the AST.\n    if (parent == null) {\n        return n;\n    }\n\n    // Decide how to modify the AST based on the result of folding.\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // Original array was empty, e.g., [].join(',') => \"\"\n        // Replace the entire call node with an empty string node.\n        Node emptyStringNode = Node.newString(\"\").copyInformationFrom(n);\n        parent.replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode; // Return the new node.\n\n      case 1:\n        // Array folded into a single element (or started with one).\n        // e.g., ['a','b'].join('') => \"ab\"\n        // e.g., [foo].join(',') => needs coercion '' + foo\n        Node singleResultNode = arrayFoldedChildren.remove(0);\n        Node replacementNode;\n        int foldedCost;\n\n        // Determine the node to replace 'n' with and estimate its cost.\n        if (singleResultNode.isString()) {\n          // Result is already a string literal (e.g., \"abc\").\n          replacementNode = singleResultNode;\n          foldedCost = InlineCostEstimator.getCost(replacementNode);\n        } else {\n          // Result is not a string (e.g., a variable 'foo').\n          // JS join semantics require coercion to string. Represent this as '' + node.\n          replacementNode = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n), // Empty string for coercion\n              singleResultNode); // The non-string node\n          replacementNode.copyInformationFrom(n); // Copy source info to the new ADD node\n          foldedCost = InlineCostEstimator.getCost(replacementNode);\n        }\n\n        // Only perform replacement if the new node is smaller or equal in cost.\n        if (foldedCost > originalSize) {\n          return n; // Optimization doesn't reduce size.\n        }\n\n        // Perform the replacement in the AST.\n        parent.replaceChild(n, replacementNode);\n        reportCodeChange();\n        return replacementNode; // Return the new node.\n\n      default:\n        // Partial folding: >1 element remains in the array.\n        // e.g. ['a', foo, 'b', 'c'].join(',') => [\"a\", foo, \"b,c\"].join(',')\n        // We need to check if this partial folding is still beneficial (reduces cost).\n\n        // If no actual merging/folding occurred (changed==false) AND the number\n        // of elements is the same as the original, then no change is needed.\n        // This avoids unnecessary modifications for cases like [a, b].join().\n        if (!changed && arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n            return n;\n        }\n\n        // Estimate the cost of the new expression:\n        // Cost([newElem1, newElem2, ...]) + Cost(.join()) + Cost(separator)\n        // Cloning nodes to build a temporary structure for accurate cost estimation.\n        Node newArrayLit = new Node(Token.ARRAYLIT);\n        for(Node node : arrayFoldedChildren) {\n            newArrayLit.addChildToBack(node.cloneTree());\n        }\n        newArrayLit.copyInformationFrom(arrayNode); // Copy source info\n\n        Node newGetProp = new Node(Token.GETPROP, newArrayLit, functionName.cloneTree());\n        newGetProp.copyInformationFrom(callTarget); // Copy source info\n\n        Node newCall = new Node(Token.CALL, newGetProp);\n        if (separatorArg != null) {\n            // If there was a separator argument, keep it in the estimated cost.\n            newCall.addChildToBack(separatorArg.cloneTree());\n        }\n        newCall.copyInformationFrom(n); // Copy source info\n\n        // Calculate the estimated cost of this potentially smaller call expression.\n        int newCost = InlineCostEstimator.getCost(newCall);\n\n        // Only perform replacement if the new structure is smaller or equal in cost.\n        if (newCost > originalSize) {\n          return n; // Optimization doesn't reduce size.\n        }\n\n        // Apply the changes to the original array node in place.\n        arrayNode.detachChildren(); // Clear existing children\n        for (Node node : arrayFoldedChildren) {\n          // Add the actual folded/unmodified nodes back to the original array node.\n          arrayNode.addChildToBack(node);\n        }\n        // The CALL node (n) and its GETPROP child (callTarget) remain,\n        // but the ARRAYLIT child of the GETPROP has been modified in place.\n        reportCodeChange();\n        break; // Break from switch, return n (which has been modified internally)\n    }\n\n    // Return the potentially modified node 'n' (for the default case where n's child array is modified).\n    return n;\n  }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}