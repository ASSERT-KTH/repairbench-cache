{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport java.util.List;\n\n/**\n * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n */\nprivate Node tryFoldArrayJoin(Node n) {\n  // Ensure the node is a CALL node\n  if (!n.isCall()) {\n    return n;\n  }\n\n  Node callTarget = n.getFirstChild();\n  if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n    return n;\n  }\n\n  // Check function arguments: [].join() or [].join(separator)\n  Node separatorNode = callTarget.getNext(); // This is the first argument\n  Node secondArg = (separatorNode == null) ? null : separatorNode.getNext();\n\n  // If there is a second argument, or any subsequent arguments, bail.\n  if (secondArg != null) {\n    return n;\n  }\n\n  // If a separator is provided, it must be an immutable value.\n  if (separatorNode != null && !NodeUtil.isImmutableValue(separatorNode)) {\n    return n;\n  }\n\n  Node arrayNode = callTarget.getFirstChild();\n  Node functionName = arrayNode.getNext();\n\n  // Check if it's a join on an array literal.\n  if (arrayNode == null || !arrayNode.isArrayLit() ||\n      functionName == null || !functionName.isString() ||\n      !functionName.getString().equals(\"join\")) {\n    return n;\n  }\n\n  // Determine the join separator string.\n  String joinString = (separatorNode == null) ? \",\" : NodeUtil.getStringValue(separatorNode);\n\n  List<Node> arrayFoldedChildren = Lists.newLinkedList();\n  StringBuilder sb = null; // Used to merge consecutive foldable elements\n  Node prev = null; // Keep track of the last node processed for copying info\n  Node elem = arrayNode.getFirstChild();\n\n  // Iterate through array elements, merging adjacent immutable values.\n  while (elem != null) {\n    // Use isEmpty() for empty array slots like [,,]\n    if (NodeUtil.isImmutableValue(elem) || elem.isEmpty()) {\n      if (sb == null) {\n        sb = new StringBuilder();\n      } else {\n        // Append separator *before* the next element's string value\n        sb.append(joinString);\n      }\n      // NodeUtil.getArrayElementStringValue handles null/undefined/empty -> \"\"\n      sb.append(NodeUtil.getArrayElementStringValue(elem));\n    } else {\n      // Hit a non-foldable element (e.g., variable, function call)\n      if (sb != null) {\n        // Add the folded string accumulated so far\n        Preconditions.checkNotNull(prev);\n        arrayFoldedChildren.add(\n            Node.newString(sb.toString()).copyInformationFrom(prev));\n        sb = null; // Reset StringBuilder\n      }\n      // Add the non-foldable element itself\n      arrayFoldedChildren.add(elem);\n    }\n    prev = elem; // Update prev to the current element before moving next\n    elem = elem.getNext();\n  }\n\n  // Add any remaining folded string at the end\n  if (sb != null) {\n    Preconditions.checkNotNull(prev);\n    arrayFoldedChildren.add(\n        Node.newString(sb.toString()).copyInformationFrom(prev));\n  }\n\n  int originalSize = InlineCostEstimator.getCost(n);\n  Node parent = n.getParent(); // Keep track of parent for replacement\n\n  switch (arrayFoldedChildren.size()) {\n    case 0: // All elements folded into an empty string or array was empty\n      Node emptyStringNode = Node.newString(\"\");\n      // Cost comparison: \"\" vs original call\n      if (InlineCostEstimator.getCost(emptyStringNode) > originalSize) {\n          return n;\n      }\n      parent.replaceChild(n, emptyStringNode);\n      reportCodeChange();\n      return emptyStringNode;\n\n    case 1: // All elements folded into a single element\n      Node foldedNode = arrayFoldedChildren.remove(0);\n      Node replacementNode;\n      int foldedSize;\n\n      // Determine the replacement node based on the type of the single element\n      if (foldedNode.isString()) {\n        // Already a string literal\n        replacementNode = foldedNode;\n      } else if (NodeUtil.isImmutableValue(foldedNode) || foldedNode.isEmpty()) {\n        // Convert immutable non-string (number, boolean, null, undefined, empty) to string\n        String stringValue = NodeUtil.getArrayElementStringValue(foldedNode);\n        replacementNode = Node.newString(stringValue).copyInformationFrom(foldedNode);\n      } else {\n        // Non-immutable (e.g., variable `foo`). Result is `\"\" + foo` for string coercion.\n        replacementNode = new Node(Token.ADD,\n            Node.newString(\"\").copyInformationFrom(n),\n            foldedNode);\n      }\n\n      foldedSize = InlineCostEstimator.getCost(replacementNode);\n\n      // Compare estimated folded size with original size\n      if (foldedSize > originalSize) {\n        return n; // Not smaller, don't replace\n      }\n\n      // Perform replacement\n      parent.replaceChild(n, replacementNode);\n      reportCodeChange();\n      return replacementNode;\n\n    default: // Partial folding or no folding of elements possible\n      // Check if any change was actually made (i.e., number of elements decreased)\n      if (arrayFoldedChildren.size() >= arrayNode.getChildCount()) {\n        return n; // No reduction in elements, no benefit\n      }\n\n      // Estimate the cost of the new partially folded call:\n      // new_array_literal.join(separator) OR new_array_literal.join()\n      int kJoinPropOverhead = \".join\".length();\n      int kCallOverhead = \"()\".length();\n\n      // Build a temporary new array node to estimate its cost\n      Node newArrayLit = new Node(Token.ARRAYLIT);\n      for (Node node : arrayFoldedChildren) {\n          newArrayLit.addChildToBack(node.cloneTree()); // Use clones for estimation\n      }\n      int newArraySize = InlineCostEstimator.getCost(newArrayLit);\n\n      int newCallSize = newArraySize + kJoinPropOverhead;\n\n      boolean useDefaultSeparator = \",\".equals(joinString);\n      boolean hasSeparatorArg = (separatorNode != null);\n\n      // Add cost of separator argument if it's present and not the default \",\"\n      if (hasSeparatorArg && !useDefaultSeparator) {\n          newCallSize += InlineCostEstimator.getCost(separatorNode);\n          newCallSize += kCallOverhead; // .join(sep)\n      } else {\n          // Using default separator: .join()\n          newCallSize += kCallOverhead;\n      }\n\n\n      if (newCallSize > originalSize) {\n        return n; // Not smaller\n      }\n\n      // Rebuild the original array node with folded children\n      arrayNode.detachChildren();\n      for (Node node : arrayFoldedChildren) {\n        arrayNode.addChildToBack(node);\n      }\n\n      // Modify the call node: remove separator argument if it was ',' and is now default\n      if (hasSeparatorArg && useDefaultSeparator) {\n          n.removeChild(separatorNode);\n      }\n\n      reportCodeChange();\n      // Return the modified node n (modified in place)\n      return n;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}