{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    // Check for correct number of arguments for the .join() method.\n    // A CALL node has children: callTarget, arg1, arg2, ...\n    // So, for a standard .join() call, the total children count should be\n    // 1 (for the call target, i.e., \"array.join\") + 0 or 1 (for the separator argument).\n    // This means n.getChildCount() should be 1 or 2. If it's more, it's not a standard join.\n    if (n.getChildCount() > 2) {\n      return n;\n    }\n\n    Node right = callTarget.getNext(); // This is the first argument (the separator)\n    if (right != null) {\n      // The separator argument must be an immutable value to be folded.\n      if (!NodeUtil.isImmutableValue(right)) {\n        return n;\n      }\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // \",\" is the default separator, it doesn't need to be explicit.\n    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    int foldedSize = 0; // Accumulates cost of the elements that will be in the new array.\n    Node prev = null;\n    Node elem = arrayNode.getFirstChild();\n\n    // Merges adjacent String nodes and converts immutable values to their string representation.\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          sb.append(joinString);\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n      } else {\n        // If an immutable string has been accumulated, flush it to a new node.\n        if (sb != null) {\n          Preconditions.checkNotNull(prev);\n          // + 2 for the quotes when creating a string literal.\n          foldedSize += sb.length() + 2;\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(prev));\n          sb = null;\n        }\n        // Add the non-immutable element directly.\n        foldedSize += InlineCostEstimator.getCost(elem);\n        arrayFoldedChildren.add(elem);\n      }\n      prev = elem;\n      elem = elem.getNext();\n    }\n\n    // Flush any remaining accumulated string builder content.\n    if (sb != null) {\n      Preconditions.checkNotNull(prev);\n      // + 2 for the quotes.\n      foldedSize += sb.length() + 2;\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(prev));\n    }\n    // Remove the following line, as its cost contribution depends on the final structure\n    // (fully folded string or partially folded array.join) and is calculated later for the latter.\n    // foldedSize += arrayFoldedChildren.size() - 1;\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    switch (arrayFoldedChildren.size()) {\n      case 0:\n        // Case: The array is empty or all elements folded to an empty string, e.g., [].join('') -> \"\"\n        Node emptyStringNode = Node.newString(\"\");\n        n.getParent().replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n      case 1:\n        // Case: All elements were folded into a single string literal or a single non-string node.\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n          return n; // No size win, so don't fold.\n        }\n        arrayNode.detachChildren(); // Detach original children before replacement.\n        if (foldedStringNode.getType() != Token.STRING) {\n          // If the Node is not a string literal, ensure that it is coerced to a string.\n          // This typically happens via concatenation with an empty string.\n          Node replacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFrom(n),\n              foldedStringNode);\n          foldedStringNode = replacement;\n        }\n        n.getParent().replaceChild(n, foldedStringNode);\n        reportCodeChange();\n        return foldedStringNode;\n      default:\n        // Case: The array could only be partially folded, resulting in a new array literal\n        // that still needs to be joined.\n        // If the number of children in the new array is the same as the original,\n        // and no adjacent strings were merged, then no effective folding happened.\n        // The condition `arrayFoldedChildren.size() == arrayNode.getChildCount()`\n        // acts as a heuristic to avoid transforming if no reduction in array size\n        // or merging of string parts occurred.\n        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n          return n;\n        }\n\n        // Now calculate the foldedSize for the new expression: `[...].join(...)`\n        // `foldedSize` currently holds the sum of costs of the elements in `arrayFoldedChildren`.\n        // Add the structural cost of the new ARRAYLIT node:\n        foldedSize += 2; // For the brackets \"[]\"\n        if (arrayFoldedChildren.size() > 0) {\n            // For commas between elements, if any.\n            foldedSize += arrayFoldedChildren.size() - 1;\n        }\n\n        // Add the cost of the .join() method call itself:\n        int kJoinOverhead = \"[].join()\".length(); // Cost of \".join()\" part\n        foldedSize += kJoinOverhead;\n\n        // Add the cost of the separator argument, if present:\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n\n        if (foldedSize > originalSize) {\n          return n; // No size win, so don't transform.\n        }\n        // Replace the original array literal children with the new, folded children.\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          arrayNode.addChildToBack(node);\n        }\n        reportCodeChange();\n        break;\n    }\n\n    return n; // Return the original node if no transformation or no size win occurred.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}