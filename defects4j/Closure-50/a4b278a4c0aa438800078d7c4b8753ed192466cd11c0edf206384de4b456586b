{
    "generation": "  /**\n   * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n   */\n  private Node tryFoldArrayJoin(Node n) {\n    // Input node 'n' is ASSUMED to be the CALL node.\n    Preconditions.checkArgument(n.isCall());\n\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    // Check structure: array.join\n    if (arrayNode == null || arrayNode.getType() != Token.ARRAYLIT ||\n        functionName == null || !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    Node right = callTarget.getNext(); // The separator argument\n\n    // Check arity: join() takes 0 or 1 argument.\n    if (right != null && right.getNext() != null) {\n      return n; // Don't fold if join() has more than one argument.\n    }\n\n    // Check separator: If present, it must be an immutable value.\n    String joinString = \",\"; // Default separator\n    if (right != null) {\n      if (!NodeUtil.isImmutableValue(right)) {\n        return n; // Separator must be constant.\n      }\n      joinString = NodeUtil.getStringValue(right);\n    }\n\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    StringBuilder sb = null;\n    boolean mergeOccurred = false; // Track if adjacent elements were merged\n    Node lastAppendedNode = null; // Track node for source info copy\n\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n        // Foldable element\n        if (sb == null) {\n          sb = new StringBuilder();\n        } else {\n          // If sb already exists, we are appending a separator -> merging elements.\n          sb.append(joinString);\n          mergeOccurred = true;\n        }\n        sb.append(NodeUtil.getArrayElementStringValue(elem));\n        lastAppendedNode = elem; // Remember last node that contributed to sb\n      } else {\n        // Non-foldable element\n        if (sb != null) {\n          // Finish the previous foldable segment.\n          Preconditions.checkNotNull(lastAppendedNode, \"Expected last node info\");\n          // Create the new string node with source info from the last folded element\n          arrayFoldedChildren.add(\n              Node.newString(sb.toString()).copyInformationFrom(lastAppendedNode));\n          sb = null;\n        }\n        // Add the non-foldable element directly. It might be reparented later.\n        arrayFoldedChildren.add(elem);\n        lastAppendedNode = elem; // Remember this node too\n      }\n      elem = elem.getNext();\n    }\n\n    // Handle the last foldable segment\n    if (sb != null) {\n      Preconditions.checkNotNull(lastAppendedNode, \"Expected last node info for final segment\");\n      // Create the final string node with source info\n      arrayFoldedChildren.add(\n          Node.newString(sb.toString()).copyInformationFrom(lastAppendedNode));\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    Node parent = n.getParent(); // Save parent for replacement\n\n    switch (arrayFoldedChildren.size()) {\n      case 0: // [''].join() -> \"\" or [].join() -> \"\"\n        Node emptyStringNode = Node.newString(\"\");\n        // Check cost benefit (unlikely to be worse, but check)\n        if (InlineCostEstimator.getCost(emptyStringNode) > originalSize) {\n          return n;\n        }\n        emptyStringNode.copyInformationFrom(n); // Copy overall source info\n        parent.replaceChild(n, emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n\n      case 1: // ['a','b'].join('') -> \"ab\" or [foo].join() -> \"\" + foo\n        Node foldedNode = arrayFoldedChildren.get(0);\n        Node potentialReplacement = foldedNode;\n\n        // Ensure the result is a string if the single element wasn't originally.\n        // Joining a single element array coerces it to string according to spec.\n        // Exception: If the element was already a string literal, keep it as is.\n        if (foldedNode.getType() != Token.STRING) {\n          // Coerce to string using \"\" + node for unknown types, or specific conversion\n          // This ADD node might be further optimized later.\n          potentialReplacement = new Node(Token.ADD,\n              Node.newString(\"\").copyInformationFromForTree(n), // Empty string gets source info\n              foldedNode); // foldedNode carries its original source info.\n          potentialReplacement.copyInformationFrom(n); // ADD node gets overall source info from the call\n        } else {\n          // If it's already a string (possibly created by merging), copy source info from the call node\n          potentialReplacement.copyInformationFrom(n);\n        }\n\n        // Check cost benefit\n        int replacementCost = InlineCostEstimator.getCost(potentialReplacement);\n        if (replacementCost > originalSize) {\n          return n;\n        }\n\n        // If the replacement is identical to the original node, avoid reporting change.\n        // This is unlikely given the transformations but good practice.\n        if (n.isEquivalentTo(potentialReplacement)) {\n            return n;\n        }\n\n        parent.replaceChild(n, potentialReplacement);\n        reportCodeChange();\n        return potentialReplacement; // Return the actual node added to the tree\n\n      default: // Multiple elements remain after folding some parts\n        // Only perform the modification if merging occurred.\n        // This prevents modifying the array if e.g. ['a', foo, 'b'] is processed\n        // but no adjacent constants were found.\n        if (!mergeOccurred) {\n          return n;\n        }\n\n        // Estimate cost of the new array join call\n        // Use the approximate size calculation similar to the original code\n        int foldedSize = 0;\n        for (Node node : arrayFoldedChildren) {\n           foldedSize += InlineCostEstimator.getCost(node);\n        }\n        // Add cost for separators in the new array literal (approximated by commas)\n        foldedSize += Math.max(0, arrayFoldedChildren.size() - 1);\n        // Approximation for call/getprop overhead\n        int kJoinOverhead = \"[].join()\".length();\n        foldedSize += kJoinOverhead;\n        // Add cost of the separator argument, if it exists\n        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n\n        if (foldedSize > originalSize) {\n          return n; // Modification estimated to be larger.\n        }\n\n        // Perform the modification: Replace children of the original arrayNode\n        arrayNode.detachChildren();\n        for (Node node : arrayFoldedChildren) {\n          // Nodes from the original list might need cloning if they are moved,\n          // but addChildToBack handles the reparenting. Newly created string\n          // nodes are fine.\n          arrayNode.addChildToBack(node);\n        }\n        // Report change as 'n' itself was modified internally (its child arrayNode)\n        reportCodeChange();\n        break; // Keep n, but modified\n    }\n\n    return n;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}