{
    "generation": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n                                         int nextLineTabStop, String text)\n{\n    final String padding = createPadding(nextLineTabStop);\n    final String newLine = defaultNewLine;\n    final int newLineLen = newLine.length();\n    boolean firstLine = true;\n\n    while (text.length() > 0)\n    {\n        // find the next break position\n        int pos = findWrapPos(text, width, firstLine ? 0 : nextLineTabStop);\n        if (pos == -1)\n        {\n            // no more wraps needed\n            if (!firstLine)\n            {\n                sb.append(padding);\n            }\n            sb.append(rtrim(text));\n            break;\n        }\n\n        // if it's an existing newline, honor it\n        if (text.startsWith(newLine, pos))\n        {\n            String line = text.substring(0, pos);\n            if (!firstLine)\n            {\n                sb.append(padding);\n            }\n            sb.append(rtrim(line)).append(newLine);\n            text = text.substring(pos + newLineLen);\n        }\n        else\n        {\n            // wrap at the whitespace/width boundary\n            String line = text.substring(0, pos);\n            if (!firstLine)\n            {\n                sb.append(padding);\n            }\n            sb.append(rtrim(line)).append(newLine);\n            // skip any whitespace after the break\n            int start = pos;\n            while (start < text.length()\n                   && Character.isWhitespace(text.charAt(start))\n                   && !text.startsWith(newLine, start))\n            {\n                start++;\n            }\n            text = text.substring(start);\n        }\n\n        firstLine = false;\n    }\n\n    return sb;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}