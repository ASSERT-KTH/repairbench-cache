{
    "generation": "    /**\n     * <p>Render the specified text and return the rendered Options\n     * in a StringBuffer.</p>\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            // text.substring(pos) gets the remainder of the text after the current wrap point.\n            // .trim() removes any leading whitespace (like the space character the text was wrapped at).\n            // padding is then prepended to the trimmed remaining text.\n            text = padding + text.substring(pos).trim();\n            \n            // findWrapPos is then called on this newly formed 'text' which includes the padding.\n            // width is the total line width.\n            // nextLineTabStop is the start position of content within this 'text' string.\n            pos = findWrapPos(text, width, nextLineTabStop);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after `startPos` for the specified line.\n     * This method tries to wrap at a space, but if a long word is encountered\n     * that exceeds the `width`, it will be broken.\n     *\n     * @param text The text to be wrapped.\n     * @param width The width of the line (total column width).\n     * @param startPos The position on the string from which the content actually starts (e.g., after padding).\n     *\n     * @return The position on the string where the wrap should occur, or -1 if no wrap is necessary.\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        // 1. Handle explicit line breaks or tabs within the allowed effective width\n        int pos = text.indexOf('\\n', startPos);\n        if (pos != -1 && pos <= width)\n        {\n            return pos;\n        }\n\n        pos = text.indexOf('\\t', startPos);\n        if (pos != -1 && pos <= width)\n        {\n            return pos;\n        }\n\n        // 2. Check if the remaining text from 'startPos' fits within the effective width\n        // The effective width for wrapping content is 'width - startPos'.\n        // If 'text.length() - startPos' (length of content after startPos)\n        // is less than or equal to 'width - startPos' (available width for content),\n        // then the content fits, and no wrap is needed.\n        if (text.length() - startPos <= width - startPos)\n        {\n            return -1;\n        }\n\n        // 3. Look for the last space character before 'width' (total column limit).\n        // Start searching backward from 'width', but ensure the position is within text bounds.\n        // The search should not go beyond the end of the string.\n        pos = Math.min(width, text.length() - 1);\n\n        char c;\n\n        // Search backward from 'pos' down to 'startPos' (inclusive).\n        // 'startPos' ensures we don't break within the padding.\n        while (pos >= startPos)\n        {\n            c = text.charAt(pos);\n\n            if (c == ' ' || c == '\\n' || c == '\\r') // Found a break character\n            {\n                return pos;\n            }\n            pos--;\n        }\n\n        // 4. If no space/newline found within the range [startPos, width],\n        // perform a hard wrap at 'width'.\n        // This assumes 'text' is long enough to be truncated at 'width'.\n        return width;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}