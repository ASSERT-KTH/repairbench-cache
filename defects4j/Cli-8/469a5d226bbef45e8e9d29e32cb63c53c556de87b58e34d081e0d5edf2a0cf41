{
    "generation": "/**\n * <p>Render the specified text and return the rendered Options\n * in a StringBuffer.</p>\n *\n * <p>This fixed version first checks for embedded newlines and, if found,\n * splits the text so as to preserve them. When re\u2010wrapping a \u201ccontinued\u201d\n * line (one that comes after a newline) the preset indent (nextLineTabStop)\n * is applied from the start.</p>\n *\n * @param sb The StringBuffer to place the rendered text into.\n * @param width The number of characters to display per line\n * @param nextLineTabStop The position on the next line for the first tab.\n * @param text The text to be rendered.\n *\n * @return the StringBuffer with the rendered Options contents.\n */\nprotected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    // If the text contains an explicit newline, process each part separately.\n    if (text.indexOf(defaultNewLine) > -1) {\n        // Tokenize keeping the newline delimiters.\n        StringTokenizer st = new StringTokenizer(text, defaultNewLine, true);\n        // After a newline the next text token should be indented (if nextLineTabStop > 0).\n        boolean padNext = false;\n        while (st.hasMoreTokens()) {\n            String token = st.nextToken();\n            if (token.equals(defaultNewLine)) {\n                sb.append(token);\n                padNext = true;\n            } else {\n                if (padNext && nextLineTabStop > 0 && token.length() > 0) {\n                    token = createPadding(nextLineTabStop) + token;\n                }\n                // Recursively wrap the token (which now does not contain any newlines).\n                renderWrappedText(sb, width, nextLineTabStop, token);\n                padNext = false;\n            }\n        }\n        return sb;\n    }\n\n    // Determine whether this line is already \u201ccontinued\u201d (padded) so that\n    // the available width should be computed relative to nextLineTabStop.\n    boolean isPadded = nextLineTabStop > 0 && text.startsWith(createPadding(nextLineTabStop));\n    int pos = isPadded ? findWrapPos(text, width, nextLineTabStop)\n                       : findWrapPos(text, width, 0);\n    if (pos == -1) {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true) {\n        text = padding + text.substring(pos).trim();\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1) {\n            sb.append(text);\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}