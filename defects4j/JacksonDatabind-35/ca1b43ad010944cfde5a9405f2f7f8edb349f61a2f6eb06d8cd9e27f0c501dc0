{
    "generation": "    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n\n        // As per [databind#400], may need to handle the case where Object Id has been read\n        //\n        // Note: IF we are called from `deserializeTypedFromObject`, we may have an Object Id,\n        // IN WHICH CASE the current token is likely FIELD_NAME, not START_OBJECT.\n        JsonToken t = p.currentToken();\n        if (t == JsonToken.START_OBJECT) {\n            // If START_OBJECT, next token MUST be FIELD_NAME\n            t = p.nextToken();\n        } else if (t != JsonToken.FIELD_NAME) {\n            // Not START_OBJECT, not FIELD_NAME: throw error\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, // Indicate the expected structure start\n                  \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n        // And then token must be FIELD_NAME... may have been START_OBJECT previously\n        // (this check is technically redundant now due to the else if above, but kept for clarity/safety)\n        // Redundant check removed for cleaner code. If it wasn't START_OBJECT or FIELD_NAME, we already threw.\n        // If it was START_OBJECT, we advanced and t is now the next token (should be FIELD_NAME).\n        // If it was FIELD_NAME, t is FIELD_NAME.\n        // So we just need to ensure t is FIELD_NAME at this point.\n        if (t != JsonToken.FIELD_NAME) {\n             throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                     \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n         }\n\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        // Move parser past the type id field name to point to the value (start of the wrapped object)\n        p.nextToken();\n\n        // Minor complication: we may need to merge type id in?\n        // 10-Mar-2017, tatu: As per [databind#1554], need to use BufferBasedJsonParser...\n        //    (or possibly TokenBuffer)\n        if (_typeIdVisible && p.currentToken() == JsonToken.START_OBJECT) {\n            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n            TokenBuffer tb = ctxt.bufferForInputBuffering(p);\n            tb.writeStartObject(); // start the buffer wrapper\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n\n            // Need to make sure we properly handle possible buffering:\n            // (JsonParserSequence will combine buffered type info + original parser)\n            // (NOTE: need to flatten to combine Object from buffer with Object from original parser)\n            p = JsonParserSequence.createFlattened(true, tb.asParser(p), p);\n\n            // Need to advance past the START_OBJECT marker we wrote in buffer:\n            p.nextToken();\n        }\n        \n        // Note: deserializer takes care of processing the value node (the object wrapped by type name):\n        // it starts from the current parser position (START_OBJECT of the value)\n        // and consumes it until the corresponding END_OBJECT.\n        Object value = deser.deserialize(p, ctxt);\n        \n        // And then need the closing END_OBJECT associated with the type wrapper object\n        // (e.g., the '}' matching the '{' before the type field name, or the '{' that BeanDeserializer skipped\n        // over if Object Id was processed first)\n        JsonToken end = p.nextToken();\n        if (end != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}