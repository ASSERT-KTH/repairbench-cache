{
    "generation": "    /**\n     * Method that handles type information wrapper, locates actual\n     * subtype deserializer to use, and calls it to do actual\n     * deserialization.\n     */\n    @SuppressWarnings(\"resource\")\n    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 02-Aug-2013, tatu: May need to use native type ids\n        if (p.canReadTypeId()) {\n            Object typeId = p.getTypeId();\n            if (typeId != null) {\n                return _deserializeWithNativeTypeId(p, ctxt, typeId);\n            }\n        }\n\n        // As per [databind#1707] and [databind#2094], we need to consider ObjectId handling\n        // for As.WRAPPER_OBJECT type when a plain ObjectId reference is encountered,\n        // or when the ObjectId property is encountered as the first field of an object.\n        // The WrapperObjectDeserializer directly calls this _deserialize method, bypassing\n        // the ObjectId handling logic in TypeDeserializerBase.deserializeTypedFromObject,\n        // which can lead to issues if ObjectId is active.\n        if (_objectIdReader != null) {\n            JsonToken t = p.getCurrentToken();\n            if (t != null) {\n                // Case 1: Scalar value (e.g., String or Number) -- direct ObjectId reference\n                // This covers JSON like: \"some-object-id\"\n                if (t.isScalarValue()) {\n                    return _deserializeWithObjectId(p, ctxt);\n                }\n                // Case 2: FIELD_NAME, which could be the ObjectId property name itself.\n                // This specifically addresses the reported error: \"Unexpected token (FIELD_NAME), expected START_OBJECT\"\n                // This occurs if the parser is already positioned at a FIELD_NAME token, and that\n                // FIELD_NAME corresponds to the ObjectId property (e.g., {\"id\": \"value\"}).\n                // For As.WRAPPER_OBJECT, the expected token is START_OBJECT, but if only an ObjectId is present,\n                // the surrounding object might be skipped or the parser might already be advanced.\n                if (t == JsonToken.FIELD_NAME) {\n                    String name = p.getCurrentName();\n                    if (name.equals(_objectIdReader.propertyName.simpleName)) {\n                        return _deserializeWithObjectId(p, ctxt);\n                    }\n                }\n                // Case 3: START_OBJECT, but this object is actually just an ObjectId reference\n                // (e.g., {\"id\": \"value\"}) instead of a full type-wrapped object.\n                // We should delegate to _deserializeWithObjectId if it's a minimal object containing only the ID.\n                // The _objectIdReader.mayContainObjectId method or similar check is needed here\n                // to differentiate from the actual As.WRAPPER_OBJECT START_OBJECT.\n                // The _deserializeWithObjectId should handle consuming the START_OBJECT and finding the ID.\n                // If we don't handle this, the standard WRAPPER_OBJECT path will try to interpret 'id' as a type name.\n                else if (t == JsonToken.START_OBJECT) {\n                     // Check if this START_OBJECT indicates an ObjectId structure (e.g., {\"id\": \"someValue\"})\n                     // rather than a type wrapper (e.g., {\"typeName\": { ... }}).\n                     // _objectIdReader.mayContainObjectId(p) from Jackson source provides this heuristic.\n                     // If it's a simple object with an ID, _deserializeWithObjectId can handle it.\n                     if (_objectIdReader.mayContainObjectId(p)) {\n                         return _deserializeWithObjectId(p, ctxt);\n                     }\n                }\n            }\n        }\n\n        // If not handled by native type IDs or ObjectId, proceed with As.WRAPPER_OBJECT specific logic.\n        // first, sanity checks: expect the outer START_OBJECT for the wrapper.\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n        }\n            // should always get field name (which is the type id), but just in case...\n            if (p.nextToken() != JsonToken.FIELD_NAME) {\n                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                        \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n            }\n        final String typeId = p.getText();\n        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n        p.nextToken();\n\n        // Minor complication: we may need to merge type id in?\n        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n            TokenBuffer tb = new TokenBuffer(null, false);\n            tb.writeStartObject(); // recreate START_OBJECT\n            tb.writeFieldName(_typePropertyName);\n            tb.writeString(typeId);\n            p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n            p.nextToken();\n        }\n        \n        Object value = deser.deserialize(p, ctxt);\n        // And then need the closing END_OBJECT\n        if (p.nextToken() != JsonToken.END_OBJECT) {\n            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n                    \"expected closing END_OBJECT after type information and deserialized value\");\n        }\n        return value;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}