{
    "generation": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     * <p>This method is lenient, however. It will tolerate files that\n     * contain more data than indicated by the flags specified in the\n     * parameters. It will only fail if the data is shorter than\n     * indicated by the flags.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            // Calculate the expected minimum length based on the flags.\n            int expectedLength = (hasUncompressedSize ? ZipConstants.DWORD : 0)\n                + (hasCompressedSize ? ZipConstants.DWORD : 0)\n                + (hasRelativeHeaderOffset ? ZipConstants.DWORD : 0)\n                + (hasDiskStart ? ZipConstants.WORD : 0);\n\n            // The raw data field might contain more data than indicated by the flags.\n            // See https://issues.apache.org/jira/browse/COMPRESS-228\n            // We only check if the data field is long enough to hold the data\n            // indicated by the flags. It's okay if it is longer.\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" is too short, expected at least \"\n                                       + expectedLength + \" but is only \"\n                                       + rawCentralDirectoryData.length);\n            }\n\n            int offset = 0;\n            // Read the fields indicated by the flags, assuming they are present\n            // in the correct order. The length check above ensures we won't read\n            // past the end of the buffer for these fields.\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += ZipConstants.DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += ZipConstants.DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += ZipConstants.DWORD;\n            }\n            if (hasDiskStart) {\n                diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                offset += ZipConstants.WORD; // Increment offset for consistency\n            }\n            // Any remaining data in rawCentralDirectoryData is ignored.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}