{
    "generation": "    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            // The following check is removed to allow for excess data\n            // in the rawCentralDirectoryData, as per COMPRESS-228.\n            // The parser should be robust and only read the expected fields,\n            // ignoring any trailing data.\n            // if (rawCentralDirectoryData.length != expectedLength) {\n            //     throw new ZipException(\"central directory zip64 extended\"\n            //                            + \" information extra field's length\"\n            //                            + \" doesn't match central directory\"\n            //                            + \" data.  Expected length \"\n            //                            + expectedLength + \" but is \"\n            //                            + rawCentralDirectoryData.length);\n            // }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                if (offset + DWORD <= rawCentralDirectoryData.length) { // Ensure there's enough data\n                    size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                    offset += DWORD;\n                } else {\n                    // Not enough data for this field, stop parsing\n                    return;\n                }\n            }\n            if (hasCompressedSize) {\n                if (offset + DWORD <= rawCentralDirectoryData.length) { // Ensure there's enough data\n                    compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                    offset += DWORD;\n                } else {\n                    return;\n                }\n            }\n            if (hasRelativeHeaderOffset) {\n                if (offset + DWORD <= rawCentralDirectoryData.length) { // Ensure there's enough data\n                    relativeHeaderOffset =\n                        new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                    offset += DWORD;\n                } else {\n                    return;\n                }\n            }\n            if (hasDiskStart) {\n                if (offset + WORD <= rawCentralDirectoryData.length) { // Ensure there's enough data\n                    diskStart = new ZipLong(rawCentralDirectoryData, offset);\n                    offset += WORD;\n                } else {\n                    return;\n                }\n            }\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}