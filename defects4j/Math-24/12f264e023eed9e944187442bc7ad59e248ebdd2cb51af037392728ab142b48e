{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0; // Step distance moved in the step before previous.\n        double fx = computeObjectiveValue(x); // Value of function at x.\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx; // Value of function at v.\n        double fw = fx; // Value of function at w.\n\n        UnivariatePointValuePair previous = null;\n        // Current best point. Updated constantly and returned at the end IF stop condition is met.\n        // Initialized with the starting point.\n        UnivariatePointValuePair best = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Point evaluated in the current iteration. Passed to the checker.\n        UnivariatePointValuePair current = best;\n\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Mid-point of the current bracket [a,b].\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion: interval width relative to current best point x.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                // Default termination (Brent's criterion).\n                // Return the best point found (x, fx), not necessarily the last evaluated point.\n                // Note: fx has been negated earlier if !isMinim, so negate it back.\n                return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            }\n\n            // Compute the next point u to be evaluated.\n            double p = 0; // Interpolation step related parameters.\n            double q = 0;\n            double r = 0;\n            double u = 0; // Next point to be evaluated.\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola if the step before last was large enough.\n                // Compute numerator and denominator of parabolic interpolation step.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                // Ensure q is positive (parabola opens upwards for minimum).\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store previous step distance 'd' into 'r'.\n                e = d; // Store step distance before previous into 'e'.\n\n                // Check acceptability of the parabolic interpolation step.\n                // Conditions: must be within bounds (a,b) and not too large compared to previous step.\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step is accepted.\n                    d = p / q; // Step distance.\n                    u = x + d; // Next point u.\n\n                    // f must not be evaluated too close to a or b.\n                    // If u is too close to the bounds, take a minimum step tol1 instead.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) { // If x is in the lower half, step towards upper bound.\n                            d = tol1;\n                        } else {      // If x is in the upper half, step towards lower bound.\n                            d = -tol1;\n                        }\n                        // Note: u is not updated here, only d is potentially adjusted for the check below.\n                        // The actual step calculation happens after this block.\n                    }\n                } else {\n                    // Parabolic step rejected, perform golden section step.\n                    if (x < m) { // Determine the segment for golden section.\n                        e = b - x; // Segment is [x, b].\n                    } else {\n                        e = a - x; // Segment is [a, x].\n                    }\n                    d = GOLDEN_SECTION * e; // Golden section step distance.\n                }\n            } else { // Previous step was too small (|e| <= tol1), perform golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Ensure the step size d is at least tol1 in magnitude.\n            if (FastMath.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1; // Force minimum step towards right.\n                } else {\n                    u = x - tol1; // Force minimum step towards left.\n                }\n            } else {\n                u = x + d; // Use the calculated step d (parabolic or golden).\n            }\n\n            double fu = computeObjectiveValue(u); // Evaluate function at the new point u.\n            if (!isMinim) {\n                fu = -fu; // Negate if maximizing (minimizing -f).\n            }\n\n            // Prepare for convergence check and next iteration.\n            previous = current; // Keep track of the previous evaluated point pair.\n            // Create the pair for the current evaluated point u. Negate fu back if maximizing.\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // User-defined convergence checker.\n            if (checker != null) {\n                // If the checker indicates convergence based on the sequence of evaluated points.\n                if (checker.converged(iter, previous, current)) {\n                    // Return the point that satisfied the convergence criterion.\n                    return current;\n                }\n            }\n\n            // Update the bracket [a, b] and the points x, v, w maintaining the best points found.\n            if (fu <= fx) { // New point u is better than or equal to the current best x.\n                // Update the bracket.\n                if (u < x) {\n                    b = x; // New upper bound is x.\n                } else {\n                    a = x; // New lower bound is x.\n                }\n                // Update best points: x becomes u, w becomes x, v becomes w.\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu; // Update the best point and its value.\n            } else { // New point u is worse than x (fu > fx).\n                // Update the bracket using u.\n                if (u < x) {\n                    a = u; // New lower bound is u.\n                } else {\n                    b = u; // New upper bound is u.\n                }\n                // Update secondary points w and v if u is better than them.\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv ||\n                           Precision.equals(v, x) ||\n                           Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n            // Update the step distance history for the next iteration's parabola decision.\n            // Note: 'e' now holds the step distance from iter-2 to iter-1.\n            // 'd' holds the step distance from iter-1 to iter (current step).\n            // This seems correct based on how 'e' and 'd' are used.\n\n            ++iter; // Increment iteration counter.\n        } // End of while loop.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}