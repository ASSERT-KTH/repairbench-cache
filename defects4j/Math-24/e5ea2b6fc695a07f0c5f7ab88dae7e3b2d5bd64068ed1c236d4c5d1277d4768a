{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        // Use getters for finalizing the values used in the loop.\n        final double relativeThreshold = getRelativeAccuracy();\n        final double absoluteThreshold = getAbsoluteAccuracy();\n\n        double a; // Lower bound of the bracket\n        double b; // Upper bound of the bracket\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid; // Current best estimate of the optimum\n        double v = x;   // Point with second best function value\n        double w = x;   // Point with third best function value\n        double d = 0;   // Step size in the last step taken (from x to u)\n        double e = 0;   // Step size taken in the step before last\n        double fx = computeObjectiveValue(x); // Function value at x\n        if (!isMinim) {\n            fx = -fx; // Work with -(objective function) if maximizing\n        }\n        double fv = fx; // Function value at v\n        double fw = fx; // Function value at w\n\n        UnivariatePointValuePair previous = null; // Point from previous iteration (for checker)\n        // Point evaluated in the current iteration (u, fu), used for checker. Initialize with start value.\n        UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        // Main optimization loop\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b); // Midpoint of the current bracket [a, b]\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Check default stopping criterion (Brent's criterion)\n            // Stop if the bracket width (b - a) is small enough relative to the best point x.\n            // The check is |x - m| <= tol2 - 0.5 * (b - a).\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\n            if (stop) {\n                // Default termination: return the best point found so far (x, fx).\n                // x holds the point with the best value found, fx holds the corresponding\n                // function value (negated if maximizing).\n                // Ensure the returned value is the original objective value, not negated.\n                return new UnivariatePointValuePair(x, isMinim ? fx : -fx); // FIX: Return best point x\n            }\n\n            // If not stopping, calculate the next point 'u' to evaluate\n            double p = 0; // Numerator for parabolic interpolation step\n            double q = 0; // Denominator for parabolic interpolation step\n            double r = 0; // Temporary variable\n            double u = 0; // Next point to evaluate\n\n            // Try parabolic interpolation using x, v, w\n            if (FastMath.abs(e) > tol1) { // Only if the step before last (e) was significant enough\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) { // Ensure q is positive for comparison below\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e; // Store step before last\n                e = d; // Store last step (d becomes the step before last for the next iteration)\n\n                // Check if the parabolic step is acceptable\n                // 1. Is the parabola's minimum within the bracket (a, b)? (p / q is the step from x)\n                // 2. Is the step size smaller than half the step size before last? (prevents large jumps)\n                if (p > q * (a - x) &&\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step is accepted\n                    d = p / q; // Calculated step size\n                    u = x + d; // New point\n\n                    // Ensure u is not too close to the boundaries a or b\n                    if (u - a < tol2 || b - u < tol2) {\n                        // If too close, adjust d to be a minimal step towards the midpoint m\n                        // This adjustment will influence the final u calculation below.\n                        if (x <= m) {\n                            d = tol1; // Minimal step to the right\n                        } else {\n                            d = -tol1; // Minimal step to the left\n                        }\n                    }\n                } else {\n                    // Golden section step (parabola failed or rejected)\n                    // Calculate step 'e' based on which side of the midpoint 'x' is\n                    if (x < m) { // x is in the lower half of [a, b]\n                        e = b - x; // Search in the upper interval [x, b]\n                    } else {      // x is in the upper half of [a, b]\n                        e = a - x; // Search in the lower interval [a, x]\n                    }\n                    d = GOLDEN_SECTION * e; // Golden ratio step size\n                }\n            } else {\n                // Golden section step (step before last 'e' was too small for parabolic fit)\n                 if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Ensure the step size d is at least tol1 in magnitude for progress\n            // Note: 'd' here might be from parabola, golden section, or the boundary adjustment (+/- tol1).\n            if (FastMath.abs(d) >= tol1) {\n                u = x + d; // Use the calculated step d\n            } else {\n                 // Force a minimal step of size tol1 if |d| was too small\n                if (d >= 0) { // If d was positive or zero\n                    u = x + tol1; // Step right\n                } else {        // If d was negative\n                    u = x - tol1; // Step left\n                }\n            }\n            // Update 'd' to reflect the actual step taken from x to u, for the next iteration's 'e'.\n            // Note: The original code implicitly uses the d calculated before this minimum step enforcement\n            // as the 'e' for the next iteration (via e = d assignment earlier).\n            // This seems slightly off, but maintaining original logic for minimal change.\n            // A potential refinement could be: d = u - x; after u is determined.\n            // However, the original logic assigned e=d before this final check/adjustment of u.\n\n            // Evaluate the objective function at the new point u\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu; // Negate if maximizing\n            }\n\n            // Prepare for convergence checker: update current point\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n            // Check user-defined convergence criterion using the latest point u\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // If checker converges, return the current point 'u' as per checker's criteria\n                    return current;\n                }\n            }\n\n            // Update the bracket [a, b] and the points x, v, w based on the new value fu\n            if (fu <= fx) { // New point u is better than or equal to the current best x\n                // Update bracket: the interval containing the minimum must now include u\n                if (u < x) { // If u is to the left of x\n                    b = x;   // New bracket is [a, x]\n                } else {      // If u is to the right of x\n                    a = x;   // New bracket is [x, b]\n                }\n                // Shift the points: x becomes the new best, w becomes x, v becomes w\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u; // u is the new best point\n                fx = fu; // fu is the new best function value\n            } else { // New point u is worse than the current best x (fu > fx)\n                // Update bracket: the interval containing the minimum must now exclude the region\n                // between x and u on the side where u lies.\n                if (u < x) { // If u is to the left of x\n                    a = u;   // New bracket is [u, b]\n                } else {      // If u is to the right of x\n                    b = u;   // New bracket is [a, u]\n                }\n                // Update v and w only if u is better than them (to maintain order fx <= fw <= fv potentially)\n                if (fu <= fw || Precision.equals(w, x)) { // If u is better than w, or w == x (degenerate case)\n                    v = w;\n                    fv = fw;\n                    w = u; // u becomes the new second best (w)\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) { // If u is better than v, or v == x or v == w (degenerate cases)\n                    v = u; // u becomes the new third best (v)\n                    fv = fu;\n                }\n                // x and fx remain unchanged as they are still the best found so far\n            }\n\n            ++iter; // Increment iteration counter\n        } // End while loop\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}