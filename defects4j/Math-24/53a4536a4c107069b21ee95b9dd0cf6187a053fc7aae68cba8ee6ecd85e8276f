{
    "generation": "    /** {@inheritDoc} */\n    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        // Best point found so far (initialized to start value).\n        UnivariatePointValuePair best = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Keep track of the best point found, in case the loop terminates\n        // returning the last evaluated point which might not be the best.\n        if (checker != null && checker.converged(0, best, best)) {\n             return best; // Initial point satisfies convergence criteria.\n        }\n\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = best;\n\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (stop) {\n                 // Return the best point found so far, which is stored in (x, fx).\n                 // Note: 'current' might hold the last evaluated point, which is not necessarily the best.\n                 return new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n            }\n\n            // The following code block was inside the \"if (!stop)\" in the original code.\n            // It's moved out because the \"stop\" check should happen first.\n            // If we are not stopping, then we proceed to calculate the next point.\n\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n\n            if (FastMath.abs(e) > tol1) { // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                // Check conditions for accepting parabolic interpolation step.\n                if (p > q * (a - x) &&    // Interpolated point is within bounds (a, b)\n                    p < q * (b - x) &&\n                    FastMath.abs(p) < FastMath.abs(0.5 * q * r)) { // Interpolation step is not too large\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        // If the potential evaluation point u is very close to bounds a or b,\n                        // step away from the bound towards the middle m.\n                        if (x <= m) { // x is on the left part of the interval?\n                            d = tol1; // Step towards right.\n                        } else { // x is on the right part of the interval?\n                            d = -tol1; // Step towards left.\n                        }\n                    } // else: d = p / q already calculated.\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x; // Golden section on the right interval (x, b)\n                    } else {\n                        e = a - x; // Golden section on the left interval (a, x)\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            // Update by at least \"tol1\".\n            // Compute the next evaluation point u.\n            if (FastMath.abs(d) < tol1) {\n                 // If the computed step d is too small, take a minimum step of size tol1.\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n\n            double fu = computeObjectiveValue(u);\n            if (!isMinim) {\n                fu = -fu;\n            }\n\n            // User-defined convergence checker.\n            previous = current;\n            current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n             // Update the overall best point found so far.\n            if (fu <= fx) { // Use '<=' to prefer the new point if values are equal.\n                 best = current;\n            } else if (current.getValue() < best.getValue()) {\n                 // Although fu > fx (Brent's algorithm prefers x),\n                 // the raw value of current might be better than the current best\n                 // due to potential negation. Check this explicitly.\n                 best = current;\n            }\n\n\n            if (checker != null) {\n                // Check convergence after updating current point and before updating Brent's state variables\n                if (checker.converged(iter, previous, current)) {\n                    // If the user-defined checker converges, return the current point,\n                    // as this is the point that satisfied the checker.\n                    return current;\n                }\n            }\n\n            // Update a, b, v, w, x, fx, fv, fw based on the comparison between fu and fx\n            // This is the core logic of Brent's algorithm for maintaining the search interval and points.\n            if (fu <= fx) { // Point u is better than or equal to x\n                if (u < x) { // Shrink interval to (a, x)\n                    b = x;\n                } else { // Shrink interval to (x, b)\n                    a = x;\n                }\n                // Update points: v <- w, w <- x, x <- u\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else { // Point u is worse than x\n                if (u < x) { // Shrink interval to (u, b)\n                    a = u;\n                } else { // Shrink interval to (a, u)\n                    b = u;\n                }\n                // Update v and w, keeping x as the best point\n                if (fu <= fw || Precision.equals(w, x)) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || Precision.equals(v, x) || Precision.equals(v, w)) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n\n            ++iter;\n            // The convergence check (stop condition) is now at the beginning of the loop.\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}