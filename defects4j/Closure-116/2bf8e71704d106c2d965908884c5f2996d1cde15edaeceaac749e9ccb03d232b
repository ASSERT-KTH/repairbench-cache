{
    "generation": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    // For each named parameter check if a mutable argument use more than once.\n    if (fnParam != null) {\n      if (cArg != null) {\n        // Check for arguments that are evaluated more than once.\n        // Note: Unlike block inlining, there it is not possible that a\n        // parameter reference will be in a loop.\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n      fnParam = fnParam.getNext();\n    }\n\n    // For every call argument check for side-effects, even if there\n    // isn't a named parameter to match.\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  //\n  // ORDERING CHECK:\n  // A direct inline moves parameter evaluation into the body. If the body\n  // has side-effects before a parameter reference, the order is changed.\n  //\n  Node returnNode = block.getFirstChild();\n  if (returnNode != null && returnNode.isReturn()) {\n    Node returnValue = returnNode.getFirstChild();\n    if (returnValue != null) {\n      // Prepare parallel traversal of params and args again.\n      Node p = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n      Node a = callNode.getFirstChild().getNext();\n      if (!callNode.getFirstChild().isName()\n          && NodeUtil.isFunctionObjectCall(callNode)) {\n        a = (a != null) ? a.getNext() : null;\n      }\n      // For each parameter with an argument, check its uses in the return\n      // expression for any preceding side-effects.\n      while (p != null && a != null) {\n        final String name = p.getString();\n        // Traverse the return expression to find all references to 'name'.\n        List<Node> stack = new ArrayList<>();\n        stack.add(returnValue);\n        for (int idx = 0; idx < stack.size(); idx++) {\n          Node cur = stack.get(idx);\n          // If this node is a reference to the parameter, check siblings.\n          if (cur.isName() && name.equals(cur.getString())) {\n            // Walk up from the use to the root of the return expression.\n            Node child = cur;\n            while (child != returnValue) {\n              Node parent = child.getParent();\n              // For each sibling before 'child', if it may have side-effects,\n              // inlining would reorder them before the parameter.\n              for (Node sib = parent.getFirstChild();\n                   sib != child; sib = sib.getNext()) {\n                if (NodeUtil.mayHaveSideEffects(sib, compiler)) {\n                  return CanInlineResult.NO;\n                }\n              }\n              child = parent;\n            }\n          }\n          // Add children for traversal.\n          for (Node c = cur.getFirstChild(); c != null; c = c.getNext()) {\n            stack.add(c);\n          }\n        }\n        p = p.getNext();\n        a = a.getNext();\n      }\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}