{
    "generation": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  // This version only permits \u201cdirect\u201d inlining if the function is very \u201csimple\u201d \u2013\n  // namely it has a single return statement and its returned value is a \u201ctrivial\u201d\n  // expression that does not reorder evaluation of its one\u2010time parameter.\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n  // Only allow direct inlining for functions that consist of a single return.\n  if (block.getChildCount() != 1 || !block.getFirstChild().isReturn()) {\n    return CanInlineResult.NO;\n  }\n  Node retExpr = block.getFirstChild().getFirstChild();\n  // A function that returns nothing can be inlined.\n  if (retExpr == null) {\n    return CanInlineResult.YES;\n  }\n\n  // Determine if the returned expression is \u201csimple enough\u201d that inlining\n  // will not change the order in which the call\u2010site\u2019s argument is evaluated.\n  // In particular, we disallow \u201ccomplex\u201d expressions that combine a parameter\n  // with another (side\u2010effecting) subexpression.\n  boolean simple;\n  if (retExpr.isName()) {\n    // e.g. \u201creturn a;\u201d\n    simple = true;\n  } else if (retExpr.isGetProp() || retExpr.isGetElem()) {\n    // e.g. \u201creturn a.x;\u201d or \u201creturn a[0];\u201d\n    Node base = retExpr.getFirstChild();\n    while (base != null && (base.isGetProp() || base.isGetElem())) {\n      base = base.getFirstChild();\n    }\n    simple = (base != null && base.isName());\n  } else if (retExpr.isCall()) {\n    // Allow calls only if they have a single argument that is a simple name.\n    // e.g. \u201creturn getWindow(a);\u201d is okay if getWindow is known to be side\u2010effect\u2013free.\n    Node arg = retExpr.getSecondChild();\n    simple = (arg != null && arg.isName() && arg.getNext() == null);\n  } else if (retExpr.isAssign()) {\n    // e.g. \u201creturn a.x = 2;\u201d\n    Node left = retExpr.getFirstChild();\n    if (left.isGetProp() || left.isGetElem()) {\n      Node base = left.getFirstChild();\n      simple = (base != null && base.isName());\n    } else {\n      simple = false;\n    }\n  } else if (retExpr.isAdd() || retExpr.isSub() || retExpr.isMul() || retExpr.isDiv()) {\n    // For binary operators, we allow inlining only if the left operand\n    // (which would be evaluated before the parameter is used) is pure.\n    Node left = retExpr.getFirstChild();\n    simple = !NodeUtil.mayHaveSideEffects(left, compiler);\n  } else {\n    // Other kinds of return expressions are not considered safe for direct inlining.\n    simple = false;\n  }\n  if (!simple) {\n    return CanInlineResult.NO;\n  }\n\n  // Now, process the call arguments.\n  // In the call node the first child is the target, and the\n  // remaining children are arguments.\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // For functions called via .call() we expect the first argument to be a 'this'-reference.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // An .apply() call should have been filtered out already.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // For each formal parameter, check that if the corresponding call argument\n  // might produce side effects or mutate state that it is not duplicated.\n  // (Reordering can occur if the inlined expression evaluates the argument \u201clate\u201d.)\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (fnParam != null && cArg != null) {\n    // If the call argument might have side effects (or change mutable state)\n    // then we must be sure that the parameter is referenced only once.\n    if ((NodeUtil.mayHaveSideEffects(cArg, compiler) ||\n         NodeUtil.mayEffectMutableState(cArg, compiler))\n        && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n      return CanInlineResult.NO;\n    }\n    fnParam = fnParam.getNext();\n    cArg = cArg.getNext();\n  }\n  // Any extra call arguments must be side-effect free, since they would be dropped.\n  while (cArg != null) {\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler) ||\n        NodeUtil.mayEffectMutableState(cArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}