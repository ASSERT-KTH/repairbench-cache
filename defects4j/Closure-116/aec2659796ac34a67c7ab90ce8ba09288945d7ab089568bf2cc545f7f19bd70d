{
    "generation": "/**\n * Determines whether a function can be inlined at a particular call site.\n * There are several criteria that the function and reference must hold in\n * order for the functions to be inlined:\n * 1) If a call's arguments have side effects, the corresponding argument in \n *    the function must only be referenced once and \u201cused in place\u201d so that the\n *    original caller\u2019s evaluation order isn\u2019t disturbed.\n * For instance, this will not be inlined:\n * <pre>\n *     function foo(a) { return a + a }\n *     x = foo(i++);\n * </pre>\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  // First, check that the general requirements of a direct call inlining\n  // are met.\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  // The function body. (Expected to be a BLOCK node.)\n  Node block = fnNode.getLastChild();\n\n  // Adjust the call arguments.\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n  // For calls like foo.call(...), the first argument is the \"this\" value.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replacing \"this\" with an appropriate value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" calls should have been filtered out already.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n  // We now iterate in lock\u2010step over the formal parameters and the call arguments.\n  // While the basic side\u2010effect check (evaluated more than once) is still in place,\n  // we also perform an \u201cordering\u201d test.\n  // The idea is that in a standard call, all arguments are evaluated before\n  // the function body runs. When inlined directly, a parameter\u2019s value is\n  // substituted at its occurrence in the body.  That means that if the first\n  // occurrence of a parameter does not appear \u201cup\u2010front\u201d (that is, at the\n  // beginning of an expression) then the caller\u2019s evaluation order is not maintained.\n  while (fnParam != null && cArg != null) {\n    // 1. If the argument might produce side effects (or is mutable)\n    //    and its corresponding formal is referenced more than once,\n    //    then inlining is unsafe.\n    if ((NodeUtil.mayHaveSideEffects(cArg, compiler)\n         || NodeUtil.mayEffectMutableState(cArg, compiler))\n        && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n      return CanInlineResult.NO;\n    }\n\n    // 2. Check that the lone substitution won\u2019t disturb evaluation order.\n    // In a function call, the argument is evaluated up front.\n    // But when inlined, the call argument \u201cappears\u201d only where the formal is used.\n    // We locate the first occurrence of the formal parameter inside the function\u2019s body\n    // and then require that it appear in a \u201csafe\u201d syntactic position.\n    // For example, if the first occurrence is the left\u2010hand operand of a binary operator,\n    // then the argument will be evaluated immediately. However, if it appears as the\n    // right operand, then some side\u2010effect (from other sub\u2010expressions, say) may come first.\n    Node firstRef = NodeUtil.getFirstReference(block, fnParam.getString());\n    if (firstRef != null) {\n      boolean safePosition = false;\n      Node parent = firstRef.getParent();\n      int parentType = parent.getType();\n      switch (parentType) {\n        // For property gets and element accesses, the object expression is evaluated first.\n        case Token.GETPROP:\n        case Token.GETELEM:\n          safePosition = (parent.getFirstChild() == firstRef);\n          break;\n        // For most binary operators the left operand is evaluated first.\n        // So to be \u201cinlined\u2010in\u2010place\u201d the parameter must be the left child.\n        case Token.ADD:\n        case Token.SUB:\n        case Token.MUL:\n        case Token.DIV:\n        case Token.COMMA:\n          safePosition = (parent.getFirstChild() == firstRef);\n          break;\n        case Token.CALL:\n          // In a call, if the parameter appears as the call\u2019s function then it is used immediately.\n          // Otherwise, if it is the (only) argument \u2013 it will be evaluated when the call is made.\n          if (firstRef == parent.getFirstChild()) {\n            safePosition = true;\n          } else {\n            // Otherwise, if the parameter is not the very first argument, then its evaluation would\n            // occur later than the other arguments.  We consider that unsafe.\n            int index = 0;\n            for (Node n = parent.getFirstChild(); n != null; n = n.getNext()) {\n              if (n == firstRef) {\n                break;\n              }\n              index++;\n            }\n            safePosition = (index == 1 && parent.getChildCount() == 2);\n          }\n          break;\n        default:\n          safePosition = false;\n      }\n      // For safety the parameter\u2019s substitution must occur in a \"front\u2010loaded\" position.\n      // There is one small exception: if the call argument is a literal value\n      // (number, string, boolean, or null) then its evaluation order is irrelevant.\n      if (!safePosition) {\n        if (cArg.isName() || !cArg.isLiteral()) {\n          return CanInlineResult.NO;\n        }\n      }\n    }\n\n    // Advance to the next parameter/argument pair.\n    fnParam = fnParam.getNext();\n    cArg = cArg.getNext();\n  }\n\n  // If there is a mismatch between the number of parameters and call arguments, then\n  // direct inlining is not possible.\n  if (fnParam != null || cArg != null) {\n    return CanInlineResult.NO;\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}