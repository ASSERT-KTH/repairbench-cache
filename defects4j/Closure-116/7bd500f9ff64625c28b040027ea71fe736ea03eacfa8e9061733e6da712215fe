{
    "generation": "/**\n * Determines whether a function can be inlined at a particular call site.\n * In addition to the original tests for \u201cmultiple\u2010use\u201d of call arguments having\n * side effects, we now also check that the formal parameters are \u201cused safely\u201d\n * in the function\u2019s return value.  In particular, if a formal parameter is\n * referenced in an expression where some other sub\u2010expression (evaluated before\n * it) has side effects, then inlining it \u201cdirectly\u201d (i.e. without first aliasing\n * the argument) would change the evaluation order of the call\u2019s already\u2013evaluated\n * argument. This situation occurs for example in:\n *\n *   function foo(a){ return modifiyX() + a }\n *\n * where the return value uses the parameter \u201ca\u201d only after modifiyX() is called.\n * A similar situation is present when a comma\u2013operator is used.\n *\n * (For safe inlining in these cases a temporary alias must be introduced.)\n *\n * See the tests:\n *   testIssue1101a, testIssue1101b, testIssue1101, testDoubleInlining2,\n *   testInlineIfParametersModified8/9, testInlineFunctions6\n *\n * @param callNode The call site node.\n * @param fnNode The function node.\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  // If we can\u2019t even do a direct replacement of the call node,\n  // then we can\u2019t inline.\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  // In a direct call, the first child of the call node is the function expression.\n  // Its next children are the call arguments.\n  Node cArg = callNode.getFirstChild().getNext();\n  // For calls of function objects (via call/apply) skip the \u201cthis\u201d parameter.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replacing 'this' with a value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // For \".apply\" call, this is filtered out upstream.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // Process matching formal parameters and their corresponding call arguments.\n  Node fnParams = NodeUtil.getFunctionParameters(fnNode);\n  Node fnParam = fnParams.getFirstChild();\n  while (cArg != null && fnParam != null) {\n    // If the argument itself may have side effects, then it must be used at most once.\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler) &&\n        NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n    fnParam = fnParam.getNext();\n  }\n  // If there are extra call arguments (beyond the formal parameters),\n  // they must be side-effect free.\n  while (cArg != null) {\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n  }\n\n  // Now check the \u201csafety\u201d of parameter use in the function's returned expression.\n  // For a direct inline to be legal, each formal parameter that appears in\n  // the returned value must be used in a \u201csafe\u201d context \u2013 that is, its first occurrence\n  // must not be preceded (in evaluation order) by any subexpression with side effects.\n  // This rule catches cases such as:\n  //    return modifiyX() + a;    or    return (x.prop = 2), a;\n  // where inlining would reorder the call\u2013site evaluation (arguments are evaluated\n  // before the call) with that side effect.\n  Node retStmt = block.getFirstChild();\n  if (retStmt != null && retStmt.isReturn()) {\n    Node retExpr = retStmt.getFirstChild();\n    if (retExpr != null) {\n      for (Node p = fnParams.getFirstChild(); p != null; p = p.getNext()) {\n        String paramName = p.getString();\n        if (NodeUtil.containsName(retExpr, paramName)) {\n          if (!isParamUsedSafely(retExpr, paramName, compiler)) {\n            return CanInlineResult.NO;\n          }\n        }\n      }\n    }\n  }\n\n  return CanInlineResult.YES;\n}\n\n\n/**\n * Returns whether the first occurrence of a given parameter name in the given node\u2019s\n * evaluation order appears \u201csafely\u201d\u2013that is, not preceded by a subexpression that may have\n * side effects.\n */\nprivate boolean isParamUsedSafely(Node expr, String paramName, AbstractCompiler compiler) {\n  Node found = findFirstOccurrence(expr, paramName);\n  if (found == null) {\n    return true;\n  }\n  Node parent = found.getParent();\n  if (parent == null) {\n    return true;\n  }\n  switch (parent.getToken()) {\n    // For binary operators (like +, -, etc.) and the comma operator,\n    // the left child is evaluated before the right.\n    // If our parameter (found) is not the first child, then any side effects\n    // in the preceding sibling would change the evaluation order.\n    case ADD:\n    case SUB:\n    case MUL:\n    case DIV:\n    case MOD:\n    case COMMA:\n      if (parent.getFirstChild() != found) {\n        for (Node sibling = parent.getFirstChild(); sibling != null && sibling != found; sibling = sibling.getNext()) {\n          if (NodeUtil.mayHaveSideEffects(sibling, compiler)) {\n            return false;\n          }\n        }\n      }\n      return true;\n\n    // In a call, the callee is evaluated before the argument list.\n    // If our parameter appears as the callee, that is safe.\n    // Otherwise, if it is in the argument list, check that all preceding arguments are side-effect\u2013free.\n    case CALL:\n      if (parent.getFirstChild() == found) {\n        return true;\n      } else {\n        // Skip the callee; check among the argument nodes.\n        // (Arguments are evaluated in left-to-right order.)\n        for (Node arg = parent.getFirstChild().getNext(); arg != null && arg != found; arg = arg.getNext()) {\n          if (NodeUtil.mayHaveSideEffects(arg, compiler)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    // For property accesses (GETPROP/GETELEM), if the parameter is used as the receiver (the first child)\n    // then its evaluation is immediate.\n    case GETPROP:\n    case GETELEM:\n      if (parent.getFirstChild() == found) {\n        return true;\n      }\n      // Otherwise, fall through.\n    default:\n      return true;\n  }\n}\n\n\n/**\n * Recursively searches (in evaluation order) for the first Name node with the given string.\n */\nprivate Node findFirstOccurrence(Node node, final String name) {\n  if (node.isName() && name.equals(node.getString())) {\n    return node;\n  }\n  for (Node child = node.getFirstChild(); child != null; child = child.getNext()) {\n    Node found = findFirstOccurrence(child, name);\n    if (found != null) {\n      return found;\n    }\n  }\n  return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}