{
    "generation": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  // If the function can\u2019t even be replaced by a direct call, then don\u2019t inline.\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  // CALL NODE is of the form: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // For calls via \u201ccall\u201d (or \u201capply\u201d) the first argument is the this\u2013object,\n  // which isn\u2019t declared in the called function\u2019s parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replacing \u201cthis\u201d with an explicit value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \u201c.apply\u201d calls should have been filtered earlier.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // For each formal parameter (from the function\u2019s parameter list)\n  // match it against the corresponding call argument.\n  Node fnParams = NodeUtil.getFunctionParameters(fnNode);\n  Node fnParam = fnParams.getFirstChild();\n  while (fnParam != null && cArg != null) {\n    // First, if the call argument is \u201cmutable\u201d (i.e. may have side effects if evaluated more than once)\n    // then the parameter must be referenced at most once in the function body.\n    if (NodeUtil.mayEffectMutableState(cArg, compiler)\n        && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n      return CanInlineResult.NO;\n    }\n\n    // Second, even when the argument is \u201csimple\u201d (a name or literal), inlining directly\n    // will substitute the call\u2013argument at the point of the formal parameter\u2019s use.\n    // In a normal call the argument is evaluated *before* entering the function. So if the\n    // parameter occurs \u201clate\u201d (for example, as the right\u2013hand operand of a binary operator)\n    // then inlining would reorder evaluation (this can be observed if the argument\u2019s value\n    // can be changed by side effects in code appearing before its use).\n    // We check that the first occurrence of the parameter in the function body is \u201csafe\u201d\n    // for direct substitution.\n    if (!isParameterUsageSafe(fnNode, fnParam.getString(), cArg)) {\n      return CanInlineResult.NO;\n    }\n    fnParam = fnParam.getNext();\n    cArg = cArg.getNext();\n  }\n\n  // For any extra call arguments (i.e. those that don\u2019t correspond\n  // to a declared parameter) we require that they be side\u2013effect free.\n  while (cArg != null) {\n    if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n    cArg = cArg.getNext();\n  }\n  return CanInlineResult.YES;\n}\n\n/**\n * Returns true if the direct \u201cinlining\u201d of a call\u2013argument for the formal parameter\n * is safe from an evaluation\u2013order point of view. In a normal function call all\n * arguments are evaluated before any function\u2013body code runs. Direct substitution,\n * however, would insert the call\u2013argument expression inside the function body.\n *\n * For example, consider\n *    function foo(a) { return modifiyX() + a; }\n *    foo(x);\n *\n * In the call the value of x is computed before modifiyX() is executed.\n * Directly inlining foo would yield:\n *    modifiyX() + x;\n * which evaluates x after modifiyX(), possibly changing the result if modifiyX() alters x.\n * We therefore walk the function\u2019s body (block) to find the first occurrence of the\n * parameter \u201ca\u201d and examine its surrounding context. (We allow direct substitution\n * when the parameter occurs as an argument to a call or as the \u201cobject\u201d of a property access,\n * or in an assignment\u2019s left\u2013side.)\n */\nprivate boolean isParameterUsageSafe(Node fnNode, String paramName, Node callArg) {\n  Node block = fnNode.getLastChild();\n  Node usage = findFirstParameterUsage(block, paramName);\n  if (usage == null) {\n    // If the parameter isn\u2019t used at all, there is no risk.\n    return true;\n  }\n  Node parent = usage.getParent();\n  switch (parent.getType()) {\n    case Token.CALL:\n      // When used as an argument inside a call the substitution is safe.\n      return true;\n    case Token.GETPROP:\n    case Token.GETELEM:\n      // For property accesses, if the parameter is the receiver (first child), it\u2019s safe.\n      return parent.getFirstChild() == usage;\n    case Token.ASSIGN:\n      // In an assignment like a.x = 2, if the parameter is the object (left\u2013side) it\u2019s safe.\n      // Otherwise (if used on the right), we allow direct inlining only if the call\u2013argument\n      // is trivial (a name or literal).\n      if (parent.getFirstChild() == usage) {\n        return true;\n      }\n      return isTrivial(callArg);\n    default:\n      // For binary operators (such as \u201c+\u201d or the comma operator), the left operand is evaluated\n      // before the right. So if the parameter appears as any operand other than the first,\n      // then any side effects in the first operand would occur before the inlined call\u2013argument is evaluated.\n      if (parent.getChildCount() > 0 && parent.getChildAtIndex(0) != usage) {\n        // If the first operand may have side effects, then reordering is dangerous.\n        if (NodeUtil.mayHaveSideEffects(parent.getChildAtIndex(0), compiler)) {\n          return false;\n        } else {\n          // If the first operand is side\u2013effect free, then a trivial call\u2013argument (name or literal)\n          // is acceptable.\n          return isTrivial(callArg);\n        }\n      }\n      return true;\n  }\n}\n\nprivate boolean isTrivial(Node n) {\n  return n.isName() || n.isLiteral();\n}\n\n/**\n * Recursively traverses the given AST (in evaluation order) to find the first occurrence\n * of a NAME node whose string equals the specified parameter name. Returns null if not found.\n */\nprivate Node findFirstParameterUsage(Node root, String paramName) {\n  if (root == null) {\n    return null;\n  }\n  if (root.isName() && paramName.equals(root.getString())) {\n    return root;\n  }\n  for (Node child = root.getFirstChild(); child != null; child = child.getNext()) {\n    Node found = findFirstParameterUsage(child, paramName);\n    if (found != null) {\n      return found;\n    }\n  }\n  return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}