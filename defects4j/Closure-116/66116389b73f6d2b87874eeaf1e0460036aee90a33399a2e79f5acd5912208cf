{
    "generation": "/**\n * Determines whether a function can be inlined at a particular call site.\n * Inlining \u201cdirectly\u201d (without first moving a call\u2010argument into a temporary)\n * is only safe if every reference to a formal parameter in the function body\n * will see the same value as was computed at the call site. In particular, if\n * a call\u2010argument is not an immutable value and the function body (before the\n * parameter\u2019s first \u201cuse\u201d) might perform side\u2010effects that could \u201cdelay\u201d\n * the evaluation of that argument, then direct inlining is unsafe.\n *\n * To capture this we do two things for each paired parameter and call\u2010argument:\n * (1) If the call\u2013argument may affect mutable state and the formal parameter is\n *     referenced more than once then inlining is disallowed.\n * (2) And if the function body has side\u2013effects then, unless the argument is\n *     immutable or the only occurrences of the parameter are \u201cwritten to\u201d\n *     (for instance, when used as the target in a property\u2013assignment), then\n *     direct inlining is disallowed.\n *\n * Extra arguments (that don\u2019t correspond to a parameter) must be side\u2013effect free.\n */\nprivate CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  // CALL NODE is structured as: [ callee, arg1, arg2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Functions called via call/apply have a this\u2013object as first parameter,\n  // but that \u201cthis\u201d is not part of the callee\u2019s parameter list.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Support replacing the this\u2013object with a computed value.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" calls should have been filtered out already.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // Get formal parameters. (They are children of the LP node.)\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n\n  // Process each pair of formal parameter and call argument.\n  // (If there are extra arguments they must be side\u2013effect free.)\n  while (fnParam != null || cArg != null) {\n    if (fnParam != null && cArg != null) {\n      // (a) When the function body might perform side\u2013effects,\n      // then the value produced by the call\u2013argument must be \u201cfrozen\u201d\n      // (that is, immutable) or else must be used only in write\u2013contexts.\n      if (NodeUtil.mayHaveSideEffects(block, compiler)\n           && !NodeUtil.isImmutableValue(cArg)\n           && !isOnlyWritten(block, fnParam.getString())) {\n        return CanInlineResult.NO;\n      }\n\n      // (b) Even if there are no interfering side\u2013effects,\n      // if the call\u2013argument has mutable state that might be re\u2013evaluated,\n      // then it must not be used more than once.\n      if (NodeUtil.mayEffectMutableState(cArg, compiler)\n           && NodeUtil.getNameReferenceCount(block, fnParam.getString()) > 1) {\n        return CanInlineResult.NO;\n      }\n\n      fnParam = fnParam.getNext();\n      cArg = cArg.getNext();\n    } else if (cArg != null) {\n      // Extra call\u2013arguments (with no matching formal parameter)\n      // must be side\u2013effect free.\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // Formal parameters without a corresponding call argument are okay.\n      fnParam = fnParam.getNext();\n    }\n  }\n\n  return CanInlineResult.YES;\n}\n\n/**\n * Returns true if every reference to the parameter (by name) in the given\n * AST (typically the function body) is used only on the left\u2013hand side of\n * an assignment. (That is, the parameter is only \u201cmodified\u201d and never read.)\n * This is important for direct inlining of arguments that are not immutable:\n * if the formal parameter isn\u2019t read, then delaying the evaluation until\n * the assignment site is safe.\n */\nprivate boolean isOnlyWritten(Node root, final String param) {\n  return isOnlyWrittenHelper(root, param);\n}\n\n/**\n * Helper: traverses the subtree rooted at n and returns false immediately if\n * any read\u2013usage (non\u2013LHS) of a name matching param is encountered.\n */\nprivate boolean isOnlyWrittenHelper(Node n, String param) {\n  if (n == null) {\n    return true;\n  }\n\n  // If this is a name node matching \"param\" then check its usage.\n  if (n.isName() && param.equals(n.getString())) {\n    Node parent = n.getParent();\n    // Consider the occurrence safe if it is the target (first child) of an assignment.\n    if (parent != null && parent.isAssign() && parent.getFirstChild() == n) {\n      // safe usage (write\u2013only)\n    } else {\n      // Any other occurrence counts as a read.\n      return false;\n    }\n  }\n\n  // Recursively check all children in evaluation order.\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!isOnlyWrittenHelper(child, param)) {\n      return false;\n    }\n  }\n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}