{
    "generation": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  // The function body block.\n  Node block = fnNode.getLastChild();\n\n  // 1) Collect the function's parameter names.\n  java.util.List<String> paramNames = new java.util.ArrayList<String>();\n  for (Node p = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n       p != null; p = p.getNext()) {\n    paramNames.add(p.getString());\n  }\n\n  // 2) Compute how many actual arguments are passed (skipping the \"this\"\n  //    if it's a .call invocation).\n  Node firstChild = callNode.getFirstChild();\n  Node argCursor = firstChild.getNext();\n  if (!firstChild.isName() && NodeUtil.isFunctionObjectCall(callNode)) {\n    // Must have a \"this\" as the first parameter.\n    if (argCursor == null || !argCursor.isThis()) {\n      return CanInlineResult.NO;\n    }\n    argCursor = argCursor.getNext();\n  }\n  int callArgsCount = 0;\n  for (Node a = argCursor; a != null; a = a.getNext()) {\n    callArgsCount++;\n  }\n\n  // 3) The original checks: multiple mutable-state effects,\n  //    side-effects in the argument expressions, etc.\n  Node cArg = callNode.getFirstChild().getNext();\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" should have been filtered out already.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    if (fnParam != null) {\n      if (cArg != null) {\n        if (NodeUtil.mayEffectMutableState(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n      fnParam = fnParam.getNext();\n    }\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  // 4) NEW CHECK: make sure no parameter is *used* after a side-effect\n  //    in the function body.  Otherwise we would change evaluation order\n  //    of that parameter relative to the body.\n  final java.util.Set<String> unsafeParams =\n      new java.util.HashSet<String>();\n  class Detector {\n    boolean sideEffectOccurred = false;\n    void traverse(Node n) {\n      if (n == null) {\n        return;\n      }\n      // If this is a reference to one of our parameters and we've already\n      // seen a side-effect, mark it unsafe.\n      if (n.isName()) {\n        String nm = n.getString();\n        if (paramNames.contains(nm) && sideEffectOccurred) {\n          unsafeParams.add(nm);\n        }\n      }\n      // Do not recurse into nested function declarations.\n      if (n.isFunction()) {\n        return;\n      }\n      // Recurse in evaluation order (child order).\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n      // After visiting children, record if *this* node has a side-effect.\n      // (calls, news, assignments, increments/decrements)\n      if (n.isCall()\n          || n.isNew()\n          || NodeUtil.isAssignmentOp(n)\n          || n.isInc()\n          || n.isDec()) {\n        sideEffectOccurred = true;\n      }\n    }\n  }\n  Detector det = new Detector();\n  for (Node stmt = block.getFirstChild(); stmt != null; stmt = stmt.getNext()) {\n    det.traverse(stmt);\n  }\n  // If any parameter that we actually passed an argument for was used\n  // unsafely, decline to inline.\n  for (int i = 0; i < callArgsCount && i < paramNames.size(); i++) {\n    if (unsafeParams.contains(paramNames.get(i))) {\n      return CanInlineResult.NO;\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}