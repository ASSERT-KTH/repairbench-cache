{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   * 2) If a function's body has side effects, it can not be inlined if the\n   *    call has arguments that could be affected by the side effect.\n   *    For instance:\n   * <pre>\n   *     function foo(a) { x=1; return a; }\n   *     y = foo(x); // x is evaluated before foo is called.\n   * </pre>\n   *    This is not inlined.\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    // Cache check result for performance and consistent use in the loop.\n    boolean functionHasSideEffects = NodeUtil.functionHasSideEffects(fnNode, compiler);\n\n    while (cArg != null || fnParam != null) {\n      // Store the current parameter reference to ensure we handle arguments\n      // without corresponding parameters appropriately.\n      Node currentParam = fnParam;\n\n      // For each named parameter check associated argument properties.\n      if (fnParam != null) {\n        if (cArg != null) {\n          int refCount = NodeUtil.getNameReferenceCount(block, fnParam.getString());\n          boolean paramIsReferenced = refCount > 0;\n\n          // Check 1: An argument that refers to mutable state MUST NOT be used\n          // for a parameter that is used more than once.\n          if (refCount > 1 && NodeUtil.mayEffectMutableState(cArg, compiler)) {\n            return CanInlineResult.NO;\n          }\n\n          // Check 2: Interaction between mutable argument & body side effects (Issue 1101).\n          // If the argument could be affected by side effects (e.g., x.prop) and the\n          // function body has side effects, inlining is unsafe if the parameter is used,\n          // because the body's side effects might change the argument's value\n          // before the parameter is used.\n          if (paramIsReferenced && NodeUtil.canBeSideEffected(cArg) && functionHasSideEffects) {\n             // This conservative check fixes Issue 1101a and 1101b by preventing inlining\n             // when mutable arguments are used in functions with side effects.\n             return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next parameter.\n        fnParam = fnParam.getNext();\n      }\n\n      // Check side effects for arguments, especially those without corresponding parameters.\n      if (cArg != null) {\n        // If the argument itself has side-effects, it must be evaluated.\n        // Inlining is unsafe if the corresponding parameter is not used (or does not exist),\n        // as the side-effect might be dropped.\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          boolean safeToDropArg = false;\n          if (currentParam != null) {\n             // Parameter exists for this argument. Check if it's referenced.\n             // We need the reference count for the specific parameter that corresponds to cArg.\n             int currentParamRefCount = NodeUtil.getNameReferenceCount(block, currentParam.getString());\n             if (currentParamRefCount > 0) {\n                // Param is referenced. Side effect ordering compared to body side effects\n                // was handled by Check 2 above. The evaluation of cArg itself will happen\n                // when it replaces currentParam. Assume okay for now w.r.t dropping side effect.\n                safeToDropArg = true;\n             }\n          }\n          // If safeToDropArg is false, it means either:\n          // 1) No parameter existed for this argument (currentParam == null)\n          // 2) Parameter existed but was not referenced (currentParamRefCount == 0)\n          // In either case, the side effect of cArg must be preserved. Direct inlining\n          // might drop it if the parameter isn't used. Be conservative and disallow.\n          if (!safeToDropArg) {\n             return CanInlineResult.NO;\n          }\n        }\n        // Move to the next argument.\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}