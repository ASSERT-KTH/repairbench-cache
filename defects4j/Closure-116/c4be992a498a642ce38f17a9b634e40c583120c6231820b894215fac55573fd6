{
    "generation": "private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  // The function body block.\n  Node block = fnNode.getLastChild();\n\n  // Collect the parameter names.\n  java.util.Set<String> paramNames = new java.util.HashSet<>();\n  for (Node p = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n       p != null; p = p.getNext()) {\n    paramNames.add(p.getString());\n  }\n\n  // Walk the entire body and reject if there is any CALL or NEW,\n  // or any assignment whose target is not a property of one of the parameters.\n  java.util.List<Node> worklist = new java.util.ArrayList<>();\n  worklist.add(block);\n  for (int i = 0; i < worklist.size(); i++) {\n    Node n = worklist.get(i);\n    if (n.isCall() || n.isNew()) {\n      return CanInlineResult.NO;\n    }\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      if (lhs.isGetProp() || lhs.isGetElem()) {\n        Node obj = lhs.getFirstChild();\n        // Only allow assignments to a parameter's property.\n        if (!obj.isName() || !paramNames.contains(obj.getString())) {\n          return CanInlineResult.NO;\n        }\n      } else {\n        // Disallow any other kind of assignment in a direct inline.\n        return CanInlineResult.NO;\n      }\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      worklist.add(c);\n    }\n  }\n\n  // ------------------------------------------------------------------\n  // Now check the usual argument\u2010side\u2010effects criteria:\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node cArg = callNode.getFirstChild().getNext();\n\n  // Handle foo.call(thisObj, ...) calls specially.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // We only support inlining if the \"this\" is explicit.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // \".apply\" calls should not reach here.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n\n  // Iterate parameters vs. call arguments.\n  Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  while (cArg != null || fnParam != null) {\n    if (fnParam != null) {\n      if (cArg != null) {\n        // If the call argument has mutable effects, the parameter\n        // must only be referenced once in the body.\n        if (NodeUtil.mayEffectMutableState(cArg, compiler)\n            && NodeUtil.getNameReferenceCount(\n                block, fnParam.getString()) > 1) {\n          return CanInlineResult.NO;\n        }\n      }\n      fnParam = fnParam.getNext();\n    }\n\n    // Even if there's no matching parameter, we must ensure\n    // that no argument has any side-effects (so we don't drop them).\n    if (cArg != null) {\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    }\n  }\n\n  return CanInlineResult.YES;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}