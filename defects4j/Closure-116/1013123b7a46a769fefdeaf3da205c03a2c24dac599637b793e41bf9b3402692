{
    "generation": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  // First, make sure the \u201cdirect\u2010call\u201d properties of the function node hold.\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n  Node block = fnNode.getLastChild();\n\n  //----------------------------------------------------------------------------\n  // Collect the call\u2019s argument nodes.\n  // The call node structure is assumed to be: [ callee, arg1, arg2, \u2026 ]\n  List<Node> callArgs = new ArrayList<>();\n  Node cArg = callNode.getFirstChild().getNext();\n  // Functions invoked via call/apply have an extra \u201cthis\u201d parameter.\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      // When called as a function object, the first argument must be 'this'.\n      if (cArg == null || !cArg.isThis()) {\n        return CanInlineResult.NO;\n      }\n      cArg = cArg.getNext();\n    } else {\n      // .apply calls ought to have been filtered earlier.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n    }\n  }\n  for (; cArg != null; cArg = cArg.getNext()) {\n    callArgs.add(cArg);\n  }\n\n  //----------------------------------------------------------------------------\n  // Collect the formal parameters.\n  Node params = NodeUtil.getFunctionParameters(fnNode);\n  List<Node> formalParams = new ArrayList<>();\n  for (Node p = params.getFirstChild(); p != null; p = p.getNext()) {\n    formalParams.add(p);\n  }\n  \n  // For the paired parameters, check two things:\n  //   (1) if a call argument \u201cmight change state\u201d (that is, its value is not\n  //       guaranteed to be the same on a repeated evaluation) then its parameter\n  //       must be referenced at most once.\n  //   (2) ALSO the \u201cevaluation\u2010order\u201d must be preserved.\n  //       (That is, when the function is invoked, its call arguments are evaluated\n  //       before entering the function body. Thus if an argument is not \u201cimmutable\u201d\n  //       then substituting it directly may change the value that is observed,\n  //       if the parameter is used later than the \u201cbeginning\u201d of the returned\n  //       expression.)\n  int pairCount = Math.min(callArgs.size(), formalParams.size());\n  // For the \u201corder\u201d check we try to grab a simple return statement from the function\n  // body. (Only simple functions are handled by direct inlining.)\n  Node firstStmt = block.getFirstChild();\n  Node retExpr = (firstStmt != null && firstStmt.isReturn()) ? firstStmt.getFirstChild() : null;\n  for (int i = 0; i < pairCount; i++) {\n    Node argNode = callArgs.get(i);\n    Node paramNode = formalParams.get(i);\n    String paramName = paramNode.getString();\n    \n    // (1) If the call argument is \u201cmutable\u201d and the parameter is used more than once,\n    //     inlining could duplicate side effects.\n    if (NodeUtil.mayEffectMutableState(argNode, compiler)\n        && NodeUtil.getNameReferenceCount(block, paramName) > 1) {\n      return CanInlineResult.NO;\n    }\n\n    // (2) If the call argument is not \u201cimmutable\u201d then its value must be \u201ccaptured\u201d\n    //     immediately in the function body. Otherwise the original call evaluates the\n    //     argument before any side-effects in the function run.\n    if (!isImmutable(argNode)) {\n      // For example, these two cases are not allowed:\n      //   foo(x)  where function foo(a) { return modifiyX() + a; }\n      //   foo(x.prop) where function foo(a) { return (x.prop = 2), a; }\n      if (retExpr == null || !isParameterUsedImmediately(retExpr, paramName)) {\n        return CanInlineResult.NO;\n      }\n    }\n  }\n  \n  //----------------------------------------------------------------------------\n  // For any extra call arguments (beyond those matched by the formal parameters),\n  // they must be side-effect\u2013free.\n  for (int i = pairCount; i < callArgs.size(); i++) {\n    Node extraArg = callArgs.get(i);\n    if (NodeUtil.mayHaveSideEffects(extraArg, compiler)) {\n      return CanInlineResult.NO;\n    }\n  }\n  \n  return CanInlineResult.YES;\n}\n\n/**\n * A call argument is considered immutable if it is a literal or the \"this\" keyword.\n */\nprivate boolean isImmutable(Node n) {\n  return n.isNumber() || n.isString() || n.isTrue() || n.isFalse() || n.isNull() || n.isThis();\n}\n\n/**\n * Returns whether the first occurrence (in evaluation order) of the parameter\n * inside the returned expression is \u201cimmediate\u201d \u2013 that is, the parameter\u2019s value\n * will be obtained as if it had been computed at the time of the call.\n *\n * For example, these are considered safe:\n *   function f(a) { return a; }\n *   function f(a) { return a.x = 2; } // the object 'a' is grabbed immediately\n *   function f(a) { return getWindow(a); } // if \"a\" is the sole argument\n *\n * And these are not safe:\n *   function f(a) { return modifiyX() + a; }  // a is used only after modifiyX()\n *   function f(a) { return (x.prop = 2), a; }  // a comes after the comma operator\n */\nprivate boolean isParameterUsedImmediately(Node expr, String paramName) {\n  if (expr == null) {\n    return false;\n  }\n  switch (expr.getToken()) {\n    case NAME:\n      return expr.getString().equals(paramName);\n      \n    case GETPROP:\n      // In a property access, the object is evaluated first.\n      Node obj = expr.getFirstChild();\n      return obj != null && obj.isName() && obj.getString().equals(paramName);\n      \n    case GETELEM:\n      Node objElem = expr.getFirstChild();\n      return objElem != null && objElem.isName() && objElem.getString().equals(paramName);\n      \n    case ASSIGN:\n      // For an assignment, the left side is evaluated first.\n      Node lhs = expr.getFirstChild();\n      if ((lhs.getType() == Token.GETPROP || lhs.getType() == Token.GETELEM)\n          && lhs.getFirstChild() != null\n          && lhs.getFirstChild().isName()\n          && lhs.getFirstChild().getString().equals(paramName)) {\n        return true;\n      }\n      return false;\n      \n    case CALL:\n      // In a call, the callee is evaluated first; if that is the parameter, it is safe.\n      Node callee = expr.getFirstChild();\n      if (callee.isName() && callee.getString().equals(paramName)) {\n        return true;\n      }\n      // Otherwise, check whether the very first argument uses the parameter.\n      Node firstArg = callee.getNext();\n      if (firstArg != null && NodeUtil.containsName(firstArg, paramName)) {\n        return true;\n      }\n      return false;\n      \n    case ADD:\n    case SUB:\n    case MUL:\n    case DIV:\n    case MOD:\n      // For binary operators, the left operand is evaluated first.\n      return NodeUtil.containsName(expr.getFirstChild(), paramName);\n      \n    default:\n      return false;\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}