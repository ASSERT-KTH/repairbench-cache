{
    "generation": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          // Malformed call FUNCTION.call() node.\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext(); // Skip 'this' arg.\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // Check arguments vs parameters\n      if (fnParam != null) {\n        if (cArg != null) {\n          // Check if the argument is safe to be used more than once.\n          // An argument is unsafe to be used multiple times if it has side-effects\n          // or its value may change between reads.\n          boolean argUnsafeForMultipleUses = NodeUtil.mayHaveSideEffects(cArg, compiler)\n              || NodeUtil.mayEffectMutableState(cArg, compiler);\n\n          if (argUnsafeForMultipleUses) {\n             int refCount = NodeUtil.getNameReferenceCount(block, fnParam.getString());\n             if (refCount > 1) {\n               // If the parameter is used more than once, it's not safe\n               // to inline this argument.\n               return CanInlineResult.NO;\n             }\n          }\n        }\n        // Move to the next parameter\n        fnParam = fnParam.getNext();\n      }\n\n      // Check extra arguments for side-effects\n      if (cArg != null) {\n        if (fnParam == null) { // Current argument is not matched by a parameter\n          if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n            // Don't inline functions with arguments that have side effects\n            // that are not assigned to parameters. We would lose the side effect.\n            return CanInlineResult.NO;\n          }\n        }\n        // Move to the next argument\n        cArg = cArg.getNext();\n      }\n    }\n\n    // TODO(johnlenz): Add checks for functions that access \"arguments\" or \"this\"\n    // in ways that can't be replicated easily.\n\n    // TODO(johnlenz): Add checks for functions that contains references to itself\n    // either by name or via arguments.callee.\n\n    // It is possible that the function body has side-effects but that the\n    // Candidate function properly handles those side-effects.\n\n    // Current Handling: If the function contains side-effects, and the\n    // arguments have side-effects or are mutable then the inlining may\n    // not be safe.\n\n    // Check for side-effects in the function body if any arguments\n    // depend on mutable state (are non-local constants)\n    // This check handles cases like testIssue1101a and testIssue1101b\n    // where function body side-effects might interact with argument values.\n    boolean functionHasSideEffects = NodeUtil.canBeSideEffected(block);\n    if (functionHasSideEffects) {\n        cArg = callNode.getFirstChild().getNext(); // Reset argument pointer\n        // Handle .call again\n        if (!callNode.getFirstChild().isName() && NodeUtil.isFunctionObjectCall(callNode)) {\n            cArg = cArg.getNext(); // Skip 'this' arg.\n        }\n        fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); // Reset param pointer\n        while (cArg != null && fnParam != null) {\n            if (NodeUtil.mayEffectMutableState(cArg, compiler)) {\n                int refCount = NodeUtil.getNameReferenceCount(block, fnParam.getString());\n                if (refCount > 0) {\n                    // If the function body has potential side-effects, and it uses a parameter\n                    // whose corresponding argument may depend on mutable state,\n                    // avoid inlining to be conservative.\n                    return CanInlineResult.NO;\n                }\n            }\n            cArg = cArg.getNext();\n            fnParam = fnParam.getNext();\n        }\n    }\n\n\n    return CanInlineResult.YES;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}