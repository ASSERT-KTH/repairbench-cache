{
    "generation": "private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      // Check if the name is in a scope where inlining is safe.\n      // Specifically, we should not inline aliases in functions that are\n      // immediately invoked or passed around, as it might change their\n      // behavior.\n      if (name.getScope().isGlobal()) {\n        if (name.globalSets == 1 && name.localSets == 0 &&\n            name.aliasingGets > 0) {\n          // {@code name} meets condition (b). Find all of its local aliases\n          // and try to inline them.\n          List<Ref> refs = new ArrayList<>(name.getRefs());\n          for (Ref ref : refs) {\n            if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n              // {@code name} meets condition (c). Try to inline it.\n              // However, we need to ensure that the alias is not used in a way\n              // that would be affected by inlining, such as being passed to\n              // another function or being used in a context where its identity\n              // matters.\n              if (canInlineAlias(ref, namespace)) {\n                if (inlineAliasIfPossible(ref, namespace)) {\n                  name.removeRef(ref);\n                }\n              }\n            }\n          }\n        }\n\n        // Check if {@code name} has any aliases left after the\n        // local-alias-inlining above.\n        if ((name.type == Name.Type.OBJECTLIT ||\n             name.type == Name.Type.FUNCTION) &&\n            name.aliasingGets == 0 && name.props != null) {\n          // All of {@code name}'s children meet condition (a), so they can be\n          // added to the worklist.\n          workList.addAll(name.props);\n        }\n      }\n    }\n  }\n\n  // Helper method to check if an alias can be safely inlined.\n  private boolean canInlineAlias(Ref ref, GlobalNamespace namespace) {\n    // Check if the alias is used in a context where its identity matters.\n    // For example, if the alias is passed to a function that might call it\n    // back, inlining could change the behavior.\n    Node node = ref.node;\n    while (node != null && !node.isScript()) {\n      if (node.isCall() || node.isNew()) {\n        // If the alias is passed as an argument to a function, we should not\n        // inline it unless we are sure the function does not rely on its\n        // identity.\n        for (Node arg : node.children()) {\n          if (arg == ref.node) {\n            return false;\n          }\n        }\n      }\n      node = node.getParent();\n    }\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}