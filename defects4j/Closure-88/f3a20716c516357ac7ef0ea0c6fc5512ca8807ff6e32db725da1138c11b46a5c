{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   * This is based on left-to-right execution order within the expression.\n   */\n  private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    // Base case: If we find the variable name, treat it as a READ initially.\n    // The specific handling of assignments (KILLs) is done when visiting\n    // the ASSIGN parent node to ensure correct evaluation order.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // Check if this name is the LHS of an assignment within the original code structure.\n      // However, relying on parent check here is tricky and led to the bug.\n      // Instead, we return READ, and let the ASSIGN node logic determine the KILL.\n      return VariableLiveness.READ;\n    }\n\n    // Handle assignments specially to respect evaluation order.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = n.getLastChild();\n      // Simple assignment is \"=\", others are compound (e.g., \"+=\", \"*=\")\n      boolean isSimpleAssign = n.getToken() == com.google.javascript.rhino.Token.ASSIGN;\n\n      // 1. Compound assignments (e.g., x += 1) read the LHS first.\n      //    Check the LHS subtree for any reads/kills of the variable.\n      //    This handles reads like 'x' in 'x+=1' or 'i' in 'a[i]+=1'.\n      if (!isSimpleAssign) {\n        VariableLiveness lhsState = isVariableReadBeforeKill(lhs, variable);\n        if (lhsState == VariableLiveness.READ) {\n          // Any read within the LHS structure happens first.\n          return VariableLiveness.READ;\n        } else if (lhsState == VariableLiveness.KILL) {\n          // A kill within the LHS structure (e.g., a[x=(b=1)] += 2, checking 'b')\n          // happens before the compound assignment's own action.\n          return VariableLiveness.KILL;\n        }\n        // If lhsState is MAYBE_LIVE, continue checking RHS, then the final kill.\n      }\n\n      // 2. Evaluate the RHS. Check for reads/kills there. This happens before the\n      //    final assignment operation.\n      VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n      if (rhsState != VariableLiveness.MAYBE_LIVE) {\n        // A read or kill in the RHS happens before the final assignment.\n        return rhsState;\n      }\n\n      // 3. For simple assignments (=), evaluate LHS structure *before* the kill.\n      //    Check for reads/kills within LHS components (like index expressions, e.g., 'x' in a[x]=1).\n      if (isSimpleAssign) {\n           VariableLiveness lhsState = isVariableReadBeforeKill(lhs, variable);\n           // We only care if a read/kill happens in a *component* of the LHS,\n           // not the target variable NAME itself (which implies the KILL later).\n           if (lhsState == VariableLiveness.READ) {\n               // If the LHS is complex (not just the target NAME), a read found\n               // within it (e.g., the index) occurs before the assignment.\n               if (!(NodeUtil.isName(lhs) && variable.equals(lhs.getString()))) {\n                   return VariableLiveness.READ;\n               }\n               // If the read was just the target NAME node, ignore it here; handled next.\n           } else if (lhsState == VariableLiveness.KILL) {\n               // A kill can also occur within LHS evaluation (e.g. a[b=(c=1)]=2, check 'c')\n               // This kill happens before the outer assignment completes.\n                return VariableLiveness.KILL;\n           }\n           // If state is MAYBE_LIVE, continue.\n      }\n\n      // 4. If RHS/LHS components didn't determine state, the final action is the\n      //    assignment's KILL, provided the LHS is the variable name itself.\n      //    This happens *after* RHS and LHS structure evaluation.\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n        return VariableLiveness.KILL;\n      }\n\n      // 5. If none of the above returned, this assignment node doesn't cause\n      //    the *first* READ or KILL of this variable within its evaluation sequence.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // Default traversal: Left-to-right, depth-first for non-assignment nodes.\n    // This handles operators like &&, +, function calls, etc.\n    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n      // Skip function bodies, as their liveness is separate and handled by CFG.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // Found the first read/kill in a child according to L-R evaluation.\n          return state;\n        }\n      }\n    }\n\n    // Variable not found in this subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}