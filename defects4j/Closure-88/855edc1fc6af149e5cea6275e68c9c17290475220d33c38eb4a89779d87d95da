{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAYBE_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // Case 1: n is the variable name itself.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // If this name node is the left-hand side of an assignment, it signifies a KILL.\n      // This KILL occurs *after* the RHS is evaluated. The handling for ASSIGN nodes\n      // below will ensure correct evaluation order for the overall assignment expression.\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ; // Otherwise, it's a read.\n      }\n    }\n\n    // Case 2: n is an ASSIGN node.\n    // For an assignment `lhs = rhs`, the `rhs` is evaluated before the assignment occurs.\n    if (n.isAssign()) {\n      // Evaluate the right-hand side first.\n      Node rhs = n.getLastChild();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        // If the variable is read or killed in the RHS, that's the first reference\n        // in this assignment expression.\n        return state;\n      }\n      // If the variable is not found in the RHS, then the assignment to the LHS\n      // is the first reference for this expression. This is a KILL, but only if\n      // the LHS is indeed the variable we are tracking.\n      Node lhs = n.getFirstChild();\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n        return VariableLiveness.KILL;\n      }\n      // If the LHS is not the variable, and RHS was MAYBE_LIVE, then the variable is MAYBE_LIVE\n      // within this assignment expression.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // Case 3: General expression (not the variable name, not an ASSIGN node).\n    // Expressions are evaluated left-right, depth-first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Don't recurse into FUNCTION nodes or similar control flow boundaries,\n      // as they introduce new scopes or change control flow, handled by other analyses.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // If a reference (READ or KILL) is found in a child, return it immediately\n          // as it's the \"first\" in evaluation order.\n          return state;\n        }\n      }\n    }\n\n    // Case 4: No reference found in this subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}