{
    "generation": "/**\n * Give an expression and a variable. It returns READ if the first \u201ceffective\u201d\n * reference to that variable is a true read; it returns KILL if the variable is\n * \u201cover\u2010written\u201d (i.e. assigned) before any such read. (Note that in an assignment\n * the \u201ckill\u201d doesn\u2019t occur until after the right\u2010hand side is evaluated.)  If no\n * reference is encountered the function returns MAYBE_LIVE.\n *\n * <p>This version fixes the bug by (1) \u201cdelaying\u201d the effect of a left\u2010hand\n * side (LHS) occurrence in an assignment until after its right\u2010hand side (RHS)\n * is scanned, and (2) by \u201caccumulating\u201d liveness info over children rather than\n * immediately returning on the first non\u2010MAYBE_LIVE value. In particular, for\n * short\u2013circuited expressions (e.g. &&, \u2013) a read later in the expression \u201cwins\u201d\n * over an earlier assignment.\n */\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  return isVariableReadBeforeKill(n, variable, false);\n}\n\n/**\n * The additional flag ignoreSelf tells this recursive routine to ignore any\n * occurrence of the given variable. This is used when scanning the right\u2013hand\n * side of an assignment to preclude self\u2013references (which use the variable\u2019s\n * old value and should not force the assignment to be considered live).\n */\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable, boolean ignoreSelf) {\n  if (n == null) {\n    return VariableLiveness.MAYBE_LIVE;\n  }\n\n  // Special handling for an assignment node: though the LHS appears first\n  // syntactically, the assignment\u2019s \u201ckill\u201d takes effect only after the RHS is evaluated.\n  // Thus, we scan the RHS (ignoring self\u2013references) before scanning the LHS.\n  if (n.getType() == Token.ASSIGN) {\n    Node lhs = n.getFirstChild();\n    Node rhs = lhs.getNext(); // In an assignment, the RHS immediately follows the LHS.\n    // Evaluate the RHS first. While scanning the RHS we ignore any occurrence of \u2018variable\u2019\n    // (self\u2013references) because they use the old value.\n    VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable, true);\n    if (rhsState == VariableLiveness.READ) {\n      return VariableLiveness.READ;\n    }\n    // Now scan the LHS normally.\n    VariableLiveness lhsState = isVariableReadBeforeKill(lhs, variable, ignoreSelf);\n    if (lhsState == VariableLiveness.READ) {\n      return VariableLiveness.READ;\n    }\n    // In an assignment to the variable, if no read was found in the RHS or LHS,\n    // the assignment \u201ckills\u201d (overwrites) the variable.\n    return VariableLiveness.KILL;\n  }\n\n  // If this node is a name, check if it matches.\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    // In a context where we are ignoring self\u2013references (e.g. when scanning an RHS)\n    // simply treat the reference as if it didn\u2019t occur.\n    if (ignoreSelf) {\n      return VariableLiveness.MAYBE_LIVE;\n    }\n    // Otherwise, if this name is an LHS (being assigned), then it is a kill.\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      return VariableLiveness.KILL;\n    }\n    // A normal occurrence is a read.\n    return VariableLiveness.READ;\n  }\n\n  // For general nodes, we \u201caccumulate\u201d the liveness information from children.\n  // Unlike the original code that returned immediately upon a non\u2013MAYBE_LIVE result,\n  // here we scan all children so that in short\u2013circuiting constructs (like && or \u2013)\n  // a later read can override an earlier kill.\n  boolean foundKill = false;\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness childState = isVariableReadBeforeKill(child, variable, ignoreSelf);\n      if (childState == VariableLiveness.READ) {\n        return VariableLiveness.READ;\n      } else if (childState == VariableLiveness.KILL) {\n        foundKill = true;\n      }\n    }\n  }\n  return foundKill ? VariableLiveness.KILL : VariableLiveness.MAYBE_LIVE;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}