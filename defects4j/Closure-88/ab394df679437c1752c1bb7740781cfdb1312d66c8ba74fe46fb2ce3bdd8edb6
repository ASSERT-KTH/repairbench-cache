{
    "generation": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  // Delegate to the overloaded helper with the \u201cignoreSelf\u201d flag false.\n  return isVariableReadBeforeKill(n, variable, false);\n}\n\n/**\n * This helper method does the real work. The extra flag \u201cignoreSelf\u201d tells the\n * method to ignore \u201cself\u2010references\u201d (reads of the same variable that occur in\n * the right\u2010hand side of an assignment to that variable). This is needed because\n * in an assignment like \u201cx = f(x)\u201d the \u201cx\u201d on the LHS is not (yet) killing the old value\u2014\n * any occurrence of \u201cx\u201d in the RHS should not count as a \u201cread\u201d (making the assignment live)\n * when deciding whether the assignment\u2019s computed value is used.\n */\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable, boolean ignoreSelf) {\n  if (n == null) {\n    return VariableLiveness.MAYBE_LIVE;\n  }\n\n  // If this node is a name that matches our variable\u2026\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    // When we are in \u201cignoreSelf\u201d mode (i.e. scanning an assignment\u2019s RHS for self\u2013references),\n    // we do not want a self\u2013reference to count as a READ.\n    if (ignoreSelf) {\n      return VariableLiveness.MAYBE_LIVE;\n    }\n    // In normal mode, if the name appears as the LHS of an assignment,\n    // we want to delay reporting a kill so that any \u201creal\u201d read later in the overall expression\n    // (outside the assignment\u2019s \u201cself\u2010referential\u201d part) can make the overall value live.\n    if (NodeUtil.isLhs(n, n.getParent()) \n          && n.getParent() != null \n          && n.getParent().getType() == Token.ASSIGN \n          && n == n.getParent().getFirstChild()) {\n      return VariableLiveness.MAYBE_LIVE;\n    }\n    // Otherwise, if not on the LHS then it\u2019s a genuine read.\n    return NodeUtil.isLhs(n, n.getParent()) ? VariableLiveness.KILL : VariableLiveness.READ;\n  }\n\n  // Special handling for an assignment that writes to our variable.\n  // (E.g. for \u201cx = ...\u201d, if the right\u2010hand side uses \u201cx\u201d in a self\u2013reference, we want to treat\n  // the assignment as dead\u2014so later we can remove the \u201cx=\u201d part.)\n  if (n.getType() == Token.ASSIGN && n.getFirstChild() != null \n      && NodeUtil.isName(n.getFirstChild()) \n      && variable.equals(n.getFirstChild().getString())) {\n    // Scan the RHS in \u201cignoreSelf\u201d mode so that any occurrence of the variable there is not counted.\n    VariableLiveness rhsState = isVariableReadBeforeKill(n.getLastChild(), variable, true);\n    // If the RHS (ignoring self\u2013reads) still produces any non\u2010neutral effect, we interpret\n    // that as a \u201ckill\u201d by this assignment.\n    if (rhsState != VariableLiveness.MAYBE_LIVE) {\n      return VariableLiveness.KILL;\n    }\n    // Otherwise fall through to combine all children.\n  }\n\n  // Instead of returning as soon as a non-neutral child is seen,\n  // iterate over all children in evaluation order and \u201ccombine\u201d the results.\n  // (A READ later in the order \u201coverrides\u201d a KILL earlier.)\n  VariableLiveness result = VariableLiveness.MAYBE_LIVE;\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    VariableLiveness childState = isVariableReadBeforeKill(child, variable, ignoreSelf);\n    if (childState == VariableLiveness.READ) {\n      return VariableLiveness.READ;  // READ wins over any KILL.\n    } else if (childState == VariableLiveness.KILL) {\n      result = VariableLiveness.KILL;\n      // Do not short\u2010circuit here because a later READ (in a short\u2010circuited operator, for example)\n      // might flip the overall result.\n    }\n  }\n  return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}