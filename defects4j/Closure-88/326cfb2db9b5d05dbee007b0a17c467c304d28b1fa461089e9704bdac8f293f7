{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    // Special handling for assignment nodes where the LHS is the variable.\n    // This must be checked first to correctly prioritize RHS evaluation.\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        // Check if the LHS of this assignment is the variable we are tracking.\n        if (lhs != null && lhs.isName() && variable.equals(lhs.getString())) {\n            Node rhs = n.getLastChild();\n            // Evaluate the RHS first for any references to the variable.\n            VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n\n            // If a READ or KILL is found in the RHS, that takes precedence.\n            if (rhsState != VariableLiveness.MAYBE_LIVE) {\n                return rhsState;\n            }\n            // If RHS is MAYBE_LIVE, then the assignment to 'lhs' is the first relevant event.\n            // This constitutes a KILL.\n            return VariableLiveness.KILL;\n        }\n        // If this is an assignment node but its LHS is not the tracked variable,\n        // it falls through to the general child traversal.\n    }\n\n    // If n is the variable name itself.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // If 'n' is the variable and it's on the LHS of an assignment,\n        // its KILL effect happens after the RHS is evaluated.\n        // Thus, if we encounter 'n' itself (the LHS name node), it's not a direct READ\n        // and its KILL is considered later via the parent ASSIGN node.\n        // So, for this specific node, it's MAYBE_LIVE to allow checking of subsequent nodes (RHS).\n        return VariableLiveness.MAYBE_LIVE;\n      } else {\n        // 'n' is the variable and it's NOT an LHS. This is a direct READ.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    // Iterate children, stopping at the first READ or KILL found.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Don't descend into new control flow graph nodes (e.g., functions),\n      // as their inner variables are not relevant for this scope.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state; // Found a READ or KILL, return it immediately.\n        }\n      }\n    }\n\n    // If no READ or KILL was found in the current node or its children, it's MAYBE_LIVE.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}