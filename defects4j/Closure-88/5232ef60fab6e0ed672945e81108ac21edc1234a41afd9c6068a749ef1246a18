{
    "generation": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  // Special handling for assignment nodes.\n  // In an assignment the left\u2010hand side is evaluated before the right\u2010hand side,\n  // but its \u201ckill\u201d does not take effect until after the right\u2010hand side is done.\n  if (n.getType() == Token.ASSIGN) {\n    // In an assignment node, the first child is the LHS and the second is the RHS.\n    Node lhs = n.getFirstChild();\n    Node rhs = lhs.getNext();\n    // Evaluate the LHS.  Note: if the LHS is a name matching the variable,\n    // we \u201cdelay\u201d its kill effect so that a later read (in the RHS) can override it.\n    VariableLiveness lhsState = isVariableReadBeforeKill(lhs, variable);\n    // If the LHS itself produces a read (as in a compound assignment like x += ...),\n    // then the assignment is live.\n    if (lhsState == VariableLiveness.READ) {\n      return VariableLiveness.READ;\n    }\n    // Now evaluate the RHS.\n    VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n    if (rhsState == VariableLiveness.READ) {\n      return VariableLiveness.READ;\n    }\n    // Only if the LHS \u201cwould kill\u201d the variable and the RHS does not read it\n    // do we consider the assignment to be a kill.\n    if (lhsState == VariableLiveness.KILL) {\n      return VariableLiveness.KILL;\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }\n\n  // For ordinary nodes: if this node is a name matching the variable, then:\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    // If the name occurs in a left\u2010hand side position...\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      // But if the parent's an assignment, then the kill is delayed until after\n      // the RHS is evaluated.  In that case we don\u2019t want to return KILL immediately.\n      if (n.getParent() != null && n.getParent().getType() == Token.ASSIGN) {\n        return VariableLiveness.MAYBE_LIVE;\n      }\n      return VariableLiveness.KILL;\n    }\n    // Otherwise, the use is a read.\n    return VariableLiveness.READ;\n  }\n\n  // For all other nodes, traverse children in evaluation order.\n  // Note: we cannot simply short-circuit on a KILL result because in a delayed-kill\n  // context (for example, within the operands of &&) a later occurrence might be a read.\n  VariableLiveness result = VariableLiveness.MAYBE_LIVE;\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness childState = isVariableReadBeforeKill(child, variable);\n      if (childState == VariableLiveness.READ) {\n        return VariableLiveness.READ;\n      }\n      if (childState == VariableLiveness.KILL && result == VariableLiveness.MAYBE_LIVE) {\n        result = VariableLiveness.KILL;\n      }\n    }\n  }\n  return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}