{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAYBE_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    // Special handling for assignment nodes (e.g., `x = y`).\n    // The RHS (`y`) is evaluated before the LHS (`x`) is assigned/killed.\n    if (n.isAssign()) {\n      Node rhs = n.getLastChild();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        // Found a read or kill in the RHS, which occurs first.\n        return state;\n      }\n\n      // If no reference was found in the RHS, then check the LHS.\n      // If the LHS is the variable we are looking for, the assignment itself\n      // is a \"kill\" for the variable. This is the first reference if it\n      // wasn't present in the RHS.\n      Node lhs = n.getFirstChild();\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n        return VariableLiveness.KILL;\n      }\n      // If the variable was not found in RHS, and the LHS is not the variable itself,\n      // then the variable's first reference is not within this assignment node.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // Check if `n` itself is the variable in question.\n    // This handles direct variable references that are not the `ASSIGN` operator node itself.\n    // Examples: `x` in `x + 1`, `x` in `x++`, `x` in `x += 1`, or `x` as the LHS\n    // when `n` is the `NAME` node child of an `ASSIGN` node.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // If `n` is the LHS of any assignment-like operation (e.g., `x = 1`, `x++`, `x += 1`),\n      // this represents a \"kill\" for the variable.\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        return VariableLiveness.KILL;\n      } else {\n        // Otherwise, it's a read.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // For other node types, evaluate children in left-to-right, depth-first order,\n    // as is standard for most expression evaluations.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Avoid recursing into new control flow graph nodes (e.g., function expressions)\n      // as they define their own scope and analysis boundaries.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // If a read or kill was found in a child, return it immediately\n          // as it's the first reference in evaluation order.\n          return state;\n        }\n      }\n    }\n\n    // If no read or kill was found within `n` itself or any of its children,\n    // the variable may still be live, but its first reference is not within this expression subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}