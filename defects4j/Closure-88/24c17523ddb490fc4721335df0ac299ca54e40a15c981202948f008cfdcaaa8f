{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAYBE_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    // Special handling for assignment operator: RHS and complex LHS components\n    // are evaluated before the actual assignment to the LHS target occurs.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = n.getLastChild();\n\n      // 1. Check the RHS first, as it's evaluated before the LHS is assigned.\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n\n      // 2. Check for references within the LHS expression (e.g., 'a' in 'a.b = c').\n      // These are evaluated before the final assignment to the LHS.\n      state = isVariableReadBeforeKill(lhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state; // Found a READ (e.g., 'a' in 'a.b = c') or a KILL (e.g., '(x=1).b = c')\n      }\n\n      // 3. If no READs or nested KILLs were found in RHS or complex LHS parts,\n      // and the LHS itself is the variable name, then this assignment is the\n      // first KILL of the variable.\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n        return VariableLiveness.KILL;\n      }\n\n      // If no reference was found within this assignment node, it's MAYBE_LIVE.\n      return VariableLiveness.MAYBE_LIVE;\n\n    } else {\n      // General case: iterate children left-to-right, depth-first.\n      // This applies to all nodes that are not ASSIGN and also\n      // to recursive calls on child nodes (which might then hit the 'isName' base case).\n      for (Node child = n.getFirstChild();\n          child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n    }\n\n    // Base case: if 'n' is the variable name itself.\n    // If 'n' is the LHS of an assignment, its 'KILL' effect is determined by\n    // the 'isAssign()' block above. So, if we reach this point and 'n' is\n    // the variable name, it must be a READ.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // If it's an LHS, it would have been handled by the parent ASSIGN node.\n      // If it's not an LHS (or is an LHS but not handled as the direct assignment target),\n      // then it's a READ.\n      if (!NodeUtil.isLhs(n, n.getParent())) { // Check if it's explicitly not an LHS\n        return VariableLiveness.READ;\n      }\n      // If it is an LHS but the parent ASSIGN logic didn't return a KILL,\n      // it means it's a complex LHS (e.g., `a.b=c`) or no reference was found.\n      // In this specific scenario, it's MAYBE_LIVE from this point.\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}