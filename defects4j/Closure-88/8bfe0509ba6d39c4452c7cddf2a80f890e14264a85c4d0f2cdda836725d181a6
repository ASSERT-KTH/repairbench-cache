{
    "generation": "/**\n * Give an expression and a variable. It returns READ, if the first\n * reference of that variable is a read. It returns KILL, if the first\n * reference of that variable is an assignment. It returns MAYBE_LIVE otherwise.\n */\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n  // First check the current node\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  // If this is an assignment node, we need to check both sides carefully\n  if (NodeUtil.isAssignmentOp(n)) {\n    Node lhs = n.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    // Check LHS first (since it would be evaluated first in any case)\n    VariableLiveness lhsState = isVariableReadBeforeKill(lhs, variable);\n    if (lhsState != VariableLiveness.MAYBE_LIVE) {\n      return lhsState;\n    }\n\n    // If variable wasn't found in LHS, check RHS\n    VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n    return rhsState;\n  }\n\n  // For other nodes, process children in order\n  boolean foundReference = false;\n  VariableLiveness result = VariableLiveness.MAYBE_LIVE;\n\n  for (Node child = n.getFirstChild();\n      child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n      VariableLiveness childState = isVariableReadBeforeKill(child, variable);\n      if (childState != VariableLiveness.MAYBE_LIVE) {\n        if (!foundReference) {\n          // This is the first reference we've found\n          result = childState;\n          foundReference = true;\n        }\n      }\n    }\n  }\n  return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}