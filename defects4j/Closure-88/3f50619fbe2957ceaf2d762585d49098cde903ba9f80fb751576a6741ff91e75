{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      Node parent = n.getParent();\n      if (NodeUtil.isLhs(n, parent)) {\n\n        // Handle simple assignment (x = ...) LHS specially.\n        // The KILL operation logically occurs *after* the RHS is evaluated.\n        if (parent.isAssign() && parent.getFirstChild() == n) {\n             Node rhs = n.getNext(); // RHS is the sibling of the LHS NAME node.\n             if (rhs != null) {\n                 // Check if the first reference to the variable within the RHS is a READ.\n                 // We need to check the RHS subtree before declaring the LHS a KILL.\n                 VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n                 if (rhsState == VariableLiveness.READ) {\n                     // If the RHS reads the variable before any potential kill within RHS,\n                     // then this READ happens before the LHS assignment's KILL.\n                     return VariableLiveness.READ;\n                 }\n                 // Fall through: If RHS is MAYBE_LIVE or KILL first, the LHS kill is dominant/first.\n             }\n             // If RHS is null or doesn't read the variable first, the LHS assignment\n             // is the first relevant operation encountered for this variable name.\n             return VariableLiveness.KILL;\n        }\n\n        // Handle other types of LHS operations:\n        // Declarations are kills.\n        if (parent.isVar() || parent.isFunction() || parent.isCatch()\n              || (parent.isForIn() && parent.getFirstChild() == n)) {\n              return VariableLiveness.KILL;\n        }\n        // Compound assignments, increment/decrement read the LHS first.\n        if (NodeUtil.isAssignmentOp(parent) || parent.isInc() || parent.isDec()) {\n              // parent.isAssign() was handled above, so this covers +=, -=, *=, etc. and ++, --\n              return VariableLiveness.READ;\n        }\n\n        // Default for any other unidentified LHS case (should be rare).\n        // Maintaining original code's tendency might involve returning KILL,\n        // but MAYBE_LIVE is safer if unsure. Let's stick to KILL like original.\n        return VariableLiveness.KILL;\n\n      } else {\n        // Not an LHS node, so it's a read operation.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    // Recursively check children.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Avoid recursing into function bodies, as they represent a new scope/CFG.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // Found the first READ or KILL in a child subtree. Return it immediately.\n          return state;\n        }\n      }\n    }\n\n    // Variable was not found in this subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}