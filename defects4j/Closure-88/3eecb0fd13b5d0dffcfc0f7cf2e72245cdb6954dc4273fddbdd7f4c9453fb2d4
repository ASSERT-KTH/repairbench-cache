{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment or kill. It returns\n   * MAY_LIVE otherwise. This follows JavaScript evaluation order.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // Base case: NAME node\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      Node parent = n.getParent();\n      // NodeUtil.isLhs determines if the name node is an L-value.\n      boolean isLhs = NodeUtil.isLhs(n, parent);\n\n      if (isLhs) {\n          // Distinguish specific LHS types for accurate first action (READ or KILL)\n          // based on JavaScript evaluation order.\n          if (parent.isAssign()) {\n              // Simple assign (x = ...), kill is deferred after RHS.\n              // The read/kill analysis happens within the ASSIGN handler below.\n              // Return MAYBE_LIVE to signal that the ASSIGN handler needs to check RHS.\n              return VariableLiveness.MAYBE_LIVE;\n          } else if (NodeUtil.isAssignmentOp(parent)) {\n              // Compound assign (x += ...), it's a READ first.\n              return VariableLiveness.READ;\n          } else if (parent.isInc() || parent.isDec()) {\n              // INC/DEC: Postfix (x++) is READ first, Prefix (++x) is KILL first.\n              // Node.INCRDECR_PROP indicates prefix according to Rhino Node documentation.\n              boolean isPrefix = parent.getBooleanProp(Node.INCRDECR_PROP);\n              return isPrefix ? VariableLiveness.KILL : VariableLiveness.READ;\n          } else if (parent.isVar() || parent.isForIn() || parent.isCatch()) {\n             // VAR declaration, FOR-IN iteration var, CATCH var are KILLs.\n             return VariableLiveness.KILL;\n          } else if (parent.isParamList()) {\n             // Function parameters are KILLs conceptually at function start,\n             // but if referenced within an expression tree being analyzed,\n             // it implies a read unless it's somehow LHS again. Safe default READ.\n             return VariableLiveness.READ;\n          } else {\n             // Other LHS cases (e.g., destructuring?).\n             // Defaulting to KILL might be appropriate for assignment contexts.\n             // TODO(user): handle destructuring correctly.\n             // For now, assume KILL for unknown LHS.\n             return VariableLiveness.KILL;\n          }\n      } else {\n          // Not LHS, must be a read.\n          return VariableLiveness.READ;\n      }\n    }\n\n    // Handle specific node types to override standard traversal order if needed\n\n    // Simple Assignment: Evaluate LHS (reads/kills within), Evaluate RHS, KILL LHS var.\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n\n        // 1. Check LHS expression (for reads/kills happening during LHS evaluation)\n        //    Skip if LHS is just the variable name itself (handled by base case + step 3).\n        if (!(NodeUtil.isName(lhs) && variable.equals(lhs.getString()))) {\n             VariableLiveness lhsExprState = isVariableReadBeforeKill(lhs, variable);\n             if (lhsExprState != VariableLiveness.MAYBE_LIVE) {\n                 // Found a read/kill within the LHS expression itself (e.g., array index)\n                 return lhsExprState;\n             }\n        }\n\n        // 2. Check RHS expression (evaluated after LHS ref evaluation, before assignment)\n        VariableLiveness rhsExprState = isVariableReadBeforeKill(rhs, variable);\n        if (rhsExprState != VariableLiveness.MAYBE_LIVE) {\n            return rhsExprState;\n        }\n\n        // 3. Check for the KILL from the assignment itself (if LHS is the variable)\n        //    This happens *after* RHS evaluation.\n        if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n            // The base case returned MAYBE_LIVE for this, now confirm the KILL.\n            return VariableLiveness.KILL;\n        }\n\n        // If none of the above found the var, it's not read/killed in this assign expr.\n        return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // Handle compound assignments (LHS read/eval -> RHS eval -> KILL LHS var)\n    if (NodeUtil.isAssignmentOp(n)) { // e.g., +=, -=, must be compound\n        Node lhs = n.getFirstChild();\n        Node rhs = n.getLastChild();\n\n        // 1. Check LHS expression (contains the initial READ or other events)\n        VariableLiveness lhsExprState = isVariableReadBeforeKill(lhs, variable);\n         // The base case correctly returns READ for simple name LHS of compound assign.\n         // It also handles INC/DEC within complex LHS correctly (returning READ/KILL).\n        if (lhsExprState != VariableLiveness.MAYBE_LIVE) {\n             // Return the first event found during LHS eval (READ or KILL).\n             return lhsExprState;\n        }\n\n        // 2. Check RHS expression (evaluated after LHS read/eval)\n        VariableLiveness rhsExprState = isVariableReadBeforeKill(rhs, variable);\n        if (rhsExprState != VariableLiveness.MAYBE_LIVE) {\n            return rhsExprState;\n        }\n\n        // 3. KILL event happens after READ/LHS-eval and RHS-eval.\n        // Since we only care about the *first* event, we don't need to explicitly\n        // return KILL here for the compound assignment itself. The initial READ\n        // (or kill from prefix inc/dec) in the LHS evaluation (Step 1) is the first event.\n\n        // If neither LHS nor RHS had the var definitively first.\n        return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // Default traversal: Left-to-right, depth-first.\n    // This handles nodes like AND, OR, CALL, GETPROP etc. correctly by default,\n    // respecting standard evaluation order for operands.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Skip FUNCTION nodes, as they define a new scope and CFG.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state; // Return the first READ/KILL found.\n        }\n      }\n    }\n\n    // If no read/kill found in the subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}