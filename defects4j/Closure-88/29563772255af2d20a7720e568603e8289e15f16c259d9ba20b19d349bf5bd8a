{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        // If 'n' is the LHS of an assignment, its 'KILL' effect happens last.\n        // Therefore, if a READ occurs in the RHS, that READ is \"first\".\n        // We return MAYBE_LIVE here to allow the parent ASSIGN node\n        // to check its RHS first. The ASSIGN node will then return KILL\n        // if no READ/KILL was found in the RHS.\n        return VariableLiveness.MAYBE_LIVE;\n      } else {\n        // This is a direct read of the variable, and it's not an LHS.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Special handling for ASSIGN nodes to correctly reflect evaluation order.\n    // The RHS is evaluated before the LHS is assigned (killed).\n    if (n.isAssign()) {\n        Node rhs = n.getLastChild(); // RHS is evaluated first\n        if (!ControlFlowGraph.isEnteringNewCfgNode(rhs)) {\n            VariableLiveness stateRhs = isVariableReadBeforeKill(rhs, variable);\n            if (stateRhs != VariableLiveness.MAYBE_LIVE) {\n                return stateRhs; // A READ or KILL was found in the RHS, which happens first.\n            }\n        }\n\n        // If no READ/KILL was found in the RHS, check the LHS.\n        // If the LHS is the variable itself, and RHS didn't contain any reference,\n        // then this assignment is the first reference (a KILL).\n        Node lhs = n.getFirstChild();\n        if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n            // This is the variable on the LHS. Since the RHS didn't contain\n            // a READ or KILL, this assignment is the first relevant reference.\n            return VariableLiveness.KILL;\n        }\n\n        // If the LHS is a complex expression (e.g., obj.prop = val), we need to\n        // recursively check within the LHS expression for references to 'variable'\n        // (e.g., if 'variable' is 'obj'). These reads happen before the final assignment.\n        if (!ControlFlowGraph.isEnteringNewCfgNode(lhs)) {\n            VariableLiveness stateLhs = isVariableReadBeforeKill(lhs, variable);\n            if (stateLhs != VariableLiveness.MAYBE_LIVE) {\n                return stateLhs;\n            }\n        }\n        return VariableLiveness.MAYBE_LIVE; // No reference found in RHS or LHS.\n    }\n\n    // For all other node types, expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}