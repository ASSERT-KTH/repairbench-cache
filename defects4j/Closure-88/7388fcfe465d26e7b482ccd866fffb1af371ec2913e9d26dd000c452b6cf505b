{
    "generation": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  // If this is an assignment node, then because of JS\u2019s evaluation order the kill\n  // (i.e. the assignment to the LHS) does not take place until AFTER the RHS is evaluated.\n  // So we must look at the RHS first.\n  if (n.isAssign()) {\n    // In an assignment node the first child is the LHS and the second is the RHS.\n    Node lhs = n.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    // Evaluate the right-hand side first. Even if the LHS (the kill) is present,\n    // any read occurring in the RHS will be executed before the assignment takes effect.\n    VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n    if (state != VariableLiveness.MAYBE_LIVE) {\n      return state;\n    }\n    // Then, if no read was found in the RHS, process the LHS.\n    return isVariableReadBeforeKill(lhs, variable);\n  }\n\n  // For any other node: if the node is the given variable, then return READ if it\u2019s not \n  // on the LHS of an assignment or KILL if it is.\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  // Process all children in order (except for nodes that start a new CFG such as FUNCTION bodies).\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}