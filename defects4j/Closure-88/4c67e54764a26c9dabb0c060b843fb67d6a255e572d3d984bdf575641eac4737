{
    "generation": "  private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    // Special-case simple assignments: the \"kill\" (write) happens after evaluating RHS.\n    if (NodeUtil.isAssignmentOp(n)) {\n      Node lhs = n.getFirstChild();\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n        // 1) Scan the LHS subtree (except the direct LHS name) for any READs.\n        for (Node c = lhs.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {\n            VariableLiveness st = isVariableReadBeforeKill(c, variable);\n            if (st != VariableLiveness.MAYBE_LIVE) {\n              return st;\n            }\n          }\n        }\n        // 2) Scan the RHS subtree for READ or a subsequent KILL.\n        Node rhs = lhs.getNext();\n        if (!ControlFlowGraph.isEnteringNewCfgNode(rhs)) {\n          VariableLiveness st = isVariableReadBeforeKill(rhs, variable);\n          if (st != VariableLiveness.MAYBE_LIVE) {\n            return st;\n          }\n        }\n        // No READ found before this assignment => KILL.\n        return VariableLiveness.KILL;\n      }\n    }\n\n    // A plain read of the variable (not on an assignment LHS).\n    if (NodeUtil.isName(n)\n        && variable.equals(n.getString())\n        && !NodeUtil.isLhs(n, n.getParent())) {\n      return VariableLiveness.READ;\n    }\n\n    // Recurse into children in left-to-right, depth-first order.\n    for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness st = isVariableReadBeforeKill(child, variable);\n        if (st != VariableLiveness.MAYBE_LIVE) {\n          return st;\n        }\n      }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}