{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAYBE_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        // This 'KILL' will be considered the first reference if no READ is found in the RHS.\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Special handling for ASSIGN nodes: The RHS is evaluated before the assignment\n    // to the LHS actually takes place. So, we must process the RHS first.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = n.getLastChild();\n\n      // 1. Check the RHS first for any reads or kills of the variable.\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state; // If found in RHS, it's the first reference.\n      }\n\n      // 2. If the variable was not found in the RHS, then check the LHS.\n      // This handles cases like `a[x] = ...` where 'x' is read in the LHS expression.\n      // If `lhs` is the variable name itself (e.g., `x = ...`), the recursive call\n      // will hit the base case (`NodeUtil.isName(n)` and `NodeUtil.isLhs(n, n.getParent())`)\n      // and correctly return `KILL` as the first reference.\n      state = isVariableReadBeforeKill(lhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n      // If neither RHS nor LHS determined liveness, it's MAYBE_LIVE within this assignment node.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // For all other node types (or if n.isAssign() was false),\n    // expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // ControlFlowGraph.isEnteringNewCfgNode checks if the child\n      // node creates a new control flow graph node (like a function).\n      // We don't analyze into function bodies for this specific check,\n      // as they have their own variable scopes and liveness.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}