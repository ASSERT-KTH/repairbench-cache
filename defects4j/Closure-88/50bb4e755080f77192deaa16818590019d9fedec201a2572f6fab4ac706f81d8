{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Special handling for AND, OR, COALESCE and HOOK and COMMA operators,\n    // as their evaluation is not always all children, due to short-circuit.\n    if (n.isAnd() || n.isOr() || n.isCoalesce()) {\n      // Evaluate left side first, return if definite read/kill found.\n      Node left = n.getFirstChild();\n      VariableLiveness state = isVariableReadBeforeKill(left, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n      // Only evaluate right side if left did not terminate the search.\n      Node right = left.getNext();\n      return isVariableReadBeforeKill(right, variable);\n    } else if (n.isHook()) {\n      // condition ? then : else\n      Node cond = n.getFirstChild();\n      Node ifTrue = cond.getNext();\n      Node ifFalse = ifTrue.getNext();\n\n      VariableLiveness state = isVariableReadBeforeKill(cond, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n      // Both branches could be first reference, check both.\n      VariableLiveness trueState = isVariableReadBeforeKill(ifTrue, variable);\n      VariableLiveness falseState = isVariableReadBeforeKill(ifFalse, variable);\n\n      // Pick the most \"killer\" state.\n      if (trueState == VariableLiveness.KILL || falseState == VariableLiveness.KILL) {\n        return VariableLiveness.KILL;\n      }\n      if (trueState == VariableLiveness.READ || falseState == VariableLiveness.READ) {\n        return VariableLiveness.READ;\n      }\n      return VariableLiveness.MAYBE_LIVE;\n    } else if (n.isComma()) {\n      // Only the last child can provide a KILL or READ that is visible.\n      Node last = n.getLastChild();\n      Node c;\n      for (c = n.getFirstChild(); c != last; c = c.getNext()) {\n        VariableLiveness state = isVariableReadBeforeKill(c, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n        // else keep iterating to the last child\n      }\n      return isVariableReadBeforeKill(last, variable);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}