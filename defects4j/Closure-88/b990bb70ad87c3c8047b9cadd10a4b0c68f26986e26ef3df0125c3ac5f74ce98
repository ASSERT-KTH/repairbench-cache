{
    "generation": "/**\n * Give an expression and a variable. It returns READ, if the first\n * reference of that variable is a read. It returns KILL, if the first\n * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n */\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      // An assignment (KILL) only counts as such if we are not directly\n      // evaluating the variable as the result of the entire assignment\n      // (i.e., x = ... is KILL, but \"x = foo(x)\" the left x, and \"x\" on the RHS is a READ).\n      Node parent = n.getParent();\n      if (parent.isAssign()) {\n        // We must make sure this is the lhs of the assignment.\n        // There's a corner-case for expr1, expr2 in \"x = foo(x)\", as in\n        // the tests, so if our variable is indeed the left-hand side of the assignment,\n        // this is a KILL.\n        if (parent.getFirstChild() == n) {\n          return VariableLiveness.KILL;\n        }\n      } else if (parent.isVar()) {\n        return VariableLiveness.KILL;\n      }\n      // Otherwise, it's actually a READ (e.g., x++ or --x, which is DUAL)\n      // but for this use-case, interpret them as READ.\n      return VariableLiveness.READ;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  // Evaluate children in order (left-to-right)\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}