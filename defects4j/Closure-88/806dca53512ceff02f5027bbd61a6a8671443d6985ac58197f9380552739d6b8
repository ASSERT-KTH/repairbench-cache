{
    "generation": "private VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n  // If this is a reference to the variable, decide if it's a read or a\n  // kill.  Simple (\u201c=\u201d) assignments and var\u2010decl initializers kill only\n  // after their RHS is done, so we defer reporting those until after\n  // we scan their children.  All other LHS contexts (compound\u2010assign,\n  // ++/--, etc.) read the old value first.\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    Node parent = n.getParent();\n    if (!NodeUtil.isLhs(n, parent)) {\n      // a plain read of the variable\n      return VariableLiveness.READ;\n    }\n    // LHS occurrence: see what kind of LHS it is\n    Token pType = parent.getType();\n    if (pType != Token.ASSIGN && pType != Token.VAR) {\n      // compound\u2010assign or update: the old value is read first\n      return VariableLiveness.READ;\n    }\n    // otherwise (simple \"=\" or var declaration) we defer the kill\n  }\n\n  // Recurse into children in evaluation order.\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n\n  // After visiting children, simple\u2010assignment nodes kill the variable.\n  if (n.getType() == Token.ASSIGN) {\n    Node lhs = n.getFirstChild();\n    if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n      return VariableLiveness.KILL;\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}