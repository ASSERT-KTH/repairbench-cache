{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent()) &&\n          n.getParent().isAssign() &&\n          n == n.getParent().getFirstChild()) {\n        // The first reference is as an assignment (KILL).\n        return VariableLiveness.KILL;\n      } else {\n        // The first reference is a read (READ).\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Walk children left-to-right, but for certain operators (like AND, OR)\n    // the evaluation may short-circuit. For those, we must stop once we know\n    // the live-ness for the left operand.\n    switch (n.getType()) {\n      // Binary operators that short-circuit (AND, OR, COALESCE)\n      case Token.AND:\n      case Token.OR:\n      case Token.COALESCE: {\n        Node left = n.getFirstChild();\n        Node right = left.getNext();\n        VariableLiveness leftState = isVariableReadBeforeKill(left, variable);\n        if (leftState != VariableLiveness.MAYBE_LIVE) {\n          return leftState;\n        }\n        return isVariableReadBeforeKill(right, variable);\n      }\n      // Conditional: only first check condition, as it may short-circuit\n      case Token.HOOK: {\n        Node cond = n.getFirstChild();\n        Node trueExpr = cond.getNext();\n        Node falseExpr = trueExpr.getNext();\n        VariableLiveness condState = isVariableReadBeforeKill(cond, variable);\n        if (condState != VariableLiveness.MAYBE_LIVE) {\n          return condState;\n        }\n        VariableLiveness trueState = isVariableReadBeforeKill(trueExpr, variable);\n        VariableLiveness falseState = isVariableReadBeforeKill(falseExpr, variable);\n        // If either child found a definitive answer, propagate up\n        if (trueState == VariableLiveness.READ || falseState == VariableLiveness.READ) {\n          return VariableLiveness.READ;\n        }\n        if (trueState == VariableLiveness.KILL && falseState == VariableLiveness.KILL) {\n          return VariableLiveness.KILL;\n        }\n        return VariableLiveness.MAYBE_LIVE;\n      }\n      // For assignments, evaluate RHS before LHS is killed\n      case Token.ASSIGN:\n        // For assignments: first check RHS (value assigned),\n        // if not found, check LHS\n        Node lhs = n.getFirstChild();\n        Node rhs = lhs.getNext();\n        VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n        if (rhsState != VariableLiveness.MAYBE_LIVE) {\n          return rhsState;\n        }\n        return isVariableReadBeforeKill(lhs, variable);\n      default:\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n              return state;\n            }\n          }\n        }\n        return VariableLiveness.MAYBE_LIVE;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}