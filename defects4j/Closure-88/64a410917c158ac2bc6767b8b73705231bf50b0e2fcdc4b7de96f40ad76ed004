{
    "generation": "private VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n  // Special\u2010case a direct \u201c=\u201d assignment to our variable: the kill\n  // actually occurs after the RHS is evaluated, so we must scan the\n  // RHS first for any reads or nested kills.\n  if (n.isAssign()\n      && NodeUtil.isName(n.getFirstChild())\n      && variable.equals(n.getFirstChild().getString())) {\n    // Evaluate RHS before the kill\n    Node rhs = n.getFirstChild().getNext();\n    VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n    if (rhsState != VariableLiveness.MAYBE_LIVE) {\n      return rhsState;\n    }\n    // No read in the RHS, so this assignment is the first reference (a kill).\n    return VariableLiveness.KILL;\n  }\n\n  // If this node is our variable name, decide READ vs KILL immediately.\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  // Otherwise, recurse left\u2010to\u2010right, depth\u2010first (skipping new CFG subnodes).\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}