{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // Base case: If the current node 'n' is the variable we are looking for.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // If it's on the LHS of an assignment, it's a KILL.\n      // The comment below explains the evaluation order for assignments.\n      // This base case will correctly identify the KILL if reached,\n      // but the special handling for ASSIGN nodes below ensures RHS is checked first.\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Special handling for ASSIGN nodes:\n    // The expression to which the assignment is made (LHS) is evaluated,\n    // then the RHS is evaluated, and finally the assignment (KILL) occurs.\n    // If the variable being assigned to is also referenced on the RHS\n    // (e.g., `x = x + 1`), the read on the RHS happens before the KILL.\n    // Therefore, for an ASSIGN node, we must check the RHS first.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = n.getLastChild();\n\n      // 1. Check RHS first for any read/kill of the variable.\n      VariableLiveness stateRhs = isVariableReadBeforeKill(rhs, variable);\n      if (stateRhs != VariableLiveness.MAYBE_LIVE) {\n        // If a READ or KILL is found in the RHS, that's the first reference.\n        return stateRhs;\n      }\n\n      // 2. If no READ/KILL in RHS, check LHS.\n      // The LHS might contain a read (e.g., `arr[x] = value;` where 'x' is the variable)\n      // or the LHS itself might be the variable being killed (`x = value;`).\n      VariableLiveness stateLhs = isVariableReadBeforeKill(lhs, variable);\n      if (stateLhs != VariableLiveness.MAYBE_LIVE) {\n        // If a READ is found (e.g., in `arr[x]`), or if the LHS itself is the\n        // variable and it's identified as a KILL by the base case, this is\n        // the first reference.\n        return stateLhs;\n      }\n      // If neither RHS nor LHS (excluding the direct KILL of the variable itself,\n      // which would be caught by stateLhs if lhs is the variable) found anything,\n      // then the variable is MAYBE_LIVE within this assignment's subtree.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // For all other node types (non-variable name, non-assignment),\n    // expressions are evaluated left-to-right, depth-first.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // We don't enter new control flow graph nodes (like function declarations\n      // or function expressions that define a new scope for liveness analysis).\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // If a READ or KILL is found in any child, return it immediately\n          // as it's the \"first reference\" according to the left-to-right, depth-first order.\n          return state;\n        }\n      }\n    }\n    // If no READ or KILL is found in this subtree, the variable MAYBE_LIVE.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}