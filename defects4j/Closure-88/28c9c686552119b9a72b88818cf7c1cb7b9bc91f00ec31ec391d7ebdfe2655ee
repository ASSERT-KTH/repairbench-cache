{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // Base Case 1: 'n' is the variable name node itself.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      Node parent = n.getParent();\n      if (NodeUtil.isLhs(n, parent)) {\n        if (parent.isAssign()) {\n          // If 'n' is the LHS of an ASSIGNment (e.g., `x = 5`),\n          // the assignment to 'n' happens AFTER its RHS is evaluated.\n          // So, this LHS reference itself is not yet an effective KILL for the purpose of\n          // finding the *first* reference in evaluation order.\n          // We return MAYBE_LIVE and defer the KILL decision to the parent ASSIGN node\n          // after it checks its RHS.\n          return VariableLiveness.MAYBE_LIVE;\n        } else {\n          // If 'n' is the LHS of a VAR declaration, FOR_IN, or FOR_OF (e.g., `var x;`, `for(x in y)`),\n          // these are definitive KILLs for the variable, and no RHS in the same expression\n          // takes precedence over this KILL for the purpose of finding the *first* reference.\n          return VariableLiveness.KILL;\n        }\n      } else {\n        // If 'n' is not an LHS, it's a plain reference/read. This is the first reference.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Special handling for assignment nodes.\n    // For an assignment `LHS = RHS`:\n    // Evaluation order: evaluate sub-expressions in LHS (if any), then evaluate RHS, then perform assignment.\n    // If the variable is read in RHS, that's a READ before the KILL.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = n.getLastChild();\n\n      // Check RHS for READ/KILL first, as it's evaluated before the assignment to LHS occurs.\n      VariableLiveness stateRhs = isVariableReadBeforeKill(rhs, variable);\n      if (stateRhs != VariableLiveness.MAYBE_LIVE) {\n        return stateRhs; // If a READ or KILL is found in the RHS, that's the first reference.\n      }\n\n      // If no READ/KILL was found in the RHS, check if the LHS itself is the variable being assigned to.\n      if (NodeUtil.isName(lhs) && variable.equals(lhs.getString())) {\n         // If we are here, it means:\n         // 1. `n` is an ASSIGN node.\n         // 2. `lhs` is the variable we are tracking (`x`).\n         // 3. `stateRhs` was MAYBE_LIVE (no READ/KILL in RHS).\n         // Therefore, the assignment *to* `x` is the first reference encountered in this subtree.\n         return VariableLiveness.KILL;\n      }\n\n      // If LHS is not the variable name itself (e.g., `obj[x] = 1`),\n      // any references to the variable within the LHS expression (e.g., `x` in `obj[x]`)\n      // will be handled by the general traversal that follows.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    // General case: Traverse children left-right, depth first.\n    // This handles all other node types (e.g., ADD, CALL, AND, OR)\n    // and also sub-expressions within LHS/RHS of assignments if they are not the\n    // direct variable name being assigned to.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Don't descend into functions (new CFG node)\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state; // First READ or KILL found in left-to-right order.\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}