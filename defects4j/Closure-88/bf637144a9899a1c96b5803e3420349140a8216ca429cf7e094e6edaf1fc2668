{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   *\n   * Fix: When figuring out if an assignment (\"KILL\") on LHS, only treat as KILL if we're processing assignment (first encounter) in the *RHS*.\n   * In an assignment node, always first process the LHS, then the RHS. The KILL occurs only after the RHS is evaluated.\n   * So, in the context of \"x = foo()\", the assignment (\"KILL\") occurs *after* foo() evaluates.\n   * Therefore, if x appears in the RHS, that's a \"READ before KILL\", but if our visit to LHS itself is the first occurrence, then it's \"KILL\".\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // If this is a NAME node for the variable of interest...\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      // If its parent is an assignment and this NAME is the LHS,\n      // then we're considering \"x = ...\" and this is occurrence of \"x\" being set\n      // However, KILL happens only *after* the RHS is fully evaluated.\n      // So, the KILL should only be considered if we visit the LHS after visiting the RHS.\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        // Only return KILL if this assignment's LHS is the first reference.\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    if (n.isAssign()) {\n      Node lhs = n.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      // Visit RHS first (right hand side may \"read\" the variable before it is \"killed\" by assignment).\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n\n      // Only after RHS, visit LHS. (We treat var read/write in this order.)\n      state = isVariableReadBeforeKill(lhs, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n\n      // No reference found.\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}