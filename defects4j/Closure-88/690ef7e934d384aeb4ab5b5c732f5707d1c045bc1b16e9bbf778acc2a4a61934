{
    "generation": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  // If we hit a name node that matches the variable,\n  // we need to decide if this is a \u201cread\u201d or a \u201ckill.\u201d\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    // Normally a name node on the left of an assignment would signal a kill.\n    // However, because JavaScript\u2019s assignment evaluates the left\u2010hand side\n    // before the right\u2010hand side\u2014and the \u201ckill\u201d (the store) happens only after\n    // the RHS is evaluated\u2014we must check the RHS first.\n    if (NodeUtil.isLhs(n, n.getParent()) && n.getParent().isAssign()) {\n      // In an assignment node, the second child is the right-hand side.\n      Node assign = n.getParent();\n      Node rhs = assign.getLastChild(); // Assumes binary assignment: [LHS, RHS]\n      VariableLiveness rhsState = isVariableReadBeforeKill(rhs, variable);\n      // If the RHS eventually reads the variable, then in execution\n      // the read happens before the assignment\u2019s effect, so treat this as a read.\n      if (rhsState == VariableLiveness.READ) {\n        return VariableLiveness.READ;\n      }\n      // Otherwise, no read occurs in the RHS so the first effective reference is the kill.\n      return VariableLiveness.KILL;\n    }\n    return VariableLiveness.READ;\n  }\n\n  // For non-name nodes, search their children in left-to-right order.\n  // (Do not descend into functions or other new control flow graph boundaries.)\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state != VariableLiveness.MAYBE_LIVE) {\n        return state;\n      }\n    }\n  }\n  return VariableLiveness.MAYBE_LIVE;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}