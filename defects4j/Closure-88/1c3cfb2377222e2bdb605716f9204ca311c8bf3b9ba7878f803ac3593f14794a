{
    "generation": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   * Note: Compound assignments (e.g., x += 1) and increments/decrements\n   * (e.g., x++) are treated as READs, as they read the variable's value before\n   * the assignment occurs.\n   */\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    // Check the node type FIRST, as specific nodes define read/kill semantics\n    // that override simple child traversal order.\n\n    // Base Case: Found the variable NAME node.\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      Node parent = n.getParent();\n      // Check if 'n' is the target (LHS) of an operation.\n      if (NodeUtil.isLhs(n, parent)) {\n\n        // Case 1: Simple assignment ( T.ASSIGN ) where n is the target.\n        if (parent.isAssign()) {\n          // We are looking at the 'x' in 'x = f(x)'\n          Node rhs = n.getNext(); // rhs is sibling of lhs 'n'\n          // Check if rhs is null for safety, although it shouldn't be for ASSIGN\n          if (rhs == null) {\n             // Should not happen for valid ASSIGN node, but be safe.\n             return VariableLiveness.KILL; // Treat as kill if RHS is unexpectedly missing\n          }\n\n          // IMPORTANT: Check the RHS *before* declaring this node a KILL.\n          // The RHS is evaluated completely before the assignment happens.\n          VariableLiveness rhsLiveness = isVariableReadBeforeKill(rhs, variable);\n          if (rhsLiveness != VariableLiveness.MAYBE_LIVE) {\n            // Variable was READ or KILLed in the RHS. Return that status,\n            // as it happens before this assignment completes.\n            return rhsLiveness;\n          }\n          // If variable is NOT in RHS, then this assignment (LHS node) is the KILL.\n          return VariableLiveness.KILL;\n        }\n\n        // Case 2: Compound assignment ( T.ASSIGN_*, e.g., += ) or Inc/Dec ( T.INC / T.DEC )\n        // where n is the target.\n        if ((NodeUtil.isAssignmentOp(parent) || parent.isInc() || parent.isDec())\n             && parent.getFirstChild() == n) {\n          // Example: x += f(y), or x++\n          // The variable 'n' (x) is read *before* the RHS is evaluated (for +=)\n          // or as part of the operation (for ++/--).\n          // So, this node represents a READ first.\n          return VariableLiveness.READ;\n        }\n\n        // Case 3: Other LHS context (VAR, PARAM_LIST, CATCH, maybe FOR-IN/OF)\n        // These are declaration/binding sites. Treat as KILL.\n        return VariableLiveness.KILL;\n\n      } else {\n        // It's a NAME node for the variable, but not LHS -> definitely a READ.\n        return VariableLiveness.READ;\n      }\n    }\n\n    // If 'n' is not the variable NAME node, traverse children L-R.\n    // The recursive calls handle nested structures. The base cases above\n    // will eventually hit the variable name or exhaust the subtree.\n    for (Node child = n.getFirstChild();\n        child != null; child = child.getNext()) {\n      // Don't descend into functions; they have different scopes/lifetimes.\n      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          // Found the first read/kill in a child. Return it immediately\n          // as we respect left-to-right evaluation.\n          return state;\n        }\n      }\n    }\n\n    // Variable was not found in this subtree.\n    return VariableLiveness.MAYBE_LIVE;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}