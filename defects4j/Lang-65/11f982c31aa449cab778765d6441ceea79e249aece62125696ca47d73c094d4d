{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     *\n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        // Check if year is too large for accurate calculations\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds, minutes, and hours using\n        // setTimeInMillis() arithmetic to avoid Calendar.set() quirks, especially near DST transitions.\n        // This is only done if the target field is coarser than the field being truncated.\n\n        long timeInMillis = val.getTimeInMillis();\n        long originalTimeInMillis = timeInMillis; // Store original time for rounding check later\n\n        // Truncate milliseconds if requested field is coarser\n        if (field != Calendar.MILLISECOND) {\n            timeInMillis = timeInMillis - (timeInMillis % 1000L);\n        }\n\n        // Truncate seconds if requested field is coarser\n        if (field != Calendar.MILLISECOND && field != Calendar.SECOND) {\n            timeInMillis = timeInMillis - (timeInMillis % (60L * 1000L));\n        }\n\n        // Truncate minutes if requested field is coarser\n        if (field != Calendar.MILLISECOND && field != Calendar.SECOND && field != Calendar.MINUTE) {\n            timeInMillis = timeInMillis - (timeInMillis % (60L * 60L * 1000L));\n        }\n\n        // Truncate hours if requested field is coarser\n        if (field != Calendar.MILLISECOND && field != Calendar.SECOND && field != Calendar.MINUTE &&\n            field != Calendar.HOUR && field != Calendar.HOUR_OF_DAY && field != Calendar.AM_PM) {\n            // Truncate to start of day using timezone offset\n            long tzOffset = val.get(Calendar.ZONE_OFFSET) + val.get(Calendar.DST_OFFSET);\n            long timeOfDayMillis = (timeInMillis - tzOffset) % (24L * 60L * 60L * 1000L);\n            if (timeOfDayMillis < 0) { // Handle time before epoch in UTC\n                timeOfDayMillis += (24L * 60L * 60L * 1000L);\n            }\n            timeInMillis = timeInMillis - timeOfDayMillis; // Truncate to start of day in the timezone\n        }\n\n        // Set time back only if it was modified by manual truncation\n        if (timeInMillis != originalTimeInMillis) {\n            val.setTimeInMillis(timeInMillis);\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) { // Iterate through field precision levels (e.g., ms, s, m, h, date...)\n            int currentFieldGroup = fields[i][0]; // The main field of this level\n\n            // Check if any field in this level matches the target field\n            boolean fieldFoundInThisLevel = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    fieldFoundInThisLevel = true;\n                    break;\n                }\n            }\n\n            // Determine if this field group was manually truncated above\n            // This helps avoid redundant/problematic set() calls later\n            boolean wasManuallyTruncated = false;\n            // Check if MILLISECOND was manually truncated\n            if (currentFieldGroup == Calendar.MILLISECOND && field != Calendar.MILLISECOND) {\n                wasManuallyTruncated = true; // It was truncated if field != MILLISECOND\n            }\n            // Check if SECOND was manually truncated\n            else if (currentFieldGroup == Calendar.SECOND && !(field == Calendar.MILLISECOND || field == Calendar.SECOND)) {\n                wasManuallyTruncated = true;\n            }\n            // Check if MINUTE was manually truncated\n            else if (currentFieldGroup == Calendar.MINUTE && !(field == Calendar.MILLISECOND || field == Calendar.SECOND || field == Calendar.MINUTE)) {\n                wasManuallyTruncated = true;\n            }\n            // Check if HOUR was manually truncated\n            else if ((currentFieldGroup == Calendar.HOUR || currentFieldGroup == Calendar.HOUR_OF_DAY) &&\n                     !(field == Calendar.MILLISECOND || field == Calendar.SECOND || field == Calendar.MINUTE ||\n                       field == Calendar.HOUR || field == Calendar.HOUR_OF_DAY || field == Calendar.AM_PM)) {\n                wasManuallyTruncated = true;\n            }\n\n\n            if (fieldFoundInThisLevel) {\n                // Target field found. Apply rounding if needed and return.\n                // Rounding depends on `roundUp` calculated from the *previous* (finer) field iteration.\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // Special case SEMI_MONTH rounding\n                        // Get the DATE value *before* potential modification\n                        int date = val.get(Calendar.DATE);\n                        if (date == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else if (field == Calendar.AM_PM) {\n                        // Special case AM_PM rounding\n                        val.add(Calendar.HOUR_OF_DAY, 12);\n                    } else {\n                        // General rounding: add 1 to the primary field of this level\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                // We've processed up to the target field. Stop.\n                return;\n            }\n\n            // Field not found in this level: currentFieldGroup is smaller than the target field.\n            // We need to:\n            // 1. Calculate `roundUp` based on this field's original value (before any truncation).\n            // 2. Truncate this field `currentFieldGroup` *if* it wasn't manually truncated.\n\n            // --- Calculate roundUp based on the original value ---\n            // Use a temporary calendar based on original time to get original field values for rounding calc.\n            Calendar originalCal = Calendar.getInstance(val.getTimeZone());\n            originalCal.setTimeInMillis(originalTimeInMillis); // Use original time before manual truncation\n\n            int offset = 0;\n            boolean offsetSet = false; // Flag for special rounding cases\n\n            // Special calculation of offset/roundUp for SEMI_MONTH and AM_PM targets\n            switch (field) { // Check the TARGET field\n                case DateUtils.SEMI_MONTH:\n                    if (currentFieldGroup == Calendar.DATE) { // If current level is DATE\n                        offset = originalCal.get(Calendar.DATE) - 1; // Use original value\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                     if (currentFieldGroup == Calendar.HOUR_OF_DAY) { // If current level is HOUR_OF_DAY\n                        offset = originalCal.get(Calendar.HOUR_OF_DAY); // Use original value\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset >= 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            // Default calculation of offset/roundUp for other fields\n            if (!offsetSet) {\n                // Use originalCal to get min/max/value to ensure rounding is based on pre-truncation state\n                int min = originalCal.getActualMinimum(currentFieldGroup);\n                int max = originalCal.getActualMaximum(currentFieldGroup);\n                offset = originalCal.get(currentFieldGroup) - min; // Use original value\n                // Determine roundUp: true if value > midpoint\n                roundUp = (offset * 2) > (max - min);\n            }\n\n            // --- Truncate the current field `currentFieldGroup` ---\n            // Only apply truncation using set() if the field wasn't manually truncated above.\n            if (!wasManuallyTruncated) {\n                 // Get the current value and minimum for the actual 'val' Calendar.\n                 int currentValField = val.get(currentFieldGroup);\n                 int minValField = val.getActualMinimum(currentFieldGroup);\n                 // Use set() only if the value is not already the minimum.\n                 // This avoids potential issues with set() if the field is already 0.\n                 if (currentValField != minValField) {\n                    val.set(currentFieldGroup, minValField);\n                 }\n            }\n            // else: Field was already truncated manually using setTimeInMillis. No action needed here.\n\n        } // End of loop through field precision levels\n\n        // This should not be reached if 'field' is valid and present in 'fields' array\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}