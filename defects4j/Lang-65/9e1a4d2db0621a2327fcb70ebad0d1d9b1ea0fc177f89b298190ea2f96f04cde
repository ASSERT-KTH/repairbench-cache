{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * Uses `add` instead of `set` for truncating time fields to mitigate LANG-59 DST issue.\n     *\n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n\n        // Store original hour & date for special AM/PM and SEMI_MONTH truncation logic\n        // Note: DateUtils.SEMI_MONTH is handled DIRECTLY in DateUtils trunc/round/ceiling methods\n        // It shouldn't be passed into modify. However, AM_PM is passed.\n        int originalHour = val.get(Calendar.HOUR_OF_DAY);\n        // int originalDate = val.get(Calendar.DATE); // Removed as SEMI_MONTH handled upstream\n\n        boolean roundUp = false;\n        // fields is ordered from smaller units to larger units. e.g. MS -> SECOND -> MINUTE ...\n        for (int i = 0; i < fields.length; i++) {\n\n            boolean fieldFound = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    fieldFound = true;\n                    break;\n                }\n            }\n\n            // If target field is found, handle rounding or specific truncation.\n            if (fieldFound) {\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // This case should not be reachable anymore, as SEMI_MONTH handled upstream\n                        // If it were reachable:\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        // General rounding: Add 1 to the primary field of this group.\n                        val.add(fields[i][0], 1);\n                    }\n                } else if (!round) {\n                    // Special truncation logic for specific fields when truncating\n                    // SEMI_MONTH is handled upstream.\n                    if (field == Calendar.AM_PM) {\n                         // Use original hour to decide truncation target (0 or 12)\n                         if (originalHour >= 12) { val.set(Calendar.HOUR_OF_DAY, 12); } else { val.set(Calendar.HOUR_OF_DAY, 0); }\n                         // Assuming set(HOUR_OF_DAY) is safe enough here for the final step.\n                    }\n                    // For other fields, truncation is complete based on loop processing.\n                }\n                return; // Done processing\n            }\n\n            // Target field not yet found. Process finer fields.\n            int currentField = fields[i][0]; // Primary field of the current group\n            int offset = 0; // Used for roundUp calculation offset logic\n            boolean offsetSet = false; // Flag for special AM_PM roundUp logic\n\n            int value = val.get(currentField); // Current value before truncation of this field\n\n             // Calculate roundUp flag based on current value\n             // Only AM_PM requires special rounding logic based on a finer field (HOUR_OF_DAY)\n             if (field == Calendar.AM_PM) {\n                 if (currentField == Calendar.HOUR_OF_DAY) {\n                     offset = value; // Hour value\n                     if (offset >= 12) { offset -= 12; } // Hour offset within AM/PM block\n                     roundUp = offset > 6; // Round up if hour is 7-11 or 19-23\n                     offsetSet = true;\n                 }\n             }\n             // SEMI_MONTH rounding logic removed as it's handled upstream.\n\n            // Calculate standard roundUp if not special case\n            if (!offsetSet) {\n                int min = val.getActualMinimum(currentField);\n                int max = val.getActualMaximum(currentField);\n                 // Protect against divide by zero or negative range\n                 if (max == min) {\n                    roundUp = false; // Cannot round if range is zero\n                 } else {\n                    offset = value - min; // Offset from minimum\n                    // Using multiply avoids double division and potential truncation\n                    roundUp = (offset * 2) > (max - min); // Round up if strictly greater than half way\n                 }\n            }\n\n            // Calculate offset from minimum for truncation amount\n            // Need the current value again as 'offset' might have been recalculated for rounding\n            value = val.get(currentField); // Refresh value before truncation calculation\n            int minTrunc = val.getActualMinimum(currentField);\n            int offsetTrunc = value - minTrunc;\n\n\n            // Truncate the current field group 'i'.\n            if (offsetTrunc != 0) { // Only modify if not already at minimum\n                // LANG-59 Fix: Use add() not set() for time fields to avoid DST issues\n                if (currentField == Calendar.MILLISECOND ||\n                    currentField == Calendar.SECOND ||\n                    currentField == Calendar.MINUTE ||\n                    currentField == Calendar.HOUR_OF_DAY) // Using HOUR_OF_DAY implies HOUR is also handled\n                {\n                    val.add(currentField, -offsetTrunc);\n                } else {\n                    // For non-time fields (DATE, MONTH, YEAR, etc.) set to minimum is definition of truncate\n                    // Using set() for these fields is assumed safer than for time fields regarding DST ambiguity\n                    val.set(currentField, minTrunc);\n                }\n            }\n        } // End of loop through field groups\n\n        // This should not normally be reached if fields array covers all supported fields\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}