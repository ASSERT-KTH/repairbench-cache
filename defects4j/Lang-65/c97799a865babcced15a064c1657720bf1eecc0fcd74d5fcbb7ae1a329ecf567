{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        // Find the index of the field group containing the target 'field'.\n        // This is necessary to know which fields are smaller than the target field.\n        int targetFieldGroupIndex = -1;\n        for (int i = 0; i < fields.length; i++) {\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    targetFieldGroupIndex = i;\n                    break;\n                }\n            }\n            if (targetFieldGroupIndex != -1) {\n                break;\n            }\n        }\n\n        // If the target field is not found in the predefined field groups, it's not supported.\n        if (targetFieldGroupIndex == -1) {\n            throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n        }\n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Problem: Using Calendar.set() for individual fields can cause issues with\n        // TimeZone/DST transitions as it re-computes the time internally, leading to\n        // incorrect results (e.g., shifting from MDT to MST unexpectedly).\n        // Solution: Perform all intermediate modifications on a cloned Calendar object,\n        // and only update the original 'val' calendar once at the very end using setTimeInMillis().\n        // This ensures the TimeZone/DST handling is consistent.\n\n        // Create a working clone of the calendar. All modifications will be done on this clone.\n        // The original calendar `val` will only be updated at the very end.\n        Calendar gVal = (Calendar) val.clone();\n        gVal.setLenient(true); // Ensure lenient mode for robust intermediate calculations\n\n        // This flag indicates if the next higher field (the target field) needs to be incremented.\n        // It's determined by the most significant field that is being truncated/zeroed out.\n        boolean roundUp = false; \n\n        // Iterate through the field groups, from smallest granularity (MILLISECOND) to largest.\n        for (int i = 0; i < fields.length; i++) {\n            // `currentFieldInGroup` is the primary Calendar field constant for the current group.\n            int currentFieldInGroup = fields[i][0];\n\n            // Check if the current field group contains the target 'field' we are modifying.\n            boolean isTargetFieldGroup = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    isTargetFieldGroup = true;\n                    break;\n                }\n            }\n\n            // If this is the target field group, we perform the rounding/truncation specific to 'field'.\n            // For fields *smaller* than the target, we truncate them and potentially set 'roundUp'.\n            if (isTargetFieldGroup) {\n                if (round && roundUp) { // If rounding is enabled and a smaller field indicated rounding up\n                    // Apply the rounding increment to the target field in the working calendar.\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // Special case for SEMI_MONTH rounding (add 15 days or 1 month - 15 days)\n                        if (gVal.get(Calendar.DATE) == 1) {\n                            gVal.add(Calendar.DATE, 15); // 1st of month rounds to 16th\n                        } else {\n                            gVal.add(Calendar.DATE, -15); // 16th onwards rounds to next month's 1st\n                            gVal.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        gVal.add(field, 1); // Increment the target field by one unit\n                    }\n                }\n                // Once the target field is processed (potentially incremented or just left), we are done.\n                break; // Exit the loop as we've processed the target field and all smaller ones.\n            }\n\n            // If we are here, 'currentFieldInGroup' is a field *smaller* than the target 'field'.\n            // We need to truncate this field in `gVal` and determine if it contributes to `roundUp`.\n\n            int offset = 0; // Amount to subtract from `currentFieldInGroup` to truncate it\n            boolean offsetSet = false; // Flag if offset was determined by a special case\n\n            // Handle special rounding rules based on the *target* `field`\n            // (e.g., when `field` is SEMI_MONTH, and `currentFieldInGroup` is Calendar.DATE).\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (currentFieldInGroup == Calendar.DATE) {\n                        // Calculate offset for DATE when target is SEMI_MONTH\n                        offset = gVal.get(Calendar.DATE) - 1; // get 0-indexed day of month\n                        if (offset >= 15) { // If date is 16th or later (0-indexed 15)\n                            offset -= 15; // adjust to 0-14 within the second half\n                        }\n                        // Determine `roundUp` if `round` is true and this field is at or past its midpoint in its \"half\"\n                        if (round && offset > 7) { // 8th day (0-indexed 7) or later in the half\n                            roundUp = true;\n                        } else {\n                            roundUp = false;\n                        }\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (currentFieldInGroup == Calendar.HOUR_OF_DAY) {\n                        // Calculate offset for HOUR_OF_DAY when target is AM_PM\n                        offset = gVal.get(Calendar.HOUR_OF_DAY); // 0-23 hours\n                        if (offset >= 12) {\n                            offset -= 12; // Adjust to 0-11 for AM/PM period\n                        }\n                        // Determine `roundUp` if `round` is true and this field is at or past its midpoint\n                        if (round && offset > 6) { // 7th hour (0-indexed 6) or later in the half\n                            roundUp = true;\n                        } else {\n                            roundUp = false;\n                        }\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            if (!offsetSet) {\n                // General case for fields smaller than the target field.\n                // Calculate minimum and maximum actual values for the current field.\n                int min = gVal.getActualMinimum(currentFieldInGroup);\n                int max = gVal.getActualMaximum(currentFieldInGroup);\n                // Calculate offset to truncate this field to its minimum value.\n                offset = gVal.get(currentFieldInGroup) - min;\n\n                // Determine if rounding up is needed based on this field's value.\n                // The `roundUp` flag will reflect the state of the *most significant* field being truncated.\n                // If `round` is true and this field's value (before truncating) is past its midpoint,\n                // then `roundUp` becomes true. Otherwise, it becomes false.\n                if (round && offset > ((max - min) / 2)) {\n                    roundUp = true;\n                } else {\n                    roundUp = false;\n                }\n            }\n            \n            // Truncate the current field by setting it to its minimum value in `gVal`.\n            // The `val.get(field) - offset` from the original code would achieve `min`.\n            gVal.set(currentFieldInGroup, min);\n        }\n\n        // After the loop, `gVal` holds the correctly truncated/rounded time.\n        // Apply this final time to the original `val` calendar using setTimeInMillis()\n        // to avoid DST issues that arise from individual field setters.\n        val.setTimeInMillis(gVal.getTimeInMillis());\n\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}