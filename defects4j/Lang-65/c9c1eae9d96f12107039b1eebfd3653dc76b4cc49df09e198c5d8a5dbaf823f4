{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually modify milliseconds, seconds and minutes fields for rounding/truncation,\n        // rather than using Calendar methods, to avoid timezone issues.\n        \n        // If the field is MILLISECOND, we don't need to modify anything below it.\n        if (field == Calendar.MILLISECOND) {\n            return;\n        }\n\n        Date date = val.getTime();\n        long time = date.getTime();\n        boolean done = false;\n\n        // truncate or round milliseconds\n        int millis = val.get(Calendar.MILLISECOND);\n        if (!round || millis < 500) {\n            // truncate\n            time = time - millis;\n        } else {\n            // round up\n            time = time - millis + 1000; // Add 1 second\n        }\n        if (field == Calendar.SECOND) {\n            done = true;\n        }\n\n        // truncate or round seconds\n        int seconds = val.get(Calendar.SECOND);\n        if (!done && (!round || seconds < 30)) {\n            // truncate\n            time = time - (seconds * 1000L);\n        } else if (!done && round && seconds >= 30) {\n             // round up seconds (moves to next minute)\n             time = time - (seconds * 1000L) + 60000L;\n        }\n        if (field == Calendar.MINUTE) {\n            done = true;\n        }\n\n        // truncate or round minutes\n        int minutes = val.get(Calendar.MINUTE);\n        if (!done && (!round || minutes < 30)) {\n            // truncate\n            time = time - (minutes * 60000L);\n        } else if (!done && round && minutes >= 30) {\n            // round up minutes (moves to next hour)\n             time = time - (minutes * 60000L) + 3600000L;\n        }\n\n        // reset time using the modified time\n        if (date.getTime() != time) {\n            date.setTime(time);\n            val.setTime(date); // Use setTime to apply the change safely respecting DST\n        }\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false; // Indicates if the previous field level rounded up\n        for (int i = 0; i < fields.length; i++) {\n\n            // Check if we need to skip modification for fields handled by LANG-59 fix\n            int currentField = fields[i][0];\n            boolean isSmallField = (currentField == Calendar.MILLISECOND ||\n                                    currentField == Calendar.SECOND ||\n                                    currentField == Calendar.MINUTE);\n\n            // Check if this level contains the target field\n            boolean foundTargetField = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    foundTargetField = true;\n                    //This is our field... we stop looping\n                    if (round && roundUp) { // roundUp determined by the previous field's processing\n                        if (field == DateUtils.SEMI_MONTH) {\n                            //This is a special case that's hard to generalize\n                            //If the date is 1, we round up to 16, otherwise\n                            //  we subtract 15 days and add 1 month\n                            if (val.get(Calendar.DATE) == 1) {\n                                val.add(Calendar.DATE, 15);\n                            } else {\n                                val.add(Calendar.DATE, -15);\n                                val.add(Calendar.MONTH, 1);\n                            }\n                        } else {\n                            //We need at add one to this field since the\n                            //  last number causes us to round up\n                            // Note: The LANG-59 block already handled rounding for MS, SEC, MINUTE targets implicitly by adjusting 'time'.\n                            // We only need to explicitly add 1 for fields larger than MINUTE.\n                            if (!isSmallField) { // Only add if not handled by LANG-59 block's time arithmetic\n                                val.add(fields[i][0], 1);\n                            }\n                        }\n                    }\n                    return; // Processing finished\n                }\n            } // End inner loop (field matching)\n\n\n            // --- Process field level BELOW the target field ---\n\n            // Calculate offset and determine if the *next* field level should round up.\n            int offset = 0;\n            boolean offsetSet = false;\n            //These are special types of fields that require different rounding rules\n            switch (field) { // Check the *target* field for special rules\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) { // If processing DATE level for SEMI_MONTH target\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7; // roundUp based on day within 1-15 or 16-end range\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) { // If processing HOUR_OF_DAY level for AM_PM target\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12; // Offset within AM/PM period\n                        }\n                        roundUp = offset >= 6; // Round up if hour is 6 or more within AM/PM (original said > 6?) Check logic: round half up. 12 hours / 2 = 6. >= 6 rounds up.\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            if (!offsetSet) {\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum (round half up)\n                // Multiply by 2 to avoid floating point / integer division issues\n                roundUp = offset * 2 >= (max - min + 1); // Check threshold carefully: (max-min+1) is range size. Half is size/2. Round up if offset >= size/2.\n                                                          // Equivalent to offset*2 >= size.\n            }\n\n            // Truncate the current field level value IF it wasn't handled by the LANG-59 block\n            if (!isSmallField) {\n                // We need to remove this field's value by setting it to its minimum\n                val.set(fields[i][0], val.getActualMinimum(fields[i][0]));\n            }\n            // For MS, SEC, MINUTE, the truncation was already done by the LANG-59 block via setTime().\n            // The roundUp value calculated here based on the state *after* the LANG-59 block is correct\n            // for determining rounding at the next higher field level.\n\n        } // End outer loop (field levels)\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}