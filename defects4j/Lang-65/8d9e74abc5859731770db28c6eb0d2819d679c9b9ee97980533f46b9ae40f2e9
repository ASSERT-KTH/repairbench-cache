{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n\n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods. This is implemented in the loop below by checking\n        // if !round and if the current field is one of the problematic time fields.\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false;\n        for (int i = 0; i < fields.length; i++) {\n            // currentFieldGroupPrimary is the primary Calendar field for this group (e.g., MILLISECOND, SECOND, MINUTE, etc.)\n            int currentFieldGroupPrimary = fields[i][0];\n            boolean reachedTargetField = false;\n\n            // Check if the target 'field' for modification is in this current group\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    reachedTargetField = true;\n                    break;\n                }\n            }\n\n            if (reachedTargetField) {\n                // This is our target field. Apply rounding if applicable and then return.\n                if (round && roundUp) { // roundUp is determined by the previous (finer) field's offset\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // This is a special case that's hard to generalize\n                        // If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        // We need to add one to this field since the\n                        //  last number causes us to round up\n                        val.add(currentFieldGroupPrimary, 1);\n                    }\n                }\n                return; // Modification complete for the target field\n            }\n\n            // If we haven't reached the target field yet, it means the current field\n            // is \"finer\" than the target field, and thus needs to be cleared (truncated)\n            // before proceeding to coarser fields. This is where the problematic\n            // Calendar.set() calls occur for lower time fields.\n\n            int offset = 0;\n            boolean offsetSet = false;\n\n            // Handle special cases for SEMI_MONTH or AM_PM to calculate 'offset' and 'roundUp'\n            // for fields that affect these special rounding types.\n            switch (field) { // This switch is based on the 'target' field, not the current field being processed.\n                case DateUtils.SEMI_MONTH:\n                    if (currentFieldGroupPrimary == Calendar.DATE) {\n                        // If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        // We need to subtract 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        // If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        // Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (currentFieldGroupPrimary == Calendar.HOUR_OF_DAY) {\n                        // If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n\n            if (!offsetSet) {\n                // Calculate the offset to set the current field to its minimum\n                int min = val.getActualMinimum(currentFieldGroupPrimary);\n                int max = val.getActualMaximum(currentFieldGroupPrimary);\n                offset = val.get(currentFieldGroupPrimary) - min; // The amount to subtract to clear the field to its minimum\n                // Determine if rounding up (for the *next* coarser field) is needed based on this field's value\n                roundUp = offset > ((max - min) / 2);\n            }\n\n            // We need to remove this field (set it to its truncated value, which is min - 0 for finer fields).\n            // This is the line that needs modification for LANG-59.\n            if (!round && (currentFieldGroupPrimary == Calendar.MILLISECOND ||\n                           currentFieldGroupPrimary == Calendar.SECOND ||\n                           currentFieldGroupPrimary == Calendar.MINUTE)) {\n                // For truncation of MILLISECOND, SECOND, or MINUTE,\n                // manually manipulate milliseconds to avoid Calendar.set() issues with DST.\n                // 'offset' holds the current value of the field relative to its minimum (e.g., 4 for 4 milliseconds).\n                // Subtracting this 'offset' effectively sets the field to its minimum (0).\n                val.setTimeInMillis(val.getTimeInMillis() - offset);\n            } else {\n                // For other fields, or if rounding, use the original Calendar.set() method.\n                val.set(currentFieldGroupPrimary, val.get(currentFieldGroupPrimary) - offset);\n            }\n        }\n        // If the loop completes, it means the 'field' was not found in the 'fields' array.\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}