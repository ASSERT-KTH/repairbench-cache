{
    "generation": "import java.util.Calendar;\nimport java.util.Date; // Required for val.getTime() in the comment or if using Date object.\nimport java.util.TimeZone; // Required for the test context, not strictly for the function itself.\n// Assuming DateUtils.SEMI_MONTH, fields array, and other DateUtils context are available.\n\n// DateUtils.SEMI_MONTH (usually 1001 or another custom field ID)\n// DateUtils.fields (the array defining calendar field hierarchies and processing order)\n// private static final int[][] fields = {\n//         {Calendar.MILLISECOND},\n//         {Calendar.SECOND},\n//         {Calendar.MINUTE},\n//         {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n//         {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH, Calendar.WEEK_OF_YEAR, Calendar.WEEK_OF_MONTH},\n//         {Calendar.MONTH},\n//         {Calendar.YEAR}\n// };\n\n\n    /**\n     * <p>Internal calculation method.</p>\n     * \n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n        \n        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n        // see http://issues.apache.org/jira/browse/LANG-59\n        //\n        // Manually truncate milliseconds, seconds and minutes, rather than using\n        // Calendar methods which can cause issues with DST transitions.\n        // This fix is integrated into the main loop below by handling specific fields\n        // using getTimeInMillis() and setTimeInMillis().\n        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n        boolean roundUp = false; // This 'roundUp' is calculated for the *previous* smaller field's offset, for carrying over.\n        for (int i = 0; i < fields.length; i++) {\n            // Determine if the current group of fields (fields[i]) contains the target 'field'.\n            boolean foundTargetFieldInGroup = false;\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    foundTargetFieldInGroup = true;\n                    break; // Found target field in this group, break inner loop\n                }\n            }\n            \n            // Calculate offset and roundUp for the *current* field being processed (fields[i][0]).\n            // This 'roundUp' is based on the *current* field's value and will be used\n            // if we need to round up the *next higher* field (in the next iteration).\n            int offset = 0;\n            boolean offsetSet = false;\n            \n            // These are special types of fields that require different rounding rules\n            // The switch is on 'field' (the target granularity), affecting how 'offset'\n            // and 'roundUp' are calculated for the *current* `fields[i][0]`.\n            switch (field) {\n                case DateUtils.SEMI_MONTH:\n                    if (fields[i][0] == Calendar.DATE) {\n                        //If we're going to drop the DATE field's value,\n                        //  we want to do this our own way.\n                        //We need to subtrace 1 since the date has a minimum of 1\n                        offset = val.get(Calendar.DATE) - 1;\n                        //If we're above 15 days adjustment, that means we're in the\n                        //  bottom half of the month and should stay accordingly.\n                        if (offset >= 15) {\n                            offset -= 15;\n                        }\n                        //Record whether we're in the top or bottom half of that range\n                        roundUp = offset > 7;\n                        offsetSet = true;\n                    }\n                    break;\n                case Calendar.AM_PM:\n                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                        //If we're going to drop the HOUR field's value,\n                        //  we want to do this our own way.\n                        offset = val.get(Calendar.HOUR_OF_DAY);\n                        if (offset >= 12) {\n                            offset -= 12;\n                        }\n                        roundUp = offset > 6;\n                        offsetSet = true;\n                    }\n                    break;\n            }\n            \n            if (!offsetSet) { // If not a special case, use generic offset calculation\n                int min = val.getActualMinimum(fields[i][0]);\n                int max = val.getActualMaximum(fields[i][0]);\n                //Calculate the offset from the minimum allowed value\n                offset = val.get(fields[i][0]) - min;\n                //Set roundUp if this is more than half way between the minimum and maximum\n                roundUp = offset > ((max - min) / 2);\n            }\n\n            // Now, apply the truncation/rounding for the *current* `fields[i][0]`.\n            if (foundTargetFieldInGroup) {\n                // This is our field... we stop looping for fields[i] and potentially exit.\n                // If 'round' is true AND 'roundUp' (from the *previous* smaller field) is true,\n                // we need to round up the current field.\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) { // Special rounding for SEMI_MONTH\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return; // Exit after handling the target field\n            }\n            \n            // If we reach here, it means `field` was NOT found in the current `fields[i]` group.\n            // Therefore, we are currently processing a field that is *smaller* in granularity\n            // than the target `field`, and it needs to be truncated (set to its minimum).\n            \n            // The value `offset` is calculated above as `val.get(fields[i][0]) - min`.\n            // So, `val.set(fields[i][0], val.get(fields[i][0]) - offset)` is equivalent to `val.set(fields[i][0], min)`.\n            // For time fields, min is 0.\n            \n            // --- Fix for LANG-59: Manually truncate time fields using milliseconds ---\n            int currentFieldId = fields[i][0];\n            if (currentFieldId == Calendar.MILLISECOND) {\n                // Truncate milliseconds by setting them to 0 using millis arithmetic\n                val.setTimeInMillis((val.getTimeInMillis() / 1000L) * 1000L);\n            } else if (currentFieldId == Calendar.SECOND) {\n                // Truncate seconds (and implicitly milliseconds) by setting them to 0\n                val.setTimeInMillis((val.getTimeInMillis() / (60L * 1000L)) * (60L * 1000L));\n            } else if (currentFieldId == Calendar.MINUTE) {\n                // Truncate minutes (and implicitly seconds, milliseconds) by setting them to 0\n                val.setTimeInMillis((val.getTimeInMillis() / (60L * 60L * 1000L)) * (60L * 60L * 1000L));\n            } else {\n                // For other fields (HOUR_OF_DAY, DATE, MONTH, YEAR), use original Calendar.set()\n                // The current offset calculated is the value to subtract to set the field to its minimum.\n                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}