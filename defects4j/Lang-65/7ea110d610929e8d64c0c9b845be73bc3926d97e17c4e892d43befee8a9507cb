{
    "generation": "    /**\n     * <p>Internal calculation method.</p>\n     *\n     * @param val  the calendar\n     * @param field  the field constant\n     * @param round  true to round, false to truncate\n     * @throws ArithmeticException if the year is over 280 million\n     * @throws IllegalArgumentException if the field is unsupported\n     */\n    private static void modify(Calendar val, int field, boolean round) {\n        // Ensure the Calendar is not excessively large to avoid calculation errors\n        if (val.get(Calendar.YEAR) > 280000000) {\n            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n        }\n\n        // If the target field is the smallest unit, no lower fields exist to modify.\n        // Rounding might still apply, handled below. Truncation is a no-op.\n        if (field == Calendar.MILLISECOND) {\n             // If rounding, the loop needs to run to potentially add 1ms if roundUp is true\n             // If truncating, nothing happens, so we could return early, but loop handles it.\n        }\n\n        boolean roundUp = false; // Stores whether the next higher field should be rounded up\n        boolean fieldFound = false; // Tracks if the specified 'field' is supported\n\n        // Step 1: Determine if rounding is needed.\n        // Iterate through the defined field levels (e.g., MILLISECOND, SECOND, MINUTE...).\n        // This loop calculates 'roundUp' based on the value of fields less significant\n        // than the target 'field'. It does *not* modify the calendar instance 'val' yet\n        // to avoid side effects (LANG-59).\n        for (int i = 0; i < fields.length; i++) {\n            boolean isTargetLevel = false; // Is this level the one specified by 'field'?\n            // Check if any field constant in the current level matches the target 'field'\n            for (int j = 0; j < fields[i].length; j++) {\n                if (fields[i][j] == field) {\n                    isTargetLevel = true;\n                    fieldFound = true; // Mark the target field as supported and found\n                    break; // Found the target field in this level\n                }\n            }\n\n            // If this level IS the target level specified by 'field'\n            if (isTargetLevel) {\n                // Apply rounding *if* requested ('round' is true) and if the calculation\n                // based on the *previous*, less significant field indicated rounding ('roundUp' is true).\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        // Special rounding logic for SEMI_MONTH field\n                        if (val.get(Calendar.DATE) == 1) {\n                            // If date is 1, round up to 16 by adding 15 days\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            // If date is > 1 (must be in 16-end range), subtract 15 days\n                            // to get to 1st of month, then add 1 month to round up.\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        // General rounding: Add 1 unit to the primary field of this level.\n                        // fields[i][0] is the main field constant for this level (e.g., Calendar.HOUR_OF_DAY).\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                // We've processed the target level (including potential rounding).\n                // No need to examine further, more significant fields.\n                break; // Exit the 'fields' loop.\n            }\n\n            // If this level is *below* the target level:\n            // Calculate the offset of the current field value from its minimum.\n            // Use this offset to determine if the *next* higher field should be rounded up.\n            int primaryFieldOfLevel = fields[i][0]; // The main field constant for this level\n            int offset = 0;\n            boolean offsetSet = false; // Flag for special calculation cases below\n\n            // Special calculation for SEMI_MONTH target field:\n            // If we are examining the DATE field level for a SEMI_MONTH target.\n            if (field == DateUtils.SEMI_MONTH && primaryFieldOfLevel == Calendar.DATE) {\n                // Offset from the start of the relevant half-month (1 or 16)\n                offset = val.get(Calendar.DATE) - 1; // 0-based day index\n                if (offset >= 15) { // Is the date in the second half (16+)?\n                    offset -= 15; // Offset relative to the 16th\n                }\n                // Round up if date is past the midpoint of the half-month (> 7 days offset)\n                roundUp = offset > 7;\n                offsetSet = true; // Mark that 'roundUp' was set by special logic\n            }\n            // Special calculation for AM_PM target field:\n            // If we are examining the HOUR_OF_DAY field level for an AM_PM target.\n            else if (field == Calendar.AM_PM && primaryFieldOfLevel == Calendar.HOUR_OF_DAY) {\n                // Offset from the start of the AM/PM period (0 or 12)\n                offset = val.get(Calendar.HOUR_OF_DAY); // 0-23 hour\n                if (offset >= 12) { // Is the hour in the PM period?\n                    offset -= 12; // Offset relative to 12:00\n                }\n                // Round up if hour is past the midpoint of the half-day (> 6 hours offset)\n                roundUp = offset > 6;\n                offsetSet = true; // Mark that 'roundUp' was set by special logic\n            }\n\n            // General calculation for 'roundUp':\n            // If 'roundUp' wasn't set by special logic above.\n            if (!offsetSet) {\n                int min = val.getActualMinimum(primaryFieldOfLevel); // Min value for this field (e.g., 0 for SECOND)\n                int max = val.getActualMaximum(primaryFieldOfLevel); // Max value for this field (e.g., 59 for SECOND)\n                // Offset from the minimum value\n                offset = val.get(primaryFieldOfLevel) - min;\n                // Round up if the value is strictly greater than the midpoint of the range.\n                // Check for max == min to avoid division by zero\n                if (max == min) {\n                    roundUp = false; // Cannot round up if range is zero\n                } else {\n                    roundUp = offset > ((max - min) / 2);\n                }\n            }\n            // Note: We do *not* modify 'val' here. 'roundUp' is carried to the next iteration or used by the target level.\n\n        } // End of loop for determining rounding\n\n        // If the loop completed without finding the field, it's unsupported.\n        if (!fieldFound) {\n            throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n        }\n\n        // Step 2: Truncate fields less significant than the target field. (LANG-59 Fix)\n        // This is done *after* potential rounding adjustments.\n        // We set these fields to their minimum value (usually 0).\n        // The order of setting fields is important: start with the smallest unit (MILLISECOND)\n        // and move up to HOUR_OF_DAY. This minimizes potential side effects with Calendar calculations.\n\n        boolean troncMillisecond = false; // Should MILLISECOND be truncated?\n        boolean troncSecond = false;      // Should SECOND be truncated?\n        boolean troncMinute = false;      // Should MINUTE be truncated?\n        boolean troncHour = false;        // Should HOUR_OF_DAY be truncated?\n\n        // Determine which fields to truncate based on the target 'field' using fall-through logic\n        switch (field) {\n            // Cases for fields Calendar.DATE and above require truncating hours, minutes, seconds, milliseconds\n            case Calendar.YEAR:\n            case Calendar.MONTH:\n            case DateUtils.SEMI_MONTH:\n            // Assuming DAY_OF_*, WEEK_OF_* fields imply truncation to the start of the day\n            case Calendar.DATE:\n            case Calendar.DAY_OF_MONTH:\n            case Calendar.DAY_OF_YEAR:\n            case Calendar.WEEK_OF_MONTH:\n            case Calendar.WEEK_OF_YEAR:\n                troncHour = true; // Need to truncate HOUR_OF_DAY\n                // Fallthrough intended\n\n            // Cases for fields Calendar.HOUR* and AM/PM require truncating minutes, seconds, milliseconds\n            // NOTE: Truncating AM/PM means truncating to the start of the AM/PM period (00:00 or 12:00).\n            // The rounding logic already handles the jump to the next AM/PM period.\n            // For truncation (round=false), setting HOUR_OF_DAY to 0 handles the AM case correctly.\n            // For PM truncation, the HOUR_OF_DAY field is handled by the general logic based on levels.\n            // Setting troncHour = true correctly zeros out H,M,S,MS when field is DATE or higher.\n            // When field is AM_PM, HOUR*, MINUTE, SECOND, only fields below it are truncated by this switch.\n            // The rounding loop already determined if AM/PM rounding needs to happen.\n            // This truncation part zeros out fields *below* the target field.\n            case Calendar.AM_PM:\n            case Calendar.HOUR_OF_DAY:\n            case Calendar.HOUR:\n                troncMinute = true; // Need to truncate MINUTE\n                // Fallthrough intended\n\n            // Case for Calendar.MINUTE requires truncating seconds, milliseconds\n            case Calendar.MINUTE:\n                troncSecond = true; // Need to truncate SECOND\n                // Fallthrough intended\n\n            // Case for Calendar.SECOND requires truncating milliseconds\n            case Calendar.SECOND:\n                troncMillisecond = true; // Need to truncate MILLISECOND\n                // Fallthrough intended\n\n            // Base case: No truncation needed below MILLISECOND\n            case Calendar.MILLISECOND:\n                break; // Stop fallthrough\n\n            // If 'field' was not matched above, it would have thrown IllegalArgumentException earlier\n        }\n\n        // Apply truncation by setting fields to their minimum value (0) in the correct order\n        if (troncMillisecond) {\n            val.set(Calendar.MILLISECOND, 0);\n        }\n        if (troncSecond) {\n            val.set(Calendar.SECOND, 0);\n        }\n        if (troncMinute) {\n            val.set(Calendar.MINUTE, 0);\n        }\n        if (troncHour) {\n            // Using HOUR_OF_DAY ensures the hour is set to 0 (midnight) regardless of AM/PM\n            val.set(Calendar.HOUR_OF_DAY, 0);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}