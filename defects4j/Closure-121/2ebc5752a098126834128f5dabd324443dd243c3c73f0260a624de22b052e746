{
    "generation": "private void inlineNonConstants(\n    Var v, ReferenceCollection referenceInfo,\n    boolean maybeModifiedArguments) {\n  int refCount = referenceInfo.references.size();\n  Reference declaration = referenceInfo.references.get(0);\n  Reference init = referenceInfo.getInitializingReference();\n  int firstRefAfterInit = (declaration == init) ? 2 : 3;\n\n  if (refCount > 1 &&\n      isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n    // If the variable is referenced more than once, we can only\n    // inline it if it\u2019s immutable and never defined before being referenced.\n    Node value;\n    if (init != null) {\n      value = init.getAssignedValue();\n    } else {\n      // Create a new node for a variable that is never initialized.\n      Node srcLocation = declaration.getNode();\n      value = NodeUtil.newUndefinedNode(srcLocation);\n    }\n    Preconditions.checkNotNull(value);\n    inlineWellDefinedVariable(v, value, referenceInfo.references);\n    staleVars.add(v);\n  } else if (refCount == firstRefAfterInit) {\n    // The variable is likely only read once.  Try some more\n    // complex inlining heuristics.  However, we now must be careful\n    // not to inline non-constant initializers when doing so would change\n    // evaluation order.  For example, inlining:\n    //   var x = u;\n    // in a context where u is later modified (e.g. via a recursive call)\n    // would result in different semantics.  To prevent this, only inline\n    // if the initializer is immutable.\n    if (init == null) {\n      return;\n    }\n    Node value = init.getAssignedValue();\n    Preconditions.checkNotNull(value);\n    if (!NodeUtil.isImmutableValue(value)) {\n      // Do not inline if the initializer isn\u2019t an immutable value.\n      return;\n    }\n    Reference reference = referenceInfo.references.get(firstRefAfterInit - 1);\n    if (canInline(declaration, init, reference)) {\n      inline(v, declaration, init, reference);\n      staleVars.add(v);\n    }\n  } else if (declaration != init && refCount == 2) {\n    if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n      // When the only reference is the initialization, remove the assignment and\n      // the variable declaration.\n      Node value = init.getAssignedValue();\n      Preconditions.checkNotNull(value);\n      inlineWellDefinedVariable(v, value, referenceInfo.references);\n      staleVars.add(v);\n    }\n  }\n\n  // If this variable was not inlined normally, check if we can\n  // inline an alias of it. (If the variable was inlined, then the\n  // reference data is out of sync. We're better off just waiting for\n  // the next pass.)\n  if (!maybeModifiedArguments &&\n      !staleVars.contains(v) &&\n      referenceInfo.isWellDefined() &&\n      referenceInfo.isAssignedOnceInLifetime()) {\n    // Inlining the variable based solely on being well-defined and assigned\n    // once is *NOT* correct. We relax the correctness requirement only if\n    // the variable is declared constant.\n    List<Reference> refs = referenceInfo.references;\n    for (int i = 1; i < refs.size(); i++) { // start from a read\n      Node nameNode = refs.get(i).getNode();\n      if (aliasCandidates.containsKey(nameNode)) {\n        AliasCandidate candidate = aliasCandidates.get(nameNode);\n        if (!staleVars.contains(candidate.alias) &&\n            !isVarInlineForbidden(candidate.alias)) {\n          Reference aliasInit = candidate.refInfo.getInitializingReference();\n          Node aliasValue = aliasInit.getAssignedValue();\n          Preconditions.checkNotNull(aliasValue);\n          inlineWellDefinedVariable(candidate.alias,\n              aliasValue,\n              candidate.refInfo.references);\n          staleVars.add(candidate.alias);\n        }\n      }\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}