{
    "generation": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.references.get(0);\n      Reference init = referenceInfo.getInitializingReference();\n      // Calculate the index of the first reference after the declaration and\n      // initialization. If declaration and initialization are the same reference,\n      // it's the second reference (index 1), otherwise it's the third (index 2).\n      // The substract-1 is because get() is 0-based.\n      int firstRefAfterInitIndex = -1;\n      if (declaration == init) {\n        // declaration and init are combined: ref0 = decl/init, ref1 = first use\n        if (refCount > 1) {\n            firstRefAfterInitIndex = 1;\n        }\n      } else if (init != null) {\n         // declaration and init are distinct: ref0 = decl, ref1 = init, ref2 = first use\n         if (refCount > 2) {\n             firstRefAfterInitIndex = 2;\n         }\n      }\n\n\n      if (refCount > 1 &&\n          isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        // if the variable is referenced more than once, we can only\n        // inline it if it's immutable and never defined before referenced.\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Create a new node for variable that is never initialized.\n          Node srcLocation = declaration.getNode();\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n        Preconditions.checkNotNull(value);\n        inlineWellDefinedVariable(v, value, referenceInfo.references);\n        staleVars.add(v);\n      } else if (firstRefAfterInitIndex != -1 && refCount == firstRefAfterInitIndex + 1) {\n        // The variable is declared, initialized, and read exactly once.\n        // Try some more complex inlining heuristics.\n        Reference reference = referenceInfo.references.get(firstRefAfterInitIndex);\n        Node value = null;\n        if (init != null) {\n            value = init.getAssignedValue();\n        }\n\n        boolean canInlineCheckResult = canInline(declaration, init, reference);\n\n        // Add a safety check for Issue 1053:\n        // If the value being inlined is a variable (NAME) that isn't inherently\n        // immutable (like primitives are), and it might be modified by side effects\n        // between the initialization and the single use (e.g., by a function call),\n        // then the canInline->checkInlineIntegrity check might not be sufficient.\n        if (canInlineCheckResult && value != null && value.isName() && !NodeUtil.isImmutableValue(value)) {\n             Var valueVar = init.getScope().getVar(value.getString());\n             // Be conservative: If the variable is potentially modified externally\n             // (non-local, captured by closure, etc.) and the initialization and\n             // use are in different basic blocks (meaning code runs between them),\n             // then disable inlining for this case.\n             if (valueVar != null &&\n                 (!valueVar.isLocal() || valueVar.isEscaped()) &&\n                 init.getBasicBlock() != reference.getBasicBlock()) {\n                 canInlineCheckResult = false;\n             }\n        }\n\n\n        if (canInlineCheckResult) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      } else if (declaration != init && init != null && refCount == 2) {\n         // This case handles variables that are declared and initialized but never read.\n         // Example: var x; x = 1;\n        if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n          // The only references are the declaration and the initialization.\n          // Remove the assignment and the variable declaration.\n          // Note: No value inlining actually happens here, just removal.\n          // We might want to adjust this logic or the calling inline method,\n          // but for safety, just remove the assignment for now.\n          Node assignNode = init.getNode().getParent(); // Assuming init is NAME in ASSIGN\n          if (assignNode != null && assignNode.isAssign()) {\n             NodeUtil.removeChild(init.getParent(), assignNode);\n             staleVars.add(v); // Mark the var as potentially removable if decl is simple\n          } else if (init.getNode().getParent().isVar() && init.getNode().hasChildren()) {\n             // Handle var x = init; where x is never used. Remove the initializer.\n             init.getNode().removeChildren();\n             staleVars.add(v);\n          }\n          // Implicitly, the declaration (which is the only other reference)\n          // might be removed by later dead code removal passes if the var becomes unused.\n        }\n      }\n\n      // If this variable was not inlined normally, check if we can\n      // inline an alias of it. (If the variable was inlined, then the\n      // reference data is out of sync. We're better off just waiting for\n      // the next pass.)\n      if (!maybeModifiedArguments &&\n          !staleVars.contains(v) &&\n          referenceInfo.isWellDefined() &&\n          referenceInfo.isAssignedOnceInLifetime()) {\n          // Inlining the variable based solely on well-defined and assigned\n          // once is *NOT* correct. We relax the correctness requirement if\n          // the variable is declared constant.\n        List<Reference> refs = referenceInfo.references;\n        // Start from 1 if decl != init, or 2 if decl == init?\n        // Needs careful index handling based on structure.\n        // Let's use the previously computed firstRefAfterInitIndex.\n        int startReadIndex = (firstRefAfterInitIndex != -1) ? firstRefAfterInitIndex : 1;\n\n        for (int i = startReadIndex; i < refs.size(); i++) {\n          Node nameNode = refs.get(i).getNode();\n          // Check reads only. A read reference must have a NAME node.\n          if (nameNode != null && nameNode.isName() && refs.get(i).isRead()) {\n              if (aliasCandidates.containsKey(nameNode)) {\n                AliasCandidate candidate = aliasCandidates.get(nameNode);\n                // Check if the alias itself is safe to inline potentially\n                if (!staleVars.contains(candidate.alias) &&\n                    !isVarInlineForbidden(candidate.alias)) {\n                  Reference aliasInit = candidate.refInfo.getInitializingReference();\n                  // Ensure the alias has a valid initialization\n                  if (aliasInit != null && isValidInitialization(aliasInit)) {\n                      Node value = aliasInit.getAssignedValue();\n                      if (value != null && NodeUtil.isImmutableValue(value)) {\n                           // Only inline if the alias value is truly immutable.\n                           // Avoids issues similar to the main variable inlining.\n                          inlineWellDefinedVariable(candidate.alias,\n                              value,\n                              candidate.refInfo.references);\n                          staleVars.add(candidate.alias);\n                      }\n                  }\n                }\n              }\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}