{
    "generation": "    private void inlineNonConstants(\n        Var v, ReferenceCollection referenceInfo,\n        boolean maybeModifiedArguments) {\n      int refCount = referenceInfo.references.size();\n      Reference declaration = referenceInfo.getDeclaration();\n      Reference init = referenceInfo.getInitializingReference();\n\n      // Calculate the index of the first reference after initialization.\n      // This helps identify cases where the variable is used exactly once after init.\n      int firstRefAfterInitIndex = -1;\n      int initIndex = (init != null) ? referenceInfo.references.indexOf(init) : -1;\n      if (initIndex != -1 && initIndex < refCount - 1) {\n          firstRefAfterInitIndex = initIndex + 1;\n      } else if (init == null && declaration != null) {\n          // No explicit init, check after declaration if declaration is present.\n          int declIndex = referenceInfo.references.indexOf(declaration);\n           if (declIndex != -1 && declIndex < refCount - 1) {\n              firstRefAfterInitIndex = declIndex + 1;\n          }\n      }\n\n      // Condition 1: Inline variables that are assigned once to an immutable value.\n      // This is safe because the value is constant and known.\n      if (refCount > 1 && isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n        Node value;\n        if (init != null) {\n          value = init.getAssignedValue();\n        } else {\n          // Variable is read but never assigned a value locally. Inline as undefined.\n          Node srcLocation = declaration != null ? declaration.getNode() : v.getNode();\n          // Ensure srcLocation is valid for creating a node.\n          if (srcLocation == null || srcLocation.getStaticSourceFile() == null) {\n             // Use a placeholder if source info is unavailable.\n             srcLocation = new Node(Token.SCRIPT);\n          }\n          value = NodeUtil.newUndefinedNode(srcLocation);\n        }\n\n        // Ensure we have a value to inline.\n        if (value != null) {\n           // Clone the value node tree for safe inlining at multiple sites.\n           inlineWellDefinedVariable(v, value.cloneTree(), referenceInfo.references);\n           staleVars.add(v);\n        }\n      // Condition 2: Try to inline variables that are initialized and used exactly once.\n      // This is potentially unsafe if the assigned value can change between init and use.\n      } else if (init != null && firstRefAfterInitIndex != -1 && refCount == firstRefAfterInitIndex + 1) {\n        // We have an initialization and exactly one reference after it.\n        Reference reference = referenceInfo.references.get(firstRefAfterInitIndex);\n\n        // Fix for issue 1053: Check stability of the assigned value, especially if it's a variable.\n        // If the assigned value (e.g., 'u' in x=u) can change state between the assignment\n        // and the use of 'x', inlining 'x' with 'u' is incorrect.\n        boolean valueIsStable = true;\n        Node valueNode = init.getAssignedValue();\n\n        if (valueNode == null) {\n             valueIsStable = false; // Cannot inline if assigned value is null/empty.\n        } else if (valueNode.isName()) {\n          // The assigned value is a variable name. Check if this variable might change.\n          Var valueVar = referenceInfo.scope.getVar(valueNode.getString());\n          if (valueVar != null) {\n            // Need reference information for the variable used as the value.\n            ReferenceCollection valueRefInfo = getRefInfo(valueVar); // Assume getRefInfo helper exists\n            if (valueRefInfo != null) {\n              // If we have reference info, check assignment count and escaped status.\n              // A variable assigned multiple times or escaped might change unexpectedly.\n              if (!valueRefInfo.isAssignedOnceInLifetime() || valueVar.isMarkedEscaped()) {\n                valueIsStable = false;\n              }\n            } else {\n              // No reference info available for the value variable.\n              // Check basic properties to assess stability.\n              // Assume unstable if global, extern, arguments object, escaped, or not declared 'const'.\n              if (valueVar.isGlobal() || valueVar.isExtern() ||\n                  valueVar.isArguments() || valueVar.isMarkedEscaped() ||\n                  !valueVar.isConst()) { // Use isConst as a best-effort check for stability.\n                valueIsStable = false;\n              }\n            }\n          } else {\n            // RHS variable name not found in scope? This indicates an error or unusual code.\n            // Treat as unstable for safety.\n            valueIsStable = false;\n          }\n        }\n        // Implicit else: valueNode is not a NAME. The canInline function should check its safety\n        // based on whether it has side effects or its value might change.\n\n        // Only proceed with inlining if the value appears stable AND canInline determines\n        // it's safe based on side effects and control flow between init and reference.\n        if (valueIsStable && canInline(declaration, init, reference)) {\n          inline(v, declaration, init, reference);\n          staleVars.add(v);\n        }\n      // Condition 3: Var declared, initialized, and never used otherwise (refCount == 2).\n      } else if (declaration != null && init != null && declaration != init && refCount == 2) {\n          // This case (e.g., var x = getValueWithSideEffects(); ) should be handled\n          // by other passes like RemoveUnusedVariables, which correctly handle\n          // preserving the initialization if it has side effects. Don't inline here.\n      }\n\n      // Condition 4: Alias inlining. Check if this variable 'v' is used as an alias\n      // for another variable that could be inlined.\n      // This check only runs if 'v' wasn't inlined above and meets basic safety criteria.\n      if (!maybeModifiedArguments && // Avoid if arguments object might be modified.\n          !staleVars.contains(v) && // Avoid if 'v' was already handled.\n          referenceInfo.isWellDefined() && // 'v' must be defined before use.\n          referenceInfo.isAssignedOnceInLifetime()) { // 'v' must be assigned only once.\n\n        List<Reference> refs = referenceInfo.references;\n        // Determine the index from where reads/aliases might start. Skip declaration/init.\n        int startReadIndex = 0;\n        if (!refs.isEmpty()) {\n            int declIndex = (declaration != null) ? refs.indexOf(declaration) : -1;\n            int initIdx = (init != null) ? refs.indexOf(init) : -1;\n            startReadIndex = Math.max(declIndex, initIdx) + 1;\n        }\n\n\n        for (int i = startReadIndex; i < refs.size(); i++) {\n          Reference currentRef = refs.get(i);\n          Node nameNode = currentRef.getNode();\n\n          // Check if this reference is a read and corresponds to a known alias candidate.\n          if (nameNode != null && nameNode.isName() && currentRef.isRead()) {\n              if (aliasCandidates.containsKey(nameNode)) {\n                  AliasCandidate candidate = aliasCandidates.get(nameNode);\n                  Var aliasVar = candidate.alias; // The variable being aliased ('v' aliased 'aliasVar').\n                  ReferenceCollection aliasRefInfo = candidate.refInfo;\n\n                  // Ensure the alias target var ('aliasVar') hasn't been removed/inlined already,\n                  // isn't forbidden, and is suitable for inlining itself.\n                  if (!staleVars.contains(aliasVar) &&\n                      !isVarInlineForbidden(aliasVar) &&\n                      aliasRefInfo != null && // Need ref info for the alias target.\n                      isImmutableAndWellDefinedVariable(aliasVar, aliasRefInfo)) {\n\n                      Reference aliasInit = aliasRefInfo.getInitializingReference();\n                      Node aliasValue;\n                      if (aliasInit != null) {\n                        aliasValue = aliasInit.getAssignedValue();\n                      } else {\n                          // Alias target is never initialized, treat as undefined.\n                          Node srcLocation = aliasVar.getNode();\n                          if (srcLocation == null || srcLocation.getStaticSourceFile() == null) {\n                             srcLocation = new Node(Token.SCRIPT); // Placeholder\n                          }\n                          aliasValue = NodeUtil.newUndefinedNode(srcLocation);\n                      }\n\n                      if (aliasValue != null) {\n                          // Inline the alias variable ('aliasVar') using its stable value.\n                          inlineWellDefinedVariable(aliasVar, aliasValue.cloneTree(), aliasRefInfo.references);\n                          staleVars.add(aliasVar);\n                          // Successfully inlined an alias based on this reference to 'v',\n                          // break from the loop checking references of 'v'.\n                          break;\n                      }\n                  }\n              }\n          }\n        }\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}