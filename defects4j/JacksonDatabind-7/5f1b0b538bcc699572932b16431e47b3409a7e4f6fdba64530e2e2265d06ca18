{
    "generation": "    /**\n     * Standard deserializer for {@link TokenBuffer}.\n     *<p>\n     * Note: requires optimization effort, should not be performance bottleneck\n     * for initial versions.\n     */\n    @Override\n    public TokenBuffer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // [databind#1681] may need to use a `TokenBuffer` directly...\n        // `TokenBuffer(p, ctxt)` does NOT work)\n        final TokenBuffer tb = ctxt.bufferForInputBuffering(p);\n\n        JsonToken t = p.currentToken();\n        if (t == JsonToken.FIELD_NAME) {\n            // 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n            // FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n            // to assume one did exist.\n            tb.writeStartObject();\n            do {\n                // 13-Aug-2017, tatu: coping mechanism update for [databind#1681]\n                tb.copyCurrentStructure(p);\n            } while (p.nextToken() == JsonToken.FIELD_NAME);\n\n            // and should end in END_OBJECT\n            if (p.currentToken() != JsonToken.END_OBJECT) {\n                // 13-Aug-2017, tatu: as per [databind#1681] need to error out\n                // Also: note that we do NOT yet know how to merge, can't merge.\n                // 13-Aug-2018, tatu: Let's use slightly more specific fail message for #1681\n                 return (TokenBuffer) ctxt.handleUnexpectedToken(handledType(), JsonToken.END_OBJECT, p,\n                         \"Expected END_OBJECT after copying contents for a TokenBuffer, starting from FIELD_NAME\", null);\n            }\n            tb.writeEndObject();\n        } else {\n            // The usual case: just copy the current event/structure\n            tb.copyCurrentStructure(p);\n        }\n        return tb;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}