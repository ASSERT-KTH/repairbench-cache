{
    "generation": "    /**\n     * Helper method used by standard deserializer.\n     *\n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        JsonToken t = jp.currentToken();\n        // [databind#592]: Handle potentially null token (pre-parsing)\n        if (t == null) {\n             t = jp.nextToken();\n             if (t == null) { // Empty input is fine, return empty buffer\n                  return this;\n             }\n        }\n\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        if (t == JsonToken.FIELD_NAME) {\n            // First: write implicit START_OBJECT\n            writeStartObject();\n            // Need to copy current field name and its value:\n            copyCurrentStructure(jp); // This will copy the field name and its value, and advance parser\n            // And then possible subsequent field/value pairs, until END_OBJECT\n            t = jp.currentToken(); // Check the token parser points to after copying structure\n            while (t == JsonToken.FIELD_NAME) {\n                copyCurrentStructure(jp); // Copy next field and value\n                t = jp.currentToken(); // Check token again\n            }\n            // Loop ends when we no longer have FIELD_NAME. If input JSON was valid,\n            // we should be at END_OBJECT.\n            if (t != JsonToken.END_OBJECT) {\n                 // 17-Jul-2020, tatu: Report exception similar to TokenBufferDeserializer\n                 // We check ctxt for null, although typical usage should provide it.\n                 if (ctxt != null) {\n                     ctxt.reportWrongTokenException(TokenBuffer.class, JsonToken.END_OBJECT,\n                             \"Expected END_OBJECT after copying contents of a JsonParser starting from FIELD_NAME, found \"+t);\n                 }\n                 // else: cannot report via context, might be direct call? Just proceed.\n            }\n             // We need to finish by writing END_OBJECT\n             writeEndObject();\n        } else {\n             // Not starting with FIELD_NAME? Need to copy the current structure/value normally\n             copyCurrentStructure(jp);\n        }\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}