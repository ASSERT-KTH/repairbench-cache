{
    "generation": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t = jp.getCurrentToken();\n        \n        if (t == JsonToken.FIELD_NAME) {\n            // When starting from FIELD_NAME, we need to implicitly wrap the content in an object.\n            // This means we consume the current FIELD_NAME and its value,\n            // and then any subsequent FIELD_NAMEs and their values, until the logical END_OBJECT.\n            writeStartObject();\n            \n            // The JsonParser is currently at FIELD_NAME. copyCurrentStructure will write the field\n            // name and its associated value, and advance the parser past that value.\n            copyCurrentStructure(jp); \n            \n            // After copying the first field, the parser is positioned at the token *after* the\n            // value of that field. We need to continue copying as long as we encounter more FIELD_NAMEs.\n            while (jp.getCurrentToken() == JsonToken.FIELD_NAME) {\n                copyCurrentStructure(jp);\n            }\n            \n            // After the loop, the parser should be at END_OBJECT (or some other token\n            // that signifies the end of the logical object scope).\n            // We must explicitly write the END_OBJECT to close the implicitly added START_OBJECT.\n            writeEndObject();\n        } else {\n            // For all other cases (e.g., parser starts at START_OBJECT, START_ARRAY, or a scalar),\n            // the standard copyCurrentStructure method handles it correctly by copying the\n            // current token and its entire structure.\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}