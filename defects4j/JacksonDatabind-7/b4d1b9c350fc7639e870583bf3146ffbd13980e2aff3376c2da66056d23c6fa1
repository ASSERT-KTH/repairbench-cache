{
    "generation": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        JsonToken t = jp.currentToken();\n        if (t == JsonToken.FIELD_NAME) {\n            // If we point to FIELD_NAME, assume START_OBJECT was already consumed\n            writeStartObject();\n            // and then fall through to copy the structure, starting with the FIELD_NAME\n        } else if (t == null) {\n             // 01-Jul-2019, tatu: As per [databind#2379], need to support case where\n             //    parser is not pointing to anything (is NOT Closed, just not pointing\n             //    to anything), and this is basically empty buffer.\n             //  NOTE: used to be an ISE but perhaps this is better?\n             _appendToken(JsonToken.VALUE_EMBEDDED_OBJECT);\n             _append(null);\n             return this;\n        }\n        // Otherwise, fall through to copy starting from the current token\n        copyCurrentStructure(jp);\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}