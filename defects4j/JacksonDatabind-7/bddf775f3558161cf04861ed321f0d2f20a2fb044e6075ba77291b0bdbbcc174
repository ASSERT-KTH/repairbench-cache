{
    "generation": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        // 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n        //    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n        //    to assume one did exist.\n        // The test failure indicates that when deserializing an object into TokenBuffer,\n        // the JsonParser `jp` might already be positioned at FIELD_NAME (e.g., when a delegating\n        // creator is used and the enclosing START_OBJECT has been consumed).\n        // In such a case, the TokenBuffer needs to implicitly wrap the content with START_OBJECT/END_OBJECT.\n\n        JsonToken t = jp.getCurrentToken();\n\n        if (t == JsonToken.FIELD_NAME) {\n            // This is the special case per #592: current token is a FIELD_NAME,\n            // implying we are \"inside\" an object that didn't provide a START_OBJECT\n            // token for this part of the stream.\n            // We need to prepend a START_OBJECT and append an END_OBJECT to make it a valid\n            // object structure within the TokenBuffer.\n            writeStartObject(); // Add the missing START_OBJECT\n            copyCurrentStructure(jp); // Copy the FIELD_NAME and its value, and any subsequent fields/values\n            writeEndObject();   // Add the corresponding END_OBJECT\n        } else {\n            // For all other cases (e.g., START_OBJECT, START_ARRAY, scalar value),\n            // the existing `copyCurrentStructure` method should correctly handle copying\n            // the current token and its subsequent structure/value.\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}