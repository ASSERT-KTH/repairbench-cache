{
    "generation": "    /**\n     * Helper method used by standard deserializer.\n     * \n     * @since 2.3\n     */\n    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n    {\n        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n         *    to assume one did exist.\n         */\n        if (jp.getCurrentToken() == JsonToken.FIELD_NAME) {\n            // First, prepend START_OBJECT to simulate the missing outer object\n            append(JsonToken.START_OBJECT);\n\n            // Now, copy the current field name and its value, and then subsequent fields.\n            // We must manually manage token advancements here because `copyCurrentStructure`\n            // does not advance the parser after copying a scalar value or field name.\n            \n            // Loop until we encounter the implicit END_OBJECT or end of stream\n            while (jp.getCurrentToken() != null && jp.getCurrentToken() != JsonToken.END_OBJECT) {\n                if (jp.getCurrentToken() == JsonToken.FIELD_NAME) {\n                    // Copy the field name\n                    writeFieldName(jp.getCurrentName());\n                    \n                    // Advance parser to the value token of the current field\n                    jp.nextToken();\n                    \n                    // Copy the value (could be a scalar, array, or object)\n                    copyCurrentStructure(jp);\n                    \n                    // After copyCurrentStructure(jp) copies a scalar value, \n                    // jp is still at that value token. We need to advance it \n                    // to the next token (which should be another FIELD_NAME or END_OBJECT).\n                    // If copyCurrentStructure copied a structured type (object/array),\n                    // it would have already advanced jp past the END_OBJECT/END_ARRAY.\n                    // This next call to jp.nextToken() will correctly move past the scalar,\n                    // or be redundant but harmless if jp is already positioned correctly.\n                    jp.nextToken();\n                } else {\n                    // Unexpected token: we are inside an implied object and expected\n                    // either FIELD_NAME or END_OBJECT, but got something else.\n                    throw ctxt.mappingException(\"Unexpected token (%s) when processing FIELD_NAME starting from FIELD_NAME, expecting FIELD_NAME or END_OBJECT\",\n                            jp.getCurrentToken());\n                }\n            }\n            // Finally, append END_OBJECT to complete the simulated outer object\n            append(JsonToken.END_OBJECT);\n        } else {\n            // Standard case: parser is at START_OBJECT, START_ARRAY, or a scalar value.\n            // `copyCurrentStructure` handles these cases. For structured types, it advances\n            // the parser past the matching end token. For scalar types, it copies and leaves\n            // the parser at that token, which is fine as the buffer is then complete.\n            copyCurrentStructure(jp);\n        }\n        return this;\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}