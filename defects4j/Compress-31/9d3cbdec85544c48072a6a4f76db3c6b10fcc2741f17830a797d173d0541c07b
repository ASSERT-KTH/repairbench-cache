{
    "generation": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n    final int fieldEnd = offset + length;\n    int pos = offset;\n    // Skip leading spaces.\n    while (pos < fieldEnd && buffer[pos] == ' ') {\n        pos++;\n    }\n    // If the field is all spaces, treat it as missing and return 0.\n    if (pos == fieldEnd) {\n        return 0L;\n    }\n    // If the first non-space is a NUL byte, treat the field as missing.\n    if (buffer[pos] == 0) {\n        return 0L;\n    }\n    long result = 0;\n    final int digitStart = pos;\n    // Parse the octal digits.\n    while (pos < fieldEnd && buffer[pos] >= '0' && buffer[pos] <= '7') {\n        result = (result << 3) + (buffer[pos] - '0');\n        pos++;\n    }\n    // If no digit was found, then the first non-space character wasn\u2019t a valid digit.\n    if (pos == digitStart) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, pos, buffer[pos]));\n    }\n    // There must be at least one trailing character (a space or NUL) after the digits.\n    if (pos == fieldEnd) {\n        throw new IllegalArgumentException(\"Trailing space/NUL missing in octal field\");\n    }\n    // All remaining characters must be trailing markers (only space or NUL allowed).\n    for (int i = pos; i < fieldEnd; i++) {\n        if (buffer[i] != 0 && buffer[i] != ' ') {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, i, buffer[i]));\n        }\n    }\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}