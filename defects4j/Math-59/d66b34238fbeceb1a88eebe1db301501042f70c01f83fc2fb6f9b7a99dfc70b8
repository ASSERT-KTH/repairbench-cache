{
    "generation": "    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     *         The behaviour is aligned with {@link java.lang.Math#max(float, float)}:\n     *         - If either argument is NaN, the result is NaN.\n     *         - max(+0.0f, -0.0f) == max(-0.0f, +0.0f) == +0.0f.\n     */\n    public static float max(final float a, final float b) {\n        // Handle NaN cases first (rule: if either is NaN, result is NaN)\n        // Note: comparisons with NaN always return false, except != which returns true.\n        if (Float.isNaN(a) || Float.isNaN(b)) {\n            return Float.NaN;\n        }\n\n        // Handle zero cases specifically: max(+0.0, -0.0) == +0.0 and max(-0.0, +0.0) == +0.0\n        // The standard comparison a >= b works for max(+0.0, -0.0) -> +0.0,\n        // but fails for max(-0.0, +0.0) because -0.0 == +0.0, so (-0.0 >= +0.0) is true, returning -0.0.\n        // We need to handle the case where a is -0.0 specifically.\n        // Use floatToRawIntBits to distinguish -0.0 (0x80000000) from +0.0 (0x0).\n        // This check also implicitly handles b == 0.0f because the equality a == b is required.\n        if (a == 0.0f && b == 0.0f && Float.floatToRawIntBits(a) == 0x80000000) {\n            // If a is -0.0f, and b is +0.0f or -0.0f, return b.\n            // max(-0.0f, +0.0f) returns +0.0f (b)\n            // max(-0.0f, -0.0f) returns -0.0f (b)\n            return b;\n        }\n\n        // For all other cases, including normal numbers, infinities, and the remaining zero cases\n        // like max(+0.0f, -0.0f) and max(+0.0f, +0.0f), the standard comparison works.\n        return (a >= b) ? a : b;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}