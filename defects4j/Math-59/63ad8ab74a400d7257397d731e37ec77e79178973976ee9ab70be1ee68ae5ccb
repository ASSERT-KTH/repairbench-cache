{
    "generation": "    /** Compute the maximum of two values\n     * @param a first value\n     * @param b second value\n     * @return b if a is lesser or equal to b, a otherwise\n     */\n    public static float max(final float a, final float b) {\n        // The original code was:\n        // return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n        //\n        // This failed for cases like max(50.0f, -50.0f) because:\n        // 1. (50.0f <= -50.0f) is false.\n        // 2. The code then enters the 'else' branch: (Float.isNaN(a + b) ? Float.NaN : b)\n        // 3. a + b = 50.0f + (-50.0f) = 0.0f.\n        // 4. Float.isNaN(0.0f) is false.\n        // 5. The expression evaluates to 'b', which is -50.0f, while 50.0f was expected.\n        //\n        // The problem is that when 'a' is indeed greater than 'b' (and neither is NaN),\n        // the function should return 'a', but it was returning 'b' in the non-NaN case\n        // of the 'else' branch.\n        //\n        // The fix is to change the final 'b' to 'a' in the ternary operation's 'else' part.\n        // This preserves the NaN handling (if a or b is NaN, a+b is NaN, so NaN is returned)\n        // and correctly returns 'a' when 'a' is the greater non-NaN value.\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n    }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}