{
    "generation": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      // Assuming 'this' is the Var object for the variable in question.\n      Var v = this;\n\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        // No single assignment found.\n        return false;\n      }\n\n      // Find the function containing the assignment statement.\n      // ref.getNode() is the NAME node. ref.getParentNode() is the expression (e.g. ASSIGN).\n      // We need the function containing the statement where assignment happens.\n      Node assignmentNode = ref.getNode();\n      // Get the statement node that contains the assignment expression.\n      Node assignmentStatement = NodeUtil.getEnclosingStatement(assignmentNode.getParent());\n      Node enclosingFunction = NodeUtil.getEnclosingFunction(assignmentStatement);\n\n      // Make sure this assignment is not inside a loop construct.\n      // We walk up the basic block graph from the assignment's block.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n\n        // If we reach the entry block of the function containing the assignment,\n        // stop checking for loops within this function.\n        if (block.isFunction) {\n            if (enclosingFunction != null && block.getRoot() == enclosingFunction) {\n                break;\n            }\n            // If checking a global assignment, stop if we hit any function boundary.\n            // The global check below handles assignments inside functions.\n            if (enclosingFunction == null) {\n               break;\n            }\n        }\n\n        // If any block in the chain up to the function/global boundary is a loop,\n        // then the assignment occurs within a loop.\n        if (block.isLoop) {\n          return false;\n        }\n      }\n\n      // Additional Check: If the variable is global, the assignment must\n      // also be in the global scope (not inside any function).\n      // An assignment to a global variable inside a function can happen multiple\n      // times if the function is called multiple times or recursively.\n      if (v.getScope().isGlobal() && enclosingFunction != null) {\n          return false;\n      }\n\n      // If the variable is local to a function F, this check currently assumes\n      // that if the assignment is not inside a loop construct *within* F,\n      // it's assigned once per execution of F. For the variable to be truly\n      // assigned once in its lifetime, F itself must execute only once.\n      // This implementation does not explicitly check if the enclosing function\n      // runs multiple times (e.g., via recursion or multiple callsites),\n      // which could lead to false positives for local variables in such functions.\n      // However, the added check for global variables fixes the specific issue\n      // highlighted by the failing test case.\n\n      // If the assignment is not in a loop and satisfies the global variable check,\n      // return true.\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}