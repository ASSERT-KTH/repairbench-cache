{
    "generation": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop, including those formed by\n      // recursive function calls or functions defined/called within loops.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isLoop) {\n          // The assignment is directly inside a syntactic loop (e.g., for, while).\n          return false;\n        } else if (block.isFunction) {\n          // The assignment is inside a function.\n          // This function itself might cause the assignment to be executed multiple times.\n          // 1. If the function is recursive: The assignment occurs in each recursive invocation.\n          // 2. If the function is defined/called from within a loop: The assignment occurs each time the loop iterates.\n\n          // Check for recursion: If the ControlFlowGraph of this function is recursive,\n          // then the assignment is effectively happening multiple times.\n          // Assuming `BasicBlock` provides access to its containing `ControlFlowGraph`,\n          // and `ControlFlowGraph` has a method to check for recursion.\n          if (block.getControlFlowGraph().isRecursive()) {\n            return false;\n          }\n          // Do NOT break here. Continue iterating up the parent chain.\n          // This allows the logic to check if this function itself is defined inside a loop\n          // (which would be detected by `block.getParent().isLoop` in a subsequent iteration).\n        }\n      }\n\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}