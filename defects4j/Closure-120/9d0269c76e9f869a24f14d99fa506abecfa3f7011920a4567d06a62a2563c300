{
    "generation": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      // Also, make sure it's not in a recursive function.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          // This 'block' is the entry block for the function containing the assignment.\n          // To check for recursion, we need the actual FUNCTION Node from the AST,\n          // not just the BasicBlock representing its control flow.\n          // We can find the containing FUNCTION node by traversing the AST parents from the assignment node.\n          Node assignmentNode = ref.getAssignment();\n          Node functionNode = assignmentNode;\n          while (functionNode != null && !functionNode.isFunction()) {\n            functionNode = functionNode.getParent();\n          }\n\n          // If no function node is found (e.g., it's a top-level script assignment,\n          // or an unexpected AST structure), be conservative.\n          if (functionNode == null) {\n            return false;\n          }\n\n          // Get access to the AbstractCompiler and its CallGraph to check for recursion.\n          // Assuming 'this' (Var) can access its Scope, and Scope can access the Compiler.\n          // These are standard patterns in Closure Compiler for accessing global analyses.\n          AbstractCompiler compiler = getScope().getCompiler();\n          if (compiler == null) {\n            // If compiler context is not available, we cannot reliably determine recursion.\n            // Be conservative and assume it might be assigned multiple times.\n            return false;\n          }\n\n          CallGraph callGraph = compiler.getCallGraph();\n          if (callGraph == null) {\n            // If call graph analysis was not performed, we cannot determine recursion.\n            // Be conservative and assume it might be assigned multiple times.\n            return false;\n          }\n\n          // Check if the function containing this assignment is recursive.\n          // If it is, the assignment can execute multiple times.\n          if (callGraph.isRecursive(functionNode)) {\n            return false;\n          }\n\n          // We've found the function scope. No need to go further up the BasicBlock parent chain.\n          break;\n        } else if (block.isLoop) {\n          // The assignment is inside an explicit loop, so it can be executed multiple times.\n          return false;\n        }\n      }\n\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}