{
    "generation": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.jscomp.Scope;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.Var;\n// Assuming BasicBlock class is defined elsewhere and has getParent(), isFunction(), isLoop() methods.\n// Assuming Reference class is defined elsewhere and has getSymbol(), getNode(), getBasicBlock() methods.\n// Assuming getOneAndOnlyAssignment() is a method available in the context (e.g., part of the surrounding class).\n\n    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime. This means the variable is assigned statically once, and\n     *     that assignment isn't inside a loop or a function that modifies\n     *     an outer-scoped variable (which could lead to multiple assignments\n     *     at runtime if the function is called multiple times).\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        // 0 or >1 static assignments\n        return false;\n      }\n\n      Var symbol = ref.getSymbol();\n      // We need the variable symbol to check its scope. If it's missing, we can't perform the check.\n      if (symbol == null) {\n         // This case seems unlikely if ref is a valid assignment reference. Return false conservatively.\n         return false;\n      }\n      Scope varScope = symbol.getScope();\n       // Scope might be null for undeclared variables used in externs.\n      if (varScope == null) {\n          return false;\n      }\n      Node varScopeRoot = varScope.getRootNode();\n\n      Node assignmentNode = ref.getNode();\n      // Find the function immediately enclosing the assignment statement.\n      // This can be null if the assignment occurs in the global scope.\n      Node assigningFunctionNode = NodeUtil.getEnclosingFunction(assignmentNode);\n\n      // Traverse the basic block hierarchy upwards from the assignment's block.\n      // Check if the assignment occurs within a loop construct or\n      // inside a function that modifies an outer-scoped variable.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n\n        // Check 1: Is the assignment inside a loop?\n        // If the block represents a loop structure, the assignment might occur multiple times.\n        if (block.isLoop) {\n          return false;\n        }\n\n        // Check 2: Have we reached a block representing a function scope?\n        if (block.isFunction) {\n          // If the variable's defining scope is different from the function where the assignment occurs,\n          // then the assignment might happen multiple times if the function is called multiple times\n          // (e.g., recursion, called from a loop). This modifies an outer-scoped or global variable.\n          // Note: assigningFunctionNode can be null if assignment is in global scope,\n          // varScopeRoot holds the root node (often a SCRIPT or FUNCTION node) of the scope where the var was defined.\n          if (varScopeRoot != assigningFunctionNode) {\n             // Var is defined in scope S1 (global or an outer function).\n             // Assignment is inside function S2 (represented by assigningFunctionNode). S1 != S2.\n             // Function S2 might be called multiple times, causing reassignment of the variable in S1.\n             return false;\n          } else {\n             // Var is local to the function where the assignment occurs (varScopeRoot == assigningFunctionNode).\n             // We have already checked that the assignment is not inside a loop *within* this function.\n             // Any recursive call or multiple calls create new instances of this local variable.\n             // From the perspective of a single instance/activation, it's assigned once.\n             // We can stop traversing upwards within this function as further checks are irrelevant\n             // for this variable's lifetime related to *this* function's scope.\n             break;\n          }\n        }\n        // Continue traversing up the parent chain.\n      }\n\n      // If we exit the loop without returning false, it means the assignment is safe:\n      // 1. It's in the global scope and not within any loop structure.\n      // 2. It's within a function, the variable is local to that function, and the assignment\n      //    is not within any loop structure inside that function.\n      return true;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}