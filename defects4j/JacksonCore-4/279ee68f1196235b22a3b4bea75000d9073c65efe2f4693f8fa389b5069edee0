{
    "generation": "    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        final int len = curr.length;\n        // Determine new length: grow by 50% up to MAX_SEGMENT_LEN, then slower (25%)\n        // Also: let's assume the ultimate maximum length is 2^30 slices (~1 GB)\n        // (and let's assume argument validation has been done by caller, or will fail with OOME)\n        int newLen;\n\n        // If length is less than MAX_SEGMENT_LEN, grow by 50%, but capped at MAX_SEGMENT_LEN\n        if (len < MAX_SEGMENT_LEN) { // Below max segment len?\n            int proposedLen;\n            // For very small arrays (0, 1), need to grow by at least 1\n            if (len <= 1) {\n                 proposedLen = len + 1;\n            } else {\n                 proposedLen = len + (len >> 1); // Calculate 50% increase\n            }\n            // Cap at MAX_SEGMENT_LEN\n            newLen = Math.min(MAX_SEGMENT_LEN, proposedLen);\n        } else { // Otherwise, already max segment len or more: grow slower (25%)\n            // Check for potential overflow if len is close to Integer.MAX_VALUE\n            // Although extremely unlikely for char[] segments\n            if (len == Integer.MAX_VALUE) {\n                // Cannot grow further\n                throw new IllegalStateException(\"Maximum segment length (\"+len+\") reached\");\n            }\n            int increment = len >> 2; // 25% increase\n            // Ensure minimum growth of 1\n            newLen = len + Math.max(increment, 1);\n            // Also check for potential overflow from addition\n            if (newLen < 0) { // integer overflow\n                 newLen = Integer.MAX_VALUE;\n            }\n        }\n        // Sanity check: Ensure that the new length is strictly greater than the old length.\n        // This should be guaranteed by the logic above, but as a safeguard:\n        if (newLen <= len) {\n             newLen = len + 1;\n        }\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}