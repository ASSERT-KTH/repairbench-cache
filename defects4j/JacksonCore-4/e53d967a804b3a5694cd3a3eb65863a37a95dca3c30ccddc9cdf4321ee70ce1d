{
    "generation": "    /**\n     * Method called to expand size of the current segment, to\n     * accommodate for more contiguous content. Usually only\n     * used when parsing tokens like names if even then.\n     */\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        final int len = curr.length;\n        int newLen;\n\n        // The original logic was:\n        // int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        // This causes a bug when `len > MAX_SEGMENT_LEN`, because `Math.min(MAX_SEGMENT_LEN, ...)`\n        // would cap the new length at `MAX_SEGMENT_LEN`, which is smaller than `len`, leading to shrinkage.\n        // The comment \"above intended maximum, slow to increase by 25%\" indicates different behavior is needed.\n\n        if (len < MAX_SEGMENT_LEN) {\n            // Below intended maximum, grow by 50%.\n            // The original code implicitly capped this at MAX_SEGMENT_LEN,\n            // so we retain that behavior for this growth phase.\n            newLen = Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        } else if (len == MAX_SEGMENT_LEN) {\n            // Exactly at intended maximum, grow by 1 to get past it.\n            // This was the explicit case in the original logic.\n            newLen = MAX_SEGMENT_LEN + 1;\n        } else { // len > MAX_SEGMENT_LEN\n            // Already above intended maximum, increase by 25% as per comment.\n            // This is the key fix for the reported bug.\n            newLen = len + (len >> 2);\n        }\n\n        // Final sanity check: ensure newLen is strictly greater than len.\n        // This handles cases where the calculated growth might be zero (for very small `len` values)\n        // or where an integer overflow might occur for extremely large `len` values (though unlikely\n        // given typical MAX_SEGMENT_LEN and test cases).\n        if (newLen <= len) {\n            // Enforce at least 1 unit of growth.\n            // (Note: For `len == Integer.MAX_VALUE`, `len + 1` would overflow, but that's\n            // a general array size limit issue not directly related to MAX_SEGMENT_LEN).\n            newLen = len + 1;\n        }\n\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}