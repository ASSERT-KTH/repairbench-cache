{
    "generation": "private void getNumUseInUseCfgNode(final Node cfgNode) {\n  numUsesWithinCfgNode = 0;\n  AbstractCfgNodeTraversalCallback gatherCb =\n      new AbstractCfgNodeTraversalCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          // Look for uses of the variable.\n          if (n.isName() && n.getString().equals(varName)) {\n            // Normally we do not count a name that is the left\u2010hand side of an assignment.\n            // However, if that assignment is not \u201ctop\u2011level\u201d within the cfgNode (for example,\n            // when it occurs inside a hook operator), then it must be counted.\n            if (isLhsOfTopLevelAssignmentChain(n, cfgNode)) {\n              return;\n            }\n            numUsesWithinCfgNode++;\n          }\n        }\n\n        /**\n         * Returns true if n is the left-hand side of an assignment that is part of a\n         * top-level assignment chain (i.e. every ancestor from the assignment node\n         * up to cfgNode is an assignment).\n         */\n        private boolean isLhsOfTopLevelAssignmentChain(Node n, Node cfgNode) {\n          // n must be the first child of an ASSIGN.\n          if (!(n.getParent().isAssign() && n.getParent().getFirstChild() == n)) {\n            return false;\n          }\n          // Walk up from the assignment node until we hit cfgNode.\n          // If every parent in between is an assignment then the entire cfgNode\n          // is just a chain of assignments, so we skip counting n.\n          Node cur = n.getParent();\n          while (cur != null && cur != cfgNode) {\n            if (!cur.isAssign()) {\n              return false;\n            }\n            cur = cur.getParent();\n          }\n          return cur == cfgNode;\n        }\n      };\n\n  NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}