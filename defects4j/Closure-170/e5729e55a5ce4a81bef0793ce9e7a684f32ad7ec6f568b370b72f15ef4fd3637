{
    "generation": "    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(final Node cfgNode) {\n\n      numUsesWithinCfgNode = 0;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName)) {\n\n            boolean isLhsOfAssignment = parent != null && parent.isAssign() && parent.getFirstChild() == n;\n\n            // Check if this assignment is part of a statement that defines/initializes the variable,\n            // rather than an assignment used as an expression value.\n            boolean isStatementLevelAssignment = false;\n            if (isLhsOfAssignment) {\n                Node assignNode = parent;\n                Node assignParent = assignNode.getParent();\n                if (assignParent != null) {\n                    // Case: i = x; (parent is EXPR_RESULT)\n                    if (assignParent.isExprResult()) {\n                        isStatementLevelAssignment = true;\n                    }\n                    // Case: for (i = 0; ...), for (...; ...; i++)\n                    // Check if assignNode is the initializer or increment part of a FOR loop.\n                    else if (assignParent.isFor() &&\n                             (assignNode == assignParent.getSecondChild() || // initializer\n                              assignNode == assignParent.getLastChild())) {  // increment\n                        isStatementLevelAssignment = true;\n                    }\n                    // NOTE: This intentionally does not cover `var x = 1;` because in that case `n`\n                    // would be the NAME node `x`, whose parent is VAR, not ASSIGN.\n                    // We only need to exclude the LHS of ASSIGN nodes in specific statement contexts.\n                }\n            }\n\n            // We count the name occurrence if it's NOT the LHS of a statement-level assignment.\n            // This means we count:\n            // 1. Regular reads of the variable.\n            // 2. LHS of assignments that are nested within expressions (e.g., `(i=5)`, `x || (i=1)`),\n            //    as these assignments are used for their value and signal complexity that\n            //    might make inlining unsafe based on a simple use count.\n            if (!isStatementLevelAssignment) {\n              numUsesWithinCfgNode++;\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}