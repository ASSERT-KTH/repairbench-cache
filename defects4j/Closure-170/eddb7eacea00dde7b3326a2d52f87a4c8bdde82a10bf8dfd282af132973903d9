{
    "generation": "/**\n * Computes the number of uses of the variable varName and stores it in\n * numUsesWithinCfgNode.\n *\n * <p>When the whole CFG node consists solely of assignment\u2010chain expressions,\n * we do not count the left\u2010hand side of an assignment. However, if an assignment\n * appears nested (for example inside a hook, binary operator, etc.), then its LHS\n * should count as a use. We detect a \u201ctop\u2010level assignment chain\u201d by looking\n * upward from an ASSIGN node and requiring that every parent up to cfgNode is either\n * an ASSIGN or a COMMA.</p>\n */\nprivate void getNumUseInUseCfgNode(final Node cfgNode) {\n  numUsesWithinCfgNode = 0;\n  AbstractCfgNodeTraversalCallback gatherCb =\n      new AbstractCfgNodeTraversalCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName)) {\n            // If n is the left-hand side of an assignment, then normally we do not count it.\n            if (parent.isAssign() && parent.getFirstChild() == n) {\n              // But only skip it if the assignment is part of a top\u2010level assignment chain.\n              // That is, if from the parent (the ASSIGN node) up to cfgNode every node is\n              // either an ASSIGN or a COMMA, then we are in an assignment chain.\n              if (parent == cfgNode) {\n                // Special case: the cfgNode is itself an assignment.\n                return;\n              }\n              boolean isTopLevelChain = false;\n              for (Node cur = parent; cur != null && cur != cfgNode; cur = cur.getParent()) {\n                Node p = cur.getParent();\n                if (p == null) {\n                  break;\n                }\n                if (p == cfgNode) {\n                  isTopLevelChain = true;\n                  break;\n                }\n                if (!p.isAssign() && !p.isComma()) {\n                  break;\n                }\n              }\n              if (isTopLevelChain) {\n                return;\n              }\n            }\n            numUsesWithinCfgNode++;\n          }\n        }\n      };\n\n  NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}