{
    "generation": "    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(final Node cfgNode) {\n      numUsesWithinCfgNode = 0;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName) &&\n              // We make a special exception when the entire cfgNode is a chain\n              // of assignments, since in that case the assignment statements\n              // will happen after the inlining of the right hand side.\n              // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n              //   and remove this special case.\n              !(parent.isAssign() && parent.getFirstChild() == n) &&\n              // Don't count LHS of assignment even if it's not the first child\n              // (to handle cases like ternary operators that might contain assignments)\n              !(isAssignmentLikeParent(parent) && isLhsOfAssignment(n, parent))) {\n            numUsesWithinCfgNode++;\n          }\n        }\n\n        private boolean isAssignmentLikeParent(Node parent) {\n          return parent.isAssign() ||\n                 (parent.isHook() && isAssignmentParent(parent));\n        }\n\n        private boolean isAssignmentParent(Node parent) {\n          if (!parent.isHook()) return false;\n          // Check if either the consequent or alternative is an assignment\n          Node consequent = parent.getChildAt(1);\n          Node alternative = parent.getChildAt(2);\n          return (consequent.isAssign() && consequent.getFirstChild() == varName) ||\n                 (alternative.isAssign() && alternative.getFirstChild() == varName);\n        }\n\n        private boolean isLhsOfAssignment(Node n, Node parent) {\n          if (parent.isAssign()) {\n            return parent.getFirstChild() == n;\n          } else if (parent.isHook()) {\n            // For ternary operators, check if we're in an assignment branch\n            Node consequent = parent.getChildAt(1);\n            Node alternative = parent.getChildAt(2);\n            return (consequent.isAssign() && consequent.getFirstChild() == n) ||\n                   (alternative.isAssign() && alternative.getFirstChild() == n);\n          }\n          return false;\n        }\n      };\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}