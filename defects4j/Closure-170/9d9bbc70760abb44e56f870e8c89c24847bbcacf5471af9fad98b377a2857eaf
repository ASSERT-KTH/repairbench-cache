{
    "generation": "private void getNumUseInUseCfgNode(final Node cfgNode) {\n  numUsesWithinCfgNode = 0;\n\n  // Determine whether the entire cfgNode is an assignment chain.\n  // In such chains the \u201cleft\u2010hand side\u201d of an assignment happens later\n  // in evaluation and should be ignored.\n  final boolean inAssignmentChain;\n  if (cfgNode.isAssign()) {\n    inAssignmentChain = true;\n  } else if (cfgNode.isExprResult() && cfgNode.getFirstChild() != null\n             && cfgNode.getFirstChild().isAssign()) {\n    inAssignmentChain = true;\n  } else if (cfgNode.isComma()) {\n    // For comma operators, all children except the last are side-effect expressions.\n    boolean allAssigns = true;\n    for (Node c = cfgNode.getFirstChild(); c != null && c != cfgNode.getLastChild(); c = c.getNext()) {\n      if (!c.isAssign()) {\n        allAssigns = false;\n        break;\n      }\n    }\n    inAssignmentChain = allAssigns;\n  } else {\n    inAssignmentChain = false;\n  }\n\n  AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName() && n.getString().equals(varName)\n          // When the entire cfgNode is a chain of assignments, skip the LHS of an assignment.\n          // Otherwise (e.g. when the assignment is nested inside a HOOK or binary op)\n          // the variable is used (and could affect evaluation order).\n          && !(inAssignmentChain && parent.isAssign() && parent.getFirstChild() == n)) {\n        numUsesWithinCfgNode++;\n      }\n    }\n  };\n\n  NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}