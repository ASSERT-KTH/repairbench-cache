{
    "generation": "    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     *\n     * <p>This function counts all occurrences of the variable name within the\n     * cfgNode, including assignments to the variable. This is because the\n     * presence of an assignment within a control flow graph node can impact\n     * the safety of inlining, even if it's not a direct 'read' use.\n     * This addresses issues where variables assigned within\n     * conditional expressions (e.g., `i = 5` in `cond ? (i=5) : 0`) were\n     * incorrectly inlined because the assignment was not counted as a use\n     * by the previous logic.\n     * TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n     * and potentially revert this to only counting read uses if side-effect\n     * detection becomes sufficiently robust.\n     */\n    private void getNumUseInUseCfgNode(final Node cfgNode) {\n\n      numUsesWithinCfgNode = 0;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName)) {\n            // Count all occurrences of the variable name, including LHS of assignments.\n            // The previous exclusion for LHS of assignments was too broad and\n            // led to incorrect inlining decisions when variables were conditionally\n            // assigned within the control flow graph node.\n            numUsesWithinCfgNode++;\n          }\n        }\n\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}