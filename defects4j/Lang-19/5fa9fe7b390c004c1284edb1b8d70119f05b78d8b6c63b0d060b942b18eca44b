{
    "generation": "/**\n * {@inheritDoc}\n */\n@Override\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    int seqEnd = input.length();\n    // Uses -1 to ensure there is something after the '&' to check for '#'\n    if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        if(start >= seqEnd) {\n            // Nothing after '&#'\n            return 0;\n        }\n\n        boolean isHex = false;\n\n        if (start < seqEnd && (input.charAt(start) == 'x' || input.charAt(start) == 'X')) {\n            start++;\n            isHex = true;\n        }\n\n        if(start >= seqEnd) {\n            // Nothing after '&#' or '&#x'\n            return 0;\n        }\n\n        int end = start;\n        // scan until ';' or end of input\n        while (end < seqEnd && input.charAt(end) != ';') {\n            end++;\n        }\n\n        // if we found a semicolon, parse up to it\n        // if not, parse until end as unfinished entity\n        boolean semiColonFound = (end < seqEnd && input.charAt(end) == ';');\n\n        int parseEnd = semiColonFound ? end : end; // parse from start to end in both cases\n\n        String numberStr = input.subSequence(start, end).toString();\n        if(numberStr.isEmpty()){\n            return 0;\n        }\n\n        int entityValue;\n        try {\n            entityValue = Integer.parseInt(numberStr, isHex ? 16 :10);\n        } catch(NumberFormatException nfe) {\n            // Not a valid number, so no translation\n            return 0;\n        }\n\n        if (entityValue > 0xFFFF) {\n            char[] chrs = Character.toChars(entityValue);\n            out.write(chrs[0]);\n            out.write(chrs[1]);\n        } else {\n            out.write(entityValue);\n        }\n\n        // skip '&#' -> 2\n        // + (possible 'x') -> (isHex ?1:0)\n        // + number length -> (end - start)\n        // + (semicolon, if found) -> (semiColonFound ?1:0)\n        return 2 + (isHex ?1:0) + (end - start) + (semiColonFound ?1:0);\n    }\n    return 0;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}