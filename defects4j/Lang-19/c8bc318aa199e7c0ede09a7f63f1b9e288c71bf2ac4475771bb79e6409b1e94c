{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        // The condition `index < seqEnd - 2` ensures `input.charAt(index + 2)` is safe.\n        if (input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n            int start = index + 2; // Position after '&#', possibly 'x' or the first digit\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++; // Move start past 'x' or 'X'\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n                // If there's nothing after '&#x', the loop below will handle it by identifying\n                // that no digits were found, leading to the 'return 0' check.\n            }\n\n            // Find the end of the numeric entity characters\n            // entityDigitsEnd will point *after* the last valid digit that forms the number\n            int entityDigitsEnd = start; \n            while (entityDigitsEnd < seqEnd) {\n                char ch = input.charAt(entityDigitsEnd);\n                if (ch == ';') {\n                    // Semicolon marks the end of the entity, but it's not part of the number itself.\n                    // Stop collecting digits at this point. The semicolon will be consumed later.\n                    break;\n                }\n                if (isHex) {\n                    if (!((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'))) {\n                        // Character is not a hex digit, so the numeric part ends here\n                        break;\n                    }\n                } else { // Decimal\n                    if (!(ch >= '0' && ch <= '9')) {\n                        // Character is not a decimal digit, so the numeric part ends here\n                        break;\n                    }\n                }\n                entityDigitsEnd++;\n            }\n\n            // If no digits were found (e.g., \"&#x;\" or \"&#;\"), then no valid entity to translate\n            // This also covers cases like \"&#x\" or \"&#\" followed by end of input, where `start` equals `entityDigitsEnd`.\n            if (entityDigitsEnd == start) {\n                return 0; // No digits found, don't consume anything.\n            }\n\n            int entityValue;\n            try {\n                if (isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, entityDigitsEnd).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, entityDigitsEnd).toString(), 10);\n                }\n            } catch (NumberFormatException nfe) {\n                // This can happen if the parsed digits are too large for int, or other parsing errors.\n                System.err.println(\"FAIL: \" + input.subSequence(start, entityDigitsEnd) + \"[\" + start + \"][\" + entityDigitsEnd + \"]\");\n                return 0; // Return 0 if parsing fails, meaning no characters were translated/consumed.\n            }\n\n            // Write the character(s) to the output\n            if (entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n            // Calculate the total number of characters consumed from the input\n            int charsConsumed = 2; // For \"&#\"\n            if (isHex) {\n                charsConsumed += 1; // For \"x\" or \"X\"\n            }\n            charsConsumed += (entityDigitsEnd - start); // For the numeric digits (e.g., \"30\" in \"&#x30\")\n\n            // Check if a semicolon was present and consumed right after the digits\n            // entityDigitsEnd currently points to the character that stopped the digit collection loop (or seqEnd)\n            // If that character is a semicolon, it should be consumed as part of the entity.\n            if (entityDigitsEnd < seqEnd && input.charAt(entityDigitsEnd) == ';') {\n                charsConsumed += 1; // For \";\"\n            }\n\n            return charsConsumed;\n        }\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}