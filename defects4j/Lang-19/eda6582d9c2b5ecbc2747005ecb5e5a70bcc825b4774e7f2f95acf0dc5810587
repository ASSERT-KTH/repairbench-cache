{
    "generation": "    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Check for \"&#\"\n        // Note: index < seqEnd - 1 ensures we can read index + 1\n        if (input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2; // Current position is after \"&#\"\n            boolean isHex = false;\n\n            // Check if we actually have characters after \"&#\"\n            if (start >= seqEnd) {\n                // Reached end of input after \"&#\"\n                return 0;\n            }\n\n            char firstChar = input.charAt(start);\n            if (firstChar == 'x' || firstChar == 'X') {\n                start++; // Current position is after \"&#x\" or \"&#X\"\n                isHex = true;\n\n                // Check if we actually have characters after \"&#x\"\n                if (start >= seqEnd) {\n                    // Reached end of input after \"&#x\"\n                    return 0;\n                }\n            }\n\n            int end = start;\n            // Find the end of the digits, stopping at the first non-digit or end of sequence\n            while (end < seqEnd) {\n                char c = input.charAt(end);\n                if (isHex) {\n                    if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {\n                        end++;\n                    } else {\n                        break; // Found non-hex digit or other character\n                    }\n                } else {\n                    if (c >= '0' && c <= '9') {\n                        end++;\n                    } else {\n                        break; // Found non-decimal digit or other character\n                    }\n                }\n            }\n\n            // Check if any digits were found\n            if (end == start) {\n                // No digits found after \"&#\" or \"&#x\"\n                return 0;\n            }\n\n            boolean semiNext = (end < seqEnd && input.charAt(end) == ';');\n\n            int entityValue;\n            try {\n                CharSequence numericSequence = input.subSequence(start, end);\n                if (isHex) {\n                    entityValue = Integer.parseInt(numericSequence.toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(numericSequence.toString(), 10);\n                }\n            } catch (NumberFormatException nfe) {\n                // Should not happen with the digit checks unless the number is too large\n                // Return 0 to indicate nothing was translated\n                // System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\"); // Original debug print removed\n                return 0;\n            }\n\n            // Write the character(s) corresponding to the entity value\n            if (entityValue > 0xFFFF) {\n                // Handle supplementary characters (codepoints > U+FFFF)\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                // Handle BMP characters (codepoints <= U+FFFF)\n                // Note: The original code wrote entityValue even if it was 0 or negative.\n                // We retain this behavior, although filtering invalid codepoints might be desired in some contexts.\n                out.write(entityValue);\n            }\n\n            // Calculate the number of input characters consumed\n            // Includes \"&#\", optional \"x\", the digits, and the trailing \";\" if present.\n            // If semiNext is true, consumed length = (end - index) + 1 = end + 1 - index\n            // If semiNext is false, consumed length = end - index\n            int consumedLength = end - index;\n            if (semiNext) {\n                consumedLength++;\n            }\n            return consumedLength;\n        }\n        // Did not find \"&#\" at the current index\n        return 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}