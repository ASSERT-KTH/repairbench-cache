{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            int readLen = 0;\n            // Keep trying to read until we get actual data (>0) or hit end of stream (-1)\n            while (readLen == 0) {\n                // First, try to read data that Base64 codec might have already buffered\n                readLen = base64.readResults(b, offset, len);\n\n                if (readLen > 0) {\n                    return readLen; // Successfully read some bytes\n                } else if (readLen == -1) {\n                    return -1; // End of stream from the codec\n                }\n\n                // If readLen is 0, it means base64.readResults couldn't provide data yet.\n                // We need to read more from the underlying stream to feed the codec.\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf); // Read from the wrapped InputStream\n\n                if (c == -1) {\n                    // If the underlying stream is exhausted (c == -1),\n                    // and base64.readResults already returned 0, it means\n                    // there's no more data to be decoded/encoded.\n                    return -1; // End of stream.\n                }\n\n                // A little optimization to avoid System.arraycopy()\n                // when possible. This logic is preserved as in the original.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n\n                // Feed the data read from the underlying stream into the Base64 codec.\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n                // The loop will now re-evaluate and call readResults again to check for output.\n            }\n            // This part of the code should theoretically be unreachable as the loop always\n            // returns when readLen is not 0.\n            return readLen; // Defensive return, though execution should not reach here.\n        }\n    }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}