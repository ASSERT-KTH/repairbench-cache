{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            int readLen = 0;\n            while (true) { // Loop indefinitely until we read > 0 bytes or hit EOF\n                // 1. Try to read from the internal Base64 buffer.\n                readLen = base64.readResults(b, offset, len);\n\n                // If we got some data (readLen > 0) or hit EOF (-1), return it.\n                if (readLen > 0 || readLen == -1) {\n                    return readLen;\n                }\n\n                // If readLen is 0, it means the internal Base64 buffer is empty,\n                // and we need to read more from the underlying stream 'in'.\n\n                // 2. Read from the underlying stream.\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf); // Read from underlying stream\n\n                // 3. Handle EOF from the underlying stream.\n                if (c < 0) { // Underlying stream is at EOF\n                    // No more data from the underlying stream to process.\n                    // Since readLen was 0 from base64.readResults, and underlying stream is EOF,\n                    // it means we have truly reached the end of the data.\n                    return -1; // Return EOF\n                }\n\n                // 4. Process the data read from 'in' into the Base64 instance.\n                // The original code had a problematic optimization (setInitialBuffer) here,\n                // which is removed as per the official fix for CODEC-101 in Commons Codec.\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n\n                // The loop will now repeat, attempting to read results again\n                // from the Base64 instance which should now have processed data.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}