{
    "generation": "/**\n * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n * from this InputStream.\n * \n * @param b\n *            destination byte array\n * @param offset\n *            where to start writing the bytes\n * @param len\n *            maximum number of bytes to read\n * \n * @return number of bytes read, or -1 if end of stream\n * @throws IOException\n *             if an I/O error occurs.\n * @throws NullPointerException\n *             if the byte array parameter is null\n * @throws IndexOutOfBoundsException\n *             if offset, len or buffer size are invalid\n */\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    }\n\n    int readLen;\n    // keep looping until we either get data (>0) or hit end-of-stream (<0)\n    while ((readLen = base64.readResults(b, offset, len)) == 0) {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            // A little optimization to avoid System.arraycopy() when possible.\n            if (c > 0 && b.length == len) {\n                base64.setInitialBuffer(b, offset, len);\n            }\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n    }\n    return readLen;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}