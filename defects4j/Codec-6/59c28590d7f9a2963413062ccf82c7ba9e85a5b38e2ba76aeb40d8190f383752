{
    "generation": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        // Loop to avoid returning 0\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c == -1) { // underlying stream EOF\n                    base64.setInitialBuffer(null, 0, 0); // clear any buffer state\n                    if (!base64.hasData()) {\n                        // No more data to decode/encode, return EOF\n                        return -1;\n                    }\n                } else {\n                    // Optimization: re-use output array directly when possible\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n            if (readLen == 0) {\n                // No data produced, but base64 may not be EOF yet, so continue looping\n                if (in.available() == 0) {\n                    int c = in.read();\n                    if (c == -1) {\n                        // underlying EOF; if no further base64 data, break\n                        if (!base64.hasData()) {\n                            return -1;\n                        }\n                    } else {\n                        // Data read: push back the byte\n                        if (in instanceof java.io.PushbackInputStream) {\n                            ((java.io.PushbackInputStream) in).unread(c);\n                        } else {\n                            // Can't push back, so allocate a new PushbackInputStream\n                            in = new java.io.PushbackInputStream(in, 1);\n                            ((java.io.PushbackInputStream) in).unread(c);\n                        }\n                    }\n                } else {\n                    // Otherwise, try reading more in next loop iteration\n                    continue;\n                }\n            }\n        }\n        return readLen;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}