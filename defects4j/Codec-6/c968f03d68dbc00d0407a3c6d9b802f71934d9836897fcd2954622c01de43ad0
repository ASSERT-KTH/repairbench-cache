{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     *\n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     *\n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    @Override\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0 || len > b.length - offset) { // Consolidated bounds check\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) { // Loop until bytes are read or EOF\n                if (!base64.hasData()) { // Check if Base64 object needs more data\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf); // Read from underlying stream\n                    if (c == -1) { // End of underlying stream reached\n                        // If Base64 has no data left to output, we are at EOF for Base64InputStream\n                        if (!base64.hasData()) {\n                           return -1; // Signal EOF for this stream\n                        }\n                        // Otherwise, proceed to call readResults to flush any remaining Base64 data\n                    } else { // Data read from underlying stream\n                        // Pass the read data to the Base64 processor\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                    }\n                }\n                // Attempt to read results into the destination buffer\n                readLen = base64.readResults(b, offset, len);\n                // If readLen is 0, loop continues to ensure we don't return 0,\n                // potentially reading more from the underlying stream if needed.\n                // If readLen > 0, loop terminates and readLen is returned.\n                // If readLen is -1 (EOF), loop terminates and -1 is returned.\n            }\n            return readLen;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}