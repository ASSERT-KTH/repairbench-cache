{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     *\n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     *\n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n\n            int bytesRead = 0;\n            boolean eof = false; // Flag to track if the underlying stream has reached EOF\n\n            // Loop until we successfully read some bytes (bytesRead > 0)\n            // or confirm that EOF is reached (bytesRead will be -1).\n            // This loop ensures that the method never returns 0 if len > 0.\n            while (bytesRead == 0) {\n                // First, attempt to read results from the Base64 codec's internal buffer.\n                // This might be data already processed or newly processed in this iteration.\n                bytesRead = base64.readResults(b, offset, len);\n\n                if (bytesRead == 0) { // If readResults returned 0, it means Base64 has no processed data to give out *at this moment*.\n                                      // We need to try to get more raw data from the underlying InputStream 'in'.\n                    if (eof) {\n                        // If underlying stream is already at EOF and base64.readResults still returns 0,\n                        // and base64.hasData() is also false, then we truly have nothing more to read.\n                        // We must ensure base64 has flushed all data, as signaling EOF to it may produce more output.\n                        // This check was handled by the base64.encode/decode(..., -1) below.\n                        // If after that, bytesRead is still 0, then we return -1.\n                        // So, this specific check is handled by the final 'if (bytesRead == 0 && eof && !base64.hasData())'\n                    }\n\n                    // If Base64 has no internal data, or readResults returned 0,\n                    // and we haven't reached EOF on the underlying stream yet, read more raw data.\n                    if (!eof) { // Only read from 'in' if not already at EOF\n                        byte[] buf = new byte[doEncode ? 4096 : 8192];\n                        int c = in.read(buf);\n\n                        if (c < 0) { // Underlying stream reached EOF\n                            eof = true; // Set EOF flag\n                            // Signal EOF to the Base64 codec to flush any remaining data.\n                            // Passing -1 to encode/decode signifies end of input.\n                            if (doEncode) {\n                                base64.encode(buf, 0, -1);\n                            } else {\n                                base64.decode(buf, 0, -1);\n                            }\n                        } else if (c > 0) { // Data was read from underlying stream\n                            // A little optimization to avoid System.arraycopy()\n                            // when possible. This line was in the original code.\n                            if (b.length == len) {\n                                base64.setInitialBuffer(b, offset, len);\n                            }\n                            if (doEncode) {\n                                base64.encode(buf, 0, c);\n                            } else {\n                                base64.decode(buf, 0, c);\n                            }\n                        }\n                        // If c == 0, it means the underlying stream returned 0 bytes (e.g., non-blocking read without data).\n                        // In this case, we don't feed new data to base64, and bytesRead will remain 0,\n                        // causing the loop to re-attempt `readResults` or `in.read` again.\n                    }\n                }\n\n                // Check for final EOF condition after processing new input or attempting to read results.\n                // If bytesRead is still 0 AND the underlying stream is at EOF AND Base64 has no more data,\n                // then we have truly reached the end of the stream.\n                if (bytesRead == 0 && eof && !base64.hasData()) {\n                    return -1; // Indicate EOF\n                }\n            }\n            return bytesRead; // Return the number of bytes read (must be > 0)\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}