{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            int readLen = 0;\n            while (true) {\n                // Attempt to read decoded/encoded bytes from the Base64 instance's internal buffer.\n                // This call might return 0 if there's insufficient data in the internal buffer\n                // to fulfill the 'len' request, or if the processed data yields no output.\n                readLen = base64.readResults(b, offset, len);\n\n                if (readLen > 0 || readLen == -1) {\n                    // If we successfully read some bytes (readLen > 0), or if\n                    // the Base64 instance has no more data and indicates EOF (readLen == -1),\n                    // then we are done and can return the result.\n                    return readLen;\n                }\n\n                // If readLen is 0, it means Base64 couldn't produce any output from its current\n                // internal buffer. This typically happens when the buffer is empty, or when\n                // non-Base64 characters were processed and produced no output.\n                // In such cases, we need to read more data from the underlying InputStream.\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf); // Read bytes from the underlying InputStream\n\n                if (c < 0) {\n                    // If the underlying InputStream signals EOF (c < 0), and our Base64 instance\n                    // already returned 0 (meaning no more data to process), then the entire\n                    // stream is at an end. Return -1 to indicate EOF.\n                    return -1;\n                }\n\n                // Optimization: If the caller is reading into the entire destination buffer\n                // (i.e., `read(byte[])` was called, or `read(byte[], 0, b.length)`),\n                // then we can potentially set 'b' as the initial buffer for Base64.\n                // This allows Base64 to write decoded/encoded data directly into 'b',\n                // avoiding an intermediate System.arraycopy().\n                if (c > 0 && offset == 0 && len == b.length) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n\n                // Process the newly read bytes (encode or decode) and feed them to the Base64 instance.\n                // This will populate Base64's internal buffer, or directly write to 'b' if setInitialBuffer was effective.\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n                // The loop will continue, and in the next iteration, it will attempt to\n                // read results from the Base64 instance again, now with the newly processed data.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}