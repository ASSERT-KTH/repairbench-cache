{
    "generation": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    }\n\n    int readLen = base64.readResults(b, offset, len);\n    // eof indicates that the underlying stream has been exhausted.\n    boolean eof = false;\n    // Loop until we either read some bytes or detect end-of-stream.\n    while (readLen == 0) {\n        if (!base64.hasData()) {\n            byte[] buf = new byte[doEncode ? 4096 : 8192];\n            int c = in.read(buf);\n            if (c == -1) {\n                eof = true;\n            } else if (c > 0 && b.length == len) {\n                // Optimization: avoid an extra copy if the user buffer is the same size.\n                base64.setInitialBuffer(b, offset, len);\n            }\n            // Pass along the data (or the end-of-stream indicator) to the codec.\n            if (doEncode) {\n                base64.encode(buf, 0, c);\n            } else {\n                base64.decode(buf, 0, c);\n            }\n        }\n        // If we've reached EOF and there's no data in our internal buffer, return -1.\n        if (eof && !base64.hasData()) {\n            return -1;\n        }\n        readLen = base64.readResults(b, offset, len);\n    }\n    return readLen;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}