{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            int readLen = 0; // Initialize readLen to 0\n            while (readLen == 0) { // Loop until bytes are read (readLen > 0) or EOF (-1)\n                if (!base64.hasData()) { // If the codec has no buffered data to offer\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf); // Read from the underlying stream\n\n                    if (c == -1) { // End of underlying stream\n                        base64.setEof(true); // Signal EOF to the Base64 codec\n                    } else if (c > 0) { // If bytes were read\n                        // A little optimization to avoid System.arraycopy() when possible.\n                        // This uses the user's buffer directly as the codec's output buffer if appropriate.\n                        if (b.length == len) {\n                            base64.setInitialBuffer(b, offset, len);\n                        }\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                    }\n                    // If c is 0, the underlying stream returned 0 bytes but not EOF.\n                    // The loop continues to try base64.readResults anyway,\n                    // or tries to read from 'in' again on the next iteration.\n                }\n\n                // Attempt to read decoded/encoded data from the base64 codec\n                readLen = base64.readResults(b, offset, len);\n\n                // If readLen is still 0, check if we've exhausted all possibilities:\n                // If EOF has been signaled to the codec AND it has no more data to process/flush,\n                // then we must return -1 as no more bytes can be read.\n                if (readLen == 0 && base64.isEof() && !base64.hasData()) {\n                    return -1;\n                }\n            }\n            return readLen; // Return the bytes read (could be > 0 or -1)\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}