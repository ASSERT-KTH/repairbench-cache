{
    "generation": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        // Keep trying to read unless we actually get some data or reach EOF\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // If there is nothing from underlying stream, break (i.e., end of stream)\n                if (c == -1) {\n                    // If base64.hasData() is false and c == -1, nothing left to process\n                    break;\n                }\n                // Optimization to avoid System.arraycopy() when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n            if (base64.hasData() || readLen != 0) {\n                break;\n            } else if (!base64.hasData()) {\n                // Try to read more base data\n                continue;\n            }\n        }\n        return readLen == 0 ? -1 : readLen;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}