{
    "generation": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     *\n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     *\n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n    @Override\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        // Consolidated bounds check: ensures offset and len are non-negative,\n        // and offset + len does not exceed the buffer length.\n        } else if (offset < 0 || len < 0 || len > b.length - offset) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1). In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero. Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) { // Check if Base64 codec needs more data\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf); // Read raw data from underlying stream\n\n                    // Pass the data read (or EOF signal c=-1) to the Base64 codec\n                    // This will process the data and potentially buffer results.\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                // Ask the Base64 codec to fill the user's buffer with processed data\n                // This reads from the Base64 codec's internal buffer.\n                readLen = base64.readResults(b, offset, len);\n\n                // If readLen is 0, it means the Base64 codec consumed some input\n                // but didn't produce output bytes yet (e.g., non-base64 characters)\n                // or it needs more input for a complete group.\n                // The loop continues to ensure we don't return 0 unless len == 0.\n                // If base64.readResults returns -1, it signifies EOF from the codec,\n                // and the loop terminates.\n                // If base64.readResults returns > 0, data was successfully read,\n                // and the loop terminates.\n            }\n            return readLen;\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}