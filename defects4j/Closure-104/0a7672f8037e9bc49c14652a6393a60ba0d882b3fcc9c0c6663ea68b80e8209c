{
    "generation": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    // Apply the distributive property for the meet (greatest common subtype) operation:\n    // (A | B) meet C = (A meet C) | (B meet C)\n    // Iterate through each alternate in 'this' and find its greatest common subtype with 'that'.\n    for (JSType alternate : alternates) {\n      // Recursively call getGreatestSubtype on each alternate.\n      // This will correctly handle cases where 'that' is also a UnionType,\n      // applying the distributive property for 'that' as well (e.g., A meet (C|D) = (A meet C) | (A meet D)).\n      JSType intersection = alternate.getGreatestSubtype(that);\n\n      // Only add non-bottom types (i.e., not NoType or NoObjectType) to the builder.\n      // If all pairwise intersections result in bottom types, the builder will remain empty.\n      if (!intersection.isNoType() && !intersection.isNoObjectType()) {\n        builder.addAlternate(intersection);\n      }\n    }\n\n    JSType result = builder.build();\n\n    // If the builder produced a non-null result (i.e., at least one non-bottom intersection was found), return it.\n    if (result != null) {\n      return result;\n    }\n    // If no common subtypes were found (builder is empty/result is null):\n    // If both 'this' and 'that' are object types, their intersection is NoObject.\n    else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    // Otherwise (if at least one is not an object type), their intersection is NoType.\n    else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}