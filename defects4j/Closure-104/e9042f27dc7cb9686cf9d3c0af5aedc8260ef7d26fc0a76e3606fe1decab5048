{
    "generation": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n\n    if (that instanceof UnionType) {\n      UnionType thatUnion = (UnionType) that;\n      for (JSType thisAlternate : alternates) {\n        for (JSType thatAlternate : thatUnion.alternates) {\n          // Recursively find the greatest subtype of each pair of alternates.\n          // This ensures the distributive property of meet over union:\n          // meet(U_i A_i, U_j B_j) = U_i U_j meet(A_i, B_j)\n          JSType commonSubtype = thisAlternate.getGreatestSubtype(thatAlternate);\n          if (commonSubtype != null) {\n            // Add all results, including NoType/NoObject, as UnionTypeBuilder\n            // and subsequent normalization will handle these correctly.\n            builder.addAlternate(commonSubtype);\n          }\n        }\n      }\n    } else { // 'that' is not a UnionType\n      for (JSType thisAlternate : alternates) {\n        // Recursively find the greatest subtype of each alternate of 'this' with 'that'.\n        // meet(U_i A_i, B) = U_i meet(A_i, B)\n        JSType commonSubtype = thisAlternate.getGreatestSubtype(that);\n        if (commonSubtype != null) {\n            // Add all results, including NoType/NoObject.\n            builder.addAlternate(commonSubtype);\n        }\n      }\n    }\n\n    JSType result = builder.build();\n\n    // The builder.build() method, through registry.createUnionType,\n    // automatically handles normalization (e.g., (Foo|NoObject) -> Foo, (NoObject|NoType) -> NoType).\n    // So 'result' will be the most specific union of common subtypes found.\n    // If all common subtypes were 'NoObject', result will be 'NoObject'.\n    // If all common subtypes were 'NoType', result will be 'NoType'.\n    // If no common subtypes were found and 'getGreatestSubtype' yielded null for all pairs,\n    // then 'result' would be null. In this case, the original fallback logic is used.\n    if (result != null) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}