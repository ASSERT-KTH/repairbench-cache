{
    "generation": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    for (JSType alternate : alternates) {\n      // Computes the meet of this alternate with that JSType.\n      // The meet operation is the greatest lower bound, equivalent to the intersection\n      // of the types. If the types are incompatible (e.g., number and string, or two\n      // unrelated object types), the meet operation should result in an appropriate\n      // bottom type (NO_TYPE or NO_OBJECT_TYPE).\n      JSType alternateMeet = alternate.meet(that);\n\n      // The UnionTypeBuilder handles adding the result of the meet.\n      // It simplifies the union as alternates are added. For example:\n      // - Adding NO_TYPE is a no-op.\n      // - Adding T to a builder containing T' where T' <: T results in T'.\n      // - Adding T to a builder containing T' where T <: T' results in T.\n      // - Adding NO_OBJECT_TYPE multiple times results in NO_OBJECT_TYPE.\n      builder.addAlternate(alternateMeet);\n    }\n\n    JSType result = builder.build();\n\n    // If the result is null, it means that the union of all the meets resulted\n    // in an empty set (e.g., all meets resulted in NO_TYPE, or types that cancelled out).\n    // In this case, the greatest lower bound is the bottom type (NO_TYPE).\n    // If the builder returns a non-null type (which could be a specific type like String,\n    // or NO_OBJECT_TYPE if the meets of object types resulted in that),\n    // that non-null type is the correct meet result for the union.\n    if (result != null) {\n      return result;\n    } else {\n      // If the union collapses to nothing, the meet is the bottom type.\n      return registry.getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}