{
    "generation": "  /**\n   * Given two types, find the greatest common subtype (aka meet).\n   * GCS(T1 | T2, T3) = GCS(T1, T3) | GCS(T2, T3)\n   *\n   * In the case where the union consists of unrelated object types, the\n   * meet is the NO_OBJECT_TYPE. e.g.\n   * GCS(Error|URIError, String) = GCS(Error, String) | GCS(URIError, String)\n   *   = NO_OBJECT_TYPE | NO_OBJECT_TYPE = NO_OBJECT_TYPE\n   */\n  @Override\n  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    boolean needsNoObject = false; // Flag to track if NO_OBJECT_TYPE is part of the meet result\n\n    // Iterate through each alternate type in this union\n    for (JSType alternate : alternates) {\n      // Compute the greatest common subtype (meet) of the alternate and 'that'\n      // Note: JSType#getGreatestSubtype is the public API for meet.\n      JSType alternateMeet = alternate.getGreatestSubtype(that);\n\n      // Process the result of the meet and add it to the builder\n      if (alternateMeet.isUnionType()) {\n        // If the meet itself is a union, process its alternates\n        for (JSType meetAlternate : alternateMeet.toMaybeUnionType().getAlternates()) {\n          if (meetAlternate.isNoObjectType()) {\n            needsNoObject = true; // Mark that NO_OBJECT_TYPE is potentially needed\n          } else if (!meetAlternate.isNoType()) {\n            builder.addAlternate(meetAlternate); // Add other non-NO_TYPE results\n          }\n        }\n      } else if (alternateMeet.isNoObjectType()) {\n        // If the meet is NO_OBJECT_TYPE, mark it as potentially needed\n        needsNoObject = true;\n      } else if (!alternateMeet.isNoType()) {\n        // If the meet is a single, non-bottom type, add it\n        builder.addAlternate(alternateMeet);\n      }\n      // If alternateMeet is NO_TYPE, do nothing, it doesn't contribute to the meet\n    }\n\n    // Build the resulting type from the collected alternates\n    JSType result = builder.build();\n\n    // Determine the final return value based on the built type and the needsNoObject flag\n    if (result != null) {\n      // If the builder produced a non-empty type, return it.\n      // This resulting type represents the union of the meets calculated.\n      // If the result is, for example, 'Number' and needsNoObject was true\n      // (because meet(Obj, That) resulted in NoObject), the union Number | NoObject\n      // simplifies to Number, so returning 'result' is correct according to lattice rules.\n      return result;\n    } else {\n      // If the builder is empty, it means all individual meets resulted in\n      // either NO_TYPE or NO_OBJECT_TYPE.\n      if (needsNoObject) {\n        // If NO_OBJECT_TYPE was encountered at least once, it's the greatest lower bound.\n        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n      } else {\n        // If only NO_TYPE was encountered (or the union was initially empty),\n        // the meet is NO_TYPE.\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}