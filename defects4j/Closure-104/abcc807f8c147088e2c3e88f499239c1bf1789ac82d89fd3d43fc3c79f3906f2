{
    "generation": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n\n    if (that instanceof UnionType) {\n      UnionType otherUnion = (UnionType) that;\n      // The intersection of two union types (A|B) & (C|D) is (A&C)|(A&D)|(B&C)|(B&D).\n      for (JSType thisAlternate : alternates) {\n        for (JSType otherAlternate : otherUnion.alternates) {\n          JSType intersection = thisAlternate.meet(otherAlternate);\n          // Only add non-empty intersection results to the builder.\n          if (!intersection.isNoType() && !intersection.isNoObjectType()) {\n            builder.addAlternate(intersection);\n          }\n        }\n      }\n    } else {\n      // The intersection of a union type (A|B) and a single type C is (A&C)|(B&C).\n      for (JSType alternate : alternates) {\n        JSType intersection = alternate.meet(that);\n        // Only add non-empty intersection results to the builder.\n        if (!intersection.isNoType() && !intersection.isNoObjectType()) {\n          builder.addAlternate(intersection);\n        }\n      }\n    }\n\n    JSType result = builder.build();\n    // If the builder produced a type, return it.\n    if (result != null) {\n      return result;\n    } \n    // If no specific intersection was found (result is null),\n    // determine if the intersection should be NoObject or NoType.\n    // If both types are objects, their \"empty\" intersection is NoObject.\n    else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } \n    // Otherwise, for any other combination (e.g., primitive, or mixed), it's NoType.\n    else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}