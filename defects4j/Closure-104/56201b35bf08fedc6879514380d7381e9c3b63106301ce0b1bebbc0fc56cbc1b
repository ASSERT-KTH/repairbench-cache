{
    "generation": "  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n\n    // The 'meet' (or greatest common subtype) operation for union types\n    // distributes over the union.\n    // If this = (U1 | U2 | ... | Un) and that = V, then meet(this, that) = (U1 meet V) | (U2 meet V) | ... | (Un meet V).\n    // If this = (U1 | ... | Un) and that = (V1 | ... | Vm), then meet(this, that) = union over i,j (Ui meet Vj).\n\n    if (that instanceof UnionType) {\n      // Case: both 'this' (a UnionType) and 'that' (a UnionType) are involved.\n      UnionType otherUnion = (UnionType) that;\n      for (JSType alternateThis : alternates) { // Iterate over U_i\n        for (JSType alternateThat : otherUnion.alternates) { // Iterate over V_j\n          // Recursively compute the meet of individual alternates.\n          JSType intersection = alternateThis.getGreatestSubtype(alternateThat);\n          if (intersection != null) {\n            // Only add to builder if the intersection is not null.\n            // (Assumes getGreatestSubtype returns null for \"no intersection\" or\n            //  that builder.addAlternate handles NO_TYPE/NO_OBJECT_TYPE appropriately.)\n            builder.addAlternate(intersection);\n          }\n        }\n      }\n    } else {\n      // Case: 'this' is a UnionType, 'that' is a single JSType (not a UnionType).\n      for (JSType alternateThis : alternates) { // Iterate over U_i\n        // Recursively compute the meet of each alternate of 'this' with 'that'.\n        JSType intersection = alternateThis.getGreatestSubtype(that);\n        if (intersection != null) {\n          builder.addAlternate(intersection);\n        }\n      }\n    }\n\n    // After collecting all relevant intersections, build the resulting union type.\n    JSType result = builder.build();\n\n    // The following logic was present in the original code and handles the cases\n    // where the builder might produce a null result (indicating an empty intersection).\n    // It distinguishes between an empty object intersection (NoObject) and a general empty intersection (NoType).\n    if (result != null) {\n      return result;\n    } else if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}