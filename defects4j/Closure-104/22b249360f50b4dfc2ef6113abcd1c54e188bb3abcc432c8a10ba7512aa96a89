{
    "generation": "  /**\n   * Computes the greatest common subtype (meet) of this union type and that type.\n   * Uses the distributive property: meet(A | B, C) = meet(A, C) | meet(B, C)\n   * The result is the union of the meets of each alternate of this union with that type.\n   */\n  JSType meet(JSType that) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n    boolean hasNonNoType = false; // Keep track if we add something other than NO_TYPE/null\n\n    for (JSType alternate : alternates) {\n      // Recursively calculate the greatest common subtype of the alternate and that.\n      JSType gcs = alternate.getGreatestSubtype(that);\n\n      // Add the result to the builder.\n      // UnionTypeBuilder is expected to handle null, NO_TYPE, NO_OBJECT_TYPE, etc.\n      // when building the final union.\n      if (gcs != null && !gcs.isNoType()) {\n          hasNonNoType = true;\n      }\n      builder.addAlternate(gcs);\n    }\n\n    JSType result = builder.build();\n\n    // If the builder returned a concrete type (possibly a union, possibly NO_OBJECT_TYPE),\n    // return it. builder.build() should return null if the resulting union is empty or equivalent to NO_TYPE.\n    if (result != null && !result.isNoType()) {\n        // If the builder result simplifies to NO_OBJECT_TYPE, we return it directly.\n        return result;\n    }\n\n    // If the distributive approach yielded an empty set (result is null or NO_TYPE),\n    // it means no common subtypes were found among the alternates intersections.\n    // Fallback to determine the correct bottom type (NO_TYPE or NO_OBJECT_TYPE).\n    // This logic mirrors the original code's fallback.\n    // If both this union and the other type are object types (contain only objects),\n    // then their meet, even if empty, should be NO_OBJECT_TYPE.\n    // Note: isObject() on a UnionType checks if *all* alternates are objects.\n    // Note: isObject() on other types checks if they are object-like (not primitive, null, void).\n    if (this.isObject() && that.isObject()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else {\n      // Otherwise, the greatest common subtype is the universal bottom type NO_TYPE.\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}