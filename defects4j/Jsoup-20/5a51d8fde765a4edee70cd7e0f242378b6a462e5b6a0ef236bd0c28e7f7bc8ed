{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.UnsupportedCharsetException;\n\n// NOTE: This code assumes the existence of a static final String defaultCharset\n// and a static helper method getCharsetFromContentType(String) in the surrounding class (e.g., DataUtil).\n// For example:\n// static final String defaultCharset = \"UTF-8\";\n// private static String getCharsetFromContentType(String contentType) { /* implementation */ }\n\nclass FixedDataUtil { // Renamed class for clarity, assumes it's part of the original class context\n\n    // Assume these exist in the actual class\n    static final String defaultCharset = \"UTF-8\"; // or StandardCharsets.UTF_8.name()\n    private static String getCharsetFromContentType(String contentType) {\n        // Dummy implementation for compilation, replace with actual jsoup implementation\n        if (contentType == null) return null;\n        String[] params = contentType.split(\";\");\n        for (String param : params) {\n            param = param.trim();\n            if (param.startsWith(\"charset=\")) {\n                return param.substring(\"charset=\".length());\n            }\n        }\n        return null;\n    }\n\n\n    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String finalCharset = charsetName; // charset used for final parse. Default to specified charset.\n\n        // *** Charset determination and initial decode ***\n        if (charsetName == null) { // determine from meta. safe parse first as UTF-8 or specified default\n            finalCharset = defaultCharset; // Assume default for now\n            try {\n                docData = Charset.forName(finalCharset).decode(byteData).toString();\n            } catch (UnsupportedCharsetException e) {\n                // Should not happen as defaultCharset should be supported. Fallback or rethrow?\n                // For now, rethrow or handle as fatal error, as parsing cannot proceed.\n                 throw new RuntimeException(\"Unsupported default charset: \" + finalCharset, e); // Or handle differently\n            }\n\n            // Check for BOM and strip it *before* parsing for meta tags\n            if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF') {\n                docData = docData.substring(1);\n            }\n\n            doc = parser.parseInput(docData, baseUri); // Parse tentatively to find meta tag\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    foundCharset = meta.attr(\"charset\");\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(finalCharset)) {\n                    foundCharset = foundCharset.trim();\n                    // Check if charset is supported before switching\n                    if (Charset.isSupported(foundCharset)) {\n                        finalCharset = foundCharset; // Update the final charset\n                        byteData.rewind(); // Reset buffer for re-decode\n                        docData = Charset.forName(finalCharset).decode(byteData).toString();\n\n                        // Check for BOM again after re-decoding\n                        if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF') {\n                            docData = docData.substring(1);\n                        }\n                        doc = null; // Mark document for re-parse\n                    }\n                    // If foundCharset is not supported, we stick with the defaultCharset parse (doc is already parsed)\n                }\n                // If meta tag found but charset is same as default or invalid, stick with default parse (doc is already parsed)\n            }\n            // If no meta tag found, stick with default parse (doc is already parsed)\n\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            try {\n                 docData = Charset.forName(charsetName).decode(byteData).toString();\n            } catch (UnsupportedCharsetException e) {\n                 // Handle case where specified charset is not supported\n                 // Maybe fallback to default or throw a more specific exception?\n                 // For now, let it propagate up.\n                 throw e;\n            }\n            // Check for BOM and strip it *before* parsing\n            if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF') {\n                docData = docData.substring(1);\n            }\n            finalCharset = charsetName; // Final charset is the specified one\n            // doc is initially null, will be parsed below\n        }\n\n        // *** Final parsing ***\n        if (doc == null) { // If doc is null, we need to parse (because charset was specified, or because we re-decoded)\n                           // docData will contain the correctly decoded (and potentially BOM-stripped) data\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Set the output charset to the one actually used for the final successful parse\n        // If finalCharset was null initially and remained null (e.g., default was used but detection failed somehow?),\n        // ensure we set a valid charset. Using the determined/default seems robust.\n        doc.outputSettings().charset(finalCharset);\n\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}