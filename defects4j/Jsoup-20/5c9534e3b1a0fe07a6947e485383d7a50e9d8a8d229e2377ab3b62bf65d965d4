{
    "generation": "import org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.parser.Parser;\nimport org.jsoup.helper.Validate;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n// NOTE: This code includes the surrounding class and necessary imports/fields\n// only to make the standalone function potentially compilable and understandable.\n// The fix focuses *only* on the parseByteData function logic. Assume necessary methods\n// like getCharsetFromContentType and fields like defaultCharset exist elsewhere.\nclass DataUtilFix {\n    // Assume these exist and are accessible\n    static final String defaultCharset = \"UTF-8\";\n    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null)\n            return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            // Some servers supply invalid names like utf8; use standard\n            if (charset.equalsIgnoreCase(\"utf8\")) charset = \"UTF-8\";\n            try { // ensure it's supported\n                 if (!Charset.isSupported(charset)) return null;\n            } catch (IllegalCharsetNameException e) {\n                return null;\n            }\n            return charset;\n        }\n        return null;\n    }\n\n\n    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        String finalCharsetName = charsetName; // charsetName might be null, indicating detection needed\n\n        if (finalCharsetName == null) { // Determine charset from meta tag.\n            // First, try decoding with the default charset.\n            // We have to always parse the docData to detect the meta charset. Previously, we only parsed if the charset was null.\n            // If the specified charset was wrong, we wouldn't change it. Now we will.\n            finalCharsetName = defaultCharset; // Start with default - will override if meta found\n            try {\n                byteData.mark(); // Mark buffer position in case we need to rewind\n                docData = Charset.forName(finalCharsetName).decode(byteData).toString();\n\n                // Look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\">\n                // or HTML5 <meta charset=\"gb2312\">\n                Document tempDoc = parser.parseInput(docData, baseUri);\n                Element meta = tempDoc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n\n                if (meta != null) {\n                    String foundCharset = null;\n                    if (meta.hasAttr(\"http-equiv\")) {\n                        foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                        // ensure we have a usable charset, e.g. if content=\"text/html\" but no charset listed\n                        if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                             foundCharset = meta.attr(\"charset\");\n                        }\n                    } else if (meta.hasAttr(\"charset\")) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n\n\n                    // Check if a valid charset was found and if it's different from the initial guess (or specified)\n                    if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equalsIgnoreCase(finalCharsetName)) {\n                         // We need to re-decode. The original `charsetName` might have been wrong.\n                        finalCharsetName = foundCharset; // Update to the found charset\n                        byteData.reset(); // Rewind buffer to marked position\n                        docData = Charset.forName(finalCharsetName).decode(byteData).toString(); // Re-decode\n                        doc = null; // discard temporary doc, needs reparsing against new charset\n                    } else if (doc == null) {\n                        // doc == null indicates we are in the charset detection path (charsetName initially null).\n                        // We parsed it once above; assign it to doc here. Correct charset found (or did not need changing).\n                        doc = tempDoc;\n                    }\n                } else if (doc == null) {\n                    // meta tag not found, and we were detecting; use the initially parsed doc.\n                    doc = tempDoc;\n                }\n\n            } catch (Exception e) {\n                // IOException, IllegalCharsetName, UnsupportedCharset -> fallback to default if detection failed\n                byteData.reset(); // Reset buffer if an error occurred during detection attempt\n                docData = Charset.forName(defaultCharset).decode(byteData).toString();\n                finalCharsetName = defaultCharset;\n                doc = null; // needs parsing\n            }\n             // Ensure finalCharsetName is set if it started as null and detection failed badly\n            if (finalCharsetName == null) {\n                finalCharsetName = defaultCharset;\n            }\n\n        } else { // Charset provided by caller (e.g., from HTTP header or user)\n            Validate.notEmpty(finalCharsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(finalCharsetName).decode(byteData).toString();\n            // doc remains null, will be parsed below\n        }\n\n        // BOM Strip: Check for and remove Byte Order Mark (U+FEFF) from the beginning of the decoded string.\n        // Applies whether charset was provided or detected.\n        if (doc == null) { // If we haven't already parsed a usable doc (because meta charset matched initial guess)\n            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n            final String bom = \"\\uFEFF\";\n            if (docData.startsWith(bom)) {\n                // Creates a new string; fine as parsing will consume it.\n                // Don't assign back to docData in case we need original for error reporting? No, parser needs corrected string.\n                docData = docData.substring(1);\n            }\n\n            // Final Parse: Parse the (potentially BOM-stripped) document data.\n            doc = parser.parseInput(docData, baseUri);\n\n            // Set Output Charset: Configure the document's output settings with the determined charset.\n            doc.outputSettings().charset(finalCharsetName);\n        } else {\n             // Doc was already parsed in the detection phase and charset matched.\n             // We should still update the output settings charset to the final determined one.\n             doc.outputSettings().charset(finalCharsetName);\n        }\n        return doc;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}