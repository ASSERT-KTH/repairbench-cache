{
    "generation": "    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null; // Will hold the final parsed Document\n\n        // Variable to hold the effective charset used for parsing and for output settings.\n        String finalCharsetUsed = charsetName;\n\n        // Step 1: Decode byteData to String using the initial/default charset.\n        // Apply BOM stripping immediately after decoding.\n        String initialDecodeCharset = charsetName;\n        if (initialDecodeCharset == null) {\n            initialDecodeCharset = defaultCharset;\n        }\n\n        docData = Charset.forName(initialDecodeCharset).decode(byteData).toString();\n        \n        // --- BOM Stripping ---\n        // If the decoded string starts with a BOM, remove it.\n        if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF') {\n            docData = docData.substring(1);\n        }\n\n        // Step 2: If charsetName was null (auto-detect), try to find charset from meta tag.\n        if (charsetName == null) {\n            // Parse provisionally to find meta charset. This parse uses the BOM-stripped docData.\n            Document provisionalDoc = parser.parseInput(docData, baseUri);\n            Element meta = provisionalDoc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n\n            if (meta != null) {\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                \n                // If a different charset is found in meta, re-decode the byte data with the correct charset.\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(initialDecodeCharset)) {\n                    finalCharsetUsed = foundCharset; // Update the effective charset\n                    byteData.rewind(); // Rewind the byte buffer to read from the beginning again\n                    \n                    docData = Charset.forName(foundCharset).decode(byteData).toString(); // Re-decode\n\n                    // --- BOM Stripping (again, as docData was re-created) ---\n                    if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF') {\n                        docData = docData.substring(1);\n                    }\n                    // Doc needs to be re-parsed, so 'doc' remains null here to trigger the final parse below.\n                } else {\n                    // No different charset found in meta, or meta not present, or found charset is same as initial.\n                    // The provisionalDoc is effectively the final doc.\n                    doc = provisionalDoc; // Set the final doc, so the final parse block is skipped.\n                    finalCharsetUsed = initialDecodeCharset; // The charset used was the initial one.\n                }\n            } else {\n                // No meta tag found, defaultCharset was used for the provisional parse.\n                doc = provisionalDoc; // Set the final doc, so the final parse block is skipped.\n                finalCharsetUsed = initialDecodeCharset; // The charset used was the initial one.\n            }\n        } else { // Charset was specified by content type header (or by user on file load)\n            // Validate that the provided charsetName is not empty.\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            \n            // docData was already decoded with 'charsetName' and BOM-stripped in Step 1.\n            // 'doc' remains null here, which means the next block will perform the final parse.\n            // 'finalCharsetUsed' is already correctly set to 'charsetName'.\n        }\n\n        // Step 3: Perform the final parse if 'doc' is not already set.\n        // This covers cases where a re-decode happened, or if charset was initially specified.\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n        }\n\n        // Step 4: Set the output settings charset on the final document.\n        // 'finalCharsetUsed' should always be non-null at this point, representing the charset used for parsing.\n        if (finalCharsetUsed != null) {\n            doc.outputSettings().charset(finalCharsetUsed);\n        }\n\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}