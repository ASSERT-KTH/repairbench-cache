{
    "generation": "    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData; // String representation of the byteData\n\n        // Step 1: Determine the final docData string based on charsetName (provided or detected)\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8 for initial sniff\n            // 1.1: First decode using defaultCharset (UTF-8) to find meta charset\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n\n            // 1.2: Temporarily parse to find meta charset. This parse might be incorrect if BOM is present,\n            // but it's only used for meta tag detection.\n            Document tempDoc = parser.parseInput(docData, baseUri);\n            Element meta = tempDoc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                    // 1.3: If a different charset is found, re-decode the byteData with the found charset\n                    charsetName = foundCharset; // Update charsetName to the detected one\n                    byteData.rewind(); // Rewind ByteBuffer to read from start again\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                }\n            }\n            // If charsetName is still null here, it means either:\n            //   - No meta charset was found, OR\n            //   - The found meta charset was the same as defaultCharset.\n            // In these cases, docData is already the defaultCharset decoded string, and defaultCharset should be used.\n            if (charsetName == null) {\n                charsetName = defaultCharset;\n            }\n        } else { // charsetName was specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            // 1.4: Decode using the provided charsetName\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n\n        // Step 2: Handle Byte Order Mark (BOM)\n        // There are times where there is a spurious byte-order-mark at the start of the text.\n        // Shouldn't be present in utf-8. If after decoding, there is a BOM, strip it;\n        // otherwise will cause the parser to go straight into head mode\n        final int BOM = 0xFEFF;\n        if (docData.length() > 0 && docData.charAt(0) == BOM) {\n            docData = docData.substring(1);\n        }\n\n        // Step 3: Perform the final parse and set document output settings\n        Document doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName); // Always set charset on output settings\n\n        return doc;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}