{
    "generation": "// Located in: com.fasterxml.jackson.databind.deser.std.StdDeserializer\n// Fixed version ensures that CoercionAction.Fail results in an exception when deserializing\n// an empty string (\"\") to a primitive type if the ACCEPT_EMPTY_STRING_AS_NULL_OBJECT\n// feature is disabled, unless a DeserializationProblemHandler successfully handles it.\n\n    /**\n     * Helper method called: verification of coercion from String is needed.\n     * Various {@link CoercionAction}s are possible, based on configuration.\n     *\n     * @param ctxt Context for accessing configuration, handling\n     * @param action Coercion action configured\n     * @param targetType Logical target type used for coercion\n     * @param inputValue Actual input value to coerce\n     * @param inputDesc Description of input type (like \"empty String\")\n     *\n     * @return Value to return (null or empty value) if coercion is allowed;\n     *    never returns if failure results in an exception\n     *\n     * @throws IOException If coercion fails and is not allowed (based on configuration)\n     *\n     * @since 2.12\n     */\n    protected Object _checkCoercionFail(DeserializationContext ctxt,\n            CoercionAction action, Class<?> targetType, Object inputValue,\n            String inputDesc)\n        throws IOException\n    {\n        switch (action) {\n        case TryConvert:\n            // 28-Sep-2021, tatu: Need to indicate impossibility to coerce; standard\n            //   mechanism is to throw exception (but note that we are in \"check\"\n            //   method, not \"do-convert\"; however, there's no fallback)\n            // So fall through to fail:\n        case Fail:\n            _reportFailedCoercion(ctxt, action, targetType, inputValue, inputDesc);\n            // above method should not return\n            return null; // unreachable\n        case AsNull:\n            // Cannot return `null` for primitive types; need special handling\n            // ... unless `FAIL_ON_NULL_FOR_PRIMITIVES` disabled?\n            if (targetType.isPrimitive()) {\n                 // Behavior changed in 2.9, must respect feature setting; previously called\n                 // _verifyNullForPrimitive(ctxt) which threw exception if feature enabled.\n                 if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                     // apparently target is primitive, does not allow nulls, but feature\n                     // allows passing default value\n                     return getNullValue(ctxt); // should be primitive default value (0, false)\n                 }\n                 // If feature enabled, fall through to failure reporting\n                 _reportFailedNullCoerce(ctxt, true, _coercedTypeDesc(), \"empty String (\\\"\\\") as null\");\n                 return null; // unreachable\n            }\n            // wrapper types, etc are nullable ok\n            return getNullValue(ctxt);\n        case AsEmpty:\n            // May also need to consider if specific target type allows empty:\n            // for now assume generally ok (?)\n            return getEmptyValue(ctxt);\n        }\n        // Unknown CoercionAction? Should not occur\n        // ... but maybe should be reported? For now, fallback to null/empty seems reasonable\n        return getNullValue(ctxt);\n    }\n\n    // NOTE: Depending on the exact version, the following helper method might also need adjustment\n    // or might be part of the fix. Including it for completeness based on later versions\n    // where this logic was extracted. The core fix is ensuring the Fail path reports the mismatch.\n    /**\n     * @since 2.13.1\n     */\n    private void _reportFailedCoercion(DeserializationContext ctxt,\n            CoercionAction action, Class<?> targetType, Object inputValue,\n            String inputDesc) throws IOException\n    {\n        String msg = String.format(\n\"Cannot coerce %s to %s (but could if coercion was enabled using `CoercionConfig`)\",                inputDesc, _coercedTypeDesc());\n        // Allow possibility of custom handler\n        Object result = ctxt.handleWeirdStringValue(targetType, String.valueOf(inputValue), msg);\n        // if ProblemHandler returns non-null (or, for 2.13, NOT_HANDLED), it has handled it, otherwise need to throw\n        // Note: Changed in 2.13 to check for specific NOT_HANDLED marker\n        if (result == DeserializationProblemHandler.NOT_HANDLED) {\n             ctxt.reportInputMismatch(this, msg);\n        }\n        // If handler returned something else, we assume it has been handled, suppress exception\n        // (caller needs to determine what to do with result)\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}