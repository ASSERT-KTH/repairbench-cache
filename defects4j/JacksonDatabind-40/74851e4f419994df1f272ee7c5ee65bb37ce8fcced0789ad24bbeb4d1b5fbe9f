{
    "generation": "    protected final int _parseIntPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.currentTokenId()) {\n            case JsonTokenId.ID_NUMBER_INT:\n                return p.getIntValue();\n            case JsonTokenId.ID_NUMBER_FLOAT: // coercing may work too\n                if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) {\n                    _failDoubleToIntCoercion(p, ctxt, \"int\");\n                }\n                return p.getValueAsInt();\n            case JsonTokenId.ID_STRING:\n                // allow empty Strings if allowed; fallback checks below\n                String text = p.getText().trim();\n\n                // 29-Nov-2016, tatu: Need special handling for empty String unless\n                //    coercion feature is explicitly enabled.\n                if (text.isEmpty()) {\n                    // 14-Mar-2017, tatu: As per [databind#1503] this should actually FAIL for primitives\n                    //    by default, possibly configurable. Most importantly, should not return 0.\n                    if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                        // Throw exception directly, cannot coerce empty string to primitive int\n                        _reportFailedNullCoerce(ctxt, true, \"empty String\", \"Cannot coerce empty String to Null value for primitive type `int`\");\n                    } else {\n                        // More general fail message if feature not enabled\n                        _reportMissingContent(ctxt, \"Cannot coerce empty String ('') to int (but could if enabling `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT`)\");\n                    }\n                    // either way, we are done with this token\n                    return 0; // never gets here\n                }\n                // [databind#109]: allow converting \"null\" String into 'null' integer value?\n                // 12-Jun-2015, tatu: Let's separate handling: separate feature for primitives?\n                // Should we? Could also be handled by `CoercionConfigs`... How about this:\n                // If specific feature enabled, OR coercion happens, use default?\n                if (_hasTextualNull(text)) {\n                    // 11-Jun-2015, tatu: Used to claim \"empty String not allowed\"; but should\n                    // be ok, depending on Features\n                    // 03-Jan-2016, tatu: Let's add explicit check for `FAIL_ON_NULL_FOR_PRIMITIVES`\n                    _verifyNullForPrimitive(ctxt);\n                    return 0; // primitive default\n                }\n                // let's allow Strings to be forced to numbers (if features allow)\n                _verifyStringForScalarCoercion(ctxt, text);\n                try {\n                    int len = text.length();\n                    // avoid parsing exceptions for simple single-character \"-\"\n                    if (len > 9) {\n                        long l = Long.parseLong(text);\n                        if (_intOverflow(l)) {\n                            return _primitiveOverflow(ctxt, text, handledType());\n                        }\n                        return (int) l;\n                    }\n                    if (len == 0) {\n                       // Should have been handled earlier: here, indicates `text.trim()` was empty\n                       // String. Should not happen?\n                       // 14-Mar-2017, tatu: This used to return 0; but as per [databind#1503] seems wrong.\n                       // Let's delegate to method that reports error or allows via config\n                       return _coerceEmptyString(ctxt, _primitive);\n                    }\n                    return NumberInput.parseInt(text);\n                } catch (IllegalArgumentException iae) {\n                    return _handleInvalidNumberFormat(ctxt, p, handledType(), text, iae);\n                }\n            case JsonTokenId.ID_NULL:\n                _verifyNullForPrimitive(ctxt);\n                return 0; // primitive default\n            case JsonTokenId.ID_START_ARRAY: // need to skip, then?\n                if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                    p.nextToken();\n                    final int parsed = _parseIntPrimitive(p, ctxt);\n                    _verifyEndArrayForSingle(p, ctxt);\n                    return parsed;            \n                }\n                break;\n        }\n        // otherwise, error\n        return _handleUnexpectedToken(ctxt, p, JsonToken.VALUE_NUMBER_INT);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}