{
    "generation": "    // Located in NumberDeserializers.PrimitiveOrWrapperDeserializer or NumberDeserializers.IntDeserializer\n    protected final int _deserializeInt(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        switch (p.currentTokenId()) {\n        case JsonTokenId.ID_NUMBER_INT:\n        case JsonTokenId.ID_NUMBER_FLOAT: // coercing may work\n            return p.getIntValue();\n        case JsonTokenId.ID_STRING:\n            String text = p.getText().trim();\n\n            // 16-Nov-2017, tatu: Moved actual handling to `_parseEmptyString`...\n            // Fallback here needs to coordinate, however. Let's see:\n            if (text.isEmpty()) {\n                // 05-May-2020, tatu: Need to call `_checkFromStringCoercion` to see if implicit coercion is ok\n                CoercionAction act = _checkFromStringCoercion(ctxt, text);\n                if (act == CoercionAction.AsNull || act == CoercionAction.AsEmpty) {\n                    // note: `getNullValue()` returns `null` for primitives... so use primitive default\n                    return _emptyValue.intValue(); // Should be 0\n                }\n                // Fail means failure, and for primitives, TryConvert is same as Fail\n                // since empty String cannot be parsed as a number\n                if (act == CoercionAction.Fail || act == CoercionAction.TryConvert) { // FIX: Added || act == CoercionAction.TryConvert\n                    _checkCoercionFail(ctxt, act, _valueClass, text, \"empty String (\\\"\\\")\");\n                    // above call throws exception, we should not get here\n                    return 0; // Default value (unreachable)\n                }\n                // Removed the original fallthrough 'return _emptyValue.intValue();' which caused the bug for TryConvert\n            }\n            // 31-Jul-2020, tatu: Also need to handle \"null\" String coercions:\n            if (_hasTextualNull(text)) {\n                // note: `getNullValue()` returns `null` for primitives... so use primitive default\n                CoercionAction act = _checkNullCoercion(ctxt, _primitive);\n                if (act == CoercionAction.AsNull || act == CoercionAction.AsEmpty) {\n                    return _emptyValue.intValue(); // Should be 0\n                }\n                if (act == CoercionAction.Fail) {\n                    _checkCoercionFail(ctxt, act, _valueClass, text, \"String \\\"null\\\"\");\n                    return 0; // Default value (unreachable)\n                }\n                // Otherwise (TryConvert?), return default\n                return _emptyValue.intValue();\n            }\n             // If not empty or null, must be ok to coerce\n             _verifyStringForScalarCoercion(ctxt, text);\n             try {\n                 // For possible overflow, Check range\n                 long l = Long.parseLong(text);\n                 if (!_isIntRange(l)) {\n                     // 13-Nov-2020, tatu: Need to use `handleInvalidFormatException` for primitive target\n                     Number n = ctxt.handleWeirdStringValue(_valueClass, text,\n                             \"Overflow: numeric value (%s) out of range of int (%d - %d)\",\n                             text, Integer.MIN_VALUE, Integer.MAX_VALUE);\n                     // 18-Nov-2020, tatu: As per [databind#2983], should delegate back for coercion attempt\n                     //                     (except for NaN)\n                     return _nonNullNumber(n).intValue();\n                 }\n                 return (int) l;\n             } catch (IllegalArgumentException iae) {\n                 // 13-Nov-2020, tatu: Need to use `handleInvalidFormatException` for primitive target\n                 return ctxt.handleInvalidFormatException(_valueClass, text,\n                         \"not a valid int value\").intValue();\n             }\n         case JsonTokenId.ID_START_ARRAY:\n             // For primitive, need to return default value on failure\n             // 13-Nov-2020, tatu: Let's use the same `_deserializeFromArray` variant as wrapper\n             return _deserializeFromArray(p, ctxt).intValue();\n         case JsonTokenId.ID_NULL: // should mostly be caught by caller (if wrapping)\n             {\n                 CoercionAction act = _checkNullCoercion(ctxt, _primitive);\n                 if (act == CoercionAction.AsNull || act == CoercionAction.AsEmpty) {\n                     return _emptyValue.intValue(); // Should be 0\n                 }\n                 if (act == CoercionAction.Fail) {\n                     _checkCoercionFail(ctxt, act, _valueClass, null, \"Cannot coerce `null` to `int` value\");\n                     return 0; // unreachable\n                 }\n                 // Otherwise (TryConvert?), return default value\n                 return _emptyValue.intValue();\n             }\n         default:\n             // For primitive, must return default value on failure\n             // 13-Nov-2020, tatu: Let's use the same `handleUnexpectedToken` variant as wrapper\n             return ctxt.handleUnexpectedToken(_valueClass, p).intValue();\n         }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}