{
    "generation": "package com.fasterxml.jackson.databind.deser.std;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Set;\n\nimport com.fasterxml.jackson.core.*;\n\nimport com.fasterxml.jackson.databind.*;\nimport com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\nimport com.fasterxml.jackson.databind.cfg.CoercionAction;\nimport com.fasterxml.jackson.databind.cfg.CoercionInputShape;\nimport com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\nimport com.fasterxml.jackson.databind.type.LogicalType;\nimport com.fasterxml.jackson.databind.util.AccessPattern;\nimport com.fasterxml.jackson.databind.util.ClassUtil;\nimport com.fasterxml.jackson.databind.util.Converter;\n\n// NOTE: Although this class is abstract, its concrete implementations are defined\n// as static inner classes. This is regrettable design choice (would be better to use\n// separate files) but has to do with legacy code structure.\n\n\n/**\n * Container class for deserializers that handle core JDK primitive (and matching wrapper) types,\n * as well as standard related number types like {@link java.math.BigInteger} and\n * {@link java.math.BigDecimal}.\n */\npublic class NumberDeserializers\n{\n    // // // Special handling for floating-point numbers\n\n    /**\n     * Helper method for encapsulating calls to low-level parsing method that requires\n     * passing context. Behavior is specified by {@link DeserializationFeature#ACCEPT_EMPTY_STRING_AS_NULL_OBJECT}\n     * and coercion configs.\n     * This value is returned if empty string is allowed.\n     *\n     * @param ctxt Deserialization context\n     * @param isPrimitive Whether target type is primitive (true) or wrapper (false)\n     *\n     * @return Value to return for empty String input, if allowed; otherwise exception thrown\n     *\n     * @throws JsonMappingException if empty string is not allowed\n     *\n     * @since 2.12 -- mostly to streamline handling between primitive/wrapper types\n     */\n    protected final int _coerceEmptyStringToInt(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException\n    {\n        // 01-Nov-2020, tatu: Need to determine action, handle failure, return default value otherwise\n        CoercionAction act = _findCoercionFromEmptyString(ctxt);\n        // For primitives, `AsNull` and `AsEmpty` are synonymous with \"default value\"\n        // which is 0 for `int`. `Fail` is failure, and `TryConvert` means \"ask deserializer\"\n        // which in this case cannot lead to success.\n        if (act != CoercionAction.AsEmpty && act != CoercionAction.AsNull) {\n            // 25-Nov-2020, tatu: Need to handle `TryConvert` as failure here, explicitly\n            //    (note: `_verifyActionForEmptyStringCoercion()` won't do that)\n            _reportFailedNullCoerce(ctxt, act, \"Integer\", \"empty String (\\\"\\\")\");\n        }\n        return 0;\n    }\n\n    // // // Then primitive/wrapper types\n\n    // @since 2.12\n    private final static class PrimitiveOrWrapperDeserializer<T>\n        extends StdScalarDeserializer<T>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final LogicalType _logicalType;\n        protected final T _nullValue;\n        protected final T _emptyValue; // since 2.12\n\n        /**\n         * Tells whether target type is primitive type (true), or wrapper\n         * type (false). Needed for error reporting purposes.\n         */\n        protected final boolean _primitive;\n\n        public PrimitiveOrWrapperDeserializer(Class<T> vc, LogicalType logicalType,\n                T nvl, T empty) {\n            super(vc);\n            _logicalType = logicalType;\n            _nullValue = nvl;\n            _emptyValue = empty;\n            _primitive = vc.isPrimitive();\n        }\n\n        @Override\n        public AccessPattern getNullAccessPattern() {\n            // 16-Nov-2017, tatu: For primitives we must use default value; probably most\n            //   optimal to see as Dynamic value, different on call basis\n            if (_primitive) {\n                return AccessPattern.DYNAMIC;\n            }\n            // wrappers may be fine (unless custom null value specified?)\n            if (_nullValue == null) {\n                return AccessPattern.ALWAYS_NULL;\n            }\n            return AccessPattern.CONSTANT;\n        }\n\n        @Override\n        public AccessPattern getEmptyAccessPattern() {\n            // As with nulls, primitives should be dynamic, wrappers constant\n            if (_primitive) {\n                return AccessPattern.DYNAMIC;\n            }\n            // wrappers may be fine (unless custom empty value specified?)\n            if (_emptyValue == null) {\n                 // 14-Jul-2020, tatu: Not sure if this should be DYNAMIC or not;\n                 //    but let's default toDYNAMIC for now\n                return AccessPattern.DYNAMIC;\n//                return AccessPattern.ALWAYS_NULL;\n            }\n            return AccessPattern.CONSTANT;\n        }\n\n        @Override // since 2.9\n        public final T getNullValue(DeserializationContext ctxt) throws JsonMappingException {\n            // For primitives, need to use the default value\n            if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                ctxt.reportInputMismatch(this,\n                        \"Cannot map `null` into type %s (set DeserializationConfig.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n                        handledType().toString());\n            }\n            return _nullValue;\n        }\n\n        @Override // since 2.12\n        public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException {\n            return _emptyValue;\n        }\n\n        @Override\n        public LogicalType logicalType() {\n            return _logicalType;\n        }\n\n        // @since 2.12\n        protected void _verifyNullForPrimitive(DeserializationContext ctxt) throws JsonMappingException\n        {\n            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                 ctxt.reportInputMismatch(this,\n \"Cannot map `null` into type %s (set DeserializationConfig.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\",\n handledType().toString());\n            }\n        }\n\n        // @since 2.12\n        protected void _verifyNullForPrimitiveCoercion(DeserializationContext ctxt, String str) throws JsonMappingException\n        {\n            // note: `str` MUST be trimmed already\n            CoercionAction act;\n\n            // Empty String requires specific check:\n            if (str.isEmpty()) {\n                act = _findCoercionFromEmptyString(ctxt);\n                // Must map: Fail -> error; AsNull/AsEmpty -> default value (0); TryConvert -> error\n                // 24-Nov-2020, tatu: Must treat `TryConvert` as fail, since it cannot succeed\n                if (act == CoercionAction.Fail || act == CoercionAction.TryConvert) {\n                    _reportFailedNullCoerce(ctxt, act, logicalType().name(), \"empty String (\\\"\\\")\");\n                }\n                return;\n            }\n\n            // Other non-numeric Strings fail completely so\n            if (str.equals(\"null\")) {\n                act = _findCoercionFromNullString(ctxt);\n                // Must map: Fail -> error; AsNull/AsEmpty -> default value (0); TryConvert -> error\n                if (act == CoercionAction.Fail || act == CoercionAction.TryConvert) {\n                    _reportFailedNullCoerce(ctxt, act, logicalType().name(), \"`null` keyword\");\n                }\n                return;\n            }\n\n            // Otherwise needs to fail regardless of settings\n            ctxt.reportInputMismatch(this,\n\"Cannot coerce String \\\"%s\\\" to %s (but might if coercion using corresponding `CoercionConfig` was enabled)\",\nstr, _coercedTypeDesc());\n        }\n\n        // @since 2.12 -- used for floating-point Wrappers\n        protected T _deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            CoercionAction act = _findCoercionFromEmptyArray(ctxt);\n            boolean unwrap = ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS);\n\n            // 24-Nov-2020, tatu: Note that `TryConvert` not accepted for empty Array\n            if (unwrap || (act != CoercionAction.Fail)) {\n                if (p.nextToken() == JsonToken.END_ARRAY) {\n                    switch (act) {\n                    case AsEmpty:\n                        return getEmptyValue(ctxt);\n                    case AsNull:\n                        return getNullValue(ctxt);\n                    case Fail:\n                    default: // or TryConvert\n                        // If unwrapping, empty array is null; otherwise fail\n                        if (unwrap) {\n                             // TODO: Is it possible to verify whether null is acceptable value?\n                             return getNullValue(ctxt);\n                        }\n                        ctxt.reportInputMismatch(this,\n\"Cannot deserialize instance of %s out of empty Array\", // Show physical type not logical\n                                _coercedTypeDesc());\n                    }\n                } else if (unwrap) {\n                    // If single value array feature enabled, and member is not END_ARRAY, means we have a single element array.\n                    // Consume that element.\n                    // Important: for primitives, this requires String coercion:\n                    final T parsed = _deserializeWrappedValue(p, ctxt);\n                    // But then need to verify that we get END_ARRAY\n                    if (p.nextToken() != JsonToken.END_ARRAY) {\n                        handleMissingEndArrayForSingle(p, ctxt);\n                    }\n                    return parsed;\n                }\n            }\n            // Either regular Fail, or `TryConvert` that ends up failing due to multiple values\n            return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), JsonToken.START_ARRAY, p, null);\n        }\n\n        /**\n         * Main method for deserializing values when the specific token type is not known\n         * (for example, when contained as generic Object).\n         * Will basically dispatch to specific {@code deserializeXxx()} method based on current\n         * token type.\n         *\n         * @since 2.12\n         */\n        protected T _deserializeWrappedValue(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            // May be ok to coerce from string, float\n            switch (p.currentTokenId()) {\n            case JsonToken.ID_STRING:\n                // 28-Oct-2020, tatu: Should not allow coercion from empty string here,\n                //   as that is controlled by `ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` / coercion config.\n                //   Need to determine actual path... This was added in 2.11.1 for [databind#2644];\n                //   removed from 2.12.\n                // 28-Oct-2020, tatu: Reverted, fixed path to use existing empty/blank handling\n                String text = p.getText();\n                // 25-Nov-2020, tatu: Need to trim() before further checks, always\n                text = text.trim();\n                if (text.isEmpty()) {\n                    // May need coercion, get defaults...\n                    CoercionAction act = _checkFromStringCoercion(ctxt, text,\n                            _logicalType, _valueClass);\n                    if (act == CoercionAction.AsNull) {\n                        return getNullValue(ctxt);\n                    }\n                    if (act == CoercionAction.AsEmpty) {\n                        return getEmptyValue(ctxt);\n                    }\n                    // 24-Nov-2020, tatu: Cannot treat `TryConvert` as success here\n                    // (note: `_checkFromStringCoercion()` won't report failure for `TryConvert`)\n                    _reportFailedNullCoerce(ctxt, act, logicalType().name(), \"empty String (\\\"\\\")\");\n                    return null;\n                }\n                if (_hasTextualNull(text)) {\n                    // note: `_checkFromStringCoercion` ensures Feature check or custom settings passed\n                    CoercionAction act = _checkTextualNull(ctxt, text);\n                    if (act == CoercionAction.AsNull) {\n                        return getNullValue(ctxt);\n                    }\n                    if (act == CoercionAction.AsEmpty) {\n                        return getEmptyValue(ctxt);\n                    }\n                    // 24-Nov-2020, tatu: Cannot treat `TryConvert` as success here\n                    _reportFailedNullCoerce(ctxt, act, logicalType().name(), String.format(\"String \\\"%s\\\"\", text));\n                    return null;\n                }\n                // default handling will throw exception if there is issue\n                return _parseString(p, ctxt, text);\n            case JsonToken.ID_NUMBER_INT:\n                return _parseInteger(p, ctxt);\n            case JsonToken.ID_NUMBER_FLOAT:\n                return _parseFloat(p, ctxt);\n            case JsonToken.ID_START_ARRAY:\n                // Let's allow 'unwrap single element arrays' by default,\n                // although ideally maybe make it configurable?\n                return _deserializeFromArray(p, ctxt);\n            case JsonToken.ID_NULL:\n                return getNullValue(ctxt);\n            // lots of things not acceptable...\n            case JsonToken.ID_START_OBJECT: // can we actually map Object to Number?\n                return _deserializeFromObject(p, ctxt);\n            case JsonToken.ID_BINARY: // How about converting from base64 encoded data?\n                // 21-May-2020, tatu: With 2.12, can allow but by default do not:\n                return _deserializeFromOther(p, ctxt, p.currentToken());\n            case JsonToken.ID_END_ARRAY: // This is generally unexpected... means code error?\n            default:\n            }\n            return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n\n        /**\n         * @param text Trimmed text to parse\n         */\n        protected T _parseString(JsonParser p, DeserializationContext ctxt, String text) throws IOException {\n            return (T) ctxt.handleMissingInstantiator(handledType(), // ValueInstantiator?\n                    p, \"Cannot deserialize value of type %s from String \\\"%s\\\": not a valid representation\",\n                    handledType().getName(), text);\n        }\n\n        protected T _parseInteger(JsonParser p, DeserializationContext ctxt) throws IOException {\n             return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n\n        protected T _parseFloat(JsonParser p, DeserializationContext ctxt) throws IOException {\n            return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n\n        // @since 2.12\n        protected T _deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException {\n            return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n\n        // @since 2.12\n        protected T _deserializeFromOther(JsonParser p, DeserializationContext ctxt, JsonToken token) throws IOException {\n            return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}