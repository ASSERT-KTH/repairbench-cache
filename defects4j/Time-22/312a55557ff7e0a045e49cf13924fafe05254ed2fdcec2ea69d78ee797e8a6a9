{
    "generation": "/**\n * Creates a period from the given millisecond duration with the standard period type\n * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n *\n * @param duration  the duration, in milliseconds\n */\nprotected BasePeriod(long duration) {\n    // Always use UTC for a pure duration\u2010to\u2010time conversion\n    Chronology chrono = DateTimeUtils.getChronology(null).withUTC();\n    this.iChronology = chrono;\n    // Store the standard period type (years, months, weeks, days, hours, minutes, seconds, millis)\n    this.iType = DateTimeUtils.getPeriodType(null);\n\n    // Break the duration into hours, minutes, seconds and millis only\n    long hours   = duration / DateTimeConstants.MILLIS_PER_HOUR;\n    long rem     = duration - hours * DateTimeConstants.MILLIS_PER_HOUR;\n    long minutes = rem     / DateTimeConstants.MILLIS_PER_MINUTE;\n    rem          = rem     - minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n    long seconds = rem     / DateTimeConstants.MILLIS_PER_SECOND;\n    int millis   = (int)(rem - seconds * DateTimeConstants.MILLIS_PER_SECOND);\n\n    // Populate an array of the correct size, leaving all date\u2010based fields at zero\n    int[] values = new int[this.iType.size()];\n    values[this.iType.indexOf(DurationFieldType.hours())]   = (int) hours;\n    values[this.iType.indexOf(DurationFieldType.minutes())] = (int) minutes;\n    values[this.iType.indexOf(DurationFieldType.seconds())] = (int) seconds;\n    values[this.iType.indexOf(DurationFieldType.millis())]  =       millis;\n    this.iValues = values;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}