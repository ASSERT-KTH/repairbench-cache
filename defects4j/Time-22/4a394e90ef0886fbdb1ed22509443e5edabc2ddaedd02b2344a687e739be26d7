{
    "generation": "/**\n * Creates a period from the given millisecond duration with the standard period type\n * and ISO rules, ensuring that the calculation is performed with the time-only period type.\n * <p>\n * The calculation uses the hour, minute, second and millisecond fields.\n *\n * @param duration  the duration, in milliseconds\n */\nprotected BasePeriod(long duration) {\n    // perform the standard UTC\u2010based breakdown first\n    this(duration, null, null);\n\n    // bug [3264409] \u2013 treat all date fields as time-only by moving them into hours\n    PeriodType standard = PeriodType.standard();\n    Chronology utc = ISOChronology.getInstanceUTC();\n    int[] values = this.iValues;\n    int y = standard.indexOf(DurationFieldType.years());\n    int mo = standard.indexOf(DurationFieldType.months());\n    int w = standard.indexOf(DurationFieldType.weeks());\n    int d = standard.indexOf(DurationFieldType.days());\n    int h = standard.indexOf(DurationFieldType.hours());\n\n    // compute total milliseconds represented by the date fields\n    long totalMillis =\n          (long) values[y]  * utc.years().getUnitMillis()\n        + (long) values[mo] * utc.months().getUnitMillis()\n        + (long) values[w]  * utc.weeks().getUnitMillis()\n        + (long) values[d]  * utc.days().getUnitMillis();\n\n    // convert those milliseconds into hours and add to the existing hour value\n    values[h] += (int)(totalMillis / DateTimeConstants.MILLIS_PER_HOUR);\n\n    // clear out the date fields\n    values[y] = 0;\n    values[mo] = 0;\n    values[w] = 0;\n    values[d] = 0;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}