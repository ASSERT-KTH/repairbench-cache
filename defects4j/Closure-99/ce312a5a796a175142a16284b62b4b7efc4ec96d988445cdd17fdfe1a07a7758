{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are known to have a non-global \"this\".\n\n      // 1. Check JSDoc annotations (@constructor, @interface, @override, @this)\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() || // Added: check for @interface\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // 2. Check for methods assigned to prototypes, object literals, or classes.\n      if (parent != null) {\n          // Functions assigned to prototype properties (e.g., Foo.prototype.bar = function() {})\n          // Handles GETPROP (a.b) and GETELEM (a['b']).\n          if (parent.getType() == Token.ASSIGN) {\n              if (n == parent.getLastChild() && // function is the RHS\n                  NodeUtil.isPrototypePropertyDeclaration(parent)) {\n                  return false;\n              }\n          } else if (parent.getType() == Token.EXPR_RESULT) {\n              // Handle assignments like (Foo.prototype.bar = function() {})\n              Node exprChild = parent.getFirstChild();\n              if (exprChild.getType() == Token.ASSIGN &&\n                  n == exprChild.getLastChild() && // function is the RHS of assign\n                  NodeUtil.isPrototypePropertyDeclaration(exprChild)) {\n                  return false;\n              }\n          }\n          // Functions defined in object literals (e.g., { bar: function() {} })\n          else if (parent.getType() == Token.OBJECTLIT && n.getParent().isStringKey()) {\n              return false;\n          }\n          // Functions defined in ES6 classes (e.g., class C { bar() {} })\n          else if (NodeUtil.isMethodDeclaration(n)) {\n              return false;\n          }\n      }\n\n      // 3. Heuristic: Limit traversal to functions where 'this' is likely global.\n      // Allow traversal only for function declarations (in SCRIPT or BLOCK)\n      // or functions assigned directly to simple names (var f = function; f = function;).\n      // Avoid traversing functions in other contexts (like callbacks, complex assignments)\n      // where 'this' is often non-global or the context is ambiguous for this check.\n      if (parent != null) {\n        int pType = parent.getType();\n        if (!(pType == Token.BLOCK || // function f() {}\n              pType == Token.SCRIPT || // function f() {} (top level)\n              (pType == Token.NAME && parent.getParent() != null && // var f = function() {}\n               parent.getParent().getType() == Token.VAR) ||\n              (pType == Token.ASSIGN && parent.getFirstChild().isName() && // f = function() {}\n               n == parent.getLastChild()))) {\n            // If the function is not in one of these simple global-likely contexts,\n            // and wasn't explicitly identified as a non-global method above,\n            // default to not traversing to avoid false positives.\n            return false;\n        }\n      } else {\n         // No parent implies the root SCRIPT node itself, not a function. Fall through.\n      }\n    }\n\n    // Allow traversal for non-function nodes, or functions determined to be\n    // potentially in a global context by the checks above.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}