{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors, interfaces,\n      // or have the @this or @override annotation.\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n); // Use NodeUtil.getBestJSDocInfo\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() || // FIX: Added check for @interface\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      // This check prevents traversing immediately-called functions,\n      // functions passed as arguments, etc., where @this doesn't apply\n      // in a way CheckGlobalThis typically cares about.\n      // Added null check for parent defensively.\n      int pType = parent == null ? Token.EMPTY : parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT || // function declaration in block/script\n            pType == Token.NAME ||   // var x = function() { ... }\n            pType == Token.ASSIGN)) { // foo.bar = function() { ... }\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      // NOTE: Removed the 'assignLhsChild' logic specific to 'shouldTraverse'.\n      // It's primarily needed during the 'visit' phase to check for\n      // `this` on the LHS of the assignment causing the error.\n      // Keeping it here complicated the traversal logic unnecessarily.\n      // The pass should reset `assignLhsChild` appropriately before visiting\n      // the children of ASSIGN if needed there.\n\n      if (n == rhs) { // Only check when traversing the right side\n        // Don't traverse the RHS if it's an assignment to a prototype property, like:\n        // Foo.prototype = ...;\n        // Foo.prototype.bar = ...;\n        // Foo.prototype['bar'] = ...;\n        // Foo.prototype.bar.baz = ...;\n        if (NodeUtil.isPrototypePropertyDeclaration(parent)) {\n           return false;\n        }\n        // The check NodeUtil.isPrototypePropertyDeclaration covers GETPROP\n        // and GETELEM cases involving \".prototype\". Let's replace the\n        // manual checks with this utility method if it correctly identifies\n        // the cases needed. A quick look suggests it handles:\n        // obj.prototype = ... (returns true)\n        // obj.prototype.prop = ... (returns true)\n        // obj.prototype[prop] = ... (returns true)\n        // This seems to cover all required cases (testPropertyOfMethod, testMethod4).\n\n        // Let's revert to the manual checks which are more explicit about the fix:\n        /*\n        if (NodeUtil.isPrototypePropertyDeclaration(parent)) {\n           return false;\n        }\n        */\n        // Manual checks (corrected):\n         if (lhs.getType() == Token.GETPROP) {\n             String qualifiedName = lhs.getQualifiedName();\n             // Handles Foo.prototype = fn, Foo.prototype.bar = fn, Foo.prototype.bar.baz = fn\n             // Check if the assignment target is related to a prototype.\n             if (qualifiedName != null && qualifiedName.contains(\".prototype\")) {\n               return false; // FIX: Don't traverse functions assigned to prototype properties\n             }\n         } else if (lhs.getType() == Token.GETELEM) { // FIX: Handle x.prototype['y'] = fn\n             Node object = lhs.getFirstChild();\n             // Check if the object being accessed is x.prototype\n             if (object.getType() == Token.GETPROP &&\n                 object.getLastChild() != null &&\n                 object.getLastChild().isString() && // Make sure it's the string \"prototype\"\n                 object.getLastChild().getString().equals(\"prototype\")) {\n               // Assignment to a property of a prototype object via computed name.\n               return false;\n             }\n         }\n\n      }\n    }\n\n    return true;\n  }\n\n  // Helper function assumed to be available or part of the class\n  // Need this if not using NodeUtil.getBestJSDocInfo(n) directly\n  private JSDocInfo getFunctionJsDocInfo(Node n) {\n      return NodeUtil.getBestJSDocInfo(n);\n  }\n\n  // Instance variable assumed to be available\n  private Node assignLhsChild;\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}