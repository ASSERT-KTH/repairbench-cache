{
    "generation": "  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors, interfaces or have the @this\n      // or @override annotation. These define their own 'this' context.\n      // Use NodeUtil.getBestJSDocInfo which handles functions, assignments, var declarations.\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() || // FIX: Added check for @interface\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they are defined in contexts where 'this'\n      // might be global or needs checking (top level script, block, simple assignments).\n      if (parent != null) {\n          int pType = parent.getType();\n          // Only traverse functions that are declarations or potentially global assignments.\n          if (!(pType == Token.BLOCK || // function foo() { ... } in a block\n                pType == Token.SCRIPT || // function foo() { ... } at top level\n                pType == Token.NAME || // var foo = function() { ... }\n                pType == Token.ASSIGN)) { // foo.bar = function() { ... } (need further check below)\n              // Skip functions in object literals, class methods, IIFEs (parent EXPR_RESULT), etc.\n              // 'this' is usually well-defined or not global in these cases.\n              return false;\n          }\n      }\n      // Note: If parent is null, n must be the SCRIPT node, which isn't a FUNCTION.\n    }\n\n    // Handle assignments: Specifically avoid traversing functions assigned to prototypes.\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == rhs) {\n        // We are traversing the right hand side (RHS) of an assignment.\n        // Check if the LHS indicates assignment to a prototype or its members.\n        // If so, don't traverse the function on the RHS, as 'this' is likely\n        // intended to refer to an instance, not the global object.\n        boolean isPrototypeAssign = false;\n        Node curr = lhs;\n        if (curr.getType() == Token.GETPROP) {\n            // Case: LHS is obj.prop1.prop2...\n            // Check if it ends in \".prototype\" (e.g., Class.prototype = {...})\n            if (curr.getLastChild().getString().equals(\"prototype\")) {\n                isPrototypeAssign = true;\n            } else {\n                // Check if \".prototype.\" exists in the qualified name\n                // (e.g., Class.prototype.method = function() {})\n                String qualifiedName = curr.getQualifiedName();\n                if (qualifiedName != null && qualifiedName.contains(\".prototype.\")) {\n                    isPrototypeAssign = true;\n                }\n            }\n        } else if (curr.getType() == Token.GETELEM) {\n            // Case: LHS is obj['prop'] or obj.prop1['prop2']\n            // FIX: Added check for GETELEM, e.g., Class.prototype['method'] = function() {}\n            Node target = curr.getFirstChild(); // The object part of GETELEM\n            // Check if target is Class.prototype\n            if (target.getType() == Token.GETPROP &&\n                target.getLastChild().getString().equals(\"prototype\")) {\n                isPrototypeAssign = true; // e.g., Class.prototype['method'] = function() {}\n            } else {\n                // Check if target is Class.prototype.Y\n                // e.g., Class.prototype.prop['method'] = function() {}\n                String qualifiedName = target.getQualifiedName();\n                if (qualifiedName != null && qualifiedName.contains(\".prototype.\")) {\n                    isPrototypeAssign = true;\n                }\n            }\n        }\n\n        if (isPrototypeAssign) {\n          // Don't traverse into functions assigned to prototype properties.\n          return false;\n        }\n      } else if (n == lhs) {\n        // Handle the LHS of assignment (potentially for nested assignments like (a=this).foo=...)\n        // Keep original logic for handling 'this' potentially used on LHS.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      }\n    }\n\n    return true; // Traverse otherwise\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}