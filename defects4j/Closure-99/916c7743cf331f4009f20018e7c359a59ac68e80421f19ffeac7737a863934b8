{
    "generation": "import com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.jscomp.NodeTraversal;\n\n// Assuming this function is part of a class that has access to\n// assignLhsChild (a Node field) and getFunctionJsDocInfo(Node n) (a method).\n// The JSDocInfo class is from com.google.javascript.rhino.JSDocInfo.\n\n/**\n * Since this pass reports errors only when a global {@code this} keyword\n * is encountered, there is no reason to traverse non global contexts.\n */\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride() ||\n         jsDoc.isInterface())) { // ADDED: Exclude functions annotated with @interface\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (isPrototypeMethodAssignmentLhs(lhs)) { // REPLACED: calls helper for robust check\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Checks if the given node (lhs of an assignment) represents a property\n * access on a 'prototype' property (e.g., Foo.prototype.bar or Foo['prototype'].bar).\n * This helper should be a private static method within the same class.\n */\nprivate static boolean isPrototypeMethodAssignmentLhs(Node lhs) {\n    Node current = lhs;\n    // Traverse up the property access chain (e.g., for 'a.prototype.b.c', it checks 'c', then 'b', then 'prototype')\n    while (current != null && (current.isGetProp() || current.isGetElem())) {\n        Node propertyNode = current.getLastChild(); // The property name/key node\n\n        if (current.isGetProp()) {\n            // For GETPROP, the property node is a NAME (e.g., 'prototype' in 'Foo.prototype')\n            if (propertyNode.isName() && \"prototype\".equals(propertyNode.getString())) {\n                return true; // Found a '.prototype' in the chain\n            }\n        } else if (current.isGetElem()) {\n            // For GETELEM, the property node can be any expression, but we only care\n            // if it's a string literal 'prototype' (e.g., 'Foo['prototype']')\n            if (propertyNode.isStringLit() && \"prototype\".equals(propertyNode.getString())) {\n                return true; // Found a \"['prototype']\" in the chain\n            }\n        }\n        current = current.getFirstChild(); // Move to the object on which the current property was accessed\n    }\n    return false; // No 'prototype' property found in the chain\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}