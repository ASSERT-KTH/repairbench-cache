{
    "generation": "@Override\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n  // Since this pass reports errors only when a global \"this\" keyword\n  // is encountered, we avoid traversing non\u2010global contexts.\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse constructors, interfaces, or functions with\n    // @this or @override annotations.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n    // Only traverse top\u2010level or simple assignment contexts.\n    int pType = parent.getType();\n    if (pType != Token.BLOCK &&\n        pType != Token.SCRIPT &&\n        pType != Token.NAME &&\n        pType != Token.ASSIGN) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    // If we're on the LHS, always traverse (for nested assignments).\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // If we're on the RHS, skip any function assigned\n      // to a prototype property or its subproperties.\n      Node candidate = lhs;\n      while (candidate != null &&\n             (candidate.getType() == Token.GETPROP ||\n              candidate.getType() == Token.GETELEM)) {\n        if (candidate.getType() == Token.GETPROP &&\n            \"prototype\".equals(candidate.getLastChild().getString())) {\n          return false;\n        }\n        candidate = candidate.getFirstChild();\n      }\n    }\n  }\n\n  return true;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}