{
    "generation": "import com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.jscomp.NodeTraversal;\n\n\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors, interfaces,\n      // or have the @this or @override annotation.\n      // NOTE: getFunctionJsDocInfo is not provided in the snippet,\n      // assuming it exists and works correctly (e.g., checks n or parent if n is NAME).\n      // A common implementation pattern is to check n.getJSDocInfo()\n      // and if null, check parent if parent is NAME, VAR, ASSIGN etc.\n      // For simplicity here, we directly use n, assuming JSDocInfo is attached.\n      // If `getFunctionJsDocInfo` is context-aware (checks parent), that's better.\n      JSDocInfo jsDoc = n.getJSDocInfo();\n      if (parent != null && jsDoc == null && parent.isName()) {\n        // Function declaration: function Foo() {}\n        jsDoc = parent.getJSDocInfo();\n      } else if (parent != null && jsDoc == null && parent.isAssign()) {\n          // Assignment: var foo = function() {}; or foo.bar = function() {};\n          jsDoc = parent.getJSDocInfo();\n      }\n\n\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() || // Added check for @interface\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they are defined in a way that\n      // allows 'this' to refer to an instance (like declarations or assignments).\n      // This excludes IIFEs, callbacks passed to other functions, etc.\n      if (parent != null) {\n          int pType = parent.getType();\n          if (!(pType == Token.BLOCK || // function declaration in block\n                pType == Token.SCRIPT || // function declaration in script\n                pType == Token.NAME ||   // var foo = function() { ... }\n                pType == Token.ASSIGN)) { // foo.bar = function() { ... }\n            return false;\n          }\n      }\n      // Note: The original check `assignLhsChild` logic was removed as it seemed\n      // related to tracking assignments involving `this` on the LHS, which is not\n      // the focus of skipping traversal based on where the *function* is defined.\n    }\n\n    // Check if the node is the RHS of an assignment.\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == rhs) { // Only check when traversing the RHS function expression\n        // Don't traverse the function if it's assigned to a prototype property\n        // (e.g., Foo.prototype.bar = function() { ... })\n        // or Foo.prototype['bar'] = function() { ... }\n        // because 'this' refers to the instance in that case.\n        if (isPrototypePropertyAssignment(lhs)) {\n            return false;\n        }\n      }\n    }\n\n    return true; // Default: traverse\n  }\n\n  /**\n   * Checks if the given node represents the left-hand side of an assignment\n   * to a prototype property, like {@code Foo.prototype.bar} or\n   * {@code Foo.prototype['bar']}. It does not match assignments directly\n   * to the prototype object like {@code Foo.prototype = ...}.\n   *\n   * @param lhs The left-hand side node of an assignment.\n   * @return True if lhs represents a prototype property assignment target.\n   */\n  private boolean isPrototypePropertyAssignment(Node lhs) {\n      Node current = lhs;\n      // Traverse up the chain of GETPROP/GETELEM nodes (e.g., from a.b.c to a.b to a)\n      // Stop if we hit something that's not a property/element access.\n      while (current.isGetProp() || current.isGetElem()) {\n          Node receiver = current.getFirstChild();\n          // Check if the receiver is specifically 'something.prototype'\n          if (receiver.isGetProp()) {\n              Node possiblePrototype = receiver.getLastChild();\n              if (possiblePrototype.isString() && possiblePrototype.getString().equals(\"prototype\")) {\n                 // Found '.prototype.' or '.prototype['...']' in the chain.\n                 // Example: current is a.prototype.b, receiver is a.prototype\n                 // Example: current is a.prototype['b'], receiver is a.prototype\n                 return true;\n              }\n          }\n          // If receiver is not ?.prototype, continue checking up the chain.\n          current = receiver;\n      }\n      // Did not find ?.prototype in the chain leading up to the final property.\n      return false;\n  }\n\n  /**\n   * Utility function to get JSDoc info for a function node.\n   * This is a placeholder based on the original code's usage.\n   * The actual implementation might involve looking at the parent node\n   * for assignments or variable declarations.\n   * Replace with the actual implementation from CheckGlobalThis if available.\n   */\n  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    // Simplified placeholder: Assumes JSDoc is directly on the FUNCTION node.\n    // A real implementation would check parents (NAME, ASSIGN, VAR) too.\n    return n.getJSDocInfo();\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}