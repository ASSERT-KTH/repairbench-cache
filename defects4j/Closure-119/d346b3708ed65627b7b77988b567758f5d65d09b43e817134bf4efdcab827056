{
    "generation": "    @Override\n    public void collect(JSModule module, Scope scope, Node n) {\n      Node parent = n.getParent();\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n        case Token.STRING_KEY:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.isObjectLit()) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) {\n            return;\n          }\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING_KEY:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GETTER_DEF:\n              type = Name.Type.GET;\n              break;\n            case Token.SETTER_DEF:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          name = n.getString(); // Get name first\n          if (name.isEmpty()) {\n              return; // Should not happen for valid NAME, but be safe.\n          }\n          // Determine if it's a set based on parent context\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                // If n is RHS (e.g. x = n), it's a get, isSet remains false.\n                break;\n              case Token.GETPROP:\n                 // If n is the obj part of a GETPROP, it's a 'get'. isSet remains false.\n                 // If n is the prop part (a string), it's not a variable ref.\n                if (parent.getFirstChild() != n) {\n                    return; // e.g. obj['nameStringNode']\n                }\n                 // If n is the object part e.g. 'obj' in obj.prop, it's a get.\n                break; // isSet remains false\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                // Function declaration name is a set.\n                if (parent.getFirstChild() == n &&\n                    gramps != null &&\n                    !NodeUtil.isFunctionExpression(parent)) {\n                  isSet = true;\n                  type = Name.Type.FUNCTION;\n                } else if (NodeUtil.isFunctionExpression(parent)) {\n                  // Function expression names are local and shouldn't be checked globally.\n                  return;\n                }\n                // Parameter names are handled by scope analysis. Let isGlobalNameReference check.\n                // Other cases (e.g., name used inside function) are gets.\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n                // Otherwise, assume it's a get. isSet remains false.\n            }\n          }\n          break; // End of NAME case\n\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n\n          // If this GETPROP is part of a longer qualified name, ignore it.\n          // e.g. in a.b.c, we process 'a.b.c', not 'a.b'.\n          if (parent != null && parent.isGetProp()) {\n             return;\n          }\n\n          name = n.getQualifiedName(); // e.g., \"e.name\" or \"a.b.c\"\n          if (name == null) {\n            return;\n          }\n\n          // Check if the base name is global. This is the fix.\n          Node root = n;\n          while (root.isGetProp()) {\n            root = root.getFirstChild();\n          }\n          // If the root is a simple name and it's declared locally, then this\n          // qualified name access does not refer to a global name.\n          if (root.isName() && !isGlobalNameReference(root.getString(), scope)) {\n             return; // Base name ('e' in 'e.name') is local, so exit.\n          }\n          // Otherwise (root is not NAME, or root NAME is global), proceed.\n\n          // Determine if the GETPROP is being set. Reset defaults.\n          isSet = false;\n          type = Name.Type.OTHER;\n          isPropAssign = false;\n\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          // 'name' remains the qualified name (e.g., \"a.b.c\")\n          break; // End of GETPROP case\n\n        default:\n          // Ignore other node types\n          return;\n      }\n\n      // If name wasn't determined (e.g. complex objlit key), exit.\n      if (name == null) {\n          return;\n      }\n\n      // We are only interested in potentially global names.\n      // The check for local base names in GETPROP case handles qualified names correctly now.\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      // If we reach here, 'name' is considered a global reference.\n      // Report sets/gets based on 'isSet'.\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(module, scope, n, parent, name);\n        }\n      } else {\n        // It's a get of a global name.\n        handleGet(module, scope, n, parent, name);\n      }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}