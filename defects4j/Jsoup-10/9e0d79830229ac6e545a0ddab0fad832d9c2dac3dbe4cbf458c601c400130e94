{
    "generation": "/**\n * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n * <code>&lt;img src></code>).\n * <p/>\n * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n * <p/>\n * If the attribute value is already absolute (i.e. it starts with a protocol, like\n * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n * absolute using that.\n * <p/>\n * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n *\n * @param attributeKey The attribute key\n * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n * could not be made successfully into a URL.\n * @see #attr\n * @see java.net.URL#URL(java.net.URL, String)\n */\npublic String absUrl(String attributeKey) {\n    Validate.notEmpty(attributeKey);\n\n    String relUrl = attr(attributeKey);\n    if (!hasAttr(attributeKey)) {\n        return \"\"; // nothing to make absolute with\n    } else {\n        URL base;\n        try {\n            base = new URL(baseUri);\n        } catch (MalformedURLException e) {\n            // the base is unsuitable, but the attribute may be abs on its own, so try that\n            try {\n                URL abs = new URL(relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException ex) {\n                return \"\";\n            }\n        }\n\n        try {\n            // Manually handle the construction of the absolute URL\n            String basePath = base.getProtocol() + \"://\" + base.getHost();\n            if (base.getPort() != -1) {\n                basePath += \":\" + base.getPort();\n            }\n            basePath += base.getPath();\n\n            if (relUrl.startsWith(\"/\")) {\n                // Absolute path\n                return basePath + relUrl;\n            } else if (relUrl.startsWith(\"?\")) {\n                // Relative path with query parameters\n                return basePath + relUrl;\n            } else {\n                // Relative path\n                String[] baseSegments = basePath.split(\"/\");\n                String[] relSegments = relUrl.split(\"/\");\n                List<String> pathSegments = new ArrayList<>();\n\n                // Add all base segments except the last one\n                for (int i = 0; i < baseSegments.length - 1; i++) {\n                    pathSegments.add(baseSegments[i]);\n                }\n\n                // Add relative segments\n                for (String segment : relSegments) {\n                    if (segment.equals(\".\") || segment.equals(\"\")) {\n                        continue;\n                    } else if (segment.equals(\"..\")) {\n                        if (!pathSegments.isEmpty()) {\n                            pathSegments.remove(pathSegments.size() - 1);\n                        }\n                    } else {\n                        pathSegments.add(segment);\n                    }\n                }\n\n                StringBuilder path = new StringBuilder();\n                for (String segment : pathSegments) {\n                    path.append(\"/\").append(segment);\n                }\n\n                // Append query parameters if any\n                int queryIndex = relUrl.indexOf('?');\n                if (queryIndex != -1) {\n                    path.append(relUrl.substring(queryIndex));\n                }\n\n                return base.getProtocol() + \"://\" + base.getHost() + (base.getPort() != -1 ? \":\" + base.getPort() : \"\") + path.toString();\n            }\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}