{
    "generation": "import java.net.MalformedURLException;\nimport java.net.URL;\nimport org.jsoup.helper.Validate;\n\n// Assuming this code is part of a class like Element which has access to baseUri and attr(), hasAttr() methods.\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        }\n\n        String relUrl = attr(attributeKey).trim(); // Trim whitespace which can lead to MalformedURLs\n\n        // First check if the attribute value is already an absolute URL. If so, return that.\n        try {\n            // Use the base URI to resolve the relative URL against, if needed.\n            // Need a base URL to resolve accurately, but we can test if relUrl is absolute first.\n            URL abs = new URL(relUrl);\n            // Check if it has a protocol - indicates absolute\n            if (abs.getProtocol() != null && !abs.getProtocol().isEmpty()) {\n                return abs.toExternalForm();\n            }\n        } catch (MalformedURLException e) {\n            // If it's not a valid absolute URL, fall through to resolve against base URI\n            // This also catches cases like protocol-relative URLs \"//example.com\" which are handled below by URL(base, rel).\n        }\n\n        // Must be a relative URL; resolve against base URI.\n        URL base;\n        try {\n            // baseUri might be null or empty string if not set. URL constructor might handle this, but better be safe.\n            if (baseUri == null || baseUri.isEmpty()) {\n                 return \"\"; // Cannot resolve relative if no base URI\n            }\n            base = new URL(baseUri);\n        } catch (MalformedURLException e) {\n            // base URI is invalid, cannot resolve\n            return \"\";\n        }\n\n        // Manually handle the case where the relative URL starts with \"?\".\n        // The standard URL(base, rel) constructor incorrectly drops the path from the base URL in this case.\n        if (relUrl.length() > 0 && relUrl.charAt(0) == '?') {\n            try {\n                // Construct the URL string manually by taking the base URL up to the query part and appending the new query.\n                String baseString = base.toExternalForm();\n                int queryIndex = baseString.indexOf('?');\n                String baseUrlWithoutQuery;\n                if (queryIndex != -1) {\n                    baseUrlWithoutQuery = baseString.substring(0, queryIndex);\n                } else {\n                    baseUrlWithoutQuery = baseString;\n                }\n                URL abs = new URL(baseUrlWithoutQuery + relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                // Should not happen if base was valid and relUrl is just \"?...\", but return \"\" if it does.\n                 return \"\";\n            }\n        }\n\n        // Standard resolution using java.net.URL constructor for all other relative URLs.\n        try {\n            URL abs = new URL(base, relUrl);\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            // Resolution failed (e.g., invalid relUrl like \"##\" relative to base).\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}