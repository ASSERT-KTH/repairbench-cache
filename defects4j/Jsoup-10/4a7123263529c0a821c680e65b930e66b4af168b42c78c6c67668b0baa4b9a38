{
    "generation": "    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        }\n\n        String relUrl = attr(attributeKey);\n        URL base;\n        try {\n            try {\n                base = new URL(baseUri);\n            } catch (MalformedURLException e) {\n                // the base is unsuitable, but the attribute may be abs on its own, so try that\n                URL abs = new URL(relUrl); // If this fails, outer catch returns \"\"\n                return abs.toExternalForm();\n            }\n            // relatively resolve relUrl against base\n            try {\n                // Special handling for query only refs (e.g. \"?foo=bar\") leveraging base URI path.\n                // A plain URL#resolve(base, \"?foo=bar\") drops the path, making it \"http://jsoup.org?foo=bar\". Handling manually.\n                if (relUrl.startsWith(\"?\")) {\n                    String baseStr = baseUri; // Use the original base string for path info\n                    // Find the start of the query or fragment, and chop it off\n                    int qPos = baseStr.indexOf('?');\n                    if (qPos > 0)\n                        baseStr = baseStr.substring(0, qPos);\n                    // Also handle fragments in the base URI - they should be removed when resolving with a query\n                    int fPos = baseStr.indexOf('#');\n                     if (fPos > 0)\n                        baseStr = baseStr.substring(0, fPos);\n                    // baseStr now contains protocol, host, path etc, but not query or fragment\n\n                    // Validate and normalize the manually constructed URL\n                    // Need to use URL constructor with String argument to properly handle the combined path and query\n                    URL abs = new URL(baseStr + relUrl);\n                    return abs.toExternalForm();\n                }\n                 // Let java.net.URL handle other resolution scenarios.\n                URL abs = new URL(base, relUrl);\n                return abs.toExternalForm();\n            } catch (MalformedURLException e) {\n                return \"\"; // Resolution failed, maybe malformed relUrl\n            }\n        } catch (MalformedURLException e) {\n            // Outer catch: handles if relUrl is invalid when base is invalid\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}