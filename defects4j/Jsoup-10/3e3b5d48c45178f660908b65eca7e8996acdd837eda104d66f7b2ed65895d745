{
    "generation": "import org.jsoup.helper.Validate; // Assuming Validate is in this package\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\n// Assume this method is part of a class that has access to 'baseUri' field\n// and 'attr(String)', 'hasAttr(String)' methods.\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n     * <code>&lt;img src></code>).\n     * <p/>\n     * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n     * <p/>\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n     * absolute using that.\n     * <p/>\n     * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n     * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n\n        String relUrl = attr(attributeKey);\n        if (!hasAttr(attributeKey)) {\n            return \"\"; // nothing to make absolute with\n        }\n\n        URL base;\n        try {\n            // Attempt to parse the base URI.\n            base = new URL(baseUri);\n        } catch (MalformedURLException e) {\n            // Base URI is unsuitable. Try to parse the relative URL as an absolute URL.\n            try {\n                URL abs = new URL(relUrl);\n                // If relUrl is potentially absolute and parses, return it.\n                // Need a check here to ensure it's truly absolute, otherwise return \"\"\n                // A simple check is if it has a protocol component.\n                if (abs.getProtocol() != null && !abs.getProtocol().isEmpty()) {\n                    return abs.toExternalForm();\n                } else {\n                    return \"\"; // Parsed, but wasn't absolute (e.g., just \"path/file\")\n                }\n            } catch (MalformedURLException e2) {\n                // Both baseUri and relUrl (as absolute) are invalid or could not be parsed.\n                return \"\";\n            }\n        }\n\n        // Base URI is valid. Now attempt to resolve the relative URL against it.\n        try {\n            URL abs;\n            // Special handling for relative URLs starting with \"?\".\n            // Java's URL constructor might incorrectly resolve this against the base path's directory\n            // instead of the full path. E.g., resolving \"?query\" against \"http://host/path/file\"\n            // should yield \"http://host/path/file?query\", not \"http://host/path/?query\".\n            if (relUrl.startsWith(\"?\")) {\n                String baseExternal = base.toExternalForm();\n                // Find the first occurrence of '?' or '#' in the base URL's external form.\n                int qPos = baseExternal.indexOf('?');\n                int fPos = baseExternal.indexOf('#');\n                int endPathPos = baseExternal.length(); // Default to the end of the string if no query/fragment\n\n                // Use the index of the first query or fragment marker\n                if (qPos != -1)\n                    endPathPos = qPos;\n                if (fPos != -1 && fPos < endPathPos) // if fragment exists and is before the query or there's no query\n                    endPathPos = fPos;\n\n                // Construct the URL string using the base path up to the query/fragment, plus the new relative query.\n                String basePath = baseExternal.substring(0, endPathPos);\n                abs = new URL(basePath + relUrl); // Create new URL by appending query to base path\n            } else {\n                // Standard resolution using the URL(base, spec) constructor.\n                abs = new URL(base, relUrl);\n            }\n            return abs.toExternalForm();\n        } catch (MalformedURLException e) {\n            // Resolution failed (e.g., the combined URL is invalid).\n            return \"\";\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}