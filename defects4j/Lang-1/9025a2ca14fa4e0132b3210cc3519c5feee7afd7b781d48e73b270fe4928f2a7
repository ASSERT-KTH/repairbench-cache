{
    "generation": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport org.apache.commons.lang3.StringUtils; // Assuming this import is available\n\n// Added helper methods assumed by the original code for context/compilation\nclass NumberUtils {\n    // Assume these exist and function correctly based on typical implementations\n    private static Integer createInteger(String str) { return Integer.decode(str); }\n    private static Long createLong(String str) { return Long.decode(str); }\n    private static BigInteger createBigInteger(String str) {\n        int index = 0;\n        int radix = 10;\n        boolean negative = false;\n        if (str.startsWith(\"-\")) {\n            negative = true;\n            index++;\n        }\n        if (str.startsWith(\"0x\", index) || str.startsWith(\"0X\", index)) {\n            radix = 16;\n            index += 2;\n        } else if (str.startsWith(\"#\", index)) {\n            radix = 16;\n            index++;\n        } else if (str.startsWith(\"0\", index) && str.length() > index + 1) {\n            // Check for octal if starts with '0' and has more digits\n            // Ensure the string contains only octal digits? Decode handles this.\n            // Let's assume createBigInteger handles octal string correctly if needed.\n            // A robust impl would check octal digits here or use a parser supporting octal.\n             radix = 8;\n             index++;\n        }\n        // If index > 0, we stripped sign or base prefix. Use the rest.\n        String valStr = str.substring(index);\n        if (valStr.isEmpty()) {\n             throw new NumberFormatException(\"Cannot parse empty string after prefix: \" + str);\n        }\n        BigInteger val = new BigInteger(valStr, radix);\n        return negative ? val.negate() : val;\n    }\n    private static Float createFloat(String str) { return Float.valueOf(str); }\n    private static Double createDouble(String str) { return Double.valueOf(str); }\n    private static BigDecimal createBigDecimal(String str) { return new BigDecimal(str); }\n    private static boolean isDigits(String str) { return StringUtils.isNumeric(str); }\n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        // An empty string is not considered all zeros based on context (e.g., \"0.F\")\n        return str.length() > 0;\n    }\n    // Static method added from NumberUtils class for the fix\n    public static Float createFloat(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    // Static method added from NumberUtils class for the fix\n    public static Double createDouble(final String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n\n    /**\n     * <p>Turns a string value into a java.lang.Number.</p>\n     *\n     * <p>If the string starts with {@code 0x} or {@code -0x} (lower or upper case) or {@code #} or {@code -#}, it\n     * will be interpreted as a hexadecimal Integer, Long, or BigInteger based on the magnitude of the value.</p>\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\n     * <code>'f','F','d','D','l','L'</code>.  If it is found, it starts\n     * trying to create successively larger types from the type specified\n     * until one is found that can represent the value.</p>\n     *\n     * <p>If a type specifier is not found, it will check for a decimal point\n     * and then try successively larger types from <code>Integer</code> to\n     * <code>BigInteger</code> and from <code>Float</code> to\n     * <code>BigDecimal</code>.</p>\n     *\n     * <p>\n     * Integral values with a leading {@code 0} will be interpreted as octal; the returned number will\n     * be Integer, Long or BigInteger as appropriate (handled by underlying parser like decode or createBigInteger).\n     * </p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * <p>This method does not trim the input string, i.e., strings with leading\n     * or trailing spaces will generate NumberFormatExceptions.</p>\n     *\n     * @param str  String containing a number, may be null\n     * @return Number created from the string (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Number createNumber(final String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }\n        // Need to deal with all possible hex prefixes here\n        final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n        int pfxLen = 0;\n        for(final String pfx : hex_prefixes) {\n            if (str.startsWith(pfx)) {\n                pfxLen = pfx.length(); // Use the length of the matched prefix\n                break;\n            }\n        }\n\n        // *** BEGIN FIX for Hex Numbers ***\n        if (pfxLen > 0) { // we have a hex number\n            final boolean negative = str.startsWith(\"-\");\n            // Get the substring representing hex digits (after prefix)\n            String hexDigitsStr = str.substring(pfxLen);\n\n            // Check if hexDigitsStr is empty (e.g., input \"0x\")\n            if (hexDigitsStr.isEmpty()) {\n                 throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n            }\n\n            try {\n                // Use BigInteger to parse the hex digits\n                BigInteger val = new BigInteger(hexDigitsStr, 16);\n                if (negative) {\n                    val = val.negate();\n                }\n                // Check if the value fits into Integer range\n                if (val.compareTo(BigInteger.valueOf(Integer.MIN_VALUE)) >= 0 && val.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) <= 0) {\n                    return Integer.valueOf(val.intValue());\n                }\n                // Check if the value fits into Long range\n                if (val.compareTo(BigInteger.valueOf(Long.MIN_VALUE)) >= 0 && val.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\n                    return Long.valueOf(val.longValue());\n                }\n                // Otherwise, return as BigInteger\n                return val;\n            } catch (final NumberFormatException e) {\n                // Rethrow specific exception if BigInteger parsing fails (e.g., invalid hex chars like 'G')\n                 throw new NumberFormatException(\"\\\"\" + str + \"\\\" is not a valid number.\");\n            }\n        }\n        // *** END FIX for Hex Numbers ***\n\n\n        // Code for non-hex numbers starts here (includes minor corrections from review)\n        final char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        final int decPos = str.indexOf('.');\n        // Correctly find exponent position, handling 'e' or 'E' but not both\n        int expPos = str.indexOf('e');\n        if (expPos == -1) {\n            expPos = str.indexOf('E');\n        }\n        // Check if exponent character is the last character, which is invalid\n        if (expPos == str.length() - 1) {\n             throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n\n        int numDecimals = 0; // Check required precision (LANG-693)\n        if (decPos > -1) { // there is a decimal point\n            if (expPos > -1) { // there is an exponent\n                if (expPos < decPos) { // exponent cannot appear before decimal point\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else { // No exponent\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n            numDecimals = dec.length(); // gets number of digits past the decimal\n        } else { // No decimal point\n            if (expPos > -1) {\n                // If no decimal point, exponent cannot be the first character\n                if (expPos == 0) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                mant = str.substring(0, expPos);\n            } else { // No decimal, no exponent\n                mant = str; // The whole string is the mantissa (integer)\n            }\n            dec = null; // No decimal part\n        }\n\n        if (!Character.isDigit(lastChar) && lastChar != '.') { // Check for type suffix\n            // Extract exponent string part if exponent exists and is not followed solely by the suffix\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1); // Exclude suffix from exponent part\n            } else {\n                exp = null; // No exponent part, or exponent was just before suffix\n            }\n            //Requesting a specific type..\n            final String numeric = str.substring(0, str.length() - 1); // String without the suffix\n            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); // Use mantissa/exponent derived from structure\n\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    // Check if the string `numeric` (without L/l suffix) represents a valid integer.\n                    // It should not contain '.', 'e', 'E'.\n                    if (dec == null && exp == null && // Ensure no decimal/exponent was found in the original string structure\n                         // Additionally check the numeric part itself for safety (e.g. \"1.L\" should fail)\n                         numeric.indexOf('.') == -1 && numeric.indexOf('e') == -1 && numeric.indexOf('E') == -1) {\n\n                        // Check if it contains only digits, possibly with a leading '-'\n                        String numberToCheck = numeric;\n                        boolean negativeFirst = numeric.startsWith(\"-\");\n                        if (negativeFirst) {\n                            numberToCheck = numeric.substring(1);\n                        }\n                        // Ensure it's not empty after removing sign (e.g. \"-L\") and contains only digits.\n                        if (!numberToCheck.isEmpty() && isDigits(numberToCheck)) {\n                            try {\n                                // Use createLong on the original numeric string (with sign if present)\n                                return createLong(numeric);\n                            } catch (final NumberFormatException nfe) { // NOPMD\n                                // Fallback to BigInteger if Long fails (e.g., too large).\n                                // Assumes createBigInteger handles decimal/octal correctly based on prefix.\n                                return createBigInteger(numeric);\n                            }\n                        }\n                    }\n                    // If format conditions are not met, it's an invalid number.\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n                case 'f' :\n                case 'F' :\n                    try {\n                        final Float f = NumberUtils.createFloat(numeric); // Use NumberUtils static method\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            // Check if the float value represents the original number accurately enough.\n                            // The original code didn't have further checks here.\n                            return f;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Ignore NFE and fall through to try Double/BigDecimal\n                    }\n                    //$FALL-THROUGH$\n                case 'd' :\n                case 'D' :\n                    try {\n                        final Double d = NumberUtils.createDouble(numeric); // Use NumberUtils static method\n                        // Corrected check: use d.doubleValue() instead of d.floatValue()\n                        if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (final NumberFormatException nfe) { // NOPMD\n                        // Ignore NFE and fall through to try BigDecimal\n                    }\n                    //$FALL-THROUGH$\n                    // Try BigDecimal as a last resort for f/F/d/D suffixes\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (final NumberFormatException e) { // NOPMD\n                        // If BigDecimal also fails, then the input is truly invalid.\n                        // Fall through to default case which throws NFE.\n                    }\n                    //$FALL-THROUGH$\n                default :\n                    // Invalid suffix or BigDecimal parsing failed after fall-through\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        }\n\n        // No type suffix, handle as Integer/Long/BigInteger or Float/Double/BigDecimal\n        // Extract exponent string part if present (runs to the end of the string now)\n        if (expPos > -1 && expPos < str.length() - 1) {\n            exp = str.substring(expPos + 1);\n        } else {\n             // If expPos == -1, exp remains null. If expPos invalid, already threw exception.\n             exp = null;\n        }\n\n        if (dec == null && exp == null) { // No decimal point and no exponent: Integer types\n             // Potential octal handled by createInteger/createLong/createBigInteger\n            try {\n                return createInteger(str); // Handles decimal, octal (if starts with 0)\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(str); // Handles decimal, octal\n            } catch (final NumberFormatException nfe) { // NOPMD\n                // ignore the bad number\n            }\n            // Finally, try BigInteger. Need to ensure createBigInteger handles octal correctly if needed.\n             return createBigInteger(str); // Handles decimal, should handle octal\n\n        }\n\n        // Has decimal point or exponent: Floating point types\n        final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); // Use mant/exp derived from structure\n        // Try Float/Double based on original heuristic (LANG-693)\n        try {\n            if (numDecimals <= 7) { // If number has 7 or fewer digits past the decimal point then make it a float\n                final Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n             if (numDecimals <= 16) { // If number has between 8 and 16 digits past the decimal point then make it a double\n                final Double d = createDouble(str);\n                 // Corrected check: use d.doubleValue()\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            }\n        } catch (final NumberFormatException nfe) { // NOPMD\n            // ignore the bad number\n        }\n\n        // Final fallback for floating point numbers is BigDecimal\n        return createBigDecimal(str);\n    }\n}\n",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}