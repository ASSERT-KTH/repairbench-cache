{
    "generation": "    @Override\n    public JsonSerializer<?> createContextual(SerializerProvider serializers,\n            BeanProperty property) throws JsonMappingException\n    {\n        // find any @JsonFormat on the property\n        JsonFormat.Value format = null;\n        if (property != null) {\n            format = serializers.getAnnotationIntrospector()\n                    .findFormat((Annotated) property.getMember());\n        }\n        // extract shape and flags\n        JsonFormat.Shape shape = (format == null) ? JsonFormat.Shape.ANY : format.getShape();\n        boolean hasPattern = (format != null && format.hasPattern());\n        boolean hasLocale  = (format != null && format.hasLocale());\n        boolean hasTimezone = (format != null && format.hasTimeZone());\n\n        // explicit numeric shape always means timestamp\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n        // if \"ANY\", we may still force string if there is any pattern/locale/tz override\n        if (shape == JsonFormat.Shape.ANY) {\n            if (hasPattern || hasLocale || hasTimezone) {\n                shape = JsonFormat.Shape.STRING;\n            } else {\n                // fall back to global WRITE_DATES_AS_TIMESTAMPS setting\n                shape = serializers.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                        ? JsonFormat.Shape.NUMBER_INT\n                        : JsonFormat.Shape.STRING;\n            }\n        }\n        // second numeric check after ANY\u2192NUMBER_INT\n        if (shape.isNumeric()) {\n            return withFormat(Boolean.TRUE, null);\n        }\n        // at this point we're doing STRING\n        // 1) explicit pattern\n        if (hasPattern) {\n            String pattern = format.getPattern();\n            Locale loc = hasLocale ? format.getLocale() : serializers.getLocale();\n            TimeZone tz = hasTimezone ? format.getTimeZone() : serializers.getTimeZone();\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n        // 2) no pattern but locale or timezone override: use ISO8601 pattern with those settings\n        if (hasLocale || hasTimezone) {\n            String pattern = StdDateFormat.DATE_FORMAT_STR_ISO8601;\n            Locale loc = hasLocale ? format.getLocale() : serializers.getLocale();\n            TimeZone tz = hasTimezone ? format.getTimeZone() : serializers.getTimeZone();\n            SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n            df.setTimeZone(tz);\n            return withFormat(Boolean.FALSE, df);\n        }\n        // 3) plain string fallback (no annotation, or empty @JsonFormat): use default provider format\n        return withFormat(Boolean.FALSE, null);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}