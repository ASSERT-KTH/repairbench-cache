{
    "generation": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        // The 'count' variable accumulates the unidimensional index represented by\n        // the indices found so far for higher dimensions.\n        int count = 0; \n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            \n            // This loop calculates the count for the current dimension (idx)\n            // such that (count + idx * offset) does not exceed the original index.\n            // 'idx' will be the largest integer such that (count + idx * offset) <= original index.\n            // The original logic with `while (count <= index)` and then `count -= offset`\n            // achieves this correctly by overshooting and then correcting.\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            // After the loop, 'count' is (previous_count_value + (idx_candidate * offset))\n            // and 'idx' is (idx_candidate).\n            // (previous_count_value + ((idx_candidate - 1) * offset)) <= index\n            // (previous_count_value + (idx_candidate * offset)) > index\n            \n            --idx; // Decrement 'idx' to get the actual count for this dimension.\n            count -= offset; // 'count' is updated to (previous_count_value + (actual_idx * offset)).\n                             // This 'count' now represents the portion of the unidimensional index\n                             // covered by indices[0] through indices[i].\n            indices[i] = idx;\n        }\n\n        // The remaining part of the unidimensional index (index - count)\n        // directly corresponds to the count for the last dimension, as its effective offset is 1.\n        indices[last] = index - count;\n\n        return indices;\n    }",
    "exact_match": true,
    "ast_match": true,
    "compile": true,
    "test": true
}