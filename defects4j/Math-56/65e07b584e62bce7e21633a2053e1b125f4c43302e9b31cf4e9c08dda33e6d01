{
    "generation": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        // The original code tried to compute the multidimensional indices\n        // by iteratively adding offsets and then backing off.\n        // This logic was flawed, particularly in how the 'count' variable\n        // (which should represent the remaining unidimensional index)\n        // was updated and reset.\n\n        // The correct approach is to iteratively divide the unidimensional index\n        // by the offset of the current dimension to find its component,\n        // and then update the index to its remainder for the next (lower) dimension.\n        // The uniCounterOffset array is defined such that uniCounterOffset[i]\n        // is the product of dimensions from i+1 to dimension-1.\n\n        // Use a working copy of the index, as it will be modified (reduced).\n        int currentUnidimensionalIndex = index;\n\n        // Iterate through all dimensions except the last one.\n        // The last dimension's count is simply the final remainder.\n        for (int i = 0; i < last; i++) {\n            final int offset = uniCounterOffset[i];\n            indices[i] = currentUnidimensionalIndex / offset; // Calculate the component index for this dimension\n            currentUnidimensionalIndex %= offset;             // Update the remaining unidimensional index for the next iteration\n        }\n\n        // The count for the last dimension is simply the remaining unidimensional index.\n        // (Because uniCounterOffset[last] is 1, currentUnidimensionalIndex / 1 = currentUnidimensionalIndex\n        // and currentUnidimensionalIndex % dimensions[last] would give the same result as just the remainder\n        // if the remainder is less than dimensions[last], which it always should be).\n        indices[last] = currentUnidimensionalIndex;\n\n        return indices;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}