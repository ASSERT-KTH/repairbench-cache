{
    "generation": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n        int remainder = index; // This will hold the remaining part of the unidimensional index\n\n        // The uniCounterOffset array contains the strides for each dimension.\n        // uniCounterOffset[i] represents the product of the sizes of all dimensions\n        // after dimension 'i' (from most significant to least significant dimension order).\n        // For example, if dimensions are [s0, s1, s2], then:\n        // uniCounterOffset[0] = s1 * s2\n        // uniCounterOffset[1] = s2\n        // uniCounterOffset[2] = 1 (for the last dimension)\n        // To find the count for each dimension (d_i) from a linear index (idx):\n        // d_0 = floor(idx / uniCounterOffset[0])\n        // remainder = idx % uniCounterOffset[0]\n        // d_1 = floor(remainder / uniCounterOffset[1])\n        // new_remainder = remainder % uniCounterOffset[1]\n        // ... and so on.\n        for (int i = 0; i < dimension; i++) {\n            final int offset = uniCounterOffset[i];\n            indices[i] = remainder / offset; // Calculate the count for the current dimension\n            remainder %= offset;             // Update the remainder for the next dimension\n        }\n\n        return indices;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}