{
    "generation": "    /**\n     * Gets a copy of this date with the specified field set to a new value.\n     * <p>\n     * If this partial did not previously support the field, the new one will.\n     * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n     * <p>\n     * For example, if the field type is <code>dayOfMonth</code> then the day\n     * would be changed/added in the returned instance.\n     *\n     * @param fieldType  the field type to set, not null\n     * @param value  the value to set\n     * @return a copy of this instance with the field set\n     * @throws IllegalArgumentException if the value is null or invalid\n     */\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            // Field is not present, so add it------------------------------------------\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n\n            // Find correct insertion point to keep largest-smallest order\n            // Logic copied from Partial(Chronology, DateTimeFieldType[], int[]) constructor\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            boolean unitFieldSupported = unitField.isSupported();\n\n            if (unitFieldSupported) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) { // Unit field is larger\n                            break;\n                        } else if (compare == 0) { // Unit fields are equal\n                            DurationField rangeField = fieldType.getRangeDurationType() == null ? null : fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType() == null ? null : loopType.getRangeDurationType().getField(iChronology);\n                            \n                            if (rangeField == null) {\n                                if (loopRangeField == null) {\n                                     // Tie break by name if range is null and duration equal\n                                     int compareNames = fieldType.getName().compareTo(loopType.getName());\n                                     if (compareNames < 0) {\n                                         break;\n                                     } else if (compareNames == 0) {\n                                         // This block should be impossible due to the index == -1 check\n                                         // If it happens, let the constructor throw the exception\n                                         break; // Treat as duplicate for insertion purposes\n                                     } // else compareNames > 0, continue\n                                } else { // rangeField is null, loopRangeField is not\n                                    break; // null range comes first\n                                }\n                            } else { // rangeField is not null\n                                if (loopRangeField == null) {\n                                     // non-null range comes after null range, continue loop\n                                } else { // both range fields not null\n                                    int compareRange = rangeField.compareTo(loopRangeField);\n                                    if (compareRange > 0) { // rangeField is larger\n                                        break;\n                                    } else if (compareRange == 0) { // range fields are equal\n                                        // Tie break by name if range and duration equal\n                                        int compareNames = fieldType.getName().compareTo(loopType.getName());\n                                        if (compareNames < 0) {\n                                            break;\n                                        } else if (compareNames == 0) {\n                                            // This block should be impossible due to the index == -1 check\n                                            // If it happens, let the constructor throw the exception\n                                            break; // Treat as duplicate for insertion purposes\n                                        } // else compareNames > 0, continue\n                                    } // else compareRange < 0, continue\n                                }\n                            }\n                        } // else compare < 0, unitField is smaller, continue loop\n                    } else { // loop field is unsupported, fieldToAdd is supported.\n                         break; // Supported fields come before unsupported ones.\n                    }\n                }\n            } else { // unitField is not supported\n                 // Field to add has unsupported duration. Goes after all supported fields.\n                 while (i < iTypes.length && iTypes[i].getDurationType().getField(iChronology).isSupported()) {\n                     i++;\n                 }\n                 // Sort among unsupported fields by name\n                 for (; i < iTypes.length; i++) {\n                     DateTimeFieldType loopType = iTypes[i];\n                     if (loopType.getDurationType().getField(iChronology).isSupported()) {\n                         // Should not happen based on while loop above\n                         break;\n                     }\n                      int compareNames = fieldType.getName().compareTo(loopType.getName());\n                      if (compareNames <= 0) { // Alphabetically before or equal (equal should be impossible)\n                          break;\n                      } // else compareNames > 0, continue\n                 }\n            }\n\n            // Insert into arrays\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, iTypes.length - i);\n            System.arraycopy(iValues, i, newValues, i + 1, iValues.length - i);\n\n            // Constructor calls chronology validation and duplicate checks\n            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n            // Note: The constructor of Partial sorts the arrays and validates.\n            // It includes checks for duplicate DateTimeFieldType instances and calls chronology.validate.\n            // If the test still fails, the issue might be within the validation logic itself (constructor/chronology)\n            // not detecting the specific conflict (e.g., hourOfDay vs clockhourOfDay).\n            return newPartial;\n\n        } else { // Field is already present, so update it-----------------------------\n            if (value == getValue(index)) {\n                return this; // No change\n            }\n            // Get a copy of the values\n            int[] newValues = getValues();\n            // Use the field's set method (which validates the value) to update the array\n            newValues = getField(index).set(this, index, newValues, value);\n            // Create a new partial with the same types but new values\n            return new Partial(this, newValues);\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}