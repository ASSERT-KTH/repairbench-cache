{
    "generation": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    Node callTarget = n.getFirstChild();\n    JSType callTargetType = callTarget.getJSType();\n    FunctionType callTargetFnType = null;\n    if (callTargetType != null && callTargetType.isFunctionType()) {\n      callTargetFnType = callTargetType.toMaybeFunctionType();\n    }\n\n    // Step 1: Infer templates from the 'this' type of the function being called.\n    // This handles cases like `new Class().foo()` where CLASS is inferred from `new Class()`.\n    Map<TemplateType, JSType> inferred = new HashMap<>();\n    if (callTargetFnType != null) {\n      JSType targetThisType = callTargetFnType.getThisType();\n      JSType fnThisType = fnType.getThisType();\n\n      if (targetThisType != null && fnThisType != null && fnThisType.hasTemplateTypes()) {\n        // Use a temporary replacer to infer templates by unifying fnThisType with targetThisType.\n        TemplateTypeReplacer tempReplacer = new TemplateTypeReplacer(registry);\n        tempReplacer.inferTemplateTypes(fnThisType, targetThisType);\n        inferred.putAll(tempReplacer.getInferredTypes());\n      }\n    }\n\n    // Step 2: Create a partially instantiated function type for parameter inference.\n    // This applies the 'this' type inferences to fnType before inferring from parameters.\n    TemplateTypeReplacer partialReplacer = new TemplateTypeReplacer(registry, inferred);\n    FunctionType partiallyInstantiatedFnType = fnType.visit(partialReplacer).toMaybeFunctionType();\n    Preconditions.checkNotNull(partiallyInstantiatedFnType);\n\n    // Step 3: Infer templates from parameters using the partially instantiated type.\n    // This ensures that templates already resolved (e.g., from 'this' type) are not\n    // re-inferred or conflicted by parameter matching.\n    Map<TemplateType, JSType> inferredFromParams =\n        inferTemplateTypesFromParameters(partiallyInstantiatedFnType, n);\n\n    // Step 4: Merge results from parameter inference into the main 'inferred' map.\n    // Prioritize specific inferences over UNKNOWN.\n    for (Map.Entry<TemplateType, JSType> entry : inferredFromParams.entrySet()) {\n        TemplateType template = entry.getKey();\n        JSType inferredType = entry.getValue();\n        if (inferredType == null || inferredType.isNoType()) {\n            continue; // Ignore null or NO_TYPE inferences\n        }\n\n        JSType currentInferred = inferred.get(template);\n        if (currentInferred == null || currentInferred.isUnknownType()) {\n            // If no prior inference or prior was UNKNOWN, use the new inference\n            inferred.put(template, inferredType);\n        } else if (!currentInferred.isEquivalentTo(inferredType) && !inferredType.isUnknownType()) {\n            // Conflict between two specific types. Set to UNKNOWN to signal unresolvable.\n            inferred.put(template, registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n        }\n        // If currentInferred is specific and inferredType is UNKNOWN, currentInferred wins, no change.\n        // If currentInferred is specific and inferredType is equivalent, no change.\n    }\n\n    // Step 5: Create the final TemplateTypeReplacer with the combined inferred map.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(registry, inferred);\n\n    // Step 6: Apply to original fnType to get replacementFnType.\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    // Step 7: Preserve the 'this' type from the call target's original function type\n    // if it's more specific (i.e., not UNKNOWN or null). This prevents parameter-based\n    // inference (which might yield UNKNOWN for the 'this' template) from overriding\n    // a more accurate 'this' type already determined from the call context.\n    if (callTargetFnType != null && callTargetFnType.getThisType() != null &&\n        !callTargetFnType.getThisType().isUnknownType()) {\n      replacementFnType = replacementFnType.toBuilder(registry)\n          .setThisType(callTargetFnType.getThisType())\n          .build();\n    }\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    // Create a new replacer instance with the final inferred map to accurately\n    // reflect if any changes were made.\n    return (new TemplateTypeReplacer(registry, inferred)).madeChanges;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}