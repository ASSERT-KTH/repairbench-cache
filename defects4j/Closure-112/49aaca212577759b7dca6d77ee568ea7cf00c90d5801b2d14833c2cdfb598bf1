{
    "generation": "import com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.ModificationVisitor;\nimport com.google.javascript.rhino.jstype.TemplateType;\nimport com.google.javascript.rhino.jstype.TemplateTypeMap;\nimport java.util.Map;\n\n// NOTE: This code snippet assumes it's part of a larger class that has access\n// to a JSTypeRegistry instance named 'registry'. Imports are included for clarity.\n\n  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   *\n   * <p>This function is also responsible for specializing template types based on the call context.\n   * It infers template types from arguments and potentially the 'this' type, then applies\n   * these inferred types to the function signature, updating the types on the call-related AST\n   * nodes.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final TemplateTypeMap fnTemplateTypeMap = fnType.getTemplateTypeMap();\n    if (fnTemplateTypeMap.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types based on the arguments and potentially 'this' type.\n    // The result is a map from template types to the JSTypes they should be replaced with.\n    Map<TemplateType, JSType> inferred =\n        inferTemplateTypesFromParameters(fnType, n);\n\n    // If no template types were resolved/inferred, no specialization is needed based on parameters.\n    // Note: Resolution based purely on 'this' type might still be desirable but is complex.\n    // For now, if the parameter-based inference yields nothing, we stop.\n    if (inferred.isEmpty()) {\n      return false;\n    }\n\n    // Visitor that replaces template types found in the map, leaving others unchanged.\n    // This prevents prematurely replacing uninferred template types with UNKNOWN,\n    // allowing them to be potentially resolved later or remain generic.\n    class PartialTemplateTypeReplacer extends ModificationVisitor {\n      private final Map<TemplateType, JSType> replacements;\n      boolean madeChanges = false;\n\n      PartialTemplateTypeReplacer(JSTypeRegistry registry, Map<TemplateType, JSType> replacements) {\n        super(registry);\n        this.replacements = replacements;\n      }\n\n      @Override\n      JSType caseTemplateType(TemplateType type) {\n        if (replacements.containsKey(type)) {\n          JSType replacement = replacements.get(type);\n          // Check that the replacement is non-null and actually different from the\n          // original template type before marking changes. Using equals avoids marking\n          // a change when a template type resolves to itself.\n          if (replacement != null && !replacement.equals(type)) {\n             madeChanges = true;\n             return replacement;\n          }\n        }\n        // Return the original template type if it's not in the map or the replacement is null/same.\n        return type;\n      }\n    }\n\n    PartialTemplateTypeReplacer replacer = new PartialTemplateTypeReplacer(registry, inferred);\n\n    // Apply the inferred replacements to the function type signature.\n    JSType replaced = fnType.visit(replacer);\n\n    // The result of visiting a FunctionType should still be a FunctionType.\n    FunctionType replacementFnType = replaced.toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType, \"Could not resolve to function type after substitution\");\n\n\n    // Only update AST types if the replacer actually made effective changes.\n    if (!replacer.madeChanges) {\n      return false;\n    }\n\n    // Update the types on the relevant AST nodes (the call target and the call itself).\n    Node callTarget = n.getFirstChild();\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return true; // Indicate that types were successfully inferred and updated.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}