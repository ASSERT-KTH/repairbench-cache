{
    "generation": "private boolean inferTemplatedTypesForCall(\n    Node n, FunctionType fnType) {\n  // Grab the template keys for this function.\n  final ImmutableList<TemplateType> keys =\n      fnType.getTemplateTypeMap().getTemplateKeys();\n  if (keys.isEmpty()) {\n    return false;\n  }\n\n  // We'll accumulate inferred mappings here.\n  Map<TemplateType, JSType> inferred = new LinkedHashMap<>();\n\n  // First, try to infer from the actual \"this\" type (e.g. generic classes).\n  Node callTarget = n.getFirstChild();\n  JSType declaredThis = fnType.getThisType();\n  if (declaredThis != null && callTarget.isGetProp()) {\n    Node thisObj = callTarget.getFirstChild();\n    if (thisObj != null) {\n      JSType actualThis = thisObj.getJSType();\n      if (actualThis != null) {\n        // If the actual \"this\" is a parameterized (templated) type, pull its map.\n        TemplatizedType asTemplated = actualThis.toMaybeTemplatizedType();\n        if (asTemplated != null) {\n          TemplateTypeMap thisMap = asTemplated.getTemplateTypeMap();\n          ImmutableList<TemplateType> thisKeys = thisMap.getTemplateKeys();\n          ImmutableList<JSType>   thisVals = thisMap.getTemplateValues();\n          for (int i = 0; i < thisKeys.size(); i++) {\n            TemplateType key = thisKeys.get(i);\n            if (keys.contains(key)) {\n              inferred.put(key, thisVals.get(i));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Next, infer from the call-site parameters, but do not override anything\n  // we've already pulled in from the \"this\" inference.\n  Map<TemplateType, JSType> paramInferred =\n      inferTemplateTypesFromParameters(fnType, n);\n  for (Map.Entry<TemplateType, JSType> e : paramInferred.entrySet()) {\n    inferred.putIfAbsent(e.getKey(), e.getValue());\n  }\n\n  // Now replace all template types in the function signature.  Missing\n  // entries are filled in with UNKNOWN.\n  TemplateTypeReplacer replacer =\n      new TemplateTypeReplacer(registry, inferred);\n  FunctionType instantiated = fnType.visit(replacer).toMaybeFunctionType();\n  Preconditions.checkNotNull(instantiated);\n\n  // Update the call-node and the call-target with the instantiated types.\n  callTarget.setJSType(instantiated);\n  n.setJSType(instantiated.getReturnType());\n\n  return replacer.madeChanges;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}