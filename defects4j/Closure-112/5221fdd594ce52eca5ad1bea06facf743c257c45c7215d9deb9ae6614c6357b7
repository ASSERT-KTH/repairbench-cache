{
    "generation": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   *\n   * This function infers template types based on the arguments passed to a\n   * function call, and specializes the function type accordingly.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    // TODO(nicksantos): This comment is suspicious. Why is it talking about\n    // function literals when this is for CALL nodes?\n\n    final TemplateTypeMap typeMap = fnType.getTemplateTypeMap();\n    final ImmutableList<TemplateType> keys = typeMap.getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types from parameters\n    Map<TemplateType, JSType> inferred =\n        inferTemplateTypesFromParameters(fnType, n);\n\n    // Build the map for the replacer. For templates not inferred from\n    // parameters, use their existing resolution in fnType (if any), or map them\n    // to themselves if they were unresolved. This prevents the replacer\n    // from defaulting uninferred/unresolved templates to UNKNOWN.\n    Map<TemplateType, JSType> replacementMap = new HashMap<>();\n    boolean madeChanges = false;\n    for (TemplateType key : keys) {\n      JSType existingType = typeMap.getResolvedTemplateType(key); // Existing resolution or null\n      if (inferred.containsKey(key)) {\n        JSType inferredType = inferred.get(key);\n        replacementMap.put(key, inferredType);\n        // Check if the inferred type differs from the existing resolution state.\n        // If existingType is null, it means the template was unresolved,\n        // so we compare the inferredType against the template key itself.\n        JSType typeToCompare = (existingType != null) ? existingType : key;\n        if (!inferredType.isEquivalentTo(typeToCompare)) {\n          madeChanges = true;\n        }\n      } else {\n        // Not inferred from parameters. Use existing resolution or self-mapping.\n        if (existingType != null) {\n          // Template was already resolved (e.g., class template from receiver type),\n          // keep the existing resolution.\n          replacementMap.put(key, existingType);\n        } else {\n          // Template was unresolved and not inferred from parameters, map to self.\n          // This prevents it from being replaced by UNKNOWN.\n          replacementMap.put(key, key);\n        }\n        // This branch doesn't contribute to 'madeChanges' because we are preserving\n        // the state from fnType (either resolved or unresolved). Changes are only\n        // recorded if inference provides a *different* type than the existing state.\n      }\n    }\n\n    // If inference didn't produce any changes compared to the initial state of fnType,\n    // then we don't need to create/set a new function type.\n    if (!madeChanges) {\n      return false;\n    }\n\n    // Replace template types using the constructed map.\n    // Because replacementMap contains mappings for all keys (either inferred,\n    // existing, or self), the TemplateTypeReplacer will not default to UNKNOWN\n    // for templates listed in 'keys'.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, replacementMap);\n\n    Node callTarget = n.getFirstChild();\n    FunctionType replacementFnType = fnType.visit(replacer).toMaybeFunctionType();\n\n    // Check if the specialization resulted in a valid FunctionType. It might become\n    // null or NoType if inference leads to incompatible types, e.g., violating\n    // template bounds.\n    Preconditions.checkNotNull(\n        replacementFnType, \"Function type specialization resulted in null. Function: %s\", fnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    // Return true because we determined earlier that actual changes were made by inference.\n    return true;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}