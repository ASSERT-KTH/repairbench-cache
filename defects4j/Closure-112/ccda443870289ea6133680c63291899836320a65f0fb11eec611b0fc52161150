{
    "generation": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   *\n   * This method attempts to infer template types for a function call and specializes\n   * the function's type accordingly. It handles both templates defined directly\n   * on the function and templates from the enclosing class (via the 'this' type).\n   * Templates not inferred from arguments or receiver context are resolved to UNKNOWN.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n\n    // Infer types for the function's own template parameters based on call arguments.\n    // Assumes inferTemplateTypesFromParameters is available and correctly infers based on args.\n    Map<TemplateType, JSType> inferred =\n        inferTemplateTypesFromParameters(fnType, n);\n\n    // Build the full map of substitutions: inferred types + defaults for others.\n    // Use HashMap for mutability.\n    Map<TemplateType, JSType> combinedMap = new HashMap<>(inferred);\n    boolean requiresSubstitution = !inferred.isEmpty();\n\n    // Find all template types referenced anywhere in the function signature\n    // (parameters, return type, this type).\n    ImmutableSet<TemplateType> allTemplates = fnType.getReferencedTemplateTypes();\n\n    // Default any template type referenced in the signature but not inferred\n    // from parameters to UNKNOWN. This handles class templates like T in C<T>.method()\n    // where T isn't determined by arguments to method().\n    for (TemplateType tt : allTemplates) {\n        if (!combinedMap.containsKey(tt)) {\n             combinedMap.put(tt, registry.getUnknownType());\n             requiresSubstitution = true;\n        }\n    }\n\n    // If no templates were inferred and no other templates needed defaulting,\n    // then no substitution is necessary, and the function type remains unchanged.\n    if (!requiresSubstitution) {\n      return false;\n    }\n\n    // Create a replacer that will substitute template types according to the combined map.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, combinedMap);\n\n    // Apply the substitutions by visiting the original function type.\n    // The visit method traverses the function type structure and applies replacements.\n    JSType replacement = fnType.visit(replacer);\n\n    // The result of replacement should ideally be a function type.\n    FunctionType replacementFnType = replacement.toMaybeFunctionType();\n    if (replacementFnType == null) {\n      // If visiting results in a non-function type, something is wrong.\n      // Avoid proceeding further.\n      return false;\n    }\n\n    // Update the JSType of the call target (e.g., the function expression like 'obj.method')\n    // with the specialized function type.\n    Node callTarget = n.getFirstChild();\n    callTarget.setJSType(replacementFnType);\n\n    // Update the JSType of the call node itself ('n') with the specialized return type.\n    n.setJSType(replacementFnType.getReturnType());\n\n    // Return true if the replacer indicates that substitutions were made.\n    // This signifies that the function type was specialized.\n    return replacer.madeChanges;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}