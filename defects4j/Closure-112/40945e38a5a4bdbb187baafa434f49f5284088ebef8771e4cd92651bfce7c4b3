{
    "generation": "  /**\n   * For functions with function(this: T, ...) and T as parameters, type\n   * inference will set the type of this on a function literal argument to the\n   * the actual type of T.\n   */\n  private boolean inferTemplatedTypesForCall(\n      Node n, FunctionType fnType) {\n    final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n        .getTemplateKeys();\n    if (keys.isEmpty()) {\n      return false;\n    }\n\n    // Try to infer the template types.\n    // Initialize the inferred map with template types inferred from the\n    // 'this' context of the call target. This is crucial for correctly\n    // inferring template types that appear in the 'this' type of the\n    // function itself (e.g., methods on templated classes).\n    Map<TemplateType, JSType> inferred = new HashMap<>();\n\n    // Get the 'this' type of the function being called (fnType) at the call site.\n    // For `new C().method()`, this is the instance type of `C` (e.g., `C<UNKNOWN>`).\n    JSType callsiteThisType = NodeUtil.getThisType(n);\n    // Get the declared 'this' type of the function (fnType).\n    // For `C.prototype.method`, if `@this {C<T>}` is used, this would be `C<T>`.\n    JSType declaredFnThisType = fnType.getThisType();\n\n    if (declaredFnThisType != null && callsiteThisType != null) {\n      // Check if the declared 'this' type contains any of the template keys\n      // belonging to the function's template map.\n      boolean hasRelevantTemplatesInThis = false;\n      for (TemplateType key : keys) {\n        if (declaredFnThisType.containsTemplateType(key)) {\n          hasRelevantTemplatesInThis = true;\n          break;\n        }\n      }\n\n      if (hasRelevantTemplatesInThis) {\n        TypeUnifier unifier = new TypeUnifier(\n            registry,\n            isLoose(),\n            compiler.getOptions().getLanguageIn());\n        // Unify the declared 'this' type (which may contain template types)\n        // with the actual 'this' type at the call site. This will populate\n        // the unifier's inferred map for these template types.\n        unifier.unify(declaredFnThisType, callsiteThisType);\n        inferred.putAll(unifier.getInferredTemplateTypes());\n      }\n    }\n\n    // Now, infer additional template types from the formal parameters and\n    // the function's return type against the actual arguments and assignment\n    // context. The `inferTemplateTypesFromParameters` method returns a\n    // new map of inferences, which are then combined with (and potentially\n    // override) the 'this' type inferences already made.\n    inferred.putAll(inferTemplateTypesFromParameters(fnType, n));\n\n    // Replace all template types using the complete set of inferred types.\n    // If a template type couldn't be inferred, it will be replaced with UNKNOWN.\n    TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n        registry, inferred);\n    Node callTarget = n.getFirstChild();\n\n    FunctionType replacementFnType = fnType.visit(replacer)\n        .toMaybeFunctionType();\n    Preconditions.checkNotNull(replacementFnType);\n\n    callTarget.setJSType(replacementFnType);\n    n.setJSType(replacementFnType.getReturnType());\n\n    return replacer.madeChanges;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}