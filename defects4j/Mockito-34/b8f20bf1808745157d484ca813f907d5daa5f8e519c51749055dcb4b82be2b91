{
    "generation": "import org.hamcrest.Matcher;\nimport org.mockito.internal.matchers.CapturesArguments;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\n\n// This is the fixed version of the buggy function.\n// It resides inside a class (presumably InvocationMatcher),\n// which has access to the 'matchers' field (List<Matcher>).\npublic void captureArgumentsFrom(Invocation i) {\n    Method method = i.getMethod();\n    boolean isVarArgs = method.isVarArgs();\n    Object[] arguments = i.getArguments();\n    int argc = arguments.length;\n    //getParameterTypes() is needed to know the declared number of parameters and the type for varargs\n    Class<?>[] parameterTypes = method.getParameterTypes();\n    int paramCount = parameterTypes.length;\n\n    for (int k = 0; k < matchers.size(); k++) {\n        Matcher m = matchers.get(k); // Use get(k) as matchers is often a List\n\n        if (!(m instanceof CapturesArguments)) {\n            continue; // Skip non-capturing matchers\n        }\n\n        CapturesArguments captor = (CapturesArguments) m;\n\n        // Check if this matcher corresponds to the vararg parameter\n        // Vararg parameter is always the last one.\n        if (isVarArgs && k == paramCount - 1) {\n            // Handle the vararg parameter capture\n            Object capturedValue;\n            if (k < argc) {\n                // If arguments exist at/beyond index k, capture the k-th argument.\n                // For varargs, Mockito wraps the varargs into an array as the last argument.\n                capturedValue = arguments[k];\n            } else {\n                // Invocation didn't have arguments for the vararg parameter\n                // (e.g., called foo() for foo(String... args)).\n                // We need to capture an empty array of the vararg component type.\n                Class<?> varargComponentType = parameterTypes[k].getComponentType();\n                capturedValue = Array.newInstance(varargComponentType, 0);\n            }\n            captor.captureFrom(capturedValue);\n            // Vararg matcher captures the argument at index k (which is the vararg array)\n            // or an empty array if no argument was provided. It consumes the conceptual 'rest'.\n            // Since the loop iterates through matchers, and we assume the vararg matcher\n            // corresponds to the last parameter, we can conceptually break here,\n            // but letting the loop finish is also fine if matchers.size() == paramCount.\n        } else {\n            // Handle standard (non-vararg) parameter capture\n            if (k < argc) {\n                // Capture the corresponding argument if it exists\n                captor.captureFrom(arguments[k]);\n            }\n            // else: If k >= argc for a non-vararg parameter, it implies an argument\n            // mismatch which arguably should have been handled elsewhere (e.g., matching phase).\n            // We don't call captureFrom in this case, preserving the original code's\n            // implicit behavior for this edge case while fixing the AIOOBE for varargs.\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}