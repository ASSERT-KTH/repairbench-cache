{
    "generation": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    int pos = -1;\n    // Find the most recently opened element with the given name.\n    for (int i = stack.size() - 1; i >= 0; i--) {\n        if (stack.get(i).nodeName().equals(elName)) {\n            pos = i;\n            break;\n        }\n    }\n    if (pos == -1)\n        return; // not found, skip\n\n    // If the matching element is at the top, remove it normally.\n    if (pos == stack.size() - 1) {\n        stack.remove(stack.size() - 1);\n        return;\n    }\n    \n    // Otherwise, there are mis-nested elements above the matching element.\n    // Remove them from the stack and save them temporarily.\n    List<Element> misnested = new ArrayList<>();\n    for (int i = stack.size() - 1; i > pos; i--) {\n        misnested.add(stack.get(i));\n        stack.remove(i);\n    }\n    \n    // Remove the matching element from the stack.\n    Element closed = stack.remove(pos);\n    \n    // Now, reparent the misnested elements to the element that is now current (if any).\n    if (!stack.isEmpty()) {\n        Element newParent = stack.get(stack.size() - 1);\n        // We iterate in reverse so that the original order is preserved.\n        for (int i = misnested.size() - 1; i >= 0; i--) {\n            Element el = misnested.get(i);\n            // Detach from its old parent (the closed element) and re-attach to the new parent.\n            el.remove();\n            newParent.appendChild(el);\n            // Since this element is still \u201copen\u201d, push it back on the stack.\n            stack.add(el);\n        }\n    } else {\n        // Unlikely case: no new parent, so re-add the misnested elements.\n        for (Element el : misnested) {\n            stack.add(el);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}