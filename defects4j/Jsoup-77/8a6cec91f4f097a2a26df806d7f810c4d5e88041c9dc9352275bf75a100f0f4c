{
    "generation": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    int pos = -1;\n    // Find the matching element in the stack (searching downward from the top)\n    for (int i = stack.size() - 1; i >= 0; i--) {\n        if (stack.get(i).nodeName().equals(elName)) {\n            pos = i;\n            break;\n        }\n    }\n    if (pos == -1)\n        return; // not found, so nothing to do\n\n    // Collect any elements that were pushed after the matching element.\n    // These are the mis-nested elements that need to be reparented.\n    List<Element> misnested = new ArrayList<>();\n    for (int i = pos + 1; i < stack.size(); i++) {\n        misnested.add(stack.get(i));\n    }\n\n    // Remove the misnested elements from the stack.\n    // (They remain in the tree as children of the element we created them under.)\n    for (int i = stack.size() - 1; i > pos; i--) {\n        stack.remove(i);\n    }\n\n    // Remove the matching element (i.e. the one we\u2019re closing) from the stack.\n    Element nodeToClose = stack.remove(pos);\n\n    // Reparent misnested elements so that they no longer live inside the closed element.\n    // They are appended as children of the new current element (if one exists).\n    if (!misnested.isEmpty() && !stack.isEmpty()) {\n        Element newCurrent = stack.get(stack.size() - 1);\n        for (Element el : misnested) {\n            // If the misnested element\u2019s parent is still the closed element, detach it.\n            if (el.parent() == nodeToClose) {\n                el.remove();\n            }\n            newCurrent.appendChild(el);\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}