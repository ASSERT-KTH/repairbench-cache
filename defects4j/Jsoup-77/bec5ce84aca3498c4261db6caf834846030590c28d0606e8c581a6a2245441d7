{
    "generation": "private void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    int pos = -1;\n    // Find the nearest element on the stack with a matching tag name.\n    for (int i = stack.size() - 1; i >= 0; i--) {\n        if (stack.get(i).nodeName().equals(elName)) {\n            pos = i;\n            break;\n        }\n    }\n    if (pos == -1)\n        return; // not found, skip\n\n    Element target = stack.get(pos);\n    Element parent = target.parent();\n    // If there are any elements above the target in the stack (i.e. mis-nested),\n    // remove them from their current parent (usually the target) and reparent\n    // them into target\u2019s parent (immediately after target). This ensures that,\n    // for example, a mis-nested <p> that was improperly appended to a <div> ends\n    // up as a sibling of the <div> (as required by the test).\n    if (parent != null) {\n        List<Element> misnested = new ArrayList<>();\n        // Collect all elements above the target\n        for (int i = pos + 1; i < stack.size(); i++) {\n            misnested.add(stack.get(i));\n        }\n        // Determine the insertion point immediately after target in the parent's children.\n        int insertIndex = parent.children().indexOf(target) + 1;\n        for (Element node : misnested) {\n            // Remove node from its current parent so as not to leave a dangling reference.\n            node.remove();\n            parent.insertChildren(insertIndex, node);\n            insertIndex++;\n        }\n    }\n    // Now pop everything from the stack from the top down to and including target.\n    for (int i = stack.size() - 1; i >= pos; i--) {\n        stack.remove(i);\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}