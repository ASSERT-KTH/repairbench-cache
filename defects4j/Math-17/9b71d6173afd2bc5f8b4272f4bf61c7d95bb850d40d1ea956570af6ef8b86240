{
    "generation": "    /** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        // Handle special values first: NaN, Infinity, Zero\n        if (isNaN() || field.getZero().getClass().cast(field.getZero()).isNaN()) {\n            return newInstance(field.getZero().nan); // propagate NaN\n        }\n        if (this.isInfinite()) {\n            if (x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return newInstance(field.getZero().nan); // inf * 0 = NaN\n            }\n            // inf * (positive/negative) = inf with sign according to x\n            if ((x > 0 && this.sign == 1) || (x < 0 && this.sign == -1)) {\n                return newInstance(this, this.sign);\n            } else {\n                return newInstance(this, -this.sign);\n            }\n        }\n        if (x == 0) {\n            // Determine the sign of 0 according to this\n            Dfp result = newInstance(field.getZero());\n            result.sign = this.sign;\n            return result;\n        }\n\n        if (this.isZero()) {\n            // 0 * inf already handled above, so just zero\n            Dfp result = newInstance(field.getZero());\n            result.sign = (x < 0) ? -this.sign : this.sign;\n            return result;\n        }\n\n        // Pass correct sign for negative x\n        Dfp result = multiplyFast(Math.abs(x));\n        if (x < 0) {\n            result = result.negate();\n        }\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}