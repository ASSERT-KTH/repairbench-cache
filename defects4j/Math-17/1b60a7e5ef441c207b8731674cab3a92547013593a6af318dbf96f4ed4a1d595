{
    "generation": "    /** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        // Handle special cases according to Dfp rules (NaN, Infinity, zero)\n        if (isNaN() || (x == 0 && (isInfinite() || isNaN()))) {\n            // Multiplying NaN or inf * 0 or 0 * inf -> NaN\n            Dfp result = newInstance(getZero());\n            result.nan = true;\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return result;\n        }\n\n        if (isInfinite()) {\n            if (x > 0) {\n                return copysign(this, false); // inf * positive = inf\n            } else if (x < 0) {\n                return copysign(this, true); // inf * negative = -inf\n            } else { // x == 0 handled above\n                // Already handled above, so unreachable\n                Dfp result = newInstance(getZero());\n                result.nan = true;\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return result;\n            }\n        }\n\n        if (isZero()) {\n            // Keep the sign correctly (handle signed zero)\n            Dfp result = copysign(getZero(), ((x < 0) ^ sign));\n            result.sign = ((x < 0) ^ sign); // \"sign\" is true for negative\n            return result;\n        }\n\n        if (x == 0) {\n            // Zero with sign handling\n            Dfp result = copysign(getZero(), (sign ^ (x < 0)));\n            result.sign = (sign ^ (x < 0));\n            return result;\n        }\n\n        // For normal numbers (not NaN/Inf/zero), delegate to multiplyFast\n        Dfp result = multiplyFast(Math.abs(x));\n        // Set correct sign if x is negative\n        result.sign = (sign ^ (x < 0));\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}