{
    "generation": "    /** Multiply this by a single digit x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n        boolean isNegative = false;\n        \n        if (x == 0) {\n            // handle special zero cases according to IEEE 754\n            if (this.isNaN()) {\n                return this.newInstance(this); // propagate NaN\n            }\n            if (this.isInfinite()) {\n                result = result.newInstance(Dfp.QNAN);\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                return result;\n            }\n            result.sign = (this.sign == -1) ? -1 : 1;\n            result.exp = 0;\n            Arrays.fill(result.mant, 0);\n            result.nans = FINITE;\n            return result;\n        }\n\n        if (this.isNaN()) {\n            return this.newInstance(this); // propagate NaN\n        }\n\n        if (this.isInfinite()) {\n            result = result.newInstance(this);\n            if (x < 0) {\n                result.sign = -this.sign;\n            }\n            return result;\n        }\n\n        if (x < 0) {\n            isNegative = !isNegative;\n        }\n        result.sign = (x < 0) ? -this.sign : this.sign;\n\n        int absX = Math.abs(x);\n\n        int[] tmp = new int[mant.length + 1];\n\n        long product;\n        int carry = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            product = ((long) mant[i]) * absX + carry;\n            tmp[i + 1] = (int) (product % RADIX);\n            carry = (int) (product / RADIX);\n        }\n        tmp[0] = carry;\n        \n        // Copy back to result, handle carry that causes normalization shift\n        if (tmp[0] != 0) {\n            for (int i = 0; i < mant.length; i++) {\n                result.mant[i] = tmp[i];\n            }\n            result.exp = this.exp + 1;\n        } else {\n            for (int i = 0; i < mant.length; i++) {\n                result.mant[i] = tmp[i + 1];\n            }\n            result.exp = this.exp;\n        }\n\n        // set non-finite flags (already handled special cases)\n        result.nans = FINITE;\n        // finalize sign\n        if (isZero(result)) {\n            result.sign = (this.sign == -1 && x != 0) ? -1 : 1;\n        }\n\n        // check for overflows/underflows\n        result = result.round();\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}