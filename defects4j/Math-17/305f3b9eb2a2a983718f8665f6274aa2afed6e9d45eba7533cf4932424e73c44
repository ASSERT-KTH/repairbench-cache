{
    "generation": "/** Multiply this by a single digit x.\n * @param x multiplicand\n * @return product of this and x\n */\npublic Dfp multiply(final int x) {\n    // Handle NaN\n    if (isNaN() || x == Integer.MIN_VALUE && x == 0) { // second part unused, but matches style\n        return newInstance(getZero().dotrap(DfpField.FLAG_INVALID, \"multiply\", getZero(), \"NaN operand\"));\n    }\n    // Handle infinity\n    if (isInfinite()) {\n        if (x == 0) {\n            return newInstance(getZero().dotrap(DfpField.FLAG_INVALID, \"multiply\", getZero(), \"Infinity * 0\"));\n        }\n        return (sign == ((x < 0) ? -1 : 1)) ? newInstance(getField().getPositiveInfinity()) : newInstance(getField().getNegativeInfinity());\n    }\n    // Handle zero\n    if (mant[mant.length - 1] == 0) {\n        if (x == 0) {\n            // Handling sign of zero: follow sign rules: sign = sign(this) * sign(x)\n            Dfp resultZero = newInstance(getZero());\n            resultZero.sign = (sign == ((x < 0) ? -1 : 1)) ? 1 : -1;\n            return resultZero;\n        }\n        Dfp resultZero = newInstance(getZero());\n        resultZero.sign = (sign == ((x < 0) ? -1 : 1)) ? 1 : -1;\n        return resultZero;\n    }\n    // Handle x == 0\n    if (x == 0) {\n        Dfp resultZero = newInstance(getZero());\n        resultZero.sign = (sign == ((x < 0) ? -1 : 1)) ? 1 : -1;\n        return resultZero;\n    }\n    // Now safe to just invoke multiplyFast\n    Dfp result = multiplyFast(Math.abs(x));\n    result.sign = (sign == ((x < 0) ? -1 : 1)) ? 1 : -1;\n    // result.sign = sign * ((x < 0) ? -1 : 1); <--- equivalent\n    return result;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}