{
    "generation": "    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     *\n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        try {\n            int offset = pos.getIndex();\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n\n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n                // Note: This uses the default local timezone. ISO 8601 without a TZ is ambiguous.\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n                offset += 1; // Skip 'T'\n                // extract hours, minutes, seconds and milliseconds\n                // Support for hhmmss format (no colons)\n                int hourEndOffset = offset + 2;\n                hour = parseInt(date, offset, hourEndOffset);\n                offset = hourEndOffset; // Move offset past hour\n\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1; // Skip ':'\n                }\n\n                int minEndOffset = offset + 2;\n                minutes = parseInt(date, offset, minEndOffset);\n                offset = minEndOffset; // Move offset past minutes\n\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1; // Skip ':'\n                }\n\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    // Check if the next char is not a timezone indicator (Z, +, -)\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        int secEndOffset = offset + 2;\n                        seconds = parseInt(date, offset, secEndOffset);\n                        offset = secEndOffset; // Move offset past seconds\n\n                        // The spec allows seconds up to 60 (for leap seconds), but Java Date/Calendar typically don't support it.\n                        // Truncate leap seconds 60, 61, 62 to 59\n                        if (seconds > 59 && seconds < 63) seconds = 59;\n\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1; // Skip '.'\n                            int endOffset = indexOfNonDigit(date, offset); // Find end of digits\n                             // Allow variable number of ms digits, but parse up to 3 for precision\n                            int parseEndOffset = Math.min(endOffset, offset + 3);\n                            if (offset < parseEndOffset) { // Check if any digits exist\n                                int fraction = parseInt(date, offset, parseEndOffset);\n                                // compensate for \"missing\" digits based on how many were parsed\n                                switch (parseEndOffset - offset) { // number of digits parsed\n                                case 2:\n                                    milliseconds = fraction * 10;\n                                    break;\n                                case 1:\n                                    milliseconds = fraction * 100;\n                                    break;\n                                default: // 3 or more digits parsed\n                                    milliseconds = fraction;\n                                }\n                            } else {\n                                // Handle case like \"...\" or \".Z\" - invalid format\n                                throw new NumberFormatException(\"Missing digits after milliseconds separator '.'\");\n                            }\n                            offset = endOffset; // Move offset past all fractional digits\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                // ISO 8601 requires timezone information if time is present.\n                throw new IllegalArgumentException(\"Missing time zone indicator\");\n            }\n\n            TimeZone timezone;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                // Use final constant TIMEZONE_UTC if available and correct, otherwise get UTC instance.\n                timezone = TimeZone.getTimeZone(\"UTC\");\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffsetStr = date.substring(offset);\n                int consumedLength; // How many characters were consumed for the timezone offset\n                String timezoneId; // The ID string passed to TimeZone.getTimeZone\n\n                // Check for [+-]hh:mm (6 chars: sign, hh, :, mm)\n                if (timezoneOffsetStr.length() >= 6 && timezoneOffsetStr.charAt(3) == ':') {\n                    // Basic validation for digits\n                    if (!Character.isDigit(timezoneOffsetStr.charAt(1)) || !Character.isDigit(timezoneOffsetStr.charAt(2)) ||\n                        !Character.isDigit(timezoneOffsetStr.charAt(4)) || !Character.isDigit(timezoneOffsetStr.charAt(5))) {\n                         throw new IndexOutOfBoundsException(\"Invalid time zone offset format: \" + timezoneOffsetStr.substring(0, 6));\n                    }\n                    timezoneId = \"GMT\" + timezoneOffsetStr.substring(0, 6);\n                    consumedLength = 6;\n                // Check for [+-]hhmm (5 chars: sign, hh, mm)\n                } else if (timezoneOffsetStr.length() >= 5 && Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2)) && Character.isDigit(timezoneOffsetStr.charAt(3)) && Character.isDigit(timezoneOffsetStr.charAt(4))) {\n                    timezoneId = \"GMT\" + timezoneOffsetStr.substring(0, 5);\n                    consumedLength = 5;\n                 // Check for [+-]hh (3 chars: sign, hh) - This is valid in ISO 8601\n                } else if (timezoneOffsetStr.length() >= 3 && Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2))) {\n                    // Normalize to GMT[+-]hh:00 for TimeZone.getTimeZone, as it might not handle GMT[+-]hh directly.\n                    timezoneId = \"GMT\" + timezoneOffsetStr.substring(0, 3) + \":00\";\n                    consumedLength = 3;\n                } else {\n                    // Throw specific exception about format if length/pattern doesn't match expected ones\n                    throw new IndexOutOfBoundsException(\"Invalid time zone offset format starting at index \" + offset + \": \" + timezoneOffsetStr);\n                }\n\n                timezone = TimeZone.getTimeZone(timezoneId);\n                String actualId = timezone.getID();\n\n                // Verification steps:\n                // 1. TimeZone.getTimeZone might return \"GMT\" if the ID is not recognized.\n                // Check if it defaulted to GMT incorrectly (i.e., timezoneId wasn't GMT+/-00:00 or equivalent).\n                if (actualId.equals(\"GMT\") && !timezoneId.matches(\"GMT[+-]00:?00\")) {\n                     throw new IndexOutOfBoundsException(\"Failed to parse timezone ID: '\" + timezoneId + \"' resulted in GMT default\");\n                }\n\n                // 2. Verify that the raw offset of the obtained TimeZone matches the offset specified in the input string.\n                // This handles cases where TimeZone.getTimeZone canonicalizes the ID (e.g., GMT+0100 -> GMT+01:00)\n                // or accepts slightly different formats.\n\n                // Extract the numerical offset part actually consumed from the date string\n                String offsetPart = date.substring(offset, offset + consumedLength);\n\n                // Calculate expected offset in milliseconds from offsetPart\n                int sign = offsetPart.charAt(0) == '+' ? 1 : -1;\n                int hours, minutes;\n                try {\n                    // Use the provided parseInt helper if robust, otherwise Integer.parseInt\n                    if (consumedLength == 6) { // [+-]hh:mm\n                       hours = parseInt(offsetPart, 1, 3); // hh\n                       minutes = parseInt(offsetPart, 4, 6); // mm\n                    } else if (consumedLength == 5) { // [+-]hhmm\n                       hours = parseInt(offsetPart, 1, 3); // hh\n                       minutes = parseInt(offsetPart, 3, 5); // mm\n                    } else { // [+-]hh (consumedLength == 3)\n                       hours = parseInt(offsetPart, 1, 3); // hh\n                       minutes = 0; // ISO 8601 implies :00 for the hh format\n                    }\n                } catch (NumberFormatException nfe) {\n                    throw new IndexOutOfBoundsException(\"Invalid numeric characters in time zone offset: \" + offsetPart);\n                }\n\n                int expectedOffsetMillis = sign * (hours * 3600 * 1000 + minutes * 60 * 1000);\n\n                if (timezone.getRawOffset() != expectedOffsetMillis) {\n                     // This might indicate an issue with TimeZone.getTimeZone or an invalid input format slipped through\n                     throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: Parsed offset \" + offsetPart\n                            + \" resulted in TimeZone \" + actualId + \" with raw offset \" + timezone.getRawOffset() + \", but expected offset \" + expectedOffsetMillis);\n                }\n\n                // If all checks pass, update the main offset\n                offset += consumedLength;\n\n            } else {\n                // Character is not Z, +, or -\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"' at index \" + offset);\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1); // Calendar month is 0-based\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset); // Update position to indicate how much of the string was successfully parsed\n            return calendar.getTime();\n\n        } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n            // Catch specific exceptions that indicate parsing failures\n            fail = e;\n        }\n        // Format the final error message for ParseException\n        String input = (date == null) ? null : ('\"' + date + '\"');\n        String msg = (fail != null) ? fail.getMessage() : \"Unknown error\";\n        if (msg == null || msg.isEmpty()) {\n            // Provide fallback message if exception message is missing\n            msg = \"(\" + fail.getClass().getName() + \")\";\n        }\n        // Create ParseException with the error message and the index where the error occurred.\n        // pos.getIndex() should ideally point to the failure location.\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n        if (fail != null) { // Preserve the original exception cause\n             ex.initCause(fail);\n        }\n        throw ex;\n    }\n\n    // Assume these helper methods are available and correct within the same class or context.\n    // private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { ... }\n    // private static boolean checkOffset(String value, int offset, char expected) { ... }\n    // private static int indexOfNonDigit(String string, int offset) { ... }\n    // private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}