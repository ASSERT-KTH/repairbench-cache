{
    "generation": "/**\n * Parse a date from ISO-8601 formatted string. It expects a format\n * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n * \n * @param date ISO string to parse in the appropriate format.\n * @param pos The position to start parsing from, updated to where parsing stopped.\n * @return the parsed date\n * @throws ParseException if the date is not in the appropriate format\n */\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0;\n\n        // if no time component and no timezone, we're done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT && date.length() <= offset) {\n            Calendar cal = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return cal.getTime();\n        }\n\n        // time component\n        if (hasT) {\n            hour = parseInt(date, ++offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset++;\n            }\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset++;\n            }\n            // seconds and millis optional\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) {\n                        seconds = 59; // drop leap seconds\n                    }\n                    if (checkOffset(date, offset, '.')) {\n                        offset++;\n                        int end = indexOfNonDigit(date, offset + 1);\n                        int fracEnd = Math.min(end, offset + 3);\n                        int frac = parseInt(date, offset, fracEnd);\n                        switch (fracEnd - offset) {\n                            case 2: milliseconds = frac * 10; break;\n                            case 1: milliseconds = frac * 100; break;\n                            default: milliseconds = frac;\n                        }\n                        offset = end;\n                    }\n                }\n            }\n        }\n\n        // timezone\n        if (date.length() <= offset) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone tz;\n        char tzIndicator = date.charAt(offset);\n        if (tzIndicator == 'Z') {\n            tz = TIMEZONE_UTC;\n            offset++;\n        } else if (tzIndicator == '+' || tzIndicator == '-') {\n            // raw offset string\n            String rawOffset = date.substring(offset);\n            int rawLen = rawOffset.length();\n            offset += rawLen;\n            // normalize \"+hh\" to \"+hh00\"\n            String tzOffset = rawOffset;\n            if (rawOffset.length() == 3) { // e.g. \"+01\" or \"-05\"\n                tzOffset = rawOffset + \"00\";\n            }\n            // check for UTC\n            if (\"+0000\".equals(tzOffset) || \"+00:00\".equals(tzOffset)) {\n                tz = TIMEZONE_UTC;\n            } else {\n                String tzId = \"GMT\" + tzOffset;\n                tz = TimeZone.getTimeZone(tzId);\n                String actual = tz.getID();\n                if (!actual.equals(tzId)) {\n                    String cleaned = actual.replace(\":\", \"\");\n                    if (!cleaned.equals(tzId)) {\n                        throw new IndexOutOfBoundsException(\n                            \"Mismatching time zone indicator: \" + tzId +\n                            \" given, resolves to \" + tz.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\n                \"Invalid time zone indicator '\" + tzIndicator + \"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(tz);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + '\"');\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\n        \"Failed to parse date [\" + input + \"]: \" + msg,\n        pos.getIndex()\n    );\n    ex.initCause(fail);\n    throw ex;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}