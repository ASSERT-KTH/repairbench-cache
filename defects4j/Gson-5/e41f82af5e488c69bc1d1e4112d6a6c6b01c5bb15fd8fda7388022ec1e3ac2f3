{
    "generation": "    /**\n     * Parse a date from ISO-8601 formatted string. It expects a format\n     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n     *\n     * @param date ISO string to parse in the appropriate format.\n     * @param pos The position to start parsing from, updated to where parsing stopped.\n     * @return the parsed date\n     * @throws ParseException if the date is not in the appropriate format\n     */\n    public static Date parse(String date, ParsePosition pos) throws ParseException {\n        Exception fail = null;\n        // Store the initial offset for potential error reporting\n        int initialOffset = pos.getIndex();\n        try {\n            int offset = initialOffset;\n\n            // extract year\n            int year = parseInt(date, offset, offset += 4);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract month\n            int month = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, '-')) {\n                offset += 1;\n            }\n\n            // extract day\n            int day = parseInt(date, offset, offset += 2);\n            // default time value\n            int hour = 0;\n            int minutes = 0;\n            int seconds = 0;\n            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n            // if the value has no time component (and no time zone), we are done\n            boolean hasT = checkOffset(date, offset, 'T');\n\n            if (!hasT && (date.length() <= offset)) {\n                Calendar calendar = new GregorianCalendar(year, month - 1, day);\n                // Note: Timezone is JVM default for date-only strings, consistent with ISO 8601 local time interpretation.\n                pos.setIndex(offset);\n                return calendar.getTime();\n            }\n\n            if (hasT) {\n                offset += 1; // Consume 'T'\n\n                // extract hours, minutes, seconds and milliseconds\n                hour = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n\n                minutes = parseInt(date, offset, offset += 2);\n                if (checkOffset(date, offset, ':')) {\n                    offset += 1;\n                }\n                // second and milliseconds can be optional\n                if (date.length() > offset) {\n                    char c = date.charAt(offset);\n                    if (c != 'Z' && c != '+' && c != '-') {\n                        seconds = parseInt(date, offset, offset += 2);\n                        // ISO 8601 section 5.3.1.3 allows seconds 60 & 61 for leap seconds\n                        // Truncate leap seconds to 59\n                        if (seconds > 59 && seconds < 62) seconds = 59;\n\n                        // milliseconds can be optional in the format\n                        if (checkOffset(date, offset, '.')) {\n                            offset += 1;\n                            int endOffset = indexOfNonDigit(date, offset);\n                            if (endOffset == -1) {\n                                endOffset = date.length(); // Consume remaining digits\n                            }\n\n                            int parseBeginOffset = offset;\n                            // Limit parsing to 3 digits for milliseconds\n                            int parseEndOffset = Math.min(endOffset, offset + 3);\n\n                            if (parseBeginOffset < parseEndOffset) {\n                                int fraction = parseInt(date, parseBeginOffset, parseEndOffset);\n                                // compensate for \"missing\" digits based on actual number parsed\n                                switch (parseEndOffset - parseBeginOffset) { // number of digits parsed\n                                case 2:\n                                    milliseconds = fraction * 10;\n                                    break;\n                                case 1:\n                                    milliseconds = fraction * 100;\n                                    break;\n                                default: // 3 or more digits, use the parsed fraction (first 3 digits)\n                                    milliseconds = fraction;\n                                }\n                            } else {\n                                // If dot is present, digits should follow. parseInt would fail if begin==end.\n                                // Throw explicitly? Or let parseInt fail? Let parseInt fail for consistency.\n                                // If parseInt allows empty string, add check:\n                                 if (parseBeginOffset >= endOffset) {\n                                     throw new NumberFormatException(\"No digits found after decimal point\");\n                                 }\n                            }\n                            // Adjust offset to the end of the fractional second part (could be more than 3 digits)\n                            offset = endOffset;\n                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                // ISO 8601 requires timezone offset or Z if time part is present.\n                throw new IllegalArgumentException(\"Missing time zone indicator\");\n            }\n\n            TimeZone timezone;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC; // Assume TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\")\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffsetStr = date.substring(offset);\n                int V0length = timezoneOffsetStr.length();\n\n                // Validate and normalize the offset string to GMT[+|-]hh:mm format\n                String timezoneId;\n                int consumedOffsetLength;\n\n                // Try matching [+-]hh:mm format (length 6)\n                if (V0length >= 6 && timezoneOffsetStr.charAt(3) == ':' &&\n                    Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2)) &&\n                    Character.isDigit(timezoneOffsetStr.charAt(4)) && Character.isDigit(timezoneOffsetStr.charAt(5)))\n                {\n                    timezoneId = \"GMT\" + timezoneOffsetStr.substring(0, 6);\n                    consumedOffsetLength = 6;\n                // Try matching [+-]hhmm format (length 5)\n                } else if (V0length >= 5 &&\n                           Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2)) &&\n                           Character.isDigit(timezoneOffsetStr.charAt(3)) && Character.isDigit(timezoneOffsetStr.charAt(4)))\n                {\n                    timezoneId = \"GMT\" + timezoneOffsetStr.substring(0, 3) + \":\" + timezoneOffsetStr.substring(3, 5);\n                    consumedOffsetLength = 5;\n                // Try matching [+-]hh format (length 3)\n                } else if (V0length >= 3 &&\n                           Character.isDigit(timezoneOffsetStr.charAt(1)) && Character.isDigit(timezoneOffsetStr.charAt(2)))\n                {\n                    // Check for ambiguity: avoid parsing \"+01\" if it's actually \"+0100\" or \"+01:00\"\n                    // The previous checks for longer formats handle this. If we reach here, it must be exactly \"+hh\".\n                    // However, check if extra unexpected characters follow the \"+hh\".\n                    if (V0length > 3 && (Character.isDigit(timezoneOffsetStr.charAt(3)) || timezoneOffsetStr.charAt(3) == ':')) {\n                         throw new IndexOutOfBoundsException(\"Invalid character found after time zone offset hours: \" + timezoneOffsetStr);\n                    }\n                    timezoneId = \"GMT\" + timezoneOffsetStr.substring(0, 3) + \":00\";\n                    consumedOffsetLength = 3;\n                } else {\n                     // If none of the formats match\n                     throw new IndexOutOfBoundsException(\"Invalid time zone offset format or length: \" + timezoneOffsetStr);\n                }\n\n                offset += consumedOffsetLength; // Consume the parsed timezone offset part\n\n                // Check for UTC offset (GMT+00:00 or GMT-00:00) which should resolve to UTC/GMT\n                if (\"GMT+00:00\".equals(timezoneId) || \"GMT-00:00\".equals(timezoneId)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    timezone = TimeZone.getTimeZone(timezoneId);\n                    // Verify if the resolved timezone has the expected offset.\n                    // TimeZone.getTimeZone might return GMT for unknown IDs (e.g., \"GMT+99:00\").\n                    String resolvedId = timezone.getID();\n                    if (!resolvedId.equals(timezoneId)) {\n                        // If the ID was canonicalized (e.g., GMT+01 -> GMT+01:00), it's okay if the offset matches.\n                        // But if resolvedId is \"GMT\", it means the input ID was likely invalid.\n                        TimeZone expectedTimezone = TimeZone.getTimeZone(timezoneId); // Get expected timezone again for offset comparison\n                        if (resolvedId.equals(\"GMT\") || timezone.getRawOffset() != expectedTimezone.getRawOffset()) {\n                            throw new IndexOutOfBoundsException(\"Invalid or unsupported time zone offset: \" + timezoneOffsetStr + \", resolves to \" + resolvedId);\n                        }\n                    }\n                }\n            } else {\n                // Use absolute index in error message\n                throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"' at index \" + offset);\n            }\n\n            Calendar calendar = new GregorianCalendar(timezone);\n            calendar.setLenient(false);\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1); // Calendar month is 0-based\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            calendar.set(Calendar.HOUR_OF_DAY, hour);\n            calendar.set(Calendar.MINUTE, minutes);\n            calendar.set(Calendar.SECOND, seconds);\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n\n            pos.setIndex(offset); // Update position to where parsing stopped successfully\n            return calendar.getTime();\n\n        } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n            // Catch parsing exceptions\n            fail = e;\n        }\n\n        // Constructing the error message if parsing failed\n        String input = (date == null) ? null : ('\"' + date + '\"');\n        String failMsg = (fail.getMessage() == null || fail.getMessage().isEmpty())\n                          ? \"(\" + fail.getClass().getName() + \")\"\n                          : fail.getMessage();\n\n        // Error index: Use the original offset provided in ParsePosition.\n        // This matches the behavior of standard Java date parsing which reports\n        // the index where parsing started. More precise error index reporting\n        // would require more complex error handling within the try block.\n        int errorIndex = initialOffset;\n\n        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + failMsg, errorIndex);\n        ex.initCause(fail);\n        throw ex;\n    }\n\n    /* Assume helper methods and constants like TIMEZONE_UTC, parseInt, checkOffset, indexOfNonDigit\n     * are defined elsewhere in the same class or are accessible.\n     *\n     * private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");\n     * private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { ... }\n     * private static boolean checkOffset(String value, int offset, char expected) { ... }\n     * private static int indexOfNonDigit(String string, int offset) { ... }\n     */",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}