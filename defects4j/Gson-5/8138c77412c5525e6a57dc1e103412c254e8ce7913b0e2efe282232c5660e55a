{
    "generation": "public static Date parse(String date, ParsePosition pos) throws ParseException {\n    Exception fail = null;\n    try {\n        int offset = pos.getIndex();\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component, we are done\n        boolean hasT = checkOffset(date, offset, 'T');\n        if (!hasT) {\n            Calendar calendar = new GregorianCalendar(year, month - 1, day);\n            pos.setIndex(offset);\n            return calendar.getTime();\n        }\n\n        if (hasT) {\n            offset++;\n            // extract hours\n            hour = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset++;\n            }\n\n            // extract minutes\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset++;\n            }\n\n            // extract seconds and milliseconds if present\n            if (offset < date.length()) {\n                char c = date.charAt(offset);\n                if (c != 'Z' && c != '+' && c != '-') {\n                    seconds = parseInt(date, offset, offset += 2);\n                    if (seconds > 59 && seconds < 63) {\n                        seconds = 59;\n                    }\n                    if (checkOffset(date, offset, '.')) {\n                        offset++;\n                        int endOffset = indexOfNonDigit(date, offset + 1);\n                        int parseEndOffset = Math.min(endOffset, offset + 3);\n                        int fraction = parseInt(date, offset, parseEndOffset);\n                        switch (parseEndOffset - offset) {\n                            case 1:\n                                milliseconds = fraction * 100;\n                                break;\n                            case 2:\n                                milliseconds = fraction * 10;\n                                break;\n                            default:\n                                milliseconds = fraction;\n                        }\n                        offset = endOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (offset >= date.length()) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone timezone = null;\n        char timezoneIndicator = date.charAt(offset);\n\n        if (timezoneIndicator == 'Z') {\n            timezone = TIMEZONE_UTC;\n            offset++;\n        } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n            String timezoneStr = date.substring(offset);\n            // Attempt to parse with and without colon for minutes\n            timezone = getTimeZone(timezoneStr);\n            offset += timezoneStr.length();\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\");\n        }\n\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false);\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        pos.setIndex(offset);\n        return calendar.getTime();\n    } catch (IndexOutOfBoundsException e) {\n        fail = e;\n    } catch (NumberFormatException e) {\n        fail = e;\n    } catch (IllegalArgumentException e) {\n        fail = e;\n    }\n    String input = (date == null) ? null : ('\"' + date + \"'\");\n    String msg = fail.getMessage();\n    if (msg == null || msg.isEmpty()) {\n        msg = \"(\" + fail.getClass().getName() + \")\";\n    }\n    ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n    ex.initCause(fail);\n    throw ex;\n}\n\nprivate static TimeZone getTimeZone(String timezoneOffset) throws IllegalArgumentException {\n    String canonical = normalize(timezoneOffset);\n    TimeZone tz = TimeZone.getTimeZone(canonical);\n    if (tz != null) {\n        return tz;\n    }\n    String modified = normalizeWithColon(timezoneOffset);\n    tz = TimeZone.getTimeZone(modified);\n    if (tz != null) {\n        return tz;\n    }\n    throw new IllegalArgumentException(\"Cannot parse timezone: \" + timezoneOffset);\n}\n\nprivate static String normalize(String timezoneOffset) {\n    String replacement = \"\";\n    for (int i = 0; i < timezoneOffset.length(); i++) {\n        char c = timezoneOffset.charAt(i);\n        if (c == ':') {\n            replacement += \"\";\n        } else {\n            replacement += c;\n        }\n    }\n    return \"GMT\" + replacement;\n}\n\nprivate static String normalizeWithColon(String timezoneOffset) {\n    String[] parts = timezoneOffset.split(\"([+-])\");\n    if (parts.length == 3) {\n        String sign = parts[1];\n        String value = parts[2];\n        if (value.length() == 2) {\n            return \"GMT\" + sign + value.charAt(0) + \":\" + value.charAt(1) + \"00\";\n        } else if (value.length() > 2 && value.charAt(2) == ':') {\n            return \"GMT\" + sign + value;\n        }\n    }\n    return null;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}