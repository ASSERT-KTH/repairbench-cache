{
    "generation": "import java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\n\n// Assume these helper methods exist and work correctly:\n// private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {}\n// private static boolean checkOffset(String value, int offset, char expected) {}\n// private static int indexOfNonDigit(String string, int offset) {}\n// Assume TIMEZONE_UTC is defined elsewhere, e.g., static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(\"UTC\");\n\n/**\n * Parse a date from ISO-8601 formatted string. It expects a format\n * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:mm]]]\n *\n * @param date ISO string to parse in the appropriate format.\n * @param pos The position to start parsing from, updated to where parsing stopped.\n * @return the parsed date\n * @throws ParseException if the date is not in the appropriate format\n */\npublic static Date parse(String date, ParsePosition pos) throws ParseException {\n    int initialOffset = pos.getIndex(); // Store initial offset for error reporting if needed\n    try {\n        int offset = initialOffset;\n\n        // extract year\n        int year = parseInt(date, offset, offset += 4);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract month\n        int month = parseInt(date, offset, offset += 2);\n        if (checkOffset(date, offset, '-')) {\n            offset += 1;\n        }\n\n        // extract day\n        int day = parseInt(date, offset, offset += 2);\n\n        // default time value\n        int hour = 0;\n        int minutes = 0;\n        int seconds = 0;\n        int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // Check for 'T' separator indicating time component\n        boolean hasT = checkOffset(date, offset, 'T');\n        TimeZone timezone = null; // Initialize timezone\n\n        if (!hasT && (date.length() <= offset)) {\n            // No 'T' and end of string reached: Only date component present\n            // Use UTC timezone as a default for date-only ISO strings\n            Calendar calendar = new GregorianCalendar(TIMEZONE_UTC);\n            calendar.setLenient(false);\n            // Set date fields\n            calendar.set(Calendar.YEAR, year);\n            calendar.set(Calendar.MONTH, month - 1); // Calendar month is 0-based\n            calendar.set(Calendar.DAY_OF_MONTH, day);\n            // Set time fields to 0 explicitly\n            calendar.set(Calendar.HOUR_OF_DAY, 0);\n            calendar.set(Calendar.MINUTE, 0);\n            calendar.set(Calendar.SECOND, 0);\n            calendar.set(Calendar.MILLISECOND, 0);\n\n            // Validate date components\n            try {\n                Date parsedDate = calendar.getTime();\n                pos.setIndex(offset); // Update position\n                return parsedDate;\n            } catch (IllegalArgumentException e) {\n                // Point error index near the problematic part (day)\n                throw new ParseException(\"Invalid date value: \" + e.getMessage(), offset - 2);\n            }\n        }\n\n        if (hasT) {\n             offset += 1; // Skip 'T'\n             int timeStart = offset; // Keep track of where time parsing starts\n\n            // extract hours\n            hour = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            // extract minutes\n            minutes = parseInt(date, offset, offset += 2);\n            if (checkOffset(date, offset, ':')) {\n                offset += 1;\n            }\n\n            // extract seconds and milliseconds (optional)\n            if (date.length() > offset) {\n                char c = date.charAt(offset);\n                if (c >= '0' && c <= '9') { // Check if seconds are present\n                    seconds = parseInt(date, offset, offset += 2);\n                    // Adjust for leap seconds if necessary (per ISO 8601 appendix D)\n                    if (seconds > 59 && seconds < 63) seconds = 59;\n\n                    // Check for milliseconds\n                    if (checkOffset(date, offset, '.')) {\n                        offset += 1; // Skip '.'\n                        int fractionStartOffset = offset;\n                        int endOffset = indexOfNonDigit(date, offset);\n                        if (endOffset == -1) endOffset = date.length(); // Digits go to the end\n\n                        // Check if any digits were found after '.'\n                        if (offset == endOffset) throw new ParseException(\"Missing fractional second digits after '.'\", offset);\n\n                        int digitCount = endOffset - fractionStartOffset;\n                        int parseDigits = Math.min(digitCount, 3); // Parse up to 3 digits\n                        int parseEndOffset = fractionStartOffset + parseDigits;\n\n                        int fraction = parseInt(date, fractionStartOffset, parseEndOffset);\n\n                        // Adjust based on number of parsed digits\n                        if (parseDigits == 1) milliseconds = fraction * 100;\n                        else if (parseDigits == 2) milliseconds = fraction * 10;\n                        else milliseconds = fraction; // 3 or more digits\n\n                        offset = endOffset; // Move offset past all fractional digits\n                    }\n                }\n                // If c was not a digit, it might be Z, +, - (handled next)\n            }\n\n            // After time component, a timezone indicator is required by ISO 8601\n            if (date.length() <= offset) {\n                 throw new ParseException(\"Missing time zone indicator after time\", offset);\n            }\n\n            // Parse timezone\n            char timezoneIndicator = date.charAt(offset);\n            int timezoneStartOffset = offset; // For error reporting\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(timezoneStartOffset); // Get the full offset string (+hh:mm, +hhmm, or +hh)\n                int consumedLength = 0; // Track length of valid offset parsed\n\n                String formattedTimezoneOffset;\n                // Try parsing known formats: +hh:mm, +hhmm, +hh, ensuring digits are present\n                // Check for \"+hh:mm\" format (length 6)\n                if (timezoneOffset.length() >= 6 && timezoneOffset.charAt(3) == ':') {\n                    if (Character.isDigit(timezoneOffset.charAt(1)) && Character.isDigit(timezoneOffset.charAt(2)) &&\n                        Character.isDigit(timezoneOffset.charAt(4)) && Character.isDigit(timezoneOffset.charAt(5))) {\n                        formattedTimezoneOffset = timezoneOffset.substring(0, 6);\n                        consumedLength = 6;\n                    } else {\n                        throw new ParseException(\"Invalid time zone offset format near \" + timezoneOffset.substring(0, 6), timezoneStartOffset);\n                    }\n                // Check for \"+hhmm\" format (length 5)\n                } else if (timezoneOffset.length() >= 5 && timezoneOffset.indexOf(':') == -1) {\n                     if (Character.isDigit(timezoneOffset.charAt(1)) && Character.isDigit(timezoneOffset.charAt(2)) &&\n                         Character.isDigit(timezoneOffset.charAt(3)) && Character.isDigit(timezoneOffset.charAt(4))) {\n                        // Normalize to +hh:mm for TimeZone.getTimeZone consistency\n                        formattedTimezoneOffset = timezoneOffset.substring(0, 3) + \":\" + timezoneOffset.substring(3, 5);\n                        consumedLength = 5;\n                     } else {\n                         throw new ParseException(\"Invalid time zone offset format near \" + timezoneOffset.substring(0, 5), timezoneStartOffset);\n                     }\n                // Check for \"+hh\" format (length 3)\n                } else if (timezoneOffset.length() >= 3 && timezoneOffset.indexOf(':') == -1) {\n                    if (Character.isDigit(timezoneOffset.charAt(1)) && Character.isDigit(timezoneOffset.charAt(2))) {\n                        // Normalize to +hh:00\n                        formattedTimezoneOffset = timezoneOffset.substring(0, 3) + \":00\";\n                        consumedLength = 3;\n                    } else {\n                        throw new ParseException(\"Invalid time zone offset format near \" + timezoneOffset.substring(0, 3), timezoneStartOffset);\n                    }\n                } else {\n                    // Does not match any of the expected formats/lengths\n                    throw new ParseException(\"Invalid time zone offset format: \" + timezoneOffset, timezoneStartOffset);\n                }\n\n                // Update main offset to after the consumed timezone string\n                offset = timezoneStartOffset + consumedLength;\n\n                // Get TimeZone instance using the normalized \"+hh:mm\" format\n                if (\"+00:00\".equals(formattedTimezoneOffset) || \"-00:00\".equals(formattedTimezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    String timezoneId = \"GMT\" + formattedTimezoneOffset;\n                    timezone = TimeZone.getTimeZone(timezoneId);\n                    // Sanity check: if TimeZone.getTimeZone failed to parse the offset, it returns GMT.\n                    // This can happen for invalid values like \"GMT+99:99\".\n                    // We check if the returned ID is \"GMT\" unless the input legitimately corresponds to GMT.\n                    if (timezone.getID().equals(\"GMT\") && !timezoneId.equals(\"GMT+00:00\") && !timezoneId.equals(\"GMT-00:00\")) {\n                         throw new ParseException(\"Invalid time zone offset value: \" + timezoneOffset.substring(0, consumedLength), timezoneStartOffset);\n                    }\n                }\n            } else {\n                // Character after time component is not Z, +, or -\n                throw new ParseException(\"Invalid time zone indicator '\" + timezoneIndicator + \"'\", timezoneStartOffset);\n            }\n        } else {\n            // No 'T' but characters remaining after date part: Invalid format\n            throw new ParseException(\"Unexpected character '\" + date.charAt(offset) + \"' after date\", offset);\n        }\n\n        // At this point, we should have parsed all components and have a valid timezone\n        if (timezone == null) {\n            // This state should be unreachable if logic is correct\n             throw new ParseException(\"Internal error: Time zone could not be determined\", offset);\n        }\n\n        // Build Calendar using the determined timezone\n        Calendar calendar = new GregorianCalendar(timezone);\n        calendar.setLenient(false); // Use strict validation\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month - 1); // Calendar month is 0-based\n        calendar.set(Calendar.DAY_OF_MONTH, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour);\n        calendar.set(Calendar.MINUTE, minutes);\n        calendar.set(Calendar.SECOND, seconds);\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n\n        // Final validation and return date object\n        try {\n            Date parsedDate = calendar.getTime(); // Forces validation if lenient is false\n            pos.setIndex(offset); // Update position to reflect successful parse up to this point\n            return parsedDate;\n        } catch (IllegalArgumentException e) {\n            // Catch errors from invalid date/time combinations (e.g., month=13, day=32)\n            throw new ParseException(\"Invalid date/time value resulting from calendar computation: \" + e.getMessage(), offset); // Report error at end of parsed section\n        }\n\n    } catch (IndexOutOfBoundsException | NumberFormatException | IllegalArgumentException e) {\n         // Catch runtime exceptions from parsing helpers (parseInt, substring, etc.) or Calendar setters\n         // Wrap them in ParseException for consistent error handling\n         int errorIndex = pos.getIndex(); // Current index, might be outdated if error was early\n         // If error index wasn't advanced (error happened early), use initial offset. Otherwise, use current.\n         if (errorIndex <= initialOffset) errorIndex = initialOffset;\n\n         // Try to provide a slightly better error index for common exceptions\n         if (e instanceof NumberFormatException && errorIndex > initialOffset) {\n             // Often means the character at errorIndex-1 (or earlier) was invalid for a number\n         } else if (e instanceof IndexOutOfBoundsException) {\n             // Usually means reading past the end of the string\n             errorIndex = Math.min(errorIndex, (date != null ? date.length() : errorIndex)); // Ensure index is within bounds\n         }\n         ParseException ex = new ParseException(\"Failed to parse date [\" + (date == null ? \"null\" : \"'\" + date + \"'\") + \"]: \" + e.getMessage(), errorIndex);\n         ex.initCause(e);\n         throw ex;\n    } catch (ParseException e) {\n        // Re-throw ParseExceptions that were explicitly thrown by our validation logic\n        throw e;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}