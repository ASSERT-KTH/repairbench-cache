{
    "generation": "    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        // Revert to scalar multiplication.\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n        double sHighPrev = prodHigh[0];\n        double sLowSum = 0;\n\n        if (len > 1) {\n            double prodHighNext = prodHigh[1];\n            double sHighCur = sHighPrev + prodHighNext;\n            double sPrime = sHighCur - prodHighNext;\n            sLowSum = (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n\n            for (int i = 1; i < len - 1; i++) {\n                prodHighNext = prodHigh[i + 1];\n                sHighCur = sHighPrev + prodHighNext;\n                sPrime = sHighCur - prodHighNext;\n                sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n                sHighPrev = sHighCur;\n            }\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}