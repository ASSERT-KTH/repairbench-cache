{
    "generation": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            // As per [JACKSON-614], use the default impl if no type id available:\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                if (actual == null) { \n                    // Instead of returning null, try to infer the type from the JSON node\n                    JsonParser p = ctxt.getParser();\n                    if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                        JsonNode node = ctxt.readTree(p);\n                        // Try to infer the type based on the node's structure\n                        type = ctxt.getTypeFactory().constructType(node.asJavaObject().getClass());\n                    } else {\n                        // If we can't infer, fall back to the original behavior\n                        return null;\n                    }\n                } else {\n                    type = actual;\n                }\n                //... would this actually work?\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if ((_baseType!= null)\n                    && _baseType.getClass() == type.getClass()) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n            }\n            // **Added Check to Handle Polymorphic Types**\n            if (type.isAbstract() || type.isInterface()) {\n                JsonParser p = ctxt.getParser();\n                if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                    JsonNode node = ctxt.readTree(p);\n                    // Try to find a concrete subtype based on the node's properties\n                    for (JavaType subtype : ctxt.getTypeFactory().findTypeParameters(type, _baseType)) {\n                        if (subtype!= null && subtype.getRawClass().isInstance(node.asJavaObject())) {\n                            type = subtype;\n                            break;\n                        }\n                    }\n                }\n            }\n            deser = ctxt.findContextualValueDeserializer(type, _property);\n        }\n        _deserializers.put(typeId, deser);\n    }\n    return deser;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}