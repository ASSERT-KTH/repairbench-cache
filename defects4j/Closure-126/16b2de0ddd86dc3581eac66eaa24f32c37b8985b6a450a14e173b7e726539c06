{
    "generation": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Do not minimize exits in FINALLY blocks. This is accomplished by\n    // checking before removing an exit node below.\n    // However, we still need to traverse into the finally block.\n\n    // Recurse base cases: Handle control structures first.\n    if (n.isIf()) {\n      // Recurse on the IF branches first.\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      // After processing children, the IF is done for this call.\n      // The IF might be processed later as part of a BLOCK.\n      return;\n    }\n\n    if (n.isTry()) {\n      // Recurse into TRY structure.\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        // Recursively process the finally block, but exits within it will be\n        // protected by the check in the base case below.\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    if (n.isLabel()) {\n      // Recurse into the label body.\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      return;\n    }\n\n    // Base Case: Is 'n' the exit node itself?\n    if (matchingExitNode(n, exitType, labelName)) {\n      // Check if 'n' is inside a finally block before removing.\n      if (!isInFinallyBlock(n)) {\n        Node parent = n.getParent();\n        // Ensure parent allows removal (is Block, Script, or Label body).\n        if (parent != null && (parent.isBlock() || parent.isScript() || parent.isLabel())) {\n             NodeUtil.removeChild(parent, n);\n             compiler.reportCodeChange();\n        }\n      }\n      // Whether removed or not, we processed this node.\n      return;\n    }\n\n\n    // --- Handle BLOCK or SCRIPT node ---\n    // Only blocks and scripts contain sequences of statements to optimize further.\n    if (!n.isBlock() && !n.isScript()) {\n      return;\n    }\n\n    // Iterate through children to process IF statements and recurse.\n    // Use explicit next sibling handling due to potential node removals/moves.\n    Node currentChild = n.getFirstChild();\n    while (currentChild != null) {\n        Node nextChild = currentChild.getNext(); // Store next before possible modifications\n\n        // Recurse into the child first. This handles nested structures and\n        // exit removals within them (respecting finally blocks).\n        tryMinimizeExits(currentChild, exitType, labelName);\n\n        // After recursion, check if the child is an IF node and still exists.\n        if (currentChild.isIf() && currentChild.getParent() == n) {\n            Node ifNode = currentChild;\n            // Re-fetch branches as recursion might have altered them.\n            Node trueBlock = ifNode.getFirstChild().getNext();\n            Node falseBlock = trueBlock.getNext();\n\n            // Check if exactly one branch *now* ends with the target exit type.\n            // The exit node itself should have already been removed by the recursive\n            // call above if it wasn't in a finally block.\n            boolean trueExits = blockEndsWithExit(trueBlock, exitType, labelName);\n            boolean falseExits = (falseBlock != null) && blockEndsWithExit(falseBlock, exitType, labelName);\n\n            // Determine if the exit node (if it existed) was protected.\n            boolean wasProtected = false;\n            if (trueExits != falseExits) {\n                 Node exitBlock = trueExits ? trueBlock : falseBlock;\n                 Node lastNode = exitBlock.getLastChild();\n                 // Check if the last node *before potential removal* was an exit in finally.\n                 // This requires looking at the original state or inferring.\n                 // Simpler: If blockEndsWithExit is true, but the node is still there,\n                 // it must have been protected.\n                 if (trueExits && lastNode != null && matchingExitNode(lastNode, exitType, labelName)) {\n                    wasProtected = true; // trueBlock ended with exit, but it's still there.\n                 } else if (falseExits && falseBlock.getLastChild() != null\n                            && matchingExitNode(falseBlock.getLastChild(), exitType, labelName)) {\n                    wasProtected = true; // elseBlock ended with exit, but it's still there.\n                 }\n            }\n\n\n            // If exactly one branch exited *and* the exit was not protected by finally,\n            // move subsequent code into the other branch.\n            if (trueExits != falseExits && !wasProtected) {\n                Node targetBlock = trueExits ? falseBlock : trueBlock;\n\n                // Move statements following the IF node.\n                Node subsequentNode = ifNode.getNext();\n                if (subsequentNode != null) { // Only move if there's something after the IF\n                    Node originalTargetBlock = targetBlock; // Remember if we created it\n\n                    // Ensure the target block exists.\n                    if (targetBlock == null) {\n                        targetBlock = IR.block().srcref(ifNode); // Use IR factory methods\n                        if (trueExits) { // Target is the ELSE block\n                            ifNode.addChildToBack(targetBlock);\n                        } else { // Target is the THEN block (must exist)\n                            // This case implies falseExits was true, so elseBlock must exist.\n                           Preconditions.checkState(false, \"Cannot move code to a non-existent THEN block\");\n                        }\n                    }\n\n                    // Move all subsequent siblings into the target block.\n                    boolean codeMoved = false;\n                    while (subsequentNode != null) {\n                        Node nodeToMove = subsequentNode;\n                        subsequentNode = subsequentNode.getNext(); // Advance pointer first\n\n                        n.removeChild(nodeToMove); // Remove from parent block 'n'\n                        targetBlock.addChildToBack(nodeToMove);\n                        codeMoved = true;\n                    }\n\n                    // Report change if nodes were moved or block created.\n                    if (codeMoved || originalTargetBlock == null) {\n                         compiler.reportCodeChange();\n                    }\n                    // Update nextChild for the outer loop since siblings were moved.\n                    nextChild = ifNode.getNext(); // Should be null or point after moved section\n                }\n            }\n        }\n        // Move to the next child for the next iteration.\n        currentChild = nextChild;\n    }\n\n\n    // After processing children, check the last child of the block again.\n    // Redundant exits at the end of the block are handled here. Loop handles\n    // cascading removals (e.g. \"return; return;\" -> \"return;\" -> \"\").\n    while (true) {\n      Node lastChild = n.getLastChild();\n      if (lastChild == null) {\n        break; // Block is empty.\n      }\n\n      // Store the node instance to check if it gets removed/replaced by the call.\n      Node originalLastChild = lastChild;\n      // Recurse into the last child. This might remove it if it's an exit.\n      tryMinimizeExits(lastChild, exitType, labelName);\n\n      // If the last child didn't change identity (i.e., wasn't removed or replaced)\n      // then we're done with this block's tail optimization for this pass.\n      if (n.getLastChild() == originalLastChild) {\n          break;\n      }\n      // Otherwise, the last child changed (likely removed), loop again to process\n      // the node that is *now* the last child.\n    }\n  }\n\n  /** Helper function: Checks if node 'n' is contained within a FINALLY block. */\n  private boolean isInFinallyBlock(Node n) {\n      // Walk up ancestors checking if any is a finally block of a TRY node.\n      for (Node ancestor = n; ancestor != null; ancestor = ancestor.getParent()) {\n          Node parent = ancestor.getParent();\n          // Check if 'ancestor' is the finally block (last child) of a TRY node.\n          if (parent != null && parent.isTry() && parent.getLastChild() == ancestor) {\n              // Ensure 'ancestor' is actually the block node, not just contained within.\n              // The check parent.getLastChild() == ancestor confirms 'ancestor' is the finally block itself.\n              // If n is this ancestor or any node inside it, return true.\n              return true;\n          }\n          // Stop searching at function/script boundaries, as TRY cannot cross these.\n          if (ancestor.isFunction() || ancestor.isScript()) {\n              break;\n          }\n      }\n      return false;\n  }\n\n  /**\n   * Helper function: Checks if a block ends with a specific exit type node.\n   * Does not consider whether the exit is in a finally block by itself.\n   */\n  private boolean blockEndsWithExit(Node block, int exitType, String labelName) {\n      if (block != null && block.isBlock()) {\n          Node last = block.getLastChild();\n          // Check if the last child exists and matches the exit criteria.\n          return last != null && matchingExitNode(last, exitType, labelName);\n      }\n      return false;\n  }\n\n  // Assumes existence of:\n  // matchingExitNode(Node, int, String) : boolean\n  // compiler.reportCodeChange() : void\n  // NodeUtil methods (removeChild is implicitly used via n.removeChild)\n  // Preconditions.checkState\n  // IR factory methods (e.g., IR.block())",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}