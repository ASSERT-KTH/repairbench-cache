{
    "generation": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Base case: If n is a matching exit node, try to remove it.\n    if (matchingExitNode(n, exitType, labelName)) {\n      Node parent = n.getParent();\n      // An exit can be removed if it's the last statement in a BLOCK\n      // and it's not a FINALLY block.\n      if (parent != null && parent.isBlock() && n == parent.getLastChild()) {\n         Node grandparent = parent.getParent();\n         boolean inFinally = false;\n         if (grandparent != null && grandparent.isTry()) {\n            Node finallyBlock = NodeUtil.getFinallyBlock(grandparent);\n            if (finallyBlock == parent) {\n               inFinally = true;\n            }\n         }\n\n         if (!inFinally) {\n            NodeUtil.removeChild(parent, n);\n            compiler.reportCodeChange();\n         }\n      }\n      // We're done with this node, whether it was removed or not.\n      return;\n    }\n\n    // Recurse on complex structures.\n\n    // If node.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      // Don't process the IF node itself further in this call.\n      return;\n    }\n\n    // Try/catch/finally node.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        // ECMA-262 only allows one catch clause.\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      // *** FIX: Do not try to minimize the exits of finally blocks ***\n      // This can change the completion type of the finally block, affecting\n      // control flow (See ECMA 262 Sections 8.9 & 12.14).\n      // The original recursive call is removed.\n      // if (NodeUtil.hasFinally(n)) {\n      //  Node finallyBlock = n.getLastChild();\n      //  tryMinimizeExits(finallyBlock, exitType, labelName); // REMOVED\n      // }\n      return; // Done processing TRY node.\n    }\n\n    // Label node.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      // TODO(johnlenz): Should we remove the label if the block is empty?\n      // This is potentially handled by RemoveUnnecessaryCode.\n      return; // Done processing LABEL node.\n    }\n\n    // TODO(johnlenz): Handle SWITCH statements?\n\n    // Only perform structural modifications on BLOCK nodes below.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Process IF nodes within this block using tryMinimizeIfBlockExits.\n    // This helper function can move statements following an IF into its branches.\n    // Iterate through children, calling the helper.\n    // NOTE: This loop structure relies on tryMinimizeIfBlockExits potentially\n    // modifying the siblings of 'c' or 'c' itself.\n    for (Node c = n.getFirstChild(); c != null; ) {\n       Node next = c.getNext(); // Get next before potentially modifying/removing c\n\n       if (c.isIf()) {\n         Node ifTree = c;\n         Node trueBlock, falseBlock;\n\n         // Minimize exits in the THEN branch\n         trueBlock = ifTree.getFirstChild().getNext();\n         falseBlock = trueBlock.getNext(); // Get ELSE block relative to THEN\n         tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n         // Refresh references, as the structure might have changed.\n         trueBlock = ifTree.getFirstChild().getNext();\n         falseBlock = trueBlock.getNext();\n\n         // Minimize exits in the ELSE branch (if it exists)\n         if (falseBlock != null) {\n           // Pass the THEN block as the \"other\" block.\n           tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n         }\n       } else {\n          // For non-IF children, recurse to handle nested structures.\n          // This wasn't explicitly done in the original loop, but seems necessary\n          // to ensure structures inside the block are minimized before checking\n          // the block's last child later.\n          tryMinimizeExits(c, exitType, labelName);\n       }\n       c = next; // Move to the next node\n    }\n\n\n    // After potentially modifying the block structure (especially IFs),\n    // check the *current* last child. It might be a simple exit node\n    // that's now redundant, or a structure containing a newly redundant exit.\n    Node lastChild = n.getLastChild();\n    if (lastChild != null) {\n      // Recursively try to minimize the last child.\n      // This handles cases where the last child is a container (like IF or TRY)\n      // which might have had its own last statement removed, potentially making\n      // the container itself removable or simpler.\n      // It also handles the case where the last child *became* a removable exit\n      // due to the loop above. The base case check at the start of the function\n      // will handle the actual removal if `lastChild` is a simple exit node.\n      tryMinimizeExits(lastChild, exitType, labelName);\n    }\n    // Removed the complex iterative loop on the last child from the original code.\n    // The combination of the initial base case check and this final recursive call\n    // should be sufficient.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}