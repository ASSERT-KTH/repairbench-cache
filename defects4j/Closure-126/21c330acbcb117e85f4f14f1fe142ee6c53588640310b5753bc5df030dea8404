{
    "generation": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n  // Just an 'exit'.\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n\n  // Just an 'if'.\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n\n  // Just a 'try/catch/finally'.\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    /* Don't try to minimize the exits of finally blocks, as this\n     * can cause problems if it changes the completion type of the finally\n     * block. See ECMA 262 Sections 8.9 & 12.14\n     */\n    // NOTE: We deliberately do NOT process the finally block.\n    return;\n  }\n\n  // Just a 'label'.\n  if (n.isLabel()) {\n    // Process the labeled statement.\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n    // If the label's statement got removed, remove the label too.\n    // (A typical label has two children: the label name and the statement.)\n    if (n.getChildCount() < 2) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n  }\n\n  // TODO(johnlenz): The last case of SWITCH statement?\n\n  // The rest assumes a block with at least one child, bail on anything else.\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n\n  // Multiple if\u2010exits can be converted in a single pass.\n  // Convert \"if (blah) exit;  if (blah2) exit; other_stmt;\" to\n  // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n  // which will eventually get transformed to \"if (!blah && !blah2) { other_stmt; }\".\n  for (Node c : n.children()) {\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock, falseBlock;\n\n      // Process the true branch.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n      // Now process the else branch.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n      }\n    }\n\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n\n  // Now try to minimize the exits of the last child repeatedly (if it gets removed,\n  // then a new last child may require processing).\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}