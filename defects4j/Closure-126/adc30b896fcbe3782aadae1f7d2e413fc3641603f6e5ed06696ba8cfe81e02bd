{
    "generation": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Recurse into child structures. These recursive calls handle minimizing\n    // exits within the sub-structures. We don't return after these calls\n    // because the container node itself (if it's a block or is the last\n    // statement in a block) might be processed by the logic below.\n\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n    } else if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        // TODO(johnlenz): Handle multi-catch properly.\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      // DO NOT process the finally block. Minimizing exits in finally blocks\n      // is problematic due to ECMA 262 control flow rules.\n      // See ECMA 262 Sections 8.9 & 12.14.\n      // if (NodeUtil.hasFinally(n)) {\n      //   Node finallyBlock = n.getLastChild();\n      //   tryMinimizeExits(finallyBlock, exitType, labelName); // This was the bug\n      // }\n    } else if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    } else if (n.isSwitch()) {\n      // TODO(johnlenz): Handle switches properly by recursing into CASE blocks.\n      // It's complex because exits in one case can affect the next.\n      // For now, do nothing with the switch structure itself,\n      // allowing block processing below if the switch is in a block.\n    }\n\n    // Block-level optimizations:\n    // These only apply if the current node 'n' is a BLOCK node.\n    if (!n.isBlock()) {\n      return;\n    }\n\n    // Optimization 1: Process IF statements within this block.\n    // The helper tryMinimizeIfBlockExits is responsible for moving code\n    // following an IF into the appropriate branch if the other branch exits.\n    // We need to iterate carefully in case tryMinimizeIfBlockExits modifies\n    // the sibling structure.\n    Node c = n.getFirstChild();\n    while (c != null) {\n      Node next = c.getNext(); // Save the next sibling before processing 'c'\n\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // Process the THEN block exit possibility.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n        // Re-fetch blocks, as tryMinimizeIfBlockExits might have changed them\n        // (e.g., by creating an ELSE block).\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n\n        // Process the ELSE block exit possibility.\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n        }\n      }\n      // Add handling for other structures like SWITCH here if needed in the future.\n\n      c = next; // Move to the next node that was originally after 'c'.\n    }\n\n    // Optimization 2: Remove redundant exit at the end of the block.\n    // If the last statement in the block is the exit we're looking for,\n    // remove it. Repeat if the new last statement is also such an exit.\n    while (true) {\n        Node lastChild = n.getLastChild();\n        if (lastChild == null) {\n            break; // Block is empty.\n        }\n\n        // Store the original state to detect removal.\n        Node lastChildParent = lastChild.getParent();\n\n        // Try to minimize the last child. This might be a recursive call\n        // (if it's an IF/TRY/LABEL/BLOCK) or it might remove the node\n        // directly if it's a matching simple exit node.\n        tryMinimizeExits(lastChild, exitType, labelName);\n\n        // Check if the last child node instance is still attached to 'n'\n        // and is still the last child. If tryMinimizeExits removed it,\n        // its parent will change or n.getLastChild() will point to a different node.\n        if (lastChild.getParent() == lastChildParent && n.getLastChild() == lastChild) {\n            // The node was not removed by the recursive call. Stop processing this block.\n            break;\n        }\n        // The last child was removed or replaced. Loop again to process the\n        // new last child (if any).\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}