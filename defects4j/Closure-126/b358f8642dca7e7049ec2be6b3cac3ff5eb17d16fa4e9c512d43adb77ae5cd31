{
    "generation": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  // Just an 'exit'.\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n\n  // Just an 'if'.\n  if (n.isIf()) {\n    Node cond = n.getFirstChild();\n    Node trueBlock = cond.getNext();\n    tryMinimizeExits(trueBlock, exitType, labelName);\n    Node falseBlock = trueBlock.getNext();\n    if (falseBlock != null) {\n      tryMinimizeExits(falseBlock, exitType, labelName);\n    }\n    return;\n  }\n\n  // Just a 'try/catch/finally'.\n  if (n.isTry()) {\n    // Recurse into try block\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n\n    // Recurse into catch block, if any\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchBlock, exitType, labelName);\n    }\n\n    // Do NOT recurse into finally \u2014 changing finally exits\n    // can alter completion type (ECMA-262 \u00a7\u00a78.9 & 12.14).\n    return;\n  }\n\n  // Just a 'label'.\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n    return;\n  }\n\n  // The rest assumes a block with at least one child.\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n\n  // If we're minimizing RETURNS, but this block\n  // has a top-level try\u2026finally (or a label whose\n  // body is a try\u2026finally), bail here to avoid\n  // changing function completion semantics.\n  if (exitType == Token.RETURN && labelName == null) {\n    for (Node c : n.children()) {\n      Node t = c;\n      if (t.isLabel()) {\n        t = t.getLastChild();\n      }\n      if (t.isTry() && NodeUtil.hasFinally(t)) {\n        return;\n      }\n    }\n  }\n\n  // Multiple if-exits conversion:\n  for (Node c : n.children()) {\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock = ifTree.getFirstChild().getNext();\n      Node falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n          ifTree, exitType, labelName);\n\n      // Re-fetch after possible changes:\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n            ifTree, exitType, labelName);\n      }\n    }\n    // Stop before last, we'll handle it below.\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n\n  // Finally, recurse into the last child (in case it changed):\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}