{
    "generation": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      // FIX: Don't remove exit points within finally blocks.\n      // As per ECMA 262 Sections 8.9 & 12.14, changing the completion type\n      // of a finally block can lead to incorrect behavior.\n      if (!NodeUtil.isWithinFinallyBlock(n)) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n      }\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       * The recursive call here is now safe because the `isWithinFinallyBlock`\n       * check at the top of this function prevents actual removal within finally blocks.\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n      // Note: Original code falls through to the next check, which is fine\n      // because try nodes are not block nodes, so they'll hit the next return.\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      // Note: Original code falls through to the next check, which is fine\n      // because label nodes are not block nodes, so they'll hit the next return.\n    }\n\n    // TODO(johnlenis): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    // FIX: Changed from for-each to while loop to safely handle AST modifications.\n    // tryMinimizeIfBlockExits can move subsequent siblings of an 'if' node\n    // into its 'else' block, which modifies the parent node 'n's children list,\n    // potentially invalidating an iterator.\n    Node currentChild = n.getFirstChild();\n    while (currentChild != null) {\n      // Store the next sibling BEFORE processing currentChild,\n      // as currentChild or its following siblings might be modified/moved.\n      Node nextChild = currentChild.getNext();\n\n      // An 'if' block to process below.\n      if (currentChild.isIf()) {\n        Node ifTree = currentChild; // ifTree is currentChild\n\n        Node trueBlock = ifTree.getFirstChild().getNext();\n        Node falseBlock = trueBlock.getNext();\n\n        // First, the true condition block.\n        // This call might modify 'n' by moving siblings of 'ifTree' into\n        // 'ifTree's 'else' block.\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed due to transformations, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n        // After tryMinimizeIfBlockExits, currentChild (the ifTree) remains,\n        // but its original subsequent siblings in 'n' might have been moved\n        // into its own 'else' block. We must advance 'currentChild' to\n        // the *next remaining* child in 'n'.\n        currentChild = currentChild.getNext();\n      } else {\n        // If it's not an IF node, just advance to the next child as planned.\n        currentChild = nextChild;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      // This is necessary because tryMinimizeExits(c, ...) might remove 'c',\n      // changing n.getLastChild(). If 'c' was removed, the loop needs to\n      // re-evaluate the new last child.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}