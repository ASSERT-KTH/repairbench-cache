{
    "generation": "  /**\n   * Attempts to minimize the number of explicit exit points in a control\n   * structure to take advantage of the implied exit at the end of the\n   * structure.  This is accomplished by removing redundant statements, and\n   * moving statements following a qualifying IF node into that node.\n   * For example:\n   *\n   * function () {\n   *   if (x) return;\n   *   else blah();\n   *   foo();\n   * }\n   *\n   * becomes:\n   *\n   * function () {\n   *  if (x) ;\n   *  else {\n   *    blah();\n   *    foo();\n   *  }\n   *\n   * @param n The execution node of a parent to inspect.\n   * @param exitType The type of exit to look for.\n   * @param labelName If parent is a label the name of the label to look for,\n   *   null otherwise.\n   * @nullable labelName non-null only for breaks within labels.\n   */\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Do not try to minimize the exits of nodes inside a FINALLY block,\n    // as it can change the completion type of the finally block.\n    // See ECMA 262 Sections 8.9 & 12.14\n    boolean isWithinFinally = NodeUtil.isWithinFinallyBlock(n);\n\n    // If n is the exit node itself:\n    if (matchingExitNode(n, exitType, labelName)) {\n      // Check if removing this node is safe\n      if (!isWithinFinally) {\n        NodeUtil.removeChild(n.getParent(), n);\n        compiler.reportCodeChange();\n      }\n      // Whether removed or not, cannot recurse further down this path.\n      return;\n    }\n\n    // Recurse into the node's structure.\n\n    // Handle IF structure\n    if (n.isIf()) {\n      // Recurse on THEN block\n      Node thenBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(thenBlock, exitType, labelName);\n      // Recurse on ELSE block\n      Node elseBlock = thenBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      // Return: IF structure is handled recursively.\n      return;\n    }\n\n    // Handle TRY structure\n    if (n.isTry()) {\n      // Recurse on TRY block\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      // Recurse on CATCH block\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        // Note: This assumes only one CATCH, which is generally true after Normalize.\n        Preconditions.checkState(allCatchNodes.hasOneChild(), \"Catch block has more than one child\");\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      // Recurse on FINALLY block\n      // The check at the beginning of the function prevents bad removals.\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n      // Return: TRY structure is handled recursively.\n      return;\n    }\n\n    // Handle LABEL structure\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      // Return: LABEL structure is handled recursively.\n      return;\n    }\n\n    // TODO(johnlenz): Handle SWITCH\n\n    // The rest applies only to BLOCK structures (or SCRIPT/FUNCTION)\n    if (!n.isBlock() && !n.isScript() && !n.isFunction()) {\n        return;\n    }\n\n    // Only applies to BLOCK/SCRIPT/FUNCTION, and must have children\n    if (n.getFirstChild() == null) {\n      return;\n    }\n\n    // ----- Processing for BLOCK/SCRIPT/FUNCTION -----\n\n    // Optimize IF statements within this block\n    // Traverse the children, optimizing IFs as we find them.\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext(); // Store next node since c might be removed/changed\n      if (c.isIf()) {\n        // Handle the IF case: move trailing statements into ELSE, etc.\n        // Note: This function might change the structure, including 'next'.\n        // It needs to be careful, or this loop needs adapting.\n        Node ifNode = c;\n        Node trueBlock = ifNode.getFirstChild().getNext();\n        Node falseBlock = trueBlock.getNext();\n        // Optimize the IF's true branch regarding exits\n        tryMinimizeIfBlockExits(trueBlock, falseBlock, ifNode, exitType, labelName);\n\n        // Re-fetch else block, might have changed\n        trueBlock = ifNode.getFirstChild().getNext(); // Re-fetch true block too? Maybe not needed.\n        falseBlock = trueBlock.getNext();\n        // Optimize the IF's false branch regarding exits\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock, ifNode, exitType, labelName);\n        }\n      }\n      c = next;\n    }\n\n    // Minimize trailing exits within the block.\n    // Keep removing the last child if it's an exit node (and not in finally)\n    // until the last child is no longer a removable exit.\n    while (true) {\n      Node lastChild = n.getLastChild();\n      if (lastChild == null) {\n        break; // Block is empty\n      }\n\n      // Store the original last child reference before the recursive call\n      Node originalLastChild = lastChild;\n\n      // Try to minimize exits within the last child structure itself\n      // (e.g., if the last child is an IF or TRY).\n      // This recursive call will handle the isWithinFinally check internally.\n      tryMinimizeExits(lastChild, exitType, labelName);\n\n      // If the recursive call removed or modified the last child,\n      // loop again to process whatever is the new last child.\n      if (n.getLastChild() != originalLastChild) {\n        continue;\n      }\n\n      // If the last child was not changed by the recursive call,\n      // no further optimization is possible on the trailing child sequence.\n      break;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}