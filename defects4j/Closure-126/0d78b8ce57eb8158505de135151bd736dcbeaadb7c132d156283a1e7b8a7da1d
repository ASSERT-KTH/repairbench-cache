{
    "generation": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  // If this node is an explicit exit and it is not part of a finally block,\n  // remove it.\n  if (matchingExitNode(n, exitType, labelName)) {\n    // Check whether n is inside a finally block.\n    boolean isInFinallyBlock = false;\n    for (Node curr = n.getParent(); curr != null; curr = curr.getParent()) {\n      if (curr.isTry() && NodeUtil.hasFinally(curr)) {\n        Node finallyBlock = curr.getLastChild();\n        // Walk up from n to see if it is a descendant of the try's finally block.\n        for (Node iter = n; iter != null; iter = iter.getParent()) {\n          if (iter == finallyBlock) {\n            isInFinallyBlock = true;\n            break;\n          }\n        }\n        if (isInFinallyBlock) {\n          break;\n        }\n      }\n    }\n    if (!isInFinallyBlock) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n    }\n    return;\n  }\n\n  // If this node is an IF, process its then and else blocks.\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n\n  // If this node is a TRY, process its try block and catch block,\n  // but deliberately do not minimize the finally block.\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    // Do not descend into the finally block.\n    return;\n  }\n\n  // If this node is a LABEL, process its labeled statement.\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n  }\n\n  // TODO(johnlenz): Handle SWITCH statements if necessary.\n\n  // Only continue if this node is a block with at least one child.\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n\n  // Process multiple if-exits.\n  for (Node c : n.children()) {\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock = ifTree.getFirstChild().getNext();\n      Node falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n      // The if/else blocks may have been modified, so re-read them.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n      }\n    }\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n\n  // Process the last child repeatedly.\n  for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n    tryMinimizeExits(c, exitType, labelName);\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}