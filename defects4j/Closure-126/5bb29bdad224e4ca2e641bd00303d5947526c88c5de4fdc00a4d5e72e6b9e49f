{
    "generation": "import com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n// NOTE: This code is part of a larger class, PeepholeMinimizeExplicitReturn.\n// It assumes 'compiler' is an accessible AbstractCompiler instance and\n// that a method 'tryMinimizeIfBlockExits' exists and works as described\n// in the original code's comments (moving code after an IF into the appropriate branch).\n\n/**\n * Attempts to minimize the number of explicit exit points in a control\n * structure to take advantage of the implied exit at the end of the\n * structure. This is accomplished by removing redundant statements, and\n * moving statements following a qualifying IF node into that node.\n * For example:\n *\n * function () {\n *   if (x) return;\n *   else blah();\n *   foo();\n * }\n *\n * becomes:\n *\n * function () {\n *  if (x) ;\n *  else {\n *    blah();\n *    foo();\n *  }\n *\n * @param n The execution node of a parent to inspect.\n * @param exitType The type of exit to look for (e.g., Token.RETURN, Token.BREAK).\n * @param labelName If parent is a label the name of the label to look for,\n *   null otherwise.\n * @nullable labelName non-null only for breaks/continues within labels.\n */\nvoid tryMinimizeExits(Node n, int exitType, String labelName) {\n\n  // Ensure we have access to the compiler for reporting changes.\n  // This should be assigned elsewhere in the containing class.\n  // Preconditions.checkNotNull(compiler);\n\n  // Don't try to minimize the exits of finally blocks, as this\n  // can cause problems if it changes the completion type of the finally\n  // block. See ECMA 262 Sections 8.9 & 12.14\n  if (NodeUtil.isFinallyBlock(n)) {\n    return;\n  }\n\n  // Handle the base case where the node itself is the exit node.\n  if (matchingExitNode(n, exitType, labelName)) {\n    Node parent = n.getParent();\n    // Check if parent is suitable for child removal (is a block-like structure).\n    // Avoid removing function/script bodies directly.\n    if (parent != null && NodeUtil.isStatementBlock(parent)) {\n        NodeUtil.removeChild(parent, n);\n        compiler.reportCodeChange();\n    }\n    // Whether removed or not, we don't process children of an exit node.\n    return;\n  }\n\n  // Minimize exits in children first using recursive descent.\n  // This handles nested structures from the bottom up.\n  Node child = n.getFirstChild();\n  while(child != null) {\n      Node nextChild = child.getNext(); // Store next before recursion modifies tree\n      tryMinimizeExits(child, exitType, labelName);\n      child = nextChild;\n  }\n\n  // Now, apply optimizations based on the structure of 'n' itself,\n  // assuming its children have already been minimized.\n\n  // --- Optimization for IF statements within a BLOCK ---\n  // This needs to be done only if 'n' is a block.\n  if (n.isBlock()) {\n      Node next = null;\n      for (Node c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext(); // Store next sibling before potential modification/removal\n\n        if (c.isIf()) {\n          Node ifTree = c;\n          Node trueBlock = ifTree.getFirstChild().getNext();\n          Node falseBlock = trueBlock.getNext();\n\n          // Check exit status AFTER internal minimization done by the first pass.\n          boolean thenExits = blockEndsWithExit(trueBlock, exitType, labelName);\n          // Check 'else' only if it exists.\n          boolean elseExits = (falseBlock != null) &&\n                              blockEndsWithExit(falseBlock, exitType, labelName);\n\n          if (thenExits && elseExits) {\n            // Case 1: IF(..) EXIT; ELSE EXIT; --> Remove exits and following code.\n            removeBlockExit(trueBlock, exitType, labelName);\n            // falseBlock might be null, removeBlockExit handles null check internally.\n            removeBlockExit(falseBlock, exitType, labelName);\n\n            // Remove all statements following this IF in the current block 'n'.\n            while (next != null) {\n              Node siblingToRemove = next;\n              next = next.getNext(); // Move next forward BEFORE removing sibling\n              NodeUtil.removeChild(n, siblingToRemove);\n              compiler.reportCodeChange();\n            }\n            // The IF node is now the last effective statement in this block.\n            // No need to process further siblings in this block.\n            break; // Exit the loop processing children of n.\n\n          } else {\n            // Case 2: One or neither branch exits.\n            // Try to move following statements into the non-exiting branch.\n            // This relies on the tryMinimizeIfBlockExits helper function (assumed to exist).\n\n            // Re-fetch blocks as they might have been modified by removeBlockExit\n            // or the initial recursive calls.\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n\n            // Call for the 'then' branch perspective\n            // (Assumes tryMinimizeIfBlockExits is defined in the same class or accessible)\n             tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n            // Re-fetch blocks again as the call above might change them\n            trueBlock = ifTree.getFirstChild().getNext();\n            falseBlock = trueBlock.getNext();\n\n            // Call for the 'else' branch perspective (if else exists)\n            if (falseBlock != null) {\n               tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n            }\n          }\n        }\n        // TODO(johnlenz): Add similar logic for TRY? If try/catch both exit unconditionally?\n        // Might be complex due to error handling semantics.\n      } // End loop processing IF children\n  } // End if (n.isBlock()) for IF optimization\n\n\n  // --- Final step: Remove redundant exit statements at the end of BLOCKs ---\n  // This handles cases like: { stmt1; stmt2; EXIT; } -> { stmt1; stmt2; }\n  // Only applies if 'n' is a block.\n  if (n.isBlock()) {\n      // Use a loop because removing one exit might reveal another (e.g., if (x) return; return;)\n      while (true) {\n          Node currentLast = n.getLastChild();\n          if (currentLast == null) {\n              break; // Block is empty\n          }\n\n          // Skip finally blocks\n          if (NodeUtil.isFinallyBlock(currentLast)) {\n              break;\n          }\n\n          // Check if the effective last statement is the matching exit.\n          // blockEndsWithExit handles potential trailing empty statements.\n          if (blockEndsWithExit(n, exitType, labelName)) {\n              // removeBlockExit finds and removes the actual exit node at the end.\n              removeBlockExit(n, exitType, labelName);\n              // Continue the loop to check the new last child.\n          } else {\n              // If the effective last statement isn't the exit we're looking for, stop.\n              break;\n          }\n      } // End while loop removing redundant exits from tail.\n  } // End if (n.isBlock()) for tail cleanup\n}\n\n\n// --- Helper Functions assumed to be within the same class ---\n\n/** Reference to the compiler object for reporting changes. Needs initialization. */\n// private AbstractCompiler compiler;\n\n/** Assumed to exist and handle moving code following an IF into a non-exiting branch. */\n// abstract void tryMinimizeIfBlockExits(Node block, Node otherBlock,\n//     Node ifNode, int exitType, String labelName);\n\n/**\n * @return Whether the node is an exit node that matches the type and label.\n */\nprivate boolean matchingExitNode(Node n, int exitType, String labelName) {\n  if (n == null) {\n    return false;\n  }\n\n  switch (n.getType()) {\n    case Token.RETURN:\n      // Both \"return;\" and \"return value;\" are exits of type RETURN.\n      return exitType == Token.RETURN;\n\n    case Token.BREAK:\n      if (exitType == Token.BREAK) {\n        // Break statements must match the expected label name.\n        // null labelName means unlabeled break.\n        String breakLabel = n.getFirstChild() != null ?\n            n.getFirstChild().getString() : null;\n        // Use Objects.equal to handle null labelName correctly.\n        return Objects.equal(labelName, breakLabel);\n      }\n      break;\n\n    case Token.CONTINUE:\n      if (exitType == Token.CONTINUE) {\n        String continueLabel = n.getFirstChild() != null ?\n            n.getFirstChild().getString() : null;\n        return Objects.equal(labelName, continueLabel);\n      }\n      break;\n  }\n  return false;\n}\n\n/** Helper to check if the last effective statement in a block is a matching exit */\nprivate boolean blockEndsWithExit(Node block, int exitType, String labelName) {\n  if (block != null && block.isBlock() && block.hasChildren()) {\n    // Check the last effective statement, ignoring EMPTY nodes.\n    for (Node last = block.getLastChild(); last != null; last = last.getPrevious()) {\n        if (!last.isEmpty()) {\n            return matchingExitNode(last, exitType, labelName);\n        }\n    }\n  }\n  return false;\n}\n\n/** Helper to remove the last effective statement if it's a matching exit */\nprivate void removeBlockExit(Node block, int exitType, String labelName) {\n  if (block != null && block.isBlock() && block.hasChildren()) {\n    // Find the last effective statement to remove.\n    Node lastToRemove = null;\n    for (Node last = block.getLastChild(); last != null; last = last.getPrevious()) {\n        if (!last.isEmpty()) {\n            // Only mark for removal if it's the matching exit node.\n            if (matchingExitNode(last, exitType, labelName)) {\n                lastToRemove = last;\n            }\n            // We only care about the very last non-empty statement.\n            break;\n        }\n    }\n    if (lastToRemove != null) {\n        NodeUtil.removeChild(block, lastToRemove);\n        compiler.reportCodeChange();\n    }\n  }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}