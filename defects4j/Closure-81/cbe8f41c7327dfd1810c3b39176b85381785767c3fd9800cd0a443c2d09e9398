{
    "generation": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      // Keep track of whether the original function was unnamed (i.e., name == null)\n      boolean originalFunctionWasUnnamed = (name == null);\n\n      if (originalFunctionWasUnnamed) {\n        // If it's an unnamed function and NOT a function expression, it's an error.\n        // Function statements/declarations must have a name in JavaScript.\n        // Unnamed function expressions are allowed (e.g., (function() {})).\n        if (!functionNode.isFunctionExpression()) {\n          // This is an unnamed function statement, which is an error.\n          // Report the error with the expected message.\n          reportError(\"unnamed function statement\", functionNode);\n          // Despite the error, we proceed to create a dummy name node to allow\n          // the AST generation to continue. This is common in error-recovering\n          // parsers to collect all errors rather than stopping on the first one.\n          name = new Name();\n          name.setIdentifier(\"\"); // Empty identifier for the synthetic name\n        } else {\n          // It's an unnamed function expression, which is allowed.\n          // Create a dummy name node for the IR since there was no name in the source.\n          name = new Name();\n          name.setIdentifier(\"\"); // Empty identifier for unnamed function expressions\n        }\n      }\n\n      Node node = newNode(Token.FUNCTION);\n      // Transform the (possibly synthetic) name node.\n      Node newName = transform(name);\n\n      // Apply line/column info to the synthetic name node for unnamed functions.\n      // This logic is relevant if the function was originally unnamed, regardless\n      // of whether it was an expression or a problematic statement.\n      if (originalFunctionWasUnnamed) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      // Note: fnName here refers to the *original* Rhino function name, before\n      // any synthetic name was created for the IR.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        // If the original function was unnamed (either an expression or a problematic\n        // statement), use the function node's line number for the left paren.\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}