{
    "generation": "import com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.parsing.Config; // Assuming part of the context/class\nimport com.google.javascript.jscomp.parsing.IRFactory; // Assuming this is the base class or similar\nimport com.google.javascript.jscomp.parsing.RhinoErrorReporter; // For PARSE_ERROR DiagnosticType\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport org.mozilla.javascript.ast.AstNode;\nimport org.mozilla.javascript.ast.FunctionNode;\nimport org.mozilla.javascript.ast.Name;\n\n// NOTE: This code snippet assumes it is part of a larger class (like IRFactory or a subclass)\n// that provides context like 'errorReporter', 'sourceName', 'newNode', 'transform',\n// 'position2charno', 'setSourceInfo', and 'parseDirectives'. The exact implementation\n// of these helper methods and the availability of instance variables like 'errorReporter'\n// depend on the surrounding class structure in the Closure Compiler codebase.\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      boolean isUnnamedFunction = (name == null || name.getIdentifier().isEmpty());\n      // Use empty string for unnamed functions, otherwise use the identifier.\n      String functionName = isUnnamedFunction ? \"\" : name.getIdentifier();\n\n      // Function declarations (statements) cannot be unnamed in standard JS.\n      // Report an error if an unnamed function is encountered in a statement context.\n      if (isUnnamedFunction && functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {\n        // Assumes 'this.errorReporter' and 'this.sourceName' are available instance members.\n        // Assumes RhinoErrorReporter.PARSE_ERROR is the correct DiagnosticType constant.\n        this.errorReporter.report(\n            CheckLevel.ERROR,\n            RhinoErrorReporter.PARSE_ERROR, // Use the appropriate error type constant\n            \"unnamed function statement\",   // The error message expected by the test.\n            this.sourceName,                // Source file name.\n            functionNode.getLineno(),       // Line number of the 'function' keyword.\n            position2charno(functionNode.getAbsolutePosition())); // Column number of 'function'.\n        // Note: Even with the error, we proceed to build a node structure\n        // similar to an unnamed function expression. This might allow some further\n        // analysis, although the compilation should ultimately fail due to the syntax error.\n      }\n\n      Node node = newNode(Token.FUNCTION);\n      // Create the NAME node for the function.\n      // Closure Compiler's AST requires a NAME node as the first child of FUNCTION,\n      // even for anonymous functions (where the NAME node's string is empty).\n      Node newName = newNode(Token.NAME);\n      newName.setString(functionName); // Set identifier (or empty string).\n\n      if (isUnnamedFunction) {\n        // For unnamed functions, set the position of the empty NAME node\n        // based on the original logic: line of 'function' keyword, charno of '('.\n        // This provides a source location anchor for the unnamed function.\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        // Copy source file info etc. from the function node if a helper exists.\n        // setSourceInfo(newName, functionNode); // Assuming setSourceInfo helper exists\n      } else {\n        // For named functions, use the position from the original Name AstNode.\n        newName.setLineno(name.getLineno());\n        newName.setCharno(position2charno(name.getAbsolutePosition()));\n        // Copy source file info etc. from the name node if a helper exists.\n        // setSourceInfo(newName, name); // Assuming setSourceInfo helper exists\n      }\n      node.addChildToBack(newName); // Add the NAME node.\n\n      // Create the PARAM_LIST node for parameters. This corrects the original code's\n      // use of Token.LP, which is inappropriate for the parameter list container.\n      Node params = newNode(Token.PARAM_LIST);\n      // Set source position for PARAM_LIST based on the '('.\n      // Use the original line number logic: use name's line if available, else function's line.\n      if (name != null) {\n         // Function has a name, use its line number for the parameter list start.\n         params.setLineno(name.getLineno());\n      } else {\n         // Function is unnamed, use the function keyword's line number.\n         params.setLineno(functionNode.getLineno());\n      }\n      // Calculate the character number of the left parenthesis.\n      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n      params.setCharno(position2charno(lparenCharno));\n      // Copy source file info etc. from the function node if a helper exists.\n      // setSourceInfo(params, functionNode); // Assuming setSourceInfo helper exists\n\n      // Recursively transform and add parameter nodes to the PARAM_LIST.\n      for (AstNode param : functionNode.getParams()) {\n        params.addChildToBack(transform(param));\n      }\n      node.addChildToBack(params); // Add PARAM_LIST node.\n\n      // Transform the function body (which is usually a BLOCK node).\n      Node bodyNode = transform(functionNode.getBody());\n      // Process directives like \"use strict\" found at the beginning of the body.\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode); // Add BODY node.\n\n      // Set overall source information for the FUNCTION node itself if a helper exists.\n      // setSourceInfo(node, functionNode); // Assuming setSourceInfo helper exists\n\n      return node;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}