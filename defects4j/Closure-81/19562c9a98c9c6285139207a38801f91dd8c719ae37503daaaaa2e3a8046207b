{
    "generation": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      boolean isUnnamedFunction = false; // Use boolean primitive\n      if (name == null) {\n        // An unnamed function. This is legal for function expressions,\n        // but not for function statements. The parser should catch\n        // errors for unnamed function statements. If it slips through,\n        // we create the standard IR for an unnamed function expression.\n        name = new Name();\n        // Position the synthetic Name node at the start of the function keyword.\n        // Ensure the position is set before transforming.\n        name.setPosition(functionNode.getAbsolutePosition());\n        name.setLength(0); // Length is zero for an empty name.\n        // Set line number explicitly based on the function node.\n        name.setLineno(functionNode.getLineno());\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n\n      // Create the main FUNCTION node\n      Node node = newNode(Token.FUNCTION);\n      // Copy source information from the FunctionNode to the FUNCTION node\n      setSourceInfo(node, functionNode);\n\n      // 1. Child: Function Name (possibly the synthetic empty Name node)\n      Node newName = transform(name);\n      // Ensure the synthetic name node has the correct line and char number\n      // after transformation, using the function keyword's start position.\n      if (isUnnamedFunction) {\n          newName.setLineno(functionNode.getLineno());\n          newName.setCharno(position2charno(functionNode.getAbsolutePosition()));\n      }\n      node.addChildToBack(newName);\n\n      // 2. Child: Parameter List\n      // Node lp = newNode(Token.LP); // Original Bug: Used LP token for parameter list\n      Node paramList = newNode(Token.PARAM_LIST); // Correct Token: PARAM_LIST\n\n      // Set source information for the parameter list, typically mapping to the '('.\n      // The line number might be the same as the function or the name; use function's line as fallback.\n      // Rhino AST often doesn't provide precise line number for '(' if name exists.\n      // Using functionNode line is a safe approximation.\n      paramList.setLineno(functionNode.getLineno());\n      // Calculate the absolute character offset of the '('. getLp() returns the offset\n      // relative to the function node's start.\n      int lparenAbsolutePos = functionNode.getAbsolutePosition() + functionNode.getLp();\n      paramList.setCharno(position2charno(lparenAbsolutePos));\n      // We don't easily know the end ')' position, so length isn't set here.\n\n      // Add transformed parameters to the PARAM_LIST node\n      for (AstNode param : functionNode.getParams()) {\n        // lp.addChildToBack(transform(param)); // Original Bug: Added params to LP node\n        paramList.addChildToBack(transform(param)); // Correct: Add params to PARAM_LIST node\n      }\n      // node.addChildToBack(lp); // Original Bug: Added LP node as second child\n      node.addChildToBack(paramList); // Correct: Add PARAM_LIST node as second child\n\n      // 3. Child: Function Body\n      Node bodyNode = transform(functionNode.getBody());\n      // parseDirectives should be called on the BLOCK node representing the function body.\n      // Assuming transform(functionNode.getBody()) returns this BLOCK node.\n      parseDirectives(bodyNode); // Process \"use strict\" etc. directives.\n      node.addChildToBack(bodyNode);\n\n      return node;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}