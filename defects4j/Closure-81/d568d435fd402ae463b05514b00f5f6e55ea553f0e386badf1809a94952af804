{
    "generation": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      // Check for unnamed function statement error (ES6 spec allows them only as expressions)\n      // Note: This doesn't handle `export default function() {}` which is legal in ES6 modules.\n      // That check should ideally happen in the context of processing the export statement.\n      if (functionNode.isFunctionDeclaration() && functionNode.getFunctionName() == null) {\n        // Report error for Function declarations that must have a name.\n        reportError(ParseError.UNNAMED_FUNCTION_STATEMENT,\n            functionNode.getLineno(),\n            position2charno(functionNode.getAbsolutePosition()));\n        // Return an empty node to indicate the error but allow parsing to continue.\n        return newNode(Token.EMPTY);\n      }\n\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false; // Keep Boolean wrapper object as in original code\n      if (name == null) {\n        // This case should now only be reached for function expressions\n        name = new Name();\n        name.setIdentifier(\"\");\n        // Assign position info to the synthetic name node using the function node's position.\n        // The subsequent block might adjust this based on original Rhino behavior.\n        name.setPosition(functionNode.getAbsolutePosition());\n        name.setLength(0); // Synthetic node has zero length identifier\n        setSourceInfo(name, name); // Set line/char based on the position.\n        isUnnamedFunction = true;\n      }\n\n      Node node = newNode(Token.FUNCTION);\n      setSourceInfo(node, functionNode); // Set source info for the Function node itself\n\n      Node newName = transform(name);\n\n      // Original logic to adjust empty name node's position info:\n      // This targets the location where the name *would* be, often near the '('.\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration (the function keyword).\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        // Calculate column based on LP offset from function start.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        // Convert absolute position + offset to char number on the line.\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n\n      // Create the parameter list node. Original code used LP, assume newNode(Token.LP)\n      // creates the correct PARAM_LIST node type expected by the rest of the compiler.\n      Node lp = newNode(Token.LP); // Should represent PARAM_LIST\n      // Set source info for the parameter list (paren '(' position)\n      // Original logic with comments about potential inaccuracy:\n      Name fnName = functionNode.getFunctionName(); // Fetch original name again\n      if (fnName != null) {\n        // If name exists, assume paren is on the same line as name. (Potentially flawed)\n        lp.setLineno(fnName.getLineno());\n      } else {\n        // If no name (expression), assume paren is on the same line as 'function'. (Potentially flawed)\n        lp.setLineno(functionNode.getLineno());\n      }\n      // Calculate char position based on LP offset from function start.\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n      lp.setCharno(position2charno(lparenCharno));\n\n\n      // Add parameters\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp); // Add Param list node\n\n      // Process function body\n      Node bodyNode = transform(functionNode.getBody());\n      // Ensure the body node (likely a BLOCK) has source information.\n      // transform() should generally handle this, but explicitly setting it ensures correctness.\n      if (bodyNode != null && functionNode.getBody() != null) {\n          setSourceInfo(bodyNode, functionNode.getBody());\n      }\n      parseDirectives(bodyNode); // Process 'use strict' etc.\n      node.addChildToBack(bodyNode);\n\n      // Set flags like generator/async if applicable\n      if (functionNode.isGenerator()) {\n         node.setIsGeneratorFunction(true);\n      }\n      // if (functionNode.isAsync()) { node.setIsAsyncFunction(true); } // Add if needed\n\n     return node;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}