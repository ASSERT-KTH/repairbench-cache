{
    "generation": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      boolean isUnnamedFunction = (name == null);\n\n      // An unnamed function statement is not syntactically valid.\n      // \"function () {}\" is not allowed, but \"var f = function () {};\"\n      // or \"(function () {})();\" are allowed.\n      if (isUnnamedFunction && functionNode.isFunctionDeclaration()) {\n        errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        // Return an empty node to avoid NPEs downstream, though the error\n        // reporting should ideally halt compilation or handle it gracefully.\n        return newNode(Token.EMPTY);\n      }\n\n      Node node = newNode(Token.FUNCTION);\n      Node newName;\n      if (isUnnamedFunction) {\n        // Create a new empty name node.\n        // We need to give it the right source information. Use the position\n        // of the left parenthesis as the position of the name node.\n        name = new Name();\n        name.setIdentifier(\"\");\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        // We don't have the line number of the LP, so use the function's line.\n        name.setPosition(lpColumn);\n        name.setLength(1); // Give it length 1 to make it represent the paren.\n        name.setLineno(functionNode.getLineno()); // Approximate line number.\n\n        newName = transform(name);\n        // Adjust the charno to be 0-based for the compiler node.\n        newName.setCharno(position2charno(lpColumn));\n\n      } else {\n        newName = transform(name);\n      }\n\n      node.addChildToBack(newName); // Add NAME node (possibly empty)\n\n      // Process parameters: create PARAM_LIST node\n      Node paramsNode = newNode(Token.PARAM_LIST);\n      // Set the position of the PARAM_LIST node based on the left parenthesis.\n      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n      // Again, we don't have the exact line number of the '('.\n      // Using the function's line number is an approximation.\n      paramsNode.setLineno(functionNode.getLineno());\n      paramsNode.setCharno(position2charno(lparenCharno));\n\n      for (AstNode param : functionNode.getParams()) {\n        paramsNode.addChildToBack(transform(param));\n      }\n      node.addChildToBack(paramsNode); // Add PARAM_LIST node as the second child\n\n      // Process the function body\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode); // Add BLOCK node as the third child\n\n     return node;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}