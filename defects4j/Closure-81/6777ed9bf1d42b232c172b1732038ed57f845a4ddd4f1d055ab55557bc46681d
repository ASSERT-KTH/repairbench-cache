{
    "generation": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      boolean isUnnamedFunction = false; // Use boolean primitive type\n\n      // Check for unnamed function statements, which are illegal syntax.\n      // Function expressions can be unnamed.\n      if (name == null) {\n        if (functionNode.isFunctionDeclaration()) {\n          // Report the error, mimicking what the parser should have done.\n          errorReporter.error(\n              \"unnamed function statement\",\n              sourceName, // Assuming 'sourceName' is an accessible member variable\n              functionNode.getLineno(),\n              position2charno(functionNode.getAbsolutePosition())\n          );\n          // Even though it's an error, proceed with creating the node structure\n          // using a dummy name to avoid potential NPEs downstream. The error\n          // has been reported, so the compilation will likely fail anyway.\n        }\n        // Create a dummy name node for all unnamed functions (expressions or illegal statements).\n        name = new Name();\n        name.setIdentifier(\"\");\n        // Ensure the dummy name has position information for source mapping.\n        name.setPosition(functionNode.getAbsolutePosition());\n        // Rhino doesn't provide specific position for the name node if it's absent,\n        // so use the function node's position.\n        isUnnamedFunction = true;\n      }\n\n      Node node = newNode(Token.FUNCTION);\n      // 'name' is now either the original Name node or the dummy \"\" Name node.\n      Node newName = transform(name);\n\n      if (isUnnamedFunction) {\n        // If it was an unnamed function (expression or illegal statement),\n        // set the line/char number on the empty name node.\n        // The original code used the line of the function keyword and the\n        // char of the left paren. Let's preserve that, although it's slightly odd.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n\n      // Process Params (parameters list represented by LP node)\n      Node lp = newNode(Token.LP);\n      // Position the LP node.\n      // Use the original function name node if available for better accuracy.\n      Name originalFnName = functionNode.getFunctionName();\n      if (originalFnName != null) {\n        // If there's a name, the paren should ideally be on the same line.\n        lp.setLineno(originalFnName.getLineno());\n      } else {\n        // If no name, assume paren is on the same line as the 'function' keyword.\n        lp.setLineno(functionNode.getLineno());\n      }\n      // Calculate the character position of the left parenthesis.\n      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n      lp.setCharno(position2charno(lparenCharno));\n\n      // Add params to the LP node\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      // Process Function Body\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode); // Process \"use strict\" and similar directives\n      node.addChildToBack(bodyNode);\n\n      return node;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}