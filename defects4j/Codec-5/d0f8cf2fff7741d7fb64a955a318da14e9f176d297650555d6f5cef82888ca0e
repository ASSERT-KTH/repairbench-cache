{
    "generation": "    void decode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n            // If we're at EOF and have unfinished business, finish it\n            if (modulus != 0 && buffer != null) {\n                x = x << 6;\n                switch (modulus) {\n                    case 2 :\n                        x = x << 6;\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        break;\n                    case 3 :\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                        break;\n                }\n            }\n        }\n        for (int i = 0; i < inAvail; i++) {\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            // Check if buffer is initialized before using it\n            if (buffer != null) {\n                x = x << 6;\n                switch (modulus) {\n                    case 2 :\n                        x = x << 6;\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        break;\n                    case 3 :\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                        break;\n                }\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}