{
    "generation": "void decode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n    }\n\n    for (int i = 0; i < inAvail; i++) {\n        // Always ensure there\u2019s room for writing decoded output.\n        if (buffer == null || buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        byte b = in[inPos++];\n        if (b == PAD) {\n            // Encountered padding \u2013 signal EOF and stop processing.\n            eof = true;\n            break;\n        }\n        if (b >= 0 && b < DECODE_TABLE.length) {\n            int result = DECODE_TABLE[b];\n            if (result >= 0) {\n                modulus = (++modulus) % 4;\n                x = (x << 6) + result;\n                if (modulus == 0) {\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    buffer[pos++] = (byte) (x & MASK_8BITS);\n                }\n            }\n        }\n    }\n    \n    // If we've reached EOF and have a partial quantum, flush the remaining bits.\n    if (eof && modulus != 0) {\n        if (buffer == null || buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        x = x << 6;\n        switch (modulus) {\n            case 2:\n                x = x << 6;\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                break;\n            case 3:\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                break;\n        }\n    }\n    \n    // FIX for CODEC-98: make sure that even if no data was decoded,\n    // the internal buffer is not left null.\n    if (buffer == null) {\n        buffer = new byte[0];\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}