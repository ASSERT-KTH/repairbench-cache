{
    "generation": "    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes.  Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached.  The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too.  This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     *     http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding, or -1 on EOF.\n     */\n    void decode(byte[] in, int inPos, int inAvail) {\n        // If we've already hit EOF on a prior call and this is not the final (-1) flush,\n        // just return.\n        if (eof && inAvail >= 0) {\n            return;\n        }\n        // Mark EOF on a -1 call\n        if (inAvail < 0) {\n            eof = true;\n        }\n\n        // Main decode loop\n        for (int i = 0; i < inAvail; i++) {\n            // Ensure we have room for at least a full decode block\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            // Padding character: end of meaningful data\n            if (b == PAD) {\n                eof = true;\n                break;\n            }\n            // Only decode bytes in the table\n            if (b >= 0 && b < DECODE_TABLE.length) {\n                int result = DECODE_TABLE[b];\n                if (result >= 0) {\n                    modulus = (++modulus) % 4;\n                    x = (x << 6) + result;\n                    // Whenever we've seen 4 6-bit values, write out 3 bytes\n                    if (modulus == 0) {\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        buffer[pos++] = (byte) ((x >> 8)  & MASK_8BITS);\n                        buffer[pos++] = (byte) ( x        & MASK_8BITS);\n                    }\n                }\n            }\n        }\n\n        // If we're at EOF (either -1 call or saw '=') and there's a partial quantum, flush it\n        if (eof && modulus != 0) {\n            // Make sure there's room for up to 2 more bytes\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            x <<= 6;\n            switch (modulus) {\n                case 2:\n                    x <<= 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3:\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8)  & MASK_8BITS);\n                    break;\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}