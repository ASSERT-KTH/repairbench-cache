{
    "generation": "    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     * @param context the context to be used\n     *\n     * N.B. The context parameter is unused but is required by the abstract base class.\n     */\n    @Override\n    void decode(byte[] in, int inPos, int inAvail, Context context) {\n        if (context.eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            context.eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n            final byte b = in[inPos++];\n            if (b == pad) {\n                // We're done.\n                context.eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    final int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\n                        context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\n                        if (context.modulus == 0) {\n                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n                            buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (context.eof && context.modulus != 0) {\n            final byte[] buffer = ensureBufferSize(decodeSize, context);\n\n            // We have some spare bits remaining\n            // Output all whole multiples of 8 bits and ignore the rest\n            context.ibitWorkArea = context.ibitWorkArea << BITS_PER_ENCODED_BYTE; // Shift in 6 bits worth of padding.\n            switch (context.modulus) {\n                case 2 : // We have 2 bytes -> 12 bits -> 1 output byte\n                    context.ibitWorkArea = context.ibitWorkArea << BITS_PER_ENCODED_BYTE; // Shift in another 6 bits worth of padding.\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n                    break;\n                case 3 : // We have 3 bytes -> 18 bits -> 2 output bytes\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\n                    buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\n                    break;\n                default:\n                    // Should not happen. Modulus must be 0, 1, 2 or 3. Put exception here if we want to be picky.\n            }\n        }\n    }\n\n    // Note: The original buggy code was missing the context parameter and used instance fields directly.\n    // The fixed code assumes the context object holds the state (eof, modulus, ibitWorkArea, buffer, pos)\n    // and uses ensureBufferSize for buffer management, which internally calls resizeBuffer if needed.\n    // The core logic fix is ensuring the buffer is ready before writing the final bytes when EOF is reached.\n    // Since the original code snippet was partial (missing class context, fields like MASK_8BITS, PAD, DECODE_TABLE, decodeSize, resizeBuffer, buffer, pos, modulus, x, eof),\n    // I've adapted the fix based on the likely structure of the surrounding BaseNCodec class from Apache Commons Codec,\n    // using context object and ensureBufferSize as is standard there. The key change is adding the `ensureBufferSize`\n    // call within the `if (context.eof && context.modulus != 0)` block.\n\n    // Minimal fix applied to the provided snippet structure (assuming fields exist on the instance):\n    /**\n     * <p>\n     * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n     * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n     * call is not necessary when decoding, but it doesn't hurt, either.\n     * </p>\n     * <p>\n     * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n     * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n     * garbage-out philosophy: it will not check the provided data for validity.\n     * </p>\n     * <p>\n     * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n     * </p>\n     *\n     * @param in\n     *            byte[] array of ascii data to base64 decode.\n     * @param inPos\n     *            Position to start reading data from.\n     * @param inAvail\n     *            Amount of bytes available from input for encoding.\n     */\n    void decode(byte[] in, int inPos, int inAvail) { // Assuming instance fields: eof, buffer, pos, decodeSize, PAD, DECODE_TABLE, modulus, x, MASK_8BITS, resizeBuffer()\n        if (eof) {\n            return;\n        }\n        if (inAvail < 0) {\n            eof = true;\n        }\n        for (int i = 0; i < inAvail; i++) {\n            // Ensure buffer has space for potential output of 3 bytes\n            if (buffer == null || buffer.length - pos < decodeSize) {\n                resizeBuffer();\n            }\n            byte b = in[inPos++];\n            if (b == PAD) {\n                // We're done.\n                eof = true;\n                break;\n            } else {\n                if (b >= 0 && b < DECODE_TABLE.length) {\n                    int result = DECODE_TABLE[b];\n                    if (result >= 0) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + result;\n                        if (modulus == 0) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (eof && modulus != 0) {\n            // Ensure buffer has space for final output (max 2 bytes)\n            // Using decodeSize (likely 3) is safe check\n            if (buffer == null || buffer.length - pos < decodeSize) { // FIX: Added this check\n                resizeBuffer();\n            }\n\n            x = x << 6;\n            switch (modulus) {\n                case 2 :\n                    x = x << 6;\n                    // Final check assumes resizeBuffer succeeded if called. Write the byte.\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    break;\n                case 3 :\n                    // Final check assumes resizeBuffer succeeded if called. Write the bytes.\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    break;\n                // case 0 and 1 should not happen here because modulus != 0 is checked.\n            }\n        }\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}