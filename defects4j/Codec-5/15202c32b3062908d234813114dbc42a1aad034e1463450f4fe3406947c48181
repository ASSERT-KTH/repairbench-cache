{
    "generation": "void decode(byte[] in, int inPos, int inAvail) {\n    if (eof || in == null) {\n        return;\n    }\n    boolean wasEof = eof;\n    eof = (inAvail < 0);\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        byte b = in[inPos++];\n        if (b == PAD) {\n            // We're done.\n            eof = true;\n            break;\n        } else {\n            if (b >= 0 && b < DECODE_TABLE.length) {\n                int result = DECODE_TABLE[b];\n                if (result >= 0) {\n                    modulus = (++modulus) % 4;\n                    x = (x << 6) + result;\n                    if (modulus == 0) {\n                        // Now, output the 3 characters\n                        if (buffer != null) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // If we reach this point, either we've processed the entire input or have encountered end of file.\n    if (wasEof || eof) {\n        // Check if we have left-over data to process\n        if (modulus > 0) {\n            // No enough data to process final characters\n            // So, do a partial decode\n            if (modulus == 2) {\n                x = x << 6;\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n            } else if (modulus == 3) {\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n            }\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}