{
    "generation": "/**\n * <p>\n * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once\n * with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\"\n * call is not necessary when decoding, but it doesn't hurt, either.\n * </p>\n * <p>\n * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are\n * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in,\n * garbage-out philosophy: it will not check the provided data for validity.\n * </p>\n * <p>\n * Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach.\n * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/\n * </p>\n * \n * @param in\n *            byte[] array of ascii data to base64 decode.\n * @param inPos\n *            Position to start reading data from.\n * @param inAvail\n *            Amount of bytes available from input for encoding.\n */\nvoid decode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n    }\n    // ensure we have a buffer before any work to avoid NPE later\n    if (buffer == null) {\n        resizeBuffer();\n    }\n    for (int i = 0; i < inAvail; i++) {\n        // make sure there is room for at least one more decode block\n        if (buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        byte b = in[inPos++];\n        if (b == PAD) {\n            // padding character: we are done\n            eof = true;\n            break;\n        }\n        if (b >= 0 && b < DECODE_TABLE.length) {\n            int result = DECODE_TABLE[b];\n            if (result >= 0) {\n                modulus = (++modulus) % 4;\n                x = (x << 6) + result;\n                if (modulus == 0) {\n                    // we have 4 valid base64 chars, emit 3 bytes\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                    buffer[pos++] = (byte) (x & MASK_8BITS);\n                }\n            }\n        }\n    }\n    // handle leftover bits at EOF or upon first '='\n    if (eof && modulus != 0) {\n        // ensure room for the final one or two bytes\n        if (buffer.length - pos < decodeSize) {\n            resizeBuffer();\n        }\n        x <<= 6;\n        switch (modulus) {\n            case 2:\n                // two base64 chars = one byte\n                x <<= 6;\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                break;\n            case 3:\n                // three base64 chars = two bytes\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                break;\n            default:\n                // no action\n                break;\n        }\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}