{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            // LZMA properties format: (lc, lp, pb), dictSize_4bytes\n            // Ensure properties array is valid and long enough (at least 5 bytes)\n            // Note: Original code didn't check length, assuming valid input based on context.\n            // We retain that assumption to minimize changes, but robust code might add a check.\n            // if (coder.properties == null || coder.properties.length < 5) {\n            //     throw new IOException(\"LZMA Coder properties are corrupt or missing\");\n            // }\n\n            byte propsByte = coder.properties[0];\n            // Dictionary size is a 32-bit unsigned integer in little-endian order.\n            // Read bytes 1 to 4, treating them as unsigned to avoid issues with sign extension\n            // when bytes >= 0x80 are promoted to int before shifting.\n            long dictSize = coder.properties[1] & 0xFF;\n            dictSize |= ((long)(coder.properties[2] & 0xFF) << 8);\n            dictSize |= ((long)(coder.properties[3] & 0xFF) << 16);\n            dictSize |= ((long)(coder.properties[4] & 0xFF) << 24);\n\n            // The org.tukaani.xz.LZMAInputStream constructor takes the dictionary size as an int.\n            // Internally, it uses org.tukaani.xz.LZMADecoder which validates that the\n            // dictionary size is not negative and does not exceed Integer.MAX_VALUE (2GiB - 1).\n            // See org.tukaani.xz.LZMADecoder constructor.\n            // Therefore, the practical maximum dictionary size is Integer.MAX_VALUE.\n            // The original check used a potentially different constant (LZMAInputStream.DICT_SIZE_MAX)\n            // which might be 4GiB-1, leading to incorrect validation before the int cast.\n            if (dictSize > Integer.MAX_VALUE) {\n                // Throw an exception consistent with the actual limitation.\n                throw new IOException(\"Dictionary larger than \" + Integer.MAX_VALUE + \" bytes maximum size\");\n            }\n\n            // Pass -1 for uncompressed size (unknown in this context).\n            // Cast dictSize to int. This is safe now because we've ensured it's within the valid range [0, Integer.MAX_VALUE].\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}