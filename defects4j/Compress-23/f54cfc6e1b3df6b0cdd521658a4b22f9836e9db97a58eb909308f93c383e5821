{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            // The dictionary size is a 4-byte little-endian integer starting at coder.properties[1].\n            // Bytes must be treated as unsigned when combining them to avoid sign-extension issues.\n            // Use 0xFFL to ensure the initial byte is treated as an unsigned long.\n            long dictSize = coder.properties[1] & 0xFFL;\n            for (int i = 1; i < 4; i++) {\n                // For subsequent bytes, mask with 0xFF to treat as unsigned, then cast to long before shifting\n                // to prevent potential sign-extension when shifting a negative byte value.\n                dictSize |= (long) (coder.properties[i + 1] & 0xFF) << (8 * i);\n            }\n\n            // LZMAInputStream.DICT_SIZE_MAX is typically Integer.MAX_VALUE (2GiB - 1).\n            // If the correctly calculated dictSize exceeds this, throw an IOException.\n            // The original message \"Dictionary larger than 4GiB maximum size\" might refer\n            // to a different LZMA variant or an architectural limit, but the check\n            // against LZMAInputStream.DICT_SIZE_MAX is correct for this specific implementation.\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            // After the corrections, dictSize is guaranteed to be a positive value\n            // within the range of Integer.MAX_VALUE (if it passed the check),\n            // making the cast to int safe for the LZMAInputStream constructor.\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}