{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            \n            // Parse the dictionary size from coder.properties bytes 1-4.\n            // These bytes represent a 4-byte little-endian unsigned integer.\n            long dictSizeLong = coder.properties[1] & 0xFFL;\n            for (int i = 1; i < 4; i++) {\n                dictSizeLong |= ((long) (coder.properties[i + 1] & 0xFFL) << (8 * i));\n            }\n\n            // org.tukaani.xz.LZMAInputStream has specific requirements for dictionary size:\n            // 1. It must be an integer (up to 128 MiB).\n            // 2. It must be between LZMAInputStream.DICT_SIZE_MIN (2 MiB) and LZMAInputStream.DICT_SIZE_MAX (128 MiB) inclusive.\n            // 3. It must be a power of two.\n\n            // First, check if the raw dictionary size from the archive is too large for this LZMA implementation.\n            // The actual limit for tukaani.xz.LZMAInputStream is 128 MiB.\n            if (dictSizeLong > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than \"\n                                      + (LZMAInputStream.DICT_SIZE_MAX / (1024 * 1024))\n                                      + \" MiB maximum size allowed by LZMAInputStream: \"\n                                      + dictSizeLong + \" bytes\");\n            }\n            \n            int dictSize = (int) dictSizeLong;\n\n            // Ensure dictionary size is at least the minimum required by LZMAInputStream.\n            // If the parsed dictSize is smaller than the minimum, round it up to the minimum.\n            if (dictSize < LZMAInputStream.DICT_SIZE_MIN) {\n                dictSize = LZMAInputStream.DICT_SIZE_MIN;\n            }\n\n            // Round up dictSize to the next power of two if it's not already one.\n            // This is crucial for satisfying the LZMAInputStream constructor's requirement.\n            // If dictSize is already a power of two, (dictSize & (dictSize - 1)) will be 0.\n            // If it's not a power of two, Integer.highestOneBit(dictSize) << 1 gives the next power of two.\n            if ((dictSize & (dictSize - 1)) != 0) { // Check if not a power of two\n                dictSize = Integer.highestOneBit(dictSize) << 1;\n            }\n\n            // At this point, dictSize should be a power of two and within the valid range\n            // (2 MiB to 128 MiB), due to the initial check against DICT_SIZE_MAX and the\n            // rounding/min fallback. No further checks are strictly necessary for the\n            // tukaani.xz.LZMAInputStream constructor parameters.\n\n            return new LZMAInputStream(in, -1, propsByte, dictSize);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}