{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            // Dictionary size is a 4-byte little-endian integer starting at properties[1].\n            // Each byte needs to be treated as unsigned to prevent sign extension issues\n            // when combining them into a long.\n            long dictSize = coder.properties[1] & 0xFFL; // Start with the least significant byte, unsigned\n            for (int i = 1; i < 4; i++) {\n                // Shift the next byte (properties[i+1]) into position.\n                // Mask with 0xFFL to ensure it's treated as an unsigned value before shifting.\n                dictSize |= (coder.properties[i + 1] & 0xFFL) << (8 * i);\n            }\n            // LZMAInputStream.DICT_SIZE_MAX represents the maximum dictionary size\n            // supported by the tukaani.xz LZMAInputStream, which is Integer.MAX_VALUE (approx. 2 GiB).\n            // The constructor for LZMAInputStream takes an 'int' for dictionarySize,\n            // so dictSize (long) must fit within an int.\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                // The original exception message incorrectly stated \"4GiB maximum size\".\n                // The actual maximum supported by tukaani.xz LZMAInputStream is 2GiB.\n                throw new IOException(\"Dictionary larger than 2GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}