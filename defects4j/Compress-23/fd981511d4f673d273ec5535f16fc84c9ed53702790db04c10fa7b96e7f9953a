{
    "generation": "        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            // Properties: lc, lp, pb (1 byte); Dictionary size (4 bytes, unsigned little endian)\n            // See https://www.7-zip.org/7zFormat.txt section 2.1.1 LZMA\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1] & 0xFFL; // Read byte 1 as unsigned long\n            for (int i = 1; i < 4; i++) {\n                // Read bytes 2, 3, 4 as unsigned longs and shift them\n                dictSize |= ((coder.properties[i + 1] & 0xFFL) << (8 * i));\n            }\n\n            // The dictionary size stored in the 7z header is a 32-bit unsigned integer.\n            // However, the LZMAInputStream constructor (and the underlying tukaani.xz library)\n            // takes the dictionary size as a signed int.\n            // Java arrays (used for dictionary) are limited to Integer.MAX_VALUE elements.\n            // Therefore, we must check if the dictionary size exceeds Integer.MAX_VALUE.\n            if (dictSize > Integer.MAX_VALUE) {\n                throw new IOException(\"Dictionary size \" + dictSize + \" is too large for this implementation (max: \" + Integer.MAX_VALUE + \")\");\n            }\n\n            // The constructor requires the dictionary size as an int.\n            // Since we've checked dictSize <= Integer.MAX_VALUE, this cast is safe.\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}