{
    "generation": "/**\n * Build the rotation that transforms a pair of vector into another pair.\n *\n * <p>Except for possible scale factors, if the instance were applied to\n * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n * (v<sub>1</sub>, v<sub>2</sub>).</p>\n *\n * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n * not the same as the angular separation between v<sub>1</sub> and\n * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n * v<sub>2</sub>) plane.</p>\n *\n * @param u1 first vector of the origin pair\n * @param u2 second vector of the origin pair\n * @param v1 desired image of u1 by the rotation\n * @param v2 desired image of u2 by the rotation\n * @exception IllegalArgumentException if the norm of one of the vectors is zero\n */\npublic Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n  // norms computation\n  double u1u1 = u1.getNormSq();\n  double u2u2 = u2.getNormSq();\n  double v1v1 = v1.getNormSq();\n  double v2v2 = v2.getNormSq();\n  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n  }\n\n  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n  v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n  // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n  double u1u2   = u1.dotProduct(u2);\n  double v1v2   = v1.dotProduct(v2);\n  double coeffU = u1u2 / u1u1;\n  double coeffV = v1v2 / u1u1;\n  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n  double alpha  = coeffU - beta * coeffV;\n  v2 = new Vector3D(alpha, v1, beta, v2);\n\n  // build the rotation matrix\n  double[][] m = new double[3][3];\n\n  // we know that u1 and v1 have the same norm, and that u2 and v2 have the same norm\n  Vector3D u3 = Vector3D.crossProduct(u1, u2);\n  Vector3D v3 = Vector3D.crossProduct(v1, v2);\n  double u3Norm = u3.getNorm();\n  double v3Norm = v3.getNorm();\n  \n  if (u3Norm < 1.0e-15 || v3Norm < 1.0e-15) {\n    // the vectors are almost aligned, we need another approach\n    // if one of the vectors in aligned with the other, we are in the identity case\n    if (u1.dotProduct(u2) < 0) {\n      // the vectors are almost opposite\n      Vector3D u1Normalized = new Vector3D(1.0 / FastMath.sqrt(u1u1), u1);\n      q0 = 0.0;\n      if (FastMath.abs(u1Normalized.getX()) < 0.8) {\n        double inv = 1.0 / FastMath.sqrt(1.0 - u1Normalized.getX() * u1Normalized.getX());\n        q1 = 0.0;\n        q2 = u1Normalized.getZ() * inv;\n        q3 = -u1Normalized.getY() * inv;\n      } else if (FastMath.abs(u1Normalized.getY()) < 0.8) {\n        double inv = 1.0 / FastMath.sqrt(1.0 - u1Normalized.getY() * u1Normalized.getY());\n        q1 = -u1Normalized.getZ() * inv;\n        q2 = 0.0;\n        q3 = u1Normalized.getX() * inv;\n      } else {\n        double inv = 1.0 / FastMath.sqrt(1.0 - u1Normalized.getZ() * u1Normalized.getZ());\n        q1 = u1Normalized.getY() * inv;\n        q2 = -u1Normalized.getX() * inv;\n        q3 = 0.0;\n      }\n      return;\n    }\n    \n    // Identity rotation\n    q0 = 1.0;\n    q1 = 0.0;\n    q2 = 0.0;\n    q3 = 0.0;\n    return;\n  }\n\n  // normalize u3 and v3 to get unit vectors\n  u3 = new Vector3D(1.0 / u3Norm, u3);\n  v3 = new Vector3D(1.0 / v3Norm, v3);\n\n  // create the normalized base (u1, u2, u3) and (v1, v2, v3)\n  double u1Norm = FastMath.sqrt(u1u1);\n  double u2Norm = FastMath.sqrt(u2u2);\n  double v1Norm = FastMath.sqrt(v1v1);\n  double v2Norm = FastMath.sqrt(v2v2);\n  \n  Vector3D u1Normalized = new Vector3D(1.0 / u1Norm, u1);\n  Vector3D u2Normalized = new Vector3D(1.0 / u2Norm, u2);\n  Vector3D v1Normalized = new Vector3D(1.0 / v1Norm, v1);\n  Vector3D v2Normalized = new Vector3D(1.0 / v2Norm, v2);\n\n  // Build the rotation matrix in the orthonormal base (u1, u2, u3)\n  // the coordinates of the vectors are:\n  // u1: (1, 0, 0)\n  // u2: (0, 1, 0)\n  // u3: (0, 0, 1)\n  // v1: (m[0][0], m[1][0], m[2][0])\n  // v2: (m[0][1], m[1][1], m[2][1])\n  // v3: (m[0][2], m[1][2], m[2][2])\n  m[0][0] = u1Normalized.dotProduct(v1Normalized);\n  m[0][1] = u1Normalized.dotProduct(v2Normalized);\n  m[0][2] = u1Normalized.dotProduct(v3);\n  m[1][0] = u2Normalized.dotProduct(v1Normalized);\n  m[1][1] = u2Normalized.dotProduct(v2Normalized);\n  m[1][2] = u2Normalized.dotProduct(v3);\n  m[2][0] = u3.dotProduct(v1Normalized);\n  m[2][1] = u3.dotProduct(v2Normalized);\n  m[2][2] = u3.dotProduct(v3);\n\n  // convert the matrix to quaternion\n  double[] quat = new double[4];\n  double trace = m[0][0] + m[1][1] + m[2][2];\n  if (trace > 0.0) {\n    double s = 0.5 / FastMath.sqrt(trace + 1.0);\n    quat[0] = 0.25 / s;\n    quat[1] = (m[2][1] - m[1][2]) * s;\n    quat[2] = (m[0][2] - m[2][0]) * s;\n    quat[3] = (m[1][0] - m[0][1]) * s;\n  } else {\n    if (m[0][0] > m[1][1] && m[0][0] > m[2][2]) {\n      double s = 2.0 * FastMath.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n      quat[0] = (m[2][1] - m[1][2]) / s;\n      quat[1] = 0.25 * s;\n      quat[2] = (m[0][1] + m[1][0]) / s;\n      quat[3] = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n      double s = 2.0 * FastMath.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n      quat[0] = (m[0][2] - m[2][0]) / s;\n      quat[1] = (m[0][1] + m[1][0]) / s;\n      quat[2] = 0.25 * s;\n      quat[3] = (m[1][2] + m[2][1]) / s;\n    } else {\n      double s = 2.0 * FastMath.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n      quat[0] = (m[1][0] - m[0][1]) / s;\n      quat[1] = (m[0][2] + m[2][0]) / s;\n      quat[2] = (m[1][2] + m[2][1]) / s;\n      quat[3] = 0.25 * s;\n    }\n  }\n\n  // normalize the quaternion to get a versor\n  double norm = FastMath.sqrt(quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2] + quat[3] * quat[3]);\n  q0 = quat[0] / norm;\n  q1 = quat[1] / norm;\n  q2 = quat[2] / norm;\n  q3 = quat[3] / norm;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}