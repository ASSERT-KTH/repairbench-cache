{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   * @exception IllegalArgumentException if the vectors u1 and u2 are collinear\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize v1 in order to have (v1'|v1') = (u1|u1)\n    v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n    // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n    double u1u2   = u1.dotProduct(u2);\n    double v1v2   = v1.dotProduct(v2); // v1 is the adjusted version now\n    double coeffU = u1u2 / u1u1;\n    // coeffV = v1'.dot(v2_orig) / |v1'|^2 = v1'.dot(v2_orig) / u1u1\n    double coeffV = v1v2 / u1u1;\n    // Denominator for beta calculation: |v2_orig|^2 - (v1'.dot(v2_orig))^2 / |v1'|^2\n    double betaDen = v2v2 - v1v2 * coeffV;\n    // Numerator for beta calculation: |u2|^2 - (u1.dot(u2))^2 / |u1|^2\n    double betaNum = u2u2 - u1u2 * coeffU;\n\n    // Check for collinearity of u1 and u2 using the beta numerator (|u1 x u2|^2 / |u1|^2)\n    // Threshold calculation: norm of cross product squared compared to product of norms squared\n    if (betaNum < 1.0e-15 * u1u1 * u2u2) {\n        // u1 and u2 are parallel. Rotation is not uniquely defined.\n        // Check if v1 and v2 are also parallel.\n        if (betaDen < 1.0e-15 * v1v1 * v2v2) { // v1v1 is u1u1 here\n            // both pairs are parallel, find rotation from u1 to v1\n            Rotation r = new Rotation(u1, v1);\n            this.q0 = r.q0;\n            this.q1 = r.q1;\n            this.q2 = r.q2;\n            this.q3 = r.q3;\n            return; // Exit constructor\n        }\n        // u1, u2 parallel but v1, v2 are not (or at least not detected as parallel by betaDen).\n        // This case implies inconsistency, as adjustment should make v parallel if u are parallel.\n        // However, let's throw based on u1, u2 collinearity.\n        throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.CLOSE_VECTORS_FOR_ROTATION_DEFINING_PAIR);\n    }\n\n    double betaArg;\n    if (betaDen < 1.0e-15 * v1v1 * v2v2) {\n         // v1 and v2 are parallel. Since u1, u2 are not parallel, this shouldn't happen\n         // if adjustment worked perfectly. Throw exception as it indicates inconsistent input.\n         // (A rotation cannot map non-parallel vectors to parallel ones).\n         throw MathRuntimeException.createIllegalArgumentException(\n                 LocalizedFormats.CLOSE_VECTORS_FOR_ROTATION_DEFINING_PAIR);\n         // betaArg = Double.POSITIVE_INFINITY; // Or handle differently\n    } else {\n        betaArg = betaNum / betaDen;\n    }\n\n    double beta   = FastMath.sqrt(betaArg); // betaArg should be non-negative now\n    double alpha  = coeffU - beta * coeffV;\n    v2 = new Vector3D(alpha, v1, beta, v2); // v2 becomes the adjusted v2a\n\n    // compute orthonormal basis U = { u1_hat, u2_hat, u3_hat } from (u1, u2)\n    Vector3D u1_hat = u1.normalize();\n    // compute u2 orthogonal to u1_hat: u2 - proj(u2 onto u1_hat)\n    Vector3D u2_orth = u1_hat.scalarMultiply(u1_hat.dotProduct(u2));\n    u2_orth = u2.subtract(u2_orth);\n    // u2_orth normSq was already checked via betaNum, normalization is safe\n    Vector3D u2_hat = u2_orth.normalize();\n    Vector3D u3_hat = Vector3D.crossProduct(u1_hat, u2_hat);\n\n    // compute orthonormal basis V = { v1_hat, v2_hat, v3_hat } from (v1a, v2a)\n    // v1 and v2 hold the adjusted vectors v1a, v2a at this point\n    Vector3D v1_hat = v1.normalize();\n    // compute v2 orthogonal to v1_hat: v2a - proj(v2a onto v1_hat)\n    Vector3D v2_orth = v1_hat.scalarMultiply(v1_hat.dotProduct(v2));\n    v2_orth = v2.subtract(v2_orth);\n    // If adjustment logic is correct, |v2_orth|^2 should equal |u2_orth|^2 and be non-zero.\n    Vector3D v2_hat = v2_orth.normalize();\n    Vector3D v3_hat = Vector3D.crossProduct(v1_hat, v2_hat);\n\n    // Compute rotation matrix R = V * U^T where R_ij = v_i_hat.dot(u_j_hat)\n    final double[][] R = new double[3][3];\n    R[0][0] = v1_hat.dotProduct(u1_hat);\n    R[0][1] = v1_hat.dotProduct(u2_hat);\n    R[0][2] = v1_hat.dotProduct(u3_hat);\n    R[1][0] = v2_hat.dotProduct(u1_hat);\n    R[1][1] = v2_hat.dotProduct(u2_hat);\n    R[1][2] = v2_hat.dotProduct(u3_hat);\n    R[2][0] = v3_hat.dotProduct(u1_hat);\n    R[2][1] = v3_hat.dotProduct(u2_hat);\n    R[2][2] = v3_hat.dotProduct(u3_hat);\n\n    // Convert matrix R to quaternion q0, q1, q2, q3\n    // Using the standard robust algorithm (Shepperd's method adaptation)\n    // From http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n    double trace = R[0][0] + R[1][1] + R[2][2];\n    if (trace > 0.0) { // Use 0.0 threshold, sqrt of slightly negative is handled by algorithm variations\n        double S = FastMath.sqrt(trace + 1.0) * 2.0; // S=4*q0\n        q0 = 0.25 * S;\n        q1 = (R[2][1] - R[1][2]) / S;\n        q2 = (R[0][2] - R[2][0]) / S;\n        q3 = (R[1][0] - R[0][1]) / S;\n    } else if ((R[0][0] > R[1][1]) && (R[0][0] > R[2][2])) { // R[0][0] is largest diagonal element\n        double S = FastMath.sqrt(1.0 + R[0][0] - R[1][1] - R[2][2]) * 2.0; // S=4*q1\n        q0 = (R[2][1] - R[1][2]) / S;\n        q1 = 0.25 * S;\n        q2 = (R[0][1] + R[1][0]) / S;\n        q3 = (R[0][2] + R[2][0]) / S;\n    } else if (R[1][1] > R[2][2]) { // R[1][1] is largest diagonal element\n        double S = FastMath.sqrt(1.0 + R[1][1] - R[0][0] - R[2][2]) * 2.0; // S=4*q2\n        q0 = (R[0][2] - R[2][0]) / S;\n        q1 = (R[0][1] + R[1][0]) / S;\n        q2 = 0.25 * S;\n        q3 = (R[1][2] + R[2][1]) / S;\n    } else { // R[2][2] is largest diagonal element\n        double S = FastMath.sqrt(1.0 + R[2][2] - R[0][0] - R[1][1]) * 2.0; // S=4*q3\n        q0 = (R[1][0] - R[0][1]) / S;\n        q1 = (R[0][2] + R[2][0]) / S;\n        q2 = (R[1][2] + R[2][1]) / S;\n        q3 = 0.25 * S;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}