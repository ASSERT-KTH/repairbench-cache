{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize u1 and v1\n    Vector3D u1Norm = u1.scalarMultiply(1.0 / FastMath.sqrt(u1u1));\n    Vector3D u2Norm = u2.scalarMultiply(1.0 / FastMath.sqrt(u2u2));\n    Vector3D v1Norm = v1.scalarMultiply(1.0 / FastMath.sqrt(v1v1));\n    Vector3D v2Norm = v2.scalarMultiply(1.0 / FastMath.sqrt(v2v2));\n\n    // build orthonormal bases {u1, u2Ort, u3} and {v1, v2Ort, v3}\n    Vector3D u3 = u1Norm.crossProduct(u2Norm).normalize();\n    Vector3D u2Ort = u3.crossProduct(u1Norm).normalize();\n    Vector3D v3 = v1Norm.crossProduct(v2Norm).normalize();\n    Vector3D v2Ort = v3.crossProduct(v1Norm).normalize();\n\n    // change of basis matrix from {u1, u2Ort, u3} to {v1, v2Ort, v3}\n    // M = [v1 | v2Ort | v3] [u1 | u2Ort | u3]^T\n    double[][] m = new double[3][3];\n    m[0][0] = v1Norm.dotProduct(u1Norm);\n    m[0][1] = v1Norm.dotProduct(u2Ort);\n    m[0][2] = v1Norm.dotProduct(u3);\n    m[1][0] = v2Ort.dotProduct(u1Norm);\n    m[1][1] = v2Ort.dotProduct(u2Ort);\n    m[1][2] = v2Ort.dotProduct(u3);\n    m[2][0] = v3.dotProduct(u1Norm);\n    m[2][1] = v3.dotProduct(u2Ort);\n    m[2][2] = v3.dotProduct(u3);\n\n    // convert matrix to rotation\n    Rotation rot = new Rotation(new double[][] { { m[0][0], m[0][1], m[0][2] },\n                                                 { m[1][0], m[1][1], m[1][2] },\n                                                 { m[2][0], m[2][1], m[2][2] } }, 1.0e-10);\n\n    this.q0 = rot.q0;\n    this.q1 = rot.q1;\n    this.q2 = rot.q2;\n    this.q3 = rot.q3;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}