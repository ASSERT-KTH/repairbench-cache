{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize u1, u2, v1, v2\n    Vector3D u1N = u1.normalize();\n    Vector3D v1N = v1.normalize();\n    Vector3D u2Ortho = u2.subtract(u1.scalarMultiply(u1.dotProduct(u2) / u1u1)).normalize();\n    Vector3D v2Ortho = v2.subtract(v1.scalarMultiply(v1.dotProduct(v2) / v1v1)).normalize();\n\n    // Build a matrix M whose columns are u1N, u2Ortho, u1N x u2Ortho\n    // and a matrix N whose columns are v1N, v2Ortho, v1N x v2Ortho\n    double[][] m = new double[3][3];\n    double[][] n = new double[3][3];\n    Vector3D u3 = u1N.crossProduct(u2Ortho);\n    Vector3D v3 = v1N.crossProduct(v2Ortho);\n\n    m[0][0] = u1N.getX();\n    m[1][0] = u1N.getY();\n    m[2][0] = u1N.getZ();\n\n    m[0][1] = u2Ortho.getX();\n    m[1][1] = u2Ortho.getY();\n    m[2][1] = u2Ortho.getZ();\n\n    m[0][2] = u3.getX();\n    m[1][2] = u3.getY();\n    m[2][2] = u3.getZ();\n\n    n[0][0] = v1N.getX();\n    n[1][0] = v1N.getY();\n    n[2][0] = v1N.getZ();\n\n    n[0][1] = v2Ortho.getX();\n    n[1][1] = v2Ortho.getY();\n    n[2][1] = v2Ortho.getZ();\n\n    n[0][2] = v3.getX();\n    n[1][2] = v3.getY();\n    n[2][2] = v3.getZ();\n\n    // Compute the rotation matrix: N * M^T\n    double[][] r = new double[3][3];\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        r[i][j] = 0;\n        for (int k = 0; k < 3; ++k) {\n          r[i][j] += n[i][k] * m[j][k]; // m^T\n        }\n      }\n    }\n\n    // Now, turn this matrix into a quaternion\n    double s = r[0][0] + r[1][1] + r[2][2];\n    if (s > -0.99999999) {\n      double q0tmp = 0.5 * FastMath.sqrt(1.0 + r[0][0] + r[1][1] + r[2][2]);\n      double inv4q0 = 1.0 / (4.0 * q0tmp);\n      q0 = q0tmp;\n      q1 = inv4q0 * (r[2][1] - r[1][2]);\n      q2 = inv4q0 * (r[0][2] - r[2][0]);\n      q3 = inv4q0 * (r[1][0] - r[0][1]);\n    } else {\n      // The rotation is close to 180 degrees\n      int i = 0;\n      if (r[1][1] > r[0][0]) {\n        i = 1;\n      }\n      if (r[2][2] > r[i][i]) {\n        i = 2;\n      }\n      int j = (i + 1) % 3;\n      int k = (i + 2) % 3;\n\n      double qi = FastMath.sqrt(r[i][i] - r[j][j] - r[k][k] + 1.0) * 0.5;\n      double inv2qi = 0.5 / qi;\n\n      double q0tmp = (r[k][j] - r[j][k]) * inv2qi;\n      double q1tmp, q2tmp, q3tmp;\n      if (i == 0) {\n        q0 = q0tmp;\n        q1 = qi;\n        q2 = (r[0][1] + r[1][0]) * inv2qi;\n        q3 = (r[0][2] + r[2][0]) * inv2qi;\n      } else if (i == 1) {\n        q0 = q0tmp;\n        q1 = (r[1][0] + r[0][1]) * inv2qi;\n        q2 = qi;\n        q3 = (r[1][2] + r[2][1]) * inv2qi;\n      } else {\n        q0 = q0tmp;\n        q1 = (r[2][0] + r[0][2]) * inv2qi;\n        q2 = (r[2][1] + r[1][2]) * inv2qi;\n        q3 = qi;\n      }\n    }\n    // Normalize the quaternion just in case (for robustness)\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    q0 /= norm;\n    q1 /= norm;\n    q2 /= norm;\n    q3 /= norm;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}