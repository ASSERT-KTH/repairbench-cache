{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize u1 and u2\n    Vector3D u1n = u1.normalize();\n    Vector3D u2n = u2.normalize();\n\n    // normalize v1 and v2\n    Vector3D v1n = v1.normalize();\n    Vector3D v2n = v2.normalize();\n\n    // Compute orthonormal bases for each pair\n    Vector3D u3 = u1n.crossProduct(u2n);\n    double normU3 = u3.getNorm();\n    if (normU3 == 0) {\n      // u1 and u2 are linearly dependent\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n    u3 = u3.normalize();\n    Vector3D u2Ortho = u3.crossProduct(u1n);\n\n    Vector3D v3 = v1n.crossProduct(v2n);\n    double normV3 = v3.getNorm();\n    if (normV3 == 0) {\n      // v1 and v2 are linearly dependent\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n    v3 = v3.normalize();\n    Vector3D v2Ortho = v3.crossProduct(v1n);\n\n    // matrix representing the change of basis from u-orthonormal to v-orthonormal\n    // Columns are v1n, v2Ortho, v3\n    // Rows are u1n, u2Ortho, u3\n    double[][] mat = new double[3][3];\n    mat[0][0] = v1n.dotProduct(u1n);\n    mat[0][1] = v1n.dotProduct(u2Ortho);\n    mat[0][2] = v1n.dotProduct(u3);\n    mat[1][0] = v2Ortho.dotProduct(u1n);\n    mat[1][1] = v2Ortho.dotProduct(u2Ortho);\n    mat[1][2] = v2Ortho.dotProduct(u3);\n    mat[2][0] = v3.dotProduct(u1n);\n    mat[2][1] = v3.dotProduct(u2Ortho);\n    mat[2][2] = v3.dotProduct(u3);\n\n    // Convert 3x3 matrix to quaternion\n    // This is equivalent to: new Rotation(matrix, 1.0e-10)\n    double trace = mat[0][0] + mat[1][1] + mat[2][2];\n    if (trace > 0) {\n      double s = FastMath.sqrt(trace + 1.0) * 2; // S=4*q0\n      q0 = 0.25 * s;\n      q1 = (mat[2][1] - mat[1][2]) / s;\n      q2 = (mat[0][2] - mat[2][0]) / s;\n      q3 = (mat[1][0] - mat[0][1]) / s;\n    } else if ((mat[0][0] > mat[1][1]) && (mat[0][0] > mat[2][2])) {\n      double s = FastMath.sqrt(1.0 + mat[0][0] - mat[1][1] - mat[2][2]) * 2; // S=4*q1\n      q0 = (mat[2][1] - mat[1][2]) / s;\n      q1 = 0.25 * s;\n      q2 = (mat[0][1] + mat[1][0]) / s;\n      q3 = (mat[0][2] + mat[2][0]) / s;\n    } else if (mat[1][1] > mat[2][2]) {\n      double s = FastMath.sqrt(1.0 + mat[1][1] - mat[0][0] - mat[2][2]) * 2; // S=4*q2\n      q0 = (mat[0][2] - mat[2][0]) / s;\n      q1 = (mat[0][1] + mat[1][0]) / s;\n      q2 = 0.25 * s;\n      q3 = (mat[1][2] + mat[2][1]) / s;\n    } else {\n      double s = FastMath.sqrt(1.0 + mat[2][2] - mat[0][0] - mat[1][1]) * 2; // S=4*q3\n      q0 = (mat[1][0] - mat[0][1]) / s;\n      q1 = (mat[0][2] + mat[2][0]) / s;\n      q2 = (mat[1][2] + mat[2][1]) / s;\n      q3 = 0.25 * s;\n    }\n\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}