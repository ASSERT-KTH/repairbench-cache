{
    "generation": "/** Build the rotation that transforms a pair of vector into another pair.\n * <p>Except for possible scale factors, if the instance were applied to\n * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n * (v<sub>1</sub>, v<sub>2</sub>).</p>\n *\n * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n * not the same as the angular separation between v<sub>1</sub> and\n * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n * v<sub>2</sub>) plane.</p>\n *\n * @param u1 first vector of the origin pair\n * @param u2 second vector of the origin pair\n * @param v1 desired image of u1 by the rotation\n * @param v2 desired image of u2 by the rotation\n * @exception IllegalArgumentException if the norm of one of the vectors is zero\n */\npublic Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // Compute squared norms and check for zero\u2010length vectors.\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // Scale v1 so that its squared norm equals that of u1.\n    double scaling = FastMath.sqrt(u1u1 / v1v1);\n    v1 = new Vector3D(scaling, v1);\n\n    // Adjust v2 so that the inner products and norms match.\n    double u1u2   = u1.dotProduct(u2);\n    double v1v2   = v1.dotProduct(v2);\n    double coeffU = u1u2 / u1u1;\n    double coeffV = v1v2 / u1u1;\n    double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n    double alpha  = coeffU - beta * coeffV;\n    v2 = new Vector3D(alpha, v1, beta, v2);\n\n    // Begin construction of the quaternion by computing two differences.\n    Vector3D uRef   = u1;\n    Vector3D vRef   = v1;\n    Vector3D v1Su1  = v1.subtract(u1);\n    Vector3D v2Su2  = v2.subtract(u2);\n    Vector3D k      = v1Su1.crossProduct(v2Su2);\n    Vector3D u3     = u1.crossProduct(u2);\n    double c        = k.dotProduct(u3);\n\n    // If the dot product is near zero, try alternative combinations.\n    if (FastMath.abs(c) < 1e-10) {\n        Vector3D v3 = v1.crossProduct(v2);\n        Vector3D v3Su3 = v3.subtract(u3);\n        k = v1Su1.crossProduct(v3Su3);\n        Vector3D u2Prime = u1.crossProduct(u3);\n        c = k.dotProduct(u2Prime);\n\n        if (FastMath.abs(c) < 1e-10) {\n            k = v2Su2.crossProduct(v3Su3);\n            c = k.dotProduct(u2.crossProduct(u3));\n            if (FastMath.abs(c) < 1e-10) {\n                // In the degenerate case, use the identity rotation.\n                q0 = 1.0;\n                q1 = 0.0;\n                q2 = 0.0;\n                q3 = 0.0;\n                return;\n            }\n            // Use the second pair if the first one is nearly degenerate.\n            uRef = u2;\n            vRef = v2;\n        }\n    }\n\n    // --- FIX: Use the absolute value and carry the sign explicitly ---\n    double sign = (c >= 0) ? 1.0 : -1.0;\n    c = FastMath.sqrt(FastMath.abs(c));\n    double inv = 1.0 / (2 * c);\n    q1 = sign * inv * k.getX();\n    q2 = sign * inv * k.getY();\n    q3 = sign * inv * k.getZ();\n\n    // Instead of the more fragile computation based on cross products,\n    // determine the scalar part from the normalization condition.\n    double vecNormSq = q1 * q1 + q2 * q2 + q3 * q3;\n    q0 = (vecNormSq < 1.0) ? FastMath.sqrt(1.0 - vecNormSq) : 0.0;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}