{
    "generation": "import org.apache.commons.math.exception.util.LocalizedFormats;\nimport org.apache.commons.math.exception.MathRuntimeException;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.geometry.euclidean.threed.Vector3D;\n\n// The class structure is assumed to be:\n// public class Rotation {\n//     private double q0;\n//     private double q1;\n//     private double q2;\n//     private double q3;\n//     ... other methods ...\n\n  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   * or if the vectors are incompatible for rotation.\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n      // norms computation\n      double u1u1 = u1.getNormSq();\n      double u2u2 = u2.getNormSq();\n      double v1v1 = v1.getNormSq();\n      double v2v2 = v2.getNormSq(); // Norm of original v2\n      if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n          throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n      }\n\n      // Store original vectors for adjustment phase\n      Vector3D v1_original = v1;\n      Vector3D v2_original = v2;\n\n      // Scale v1 to match u1's norm -> v1'\n      v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1_original);\n      // Now v1.getNormSq() == u1u1\n\n      // Adjust v2 to v2' such that (u1|u2) = (v1'|v2') and |v2'|^2 = |u2|^2\n      // v2' = alpha * v1' + beta * v2_original\n      double u1u2   = u1.dotProduct(u2);\n      // Dot product uses scaled v1 (v1') and original v2 (v2_original)\n      double v1prime_dot_v2original = v1.dotProduct(v2_original);\n      double coeffU = u1u2 / u1u1;\n      double coeffV = v1prime_dot_v2original / u1u1;\n\n      // num = |u2|^2 - (u1.u2)^2 / |u1|^2 = |u2|^2 * sin^2(angle_u) >= 0\n      double num = u2u2 - u1u2 * coeffU;\n      // den = |v2_original|^2 - (v1'.v2_original)^2 / |v1'|^2 = |v2_original|^2 * sin^2(angle_v') >= 0\n      // Note: v2v2 is |v2_original|^2\n      double den = v2v2 - v1prime_dot_v2original * coeffV;\n\n      // Check for collinearity using a relative tolerance.\n      final double U1U1_TIMES_U2U2 = u1u1 * u2u2;\n      // Tolerance for denominator uses |v1'|^2 * |v2_original|^2\n      final double V1PrimeSq_TIMES_V2OrigSq = u1u1 * v2v2;\n\n      final double SMALL_RELATIVE = 1.0e-15; // Relative tolerance for checking zero\n\n      // Clamp num and den based on theory and tolerance\n      // num should be >= 0\n      if (num < SMALL_RELATIVE * U1U1_TIMES_U2U2) { num = 0.0; }\n      // den should be >= 0\n      if (den < SMALL_RELATIVE * V1PrimeSq_TIMES_V2OrigSq) { den = 0.0; }\n\n      boolean uCollinear = (num == 0.0);\n      boolean vCollinear = (den == 0.0); // vCollinear means v1' and v2_original are collinear\n\n      double beta;\n      if (vCollinear) {\n          if (uCollinear) {\n              // Both pairs are collinear. Adjusted v2' = coeffU * v1'. beta = 0.\n              beta = 0.0;\n          } else {\n              // v1', v2_original are collinear, but u1, u2 are not.\n              // The adjustment formula requires v2' to be collinear with v1',\n              // which cannot match the non-zero angle between u1, u2. Impossible transformation.\n              throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.CLOSE_VECTORS); // Or a more specific error\n          }\n      } else { // v not collinear (den > 0)\n          if (uCollinear) {\n             // u1, u2 are collinear, v1', v2_original are not.\n             // Adjusted v2' must be coeffU * v1'. Requires beta = sqrt(num/den) = sqrt(0/den) = 0.\n             beta = 0.0;\n          } else {\n             // General case: num > 0, den > 0.\n             beta = FastMath.sqrt(num / den);\n          }\n      }\n\n      double alpha  = coeffU - beta * coeffV;\n      // Compute the adjusted v2' using scaled v1' and original v2_original\n      v2 = new Vector3D(alpha, v1, beta, v2_original);\n      // Now v1 = v1' and v2 = v2'\n\n      // preliminary computation for rotation q = (q0, q1, q2, q3)\n      // Use adjusted vectors v1=v1', v2=v2' from here\n      Vector3D uRef = u1; // Default reference vector\n      Vector3D vRef = v1; // Default reference vector image (adjusted v1')\n      Vector3D uAlt = u2; // Alternative reference vector\n      Vector3D vAlt = v2; // Alternative reference vector image (adjusted v2')\n\n      Vector3D v1Su1 = v1.subtract(u1);\n      Vector3D v2Su2 = v2.subtract(u2); // v2 is adjusted v2' here\n      Vector3D k     = v1Su1.crossProduct(v2Su2);\n      Vector3D u3    = u1.crossProduct(u2);\n      double c       = k.dotProduct(u3);\n\n      // Check if c is near zero using a tolerance\n      // Using an absolute tolerance check, might need refinement based on vector magnitudes\n      final double SMALL_ABS = 1.0e-12;\n\n      if (FastMath.abs(c) < SMALL_ABS) {\n          // Degenerate case 1: Try using (u1, u3) and (v1, v3)\n          Vector3D v3 = v1.crossProduct(v2); // Use adjusted v1', v2'\n          Vector3D v3Su3 = v3.subtract(u3);\n          k = v1Su1.crossProduct(v3Su3); // New k\n          Vector3D u2Prime = u1.crossProduct(u3); // Vector orthogonal to u1 in u1,u3 plane\n          c = k.dotProduct(u2Prime); // New c\n\n          if (FastMath.abs(c) < SMALL_ABS) {\n              // Degenerate case 2: Try using (u2, u3) and (v2, v3)\n              k = v2Su2.crossProduct(v3Su3); // New k\n              Vector3D u1Prime = u2.crossProduct(u3); // Vector orthogonal to u2 in u2,u3 plane\n              c = k.dotProduct(u1Prime); // New c\n\n              if (FastMath.abs(c) < SMALL_ABS) {\n                  // All attempts failed, must be identity rotation\n                  this.q0 = 1.0; this.q1 = 0.0; this.q2 = 0.0; this.q3 = 0.0;\n                  return;\n              }\n              // Use u2, v2 for the q0 calculation reference frame\n              uRef = u2; vRef = v2;\n              uAlt = u1; vAlt = v1;\n          }\n      }\n\n      // Compute the vectorial part using the final non-zero k and c\n      // Clamp c before sqrt, just in case of numerical noise making it slightly negative.\n      if (c < 0.0) {\n           c = 0.0; // Force non-negative. Should ideally not happen.\n      }\n\n      // If c ended up being zero after all checks, assume identity.\n      if (c == 0.0) {\n          this.q0 = 1.0; this.q1 = 0.0; this.q2 = 0.0; this.q3 = 0.0;\n          return;\n      }\n\n      // c > 0 guaranteed (or returned identity)\n      double s = FastMath.sqrt(c);\n      double inv = 0.5 / s;\n      // Compute vector part q = (q1, q2, q3)\n      this.q1 = inv * k.getX();\n      this.q2 = inv * k.getY();\n      this.q3 = inv * k.getZ();\n\n      // Compute the scalar part q0 using the robust method\n      Vector3D qVec = new Vector3D(this.q1, this.q2, this.q3);\n      Vector3D k1 = uRef.crossProduct(qVec);\n      double normSqK1 = k1.getNormSq();\n      double uRefNormSq = uRef.getNormSq(); // Must be > 0\n      double qVecNormSq = qVec.getNormSq();\n\n      // Threshold for parallelism check (relative to norms squared)\n      double par_threshold = SMALL_RELATIVE * SMALL_RELATIVE * uRefNormSq * qVecNormSq;\n\n      if (normSqK1 < par_threshold) { // uRef is parallel to axis qVec\n          Vector3D k2 = uAlt.crossProduct(qVec);\n          double normSqK2 = k2.getNormSq();\n          double uAltNormSq = uAlt.getNormSq(); // Must be > 0\n          double par_threshold2 = SMALL_RELATIVE * SMALL_RELATIVE * uAltNormSq * qVecNormSq;\n\n          if (normSqK2 < par_threshold2) { // uAlt also parallel\n              // Both u1, u2 parallel to axis => u1, u2 collinear.\n              // Rotation must be around this axis.\n              // Calculate angle from vRef = R uRef. Since |vRef|=|uRef|, cos(angle) = dot / normSq\n              double uVRefDot = uRef.dotProduct(vRef);\n              // Handle case where uRefNormSq is zero (should not happen due to initial check)\n              double cosAngle = (uRefNormSq == 0) ? 1.0 : uVRefDot / uRefNormSq;\n              cosAngle = FastMath.max(-1.0, FastMath.min(1.0, cosAngle));\n              // q0 = cos(angle/2). Choose positive root (angle <= 180).\n              this.q0 = FastMath.sqrt(0.5 * (1.0 + cosAngle));\n          } else {\n              // Use uAlt, vAlt pair for q0 computation\n              // q0 = (vAlt . k2) / (2 * |k2|^2)\n              this.q0 = vAlt.dotProduct(k2) / (2.0 * normSqK2);\n          }\n      } else {\n          // Use uRef, vRef pair for q0 computation\n          // q0 = (vRef . k1) / (2 * |k1|^2)\n          this.q0 = vRef.dotProduct(k1) / (2.0 * normSqK1);\n      }\n\n      // The quaternion (q0, q1, q2, q3) should be normalized by construction if formulas are exact.\n      // No explicit renormalization is performed here.\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}