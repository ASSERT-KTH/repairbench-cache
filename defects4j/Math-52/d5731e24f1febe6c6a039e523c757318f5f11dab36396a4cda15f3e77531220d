{
    "generation": "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // check for zero\u2010norm defining vectors\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if (u1u1 == 0 || u2u2 == 0 || v1v1 == 0 || v2v2 == 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n            LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // build an orthonormal basis (e1,e2,e3) from (u1,u2)\n    double norm = FastMath.sqrt(u1u1);\n    Vector3D e1 = new Vector3D(1.0 / norm, u1);\n    double proj = e1.dotProduct(u2);\n    Vector3D tmp = u2.subtract(new Vector3D(proj, e1));\n    norm = tmp.getNorm();\n    if (norm == 0) {\n        // u1 and u2 are parallel: pick any perpendicular direction\n        if (FastMath.abs(e1.getX()) < FastMath.abs(e1.getY())\n                && FastMath.abs(e1.getX()) < FastMath.abs(e1.getZ())) {\n            tmp = new Vector3D(0, -e1.getZ(), e1.getY());\n        } else if (FastMath.abs(e1.getY()) < FastMath.abs(e1.getZ())) {\n            tmp = new Vector3D(-e1.getZ(), 0, e1.getX());\n        } else {\n            tmp = new Vector3D(-e1.getY(), e1.getX(), 0);\n        }\n        norm = tmp.getNorm();\n    }\n    Vector3D e2 = new Vector3D(1.0 / norm, tmp);\n    Vector3D e3 = e1.crossProduct(e2);\n\n    // build an orthonormal basis (f1,f2,f3) from (v1,v2)\n    norm = FastMath.sqrt(v1v1);\n    Vector3D f1 = new Vector3D(1.0 / norm, v1);\n    proj = f1.dotProduct(v2);\n    tmp = v2.subtract(new Vector3D(proj, f1));\n    norm = tmp.getNorm();\n    if (norm == 0) {\n        // v1 and v2 are parallel: pick any perpendicular direction\n        if (FastMath.abs(f1.getX()) < FastMath.abs(f1.getY())\n                && FastMath.abs(f1.getX()) < FastMath.abs(f1.getZ())) {\n            tmp = new Vector3D(0, -f1.getZ(), f1.getY());\n        } else if (FastMath.abs(f1.getY()) < FastMath.abs(f1.getZ())) {\n            tmp = new Vector3D(-f1.getZ(), 0, f1.getX());\n        } else {\n            tmp = new Vector3D(-f1.getY(), f1.getX(), 0);\n        }\n        norm = tmp.getNorm();\n    }\n    Vector3D f2 = new Vector3D(1.0 / norm, tmp);\n    Vector3D f3 = f1.crossProduct(f2);\n\n    // rotation matrix M = [f1 f2 f3] * [e1 e2 e3]^T\n    double m00 = f1.getX() * e1.getX() + f2.getX() * e2.getX() + f3.getX() * e3.getX();\n    double m01 = f1.getX() * e1.getY() + f2.getX() * e2.getY() + f3.getX() * e3.getY();\n    double m02 = f1.getX() * e1.getZ() + f2.getX() * e2.getZ() + f3.getX() * e3.getZ();\n    double m10 = f1.getY() * e1.getX() + f2.getY() * e2.getX() + f3.getY() * e3.getX();\n    double m11 = f1.getY() * e1.getY() + f2.getY() * e2.getY() + f3.getY() * e3.getY();\n    double m12 = f1.getY() * e1.getZ() + f2.getY() * e2.getZ() + f3.getY() * e3.getZ();\n    double m20 = f1.getZ() * e1.getX() + f2.getZ() * e2.getX() + f3.getZ() * e3.getX();\n    double m21 = f1.getZ() * e1.getY() + f2.getZ() * e2.getY() + f3.getZ() * e3.getY();\n    double m22 = f1.getZ() * e1.getZ() + f2.getZ() * e2.getZ() + f3.getZ() * e3.getZ();\n\n    // extract quaternion (q0,q1,q2,q3) from M\n    double trace = m00 + m11 + m22;\n    if (trace >= 0) {\n        double s = FastMath.sqrt(trace + 1.0);\n        q0 = 0.5 * s;\n        double invS = 0.5 / s;\n        q1 = (m21 - m12) * invS;\n        q2 = (m02 - m20) * invS;\n        q3 = (m10 - m01) * invS;\n    } else if (m00 > m11 && m00 > m22) {\n        double s = FastMath.sqrt(1.0 + m00 - m11 - m22);\n        double invS = 0.5 / s;\n        q1 = 0.5 * s;\n        q2 = (m01 + m10) * invS;\n        q3 = (m02 + m20) * invS;\n        q0 = (m21 - m12) * invS;\n    } else if (m11 > m22) {\n        double s = FastMath.sqrt(1.0 + m11 - m00 - m22);\n        double invS = 0.5 / s;\n        q1 = (m01 + m10) * invS;\n        q2 = 0.5 * s;\n        q3 = (m12 + m21) * invS;\n        q0 = (m02 - m20) * invS;\n    } else {\n        double s = FastMath.sqrt(1.0 + m22 - m00 - m11);\n        double invS = 0.5 / s;\n        q1 = (m02 + m20) * invS;\n        q2 = (m12 + m21) * invS;\n        q3 = 0.5 * s;\n        q0 = (m10 - m01) * invS;\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}