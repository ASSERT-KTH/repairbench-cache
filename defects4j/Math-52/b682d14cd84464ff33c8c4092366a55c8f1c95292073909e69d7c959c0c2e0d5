{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize u1, u2, v1, v2\n    Vector3D u1N = u1.normalize();\n    Vector3D u2N = u2.normalize();\n    Vector3D v1N = v1.normalize();\n    Vector3D v2N = v2.normalize();\n\n    // compute the axis and angle that rotates u1N to v1N\n    Vector3D axis = Vector3D.crossProduct(u1N, v1N);\n    double axisNorm = axis.getNorm();\n    double dot = u1N.dotProduct(v1N);\n    // Clamp dot to [-1, 1] to avoid NaNs due to numerical errors\n    dot = Math.max(-1.0, Math.min(1.0, dot));\n    double angle = Math.acos(dot);\n\n    Rotation r1;\n    if (axisNorm < 1e-12) {\n      // u1N and v1N are aligned or opposite\n      if (dot > 0) {\n        r1 = Rotation.IDENTITY;\n      } else {\n        // 180 degree rotation around any axis perpendicular to u1N\n        Vector3D ortho = u1N.orthogonal();\n        r1 = new Rotation(ortho, Math.PI);\n      }\n    } else {\n      axis = axis.scalarMultiply(1.0 / axisNorm);\n      r1 = new Rotation(axis, angle);\n    }\n\n    // rotate u2N using r1, compute required in-plane rotation to align with v2N\n    Vector3D pU2 = r1.applyTo(u2N);\n    Vector3D projV2 = v2N.subtract(v1N.scalarMultiply(v1N.dotProduct(v2N))).normalize();\n    Vector3D projPU2 = pU2.subtract(v1N.scalarMultiply(v1N.dotProduct(pU2))).normalize();\n\n    double inPlaneCos = Math.max(-1.0, Math.min(1.0, projPU2.dotProduct(projV2)));\n    double inPlaneAngle = Math.acos(inPlaneCos);\n    double sign = Vector3D.dotProduct(Vector3D.crossProduct(projPU2, projV2), v1N);\n\n    if (sign < 0) {\n      inPlaneAngle = -inPlaneAngle;\n    }\n\n    Rotation r2 = new Rotation(v1N, inPlaneAngle);\n    Rotation total = r2.applyTo(r1);\n\n    this.q0 = total.q0;\n    this.q1 = total.q1;\n    this.q2 = total.q2;\n    this.q3 = total.q3;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}