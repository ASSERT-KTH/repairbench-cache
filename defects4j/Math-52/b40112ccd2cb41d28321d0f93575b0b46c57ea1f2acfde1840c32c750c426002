{
    "generation": "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // check input norms\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if (u1u1 == 0 || u2u2 == 0 || v1v1 == 0 || v2v2 == 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n                LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // build orthonormal basis for U = (u1n, u2n, u3n)\n    double normU1 = FastMath.sqrt(u1u1);\n    Vector3D u1n = new Vector3D(1.0 / normU1, u1);\n\n    double proj = u2.dotProduct(u1n);\n    Vector3D u2proj = new Vector3D(proj, u1n);\n    Vector3D u2perp = u2.subtract(u2proj);\n    double u2perpNorm = u2perp.getNorm();\n    if (u2perpNorm == 0) {\n        // u1 and u2 are colinear -> pick any perpendicular\n        Vector3D ortho = u1n.crossProduct(Vector3D.PLUS_I);\n        double orthoNorm = ortho.getNorm();\n        if (orthoNorm == 0) {\n            ortho = u1n.crossProduct(Vector3D.PLUS_J);\n            orthoNorm = ortho.getNorm();\n        }\n        u2perp = new Vector3D(1.0 / orthoNorm, ortho);\n    } else {\n        u2perp = new Vector3D(1.0 / u2perpNorm, u2perp);\n    }\n    Vector3D u3n = u1n.crossProduct(u2perp);\n\n    // build orthonormal basis for V = (v1n, v2n, v3n)\n    double normV1 = FastMath.sqrt(v1v1);\n    Vector3D v1n = new Vector3D(1.0 / normV1, v1);\n\n    proj = v2.dotProduct(v1n);\n    Vector3D v2proj = new Vector3D(proj, v1n);\n    Vector3D v2perp = v2.subtract(v2proj);\n    double v2perpNorm = v2perp.getNorm();\n    if (v2perpNorm == 0) {\n        // v1 and v2 are colinear -> pick any perpendicular\n        Vector3D ortho = v1n.crossProduct(Vector3D.PLUS_I);\n        double orthoNorm = ortho.getNorm();\n        if (orthoNorm == 0) {\n            ortho = v1n.crossProduct(Vector3D.PLUS_J);\n            orthoNorm = ortho.getNorm();\n        }\n        v2perp = new Vector3D(1.0 / orthoNorm, ortho);\n    } else {\n        v2perp = new Vector3D(1.0 / v2perpNorm, v2perp);\n    }\n    Vector3D v3n = v1n.crossProduct(v2perp);\n\n    // build rotation matrix M = V * U^T\n    double m00 = v1n.dotProduct(u1n);\n    double m01 = v1n.dotProduct(u2perp);\n    double m02 = v1n.dotProduct(u3n);\n    double m10 = v2perp.dotProduct(u1n);\n    double m11 = v2perp.dotProduct(u2perp);\n    double m12 = v2perp.dotProduct(u3n);\n    double m20 = v3n.dotProduct(u1n);\n    double m21 = v3n.dotProduct(u2perp);\n    double m22 = v3n.dotProduct(u3n);\n\n    // convert rotation matrix to quaternion\n    double trace = m00 + m11 + m22;\n    double q0_tmp, q1_tmp, q2_tmp, q3_tmp;\n    if (trace >= 0) {\n        double s = FastMath.sqrt(trace + 1.0);\n        q0_tmp = 0.5 * s;\n        double invS = 0.5 / s;\n        q1_tmp = (m21 - m12) * invS;\n        q2_tmp = (m02 - m20) * invS;\n        q3_tmp = (m10 - m01) * invS;\n    } else if (m00 > m11 && m00 > m22) {\n        double s = FastMath.sqrt(1.0 + m00 - m11 - m22);\n        q1_tmp = 0.5 * s;\n        double invS = 0.5 / s;\n        q0_tmp = (m21 - m12) * invS;\n        q2_tmp = (m01 + m10) * invS;\n        q3_tmp = (m02 + m20) * invS;\n    } else if (m11 > m22) {\n        double s = FastMath.sqrt(1.0 + m11 - m00 - m22);\n        q2_tmp = 0.5 * s;\n        double invS = 0.5 / s;\n        q0_tmp = (m02 - m20) * invS;\n        q1_tmp = (m01 + m10) * invS;\n        q3_tmp = (m12 + m21) * invS;\n    } else {\n        double s = FastMath.sqrt(1.0 + m22 - m00 - m11);\n        q3_tmp = 0.5 * s;\n        double invS = 0.5 / s;\n        q0_tmp = (m10 - m01) * invS;\n        q1_tmp = (m02 + m20) * invS;\n        q2_tmp = (m12 + m21) * invS;\n    }\n\n    // normalize quaternion\n    double qNorm = FastMath.sqrt(q0_tmp*q0_tmp + q1_tmp*q1_tmp +\n                                 q2_tmp*q2_tmp + q3_tmp*q3_tmp);\n    q0_tmp /= qNorm;\n    q1_tmp /= qNorm;\n    q2_tmp /= qNorm;\n    q3_tmp /= qNorm;\n\n    // ensure scalar part is non-negative\n    if (q0_tmp < 0) {\n        q0_tmp = -q0_tmp;\n        q1_tmp = -q1_tmp;\n        q2_tmp = -q2_tmp;\n        q3_tmp = -q3_tmp;\n    }\n\n    this.q0 = q0_tmp;\n    this.q1 = q1_tmp;\n    this.q2 = q2_tmp;\n    this.q3 = q3_tmp;\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}