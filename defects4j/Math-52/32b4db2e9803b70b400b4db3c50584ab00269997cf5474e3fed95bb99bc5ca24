{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize u1 and u2 to create an orthonormal basis\n    Vector3D u1Unit = u1.normalize();\n    Vector3D tmp = u2.subtract(u1.scalarMultiply(u1.dotProduct(u2) / u1u1));\n    Vector3D u2Unit = tmp.normalize();\n    Vector3D u3Unit = u1Unit.crossProduct(u2Unit);\n\n    // normalize v1 and v2 to create an orthonormal basis\n    Vector3D v1Unit = v1.normalize();\n    tmp = v2.subtract(v1.scalarMultiply(v1.dotProduct(v2) / v1v1));\n    Vector3D v2Unit = tmp.normalize();\n    Vector3D v3Unit = v1Unit.crossProduct(v2Unit);\n\n    // Rotation matrix from u-basis to v-basis: rM = vB * uB^T\n    double[][] uMat = new double[3][3];\n    double[][] vMat = new double[3][3];\n    uMat[0][0] = u1Unit.getX(); uMat[0][1] = u2Unit.getX(); uMat[0][2] = u3Unit.getX();\n    uMat[1][0] = u1Unit.getY(); uMat[1][1] = u2Unit.getY(); uMat[1][2] = u3Unit.getY();\n    uMat[2][0] = u1Unit.getZ(); uMat[2][1] = u2Unit.getZ(); uMat[2][2] = u3Unit.getZ();\n    vMat[0][0] = v1Unit.getX(); vMat[0][1] = v2Unit.getX(); vMat[0][2] = v3Unit.getX();\n    vMat[1][0] = v1Unit.getY(); vMat[1][1] = v2Unit.getY(); vMat[1][2] = v3Unit.getY();\n    vMat[2][0] = v1Unit.getZ(); vMat[2][1] = v2Unit.getZ(); vMat[2][2] = v3Unit.getZ();\n\n    double[][] rot = new double[3][3];\n    // rot = vMat * uMat^T\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        rot[i][j] = 0;\n        for (int k = 0; k < 3; ++k) {\n          rot[i][j] += vMat[i][k] * uMat[j][k]; // uMat^T\n        }\n      }\n    }\n\n    // Now convert rot to quaternion\n    double r00 = rot[0][0];\n    double r11 = rot[1][1];\n    double r22 = rot[2][2];\n    double trace = r00 + r11 + r22;\n\n    if (trace > 0) {\n      double s = 0.5 / FastMath.sqrt(trace + 1.0);\n      q0 = 0.25 / s;\n      q1 = (rot[2][1] - rot[1][2]) * s;\n      q2 = (rot[0][2] - rot[2][0]) * s;\n      q3 = (rot[1][0] - rot[0][1]) * s;\n    } else {\n      if ((r00 > r11) && (r00 > r22)) {\n        double s = 2.0 * FastMath.sqrt(1.0 + r00 - r11 - r22);\n        q0 = (rot[2][1] - rot[1][2]) / s;\n        q1 = 0.25 * s;\n        q2 = (rot[0][1] + rot[1][0]) / s;\n        q3 = (rot[0][2] + rot[2][0]) / s;\n      } else if (r11 > r22) {\n        double s = 2.0 * FastMath.sqrt(1.0 + r11 - r00 - r22);\n        q0 = (rot[0][2] - rot[2][0]) / s;\n        q1 = (rot[0][1] + rot[1][0]) / s;\n        q2 = 0.25 * s;\n        q3 = (rot[1][2] + rot[2][1]) / s;\n      } else {\n        double s = 2.0 * FastMath.sqrt(1.0 + r22 - r00 - r11);\n        q0 = (rot[1][0] - rot[0][1]) / s;\n        q1 = (rot[0][2] + rot[2][0]) / s;\n        q2 = (rot[1][2] + rot[2][1]) / s;\n        q3 = 0.25 * s;\n      }\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}