{
    "generation": "  /**\n   * Build the rotation that transforms a pair of vector into another pair.\n   *\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n   *\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n   *\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n      // norms computation\n      double u1u1 = u1.getNormSq();\n      double u2u2 = u2.getNormSq();\n      double v1v1 = v1.getNormSq();\n      double v2v2 = v2.getNormSq();\n      if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n          throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n      }\n\n      // normalize u1 and v1 to unit vectors\n      Vector3D u1Unit = u1.normalize();\n      Vector3D u2Unit = u2.subtract(u1.scalarMultiply(u1.dotProduct(u2) / u1u1)).normalize();\n\n      Vector3D v1Unit = v1.normalize();\n      Vector3D v2Proj = v2.subtract(v1.scalarMultiply(v1.dotProduct(v2) / v1v1));\n      if (v2Proj.getNormSq() == 0) {\n          // (v1, v2) are parallel, choose arbitrary orthogonal\n          v2Proj = Vector3D.crossProduct(v1, Vector3D.PLUS_I);\n          if (v2Proj.getNormSq() == 0) {\n              v2Proj = Vector3D.crossProduct(v1, Vector3D.PLUS_J);\n          }\n      }\n      Vector3D v2Unit = v2Proj.normalize();\n\n      // build bases\n      Vector3D u3Unit = Vector3D.crossProduct(u1Unit, u2Unit);\n      Vector3D v3Unit = Vector3D.crossProduct(v1Unit, v2Unit);\n\n      // Handle special case where the bases are close to being singular\n      double u3Norm = u3Unit.getNorm();\n      double v3Norm = v3Unit.getNorm();\n      if (u3Norm == 0.0 || v3Norm == 0.0) {\n          // fallback to identity\n          q0 = 1.0;\n          q1 = 0.0;\n          q2 = 0.0;\n          q3 = 0.0;\n          return;\n      }\n      u3Unit = u3Unit.scalarMultiply(1.0 / u3Norm);\n      v3Unit = v3Unit.scalarMultiply(1.0 / v3Norm);\n\n      // Build the matrix which transforms u basis to v basis\n      double[][] uMat = new double[][] {\n          { u1Unit.getX(), u2Unit.getX(), u3Unit.getX() },\n          { u1Unit.getY(), u2Unit.getY(), u3Unit.getY() },\n          { u1Unit.getZ(), u2Unit.getZ(), u3Unit.getZ() }\n      };\n      double[][] vMat = new double[][] {\n          { v1Unit.getX(), v2Unit.getX(), v3Unit.getX() },\n          { v1Unit.getY(), v2Unit.getY(), v3Unit.getY() },\n          { v1Unit.getZ(), v2Unit.getZ(), v3Unit.getZ() }\n      };\n\n      // Compute the rotation matrix: rM = vMat * uMat^T\n      double[][] rM = new double[3][3];\n      for (int i = 0; i < 3; ++i) {\n          for (int j = 0; j < 3; ++j) {\n              rM[i][j] = 0.0;\n              for (int k = 0; k < 3; ++k) {\n                  rM[i][j] += vMat[i][k] * uMat[j][k];\n              }\n          }\n      }\n\n      // Now convert rotation matrix to quaternion\n      double r00 = rM[0][0];\n      double r11 = rM[1][1];\n      double r22 = rM[2][2];\n      double trace = r00 + r11 + r22;\n\n      if (trace > 0.0) {\n          double s = FastMath.sqrt(trace + 1.0) * 2.0; // S=4*q0\n          q0 = 0.25 * s;\n          q1 = (rM[2][1] - rM[1][2]) / s;\n          q2 = (rM[0][2] - rM[2][0]) / s;\n          q3 = (rM[1][0] - rM[0][1]) / s;\n      } else if ((r00 > r11) && (r00 > r22)) {\n          double s = FastMath.sqrt(1.0 + r00 - r11 - r22) * 2.0; // S=4*q1\n          q0 = (rM[2][1] - rM[1][2]) / s;\n          q1 = 0.25 * s;\n          q2 = (rM[0][1] + rM[1][0]) / s;\n          q3 = (rM[0][2] + rM[2][0]) / s;\n      } else if (r11 > r22) {\n          double s = FastMath.sqrt(1.0 + r11 - r00 - r22) * 2.0; // S=4*q2\n          q0 = (rM[0][2] - rM[2][0]) / s;\n          q1 = (rM[0][1] + rM[1][0]) / s;\n          q2 = 0.25 * s;\n          q3 = (rM[1][2] + rM[2][1]) / s;\n      } else {\n          double s = FastMath.sqrt(1.0 + r22 - r00 - r11) * 2.0; // S=4*q3\n          q0 = (rM[1][0] - rM[0][1]) / s;\n          q1 = (rM[0][2] + rM[2][0]) / s;\n          q2 = (rM[1][2] + rM[2][1]) / s;\n          q3 = 0.25 * s;\n      }\n\n      // normalize quaternion (defensive, in case of numerical issues)\n      double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n      q0 /= norm;\n      q1 /= norm;\n      q2 /= norm;\n      q3 /= norm;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}