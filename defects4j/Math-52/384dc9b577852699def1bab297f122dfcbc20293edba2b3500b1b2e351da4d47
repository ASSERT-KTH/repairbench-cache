{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n      // norms computation\n      double u1u1 = u1.getNormSq();\n      double u2u2 = u2.getNormSq();\n      double v1v1 = v1.getNormSq();\n      double v2v2 = v2.getNormSq();\n      if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n          throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n      }\n\n      // normalize u1, u2, v1, v2\n      Vector3D u1n = new Vector3D(1.0 / FastMath.sqrt(u1u1), u1);\n      Vector3D u2n = new Vector3D(1.0 / FastMath.sqrt(u2u2), u2);\n      Vector3D v1n = new Vector3D(1.0 / FastMath.sqrt(v1v1), v1);\n      Vector3D v2n = new Vector3D(1.0 / FastMath.sqrt(v2v2), v2);\n\n      // Orthonormalize u2 with respect to u1\n      double proj = u1n.dotProduct(u2n);\n      Vector3D u2Ortho = u2n.subtract(new Vector3D(proj, u1n));\n      double normU2Ortho = u2Ortho.getNorm();\n      if (normU2Ortho == 0.0) {\n          // The two vectors are colinear or one is zero\n          throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n      }\n      u2Ortho = new Vector3D(1.0 / normU2Ortho, u2Ortho);\n\n      // Orthonormalize v2 with respect to v1\n      proj = v1n.dotProduct(v2n);\n      Vector3D v2Ortho = v2n.subtract(new Vector3D(proj, v1n));\n      double normV2Ortho = v2Ortho.getNorm();\n      if (normV2Ortho == 0.0) {\n          // The two vectors are colinear or one is zero\n          throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n      }\n      v2Ortho = new Vector3D(1.0 / normV2Ortho, v2Ortho);\n\n      // Now build third orthonormal vector by cross product\n      Vector3D u3 = u1n.crossProduct(u2Ortho);\n      Vector3D v3 = v1n.crossProduct(v2Ortho);\n\n      // Build the rotation matrix that maps u* to v*\n      // Each column is the coordinates of ui in the original frame\n      double[][] mU = new double[][] {\n          { u1n.getX(), u2Ortho.getX(), u3.getX() },\n          { u1n.getY(), u2Ortho.getY(), u3.getY() },\n          { u1n.getZ(), u2Ortho.getZ(), u3.getZ() }\n      };\n      double[][] mV = new double[][] {\n          { v1n.getX(), v2Ortho.getX(), v3.getX() },\n          { v1n.getY(), v2Ortho.getY(), v3.getY() },\n          { v1n.getZ(), v2Ortho.getZ(), v3.getZ() }\n      };\n\n      // Compute m = mV \u00d7 mU^T\n      double[][] m = new double[3][3];\n      for (int i = 0; i < 3; ++i) {\n          for (int j = 0; j < 3; ++j) {\n              m[i][j] = mV[i][0] * mU[j][0] + mV[i][1] * mU[j][1] + mV[i][2] * mU[j][2];\n          }\n      }\n\n      // Now convert the rotation matrix m to quaternion\n      double trace = m[0][0] + m[1][1] + m[2][2];\n      if (trace > 0.0) {\n          double s = FastMath.sqrt(trace + 1.0) * 2.0;\n          q0 = 0.25 * s;\n          q1 = (m[2][1] - m[1][2]) / s;\n          q2 = (m[0][2] - m[2][0]) / s;\n          q3 = (m[1][0] - m[0][1]) / s;\n      } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n          double s = FastMath.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2.0;\n          q0 = (m[2][1] - m[1][2]) / s;\n          q1 = 0.25 * s;\n          q2 = (m[0][1] + m[1][0]) / s;\n          q3 = (m[0][2] + m[2][0]) / s;\n      } else if (m[1][1] > m[2][2]) {\n          double s = FastMath.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2.0;\n          q0 = (m[0][2] - m[2][0]) / s;\n          q1 = (m[0][1] + m[1][0]) / s;\n          q2 = 0.25 * s;\n          q3 = (m[1][2] + m[2][1]) / s;\n      } else {\n          double s = FastMath.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2.0;\n          q0 = (m[1][0] - m[0][1]) / s;\n          q1 = (m[0][2] + m[2][0]) / s;\n          q2 = (m[1][2] + m[2][1]) / s;\n          q3 = 0.25 * s;\n      }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}