{
    "generation": "  /** Build the rotation that transforms a pair of vector into another pair.\n\n   * <p>Except for possible scale factors, if the instance were applied to\n   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n\n   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n   * not the same as the angular separation between v<sub>1</sub> and\n   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n   * v<sub>2</sub>) plane.</p>\n\n   * @param u1 first vector of the origin pair\n   * @param u2 second vector of the origin pair\n   * @param v1 desired image of u1 by the rotation\n   * @param v2 desired image of u2 by the rotation\n   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n   */\n  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n    if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n      throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // normalize vectors to improve numerical stability\n    Vector3D u1n = u1.normalize();\n    Vector3D u2n = u2.normalize();\n    Vector3D v1n = v1.normalize();\n    Vector3D v2n = v2.normalize();\n\n    // Build orthonormal bases {u1n,u2Ortho,u3Ortho} and {v1n,v2Ortho,v3Ortho}\n    Vector3D u2Ortho = u2n.subtract(u1n.scalarMultiply(u2n.dotProduct(u1n))).normalize();\n    Vector3D u3Ortho = u1n.crossProduct(u2Ortho);\n\n    Vector3D v2Ortho = v2n.subtract(v1n.scalarMultiply(v2n.dotProduct(v1n))).normalize();\n    Vector3D v3Ortho = v1n.crossProduct(v2Ortho);\n\n    // Compute rotation matrix mapping u-basis to v-basis:\n    // Each column is the image of the u-basis vector in the v-basis\n    double[][] m = new double[3][3];\n    m[0][0] = v1n.dotProduct(u1n);\n    m[0][1] = v1n.dotProduct(u2Ortho);\n    m[0][2] = v1n.dotProduct(u3Ortho);\n    m[1][0] = v2Ortho.dotProduct(u1n);\n    m[1][1] = v2Ortho.dotProduct(u2Ortho);\n    m[1][2] = v2Ortho.dotProduct(u3Ortho);\n    m[2][0] = v3Ortho.dotProduct(u1n);\n    m[2][1] = v3Ortho.dotProduct(u2Ortho);\n    m[2][2] = v3Ortho.dotProduct(u3Ortho);\n\n    // Now convert rotation matrix to quaternion\n    double trace = m[0][0] + m[1][1] + m[2][2];\n    if (trace > 0.0) {\n      double s = FastMath.sqrt(trace + 1.0) * 2.0;\n      q0 = 0.25 * s;\n      q1 = (m[2][1] - m[1][2]) / s;\n      q2 = (m[0][2] - m[2][0]) / s;\n      q3 = (m[1][0] - m[0][1]) / s;\n    } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n      double s = FastMath.sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2.0;\n      q0 = (m[2][1] - m[1][2]) / s;\n      q1 = 0.25 * s;\n      q2 = (m[0][1] + m[1][0]) / s;\n      q3 = (m[0][2] + m[2][0]) / s;\n    } else if (m[1][1] > m[2][2]) {\n      double s = FastMath.sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2.0;\n      q0 = (m[0][2] - m[2][0]) / s;\n      q1 = (m[0][1] + m[1][0]) / s;\n      q2 = 0.25 * s;\n      q3 = (m[1][2] + m[2][1]) / s;\n    } else {\n      double s = FastMath.sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2.0;\n      q0 = (m[1][0] - m[0][1]) / s;\n      q1 = (m[0][2] + m[2][0]) / s;\n      q2 = (m[1][2] + m[2][1]) / s;\n      q3 = 0.25 * s;\n    }\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}