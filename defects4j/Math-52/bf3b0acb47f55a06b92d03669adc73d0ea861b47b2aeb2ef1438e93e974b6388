{
    "generation": "import org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.exception.util.LocalizedFormats; // Assuming this path based on original code context\nimport org.apache.commons.math.MathRuntimeException; // Assuming this path based on original code context\n\n// Assuming Rotation class structure exists with q0, q1, q2, q3 fields\n// and Vector3D class exists with necessary methods like getNormSq, dotProduct, crossProduct, subtract, scalarMultiply, normalize, getX, getY, getZ.\n\n/** Build the rotation that transforms a pair of vector into another pair.\n * <p>Except for possible scale factors, if the instance were applied to\n * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n * (v<sub>1</sub>, v<sub>2</sub>).</p>\n * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n * not the same as the angular separation between v<sub>1</sub> and\n * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n * v<sub>2</sub>) plane.</p>\n * @param u1 first vector of the origin pair\n * @param u2 second vector of the origin pair\n * @param v1 desired image of u1 by the rotation\n * @param v2 desired image of u2 by the rotation\n * @exception IllegalArgumentException if the norm of one of the vectors is zero,\n * or if one of the pairs is degenerated (u1, u2 collinear or v1, v2 collinear)\n */\npublic Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n    // Tolerance for checking norms are non-zero. Use a small number relative to potential maximum values or machine epsilon.\n    final double NORM_ZERO_THRESHOLD = 1e-15;\n    // Threshold for checking cross product norm squared is non-zero (collinearity check).\n    // Use a relative threshold based on the squared norms of the input vectors.\n    final double CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR = 1e-28; // (epsilon^2 roughly)\n\n    // norms computation\n    double u1u1 = u1.getNormSq();\n    double u2u2 = u2.getNormSq();\n    double v1v1 = v1.getNormSq();\n    double v2v2 = v2.getNormSq();\n\n    // Check for zero norms\n    if ((u1u1 < NORM_ZERO_THRESHOLD) || (u2u2 < NORM_ZERO_THRESHOLD) ||\n        (v1v1 < NORM_ZERO_THRESHOLD) || (v2v2 < NORM_ZERO_THRESHOLD)) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n    }\n\n    // Check for collinearity of u1 and u2\n    final Vector3D u3 = Vector3D.crossProduct(u1, u2);\n    double u3u3 = u3.getNormSq();\n    if (u3u3 < CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * u1u1 * u2u2) {\n        // Provide a more specific error message if possible\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); // Ideally: VECTORS_ARE_COLLINEAR for u1, u2\n    }\n\n    // Check for collinearity of v1 and v2\n    final Vector3D v3_orig = Vector3D.crossProduct(v1, v2);\n    double v3v3_orig = v3_orig.getNormSq();\n    if (v3v3_orig < CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * v1v1 * v2v2) {\n        // Provide a more specific error message if possible\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); // Ideally: VECTORS_ARE_COLLINEAR for v1, v2\n    }\n\n    // normalize v1 to have the same norm as u1\n    // v1_adj = v1 * sqrt(|u1|^2 / |v1|^2)\n    final Vector3D v1_adj = v1.scalarMultiply(FastMath.sqrt(u1u1 / v1v1));\n\n    // adjust v2 to preserve scalar products and norms relative to v1_adj\n    // We want v2_adj = alpha * v1_adj + beta * v2 such that:\n    // v1_adj . v2_adj = u1 . u2\n    // v2_adj . v2_adj = u2 . u2\n\n    final double u1u2 = u1.dotProduct(u2);\n    final double v1_adj_v2 = v1_adj.dotProduct(v2); // Dot product using adjusted v1\n\n    // Compute squares of norms of components perpendicular to u1 and v1_adj respectively\n    // |u2_perp_u1|^2 = u2u2 - (u1.u2)^2 / u1u1\n    final double U2PerpNormSq = u2u2 - u1u2 * u1u2 / u1u1;\n    // |v2_perp_v1'|^2 = v2v2 - (v1'.v2)^2 / |v1'|^2 = v2v2 - v1_adj_v2^2 / u1u1\n    final double V2PerpNormSq = v2v2 - v1_adj_v2 * v1_adj_v2 / u1u1;\n\n    // Need to check V2PerpNormSq is positive before division (collinearity of v1,v2 again)\n    // This check should be redundant due to the earlier cross product check, but included for safety.\n    final double minPerpNormSq = CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * v1v1 * v2v2; // Relative threshold\n    if (V2PerpNormSq < minPerpNormSq) {\n        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); // Should not happen\n    }\n\n    // Compute scaling factor beta = |u2_perp_u1| / |v2_perp_v1'|\n    final double beta = FastMath.sqrt(U2PerpNormSq / V2PerpNormSq);\n    // Compute coefficient alpha for v1_adj component\n    final double alpha = (u1u2 - beta * v1_adj_v2) / u1u1;\n    // Compute adjusted v2: v2_adj = alpha * v1_adj + beta * v2\n    final Vector3D v2_adj = new Vector3D(alpha, v1_adj, beta, v2); // Assumes Vector3D constructor for linear combination\n\n    // Now we have pairs (u1, u2) and (v1_adj, v2_adj) with matching norms and dot products.\n    // Find the rotation mapping u1->v1_adj and u2->v2_adj.\n\n    // Compute the rotation angle cosine from u1 and v1_adj\n    // cos(theta) = (u1 . v1_adj) / (|u1| * |v1_adj|) = (u1 . v1_adj) / u1u1\n    double cosTheta = u1.dotProduct(v1_adj) / u1u1;\n    // Clamp cosTheta to [-1, 1] to handle potential numerical errors\n    cosTheta = FastMath.max(-1.0, FastMath.min(1.0, cosTheta));\n\n    // Compute scalar quaternion component q0 = cos(theta/2)\n    // We use the convention q0 >= 0, so theta is in [0, pi].\n    q0 = FastMath.sqrt((1.0 + cosTheta) / 2.0);\n\n    // Compute sin(theta/2) = sqrt((1 - cosTheta) / 2)\n    double sinHalfTheta = FastMath.sqrt((1.0 - cosTheta) / 2.0);\n\n    // Check if angle is close to 0 or pi (which implies sin(theta/2) is close to 0 or 1)\n    if (sinHalfTheta < NORM_ZERO_THRESHOLD) {\n        // Angle is ~0. Rotation is identity.\n        q0 = 1.0;\n        q1 = 0.0;\n        q2 = 0.0;\n        q3 = 0.0;\n    } else {\n        // Rotation is not identity. Need to find the rotation axis.\n        // The axis is orthogonal to u1 and v1_adj (if they are different).\n        // A robust way to find the axis direction 'k' is using cross products involving vector differences.\n        final Vector3D v1Su1 = v1_adj.subtract(u1);\n        final Vector3D v2Su2 = v2_adj.subtract(u2);\n        Vector3D k = v1Su1.crossProduct(v2Su2);\n        double kNormSq = k.getNormSq();\n\n        // Threshold for checking if kNormSq is too small\n        double v1Su1NormSq = v1Su1.getNormSq();\n        double v2Su2NormSq = v2Su2.getNormSq();\n        final double minKNormSq = CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * v1Su1NormSq * v2Su2NormSq;\n\n        // If k is too small, try alternative vector combinations.\n        // This usually happens when the rotation axis is close to the plane of the vectors used.\n        if (kNormSq < minKNormSq) {\n            final Vector3D v3_adj = Vector3D.crossProduct(v1_adj, v2_adj);\n            final Vector3D v3Su3 = v3_adj.subtract(u3); // u3 = u1 x u2\n            double v3Su3NormSq = v3Su3.getNormSq();\n            k = v1Su1.crossProduct(v3Su3);\n            kNormSq = k.getNormSq();\n\n            if (kNormSq < CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * v1Su1NormSq * v3Su3NormSq) {\n                k = v2Su2.crossProduct(v3Su3);\n                kNormSq = k.getNormSq();\n\n                if (kNormSq < CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * v2Su2NormSq * v3Su3NormSq) {\n                    // All difference cross products are small. This implies u_i are close to v_i.\n                    // The only remaining problematic case is a 180-degree rotation (cosTheta = -1).\n                    // In this case, v1_adj = -u1. k = (-2u1) x (v2_adj - u2).\n                    // If v2_adj - u2 is parallel to u1, k is zero.\n                    if (cosTheta < (-1.0 + NORM_ZERO_THRESHOLD)) { // Check if angle is ~180 degrees\n                        // Axis is orthogonal to u1. Find a vector orthogonal to u1.\n                        // Example: u1 x w where w is a basis vector not parallel to u1.\n                        Vector3D w;\n                        double u1X2 = u1.getX() * u1.getX();\n                        double u1Y2 = u1.getY() * u1.getY();\n                        double u1Z2 = u1.getZ() * u1.getZ();\n                        // Protect against u1 being zero vector (already checked)\n                        // Choose w along axis with smallest u1 component projection squared\n                        if ((u1X2 <= u1Y2) && (u1X2 <= u1Z2)) {\n                            w = Vector3D.PLUS_I;\n                        } else if (u1Y2 <= u1Z2) {\n                            w = Vector3D.PLUS_J;\n                        } else {\n                            w = Vector3D.PLUS_K;\n                        }\n                        k = Vector3D.crossProduct(u1, w);\n                        kNormSq = k.getNormSq();\n                        // Check if u1 was parallel to w (should not happen with this choice if u1 is non-zero)\n                        if (kNormSq < CROSS_PRODUCT_ZERO_THRESHOLD_SQUARED_FACTOR * u1u1 * w.getNormSq()) {\n                           throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR); // Cannot determine axis for 180 deg rotation\n                        }\n                    } else {\n                        // Angle is not 180 degrees, but k is still small. This implies identity rotation.\n                        // Should have been caught by sinHalfTheta check? Or numerical instability.\n                        // Assume identity if k is numerically zero and angle is not 180 deg.\n                         q0 = 1.0; q1 = 0.0; q2 = 0.0; q3 = 0.0; return;\n                    }\n                }\n            }\n        }\n\n        // We have a non-zero vector k proportional to the axis. Normalize it.\n        Vector3D axis = k.normalize(); // normalize() should handle non-zero norm\n\n        // Compute vector part q = sin(theta/2) * axis\n        Vector3D qVec = axis.scalarMultiply(sinHalfTheta);\n        q1 = qVec.getX();\n        q2 = qVec.getY();\n        q3 = qVec.getZ();\n    }\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}