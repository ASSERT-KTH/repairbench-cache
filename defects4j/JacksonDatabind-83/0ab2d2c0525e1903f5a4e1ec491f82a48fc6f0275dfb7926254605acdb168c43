{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            text = text.trim();\n            if (text.isEmpty()) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                // 21-Nov-2017, tatu: ... potentially check for empty string config\n                // Assume _deserializeFromEmptyString(ctxt) exists and handles based on context/config\n                // (passing context might be a necessary change depending on base class)\n                // Let's stick closer to original by not passing context if it wasn't there,\n                // assuming the base class or specific implementation handles it.\n                // If _deserializeFromEmptyString needs context, the original was also buggy there.\n                // Let's assume the original call signature was intended for the version.\n                return _deserializeFromEmptyString();\n            }\n\n            // We have non-empty textual representation.\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value. So simply call and return:\n                 T result = _deserialize(text, ctxt);\n                 // Call succeeded, return result (could be null)\n                 return result;\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // [databind#1629]: Problem handlers may be able to resolve this\n                // Store cause for exception enrichment if handler fails\n                cause = e;\n                String msg = cause.getMessage();\n                // Ask handler first\n                // 05-May-2016, tatu: Unlike most usage, this seems legit, so... call handler\n                Object result = ctxt.handleWeirdStringValue(_valueClass, text,\n                        \"not a valid textual representation\" + (msg == null ? \"\" : (\", problem: \"+msg))\n                );\n                // If NOT_HANDLED, will throw exception later; if anything else, use that:\n                if (result != DeserializationProblemHandler.NOT_HANDLED) {\n                    return (T) result;\n                }\n                // If not handled, construct and throw the exception: use specific exception from context\n                // to allow overrides AND pass original cause\n                JsonMappingException jme = ctxt.weirdStringException(text, _valueClass,\n                        \"not a valid textual representation\" + (msg == null ? \"\" : (\", problem: \"+msg)));\n                if (cause != null) { // should be non-null here\n                     jme.initCause(cause);\n                }\n                 throw jme;\n                // NOTE: changed from InvalidFormatException.from(...) back to weirdStringException(...)\n                // based on closer reading of original code's intent and comments, but fixing the\n                // subsequent NPE and unconditional throw. weirdStringException returns null if handled,\n                // throws exception otherwise. We already checked handler via handleWeirdStringValue,\n                // so we know it wasn't handled. weirdStringException will confirm this and throw.\n            }\n            // Other kinds of exceptions (like IOException) not caught, propagate naturally.\n        }\n\n        // [databind#381]: Support for array representation of scalars\n        JsonToken t = p.currentToken(); // Need current token check\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n\n        // Then check for embedded object\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            // 30-Sep-2018, tatu: Need to delegate handler for this too\n            return _deserializeEmbedded(ob, ctxt);\n        }\n\n        // Otherwise, declare unrecognized value type\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}