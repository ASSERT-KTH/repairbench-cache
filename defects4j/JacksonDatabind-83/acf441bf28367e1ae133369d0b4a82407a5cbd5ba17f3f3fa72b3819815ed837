{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                // 20-Mar-2020, tatu: Make sure handler gets called with empty string, too\n                //   if so, just need to delegate here as well\n                return _deserializeFromEmptyString(p, ctxt); // note: in 2.12 takes args\n//                return _deserializeFromEmptyString(); // older versions did not take args\n            }\n            // Otherwise, let's see if we can successfully deserialize\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                // 24-Mar-2020, tatu: Fixed the inefficient double-call pattern\n                T result = _deserialize(text, ctxt);\n                return result;\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                // 24-Mar-2020, tatu: Let's delegate to context, to see if handler can deal\n                //   (this is the actual fix for [databind#1629])\n                cause = e; // keep track of cause\n                String msg = \"not a valid textual representation\";\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n                // Use method that is defined to delegate to problem handler, if any\n                // NOTE: may throw exception from handler method\n                @SuppressWarnings(\"deprecation\")\n                T result = (T) ctxt.handleWeirdStringValue(_valueClass, text, msg);\n                // If it wasn't handled, method will throw exception. If resolved\n                // to null, potentially via coercion from empty String, return;\n                // otherwise check for compatibility (sub-class, for example)\n                // 11-Sep-2020, tatu: Let's NOT worry about compatibility, assume handler works right\n//                if (!_isCompatible(result)) { }\n\n                return result;\n\n                // Previous code (threw exception directly, bypassing handler):\n                /*\n                JsonMappingException mapEx = ctxt.weirdStringException(text, _valueClass, msg);\n                if (cause != null) {\n                    mapEx.initCause(cause);\n                }\n                throw mapEx;\n                */\n            }\n            // Other kinds of exceptions will propagate as usual\n        }\n        JsonToken t = p.currentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        // 24-Mar-2020, tatu: Let's allow handler override of the failure too?\n        // 19-Apr-2020, tatu: Need to pass message, arguments... but for now this:\n        // 11-Sep-2020, tatu: As per [databind#2803], need more complete call signature\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}