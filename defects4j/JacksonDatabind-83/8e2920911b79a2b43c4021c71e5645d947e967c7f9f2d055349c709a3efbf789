{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            text = text.trim();\n            // 24-Jun-2020: Coerce empty String to null value, unless prohibited\n            // 17-Dec-2020, tatu: ... or handled by problem handler\n            if (text.isEmpty()) {\n                 // Usually should become null; but not always.\n                 // Delegate to context/handler mechanism first.\n                 String msg = String.format(\"Cannot deserialize value of type %s from empty String\",\n                          ClassUtil.nameOf(_valueClass));\n                 Object result = ctxt.handleWeirdStringValue(_valueClass, text, msg);\n                 if (result == DeserializationProblemHandler.NOT_HANDLED) {\n                     // If not handled, use default handling (which might still return null,\n                     // or throw exception, depending on context)\n                     // Mimic the behavior of _deserializeFromEmptyString which called handleMissingInstantiator\n                    return (T) ctxt.handleMissingInstantiator(_valueClass, null, p, msg);\n                 }\n                 // Otherwise handler handled it (possibly returning null)\n                 return (T) result;\n            }\n            \n            // Otherwise, try parsing from non-empty String\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                // 24-Jun-2020, tatu: Call once, NOT twice\n                T result = _deserialize(text, ctxt);\n                return result;\n            // Catch specific expected exceptions...\n            } catch (IllegalArgumentException | MalformedURLException e) {\n                cause = e;\n                // and let context try to handle them via DeserializationProblemHandler\n                String msg = \"not a valid textual representation\";\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \" + m2;\n                }\n                Object result = ctxt.handleWeirdStringValue(_valueClass, text, msg);\n                // If NOT_HANDLED, means DPH did not handle; throw exception like originally\n                if (result == DeserializationProblemHandler.NOT_HANDLED) {\n                     JsonMappingException jme = ctxt.weirdStringException(text, _valueClass, msg);\n                     jme.initCause(cause);\n                     throw jme;\n                }\n                // Otherwise, handler handled it, return result (which might be null)\n                return (T) result;\n            }\n            // Other kinds of exceptions will propagate just fine\n        }\n        \n        // What if not sent as String? Maybe START_ARRAY (for single-element array to value)\n        // or embedded object?\n        JsonToken t = p.currentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            // Let's delegate array handling to specialist method, again, for better recovery etc\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            // 30-Sep-2018, tatu: Related to [databind#2119], let's verify cases where this may be called\n            // 24-Jun-2020, tatu: Ok seems this may be called for things like UUID etc too\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        // Can't deal with anything else\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}