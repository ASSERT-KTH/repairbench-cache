{
    "generation": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            \n            // Fix: Capture the result of _deserialize once, and handle potential exceptions.\n            Object result = null;\n            Exception cause = null;\n            try {\n                // Call the protected _deserialize method which concrete deserializers implement.\n                // This method might internally call ctxt.handleWeirdStringValue, which\n                // in turn can consult DeserializationProblemHandlers.\n                result = _deserialize(text, ctxt);\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            // If `result` is non-null, or if `result` is null BUT no exception (`cause`) occurred,\n            // it means a ProblemHandler successfully processed the input (possibly returning null).\n            // In the UUID test case, UUIDDeserializer._deserialize catches IllegalArgumentException,\n            // calls ctxt.handleWeirdStringValue which calls WeirdStringHandler, and if handler returns null,\n            // UUIDDeserializer._deserialize returns null. No exception propagates, so 'cause' remains null.\n            if (result != null || (result == null && cause == null)) {\n                return (T) result;\n            }\n\n            // If we reach here, 'result' is null AND 'cause' is not null.\n            // This means _deserialize did not produce a value, and an explicit parsing error occurred\n            // that was not (or could not be) fully handled by a ProblemHandler.\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n        }\n        JsonToken t = p.getCurrentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}