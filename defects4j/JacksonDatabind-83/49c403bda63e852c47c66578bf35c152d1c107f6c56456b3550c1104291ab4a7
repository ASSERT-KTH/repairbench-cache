{
    "generation": "@SuppressWarnings(\"unchecked\")\n@Override\npublic T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // try to see if we have a String value\n    String text = p.getValueAsString();\n    if (text != null) {\n        // trim or handle empty\n        text = text.trim();\n        if (text.isEmpty()) {\n            return _deserializeFromEmptyString();\n        }\n        // try real conversion; allow null return as legitimate\n        try {\n            return _deserialize(text, ctxt);\n        } catch (IllegalArgumentException|MalformedURLException cause) {\n            // build failure message and let any ProblemHandler handle it\n            String msg = \"not a valid textual representation\";\n            String cm = cause.getMessage();\n            if (cm != null) {\n                msg += \", problem: \" + cm;\n            }\n            // will either return a handler\u2010provided value (possibly null),\n            // or throw a MismatchedInputException\n            return (T) ctxt.handleWeirdStringValue(_valueClass, text, msg);\n        }\n    }\n    // if not a String, fall back on non-textual handling\n    JsonToken t = p.getCurrentToken();\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}