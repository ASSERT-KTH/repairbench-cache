{
    "generation": "    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0); // Column 0 is the constant term of the objective function (always removed)\n\n        // positive cost non-artificial variables\n        // These are variables (typically slack/surplus or original variables)\n        // that are not artificial but have a positive coefficient in the phase 1 objective.\n        // They are usually non-basic and are removed.\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i); // Check the coefficient in the phase 1 objective row (row 0)\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        // These are artificial variables that are not part of the current basis.\n        // They are no longer needed for phase 2.\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          // getBasicRow(col) returns the row index if 'col' is a basic variable, null otherwise.\n          if (getBasicRow(col) == null) { // If 'col' is a non-basic artificial variable\n            columnsToDrop.add(col);\n          }\n        }\n\n        // Sort the indices to drop in ascending order. This is important for:\n        // 1. Correctly calculating the new indices for basic variables.\n        // 2. Ensuring that columnLabels.remove works correctly when removing in reverse order.\n        Collections.sort(columnsToDrop);\n\n        // Construct the new matrix without the dropped columns and the phase 1 objective row.\n        // The new matrix will have one less row (phase 1 objective) and `columnsToDrop.size()` fewer columns.\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) { // Iterate through original rows, starting from row 1 (phase 2 objective and constraints)\n          int col = 0; // Column index for the new matrix\n          for (int j = 0; j < getWidth(); j++) { // Iterate through all original columns\n            if (!columnsToDrop.contains(j)) { // If the current column 'j' is NOT in the list of columns to drop\n              matrix[i - 1][col++] = tableau.getEntry(i, j); // Copy the entry to the new matrix, adjusting row index\n            }\n          }\n        }\n\n        // Update column labels.\n        // Iterate in reverse order of the sorted indices to drop. This prevents index shifting issues\n        // when removing elements from a List by index.\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        // The core fix: Update basicRows to reflect the new column indices.\n        // The basicRows array maps row index to the column index of its basic variable.\n        // Since row 0 (phase 1 objective) is removed, all subsequent row indices shift by -1.\n        // Also, column indices for non-dropped columns shift based on how many columns before them were dropped.\n        int[] newBasicRows = new int[getHeight() - 1];\n        // Iterate through the original basicRows from row 1 onwards (as original row 0 is dropped).\n        for (int i = 1; i < getHeight(); i++) {\n            int originalBasicCol = basicRows[i]; // Get the original basic column index for this row\n\n            // Calculate the new column index for this basic variable.\n            // Subtract 1 from the original column index for every column dropped that came before it.\n            int newBasicCol = originalBasicCol;\n            for (Integer droppedColIdx : columnsToDrop) {\n                if (droppedColIdx < originalBasicCol) {\n                    newBasicCol--;\n                }\n            }\n            // Assign the new basic column index to the corresponding new row index (original row index - 1).\n            newBasicRows[i - 1] = newBasicCol;\n        }\n        this.basicRows = newBasicRows; // Update the tableau's basicRows member.\n\n        // Update the tableau's matrix.\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        // Reset the count of artificial variables as they are no longer in use in phase 2.\n        this.numArtificialVariables = 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}