{
    "generation": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\nimport org.apache.commons.math3.util.Precision;\n\n// Assuming this code is within the org.apache.commons.math3.optimization.linear.SimplexTableau class\n// which has access to fields like: tableau, numArtificialVariables, columnLabels, maxUlps, basicRows, basicVariables\n// and methods like: getNumObjectiveFunctions, getArtificialVariableOffset, getNumArtificialVariables, getBasicRow, getHeight, getWidth\n\n    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        // Do NOT drop column 0 (RHS column)\n\n        // Identify columns corresponding to positive cost non-artificial variables in Phase 1 objective (row 0)\n        // Non-artificial variables are in columns 1 to getArtificialVariableOffset() - 1\n        for (int i = 1; i < getArtificialVariableOffset(); i++) { // Start from column 1\n            final double entry = tableau.getEntry(0, i); // Phase 1 objective is in row 0\n            // Use maxUlps for comparison as in the original code\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // Identify columns corresponding to non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) { // Check if variable is non-basic\n            columnsToDrop.add(col);\n          }\n        }\n\n        // Create the new matrix, removing row 0 (Phase 1 objective) and the identified columns\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n\n        // Create mapping for old column index to new column index\n        int currentNewCol = 0;\n        // Use an array for efficient lookup; initialize with -1 for dropped columns\n        int[] oldColToNewCol = new int[getWidth()];\n        java.util.Arrays.fill(oldColToNewCol, -1); // Initialize all as dropped\n        for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n                oldColToNewCol[j] = currentNewCol++;\n            }\n        }\n\n        // Copy row by row, skipping row 0 and columns in columnsToDrop\n        for (int i = 1; i < getHeight(); i++) { // Start from row 1 (Phase 2 objective or first constraint)\n          int newMatrixCol = 0;\n          for (int j = 0; j < getWidth(); j++) { // Iterate through columns of the old tableau\n            if (!columnsToDrop.contains(j)) { // Check if column should be kept\n              // Row index in new matrix is i - 1\n              // Column index in new matrix is newMatrixCol (which corresponds to oldColToNewCol[j])\n              matrix[i - 1][newMatrixCol++] = tableau.getEntry(i, j); // Copy entry to new matrix\n            }\n          }\n        }\n\n        // Update column labels by removing labels for dropped columns\n        // Sort columnsToDrop indices in descending order for safe removal by index\n        Collections.sort(columnsToDrop, Collections.reverseOrder());\n        for (int colIndex : columnsToDrop) {\n          columnLabels.remove(colIndex); // Remove by index\n        }\n\n        // Update the basic variable maps {column -> row} and {row -> column}\n        Map<Integer, Integer> newBasicRows = new HashMap<>();\n        Map<Integer, Integer> newBasicVariables = new HashMap<>();\n        if (this.basicRows != null) { // Check if map exists (it should)\n            for (Map.Entry<Integer, Integer> entry : this.basicRows.entrySet()) {\n                int oldCol = entry.getKey();\n                int oldRow = entry.getValue();\n\n                // Only consider basic variables that are not dropped and whose rows are kept (i.e., oldRow >= 1)\n                if (oldRow >= 1 && !columnsToDrop.contains(oldCol)) {\n                    int newCol = oldColToNewCol[oldCol]; // Map old column to new column index\n                    int newRow = oldRow - 1; // Row index shifts down by 1\n\n                    // Ensure the mapping was successful (newCol >= 0)\n                    if (newCol >= 0) {\n                         newBasicRows.put(newCol, newRow);\n                         // basicVariables map should always be maintained if basicRows is\n                         if (newBasicVariables != null) {\n                             newBasicVariables.put(newRow, newCol);\n                         }\n                    }\n                }\n            }\n             this.basicRows = newBasicRows;\n             // Only update basicVariables if it was previously being maintained (it should be)\n             if (this.basicVariables != null) {\n                 this.basicVariables = newBasicVariables;\n             }\n        }\n\n\n        // Update the tableau and artificial variable count\n        // Use copy=false for efficiency as the matrix array is newly created\n        this.tableau = new Array2DRowRealMatrix(matrix, false);\n        this.numArtificialVariables = 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}