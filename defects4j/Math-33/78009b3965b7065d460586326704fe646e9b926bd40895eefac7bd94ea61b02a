{
    "generation": "    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0); // Always drop the phase 1 objective column (column 0)\n\n        // Identify positive cost non-artificial variables in the phase 1 objective row (row 0).\n        // These are variables (original or slack/surplus) that have a positive coefficient\n        // in the phase 1 objective function. Such variables should be removed from the tableau\n        // for phase 2.\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i); // Check the coefficient in the phase 1 objective row\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) { // If the coefficient is effectively positive\n                columnsToDrop.add(i); // Add the column index to the list of columns to drop\n            }\n        }\n\n        // Identify non-basic artificial variables.\n        // At the end of phase 1, if the phase 1 objective value is zero, all artificial variables\n        // must have a value of zero. Non-basic artificial variables can therefore be removed.\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n            int col = i + getArtificialVariableOffset(); // Calculate the actual column index of the artificial variable\n            if (getBasicRow(col) == null) { // If the artificial variable is non-basic (not part of the current basis)\n                columnsToDrop.add(col); // Add its column index to the list of columns to drop\n            }\n        }\n\n        // Create the new tableau matrix. It will have one less row (the phase 1 objective row)\n        // and fewer columns (the dropped columns).\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) { // Iterate over rows, starting from row 1 (skipping phase 1 objective row)\n            int col = 0; // Initialize column index for the new matrix row\n            for (int j = 0; j < getWidth(); j++) { // Iterate over columns of the original tableau\n                if (!columnsToDrop.contains(j)) { // If the current column 'j' is not in the list of columns to drop\n                    matrix[i - 1][col++] = tableau.getEntry(i, j); // Copy the element to the new matrix. 'i-1' adjusts for the removed row 0.\n                }\n            }\n        }\n\n        // BUG FIX: The original code for updating columnLabels was incorrect.\n        // It attempted to remove elements by index from the existing list, but the indices\n        // in `columnsToDrop` refer to original positions, and `List.remove(int index)` shifts\n        // subsequent elements, leading to incorrect removals when multiple columns are dropped.\n        // The fix is to reconstruct the `columnLabels` list entirely based on which\n        // columns are retained.\n        List<Integer> newColumnLabels = new ArrayList<Integer>();\n        for (int j = 0; j < getWidth(); j++) { // Iterate over the original column indices\n            if (!columnsToDrop.contains(j)) { // If this column is not scheduled to be dropped\n                newColumnLabels.add(columnLabels.get(j)); // Add its original label to the new list\n            }\n        }\n        this.columnLabels = newColumnLabels; // Update the tableau's column labels to the new list\n\n        // Update the tableau matrix and set the number of artificial variables to zero.\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}