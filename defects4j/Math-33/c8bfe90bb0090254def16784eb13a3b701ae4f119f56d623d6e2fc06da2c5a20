{
    "generation": "    /**\n     * Removes the phase 1 objective function, positive cost non-artificial variables,\n     * and the non-basic artificial variables from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        // Identify columns corresponding to variables to drop (NOT including column 0 - RHS)\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n\n        // Positive cost non-artificial variables in the phase 1 objective row (row 0)\n        // Variables start after the objective function columns.\n        // getNumObjectiveFunctions() gives the index of the first variable column.\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            // If the reduced cost in phase 1 objective is positive, mark column for removal\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // Non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          // Check if the artificial variable is non-basic (its column is not a basic variable)\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        // Create the new matrix excluding row 0 (phase 1 objective) and the selected columns\n        // New dimensions: height-1 rows, width - columnsToDrop.size() columns\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n\n        // Copy row by row, skipping row 0\n        for (int i = 1; i < getHeight(); i++) {\n          int targetCol = 0; // Column index for the new matrix\n          // Copy column by column for the current row\n          for (int j = 0; j < getWidth(); j++) {\n            // Check if current column j should be dropped\n            boolean drop = false;\n            // Use contains for efficient checking if list size grows\n            if (columnsToDrop.contains(j)) {\n                 drop = true;\n            }\n            // If the column is not dropped, copy the entry\n            if (!drop) {\n              // Copy from original tableau (row i, col j) to new matrix (row i-1, targetCol)\n              matrix[i - 1][targetCol++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        // Remove column labels for the dropped variable columns.\n        // Sort the indices in descending order to handle index shifts correctly during removal.\n        Collections.sort(columnsToDrop, Collections.reverseOrder());\n        for (int colIndex : columnsToDrop) {\n          // Ensure index is valid before removing. Should be fine if logic is correct.\n          if (colIndex < columnLabels.size()) {\n             columnLabels.remove(colIndex);\n          } else {\n             // Log or handle potential error: index out of bounds for columnLabels\n             // This might indicate an issue in calculating columnsToDrop or inconsistency\n             // between tableau width and columnLabels size.\n          }\n        }\n\n        // Update the tableau with the new matrix\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        // Reset the count of artificial variables as they are effectively removed\n        this.numArtificialVariables = 0;\n        // Note: numObjectiveFunctions is not explicitly updated here.\n        // It's assumed the caller or subsequent operations handle the transition correctly.\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}