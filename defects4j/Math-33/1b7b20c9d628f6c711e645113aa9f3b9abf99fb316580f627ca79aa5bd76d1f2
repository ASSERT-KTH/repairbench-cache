{
    "generation": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\n// Note: Ensure other necessary imports like RealMatrix and Precision are available if needed elsewhere in the class.\n\n// Inside the SimplexTableau class...\n\n    /**\n     * Removes the phase 1 objective function row and the non-basic artificial variables columns\n     * from this tableau.\n     */\n    protected void dropPhase1Objective() {\n        // Check if we are already in phase 2 (only one objective function)\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        // Identify the columns corresponding to non-basic artificial variables.\n        // These columns should be dropped.\n        Set<Integer> columnsToDrop = new HashSet<Integer>();\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n            int artificialVarColIndex = i + getArtificialVariableOffset();\n            // A variable is non-basic if it's not in the basis (getBasicRow returns null).\n            if (getBasicRow(artificialVarColIndex) == null) {\n                columnsToDrop.add(artificialVarColIndex);\n            }\n        }\n\n        // Create the data array for the new tableau matrix.\n        // The new matrix will have one less row (row 0, the phase 1 objective, is removed)\n        // and fewer columns (non-basic artificial variable columns are removed).\n        final int newHeight = getHeight() - 1;\n        final int newWidth = getWidth() - columnsToDrop.size();\n        double[][] matrixData = new double[newHeight][newWidth];\n\n        // Populate the new matrix data by copying entries from the old tableau,\n        // skipping row 0 and the columns marked for dropping.\n        for (int i = 1; i < getHeight(); i++) { // Iterate old rows, skipping row 0.\n            int newMatrixCol = 0; // Column index for the new matrix data array.\n            for (int j = 0; j < getWidth(); j++) { // Iterate old columns.\n                if (!columnsToDrop.contains(j)) { // If this column is kept...\n                    // Copy the value to the new matrix data.\n                    // The row index in the new matrix is 'i - 1' because row 0 was skipped.\n                    matrixData[i - 1][newMatrixCol++] = tableau.getEntry(i, j);\n                }\n            }\n        }\n\n        // Update the list of column labels: remove labels for the dropped columns.\n        // Get a sorted list of columns to drop to remove labels correctly by index.\n        List<Integer> sortedColumnsToDrop = new ArrayList<Integer>(columnsToDrop);\n        Collections.sort(sortedColumnsToDrop);\n\n        // Remove labels from right to left (highest index first) to avoid index shifting issues\n        // when removing elements from the list.\n        for (int i = sortedColumnsToDrop.size() - 1; i >= 0; i--) {\n            columnLabels.remove((int) sortedColumnsToDrop.get(i));\n        }\n\n        // Update the map of basic variables: adjust row and column indices.\n        Map<Integer, Integer> newBasicVariables = new HashMap<Integer, Integer>();\n        for (Map.Entry<Integer, Integer> entry : basicVariables.entrySet()) {\n            Integer oldColumnIndex = entry.getKey();\n            // Consider only basic variables whose columns are *not* being dropped.\n            // Note: Basic artificial variables might remain if they were basic at level zero;\n            // their columns are not dropped, and they are treated as regular variables in Phase 2.\n            if (!columnsToDrop.contains(oldColumnIndex)) {\n                int oldRowIndex = entry.getValue();\n                // New row index is one less because row 0 was removed.\n                int newRowIndex = oldRowIndex - 1;\n\n                // Calculate the new column index: subtract the count of dropped columns\n                // that appeared *before* this column's original index.\n                int droppedCountBefore = 0;\n                for (int droppedCol : sortedColumnsToDrop) {\n                    if (droppedCol < oldColumnIndex) {\n                        droppedCountBefore++;\n                    } else {\n                        // Optimization: since the list of dropped columns is sorted,\n                        // we can stop counting once we encounter a dropped column index\n                        // that is not smaller than the current variable's column index.\n                        break;\n                    }\n                }\n                int newColumnIndex = oldColumnIndex - droppedCountBefore; // Adjust column index.\n\n                // Add the updated mapping (new column index -> new row index) to the new map,\n                // but only if the adjusted row index is valid (non-negative).\n                if (newRowIndex >= 0) {\n                    newBasicVariables.put(newColumnIndex, newRowIndex);\n                }\n                // If newRowIndex < 0, it would imply the basic variable was in the objective row (row 0).\n                // This should not happen in a standard Simplex tableau structure after Phase 1 initialization.\n            }\n        }\n        // Replace the old basic variables map with the newly computed map.\n        this.basicVariables = newBasicVariables;\n\n        // Update the tableau's underlying matrix reference with the new matrix.\n        // Use the 'false' flag in the constructor to avoid making another copy of the 'matrixData' array.\n        this.tableau = new Array2DRowRealMatrix(matrixData, false);\n\n        // Phase 1 is complete, so set the number of artificial variables to 0.\n        // Any remaining artificial variables (which must be basic at level 0)\n        // are now treated like other variables.\n        this.numArtificialVariables = 0;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}