{
    "generation": "    /**\n      * Returns the percentage of values that are equal to v\n     * (as a proportion between 0 and 1).\n     * <p>\n     * Returns <code>Double.NaN</code> if no values have been added.</p>\n     *\n     * @param v the value to lookup\n     * @return the proportion of values equal to v\n     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n     */\n    @Deprecated\n    public double getPct(Object v) {\n        if (v instanceof Number) {\n            // For Number types, we need to handle possible type mismatches\n            // by checking all numeric values that might be equivalent\n            long count = 0;\n            long total = 0;\n            for (Object[] entry : getCounts().entrySet()) {\n                Object key = entry[0];\n                Long frequency = (Long) entry[1];\n                total += frequency;\n                if (key instanceof Number) {\n                    Number keyNum = (Number) key;\n                    Number vNum = (Number) v;\n                    // Compare values numerically, not by reference\n                    if (compareNumbers(keyNum, vNum) == 0) {\n                        count += frequency;\n                    }\n                }\n            }\n            return total == 0 ? Double.NaN : (double) count / (double) total;\n        } else {\n            // For non-Number types, do regular comparison\n            long count = 0;\n            long total = 0;\n            for (Object[] entry : getCounts().entrySet()) {\n                Object key = entry[0];\n                Long frequency = (Long) entry[1];\n                total += frequency;\n                if (key.equals(v)) {\n                    count += frequency;\n                }\n            }\n            return total == 0 ? Double.NaN : (double) count / (double) total;\n        }\n    }\n\n    /**\n     * Helper method to compare two Numbers numerically\n     */\n    private int compareNumbers(Number n1, Number n2) {\n        // If both are integers (byte, short, int, long)\n        if (isInteger(n1) && isInteger(n2)) {\n            return Long.compare(n1.longValue(), n2.longValue());\n        }\n        // Otherwise compare as doubles\n        return Double.compare(n1.doubleValue(), n2.doubleValue());\n    }\n\n    /**\n     * Check if a number is an integer type\n     */\n    private boolean isInteger(Number n) {\n        return n instanceof Byte || n instanceof Short ||\n               n instanceof Integer || n instanceof Long;\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}