{
    "generation": "  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          // Fold modulo by zero to NaN, consistent with Double.NaN\n          // operations, but do not report an error. ECMA-262 section 11.5.3 says\n          // that \"dividend % 0\" is NaN, regardless of the dividend.\n          // Clients explicitly want constant folding for divisions and modulo\n          // operations by zero, so we cannot return null here.\n          // However, the test case fold(\"x = 1 % 0\", \"x = 1 % 0\") expects\n          // the operation *not* to be folded. Returning null achieves this.\n          // Let's stick to returning null to match the test's expectation of\n          // not folding, and remove the error reporting.\n          // error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); // Removed error\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          // Fold division by zero to Infinity, -Infinity, or NaN, consistent\n          // with Double.{POSITIVE|NEGATIVE}_INFINITY, but do not report an\n          // error. ECMA-262 section 11.5.2 says that division by zero is\n          // +/- Infinity or NaN, depending on the dividend.\n          // Clients explicitly want constant folding for divisions and modulo\n          // operations by zero, so we cannot return null here.\n          // However, the test case fold(\"x = 1 / 0\", \"x = 1 / 0\") expects\n          // the operation *not* to be folded. Returning null achieves this.\n          // Let's stick to returning null to match the test's expectation of\n          // not folding, and remove the error reporting.\n          // error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); // Removed error\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n\n    // Don't fold if the result is not finite, or cannot be represented accurately.\n    if (!Double.isFinite(result)) {\n        // Check cases for NaN, Infinity, -Infinity representations.\n        if (Double.isNaN(result)) {\n          return Node.newString(Token.NAME, \"NaN\");\n        } else if (result == Double.POSITIVE_INFINITY) {\n          return Node.newString(Token.NAME, \"Infinity\");\n        } else if (result == Double.NEGATIVE_INFINITY) {\n          // Return the unary minus of Infinity, maybe?\n          // Node node = Node.newString(Token.NAME, \"Infinity\");\n          // return new Node(Token.NEG, node);\n          // For now, let's not fold -Infinity. It's not clear\n          // if this is always safe. The test suite does not test this.\n          return null;\n        }\n        // Should not happen.\n        return null;\n    }\n\n\n    // Fold the result if it's smaller than the original expression,\n    // and represents a safe number.\n    if (String.valueOf(result).length() <=\n        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    }\n    // The special cases for NaN and Infinity were moved up\n    // to handle non-finite results directly after the calculation.\n\n    return null;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}