{
    "generation": "  /**\n   * Try to fold arithmetic binary operators\n   */\n  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD\n        && (NodeUtil.mayBeString(left, false)\n            || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          // Modulo by zero yields NaN. This is valid JavaScript\n          // but we don't fold it because it is often unintentional. Return\n          // null to indicate that this operation cannot be folded.\n          // error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); // Removed error reporting\n          return null;\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          // Division by zero yields Infinity or NaN. This is valid JavaScript\n          // but we don't fold it because it is often unintentional. Return\n          // null to indicate that this operation cannot be folded.\n          // error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); // Removed error reporting\n          return null;\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // Check if the result is NaN or +/-Infinity. These results are only\n    // foldable if the original expression consisted of constants, because\n    // these results are non-numeric. These are handled later.\n\n    // Do not try to fold arithmetic for numbers > 2^53 or numbers that\n    // Increase code size. After that point, fixed-point math starts to break\n    // down and become inaccurate.\n    if (!(Math.abs(result) <= MAX_FOLD_NUMBER &&\n          String.valueOf(result).length() <=\n             String.valueOf(lval).length() + String.valueOf(rval).length() + 1)) {\n       // Check for NaN and Infinity. These need to be handled specially.\n       if (Double.isNaN(result)) {\n         return Node.newString(Token.NAME, \"NaN\");\n       } else if (result == Double.POSITIVE_INFINITY) {\n         return Node.newString(Token.NAME, \"Infinity\");\n       } else if (result == Double.NEGATIVE_INFINITY) {\n         return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n       } else {\n         // Otherwise, don't fold it.\n         return null;\n       }\n    }\n\n    Node newNumber = Node.newNumber(result);\n    return newNumber;\n  }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": true
}