{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // Major check: need to ensure we are handling possibly filters passed through context\n        // Also: if distribution disabled, need to stop processing.\n        if (!_allowMultipleMatches && _matchFound) {\n            // If previously matched, and multiple matches not allowed, just return null\n            return (_currToken = null);\n        }\n\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        _currToken = t;\n                        return t;\n                    }\n                    // If not in array (and not root), must be object, FIELD_NAME should be current\n                    // token, so need to skip that name\n                    // 13-Dec-2015, tatu: Does this ever happen? Seems like it shouldn't\n                    /*\n                    JsonToken t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            // Except: must clear context object filter states? For now, nope\n            /*\n            if (_headContext != null) {\n                _headContext.ensureNotStuck();\n            }\n            */\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY: // START_ARRAY == 3\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                if (!_allowMultipleMatches) { _matchFound = true; }\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                if (!_allowMultipleMatches) { _matchFound = true; }\n                return (_currToken = t);\n            }\n            // Still need to create context, may need filtering paths\n            _headContext = _headContext.createChildArrayContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    // Also needs to be considered a match right away if Path is included\n                    if (!_allowMultipleMatches) { _matchFound = true; }\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // If it wasn't returned, need to proceed to find the first included token\n            break;\n\n        case ID_START_OBJECT: // START_OBJECT == 1\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                if (!_allowMultipleMatches) { _matchFound = true; }\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                if (!_allowMultipleMatches) { _matchFound = true; }\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    // Also needs to be considered a match right away if Path is included\n                    if (!_allowMultipleMatches) { _matchFound = true; }\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via FIELD_NAME\n            break;\n\n        case ID_END_ARRAY: // END_ARRAY == 4\n        case ID_END_OBJECT: // END_OBJECT == 2\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    // We don't normally call filter methods ProcessingContext has ended;\n                    // but for now let's assume this is ok\n                    // 17-Jan-2017, tatu: Filter completion method was missing for arrays it seems?\n                    if (t == JsonToken.END_ARRAY) {\n                        f.filterFinishArray();\n                    } else {\n                        // Filter does not know about FIELD_NAMEs, needs to know it is finishing Object\n                        // TODO: Verify what needs to be called here, potentially `filterFinishObject`\n                        //   which does not exist. Or, perhaps, nothing?\n//                        f.filterFinishObject();\n                    }\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    // This is not a new match, just the end of a previously started structure\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME: // FIELD_NAME == 5\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) { // Field name criteria matched (e.g. PathPropertyFilter)\n                    _itemFilter = f;\n                    // If path is included, it means FIELD_NAME is needed as well\n                    // Also: may need to start buffering START_OBJECT too\n                    if (!_includePath && _includeImmediateParent && !_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                        // Do not set match found yet, FIELD_NAME is the trigger, not START_OBJECT\n                         _currToken = t;\n                         return t; // return START_OBJECT\n                    }\n                    // Ok: FIELD_NAME is included, and potentially its value(s?)\n                    if (!_allowMultipleMatches) { _matchFound = true; }\n                    return (_currToken = t);\n                }\n                if (f == null) { // Filter indicated FIELD_NAME and value are to be skipped\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                // Filter needs to check the value associated with FIELD_NAME\n                f = f.includeProperty(name);\n                if (f == null) { // Filter indicated value is to be skipped\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f; // Filter to apply to the value\n                if (f == TokenFilter.INCLUDE_ALL) { // Value is to be included\n                    if (_includePath) { // If path included, return FIELD_NAME now\n                        if (!_allowMultipleMatches) { _matchFound = true; }\n                        return (_currToken = t);\n                    }\n                    // If path not included, FIELD_NAME is skipped.\n                    // We need to check if START_OBJECT needs buffering/output first\n                     if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                         t = _headContext.nextTokenToRead(); // returns START_OBJECT\n                         _exposedContext = _headContext;\n                         _currToken = t;\n                          // Do not set match found yet, value token will trigger it\n                          return t; // Return START_OBJECT\n                      }\n                    // Otherwise, proceed to read the value token in the next iteration (_nextToken2)\n                } else { // A specific filter `f` applies to the value\n                    if (_includePath) { // If path included, buffer and possibly return FIELD_NAME\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            // Got FIELD_NAME via buffering: considered match indicating path inclusion\n                            if (!_allowMultipleMatches) { _matchFound = true; }\n                             _currToken = t;\n                            return t;\n                        }\n                    }\n                    // If path not included or buffering didn't yield FIELD_NAME,\n                    // proceed to read value token, filter `f` is active.\n                }\n                // We get here if FIELD_NAME is not returned; indicates need to fetch value token next\n                // which will be handled by the default processing loop\n                break;\n            }\n\n        default: // scalar value token\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) { // Value included due to filter context\n                 if (!_allowMultipleMatches) { _matchFound = true; }\n                return (_currToken = t);\n            }\n            if (f != null) { // Must check specific filter\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL) // checkValue might return INCLUDE_ALL\n                        || ((f != null) && f.includeValue(delegate))) { // Filter includes this value\n                     if (!_allowMultipleMatches) { _matchFound = true; }\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise value not included\n            break;\n        }\n\n        // We get here if token was not yet found; delegate to recursive call\n        // which heads to the top of the loop or reads more tokens via delegate\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}