{
    "generation": "    // NOTE: Requires adding the field to the class:\n    // protected boolean _matchFound = false;\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        // Minor tweak: reset _currToken? Or is it fine? Let's trust original logic.\n                        // Also: note that we may have returned START_ARRAY previously...\n                        _currToken = t;\n                        return t;\n                    }\n                    // [JACKSON-1 Filtering]: Was missing check for Object context? Added in 2.10\n                    if (ctxt.inObject()) {\n                         t = delegate.getCurrentToken();\n                         // We likely just returned FIELD_NAME, delegate is pointing at it.\n                         // Let's see if original code had anything here... it didn't.\n                         // Rely on delegate.nextToken() advancing past value.\n                    }\n                    break; // Break while loop\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more.\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // End of input\n            // Need to check if possibly END_OBJECT/ARRAY needs to be returned?\n            // Context should be root context, still active?\n            /*\n            if (_headContext != null && !_headContext.isRoot()) {\n                // Error? Or auto-close? Let's assume caller handles it?\n            }\n            */\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                // Check multiple matches constraint\n                if (!_allowMultipleMatches || !_matchFound) {\n                    _matchFound = true; // Mark first match found (or multiple allowed)\n                    return (_currToken = t);\n                }\n                // Skip - already matched, multiple not allowed\n                delegate.skipChildren(); // Skip the array content from delegate\n                // Do not return START_ARRAY, proceed to find next token after array\n                break; // Break switch, will go to _nextToken2() to find next token\n            }\n            if (f == null) { // skip\n                delegate.skipChildren();\n                break;\n            }\n            // Check filter with context\n            f = _headContext.checkValue(f);\n            if (f == null) { // skip\n                delegate.skipChildren();\n                break;\n            }\n            // Apply array filtering if needed\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f; // Item filter for elements\n            if (f == TokenFilter.INCLUDE_ALL) { // Filter chain resulted in INCLUDE_ALL\n                _headContext = _headContext.createChildArrayContext(f, true);\n                // Check multiple matches constraint\n                if (!_allowMultipleMatches || !_matchFound) {\n                    _matchFound = true; // Mark match found\n                    return (_currToken = t);\n                }\n                // Skip\n                delegate.skipChildren();\n                break;\n            }\n             // Filter resulted in specific filter, create context\n             _headContext = _headContext.createChildArrayContext(f, false);\n            // Buffering only needed if path included (usually for START_OBJECT)\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    // NOTE: Buffering logic might need _matchFound updates too\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // Proceed to find first element via _nextToken2()\n            break;\n\n        case ID_START_OBJECT:\n             f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                 // Check multiple matches constraint\n                if (!_allowMultipleMatches || !_matchFound) {\n                    _matchFound = true;\n                    return (_currToken = t);\n                }\n                // Skip\n                delegate.skipChildren();\n                break;\n            }\n            if (f == null) { // skip\n                delegate.skipChildren();\n                break;\n            }\n            f = _headContext.checkValue(f);\n            if (f == null) { // skip\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                // Check multiple matches constraint\n                if (!_allowMultipleMatches || !_matchFound) {\n                    _matchFound = true;\n                    return (_currToken = t);\n                }\n                // Skip\n                delegate.skipChildren();\n                break;\n            }\n             _headContext = _headContext.createChildObjectContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    // NOTE: Buffering logic might need _matchFound updates too\n                    _currToken = t;\n                    return t;\n                }\n            }\n             // Proceed to find first field via _nextToken2()\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                     if (t == JsonToken.END_ARRAY) { f.filterFinishArray(); } else { f.filterFinishObject(); }\n                }\n                _headContext = _headContext.getParent();\n                // Reset item filter based on the new parent context\n                _itemFilter = (_headContext == null) ? null : _headContext.getFilter();\n                if (returnEnd) {\n                    // Return END token only if START was handled\n                    // Do not check _matchFound here, END does not constitute a value match\n                    return (_currToken = t);\n                }\n                // If corresponding START was skipped, skip END as well.\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // Ask head context for filter appropriate for this field's value\n                TokenFilter valueFilter = _headContext.setFieldName(name);\n\n                // Property itself excluded?\n                if (valueFilter == null) {\n                    delegate.nextToken(); // consume field name from delegate\n                    delegate.skipChildren(); // skip value\n                    break;\n                }\n                // Property included fully?\n                if (valueFilter == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = valueFilter; // Value is included\n                    // Check multiple matches constraint before potentially returning FIELD_NAME or START_OBJECT\n                    if (!_allowMultipleMatches || !_matchFound) {\n                        // OK to proceed (first match or multiple allowed)\n                        if (_includePath) {\n                            _matchFound = true; // Mark match found as FIELD_NAME is returned\n                            return (_currToken = t);\n                        }\n                        // If !_includePath, FIELD_NAME not returned, but maybe START_OBJECT needs to be?\n                         if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                             // Expose START_OBJECT of parent, do not mark match yet.\n                             // Let _matchFound be set when value token(s) are returned.\n                            t = _headContext.nextTokenToRead();\n                            _exposedContext = _headContext;\n                             if (t != null) { // Should be START_OBJECT\n                                 _currToken = t;\n                                 return t;\n                              }\n                         }\n                         // If neither of above, just break. Value will be handled by next call.\n                         // _matchFound is NOT set here yet; value will trigger it.\n                    } else {\n                        // Skip property - already matched, multiple not allowed\n                        delegate.nextToken(); // Consume value node\n                        delegate.skipChildren(); // Skip children\n                    }\n                    // Break whether we returned, skipped or are just proceeding to value\n                    break;\n                }\n\n                // Property included with a specific filter\n                _itemFilter = valueFilter;\n\n                if (_includePath) {\n                     // Check multiple matches constraint before potentially returning/buffering\n                     if (!_allowMultipleMatches || !_matchFound) {\n                         // OK to proceed\n                         _matchFound = true; // Mark match found as FIELD_NAME/START is returned/buffered\n                         t = _nextTokenWithBuffering(_headContext);\n                         if (t != null) {\n                             _currToken = t;\n                             return t;\n                         }\n                         // If buffering didn't yield token, break. Value handled next.\n                     } else {\n                         // Skip property - already matched, multiple not allowed\n                         delegate.nextToken();\n                         delegate.skipChildren();\n                         // Break switch to proceed scan after skipped value\n                     }\n                }\n                // If !_includePath, or match skipped, break. Value handled next (_itemFilter is set).\n                // _matchFound only set above if _includePath was true and match was allowed.\n                break;\n            }\n\n        default: // scalar value (VALUE_STRING, VALUE_NUMBER_INT, etc.)\n            f = _itemFilter;\n            if (f == null) { break; } // Skip if item filter is null\n\n            // Check filter in context (for array index etc)\n            TokenFilter fctxt = _headContext.checkValue(f);\n            if (fctxt == null) { break; } // Skip if context check yields null\n\n            // Include if context check yields INCLUDE_ALL or specific filter includes the value\n            if (fctxt == TokenFilter.INCLUDE_ALL || fctxt.includeValue(delegate)) {\n                // Value is included. Check multiple matches constraint.\n                if (!_allowMultipleMatches || !_matchFound) {\n                    // OK to return (first match or multiple allowed)\n                    _matchFound = true; // Mark match found\n                    return (_currToken = t);\n                }\n                // else: Skip value - already matched, multiple not allowed\n            }\n            // If not included, or skipped, break to continue scan.\n            break;\n        }\n\n        // We get here if token was filtered out, skipped, or requires further context (buffering empty)\n        // Need ensure state (like _itemFilter, _headContext) is correct for the next call.\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}