{
    "generation": "    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First, check if we have buffered tokens:\n        TokenFilterContext ctxt = _exposedContext;\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    // If context is now null, break to potentially check allowMultipleMatches\n                    // or read next token normally.\n                    // We must NOT check delegate's current token, as it may be anything\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // Added check for allowMultipleMatches: if disabled and match found, stop.\n        // Must be done after exhausting buffer, before fetching next token.\n        if (!_allowMultipleMatches && _matchCount > 0) {\n             // Simple check: if we already had a match, and are not allowing multiple,\n             // we are done.\n             return (_currToken = null);\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            return (_currToken = t);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                if (_includePath) {\n                    _matchCount++;\n                }\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                if (_includePath) {\n                    _matchCount++;\n                }\n                return (_currToken = t);\n            }\n            // If filter is not INCLUDE_ALL, array needs filtering\n            _headContext = _headContext.createChildArrayContext(f, false);\n\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    // If buffering returns a token, assume it's a match handled within?\n                    // Or should match count be incremented here? Let's assume _nextTokenWithBuffering handles it.\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // If !_includePath, or buffering yielded nothing yet, START_ARRAY is not returned;\n            // need to proceed to find first element etc.\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                 if (_includePath) {\n                    _matchCount++;\n                }\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                 if (_includePath) {\n                    _matchCount++;\n                }\n                return (_currToken = t);\n            }\n            // If filter is not INCLUDE_ALL, object needs filtering\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    // Assume _nextTokenWithBuffering handles match count\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // If !_includePath, or buffering yielded nothing yet, START_OBJECT is not returned;\n            // need to proceed to find first field etc.\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray(); // Or object\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                // Only return END token if START was returned\n                if (returnEnd) {\n                    // Does END token count towards match? Assume no.\n                    return (_currToken = t);\n                }\n            }\n            // If START not handled, END is implicitly skipped, find next token\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) { // Field name itself matches filter context\n                    _itemFilter = f;\n                    if (_includePath) {\n                        _matchCount++; // Count match if path included\n                        return (_currToken = t);\n                    }\n                    // If !_includePath: FIELD_NAME is not returned, but its value might be.\n                    // Check for START_OBJECT injection if needed for non-path-included parent.\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                       t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                       _exposedContext = _headContext;\n                       // Does START_OBJECT count as a match? Assume not if !_includePath.\n                       return (_currToken = t); // Return START_OBJECT injected token\n                    }\n                    // If no injection, just proceed to fetch the value. Match count handled by value.\n                    break; // Break switch, loop via _nextToken2() to fetch value\n                }\n                if (f == null) { // Property excluded entirely\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break; // Break switch, loop via _nextToken2()\n                }\n                // Field name didn't match context, but check property filter\n                f = f.includeProperty(name);\n                if (f == null) { // Property value excluded by filter\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break; // Break switch, loop via _nextToken2()\n                }\n                // Property value *might* be included. Set item filter for value.\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) { // Value filter is INCLUDE_ALL (match definite)\n                    if (_includePath) {\n                        // Return FIELD_NAME now as part of the match path\n                        _matchCount++; // Count match\n                        return (_currToken = t);\n                    }\n                    // If !_includePath: FIELD_NAME not returned, proceed to value. Match count handled by value.\n                }\n                // If value filter is specific (f != INCLUDE_ALL), or if !_includePath:\n                if (_includePath) {\n                    // Need buffering to filter value, FIELD_NAME might be returned first by buffering logic\n                    // _nextTokenWithBuffering should handle match count internally for buffered tokens.\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                    // If buffering doesn't yield token now, fall through to fetch value normally?\n                    // This seems complex. Let's assume for now that if _includePath is true\n                    // and filter is specific, the FIELD_NAME itself isn't the \"match\" token yet.\n                }\n                // If !_includePath, or if value filter is specific:\n                // Proceed to fetch the value token. The value handler below will check _itemFilter.\n                 break; // Break switch, loop via _nextToken2() to fetch value\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) { // Value context (field or array element) was INCLUDE_ALL\n                _matchCount++; // Scalar value is the match result\n                return (_currToken = t);\n            }\n            if (f != null) { // Specific filter for item/field\n                f = _headContext.checkValue(f); // Check filter in current context (array/object value)\n                if ((f == TokenFilter.INCLUDE_ALL) // CheckValue filter becomes generic include\n                        || ((f != null) && f.includeValue(delegate))) { // Or specific filter includes value\n                    _matchCount++; // Scalar value is the match result\n                    return (_currToken = t);\n                }\n            }\n            // Otherwise scalar value not included\n            break; // Break switch, loop via _nextToken2()\n        } // switch\n\n        // We get here if token was filtered out / skipped, or requires further processing\n        // like reading value after field name. Tail recursion (implemented as loop):\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}