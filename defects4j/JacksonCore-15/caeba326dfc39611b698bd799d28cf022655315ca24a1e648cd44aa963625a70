{
    "generation": "    // Add this field to the class FilteringParserDelegate:\n    protected boolean _matchFound = false;\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // I. Handle any buffered tokens first\n        TokenFilterContext ctxt = _exposedContext;\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t; // Return buffered token, don't change state here\n                }\n                // If buffer ended for this context, try moving up\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    // Need to check delegate's current token? Original code had this for arrays.\n                    // This part seems potentially fragile, but let's keep original logic.\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        // Maybe JsonToken.END_ARRAY? Let's trust original.\n                        _currToken = t;\n                        return t;\n                    }\n                    // Original code also had a commented out check for FIELD_NAME.\n                    // Let's assume breaking out handles object end correctly.\n                    break; // Buffer drained for this level\n                }\n                // Eager-pop context? Seems required for nested buffered matches.\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // Should not happen\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // II. Check if filtering is already complete\n        // (if multiple matches disallowed, and we already found one)\n        if (!_allowMultipleMatches && _matchFound) {\n            // No more tokens to be filtered, buffer is empty\n            return null;\n        }\n\n        // III. No buffered tokens, need to read from delegate\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // End-of-input\n            _currToken = t;\n            return t;\n        }\n\n        // IV. Apply filter logic\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                // Included because parent is included. Propagate inclusion.\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // Excluded by parent filter. Skip.\n                delegate.skipChildren();\n                break; // Continue filtering via _nextToken2\n            }\n            // Parent filter active, check value itself.\n            f = _headContext.checkValue(f);\n            if (f == null) { // Excluded by value check (index etc)\n                delegate.skipChildren();\n                break; // Continue filtering via _nextToken2\n            }\n            // Filter wants to check contents. Apply specific filter method.\n            if (f != TokenFilter.INCLUDE_ALL) {\n                // Let filter decide if array itself is included\n                f = f.filterStartArray();\n            }\n            _itemFilter = f; // Filter for elements\n\n            if (f == TokenFilter.INCLUDE_ALL) {\n                // Array included by filter rule. This is a match.\n                _headContext = _headContext.createChildArrayContext(f, true);\n                if (!_allowMultipleMatches) {\n                     _matchFound = true; // Mark match found\n                }\n                return (_currToken = t);\n            }\n            if (f == null) { // Filter excluded array starting from here.\n                delegate.skipChildren();\n                break; // Continue filtering via _nextToken2\n            }\n            // Filter is specific, create context but don't fully include yet.\n            _headContext = _headContext.createChildArrayContext(f, false);\n            // Need buffering if path included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t; // Return buffered START_ARRAY\n                }\n                // If buffering yielded null, _nextToken2 will handle subsequent tokens\n            }\n            // If no buffering or buffer empty now, let _nextToken2 handle content\n            break;\n\n        case ID_START_OBJECT:\n            // Symmetric logic to START_ARRAY\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                 f = f.filterStartObject(); // Let filter decide if object itself is included\n            }\n            _itemFilter = f; // Filter for properties\n\n            if (f == TokenFilter.INCLUDE_ALL) {\n                // Object included by filter rule. This is a match.\n                _headContext = _headContext.createChildObjectContext(f, true);\n                if (!_allowMultipleMatches) {\n                    _matchFound = true; // Mark match found\n                }\n                return (_currToken = t);\n            }\n            if (f == null) { // Filter excluded object starting from here.\n                delegate.skipChildren();\n                break;\n            }\n            // Filter is specific, create context.\n            _headContext = _headContext.createChildObjectContext(f, false);\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t; // Return buffered START_OBJECT\n                }\n            }\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                     // Call finish method based on context type\n                     if (_headContext.inArray()) {\n                         f.filterFinishArray();\n                     } else if (_headContext.inObject()) { // More robust check\n                         f.filterFinishObject();\n                     }\n                }\n                _headContext = _headContext.getParent();\n                // Update filter based on parent context; use _rootFilter if back at top level\n                _itemFilter = (_headContext == null) ? _rootFilter : _headContext.getFilter();\n                if (returnEnd) {\n                    // Return END token; does not affect match status.\n                    return (_currToken = t);\n                }\n                // If START was skipped, END is also skipped.\n            }\n            break; // Continue filtering via _nextToken2\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // Determine filter for the value pointed to by this field\n                TokenFilter valueFilter = _headContext.setFieldName(name);\n                _itemFilter = valueFilter; // Update item filter for subsequent value\n\n                if (valueFilter == null) { // Value is definitely excluded\n                    delegate.nextToken(); // Consume value token(s) from delegate\n                    delegate.skipChildren();\n                    break; // Continue filtering via _nextToken2\n                }\n\n                // Value might be included (filter is INCLUDE_ALL or specific filter)\n                if (valueFilter == TokenFilter.INCLUDE_ALL) {\n                    if (_includePath) {\n                        // Path included, return FIELD_NAME token\n                        return (_currToken = t); // Not a core match trigger itself\n                    }\n                    // Path not included, do not return FIELD_NAME token.\n                    // Handle optional immediate parent buffering.\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        // This requires buffering START_OBJECT first\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t; // Return START_OBJECT\n                        }\n                        // If buffering yields null, fall through to _nextToken2\n                    }\n                    // Otherwise just continue; value token will be handled by next call or _nextToken2\n                    break;\n                }\n                // Value has a specific filter.\n                if (_includePath) {\n                    // Path included, value has specific filter => need buffering.\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t; // Return buffered FIELD_NAME (or START_OBJECT)\n                    }\n                    // If buffering yields null, fall through to _nextToken2\n                }\n                // Path not included, do not return FIELD_NAME token.\n                // Value token will be handled by next call or _nextToken2\n                break;\n            }\n\n        default: // Scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                // Included due to parent context/filter. This is a match.\n                if (!_allowMultipleMatches) {\n                    _matchFound = true; // Mark match found\n                }\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f); // Apply context check first\n                // Check if filter includes the scalar value\n                if ((f == TokenFilter.INCLUDE_ALL) // checkValue might return INCLUDE_ALL\n                        || ((f != null) && f.includeValue(delegate)))\n                {\n                     // Included by specific filter rule. This is a match.\n                     if (!_allowMultipleMatches) {\n                         _matchFound = true; // Mark match found\n                     }\n                    return (_currToken = t);\n                }\n                // Excluded by filter\n            }\n            // Value excluded (f=null initially, or filter rejected it)\n            break; // Continue filtering via _nextToken2\n        } // End switch\n\n        // V. If break was hit, delegate to _nextToken2 to skip or find next token\n        // _nextToken2 presumably starts its loop again, eventually calling nextToken()\n        // on the delegate, and the check II at the top of this method will catch\n        // the _matchFound state if applicable.\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}