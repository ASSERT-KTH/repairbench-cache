{
    "generation": "    /**\n     * State that tracks whether the first match has been found and returned,\n     * used when {@link #_allowMultipleMatches} is false.\n     * \n     * @since 2.9\n     */\n    protected boolean _matchFound; // Added field\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // I. Handle locally buffered tokens\n        TokenFilterContext ctxt = _exposedContext;\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                     // If we are consuming buffered tokens, the decision to include\n                     // (and potentially set _matchFound) was already made.\n                     return (_currToken = t);\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    // If we just finished the buffered context for the first match, we are done.\n                    if (!_allowMultipleMatches && _matchFound) {\n                         // If we don't allow multiple matches and have found the first one,\n                         // and finished processing its buffered context, then terminate.\n                         return (_currToken = null);\n                    }\n                    // Or, if it was the end of an array, return delegate's current token\n                    // (which should be END_ARRAY)\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n                        // Does END_ARRAY need _matchFound check? Seems unlikely as it closes a structure\n                        // that would have started the match.\n                        return (_currToken = t);\n                    }\n                    // If it was Object end, fall through to read next token from delegate\n                    break; // Break from buffer handling loop\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // II. Check if we already found the match and should not allow multiple\n        // (Also, make sure we are not still handling buffered context from that match)\n        if (!_allowMultipleMatches && _matchFound && _exposedContext == null) {\n             // If !allowMultipleMatches, and we have found the first match (_matchFound=true),\n             // and we are not currently processing its buffered tokens (_exposedContext=null),\n             // then we are done.\n             return (_currToken = null);\n        }\n\n        // III. Ok, need to fetch the next token...\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // End-of-input is fine, return null\n            return (_currToken = t);\n        }\n\n        // IV. Does it pass the filter?\n        TokenFilter f;\n\n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) { // Included unconditionally by parent filter\n                _headContext = _headContext.createChildArrayContext(f, true);\n                 _currToken = t; // Set current token before potential flag update\n                 if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark as first match found\n                 return t;\n            }\n            if (f == null) { // Filter indicates skip\n                delegate.skipChildren();\n                break; // Continue via _nextToken2\n            }\n            // Filter needs to be checked against the array itself\n            f = _headContext.checkValue(f);\n            if (f == null) { // Filter excluded this array value\n                delegate.skipChildren();\n                break; // Continue via _nextToken2\n            }\n            // Check specific filter for arrays\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            if (f == null) { // Array specifically filtered out\n                delegate.skipChildren();\n                break; // Continue via _nextToken2\n            }\n            // Ok, array included by the filter:\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                 _currToken = t;\n                 if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                 return t;\n            }\n            // Non-INCLUDE_ALL filter means we need context, maybe buffering\n            _headContext = _headContext.createChildArrayContext(f, false);\n            if (_includePath) {\n                // Call buffering which may return START_ARRAY or first element\n                JsonToken bufferedToken = _nextTokenWithBuffering(_headContext);\n                if (bufferedToken != null) {\n                     _currToken = bufferedToken;\n                     if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                     return bufferedToken;\n                }\n            }\n            // If no buffering or buffer empty, filter logic continues via _nextToken2\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) { // Included unconditionally by parent filter\n                _headContext = _headContext.createChildObjectContext(f, true);\n                 _currToken = t;\n                 if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                 return t;\n            }\n            if (f == null) { // Filter indicates skip\n                delegate.skipChildren();\n                break; // Continue via _nextToken2\n            }\n            // Filter needs to be checked against the object itself\n            f = _headContext.checkValue(f);\n            if (f == null) { // Filter excluded this object value\n                delegate.skipChildren();\n                break; // Continue via _nextToken2\n            }\n            // Check specific filter for objects\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            if (f == null) { // Object specifically filtered out\n                delegate.skipChildren();\n                break; // Continue via _nextToken2\n            }\n            // Ok, object included by the filter:\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                 _currToken = t;\n                 if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                 return t;\n            }\n            // Non-INCLUDE_ALL filter means we need context, maybe buffering\n            _headContext = _headContext.createChildObjectContext(f, false);\n            if (_includePath) {\n                // Call buffering which may return START_OBJECT or first element\n                JsonToken bufferedToken = _nextTokenWithBuffering(_headContext);\n                if (bufferedToken != null) {\n                     _currToken = bufferedToken;\n                     if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                     return bufferedToken;\n                }\n            }\n            // If no buffering or buffer empty, filter logic continues via _nextToken2\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                     // Let filter know structure ended (might have state to clean up)\n                     // Bug fix: Call appropriate filter finish method\n                     if (t == JsonToken.END_ARRAY) {\n                         f.filterFinishArray();\n                     } else {\n                        f.filterFinishObject();\n                     }\n                }\n                _headContext = _headContext.getParent();\n                // Update item filter based on the parent context's filter\n                if (_headContext != null) {\n                    _itemFilter = _headContext.getFilter();\n                }\n                 if (returnEnd) {\n                    // If the start was handled (returned), we must return the end token.\n                    // End markers don't \"start\" a match, so don't set _matchFound here.\n                     return (_currToken = t);\n                }\n            }\n            // If start was not handled, END marker is implicitly skipped. Continue via _nextToken2.\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // Ask context for filter to apply to the field's value\n                TokenFilter valueFilter = _headContext.setFieldName(name);\n                if (valueFilter == TokenFilter.INCLUDE_ALL) { // Field name forces inclusion of value\n                    _itemFilter = valueFilter; // Set filter for value processing\n                    if (_includePath) {\n                         // Return FIELD_NAME token itself if path included\n                         _currToken = t;\n                         if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                         return t;\n                    }\n                    // If not including path, but need parent structure, expose START_OBJECT\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        JsonToken ownerToken = _headContext.nextTokenToRead(); // This returns START_OBJECT\n                        _exposedContext = _headContext; // Mark context as buffering\n                         _currToken = ownerToken;\n                         if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                         return ownerToken;\n                    }\n                    // Field name matched, path/parent not included -> don't return FIELD_NAME itself.\n                    // Proceed to process the value via _nextToken2(). Match found flag will be set by value.\n                    break;\n                }\n                if (valueFilter == null) { // Field name excluded, skip value too\n                    delegate.nextToken(); // Consume FIELD_NAME\n                    delegate.skipChildren(); // Skip value tokens\n                    break; // Continue via _nextToken2\n                }\n\n                // Field name not INCLUDE_ALL, value needs filtering. Check property inclusion filter.\n                TokenFilter propertyFilter = valueFilter.includeProperty(name);\n                if (propertyFilter == null) { // Property specifically excluded\n                    delegate.nextToken(); // Consume FIELD_NAME\n                    delegate.skipChildren(); // Skip value tokens\n                    break; // Continue via _nextToken2\n                }\n                // Property potentially included. Use this filter for the value.\n                _itemFilter = propertyFilter;\n\n                if (propertyFilter == TokenFilter.INCLUDE_ALL) { // Property included fully\n                    if (_includePath) {\n                         // Return FIELD_NAME token itself\n                         _currToken = t;\n                         if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                         return t;\n                    }\n                    // If not including path, but need parent structure, expose START_OBJECT\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        JsonToken ownerToken = _headContext.nextTokenToRead();\n                        _exposedContext = _headContext;\n                         _currToken = ownerToken;\n                         if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                         return ownerToken;\n                    }\n                    // Property included, but FIELD_NAME not returned -> proceed to value via _nextToken2().\n                    // Match found flag will be set by value token if needed.\n                    break;\n                }\n                // Filter is not INCLUDE_ALL. If including path, need buffering.\n                if (_includePath) {\n                    // Buffering logic will decide if FIELD_NAME or subsequent tokens are returned.\n                    JsonToken bufferedToken = _nextTokenWithBuffering(_headContext);\n                    if (bufferedToken != null) {\n                         _currToken = bufferedToken;\n                         if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                         return bufferedToken;\n                    }\n                }\n                // If not including path, or buffering didn't yield token,\n                // continue loop via _nextToken2() to process value with the propertyFilter.\n                break;\n            }\n\n        default: // scalar value (string, number, boolean, null)\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) { // Included due to parent context (Object field or Array element)\n                 _currToken = t;\n                 if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                 return t;\n            }\n            if (f != null) {\n                // Check filter against the scalar value itself\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL) // Filter says include unconditionally\n                        || ((f != null) && f.includeValue(delegate))) { // Filter includes this specific value\n                     _currToken = t;\n                     if (!_allowMultipleMatches && !_matchFound) { _matchFound = true; } // Mark first match\n                     return t;\n                }\n            }\n            // Otherwise scalar value is not included\n            break; // Continue via _nextToken2\n        }\n\n        // V. If we get this far, token was filtered out, or we need to process the value\n        //    associated with a FIELD_NAME. Need to fetch next token via recursive call\n        //    (offlined to _nextToken2() to prevent stack overflow).\n        return _nextToken2();\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": true,
    "test": false
}