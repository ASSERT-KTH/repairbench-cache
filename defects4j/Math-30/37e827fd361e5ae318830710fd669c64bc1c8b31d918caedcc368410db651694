{
    "generation": "import org.apache.commons.math3.distribution.NormalDistribution;\nimport org.apache.commons.math3.exception.ConvergenceException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.util.FastMath;\n\n// Note: Imports are usually handled outside the function, but included here for clarity.\n\n    /**\n     * Calculates the asymptotic p-value for the Mann-Whitney U test using the normal approximation.\n     * This method applies a continuity correction.\n     *\n     * @param Umin smallest Mann-Whitney U value (U = min(U1, U2))\n     * @param n1 number of subjects in first sample\n     * @param n2 number of subjects in second sample\n     * @return two-sided asymptotic p-value\n     * @throws ConvergenceException if the p-value can not be computed\n     * due to a convergence error in the normal distribution function.\n     * @throws MaxCountExceededException if the maximum number of\n     * iterations is exceeded in the normal distribution function.\n     */\n    private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        // Use double for intermediate product computations to avoid integer overflow\n        // which occurred in the original code for the VarU calculation with large n1, n2.\n        final double n1d = n1;\n        final double n2d = n2;\n        final double n1n2prod = n1d * n2d;\n\n        // Mean of U distribution: EU = n1 * n2 / 2\n        final double EU = n1n2prod / 2.0;\n\n        // Variance of U distribution: VarU = n1 * n2 * (n1 + n2 + 1) / 12\n        // Calculate VarU using double arithmetic to avoid potential integer overflow.\n        final double VarU = n1n2prod * (n1d + n2d + 1.0) / 12.0;\n\n        // Calculate the z-score using continuity correction.\n        // The correction involves adjusting the statistic (|Umin - EU|) towards 0 by 0.5.\n        // Since Umin <= EU, this means the numerator is Umin - EU + 0.5.\n        // z = (Umin - EU + 0.5) / sqrt(VarU)\n        final double sqrtVarU = FastMath.sqrt(VarU);\n\n        // Handle cases where variance might be zero or negative (e.g., due to tie correction or invalid input).\n        // If variance is zero, the z-score is undefined. Depending on the context,\n        // returning 1.0 (no difference) or throwing an error might be appropriate.\n        // Here, we let potential division by zero produce NaN/Infinity,\n        // assuming standard use cases have VarU > 0.\n        if (sqrtVarU == 0) {\n             // Consider the case Umin == EU. Z-score numerator is 0.5. If VarU is 0, z -> Inf.\n             // If Umin < EU, Z-score numerator is negative. If VarU is 0, z -> -Inf.\n             // P(Z <= +Inf) = 1.0. min(2*1, 1) = 1.\n             // P(Z <= -Inf) = 0.0. min(2*0, 1) = 0.\n             // Returning 1.0 seems reasonable if VarU=0 implies no variance/all equal ranks.\n             // However, sticking close to original behavior path unless clearly wrong.\n             // The NormalDistribution cumulativeProbability might handle Inf/-Inf appropriately.\n        }\n\n        final double z = (Umin - EU + 0.5) / sqrtVarU;\n\n        final NormalDistribution standardNormal = new NormalDistribution(null, 0, 1,\n                                                                         NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n\n        // Calculate the two-sided p-value: P-value = 2 * P(Z <= z)\n        // Use min(..., 1.0) to cap the p-value at 1.0. This is necessary because the continuity\n        // correction can cause 2 * P(Z <= z) to slightly exceed 1.0 when Umin is very close to EU.\n        // This approach mirrors the logic used in R's wilcox.test implementation.\n        return FastMath.min(2.0 * standardNormal.cumulativeProbability(z), 1.0);\n    }",
    "exact_match": false,
    "ast_match": false,
    "compile": false,
    "test": false
}